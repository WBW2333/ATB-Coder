[
    {
        "id": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, find the length of the **longest** **substring** without repeating characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcabcbb \"\n**Output:** 3\n**Explanation:** The answer is  \"abc \", with the length of 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"bbbbb \"\n**Output:** 1\n**Explanation:** The answer is  \"b \", with the length of 1.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"pwwkew \"\n**Output:** 3\n**Explanation:** The answer is  \"wke \", with the length of 3.\nNotice that the answer must be a substring,  \"pwke \" is a subsequence and not a substring."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of English letters, digits, symbols and spaces.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"abcabcbb\"",
                "output": "3"
            },
            {
                "input": "\"bbbbb\"",
                "output": "1"
            },
            {
                "input": "\"pwwkew\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "python": "\n    ```python\ndef length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLongestSubstring(s) {\n    let left = 0, right = 0, maxLength = 0;\n    const characters = new Set();\n\n    while (right < s.length) {\n        if (!characters.has(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.delete(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    "
    },
    {
        "id": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,3\\], nums2 = \\[2\\]\n**Output:** 2.00000\n**Explanation:** merged array = \\[1,2,3\\] and median is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[3,4\\]\n**Output:** 2.50000\n**Explanation:** merged array = \\[1,2,3,4\\] and median is (2 + 3) / 2 = 2.5."
            ],
            "constraints": "**Constraints:**\n\n*   `nums1.length == m`\n*   `nums2.length == n`\n*   `0 <= m <= 1000`\n*   `0 <= n <= 1000`\n*   `1 <= m + n <= 2000`\n*   `-106 <= nums1[i], nums2[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer"
        ],
        "example": [
            {
                "input": "[1,3],[2]",
                "output": "2.00000"
            },
            {
                "input": "[1,2],[3,4]",
                "output": "2.50000"
            }
        ],
        "java": "\n    ```java\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "python": "\n    ```python\ndef findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "c++": "\n    ```cpp\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "js": "\n    ```javascript\nfunction findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    "
    },
    {
        "id": 7,
        "title": "Reverse Integer",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 123\n**Output:** 321\n\n",
                "**Example 2:**\n\n**Input:** x = -123\n**Output:** -321\n\n",
                "**Example 3:**\n\n**Input:** x = 120\n**Output:** 21"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= x <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "123",
                "output": "321"
            },
            {
                "input": "-123",
                "output": "-321"
            },
            {
                "input": "120",
                "output": "21"
            }
        ],
        "java": "\n    ```java\npublic int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "python": "\n    ```python\ndef reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "c++": "\n    ```cpp\nint reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < INT_MIN || res > INT_MAX) ? 0 : res;\n}\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "js": "\n    ```javascript\nfunction reverse(x) {\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n}\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    "
    },
    {
        "id": 8,
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"42 \" ( \"42 \" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n            ^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n             ^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"42\"",
                "output": "42"
            },
            {
                "input": "\"-42\"",
                "output": "-42"
            },
            {
                "input": "\"4193withwords\"",
                "output": "4193"
            }
        ],
        "java": "\n    ```java\npublic int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "python": "\n    ```python\ndef myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "c++": "\n    ```cpp\nint myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "js": "\n    ```javascript\nfunction myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    "
    },
    {
        "id": 9,
        "title": "Palindrome Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 121\n**Output:** true\n**Explanation:** 121 reads as 121 from left to right and from right to left.\n\n",
                "**Example 2:**\n\n**Input:** x = -121\n**Output:** false\n**Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** x = 10\n**Output:** false\n**Explanation:** Reads 01 from right to left. Therefore it is not a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without converting the integer to a string?"
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "121",
                "output": "true"
            },
            {
                "input": "-121",
                "output": "false"
            },
            {
                "input": "10",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "python": "\n    ```python\ndef is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "c++": "\n    ```cpp\nbool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    "
    },
    {
        "id": 10,
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.​​​​\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"a\\* \"\n**Output:** true\n**Explanation:** '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"ab \", p =  \".\\* \"\n**Output:** true\n**Explanation:**  \".\\* \" means  \"zero or more (\\*) of any character (.) \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= p.length <= 20`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'.'`, and `'*'`.\n*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"aa\",\"a\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"a*\"",
                "output": "true"
            },
            {
                "input": "\"ab\",\".*\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "c++": "\n    ```cpp\nbool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "js": "\n    ```javascript\nfunction isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    "
    },
    {
        "id": 11,
        "title": "Container With Most Water",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = \\[1,8,6,2,5,4,8,3,7\\]\n**Output:** 49\n**Explanation:** The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49.\n\n",
                "**Example 2:**\n\n**Input:** height = \\[1,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,8,6,2,5,4,8,3,7]",
                "output": "49"
            },
            {
                "input": "[1,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "python": "\n    ```python\ndef max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "c++": "\n    ```cpp\nint maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "js": "\n    ```javascript\nfunction maxArea(height) {\n    let max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    "
    },
    {
        "id": 12,
        "title": "Integer to Roman",
        "difficulty": "Medium",
        "content": {
            "problem": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 3\n**Output:**  \"III \"\n**Explanation:** 3 is represented as 3 ones.\n\n",
                "**Example 2:**\n\n**Input:** num = 58\n**Output:**  \"LVIII \"\n**Explanation:** L = 50, V = 5, III = 3.\n\n",
                "**Example 3:**\n\n**Input:** num = 1994\n**Output:**  \"MCMXCIV \"\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 3999`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "3",
                "output": "\"III\""
            },
            {
                "input": "58",
                "output": "\"LVIII\""
            },
            {
                "input": "1994",
                "output": "\"MCMXCIV\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RomanNumerals {\n    public static String intToRoman(int num) {\n        List<Pair> romans = Arrays.asList(\n            new Pair(1000, \"M\"), new Pair(900, \"CM\"), new Pair(500, \"D\"), \n            new Pair(400, \"CD\"), new Pair(100, \"C\"), new Pair(90, \"XC\"),\n            new Pair(50, \"L\"), new Pair(40, \"XL\"), new Pair(10, \"X\"), \n            new Pair(9, \"IX\"), new Pair(5, \"V\"), new Pair(4, \"IV\"),\n            new Pair(1, \"I\")\n        );\n        StringBuilder roman = new StringBuilder();\n        for (Pair p : romans) {\n            while (num >= p.num) {\n                roman.append(p.symbol);\n                num -= p.num;\n            }\n        }\n        return roman.toString();\n    }\n    \n    private static class Pair {\n        final int num;\n        final String symbol;\n        \n        Pair(int num, String symbol) {\n            this.num = num;\n            this.symbol = symbol;\n        }\n    }\n}\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "python": "\n    ```python\ndef int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    std::vector<std::pair<int, std::string>> romans = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}\n    };\n    std::string roman = \"\";\n    for (const auto& p : romans) {\n        while (num >= p.first) {\n            roman += p.second;\n            num -= p.first;\n        }\n    }\n    return roman;\n}\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "js": "\n    ```javascript\nfunction intToRoman(num) {\n    const romans = [\n        [1000, \"M\"], [900, \"CM\"], [500, \"D\"],\n        [400, \"CD\"], [100, \"C\"], [90, \"XC\"],\n        [50, \"L\"], [40, \"XL\"], [10, \"X\"], \n        [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]\n    ];\n    let roman = \"\";\n    for (const [value, symbol] of romans) {\n        while (num >= value) {\n            roman += symbol;\n            num -= value;\n        }\n    }\n    return roman;\n}\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    "
    },
    {
        "id": 13,
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"III \"\n**Output:** 3\n**Explanation:** III = 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"LVIII \"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"MCMXCIV \"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"III\"",
                "output": "3"
            },
            {
                "input": "\"LVIII\"",
                "output": "58"
            },
            {
                "input": "\"MCMXCIV\"",
                "output": "1994"
            }
        ],
        "java": "\n    ```java\npublic int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "python": "\n    ```python\ndef roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "c++": "\n    ```cpp\nint romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "js": "\n    ```javascript\nfunction romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    "
    },
    {
        "id": 14,
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\" \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"flower \", \"flow \", \"flight \"\\]\n**Output:**  \"fl \"\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"dog \", \"racecar \", \"car \"\\]\n**Output:**  \" \"\n**Explanation:** There is no common prefix among the input strings."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Trie"
        ],
        "example": [
            {
                "input": "[\"flower\",\"flow\",\"flight\"]",
                "output": "\"fl\""
            },
            {
                "input": "[\"dog\",\"racecar\",\"car\"]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; ++j) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "python": "\n    ```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "js": "\n    ```javascript\nfunction longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n\n    for (let i = 0; i < strs[0].length; ++i) {\n        const c = strs[0][i];\n        for (let j = 1; j < strs.length; ++j) {\n            if (i === strs[j].length || strs[j][i] !== c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    "
    },
    {
        "id": 15,
        "title": "3Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,0,1,2,-1,-4\\]\n**Output:** \\[\\[-1,-1,2\\],\\[-1,0,1\\]\\]\n**Explanation:** \nnums\\[0\\] + nums\\[1\\] + nums\\[2\\] = (-1) + 0 + 1 = 0.\nnums\\[1\\] + nums\\[2\\] + nums\\[4\\] = 0 + 1 + (-1) = 0.\nnums\\[0\\] + nums\\[3\\] + nums\\[4\\] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are \\[-1,0,1\\] and \\[-1,-1,2\\].\nNotice that the order of the output and the order of the triplets does not matter.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,1\\]\n**Output:** \\[\\]\n**Explanation:** The only possible triplet does not sum up to 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** \\[\\[0,0,0\\]\\]\n**Explanation:** The only possible triplet sums up to 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 3000`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[-1,0,1,2,-1,-4]",
                "output": "[[-1,-1,2],[-1,0,1]]"
            },
            {
                "input": "[0,1,1]",
                "output": "[]"
            },
            {
                "input": "[0,0,0]",
                "output": "[[0,0,0]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));\n                    while (j < k && nums[j] == nums[j + 1]) j++;\n                    while (j < k && nums[k] == nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }                    \n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "python": "\n    ```python\ndef threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "js": "\n    ```javascript\nfunction threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            let j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                const sum = nums[i] + nums[j] + nums[k];\n                if (sum === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                    while (j < k && nums[j] === nums[j + 1]) j++;\n                    while (j < k && nums[k] === nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    "
    },
    {
        "id": 16,
        "title": "3Sum Closest",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,2,1,-4\\], target = 1\n**Output:** 2\n**Explanation:** The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,0\\], target = 1\n**Output:** 0\n**Explanation:** The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 500`\n*   `-1000 <= nums[i] <= 1000`\n*   `-104 <= target <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[-1,2,1,-4],1",
                "output": "2"
            },
            {
                "input": "[0,0,0],1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target) {\n    Arrays.sort(nums);\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.length - 2; ++i) {\n        int left = i + 1;\n        int right = nums.length - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "python": "\n    ```python\ndef threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1;\n        int right = nums.size() - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (abs(target - sum) < abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "js": "\n    ```javascript\nfunction threeSumClosest(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closest = nums[0] + nums[1] + nums[2];\n    for (let i = 0; i < nums.length - 2; ++i) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        while (left < right) {\n            let sum = nums[i] + nums[left] + nums[right];\n            if (sum === target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    "
    },
    {
        "id": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits =  \"23 \"\n**Output:** \\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n\n",
                "**Example 2:**\n\n**Input:** digits =  \" \"\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** digits =  \"2 \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Backtracking"
        ],
        "example": [
            {
                "input": "\"23\"",
                "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
            },
            {
                "input": "\"\"",
                "output": "[]"
            },
            {
                "input": "\"2\"",
                "output": "[\"a\",\"b\",\"c\"]"
            }
        ],
        "java": "\n    ```java\npublic List<String> letterCombinations(String digits) {\n    LinkedList<String> output = new LinkedList<>();\n    if(digits.isEmpty()) return output;\n    \n    String[] phone = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    output.add(\"\");\n    \n    for(char d : digits.toCharArray()){\n        while(output.peek().length() == digits.indexOf(d)){\n            String perm = output.remove();\n            for(char c : phone[d - '2'].toCharArray()){\n                output.add(perm + c);\n            }\n        }\n    }\n    \n    return output;\n}\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "python": "\n    ```python\ndef letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    if(digits.empty()) return {};\n    vector<string> phone = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> result = {\"\"};\n\n    for (char d : digits) {\n        vector<string> temp;\n        for (const string &s : result) {\n            for (char c : phone[d - '2']) {\n                temp.push_back(s + c);\n            }\n        }\n        result.swap(temp);\n    }\n    return result;\n}\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "js": "\n    ```javascript\nfunction letterCombinations(digits) {\n    if (digits.length === 0) return [];\n    \n    let phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n    let result = [\"\"];\n\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let temp = [];\n\n        for (let s of result) {\n            for (let c of phone[digit - 2]) {\n                temp.push(s + c);\n            }\n        }\n\n        result = temp;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    "
    },
    {
        "id": 18,
        "title": "4Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n*   `0 <= a, b, c, d < n`\n*   `a`, `b`, `c`, and `d` are **distinct**.\n*   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,0,-1,0,-2,2\\], target = 0\n**Output:** \\[\\[-2,-1,1,2\\],\\[-2,0,0,2\\],\\[-1,0,0,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\], target = 8\n**Output:** \\[\\[2,2,2,2\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,0,-1,0,-2,2],0",
                "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]"
            },
            {
                "input": "[2,2,2,2,2],8",
                "output": "[[2,2,2,2]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    if(nums == null || nums.length < 4)\n        return result;\n\n    Arrays.sort(nums);\n    for(int i = 0; i < nums.length - 3; i++) {\n        if(i > 0 && nums[i] == nums[i-1])\n            continue;\n\n        for(int j = i + 1; j < nums.length - 2; j++) {\n            if(j > i + 1 && nums[j] == nums[j-1])\n                continue;\n\n            int left = j + 1;\n            int right = nums.length - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                    ++left;\n                    --right;\n                    while(left < right && nums[left] == nums[left - 1]) ++left;\n                    while(left < right && nums[right] == nums[right + 1]) --right;\n                } else if(sum < target) {\n                    ++left;\n                } else {\n                    --right;\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "python": "\n    ```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if cur_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]: left += 1\n                    while left < right and nums[right] == nums[right + 1]: right -= 1\n                elif cur_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n    vector<vector<int>> result;\n    int n = nums.size();\n    if(n < 4)\n        return result;\n\n    sort(nums.begin(), nums.end());\n    for(int i = 0; i < n - 3; i++) {\n        if(i > 0 && nums[i] == nums[i-1])\n            continue;\n\n        for(int j = i + 1; j < n - 2; j++) {\n            if(j > i + 1 && nums[j] == nums[j-1])\n                continue;\n\n            int left = j + 1;\n            int right = n - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.push_back({nums[i], nums[j], nums[left], nums[right]});\n                    ++left;\n                    --right;\n                    while(left < right && nums[left] == nums[left-1]) ++left;\n                    while(left < right && nums[right] == nums[right+1]) --right;\n                } else if(sum < target) {\n                    ++left;\n                } else {\n                    --right;\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "js": "\n    ```javascript\nfunction fourSum(nums, target) {\n    nums.sort((a, b) => a - b);\n    let result = [];\n    for (let i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n\n            let left = j + 1;\n            let right = nums.length - 1;\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    left++;\n                    right--;\n                    while (left < right && nums[left] === nums[left - 1]) left++;\n                    while (left < right && nums[right] === nums[right + 1]) right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    "
    },
    {
        "id": 20,
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"() \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"()\\[\\]{} \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"(\\] \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of parentheses only `'()[]{}'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"()\"",
                "output": "true"
            },
            {
                "input": "\"()[]{}\"",
                "output": "true"
            },
            {
                "input": "\"(",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.peek() != '(') return false;\n            if (c == '}' && stack.peek() != '{') return false;\n            if (c == ']' && stack.peek() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "python": "\n    ```python\ndef is_valid(s: str) -> bool:\n    stack = []\n\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        else:\n            if not stack:\n                return False\n            if c == ')' and stack[-1] != '(':\n                return False\n            if c == '}' and stack[-1] != '{':\n                return False\n            if c == ']' and stack[-1] != '[':\n                return False\n            stack.pop()\n\n    return not stack\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "c++": "\n    ```cpp\nbool isValid(std::string s) {\n    std::stack<char> stack;\n\n    for (char c : s) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.top() != '(') return false;\n            if (c == '}' && stack.top() != '{') return false;\n            if (c == ']' && stack.top() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "js": "\n    ```javascript\nfunction isValid(s) {\n    const stack = [];\n\n    for (const c of s) {\n        if (c === '(' || c === '{' || c === '[') {\n            stack.push(c);\n        } else {\n            if (!stack.length) return false;\n            if (c === ')' && stack[stack.length - 1] !== '(') return false;\n            if (c === '}' && stack[stack.length - 1] !== '{') return false;\n            if (c === ']' && stack[stack.length - 1] !== '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.length === 0;\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    "
    },
    {
        "id": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn _the head of the merged linked list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** list1 = \\[1,2,4\\], list2 = \\[1,3,4\\]\n**Output:** \\[1,1,2,3,4,4\\]\n\n",
                "**Example 2:**\n\n**Input:** list1 = \\[\\], list2 = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** list1 = \\[\\], list2 = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in both lists is in the range `[0, 50]`.\n*   `-100 <= Node.val <= 100`\n*   Both `list1` and `list2` are sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,4],[1,3,4]",
                "output": "[1,1,2,3,4,4]"
            },
            {
                "input": "[],[]",
                "output": "[]"
            },
            {
                "input": "[],[0]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list1 == null) return list2;\n    if (list2 == null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n         \ndef merge_two_lists(list1, list2):\n    if list1 is None:\n        return list2\n    if list2 is None:\n        return list1\n\n    if list1.val < list2.val:\n        list1.next = merge_two_lists(list1.next, list2)\n        return list1\n    else:\n        list2.next = merge_two_lists(list1, list2.next)\n        return list2\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    ",
        "c++": "\n    ```cpp\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (list1 == nullptr) return list2;\n    if (list2 == nullptr) return list1;\n\n    if (list1->val < list2->val) {\n        list1->next = mergeTwoLists(list1->next, list2);\n        return list1;\n    } else {\n        list2->next = mergeTwoLists(list1, list2->next);\n        return list2;\n    }\n}\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    ",
        "js": "\n    ```javascript\nfunction ListNode(val, next) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n}\n\nfunction mergeTwoLists(list1, list2) {\n    if (list1 === null) return list2;\n    if (list2 === null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}\n```\n    \n    The algorithm is a recursive solution:\n1. If either `list1` or `list2` is null, return the other list as the result.\n2. Compare the values of the nodes in `list1` and `list2`.\n3. If `list1` node value is smaller, set `list1.next` to the result of recursively calling the function with `list1.next` and `list2`.\n4. Otherwise, set `list2.next` to the result of recursively calling the function with `list1` and `list2.next`.\n5. Return the current node as the new head of the merged list.\n\nThis process is repeated until one of the lists becomes null, then the other list is returned as the remainder of the merged list.\n\nPlease note that each language has some differences in syntax, like defining a class in Python or using the `nullptr` keyword in C++. However, the core logic of the solution remains the same for all languages.\n    "
    },
    {
        "id": 22,
        "title": "Generate Parentheses",
        "difficulty": "Medium",
        "content": {
            "problem": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"()\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 8`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Backtracking"
        ],
        "example": [
            {
                "input": "3",
                "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
            },
            {
                "input": "1",
                "output": "[\"()\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n\nprivate void generateParenthesisHelper(int open, int close, String current, List<String> result) {\n    if (open == 0 && close == 0) {\n        result.add(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "python": "\n    ```python\ndef generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) {\n    if (open == 0 && close == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n\nstd::vector<std::string> generateParenthesis(int n) {\n    std::vector<std::string> result;\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "js": "\n    ```javascript\nfunction generateParenthesis(n) {\n    function generateParenthesisHelper(open, close, current, result) {\n        if (open === 0 && close === 0) {\n            result.push(current);\n            return;\n        }\n        if (open > 0) {\n            generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n        }\n        if (close > 0) {\n            generateParenthesisHelper(open, close - 1, current + ')', result);\n        }\n    }\n\n    let result = [];\n    generateParenthesisHelper(n, 0, '', result);\n    return result;\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    "
    },
    {
        "id": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\n_Merge all the linked-lists into one sorted linked-list and return it._",
            "examples": [
                "**Example 1:**\n\n**Input:** lists = \\[\\[1,4,5\\],\\[1,3,4\\],\\[2,6\\]\\]\n**Output:** \\[1,1,2,3,4,4,5,6\\]\n**Explanation:** The linked-lists are:\n\\[\n  1->4->5,\n  1->3->4,\n  2->6\n\\]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\n",
                "**Example 2:**\n\n**Input:** lists = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** lists = \\[\\[\\]\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `k == lists.length`\n*   `0 <= k <= 104`\n*   `0 <= lists[i].length <= 500`\n*   `-104 <= lists[i][j] <= 104`\n*   `lists[i]` is sorted in **ascending order**.\n*   The sum of `lists[i].length` will not exceed `104`.",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Divide and Conquer",
            "Heap (Priority Queue)",
            "Merge Sort"
        ],
        "example": [
            {
                "input": "[[1,4,5],[1,3,4],[2,6]]",
                "output": "[1,1,2,3,4,4,5,6]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[[]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        while(lists.length > 1){\n            List<ListNode> tempList = new ArrayList<>();\n            tempList.add(mergeTwoLists(lists[0],lists[1]));\n            tempList.addAll(Arrays.asList(lists).subList(2, lists.length));\n            lists = tempList.toArray(new ListNode[tempList.size()]);\n        }\n        return lists[0];\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        if(l1.val <= l2.val){\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists: return None\n        while len(lists) > 1:\n            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))\n        return lists[0]\n        \n    def merge2Lists(self, l1, l2):\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val <= l2.val:\n            l1.next = self.merge2Lists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.merge2Lists(l1, l2.next)\n            return l2\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.empty()) return nullptr;\n        while(lists.size()>1){\n            lists.push_back(merge2Lists(lists[0],lists[1]));\n            lists.erase(lists.begin());\n            lists.erase(lists.begin());\n        }\n        return lists[0];\n    }\n    \n     ListNode* merge2Lists(ListNode* l1, ListNode* l2){\n        if(!l1) return l2;\n        if(!l2) return l1;\n        if(l1->val <= l2->val){\n            l1->next = merge2Lists(l1->next, l2);\n            return l1;\n        }\n        else{\n            l2->next = merge2Lists(l1, l2->next);\n            return l2;\n        }\n    }\n};\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val=0, next=null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction mergeKLists(lists) {\n    if(lists.length === 0) return null;\n    while(lists.length > 1){\n        lists.push(merge2Lists(lists.shift(), lists.shift()));\n    }\n    return lists[0];\n}\n\nfunction merge2Lists(l1, l2){\n    if(!l1) return l2;\n    if(!l2) return l1;\n    if(l1.val <= l2.val){\n        l1.next = merge2Lists(l1.next, l2);\n        return l1;\n    }\n    else{\n        l2.next = merge2Lists(l1, l2.next);\n        return l2;\n    }\n}\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    "
    },
    {
        "id": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[2,1,4,3,5\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 3\n**Output:** \\[3,2,1,4,5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= k <= n <= 5000`\n*   `0 <= Node.val <= 1000`\n\n**",
            "follow_up": "Follow-up:** Can you solve the problem in `O(1)` extra memory space?"
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5],2",
                "output": "[2,1,4,3,5]"
            },
            {
                "input": "[1,2,3,4,5],3",
                "output": "[3,2,1,4,5]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode reverseKGroup(ListNode head, int k) {\n    if (head == null || k == 1) return head;\n    \n    int len = 0;\n    ListNode cur = head;\n    while (cur != null) {\n        len++;\n        cur = cur.next;\n    }\n    \n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n        \n    cur = head\n    length = 0\n    while cur:\n        length += 1\n        cur = cur.next\n        \n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n    \n    while length >= k:\n        for _ in range(1, k):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        prev = cur\n        cur = cur.next\n        length -= k\n        \n    return dummy.next\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* reverseKGroup(ListNode* head, int k) {\n    if (head == nullptr || k == 1) return head;\n    \n    int len = 0;\n    ListNode *cur = head;\n    while (cur != nullptr) {\n        len++;\n        cur = cur->next;\n    }\n    \n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode *prev = &dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode *temp = cur->next;\n            cur->next = temp->next;\n            temp->next = prev->next;\n            prev->next = temp;\n        }\n        prev = cur;\n        cur = cur->next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseKGroup(head, k) {\n    if (!head || k === 1) return head;\n    \n    let len = 0;\n    let cur = head;\n    while (cur) {\n        len++;\n        cur = cur.next;\n    }\n    \n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (let i = 1; i < k; i++) {\n            let temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    "
    },
    {
        "id": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.\n\nConsider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** 2, nums = \\[1,2,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,2,2,3,3,4\\]\n**Output:** 5, nums = \\[0,1,2,3,4,\\_,\\_,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-100 <= nums[i] <= 100`\n*   `nums` is sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[1,1,2]",
                "output": "2,nums=[1,2,_]"
            },
            {
                "input": "[0,0,1,1,1,2,2,3,3,4]",
                "output": "5,nums=[0,1,2,3,4,_,_,_,_,_]"
            }
        ],
        "java": "\n    ```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "python": "\n    ```python\ndef removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "c++": "\n    ```cpp\nint removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.size(); j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "js": "\n    ```javascript\nfunction removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    let i = 0;\n    for (let j = 1; j < nums.length; j++) {\n        if (nums[j] !== nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    "
    },
    {
        "id": 27,
        "title": "Remove Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint val = ...; // Value to remove\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,2,3\\], val = 3\n**Output:** 2, nums = \\[2,2,\\_,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,2,2,3,0,4,2\\], val = 2\n**Output:** 5, nums = \\[0,1,4,0,3,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 100`\n*   `0 <= nums[i] <= 50`\n*   `0 <= val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[3,2,2,3],3",
                "output": "2,nums=[2,2,_,_]"
            },
            {
                "input": "[0,1,2,2,3,0,4,2],2",
                "output": "5,nums=[0,1,4,0,3,_,_,_]"
            }
        ],
        "java": "\n    ```java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "python": "\n    ```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "c++": "\n    ```cpp\nint removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "js": "\n    ```javascript\nfunction removeElement(nums, val) {\n    let i = 0;\n    for (let j = 0; j < nums.length; j++) {\n        if (nums[j] !== val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    "
    },
    {
        "id": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.",
            "examples": [
                "**Example 1:**\n\n**Input:** haystack =  \"sadbutsad \", needle =  \"sad \"\n**Output:** 0\n**Explanation:**  \"sad \" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\n",
                "**Example 2:**\n\n**Input:** haystack =  \"leetcode \", needle =  \"leeto \"\n**Output:** -1\n**Explanation:**  \"leeto \" did not occur in  \"leetcode \", so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= haystack.length, needle.length <= 104`\n*   `haystack` and `needle` consist of only lowercase English characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"sadbutsad\",\"sad\"",
                "output": "0"
            },
            {
                "input": "\"leetcode\",\"leeto\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    \n    int index = haystack.indexOf(needle);\n    return index;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "python": "\n    ```python\ndef strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "c++": "\n    ```cpp\nint strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n\n    size_t pos = haystack.find(needle);\n    if(pos != string::npos)\n        return pos;\n    return -1;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "js": "\n    ```javascript\nfunction strStr(haystack, needle) {\n    if (needle === '') return 0;\n\n    let index = haystack.indexOf(needle);\n    return index;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    "
    },
    {
        "id": 29,
        "title": "Divide Two Integers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers `dividend` and `divisor`, divide two integers **without** using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`.\n\nReturn _the **quotient** after dividing_ `dividend` _by_ `divisor`.\n\n**Note:** Assume we are dealing with an environment that could only store integers within the **32-bit** signed integer range: `[-231, 231 - 1]`. For this problem, if the quotient is **strictly greater than** `231 - 1`, then return `231 - 1`, and if the quotient is **strictly less than** `-231`, then return `-231`.",
            "examples": [
                "**Example 1:**\n\n**Input:** dividend = 10, divisor = 3\n**Output:** 3\n**Explanation:** 10/3 = 3.33333.. which is truncated to 3.\n\n",
                "**Example 2:**\n\n**Input:** dividend = 7, divisor = -3\n**Output:** -2\n**Explanation:** 7/-3 = -2.33333.. which is truncated to -2."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= dividend, divisor <= 231 - 1`\n*   `divisor != 0`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "10,3",
                "output": "3"
            },
            {
                "input": "7,-3",
                "output": "-2"
            }
        ],
        "java": "\n    ```java\npublic int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "python": "\n    ```python\ndef divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "c++": "\n    ```cpp\nint divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "js": "\n    ```javascript\nfunction divide(dividend, divisor) {\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\n        return Math.pow(2, 31) - 1;\n    }\n\n    const sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    let dvd = Math.abs(dividend);\n    let dvs = Math.abs(divisor);\n    let ans = 0;\n\n    while (dvd >= dvs) {\n        let temp = dvs;\n        let multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    "
    },
    {
        "id": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of **the same length**.\n\nA **concatenated substring** in `s` is a substring that contains all the strings of any permutation of `words` concatenated.\n\n*   For example, if `words = [ \"ab \", \"cd \", \"ef \"]`, then `\"abcdef \"`, `\"abefcd \"`, `\"cdabef \"`, `\"cdefab \"`, `\"efabcd \"`, and `\"efcdab \"` are all concatenated strings. `\"acdbef \"` is not a concatenated substring because it is not the concatenation of any permutation of `words`.\n\nReturn _the starting indices of all the concatenated substrings in_ `s`. You can return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"barfoothefoobarman \", words = \\[ \"foo \", \"bar \"\\]\n**Output:** \\[0,9\\]\n**Explanation:** Since words.length == 2 and words\\[i\\].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is  \"barfoo \". It is the concatenation of \\[ \"bar \", \"foo \"\\] which is a permutation of words.\nThe substring starting at 9 is  \"foobar \". It is the concatenation of \\[ \"foo \", \"bar \"\\] which is a permutation of words.\nThe output order does not matter. Returning \\[9,0\\] is fine too.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"wordgoodgoodgoodbestword \", words = \\[ \"word \", \"good \", \"best \", \"word \"\\]\n**Output:** \\[\\]\n**Explanation:** Since words.length == 4 and words\\[i\\].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"barfoofoobarthefoobarman \", words = \\[ \"bar \", \"foo \", \"the \"\\]\n**Output:** \\[6,9,12\\]\n**Explanation:** Since words.length == 3 and words\\[i\\].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is  \"foobarthe \". It is the concatenation of \\[ \"foo \", \"bar \", \"the \"\\] which is a permutation of words.\nThe substring starting at 9 is  \"barthefoo \". It is the concatenation of \\[ \"bar \", \"the \", \"foo \"\\] which is a permutation of words.\nThe substring starting at 12 is  \"thefoobar \". It is the concatenation of \\[ \"the \", \"foo \", \"bar \"\\] which is a permutation of words."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `1 <= words.length <= 5000`\n*   `1 <= words[i].length <= 30`\n*   `s` and `words[i]` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"barfoothefoobarman\",[\"foo\",\"bar\"]",
                "output": "[0,9]"
            },
            {
                "input": "\"wordgoodgoodgoodbestword\",[\"word\",\"good\",\"best\",\"word\"]",
                "output": "[]"
            },
            {
                "input": "\"barfoofoobarthefoobarman\",[\"bar\",\"foo\",\"the\"]",
                "output": "[6,9,12]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {\n    if (s.empty() || words.empty()) return {};\n    \n    std::unordered_map<std::string, int> word_count;\n    for (const auto& word : words) {\n        ++word_count[word];\n    }\n    \n    int word_length = words[0].size();\n    int total_words = words.size();\n    int total_length = word_length * total_words;\n    std::vector<int> result;\n    \n    for (int i = 0; i <= (int)s.size() - total_length; ++i) {\n        std::unordered_map<std::string, int> temp_word_count;\n        for (int j = 0; j < total_words; ++j) {\n            std::string current_word = s.substr(i + j * word_length, word_length);\n            if (word_count.find(current_word) == word_count.end()) break;\n            ++temp_word_count[current_word];\n            if (temp_word_count[current_word] > word_count[current_word]) break;\n            if (j + 1 == total_words) result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    ",
        "js": "\n    ```javascript\nfunction findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const word_count = new Map();\n    for (const word of words) {\n        word_count.set(word, (word_count.get(word) || 0) + 1);\n    }\n\n    const word_length = words[0].length;\n    const total_words = words.length;\n    const total_length = word_length * total_words;\n    const result = [];\n\n    for (let i = 0; i <= s.length - total_length; i++) {\n        const temp_word_count = new Map();\n        for (let j = 0; j < total_words; j++) {\n            const current_word = s.substr(i + j * word_length, word_length);\n            if (!word_count.has(current_word)) break;\n            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 === total_words) result.push(i);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    "
    },
    {
        "id": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Stack"
        ],
        "example": [
            {
                "input": "\"(()\"",
                "output": "2"
            },
            {
                "input": "\")()())\"",
                "output": "4"
            },
            {
                "input": "\"\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int longestValidParentheses(String s) {\n    int n = s.length();\n    int result = 0;\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; ++i) {\n        if (s.charAt(i) == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s.charAt(st.peek()) == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "python": "\n    ```python\ndef longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <stack>\n\nint longestValidParentheses(string s) {\n    int n = s.length();\n    int result = 0;\n    std::stack<int> st;\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s[st.top()] == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.top();\n            st.pop();\n            result = std::max(result, right - left - 1);\n            right = left;\n        }\n        result = std::max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "js": "\n    ```javascript\nfunction longestValidParentheses(s) {\n    const n = s.length;\n    let result = 0;\n    const st = [];\n\n    for (let i = 0; i < n; ++i) {\n        if (s[i] === '(') {\n            st.push(i);\n        } else {\n            if (st.length > 0 && s[st[st.length - 1]] === '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.length === 0) {\n        result = n;\n    } else {\n        let right = n, left = 0;\n        while (st.length > 0) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    "
    },
    {
        "id": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\n\nGiven the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 0\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 3\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\], target = 0\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   All values of `nums` are **unique**.\n*   `nums` is an ascending array that is possibly rotated.\n*   `-104 <= target <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[4,5,6,7,0,1,2],0",
                "output": "4"
            },
            {
                "input": "[4,5,6,7,0,1,2],3",
                "output": "-1"
            },
            {
                "input": "[1],0",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "python": "\n    ```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "c++": "\n    ```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "js": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    "
    },
    {
        "id": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 8\n**Output:** \\[3,4\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 6\n**Output:** \\[-1,-1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** \\[-1,-1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `nums` is a non-decreasing array.\n*   `-109 <= target <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[5,7,7,8,8,10],8",
                "output": "[3,4]"
            },
            {
                "input": "[5,7,7,8,8,10],6",
                "output": "[-1,-1]"
            },
            {
                "input": "[],0",
                "output": "[-1,-1]"
            }
        ],
        "java": "\n    ```java\npublic int[] searchRange(int[] nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0;\n    right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return new int[] {start, end};\n}\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "python": "\n    ```python\ndef searchRange(nums, target):\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> searchRange(std::vector<int>& nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return {start, end};\n}\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "js": "\n    ```javascript\nfunction searchRange(nums, target) {\n    let start = -1, end = -1;\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] === target) {\n                start = mid;\n            }\n        }\n    }\n\n    left = 0;\n    right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] === target) {\n                end = mid;\n            }\n        }\n    }\n\n    return [start, end];\n}\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    "
    },
    {
        "id": 35,
        "title": "Search Insert Position",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 5\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 2\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 7\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` contains **distinct** values sorted in **ascending** order.\n*   `-104 <= target <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[1,3,5,6],5",
                "output": "2"
            },
            {
                "input": "[1,3,5,6],2",
                "output": "1"
            },
            {
                "input": "[1,3,5,6],7",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "python": "\n    ```python\ndef searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "c++": "\n    ```cpp\nint searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "js": "\n    ```javascript\nfunction searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    "
    },
    {
        "id": 37,
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "content": {
            "problem": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules**:\n\n1.  Each of the digits `1-9` must occur exactly once in each row.\n2.  Each of the digits `1-9` must occur exactly once in each column.\n3.  Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\],\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\],\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\],\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\],\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\],\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\],\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\],\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\],\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** \\[\\[ \"5 \", \"3 \", \"4 \", \"6 \", \"7 \", \"8 \", \"9 \", \"1 \", \"2 \"\\],\\[ \"6 \", \"7 \", \"2 \", \"1 \", \"9 \", \"5 \", \"3 \", \"4 \", \"8 \"\\],\\[ \"1 \", \"9 \", \"8 \", \"3 \", \"4 \", \"2 \", \"5 \", \"6 \", \"7 \"\\],\\[ \"8 \", \"5 \", \"9 \", \"7 \", \"6 \", \"1 \", \"4 \", \"2 \", \"3 \"\\],\\[ \"4 \", \"2 \", \"6 \", \"8 \", \"5 \", \"3 \", \"7 \", \"9 \", \"1 \"\\],\\[ \"7 \", \"1 \", \"3 \", \"9 \", \"2 \", \"4 \", \"8 \", \"5 \", \"6 \"\\],\\[ \"9 \", \"6 \", \"1 \", \"5 \", \"3 \", \"7 \", \"2 \", \"8 \", \"4 \"\\],\\[ \"2 \", \"8 \", \"7 \", \"4 \", \"1 \", \"9 \", \"6 \", \"3 \", \"5 \"\\],\\[ \"3 \", \"4 \", \"5 \", \"2 \", \"8 \", \"6 \", \"1 \", \"7 \", \"9 \"\\]\\]\n**Explanation:** The input board is shown above and the only valid solution is shown below:"
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 9`\n*   `board[i].length == 9`\n*   `board[i][j]` is a digit or `'.'`.\n*   It is **guaranteed** that the input board has only one solution.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Backtracking",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n\n    public boolean solveSudokuHelper(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n\n                            if (solveSudokuHelper(board)) {\n                                return true;\n                            }\n\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void solveSudoku(char[][] board) {\n        solveSudokuHelper(board);\n    }\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "python": "\n    ```python\ndef isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "js": "\n    ```javascript\nfunction isValid(board, row, col, c) {\n    for (let i = 0; i < 9; i++) {\n        if (board[i][col] === c) return false;\n        if (board[row][i] === c) return false;\n        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;\n    }\n    return true;\n}\n\nfunction solveSudokuHelper(board) {\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            if (board[i][j] === '.') {\n                for (let c = 1; c <= 9; c++) {\n                    if (isValid(board, i, j, c.toString())) {\n                        board[i][j] = c.toString();\n\n                        if (solveSudokuHelper(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction solveSudoku(board) {\n    solveSudokuHelper(board);\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    "
    },
    {
        "id": 38,
        "title": "Count and Say",
        "difficulty": "Medium",
        "content": {
            "problem": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n\n*   `countAndSay(1) = \"1 \"`\n*   `countAndSay(n)` is the way you would \"say \" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say \" a digit string, split it into the **minimal** number of substrings such that each substring contains exactly **one** unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n\nFor example, the saying and conversion for digit string `\"3322251 \"`:\n\nGiven a positive integer `n`, return _the_ `nth` _term of the **count-and-say** sequence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:**  \"1 \"\n**Explanation:** This is the base case.\n\n",
                "**Example 2:**\n\n**Input:** n = 4\n**Output:**  \"1211 \"\n**Explanation:**\ncountAndSay(1) =  \"1 \"\ncountAndSay(2) = say  \"1 \" = one 1 =  \"11 \"\ncountAndSay(3) = say  \"11 \" = two 1's =  \"21 \"\ncountAndSay(4) = say  \"21 \" = one 2 + one 1 =  \"12 \" +  \"11 \" =  \"1211 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 30`",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "1",
                "output": "\"1\""
            },
            {
                "input": "4",
                "output": "\"1211\""
            }
        ],
        "java": "\n    ```java\npublic String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "python": "\n    ```python\ndef count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "js": "\n    ```javascript\nfunction countAndSay(n) {\n    if (n === 1) return \"1\";\n    let previous = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n    for (let i = 1; i < previous.length; i++) {\n        if (previous[i] === previous[i - 1]) {\n            count++;\n        } else {\n            result += count.toString() + previous[i - 1];\n            count = 1;\n        }\n    }\n    result += count.toString() + previous[previous.length - 1];\n    return result;\n}\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    "
    },
    {
        "id": 39,
        "title": "Combination Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.",
            "examples": [
                "**Example 1:**\n\n**Input:** candidates = \\[2,3,6,7\\], target = 7\n**Output:** \\[\\[2,2,3\\],\\[7\\]\\]\n**Explanation:**\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n",
                "**Example 2:**\n\n**Input:** candidates = \\[2,3,5\\], target = 8\n**Output:** \\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** candidates = \\[2\\], target = 1\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= candidates.length <= 30`\n*   `2 <= candidates[i] <= 40`\n*   All elements of `candidates` are **distinct**.\n*   `1 <= target <= 40`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking"
        ],
        "example": [
            {
                "input": "[2,3,6,7],7",
                "output": "[[2,2,3],[7]]"
            },
            {
                "input": "[2,3,5],8",
                "output": "[[2,2,2,2],[2,3,3],[3,5]]"
            },
            {
                "input": "[2],1",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    findCombinations(candidates, target, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void findCombinations(int[] candidates, int target, int startIndex, List<Integer> current, List<List<Integer>> result) {\n    if (target == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n    if (startIndex == candidates.length || target < 0) {\n        return;\n    }\n\n    findCombinations(candidates, target, startIndex + 1, current, result);\n\n    current.add(candidates[startIndex]);\n    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\n    current.remove(current.size() - 1);\n}\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "python": "\n    ```python\ndef combinationSum(candidates, target):\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (target == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (startIndex == candidates.size() || target < 0) {\n        return;\n    }\n\n    findCombinations(candidates, target, startIndex + 1, current, result);\n\n    current.push_back(candidates[startIndex]);\n    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\n    current.pop_back();\n}\n\nstd::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {\n    std::vector<int> current;\n    std::vector<std::vector<int>> result;\n    findCombinations(candidates, target, 0, current, result);\n    return result;\n}\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "js": "\n    ```javascript\nfunction combinationSum(candidates, target) {\n    function findCombinations(startIndex, remaining) {\n        if (remaining === 0) {\n            return [[]];\n        }\n        if (startIndex === candidates.length || remaining < 0) {\n            return [];\n        }\n\n        let result = [];\n        result = result.concat(findCombinations(startIndex + 1, remaining));\n        result = result.concat(findCombinations(startIndex, remaining - candidates[startIndex]).map(x => x.concat([candidates[startIndex]])));\n\n        return result;\n    }\n\n    return findCombinations(0, target);\n}\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    "
    },
    {
        "id": 40,
        "title": "Combination Sum II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:** The solution set must not contain duplicate combinations.",
            "examples": [
                "**Example 1:**\n\n**Input:** candidates = \\[10,1,2,7,6,1,5\\], target = 8\n**Output:** \n\\[\n\\[1,1,6\\],\n\\[1,2,5\\],\n\\[1,7\\],\n\\[2,6\\]\n\\]\n\n",
                "**Example 2:**\n\n**Input:** candidates = \\[2,5,2,1,2\\], target = 5\n**Output:** \n\\[\n\\[1,2,2\\],\n\\[5\\]\n\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= candidates.length <= 100`\n*   `1 <= candidates[i] <= 50`\n*   `1 <= target <= 30`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking"
        ],
        "example": [
            {
                "input": "[10,1,2,7,6,1,5],8",
                "output": "\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]"
            },
            {
                "input": "[2,5,2,1,2],5",
                "output": "\n[\n[1,2,2],\n[5]\n]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(candidates);\n    combine(candidates, target, 0, result, new ArrayList<Integer>());\n    return result;\n}\n\nprivate void combine(int[] candidates, int target, int start, List<List<Integer>> result, List<Integer> current) {\n    if (target == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i < candidates.length && target >= candidates[i]; i++) {\n        if (i == start || candidates[i] != candidates[i - 1]) {\n            current.add(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, result, current);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "python": "\n    ```python\ndef combinationSum2(candidates, target):\n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nvoid combine(std::vector<int>& candidates, int target, std::vector<std::vector<int>>& result, std::vector<int>& combination, int index) {\n    if (target == 0) {\n        result.push_back(combination);\n        return;\n    }\n\n    for (int i = index; i < candidates.size() && target >= candidates[i]; ++i) {\n        if (i == index || candidates[i] != candidates[i - 1]) {\n            combination.push_back(candidates[i]);\n            combine(candidates, target - candidates[i], result, combination, i + 1);\n            combination.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum2(std::vector<int>& candidates, int target) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> combination;\n    std::sort(candidates.begin(), candidates.end());\n    combine(candidates, target, result, combination, 0);\n    return result;\n}\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "js": "\n    ```javascript\nfunction combinationSum2(candidates, target) {\n    const result = [];\n    candidates.sort((a, b) => a - b);\n    combine(candidates, target, 0, [], result);\n    return result;\n}\n\nfunction combine(candidates, target, start, current, result) {\n    if (target === 0) {\n        result.push([...current]);\n        return;\n    }\n\n    for (let i = start; i < candidates.length && target >= candidates[i]; i++) {\n        if (i === start || candidates[i] !== candidates[i - 1]) {\n            current.push(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, current, result);\n            current.pop();\n        }\n    }\n}\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    "
    },
    {
        "id": 41,
        "title": "First Missing Positive",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in `O(n)` time and uses constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,0\\]\n**Output:** 3\n**Explanation:** The numbers in the range \\[1,2\\] are all in the array.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,4,-1,1\\]\n**Output:** 2\n**Explanation:** 1 is in the array but 2 is missing.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,8,9,11,12\\]\n**Output:** 1\n**Explanation:** The smallest positive integer 1 is missing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2,0]",
                "output": "3"
            },
            {
                "input": "[3,4,-1,1]",
                "output": "2"
            },
            {
                "input": "[7,8,9,11,12]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "python": "\n    ```python\ndef firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "c++": "\n    ```cpp\nint firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "js": "\n    ```javascript\nfunction firstMissingPositive(nums) {\n    let n = nums.length;\n    for(let i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            let temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        if(nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    "
    },
    {
        "id": 42,
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "content": {
            "problem": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n",
                "**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
                "output": "6"
            },
            {
                "input": "[4,2,0,3,2,5]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "python": "\n    ```python\ndef trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "js": "\n    ```javascript\nfunction trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    "
    },
    {
        "id": 43,
        "title": "Multiply Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 = \"2\", num2 = \"3\"\n**Output:** \"6\"\n\n",
                "**Example 2:**\n\n**Input:** num1 = \"123\", num2 = \"456\"\n**Output:** \"56088\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 200`\n*   `num1` and `num2` consist of digits only.\n*   Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"2\",\"3\"",
                "output": "\"6\""
            },
            {
                "input": "\"123\",\"456\"",
                "output": "\"56088\""
            }
        ],
        "java": "\n    ```java\npublic String multiply(String num1, String num2) {\n    int m = num1.length(), n = num2.length();\n    int[] pos = new int[m + n];\n    \n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            int mult = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n            int p1 = i + j, p2 = i + j + 1;\n            int sum = mult + pos[p2];\n            pos[p1] += sum / 10;\n            pos[p2] = sum % 10;\n        }\n    }\n    \n    StringBuilder res = new StringBuilder();\n    for (int p : pos) if (!(res.length() == 0 && p == 0)) res.append(p);\n    return res.length() == 0 ? \"0\" : res.toString();\n}\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "python": "\n    ```python\ndef multiply(num1, num2):\n    m, n = len(num1), len(num2)\n    pos = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n            p1, p2 = i + j, i + j + 1\n            total_pos = mult + pos[p2]\n            pos[p1] += total_pos // 10\n            pos[p2] = total_pos % 10\n            \n    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            \n    return '0' if len(res) == 0 else res\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "c++": "\n    ```cpp\nstring multiply(string num1, string num2) {\n    int m = num1.size(), n = num2.size();\n    string res(m + n, '0');\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            int p1 = i + j, p2 = i + j + 1;\n            int mult = (num1[i] - '0') * (num2[j] - '0') + (res[p2] - '0');\n            res[p1] += mult / 10;\n            res[p2] = (mult % 10) + '0';\n        }\n    }\n    while (res.size() > 1 && res[0] == '0')\n        res.erase(res.begin());\n    return res;\n}\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "js": "\n    ```javascript\nfunction multiply(num1, num2) {\n    let m = num1.length, n = num2.length;\n    let pos = new Array(m + n).fill(0);\n    \n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            let mult = (num1[i] - '0') * (num2[j] - '0');\n            let p1 = i + j, p2 = i + j + 1;\n            let sum = mult + pos[p2];\n            pos[p1] += Math.floor(sum / 10);\n            pos[p2] = sum % 10;\n        }\n    }\n    \n    while (pos.length > 1 && pos[0] == 0)\n        pos.shift();\n    return pos.join('');\n}\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    "
    },
    {
        "id": 44,
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Greedy",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"aa\",\"a\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"*\"",
                "output": "true"
            },
            {
                "input": "\"cb\",\"?a\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "c++": "\n    ```cpp\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "js": "\n    ```javascript\nfunction isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    "
    },
    {
        "id": 45,
        "title": "Jump Game II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,0,1,4\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[2,3,1,1,4]",
                "output": "2"
            },
            {
                "input": "[2,3,0,1,4]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int jump(int[] nums) {\n    int jumps = 0, currentEnd = 0, currentFarthest = 0;\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "python": "\n    ```python\ndef jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "c++": "\n    ```cpp\nint jump(vector<int>& nums) {\n    int jumps = 0, current_end = 0, current_farthest = 0;\n    \n    for (int i = 0; i < nums.size() - 1; i++) {\n        current_farthest = max(current_farthest, i + nums[i]);\n        if (i == current_end) {\n            jumps++;\n            current_end = current_farthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "js": "\n    ```javascript\nfunction jump(nums) {\n    let jumps = 0, currentEnd = 0, currentFarthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    "
    },
    {
        "id": 52,
        "title": "N-Queens II",
        "difficulty": "Hard",
        "content": {
            "problem": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`",
            "follow_up": null
        },
        "tag": [
            "Backtracking"
        ],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int totalNQueens(int n) {\n    ArrayList<Integer> cols = new ArrayList<>();\n    return backtrack(n, cols);\n}\n\npublic int backtrack(int n, ArrayList<Integer> cols) {\n    if (cols.size() == n) {\n        return 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.add(i);\n            count += backtrack(n, cols);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    return count;\n}\n\npublic boolean isSafe(ArrayList<Integer> cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "python": "\n    ```python\ndef is_safe(cols, row):\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)\n```\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool isSafe(vector<int> &cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols[i] == row || abs(i - col) == abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, vector<int> &cols, int &count) {\n    if (cols.size() == n) {\n        count++;\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push_back(i);\n            backtrack(n, cols, count);\n            cols.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int n) {\n    vector<int> cols;\n    int count = 0;\n    backtrack(n, cols, count);\n    return count;\n}\n```\n\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "js": "\n    ```javascript\nfunction isSafe(cols, row) {\n    let col = cols.length;\n    for (let i = 0; i < cols.length; i++) {\n        if (cols[i] === row || Math.abs(i - col) === Math.abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction backtrack(n, cols) {\n    if (cols.length === n) {\n        return 1;\n    }\n\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push(i);\n            count += backtrack(n, cols);\n            cols.pop();\n        }\n    }\n    return count;\n}\n\nfunction totalNQueens(n) {\n    let cols = [];\n    return backtrack(n, cols);\n}\n```\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    "
    },
    {
        "id": 53,
        "title": "Maximum Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,1,-3,4,-1,2,1,-5,4\\]\n**Output:** 6\n**Explanation:** The subarray \\[4,-1,2,1\\] has the largest sum 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:** The subarray \\[1\\] has the largest sum 1.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[5,4,-1,7,8\\]\n**Output:** 23\n**Explanation:** The subarray \\[5,4,-1,7,8\\] has the largest sum 23."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n\n**",
            "follow_up": "Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle."
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6"
            },
            {
                "input": "[1]",
                "output": "1"
            },
            {
                "input": "[5,4,-1,7,8]",
                "output": "23"
            }
        ],
        "java": "\n    ```java\npublic int maxSubArray(int[] nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n\n    for (int i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "python": "\n    ```python\ndef maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "c++": "\n    ```cpp\nint maxSubArray(vector<int>& nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n    \n    for (int i = 1; i < nums.size(); i++) {\n        current_sum = max(current_sum + nums[i], nums[i]);\n        max_sum = max(max_sum, current_sum);\n    }\n    \n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "js": "\n    ```javascript\nfunction maxSubArray(nums) {\n    let max_sum = nums[0];\n    let current_sum = max_sum;\n\n    for (let i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    "
    },
    {
        "id": 54,
        "title": "Spiral Matrix",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[1,2,3,6,9,8,7,4,5\\]\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3,4\\],\\[5,6,7,8\\],\\[9,10,11,12\\]\\]\n**Output:** \\[1,2,3,4,8,12,11,10,9,5,6,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 10`\n*   `-100 <= matrix[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[1,2,3,6,9,8,7,4,5]"
            },
            {
                "input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
                "output": "[1,2,3,4,8,12,11,10,9,5,6,7]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "python": "\n    ```python\ndef spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    if (matrix.empty()) return result;\n    int m = matrix.size(), n = matrix[0].size();\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; ++i) {\n            result.push_back(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; ++i) {\n            result.push_back(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; --i) {\n                result.push_back(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; --i) {\n                result.push_back(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "js": "\n    ```javascript\nfunction spiralOrder(matrix) {\n    const result = [];\n    if (!matrix.length) return result;\n    let m = matrix.length, n = matrix[0].length;\n    let rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (let i = colStart; i <= colEnd; i++) {\n            result.push(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (let i = rowStart; i <= rowEnd; i++) {\n            result.push(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (let i = colEnd; i >= colStart; i--) {\n                result.push(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (let i = rowEnd; i >= rowStart; i--) {\n                result.push(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    "
    },
    {
        "id": 56,
        "title": "Merge Intervals",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[2,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Output:** \\[\\[1,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Explanation:** Since intervals \\[1,3\\] and \\[2,6\\] overlap, merge them into \\[1,6\\].\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[4,5\\]\\]\n**Output:** \\[\\[1,5\\]\\]\n**Explanation:** Intervals \\[1,4\\] and \\[4,5\\] are considered overlapping."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti <= endi <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,3],[2,6],[8,10],[15,18]]",
                "output": "[[1,6],[8,10],[15,18]]"
            },
            {
                "input": "[[1,4],[4,5]]",
                "output": "[[1,5]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "python": "\n    ```python\ndef merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n\n    std::sort(intervals.begin(), intervals.end());\n    std::vector<std::vector<int>> result;\n    result.push_back(intervals[0]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (result.back()[1] >= intervals[i][0]) {\n            result.back()[1] = std::max(result.back()[1], intervals[i][1]);\n        } else {\n            result.push_back(intervals[i]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "js": "\n    ```javascript\nfunction merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const result = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (result[result.length - 1][1] >= intervals[i][0]) {\n            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    "
    },
    {
        "id": 58,
        "title": "Length of Last Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello World \"\n**Output:** 5\n**Explanation:** The last word is  \"World \" with length 5.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"   fly me   to   the moon   \"\n**Output:** 4\n**Explanation:** The last word is  \"moon \" with length 4.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"luffy is still joyboy \"\n**Output:** 6\n**Explanation:** The last word is  \"joyboy \" with length 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only English letters and spaces `' '`.\n*   There will be at least one word in `s`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"HelloWorld\"",
                "output": "5"
            },
            {
                "input": "\"flymetothemoon\"",
                "output": "4"
            },
            {
                "input": "\"luffyisstilljoyboy\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "python": "\n    ```python\ndef length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    "
    },
    {
        "id": 60,
        "title": "Permutation Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1.  `\"123 \"`\n2.  `\"132 \"`\n3.  `\"213 \"`\n4.  `\"231 \"`\n5.  `\"312 \"`\n6.  `\"321 \"`\n\nGiven `n` and `k`, return the `kth` permutation sequence.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 3\n**Output:** \"213\"\n\n",
                "**Example 2:**\n\n**Input:** n = 4, k = 9\n**Output:** \"2314\"\n\n",
                "**Example 3:**\n\n**Input:** n = 3, k = 1\n**Output:** \"123\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`\n*   `1 <= k <= n!`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Recursion"
        ],
        "example": [
            {
                "input": "3,3",
                "output": "\"213\""
            },
            {
                "input": "4,9",
                "output": "\"2314\""
            },
            {
                "input": "3,1",
                "output": "\"123\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "python": "\n    ```python\ndef getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) {\n    std::vector<int> factorials(n, 1);\n    std::vector<char> nums(n, '1');\n    std::string result;\n    int index;\n\n    for (int i = 1; i <= n; ++i) {\n        nums[i - 1] += i - 1;\n        factorials[i - 1] *= i;\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        result.push_back(nums[index]);\n        nums.erase(nums.begin() + index);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "js": "\n    ```javascript\nfunction getPermutation(n, k) {\n    const factorials = [1];\n    const nums = [...Array(n)].map((_, i) => i + 1);\n    let result = '';\n\n    for (let i = 1; i < n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    k--;\n\n    for (let i = n; i >= 1; i--) {\n        const index = Math.floor(k / factorials[i - 1]);\n        k %= factorials[i - 1];\n        result += nums[index];\n        nums.splice(index, 1);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    "
    },
    {
        "id": 62,
        "title": "Unique Paths",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 7\n**Output:** 28\n\n",
                "**Example 2:**\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "3,7",
                "output": "28"
            },
            {
                "input": "3,2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "python": "\n    ```python\ndef uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "c++": "\n    ```cpp\nint uniquePaths(int m, int n) {\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "js": "\n    ```javascript\nfunction uniquePaths(m, n) {\n    const dp = Array.from({ length: m }, () => Array(n).fill(1));\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    "
    },
    {
        "id": 63,
        "title": "Unique Paths II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.",
            "examples": [
                "**Example 1:**\n\n**Input:** obstacleGrid = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n",
                "**Example 2:**\n\n**Input:** obstacleGrid = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,0,0],[0,1,0],[0,0,0]]",
                "output": "2"
            },
            {
                "input": "[[0,1],[0,0]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int uniquePathsWithObstacles(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0)\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else\n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "python": "\n    ```python\ndef uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "c++": "\n    ```cpp\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0) \n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else \n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "js": "\n    ```javascript\nfunction uniquePathsWithObstacles(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    if (grid[0][0] === 1) return 0;\n\n    grid[0][0] = 1;\n    for (let i = 1; i < m; ++i) {\n        grid[i][0] = (grid[i][0] === 0 && grid[i - 1][0] === 1) ? 1 : 0;\n    }\n    for (let i = 1; i < n; ++i) {\n        grid[0][i] = (grid[0][i] === 0 && grid[0][i - 1] === 1) ? 1 : 0;\n    }\n\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            if (grid[i][j] === 0) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            } else {\n                grid[i][j] = 0;\n            }\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    "
    },
    {
        "id": 64,
        "title": "Minimum Path Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,3,1],[1,5,1],[4,2,1]]",
                "output": "7"
            },
            {
                "input": "[[1,2,3],[4,5,6]]",
                "output": "12"
            }
        ],
        "java": "\n    ```java\npublic int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "python": "\n    ```python\ndef minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "c++": "\n    ```cpp\nint minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "js": "\n    ```javascript\nfunction minPathSum(grid) {\n    let m = grid.length, n = grid[0].length;\n        \n    for(let i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(let i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    "
    },
    {
        "id": 65,
        "title": "Valid Number",
        "difficulty": "Hard",
        "content": {
            "problem": "A **valid number** can be split up into these components (in order):\n\n1.  A **decimal number** or an **integer**.\n2.  (Optional) An `'e'` or `'E'`, followed by an **integer**.\n\nA **decimal number** can be split up into these components (in order):\n\n1.  (Optional) A sign character (either `'+'` or `'-'`).\n2.  One of the following formats:\n    1.  One or more digits, followed by a dot `'.'`.\n    2.  One or more digits, followed by a dot `'.'`, followed by one or more digits.\n    3.  A dot `'.'`, followed by one or more digits.\n\nAn **integer** can be split up into these components (in order):\n\n1.  (Optional) A sign character (either `'+'` or `'-'`).\n2.  One or more digits.\n\nFor example, all the following are valid numbers: `[ \"2 \", \"0089 \", \"-0.1 \", \"+3.14 \", \"4. \", \"-.9 \", \"2e10 \", \"-90E3 \", \"3e+7 \", \"+6e-1 \", \"53.5e93 \", \"-123.456e789 \"]`, while the following are not valid numbers: `[ \"abc \", \"1a \", \"1e \", \"e3 \", \"99e2.5 \", \"--6 \", \"-+3 \", \"95a54e53 \"]`.\n\nGiven a string `s`, return `true` _if_ `s` _is a **valid number**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"0 \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"e \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s =  \". \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `s` consists of only English letters (both uppercase and lowercase), digits (`0-9`), plus `'+'`, minus `'-'`, or dot `'.'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"0\"",
                "output": "true"
            },
            {
                "input": "\"e\"",
                "output": "false"
            },
            {
                "input": "\".\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Solution {\n    public boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }\n}\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    ",
        "python": "\n    ```python\nimport re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    ",
        "c++": "\n    ```cpp\n#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    std::regex pattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(s, pattern);\n}\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    ",
        "js": "\n    ```javascript\nfunction isNumber(s) {\n    const pattern = /^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$/;\n    return pattern.test(s);\n}\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    "
    },
    {
        "id": 66,
        "title": "Plus One",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits = \\[1,2,3\\]\n**Output:** \\[1,2,4\\]\n**Explanation:** The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be \\[1,2,4\\].\n\n",
                "**Example 2:**\n\n**Input:** digits = \\[4,3,2,1\\]\n**Output:** \\[4,3,2,2\\]\n**Explanation:** The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be \\[4,3,2,2\\].\n\n",
                "**Example 3:**\n\n**Input:** digits = \\[9\\]\n**Output:** \\[1,0\\]\n**Explanation:** The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be \\[1,0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= digits.length <= 100`\n*   `0 <= digits[i] <= 9`\n*   `digits` does not contain any leading `0`'s.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "[1,2,4]"
            },
            {
                "input": "[4,3,2,1]",
                "output": "[4,3,2,2]"
            },
            {
                "input": "[9]",
                "output": "[1,0]"
            }
        ],
        "java": "\n    ```java\npublic int[] plusOne(int[] digits) {\n    int n = digits.length;\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    int[] newDigits = new int[n + 1];\n    newDigits[0] = 1;\n    return newDigits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "python": "\n    ```python\ndef plusOne(digits: List[int]) -> List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n\n    digits.insert(0, 1)\n    return digits\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> plusOne(std::vector<int>& digits) {\n    int n = digits.size();\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "js": "\n    ```javascript\nfunction plusOne(digits) {\n    let n = digits.length;\n\n    for(let i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.unshift(1);\n    return digits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    "
    },
    {
        "id": 67,
        "title": "Add Binary",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two binary strings `a` and `b`, return _their sum as a binary string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = \"11\", b = \"1\"\n**Output:** \"100\"\n\n",
                "**Example 2:**\n\n**Input:** a = \"1010\", b = \"1011\"\n**Output:** \"10101\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a.length, b.length <= 104`\n*   `a` and `b` consist only of `'0'` or `'1'` characters.\n*   Each string does not contain leading zeros except for the zero itself.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Bit Manipulation",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"11\",\"1\"",
                "output": "\"100\""
            },
            {
                "input": "\"1010\",\"1011\"",
                "output": "\"10101\""
            }
        ],
        "java": "\n    ```java\npublic String addBinary(String a, String b) {\n    StringBuilder result = new StringBuilder();\n    int i = a.length() - 1, j = b.length() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry != 0) {\n        if (i >= 0) carry += a.charAt(i--) - '0';\n        if (j >= 0) carry += b.charAt(j--) - '0';\n        result.insert(0, carry % 2);\n        carry /= 2;\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "python": "\n    ```python\ndef addBinary(a: str, b: str) -> str:\n    result, carry, i, j = \"\", 0, len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        if i >= 0:\n            carry += int(a[i])\n            i -= 1\n        if j >= 0:\n            carry += int(b[j])\n            j -= 1\n        result = str(carry % 2) + result\n        carry //= 2\n    return result\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "c++": "\n    ```cpp\nstd::string addBinary(std::string a, std::string b) {\n    std::string result = \"\";\n    int i = a.size() - 1, j = b.size() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += a[i--] - '0';\n        if (j >= 0) carry += b[j--] - '0';\n        result = char(carry % 2 + '0') + result;\n        carry /= 2;\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "js": "\n    ```javascript\nfunction addBinary(a, b) {\n    let result = \"\";\n    let i = a.length - 1, j = b.length - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += parseInt(a[i--], 10);\n        if (j >= 0) carry += parseInt(b[j--], 10);\n        result = (carry % 2) + result;\n        carry = Math.floor(carry / 2);\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    "
    },
    {
        "id": 68,
        "title": "Text Justification",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n**Note:**\n\n*   A word is defined as a character sequence consisting of non-space characters only.\n*   Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.\n*   The input array `words` contains at least one word.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"This \",  \"is \",  \"an \",  \"example \",  \"of \",  \"text \",  \"justification. \"\\], maxWidth = 16\n**Output:**\n\\[\n    \"This    is    an \",\n    \"example  of text \",\n    \"justification.   \"\n\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"What \", \"must \", \"be \", \"acknowledgment \", \"shall \", \"be \"\\], maxWidth = 16\n**Output:**\n\\[\n   \"What   must   be \",\n   \"acknowledgment   \",\n   \"shall be         \"\n\\]\n**Explanation:** Note that the last line is  \"shall be     \" instead of  \"shall     be \", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"Science \", \"is \", \"what \", \"we \", \"understand \", \"well \", \"enough \", \"to \", \"explain \", \"to \", \"a \", \"computer. \", \"Art \", \"is \", \"everything \", \"else \", \"we \", \"do \"\\], maxWidth = 20\n**Output:**\n\\[\n   \"Science  is  what we \",\n   \"understand      well \",\n   \"enough to explain to \",\n   \"a  computer.  Art is \",\n   \"everything  else  we \",\n   \"do                   \"\n\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 300`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of only English letters and symbols.\n*   `1 <= maxWidth <= 100`\n*   `words[i].length <= maxWidth`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "[\"This\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"],16",
                "output": "\n[\n\"Thisisan\",\n\"exampleoftext\",\n\"justification.\"\n]"
            },
            {
                "input": "[\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"],16",
                "output": "\n[\n\"Whatmustbe\",\n\"acknowledgment\",\n\"shallbe\"\n]"
            },
            {
                "input": "[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"],20",
                "output": "\n[\n\"Scienceiswhatwe\",\n\"understandwell\",\n\"enoughtoexplainto\",\n\"acomputer.Artis\",\n\"everythingelsewe\",\n\"do\"\n]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> result = new ArrayList<>();\n    int idx = 0;\n    while (idx < words.length) {\n        int totalChars = words[idx].length();\n        int last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        StringBuilder line = new StringBuilder();\n        if (last == words.length || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) line.append(\" \");\n            }\n            while (line.length() < maxWidth) line.append(\" \");\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) {\n                    line.append(\" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));\n                }\n            }\n        }\n        idx = last;\n        result.add(line.toString());\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "python": "\n    ```python\ndef fullJustify(words, maxWidth):\n    result = []\n    idx = 0\n    while idx < len(words):\n        total_chars = len(words[idx])\n        last = idx + 1\n        while last < len(words):\n            if total_chars + 1 + len(words[last]) > maxWidth:\n                break\n            total_chars += 1 + len(words[last])\n            last += 1\n        gaps = last - idx - 1\n        line = []\n        if last == len(words) or gaps == 0:\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \")\n            while sum(len(w) for w in line) < maxWidth:\n                line.append(\" \")\n        else:\n            even_spaces = (maxWidth - total_chars) // gaps\n            extra_spaces = (maxWidth - total_chars) % gaps\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \" * (even_spaces + (1 if i - idx < extra_spaces else 0)))\n        idx = last\n        result.append(\"\".join(line))\n    return result\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int idx = 0;\n    while (idx < words.size()) {\n        int totalChars = words[idx].size();\n        int last = idx + 1;\n        while (last < words.size()) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        stringstream line;\n        if (last == words.size() || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) line << \" \";\n            }\n            line << string(maxWidth - line.str().size(), ' ');\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) {\n                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        idx = last;\n        result.push_back(line.str());\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "js": "\n    ```javascript\nfunction fullJustify(words, maxWidth) {\n    const result = [];\n    let idx = 0;\n    while (idx < words.length) {\n        let totalChars = words[idx].length;\n        let last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length > maxWidth) break;\n            totalChars += 1 + words[last].length;\n            last++;\n        }\n        const gaps = last - idx - 1;\n        let line = \"\";\n        if (last === words.length || gaps === 0) {\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) line += \" \";\n            }\n            while (line.length < maxWidth) line += \" \";\n        } else {\n            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);\n            const extraSpaces = (maxWidth - totalChars) % gaps;\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) {\n                    line += \" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));\n                }\n            }\n        }\n        idx = last;\n        result.push(line);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    "
    },
    {
        "id": 69,
        "title": "Sqrt(x)",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.\n\nYou **must not use** any built-in exponent function or operator.\n\n*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 4\n**Output:** 2\n**Explanation:** The square root of 4 is 2, so we return 2.\n\n",
                "**Example 2:**\n\n**Input:** x = 8\n**Output:** 2\n**Explanation:** The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= x <= 231 - 1`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "8",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "python": "\n    ```python\ndef mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "c++": "\n    ```cpp\nint mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "js": "\n    ```javascript\nfunction mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    "
    },
    {
        "id": 70,
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "content": {
            "problem": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 45`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "2",
                "output": "2"
            },
            {
                "input": "3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "python": "\n    ```python\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "c++": "\n    ```cpp\nint climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "js": "\n    ```javascript\nfunction climbStairs(n) {\n    if(n <= 2) return n;\n    let a = 1, b = 2, c;\n    for(let i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    "
    },
    {
        "id": 71,
        "title": "Simplify Path",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.\n\nIn a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.\n\nThe **canonical path** should have the following format:\n\n*   The path starts with a single slash `'/'`.\n*   Any two directories are separated by a single slash `'/'`.\n*   The path does not end with a trailing `'/'`.\n*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)\n\nReturn _the simplified **canonical path**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** path =  \"/home/ \"\n**Output:**  \"/home \"\n**Explanation:** Note that there is no trailing slash after the last directory name.\n\n",
                "**Example 2:**\n\n**Input:** path =  \"/../ \"\n**Output:**  \"/ \"\n**Explanation:** Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\n",
                "**Example 3:**\n\n**Input:** path =  \"/home//foo/ \"\n**Output:**  \"/home/foo \"\n**Explanation:** In the canonical path, multiple consecutive slashes are replaced by a single one."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= path.length <= 3000`\n*   `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n*   `path` is a valid absolute Unix path.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"/home/\"",
                "output": "\"/home\""
            },
            {
                "input": "\"/../\"",
                "output": "\"/\""
            },
            {
                "input": "\"/home//foo/\"",
                "output": "\"/home/foo\""
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\n\npublic String simplifyPath(String path) {\n    String[] parts = path.split(\"/\");\n    LinkedList<String> stack = new LinkedList<>();\n\n    for (String part : parts) {\n        if (part.isEmpty() || part.equals(\".\")) continue;\n        if (part.equals(\"..\")) {\n            if (!stack.isEmpty()) stack.removeLast();\n        } else {\n            stack.addLast(part);\n        }\n    }\n\n    StringBuilder canonicalPath = new StringBuilder();\n    for (String piece : stack) {\n        canonicalPath.append('/').append(piece);\n    }\n    return stack.isEmpty() ? \"/\" : canonicalPath.toString();\n}\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "python": "\n    ```python\ndef simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) {\n    std::vector<std::string> stack;\n    std::istringstream ss{path};\n    std::string part;\n\n    while (std::getline(ss, part, '/')) {\n        if (part.empty() || part == \".\") continue;\n        if (part == \"..\") {\n            if (!stack.empty()) stack.pop_back();\n        } else {\n            stack.push_back(part);\n        }\n    }\n\n    std::string canonicalPath;\n    for (const auto &piece : stack) {\n        canonicalPath += '/' + piece;\n    }\n    return stack.empty() ? \"/\" : canonicalPath;\n}\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "js": "\n    ```javascript\nfunction simplifyPath(path) {\n    let stack = [];\n    let parts = path.split(\"/\");\n\n    for (let part of parts) {\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) stack.pop();\n        } else {\n            stack.push(part);\n        }\n    }\n\n    return \"/\" + stack.join(\"/\");\n}\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    "
    },
    {
        "id": 76,
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window**_ **_substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `\" \"`.\n\nThe testcases will be generated such that the answer is **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ADOBECODEBANC \", t =  \"ABC \"\n**Output:**  \"BANC \"\n**Explanation:** The minimum window substring  \"BANC \" includes 'A', 'B', and 'C' from string t.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \", t =  \"a \"\n**Output:**  \"a \"\n**Explanation:** The entire string s is the minimum window.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a \", t =  \"aa \"\n**Output:**  \" \"\n**Explanation:** Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string."
            ],
            "constraints": "**Constraints:**\n\n*   `m == s.length`\n*   `n == t.length`\n*   `1 <= m, n <= 105`\n*   `s` and `t` consist of uppercase and lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Could you find an algorithm that runs in `O(m + n)` time?"
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"ADOBECODEBANC\",\"ABC\"",
                "output": "\"BANC\""
            },
            {
                "input": "\"a\",\"a\"",
                "output": "\"a\""
            },
            {
                "input": "\"a\",\"aa\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t) {\n    std::unordered_map<char, int> need, window;\n    for (char c : t) need[c]++;\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = INT_MAX;\n\n    while (right < s.length()) {\n        char c = s[right];\n        right++;\n        if (need.count(c)) {\n            window[c]++;\n            if (window[c] <= need[c]) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s[left];\n            left++;\n            if (need.count(d)) {\n                if (window[d] <= need[d]) valid--;\n                window[d]--;\n            }\n        }\n    }\n    return length == INT_MAX ? \"\" : s.substr(start, length);\n}\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    ",
        "js": "\n    ```javascript\nfunction minWindow(s, t) {\n    const need = new Map();\n    const window = new Map();\n\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    let left = 0, right = 0;\n    let valid = 0;\n    let start = 0, length = Infinity;\n\n    while (right < s.length) {\n        const c = s[right];\n        right++;\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid === t.length) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            const d = s[left];\n            left++;\n            if (need.has(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length === Infinity ? \"\" : s.substring(start, start + length);\n}\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    "
    },
    {
        "id": 78,
        "title": "Subsets",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[\\[\\],\\[1\\],\\[2\\],\\[1,2\\],\\[3\\],\\[1,3\\],\\[2,3\\],\\[1,2,3\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[\\[\\],\\[0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `-10 <= nums[i] <= 10`\n*   All the numbers of `nums` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
            },
            {
                "input": "[0]",
                "output": "[[],[0]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "python": "\n    ```python\ndef subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    int n = nums.size();\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        std::vector<int> subset;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push_back(nums[j]);\n            }\n        }\n        result.push_back(subset);\n    }\n    return result;\n}\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "js": "\n    ```javascript\nfunction subsets(nums) {\n    let result = [];\n    let n = nums.length;\n    let num_subsets = 1 << n;\n\n    for (let i = 0; i < num_subsets; ++i) {\n        let subset = [];\n        for (let j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push(nums[j]);\n            }\n        }\n        result.push(subset);\n    }\n    return result;\n}\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    "
    },
    {
        "id": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a sorted linked list, _delete all duplicates such that each element appears only once_. Return _the linked list **sorted** as well_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,1,2\\]\n**Output:** \\[1,2\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,1,2,3,3\\]\n**Output:** \\[1,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 300]`.\n*   `-100 <= Node.val <= 100`\n*   The list is guaranteed to be **sorted** in ascending order.",
            "follow_up": null
        },
        "tag": [
            "Linked List"
        ],
        "example": [
            {
                "input": "[1,1,2]",
                "output": "[1,2]"
            },
            {
                "input": "[1,1,2,3,3]",
                "output": "[1,2,3]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode current = head;\n    while (current != null && current.next != null) {\n        if (current.next.val == current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef delete_duplicates(head):\n    current = head\n    while current and current.next:\n        if current.next.val == current.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* deleteDuplicates(ListNode* head) {\n    ListNode* current = head;\n    while (current && current->next) {\n        if (current->next->val == current->val) {\n            ListNode* temp = current->next;\n            current->next = temp->next;\n            delete temp;\n        } else {\n            current = current->next;\n        }\n    }\n    return head;\n}\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction deleteDuplicates(head) {\n    let current = head;\n    while (current && current.next) {\n        if (current.next.val === current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n```\n    \n    The algorithm to delete all duplicates in a sorted linked list simply iterates through the list and compares the value of the current node with the value of the next. If both values are the same, it means that there is a duplicate, so the current node's \"next\" pointer is updated to point to the node after the duplicate. If the values are different, the algorithm continues iterating to the next node. The process continues until reaching the end of the list. Since the linked list is already sorted, this algorithm guarantees that duplicates will appear consecutively, allowing for their removal in linear time.\n    "
    },
    {
        "id": 85,
        "title": "Maximal Rectangle",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Stack",
            "Matrix",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                "output": "6"
            },
            {
                "input": "[[\"0\"]]",
                "output": "0"
            },
            {
                "input": "[[\"1\"]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[] height = new int[n + 1];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        Stack<Integer> s = new Stack<>();\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.peek()]) {\n                int h = height[s.pop()];\n                int w = s.empty() ? j : j - s.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "python": "\n    ```python\ndef maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty()) return 0;\n\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<int> height(n + 1, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        stack<int> s;\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.top()]) {\n                int h = height[s.top()];\n                s.pop();\n                int w = s.empty() ? j : j - s.top() - 1;\n                maxArea = max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "js": "\n    ```javascript\nfunction maximalRectangle(matrix) {\n    if (!matrix.length) return 0;\n\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let height = Array(n + 1).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < m; i++) {\n        let s = [];\n        for (let j = 0; j <= n; j++) {\n            if (j < n) {\n                height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;\n            }\n            while (s.length && height[j] < height[s[s.length - 1]]) {\n                let h = height[s.pop()];\n                let w = !s.length ? j : j - s[s.length - 1] - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    "
    },
    {
        "id": 87,
        "title": "Scramble String",
        "difficulty": "Hard",
        "content": {
            "problem": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"great \", s2 =  \"rgeat \"\n**Output:** true\n**Explanation:** One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"abcde \", s2 =  \"caebd \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s1 =  \"a \", s2 =  \"a \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `s1.length == s2.length`\n*   `1 <= s1.length <= 30`\n*   `s1` and `s2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"great\",\"rgeat\"",
                "output": "true"
            },
            {
                "input": "\"abcde\",\"caebd\"",
                "output": "false"
            },
            {
                "input": "\"a\",\"a\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "python": "\n    ```python\ndef isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "c++": "\n    ```cpp\nbool isScramble(string s1, string s2) {\n    if (s1 == s2) return true;\n    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;\n\n    for (int i = 1; i < s1.size(); i++) {\n        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\n            return true;\n        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))\n            return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "js": "\n    ```javascript\nfunction isScramble(s1, s2) {\n    if (s1 === s2) return true;\n    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;\n\n    for (let i = 1; i < s1.length; i++) {\n        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || \n            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))\n            return true;\n    }\n    return false;\n}\n\nfunction sorted(s) {\n    return s.split('').sort().join('');\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    "
    },
    {
        "id": 88,
        "title": "Merge Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\n\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
            ],
            "constraints": "**Constraints:**\n\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n\n**",
            "follow_up": "Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3,0,0,0],3,[2,5,6],3",
                "output": "[1,2,2,3,5,6]"
            },
            {
                "input": "[1],1,[],0",
                "output": "[1]"
            },
            {
                "input": "[0],0,[1],1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "python": "\n    ```python\ndef merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "c++": "\n    ```cpp\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "js": "\n    ```javascript\nfunction merge(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    "
    },
    {
        "id": 89,
        "title": "Gray Code",
        "difficulty": "Medium",
        "content": {
            "problem": "An **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n*   Every integer is in the **inclusive** range `[0, 2n - 1]`,\n*   The first integer is `0`,\n*   An integer appears **no more than once** in the sequence,\n*   The binary representation of every pair of **adjacent** integers differs by **exactly one bit**, and\n*   The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n`, return _any valid **n-bit gray code sequence**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,3,2\\]\n**Explanation:**\nThe binary representation of \\[0,1,3,2\\] is \\[00,01,11,10\\].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\\[0,2,3,1\\] is also a valid gray code sequence, whose binary representation is \\[00,10,11,01\\].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 16`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Backtracking",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "2",
                "output": "[0,1,3,2]"
            },
            {
                "input": "1",
                "output": "[0,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> grayCode(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < (1 << n); i++) {\n        result.add(i ^ (i >> 1));\n    }\n    return result;\n}\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "python": "\n    ```python\ndef grayCode(n):\n    result = []\n    for i in range(1 << n):\n        result.append(i ^ (i >> 1))\n    return result\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> grayCode(int n) {\n    std::vector<int> result;\n    for (int i = 0; i < (1 << n); i++) {\n        result.push_back(i ^ (i >> 1));\n    }\n    return result;\n}\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "js": "\n    ```javascript\nfunction grayCode(n) {\n    const result = [];\n    for (let i = 0; i < (1 << n); i++) {\n        result.push(i ^ (i >> 1));\n    }\n    return result;\n}\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    "
    },
    {
        "id": 91,
        "title": "Decode Ways",
        "difficulty": "Medium",
        "content": {
            "problem": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\n",
                "**Example 2:**\n\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\n",
                "**Example 3:**\n\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \")."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"12\"",
                "output": "2"
            },
            {
                "input": "\"226\"",
                "output": "3"
            },
            {
                "input": "\"06\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n        int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "python": "\n    ```python\ndef numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; ++i) {\n        int oneDigit = stoi(s.substr(i - 1, 1));\n        int twoDigits = stoi(s.substr(i - 2, 2));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "js": "\n    ```javascript\nvar numDecodings = function(s) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.slice(i - 1, i), 10);\n        const twoDigits = parseInt(s.slice(i - 2, i), 10);\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n};\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    "
    },
    {
        "id": 93,
        "title": "Restore IP Addresses",
        "difficulty": "Medium",
        "content": {
            "problem": "A **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.\n\n*   For example, `\"0.1.2.201 \"` and `\"192.168.1.1 \"` are **valid** IP addresses, but `\"0.011.255.245 \"`, `\"192.168.1.312 \"` and `\"192.168@1.1 \"` are **invalid** IP addresses.\n\nGiven a string `s` containing only digits, return _all possible valid IP addresses that can be formed by inserting dots into_ `s`. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"25525511135 \"\n**Output:** \\[ \"255.255.11.135 \", \"255.255.111.35 \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"0000 \"\n**Output:** \\[ \"0.0.0.0 \"\\]\n\n",
                "**Example 3:**\n\n**Input:** s =  \"101023 \"\n**Output:** \\[ \"1.0.10.23 \", \"1.0.102.3 \", \"10.1.0.23 \", \"10.10.2.3 \", \"101.0.2.3 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `s` consists of digits only.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking"
        ],
        "example": [
            {
                "input": "\"25525511135\"",
                "output": "[\"255.255.11.135\",\"255.255.111.35\"]"
            },
            {
                "input": "\"0000\"",
                "output": "[\"0.0.0.0\"]"
            },
            {
                "input": "\"101023\"",
                "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> restoreIpAddresses(String s) {\n    List<String> result = new ArrayList<>();\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nprivate void dfs(String s, int start, String ip, List<String> result, int part) {\n    if (part == 4 && start == s.length()) {\n        result.add(ip.substring(0, ip.length() - 1));\n        return;\n    }\n    if (part == 4 || start >= s.length()) return;\n\n    int num = 0;\n    for (int i = start; i < s.length(); i++) {\n        num = num * 10 + (s.charAt(i) - '0');\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s.charAt(i) + \".\", result, part + 1);\n        if (num == 0) break;\n    }\n}\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "python": "\n    ```python\ndef restore_ip_addresses(s):\n    def dfs(s, start, ip, result, part):\n        if part == 4 and start == len(s):\n            result.append(ip[:-1])\n            return\n        if part == 4 or start >= len(s):\n            return\n\n        num = 0\n        for i in range(start, len(s)):\n            num = num * 10 + int(s[i])\n            if num > 255:\n                break\n            dfs(s, i + 1, ip + s[i] + \".\", result, part + 1)\n            if num == 0:\n                break\n\n    result = []\n    dfs(s, 0, \"\", result, 0)\n    return result\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> restore_ip_address(string s) {\n    vector<string> result;\n    string ip;\n    dfs(result, s, ip, 0, 0);\n    return result;\n}\n\nvoid dfs(vector<string>& result, string s, string ip, int start, int part) {\n    if (part == 4 && start == s.size()) {\n        ip.pop_back();\n        result.push_back(ip);\n        return;\n    }\n    if (part == 4 || start == s.size()) return;\n\n    int num = 0;\n    for (int i = start; i < s.size(); i++) {\n        num = num * 10 + (s[i] - '0');\n        if (num > 255) break;\n        ip += s[i];\n        dfs(result, s, ip + '.', i + 1, part + 1);\n        if (num == 0) break;\n    }\n}\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "js": "\n    ```javascript\nfunction restoreIpAddresses(s) {\n    const result = [];\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nfunction dfs(s, start, ip, result, part) {\n    if (part === 4 && start === s.length) {\n        result.push(ip.slice(0, -1));\n        return;\n    }\n    if (part === 4 || start >= s.length) return;\n\n    let num = 0;\n    for (let i = start; i < s.length; i++) {\n        num = num * 10 + parseInt(s[i]);\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s[i] + \".\", result, part + 1);\n        if (num === 0) break;\n    }\n}\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    "
    },
    {
        "id": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the inorder traversal of its nodes' values_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,3,2\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,3]",
                "output": "[1,3,2]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    inorderTraversalHelper(root, result);\n    return result;\n}\n\nprivate void inorderTraversalHelper(TreeNode root, List<Integer> result) {\n    if (root == null) {\n        return;\n    }\n    inorderTraversalHelper(root.left, result);\n    result.add(root.val);\n    inorderTraversalHelper(root.right, result);\n}\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversalHelper(root, result):\n    if not root:\n        return\n    inorderTraversalHelper(root.left, result)\n    result.append(root.val)\n    inorderTraversalHelper(root.right, result)\n\ndef inorderTraversal(root):\n    result = []\n    inorderTraversalHelper(root, result)\n    return result\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvoid inorderTraversalHelper(TreeNode* root, vector<int>& result) {\n    if (!root) return;\n    inorderTraversalHelper(root->left, result);\n    result.push_back(root->val);\n    inorderTraversalHelper(root->right, result);\n}\n\nvector<int> inorderTraversal(TreeNode* root){\n    vector<int> result;\n    inorderTraversalHelper(root, result);\n    return result;\n}\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null){\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorderTraversalHelper(root, result) {\n    if (!root) return;\n    inorderTraversalHelper(root.left, result);\n    result.push(root.val);\n    inorderTraversalHelper(root.right, result);\n}\n\nfunction inorderTraversal(root) {\n    let result = [];\n    inorderTraversalHelper(root, result);\n    return result;\n}\n```\n    \n    The algorithm simply performs an inorder traversal on the given binary tree. An inorder traversal goes as follows: \n\n1. Traverse the left subtree, and call the function recursively for the left child.\n2. Visit the root.\n3. Traverse the right subtree, and call the function recursively for the right child.\n\nThis process is implemented by defining a helper function (`inorderTraversalHelper`) that takes a node and a `result` list (or vector in C++), and appends the node's value to the `result` list according to the inorder traversal order. The main `inorderTraversal` function initializes the result list and calls the helper function with the root of the tree. At the end, `inorderTraversal` returns the result list containing the values of the nodes in inorder traversal order.\n    "
    },
    {
        "id": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 19`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "3",
                "output": "5"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "python": "\n    ```python\ndef numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "c++": "\n    ```cpp\nint numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "js": "\n    ```javascript\nfunction numTrees(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    "
    },
    {
        "id": 100,
        "title": "Same Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
            "examples": [
                "**Example 1:**\n\n**Input:** p = \\[1,2,3\\], q = \\[1,2,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** p = \\[1,2\\], q = \\[1,null,2\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** p = \\[1,2,1\\], q = \\[1,1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 100]`.\n*   `-104 <= Node.val <= 104`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3],[1,2,3]",
                "output": "true"
            },
            {
                "input": "[1,2],[1,null,2]",
                "output": "false"
            },
            {
                "input": "[1,2,1],[1,1,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) {\n        return true;\n    }\n    if (p == null || q == null) {\n        return false;\n    }\n    if (p.val != q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p == nullptr && q == nullptr) {\n        return true;\n    }\n    if (p == nullptr || q == nullptr) {\n        return false;\n    }\n    if (p->val != q->val) {\n        return false;\n    }\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isSameTree(p, q) {\n    if (p === null && q === null) {\n        return true;\n    }\n    if (p === null || q === null) {\n        return false;\n    }\n    if (p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```\n\n    \n    The algorithm used is a recursive depth-first traversal of both trees. It will compare the nodes at each level of the tree, and return false if the nodes have different values or if one node is missing in one of the trees. The algorithm will only return true if all nodes in both trees are the same.\n\nAt each level, the function checks if both nodes are null, indicating we've reached the end of both trees and they must be the same. Then it checks if either node is null, indicating that one tree is missing a node and they cannot be the same. If both nodes have the same value, we then recursively check their left and right children. If both children are the same, the function returns true. If at any point nodes are found to be different, the function returns false.\n    "
    },
    {
        "id": 101,
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,2,3,4,4,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,2,null,3,null,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Could you solve it both recursively and iteratively?"
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,2,3,4,4,3]",
                "output": "true"
            },
            {
                "input": "[1,2,2,null,3,null,3]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isSymmetric(TreeNode root) {\n    return checkSymmetry(root, root);\n}\n\npublic boolean checkSymmetry(TreeNode node1, TreeNode node2) {\n    if (node1 == null && node2 == null) return true;\n    if (node1 == null || node2 == null) return false;\n    return (node1.val == node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "python": "\n    ```python\ndef isSymmetric(root):\n    return checkSymmetry(root, root)\n\ndef checkSymmetry(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "c++": "\n    ```cpp\nbool isSymmetric(TreeNode* root) {\n    return checkSymmetry(root, root);\n}\n\nbool checkSymmetry(TreeNode* node1, TreeNode* node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1->val == node2->val) && checkSymmetry(node1->right, node2->left) && checkSymmetry(node1->left, node2->right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "js": "\n    ```javascript\nfunction isSymmetric(root) {\n    return checkSymmetry(root, root);\n}\n\nfunction checkSymmetry(node1, node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1.val === node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    "
    },
    {
        "id": 104,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "3"
            },
            {
                "input": "[1,null,2]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "python": "\n    ```python\ndef maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "c++": "\n    ```cpp\nint maxDepth(TreeNode* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "js": "\n    ```javascript\nfunction maxDepth(root) {\n    if (root === null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    "
    },
    {
        "id": 108,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a_ **_height-balanced_** _binary search tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-10,-3,0,5,9\\]\n**Output:** \\[0,-3,9,-10,null,5\\]\n**Explanation:** \\[0,-10,5,null,-3,null,9\\] is also accepted:\n \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3\\]\n**Output:** \\[3,1\\]\n**Explanation:** \\[1,null,3\\] and \\[3,1\\] are both height-balanced BSTs."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in a **strictly increasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Tree",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[-10,-3,0,5,9]",
                "output": "[0,-3,9,-10,null,5]"
            },
            {
                "input": "[1,3]",
                "output": "[3,1]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return sortedArrayToBST(nums, 0, nums.length - 1);\n}\n\nprivate TreeNode sortedArrayToBST(int[] nums, int start, int end) {\n    if (start > end) return null;\n\n    int mid = start + (end - start) / 2;\n    TreeNode node = new TreeNode(nums[mid]);\n    node.left = sortedArrayToBST(nums, start, mid - 1);\n    node.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sorted_array_to_bst(nums):\n    def helper(start, end):\n        if start > end:\n            return None\n\n        mid = start + (end - start) // 2\n        node = TreeNode(nums[mid])\n        node.left = helper(start, mid - 1)\n        node.right = helper(mid + 1, end)\n\n        return node\n\n    return helper(0, len(nums) - 1)\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* sortedArrayToBST(std::vector<int>& nums, int start, int end) {\n    if (start > end) return nullptr;\n\n    int mid = start + (end - start) / 2;\n    TreeNode* node = new TreeNode(nums[mid]);\n    node->left = sortedArrayToBST(nums, start, mid - 1);\n    node->right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n\nTreeNode* sortedArrayToBST(std::vector<int>& nums) {\n    return sortedArrayToBST(nums, 0, nums.size() - 1);\n}\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction sortedArrayToBST(nums, start = 0, end = nums.length - 1) {\n    if (start > end) return null;\n\n    let mid = start + Math.floor((end - start) / 2);\n    let node = new TreeNode(nums[mid]);\n    node.left = sortedArrayToBST(nums, start, mid - 1);\n    node.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n```\n\n    \n    The algorithm for creating a height-balanced binary search tree from a sorted array can be described as follows:\n\n1. Find the middle element of the array, and make it the root of the binary search tree.\n2. For each half of the array (elements to the left of the middle element and elements to the right of the middle element), repeat step 1 recursively.\n3. The base case is when the start index is greater than the end index, in which case a null node is returned.\n\nThe above code implements this algorithm in C++, Java, Python, and JavaScript.\n    "
    },
    {
        "id": 110,
        "title": "Balanced Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary tree, determine if it is **height-balanced**.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,2,3,3,null,null,4,4\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-104 <= Node.val <= 104`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "true"
            },
            {
                "input": "[1,2,2,3,3,null,null,4,4]",
                "output": "false"
            },
            {
                "input": "[]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int getHeight(TreeNode node) {\n    if (node == null) return 0;\n    int leftHeight = getHeight(node.left);\n    int rightHeight = getHeight(node.right);\n    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\npublic boolean isBalanced(TreeNode root) {\n    return getHeight(root) != -1;\n}\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef getHeight(node):\n    if not node:\n        return 0\n    left_height = getHeight(node.left)\n    right_height = getHeight(node.right)\n    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n        return -1\n    return 1 + max(left_height, right_height)\n\ndef isBalanced(root):\n    return getHeight(root) != -1\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint getHeight(TreeNode* node) {\n    if (!node) return 0;\n    int leftHeight = getHeight(node->left);\n    int rightHeight = getHeight(node->right);\n    if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + max(leftHeight, rightHeight);\n}\n\nbool isBalanced(TreeNode* root) {\n    return getHeight(root) != -1;\n}\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction getHeight(node) {\n    if (!node) return 0;\n    let leftHeight = getHeight(node.left);\n    let rightHeight = getHeight(node.right);\n    if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\nfunction isBalanced(root) {\n    return getHeight(root) !== -1;\n}\n```\n\n    \n    The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.\n\nThe `getHeight` function works as follows:\n1. If the current node is null, return 0 (base case).\n2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).\n3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.\n4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.\n\nThe main function `isBalanced` just calls the `getHeight` function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.\n    "
    },
    {
        "id": 111,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n**Note:** A leaf is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "2"
            },
            {
                "input": "[2,null,3,null,4,null,5,null,6]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minDepth(TreeNode root) {\n    if (root == null) return 0;\n    int left = minDepth(root.left);\n    int right = minDepth(root.right);\n    return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "python": "\n    ```python\ndef minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "c++": "\n    ```cpp\nint minDepth(TreeNode* root) {\n    if (!root) return 0;\n    int left = minDepth(root->left);\n    int right = minDepth(root->right);\n    return (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "js": "\n    ```javascript\nfunction minDepth(root) {\n    if (!root) return 0;\n    let left = minDepth(root.left);\n    let right = minDepth(root.right);\n    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    "
    },
    {
        "id": 112,
        "title": "Path Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\n\nA **leaf** is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[5,4,8,11,null,13,4,7,2,null,null,null,1],22",
                "output": "true"
            },
            {
                "input": "[1,2,3],5",
                "output": "false"
            },
            {
                "input": "[],0",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n    if (root.left == null && root.right == null) return targetSum - root.val == 0;\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return targetSum - root.val == 0\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nbool hasPathSum(TreeNode* root, int targetSum) {\n    if (!root) return false;\n    if (!root->left && !root->right) return targetSum - root->val == 0;\n    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\n}\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction hasPathSum(root, targetSum) {\n    if (!root) return false;\n    if (!root.left && !root.right) return targetSum - root.val === 0;\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n```\n    \n    The algorithm starts at the root of the tree and performs a depth-first search. If the root is null, the function returns false as there is no path for the empty tree. If the root is a leaf node, the function checks if the targetSum is equal to the value of the root node.\n\nThen for non-leaf nodes, it checks if there exists a root-to-leaf path in the left or right subtree by recursively calling the function on the child nodes. The targetSum is updated by subtracting the value of the current node i.e., `targetSum - root.val`.\n\nThis process continues until a leaf node satisfying the targetSum is found, or all the paths have been explored and there's no match.\n    "
    },
    {
        "id": 115,
        "title": "Distinct Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"rabbbit \", t =  \"rabbit \"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`\n\n",
                "**Example 2:**\n\n**Input:** s =  \"babgbag \", t =  \"bag \"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 1000`\n*   `s` and `t` consist of English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"rabbbit\",\"rabbit\"",
                "output": "3"
            },
            {
                "input": "\"babgbag\",\"bag\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "python": "\n    ```python\ndef numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "c++": "\n    ```cpp\nint numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "js": "\n    ```javascript\nfunction numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    "
    },
    {
        "id": 118,
        "title": "Pascal's Triangle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:",
            "examples": [
                "**Example 1:**\n\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= numRows <= 30`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5",
                "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
            },
            {
                "input": "1",
                "output": "[[1]]"
            }
        ],
        "java": "\n    ```java\npublic List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> pascalsTriangle = new ArrayList<>();\n    for (int i = 0; i < numRows; i++) {\n        List<Integer> row = new ArrayList<>();\n        row.add(1);\n        for (int j = 1; j < i; j++) {\n            row.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));\n        }\n        if (i > 0) row.add(1);\n        pascalsTriangle.add(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "python": "\n    ```python\ndef generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "c++": "\n    ```cpp\nvector<vector<int>> generate(int numRows) {\n    vector<vector<int>> pascalsTriangle(numRows);\n    for (int i = 0; i < numRows; i++) {\n        pascalsTriangle[i].resize(i + 1);\n        pascalsTriangle[i][0] = pascalsTriangle[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            pascalsTriangle[i][j] = pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j];\n        }\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "js": "\n    ```javascript\nfunction generate(numRows) {\n    const pascalsTriangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        for (let j = 1; j < i; j++) {\n            row.push(pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j]);\n        }\n        if (i > 0) row.push(1);\n        pascalsTriangle.push(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    "
    },
    {
        "id": 119,
        "title": "Pascal's Triangle II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:",
            "examples": [
                "**Example 1:**\n\n**Input:** rowIndex = 3\n**Output:** \\[1,3,3,1\\]\n\n",
                "**Example 2:**\n\n**Input:** rowIndex = 0\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** rowIndex = 1\n**Output:** \\[1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= rowIndex <= 33`\n\n**",
            "follow_up": "Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?"
        },
        "tag": [],
        "example": [
            {
                "input": "3",
                "output": "[1,3,3,1]"
            },
            {
                "input": "0",
                "output": "[1]"
            },
            {
                "input": "1",
                "output": "[1,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "python": "\n    ```python\ndef get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex) {\n    vector<int> row(rowIndex + 1, 1);\n    for (int i = 1; i <= rowIndex; i++) {\n        for (int j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "js": "\n    ```javascript\nfunction getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(1);\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    "
    },
    {
        "id": 120,
        "title": "Triangle",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.",
            "examples": [
                "**Example 1:**\n\n**Input:** triangle = \\[\\[2\\],\\[3,4\\],\\[6,5,7\\],\\[4,1,8,3\\]\\]\n**Output:** 11\n**Explanation:** The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n",
                "**Example 2:**\n\n**Input:** triangle = \\[\\[-10\\]\\]\n**Output:** -10"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= triangle.length <= 200`\n*   `triangle[0].length == 1`\n*   `triangle[i].length == triangle[i - 1].length + 1`\n*   `-104 <= triangle[i][j] <= 104`\n\n**",
            "follow_up": "Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?"
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[[2],[3,4],[6,5,7],[4,1,8,3]]",
                "output": "11"
            },
            {
                "input": "[[-10]]",
                "output": "-10"
            }
        ],
        "java": "\n    ```java\npublic int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "python": "\n    ```python\ndef minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "c++": "\n    ```cpp\nint minimumTotal(vector<vector<int>>& triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle[row].size(); col++) {\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "js": "\n    ```javascript\nfunction minimumTotal(triangle) {\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    "
    },
    {
        "id": 121,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[7,1,5,3,6,4]",
                "output": "5"
            },
            {
                "input": "[7,6,4,3,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    "
    },
    {
        "id": 122,
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n",
                "**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[7,1,5,3,6,4]",
                "output": "7"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "4"
            },
            {
                "input": "[7,6,4,3,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "python": "\n    ```python\ndef max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(prices) {\n    let max_profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    "
    },
    {
        "id": 124,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "6"
            },
            {
                "input": "[-10,9,20,null,null,15,7]",
                "output": "42"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int maxPathSum(TreeNode root) {\n    int[] maxSum = new int[]{Integer.MIN_VALUE};\n    helper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int helper(TreeNode root, int[] maxSum) {\n    if (root == null) return 0;\n\n    int left = Math.max(0, helper(root.left, maxSum));\n    int right = Math.max(0, helper(root.right, maxSum));\n\n    maxSum[0] = Math.max(maxSum[0], left + right + root.val);\n\n    return Math.max(left, right) + root.val;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint helper(TreeNode* root, int& maxSum) {\n    if(!root) return 0;\n\n    int left = max(0, helper(root->left, maxSum));\n    int right = max(0, helper(root->right, maxSum));\n\n    maxSum = max(maxSum, left + right + root->val);\n\n    return max(left, right) + root->val;\n}\n\nint maxPathSum(TreeNode* root) {\n    int maxSum = INT_MIN;\n    helper(root, maxSum);\n    return maxSum;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction maxPathSum(root) {\n    let maxSum = Number.MIN_SAFE_INTEGER;\n    \n    function helper(node) {\n        if (node === null) return 0;\n        \n        const left = Math.max(0, helper(node.left));\n        const right = Math.max(0, helper(node.right));\n        \n        maxSum = Math.max(maxSum, left + right + node.val);\n        \n        return Math.max(left, right) + node.val;\n    }\n    \n    helper(root);\n    return maxSum;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    "
    },
    {
        "id": 125,
        "title": "Valid Palindrome",
        "difficulty": "Easy",
        "content": {
            "problem": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"A man, a plan, a canal: Panama \"\n**Output:** true\n**Explanation:**  \"amanaplanacanalpanama \" is a palindrome.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"race a car \"\n**Output:** false\n**Explanation:**  \"raceacar \" is not a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"  \"\n**Output:** true\n**Explanation:** s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"Aman,",
                "output": "true"
            },
            {
                "input": "\"raceacar\"",
                "output": "false"
            },
            {
                "input": "\"\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isPalindrome(String s) {\n    StringBuilder cleaned = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            cleaned.append(Character.toLowerCase(c));\n        }\n    }\n    int left = 0, right = cleaned.length() - 1;\n    while (left < right) {\n        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "python": "\n    ```python\ndef isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\n\nbool isPalindrome(std::string s) {\n    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(s) {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    let left = 0, right = cleaned.length - 1;\n    while (left < right) {\n        if (cleaned[left++] !== cleaned[right--]) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    "
    },
    {
        "id": 126,
        "title": "Word Ladder II",
        "difficulty": "Hard",
        "content": {
            "problem": "A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n*   Every adjacent pair of words differs by a single letter.\n*   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n*   `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _all the **shortest transformation sequences** from_ `beginWord` _to_ `endWord`_, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words_ `[beginWord, s1, s2, ..., sk]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \", \"cog \"\\]\n**Output:** \\[\\[ \"hit \", \"hot \", \"dot \", \"dog \", \"cog \"\\],\\[ \"hit \", \"hot \", \"lot \", \"log \", \"cog \"\\]\\]\n**Explanation:** There are 2 shortest transformation sequences:\n \"hit \" ->  \"hot \" ->  \"dot \" ->  \"dog \" ->  \"cog \"\n \"hit \" ->  \"hot \" ->  \"lot \" ->  \"log \" ->  \"cog \"\n\n",
                "**Example 2:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \"\\]\n**Output:** \\[\\]\n**Explanation:** The endWord  \"cog \" is not in wordList, therefore there is no valid transformation sequence."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= beginWord.length <= 5`\n*   `endWord.length == beginWord.length`\n*   `1 <= wordList.length <= 500`\n*   `wordList[i].length == beginWord.length`\n*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n*   `beginWord != endWord`\n*   All the words in `wordList` are **unique**.\n*   The **sum** of all shortest transformation sequences does not exceed `105`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]"
            },
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef findLadders(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return []\n\n    adjacent = defaultdict(list)\n    distance = defaultdict(int)\n    queue = deque([beginWord])\n    distance[beginWord] = 0\n    \n    def neighbors(word):\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z') + 1):\n                yield word[:i] + chr(j) + word[i + 1:]\n                \n    while queue:\n        current = queue.popleft()\n        if current == endWord:\n            break\n        for neighbor in neighbors(current):\n            if neighbor not in wordList:\n                continue\n            if neighbor not in distance:\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n            if distance[neighbor] == distance[current] + 1:\n                adjacent[current].append(neighbor)\n\n    result = []\n    path = [beginWord]\n\n    def backtrack(word):\n        if word == endWord:\n            result.append(path[:])\n        else:\n            for next_word in adjacent[word]:\n                path.append(next_word)\n                backtrack(next_word)\n                path.pop()\n                \n    backtrack(beginWord)\n    return result\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    ",
        "js": "\n    ```javascript\nfunction findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    "
    },
    {
        "id": 127,
        "title": "Word Ladder",
        "difficulty": "Hard",
        "content": {
            "problem": "A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n*   Every adjacent pair of words differs by a single letter.\n*   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n*   `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _the **number of words** in the **shortest transformation sequence** from_ `beginWord` _to_ `endWord`_, or_ `0` _if no such sequence exists._",
            "examples": [
                "**Example 1:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \", \"cog \"\\]\n**Output:** 5\n**Explanation:** One shortest transformation sequence is  \"hit \" ->  \"hot \" ->  \"dot \" ->  \"dog \" -> cog \", which is 5 words long.\n\n",
                "**Example 2:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \"\\]\n**Output:** 0\n**Explanation:** The endWord  \"cog \" is not in wordList, therefore there is no valid transformation sequence."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= beginWord.length <= 10`\n*   `endWord.length == beginWord.length`\n*   `1 <= wordList.length <= 5000`\n*   `wordList[i].length == beginWord.length`\n*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n*   `beginWord != endWord`\n*   All the words in `wordList` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "5"
            },
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        size = len(q)\n        current_level = set()\n        \n        for _ in range(size):\n            current_word = q.popleft()\n            if current_word == endWord:\n                return steps\n\n            word_chars = list(current_word)\n            for i in range(len(word_chars)):\n                original_char = word_chars[i]\n                for j in range(26):\n                    word_chars[i] = chr(ord('a') + j)\n                    new_word = ''.join(word_chars)\n                    if new_word in word_set:\n                        q.append(new_word)\n                        current_level.add(new_word)\n                        \n                word_chars[i] = original_char\n        \n        word_set -= current_level\n        steps += 1\n        \n    return 0\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (!dict.count(endWord)) return 0;\n\n    std::queue<std::string> q;\n    q.push(beginWord);\n    int steps = 1;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            std::string currentWord = q.front();\n            q.pop();\n            if (currentWord == endWord) return steps;\n\n            for (char& c : currentWord) {\n                char originalChar = c;\n                for (int j = 0; j < 26; ++j) {\n                    c = 'a' + j;\n                    if (dict.count(currentWord)) {\n                        q.push(currentWord);\n                        dict.erase(currentWord);\n                    }\n                }\n                c = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    ",
        "js": "\n    ```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    "
    },
    {
        "id": 128,
        "title": "Longest Consecutive Sequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[100,4,200,1,3,2\\]\n**Output:** 4\n**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,3,7,2,5,8,4,6,0,1\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Union Find"
        ],
        "example": [
            {
                "input": "[100,4,200,1,3,2]",
                "output": "4"
            },
            {
                "input": "[0,3,7,2,5,8,4,6,0,1]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "python": "\n    ```python\ndef longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "c++": "\n    ```cpp\nint longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "js": "\n    ```javascript\nfunction longestConsecutive(nums) {\n    const elements = new Set(nums);\n    let longestSeq = 0;\n\n    for (const num of nums) {\n        if (!elements.has(num - 1)) {\n            let currentNum = num;\n            let currentSeq = 1;\n\n            while (elements.has(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n\n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n\n    return longestSeq;\n}\n```\n\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    "
    },
    {
        "id": 133,
        "title": "Clone Graph",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a reference of a node in a **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.\n\nReturn a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n\nclass Node {\n    public int val;\n    public List neighbors;\n}\n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.",
            "examples": [
                "**Example 1:**\n\n**Input:** adjList = \\[\\[2,4\\],\\[1,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Output:** \\[\\[2,4\\],\\[1,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Explanation:** There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n",
                "**Example 2:**\n\n**Input:** adjList = \\[\\[\\]\\]\n**Output:** \\[\\[\\]\\]\n**Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n",
                "**Example 3:**\n\n**Input:** adjList = \\[\\]\n**Output:** \\[\\]\n**Explanation:** This an empty graph, it does not have any nodes."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the graph is in the range `[0, 100]`.\n*   `1 <= Node.val <= 100`\n*   `Node.val` is unique for each node.\n*   There are no repeated edges and no self-loops in the graph.\n*   The Graph is connected and all nodes can be visited starting from the given node.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "example": [
            {
                "input": "[[2,4],[1,3],[2,4],[1,3]]",
                "output": "[[2,4],[1,3],[2,4],[1,3]]"
            },
            {
                "input": "[[]]",
                "output": "[[]]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n\n    public Node(int val) {\n        this.val = val;\n        this.neighbors = new ArrayList<>();\n    }\n}\n\npublic Node cloneGraph(Node node, Map<Node, Node> visited) {\n    if (node == null) {\n        return null;\n    }\n\n    if (visited.containsKey(node)) {\n        return visited.get(node);\n    }\n\n    Node cloneNode = new Node(node.val);\n    visited.put(node, cloneNode);\n\n    for (Node neighbor : node.neighbors) {\n        cloneNode.neighbors.add(cloneGraph(neighbor, visited));\n    }\n\n    return cloneNode;\n}\n\npublic Node cloneGraph(Node node) {\n    Map<Node, Node> visited = new HashMap<>();\n    return cloneGraph(node, visited);\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to traverse the graph and make a deep copy of the nodes. Here is the algorithm:\n\n1. Create a `visited` dictionary (C++: `unordered_map`, Java: `HashMap`, Python: `dict`, JavaScript: `Map`) to track visited nodes and keep their clones.\n2. Define a recursive helper function `cloneGraph` that takes a node and the visited dictionary as input.\n3. If the input node is `null`, return `null`.\n4. If the input node is already in the visited dictionary, return its clone.\n5. Otherwise, create a new clone node with the same value as the input node, and add it to the visited dictionary.\n6. Iterate through the neighbors of the input node, and call the `cloneGraph` helper function recursively for each neighbor, adding the returned clones to the clone node's neighbors.\n7. Return the clone node.\n\nFinally, call the `cloneGraph` helper function with the given node and the initially empty visited dictionary.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node, visited=None):\n    if node is None:\n        return None\n\n    if visited is None:\n        visited = {}\n\n    if node in visited:\n        return visited[node]\n\n    cloneNode = Node(node.val)\n    visited[node] = cloneNode\n\n    for neighbor in node.neighbors:\n        cloneNode.neighbors.append(cloneGraph(neighbor, visited))\n\n    return cloneNode\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to traverse the graph and make a deep copy of the nodes. Here is the algorithm:\n\n1. Create a `visited` dictionary (C++: `unordered_map`, Java: `HashMap`, Python: `dict`, JavaScript: `Map`) to track visited nodes and keep their clones.\n2. Define a recursive helper function `cloneGraph` that takes a node and the visited dictionary as input.\n3. If the input node is `null`, return `null`.\n4. If the input node is already in the visited dictionary, return its clone.\n5. Otherwise, create a new clone node with the same value as the input node, and add it to the visited dictionary.\n6. Iterate through the neighbors of the input node, and call the `cloneGraph` helper function recursively for each neighbor, adding the returned clones to the clone node's neighbors.\n7. Return the clone node.\n\nFinally, call the `cloneGraph` helper function with the given node and the initially empty visited dictionary.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n};\n\nNode* cloneGraph(Node* node, unordered_map<Node*, Node*>& visited) {\n    if (node == nullptr) {\n        return nullptr;\n    }\n\n    if (visited.find(node) != visited.end()) {\n        return visited[node];\n    }\n\n    Node* cloneNode = new Node(node->val);\n    visited[node] = cloneNode;\n\n    for (Node* neighbor : node->neighbors) {\n        cloneNode->neighbors.push_back(cloneGraph(neighbor, visited));\n    }\n\n    return cloneNode;\n}\n\nNode* cloneGraph(Node* node) {\n    unordered_map<Node*, Node*> visited;\n    return cloneGraph(node, visited);\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to traverse the graph and make a deep copy of the nodes. Here is the algorithm:\n\n1. Create a `visited` dictionary (C++: `unordered_map`, Java: `HashMap`, Python: `dict`, JavaScript: `Map`) to track visited nodes and keep their clones.\n2. Define a recursive helper function `cloneGraph` that takes a node and the visited dictionary as input.\n3. If the input node is `null`, return `null`.\n4. If the input node is already in the visited dictionary, return its clone.\n5. Otherwise, create a new clone node with the same value as the input node, and add it to the visited dictionary.\n6. Iterate through the neighbors of the input node, and call the `cloneGraph` helper function recursively for each neighbor, adding the returned clones to the clone node's neighbors.\n7. Return the clone node.\n\nFinally, call the `cloneGraph` helper function with the given node and the initially empty visited dictionary.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, neighbors) {\n        this.val = val === undefined ? 0 : val;\n        this.neighbors = neighbors === undefined ? [] : neighbors;\n    }\n}\n\nfunction cloneGraph(node, visited = new Map()) {\n    if (node === null) {\n        return null;\n    }\n\n    if (visited.has(node)) {\n        return visited.get(node);\n    }\n\n    const cloneNode = new Node(node.val);\n    visited.set(node, cloneNode);\n\n    for (const neighbor of node.neighbors) {\n        cloneNode.neighbors.push(cloneGraph(neighbor, visited));\n    }\n\n    return cloneNode;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to traverse the graph and make a deep copy of the nodes. Here is the algorithm:\n\n1. Create a `visited` dictionary (C++: `unordered_map`, Java: `HashMap`, Python: `dict`, JavaScript: `Map`) to track visited nodes and keep their clones.\n2. Define a recursive helper function `cloneGraph` that takes a node and the visited dictionary as input.\n3. If the input node is `null`, return `null`.\n4. If the input node is already in the visited dictionary, return its clone.\n5. Otherwise, create a new clone node with the same value as the input node, and add it to the visited dictionary.\n6. Iterate through the neighbors of the input node, and call the `cloneGraph` helper function recursively for each neighbor, adding the returned clones to the clone node's neighbors.\n7. Return the clone node.\n\nFinally, call the `cloneGraph` helper function with the given node and the initially empty visited dictionary.\n    "
    },
    {
        "id": 134,
        "title": "Gas Station",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**",
            "examples": [
                "**Example 1:**\n\n**Input:** gas = \\[1,2,3,4,5\\], cost = \\[3,4,5,1,2\\]\n**Output:** 3\n**Explanation:**\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n",
                "**Example 2:**\n\n**Input:** gas = \\[2,3,4\\], cost = \\[3,4,3\\]\n**Output:** -1\n**Explanation:**\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start."
            ],
            "constraints": "**Constraints:**\n\n*   `n == gas.length == cost.length`\n*   `1 <= n <= 105`\n*   `0 <= gas[i], cost[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5],[3,4,5,1,2]",
                "output": "3"
            },
            {
                "input": "[2,3,4],[3,4,3]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int canCompleteCircuit(int[] gas, int[] cost) {\n    int totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (int i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "python": "\n    ```python\ndef can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "c++": "\n    ```cpp\nint can_complete_circuit(vector<int>& gas, vector<int>& cost) {\n    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;\n    for (int i = 0; i < gas.size(); ++i) {\n        total_gas += gas[i];\n        total_cost += cost[i];\n        gas_tank += gas[i] - cost[i];\n        if (gas_tank < 0) {\n            start = i + 1;\n            gas_tank = 0;\n        }\n    }\n    return (total_gas < total_cost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "js": "\n    ```javascript\nfunction canCompleteCircuit(gas, cost) {\n    let totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (let i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    "
    },
    {
        "id": 135,
        "title": "Candy",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_.",
            "examples": [
                "**Example 1:**\n\n**Input:** ratings = \\[1,0,2\\]\n**Output:** 5\n**Explanation:** You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n",
                "**Example 2:**\n\n**Input:** ratings = \\[1,2,2\\]\n**Output:** 4\n**Explanation:** You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `n == ratings.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= ratings[i] <= 2 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,0,2]",
                "output": "5"
            },
            {
                "input": "[1,2,2]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "python": "\n    ```python\ndef min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "js": "\n    ```javascript\nfunction minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    "
    },
    {
        "id": 136,
        "title": "Single Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,2,1\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,1,2,1,2\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`\n*   Each element in the array appears twice except for one element which appears only once.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[2,2,1]",
                "output": "1"
            },
            {
                "input": "[4,1,2,1,2]",
                "output": "4"
            },
            {
                "input": "[1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int singleNumber(int[] nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "python": "\n    ```python\ndef singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "c++": "\n    ```cpp\nint singleNumber(vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "js": "\n    ```javascript\nfunction singleNumber(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    "
    },
    {
        "id": 137,
        "title": "Single Number II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. _Find the single element and return it_.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,2,3,2\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,0,1,0,1,99\\]\n**Output:** 99"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-231 <= nums[i] <= 231 - 1`\n*   Each element in `nums` appears exactly **three times** except for one element which appears **once**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[2,2,3,2]",
                "output": "3"
            },
            {
                "input": "[0,1,0,1,0,1,99]",
                "output": "99"
            }
        ],
        "java": "\n    ```java\npublic int singleNumber(int[] nums) {\n    int ones = 0, twos = 0;\n    for (int n : nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "python": "\n    ```python\ndef singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "c++": "\n    ```cpp\nint singleNumber(vector<int>& nums) {\n    int ones = 0, twos = 0;\n    for (int n : nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "js": "\n    ```javascript\nfunction singleNumber(nums) {\n    let ones = 0, twos = 0;\n    for (let n of nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    "
    },
    {
        "id": 140,
        "title": "Word Break II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"catsanddog \", wordDict = \\[ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"\\]\n**Output:** \\[ \"cats and dog \", \"cat sand dog \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"pineapplepenapple \", wordDict = \\[ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"\\]\n**Output:** \\[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"\\]\n**Explanation:** Note that you are allowed to reuse a dictionary word.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 10`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\n*   Input is generated in a way that the length of the answer doesn't exceed 105.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Dynamic Programming",
            "Backtracking",
            "Trie",
            "Memoization"
        ],
        "example": [
            {
                "input": "\"catsanddog\",[\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
                "output": "[\"catsanddog\",\"catsanddog\"]"
            },
            {
                "input": "\"pineapplepenapple\",[\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
                "output": "[\"pineapplepenapple\",\"pineapplepenapple\",\"pineapplepenapple\"]"
            },
            {
                "input": "\"catsandog\",[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "python": "\n    ```python\ndef word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {\n    if (memo.count(s)) return memo[s];\n\n    std::vector<std::string> res;\n    if (dict.count(s)) res.push_back(s);\n\n    for (int i = 1; i < s.size(); ++i) {\n        std::string prefix = s.substr(0, i);\n        if (!dict.count(prefix)) continue;\n        std::string suffix = s.substr(i);\n        auto temp = helper(suffix, dict, memo);\n        for (const auto& t : temp) {\n            res.push_back(prefix + \" \" + t);\n        }\n    }\n    memo[s] = res;\n    return res;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::unordered_map<std::string, std::vector<std::string>> memo;\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "js": "\n    ```javascript\nfunction wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const memo = {};\n\n    function helper(s, dict, memo) {\n        if (s in memo) {\n            return memo[s];\n        }\n        \n        const res = [];\n        if (dict.has(s)) {\n            res.push(s);\n        }\n        \n        for (let i = 1; i < s.length; ++i) {\n            const prefix = s.slice(0, i);\n            if (!dict.has(prefix)) continue;\n            const suffix = s.slice(i);\n            const temp = helper(suffix, dict, memo);\n            for (const t of temp) {\n                res.push(prefix + \" \" + t);\n            }\n        }\n\n        memo[s] = res;\n        return res;\n    }\n\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    "
    },
    {
        "id": 141,
        "title": "Linked List Cycle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n\n",
                "**Example 3:**\n\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list."
            ],
            "constraints": "**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**",
            "follow_up": "Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?"
        },
        "tag": [
            "Hash Table",
            "Linked List",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[3,2,0,-4],1",
                "output": "true"
            },
            {
                "input": "[1,2],0",
                "output": "true"
            },
            {
                "input": "[1],-1",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "python": "\n    ```python\ndef hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool hasCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "js": "\n    ```javascript\nfunction hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    "
    },
    {
        "id": 144,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,3]",
                "output": "[1,2,3]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    \n    if (root == null) {\n        return result;\n    }\n    \n    result.add(root.val);\n    result.addAll(preorderTraversal(root.left));\n    result.addAll(preorderTraversal(root.right));\n \n    return result;\n}\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef preorderTraversal(root):\n    if root is None:\n        return []\n        \n    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<int> preorderTraversal(TreeNode* root) {\n    std::vector<int> result;\n    if (root == nullptr) {\n        return result;\n    }\n    \n    result.push_back(root->val);\n    std::vector<int> left = preorderTraversal(root->left);\n    std::vector<int> right = preorderTraversal(root->right);\n    \n    result.insert(result.end(), left.begin(), left.end());\n    result.insert(result.end(), right.begin(), right.end());\n    \n    return result;\n}\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction preorderTraversal(root) {\n    if (!root) {\n        return [];\n    }\n    \n    let result = [root.val];\n    result = result.concat(preorderTraversal(root.left));\n    result = result.concat(preorderTraversal(root.right));\n    \n    return result;\n}\n```\n    \n    The algorithm performs a preorder traversal of the binary tree, which involves visiting the root node, then the left subtree, and finally the right subtree. This is a simple recursive algorithm: \n\n1. If the binary tree is empty (i.e., the root is `null`), return an empty list.\n2. For a non-empty binary tree with root `r`, left subtree `left`, and right subtree `right`, return a list containing:\n\n    - `r.val`\n    - The elements of the list returned by the call `preorderTraversal(left)`.\n    - The elements of the list returned by the call `preorderTraversal(right)`.\n\nNote that this algorithm can be implemented in each language using similar concepts, but the syntax for concatenating lists in each language may differ.\n    "
    },
    {
        "id": 145,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the postorder traversal of its nodes' values_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[3,2,1\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of the nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Recursive solution is trivial, could you do it iteratively?"
        },
        "tag": [
            "Stack",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,null,2,3]",
                "output": "[3,2,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Stack<TreeNode> s = new Stack<>();\n\n    if (root == null) return result;\n\n    s.push(root);\n    while (!s.isEmpty()) {\n        TreeNode current = s.pop();\n        result.add(0, current.val);\n        if (current.left != null) s.push(current.left);\n        if (current.right != null) s.push(current.right);\n    }\n\n    return result;\n}\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef postorderTraversal(root):\n    if not root:\n        return []\n\n    result = []\n    s = [root]\n    while s:\n        current = s.pop()\n        result.insert(0, current.val)\n        if current.left:\n            s.append(current.left)\n        if current.right:\n            s.append(current.right)\n\n    return result\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> postorderTraversal(TreeNode* root) {\n    vector<int> result;\n    stack<TreeNode*> s;\n\n    if (!root) return result;\n\n    s.push(root);\n    while (!s.empty()) {\n        TreeNode *current = s.top();\n        s.pop();\n        result.insert(result.begin(), current->val);\n        if (current->left) s.push(current->left);\n        if (current->right) s.push(current->right);\n    }\n\n    return result;\n}\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction postorderTraversal(root) {\n    if (!root) {\n        return [];\n    }\n\n    let result = [];\n    let s = [root];\n    while (s.length) {\n        let current = s.pop();\n        result.unshift(current.val);\n        if (current.left) {\n            s.push(current.left);\n        }\n        if (current.right) {\n            s.push(current.right);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The idea of the algorithm is using a stack. Initially, the root node is pushed to the stack. Next, we enter a loop that ends when the stack is empty. In each iteration, we pop a node from the stack, and insert its value at the beginning of the result list (to ensure the correct order for the postorder traversal), then, push its left child, and then its right child to the stack (if they are not null). In the end, we return the result list. The algorithm is non-recursive which makes it easier to understand for some. Since the result list will store the output in reversed order, this iterative version avoids the necessity of reversing the final output.\n    "
    },
    {
        "id": 149,
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,2\\],\\[5,3\\],\\[4,1\\],\\[2,3\\],\\[1,4\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 300`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `points` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,1],[2,2],[3,3]]",
                "output": "3"
            },
            {
                "input": "[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nprivate int gcd(int a, int b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    ",
        "python": "\n    ```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    ",
        "js": "\n    ```javascript\nfunction maxPoints(points) {\n    const n = points.length;\n    if (n <= 2) return n;\n\n    let maxCount = 0;\n\n    for (let i = 0; i < n; i++) {\n        const slopeMap = new Map();\n        let duplicates = 0, localMax = 0;\n\n        for (let j = i + 1; j < n; j++) {\n            let deltaX = points[j][0] - points[i][0];\n            let deltaY = points[j][1] - points[i][1];\n\n            if (deltaX === 0 && deltaY === 0) {\n                duplicates++;\n                continue;\n            }\n\n            const gcdVal = gcd(deltaX, deltaY);\n            deltaX /= gcdVal;\n            deltaY /= gcdVal;\n\n            const key = `${deltaX}_${deltaY}`;\n            slopeMap.set(key, (slopeMap.get(key) || 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    "
    },
    {
        "id": 152,
        "title": "Maximum Product Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,-2,4\\]\n**Output:** 6\n**Explanation:** \\[2,3\\] has the largest product 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-2,0,-1\\]\n**Output:** 0\n**Explanation:** The result cannot be 2, because \\[-2,-1\\] is not a subarray."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-10 <= nums[i] <= 10`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[2,3,-2,4]",
                "output": "6"
            },
            {
                "input": "[-2,0,-1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "python": "\n    ```python\ndef maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "c++": "\n    ```cpp\nint maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "js": "\n    ```javascript\nfunction maxProduct(nums) {\n    let max_so_far = nums[0];\n    let min_so_far = nums[0];\n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            [max_so_far, min_so_far] = [min_so_far, max_so_far];\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    "
    },
    {
        "id": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n*   `[0,1,2,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.\n\nYou must write an algorithm that runs in `O(log n) time.`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 1\n**Explanation:** The original array was \\[1,2,3,4,5\\] rotated 3 times.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\]\n**Output:** 0\n**Explanation:** The original array was \\[0,1,2,4,5,6,7\\] and it was rotated 4 times.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[11,13,15,17\\]\n**Output:** 11\n**Explanation:** The original array was \\[11,13,15,17\\] and it was rotated 4 times."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   All the integers of `nums` are **unique**.\n*   `nums` is sorted and rotated between `1` and `n` times.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[3,4,5,1,2]",
                "output": "1"
            },
            {
                "input": "[4,5,6,7,0,1,2]",
                "output": "0"
            },
            {
                "input": "[11,13,15,17]",
                "output": "11"
            }
        ],
        "java": "\n    ```java\npublic int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "python": "\n    ```python\ndef find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "c++": "\n    ```c++\nint findMin(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "js": "\n    ```javascript\nfunction findMin(nums) {\n    let left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    "
    },
    {
        "id": 154,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": "Hard",
        "content": {
            "problem": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,4]` if it was rotated `4` times.\n*   `[0,1,4,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` that may contain **duplicates**, return _the minimum element of this array_.\n\nYou must decrease the overall operation steps as much as possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,0,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   `nums` is sorted and rotated between `1` and `n` times.\n\n**",
            "follow_up": "Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?"
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[1,3,5]",
                "output": "1"
            },
            {
                "input": "[2,2,2,0,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int findMin(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "python": "\n    ```python\ndef findMin(nums):\n    low, high = 0, len(nums) - 1\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        if nums[mid] > nums[high]:\n            low = mid + 1\n        elif nums[mid] < nums[high]:\n            high = mid\n        else:\n            high -= 1\n            \n    return nums[low]\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "c++": "\n    ```cpp\nint findMin(vector<int>& nums) {\n    int low = 0, high = nums.size() - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "js": "\n    ```javascript\nfunction findMin(nums) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    "
    },
    {
        "id": 157,
        "title": "Read N Characters Given Read4",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method to read `n` characters.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The `read` function will only be called once for each test case.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** file =  \"abc \", n = 4\n**Output:** 3\n**Explanation:** After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nNote that  \"abc \" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.\n\n",
                "**Example 2:**\n\n**Input:** file =  \"abcde \", n = 5\n**Output:** 5\n**Explanation:** After calling your read method, buf should contain  \"abcde \". We read a total of 5 characters from the file, so return 5.\n\n",
                "**Example 3:**\n\n**Input:** file =  \"abcdABCD1234 \", n = 12\n**Output:** 12\n**Explanation:** After calling your read method, buf should contain  \"abcdABCD1234 \". We read a total of 12 characters from the file, so return 12."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abc\",4",
                "output": "3"
            },
            {
                "input": "\"abcde\",5",
                "output": "5"
            },
            {
                "input": "\"abcdABCD1234\",12",
                "output": "12"
            }
        ],
        "java": "\n    ```java\npublic int read4(char[] buf4);\n\npublic int read(char[] buf, int n) {\n    int totalRead = 0;\n    char[] buf4 = new char[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; i++) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "python": "\n    ```python\ndef read4(buf4: List[str]) -> int:\n    pass\n\ndef read(buf: List[str], n: int) -> int:\n    total_read = 0\n    buf4 = [''] * 4\n\n    while total_read < n:\n        read4_count = read4(buf4)\n        for i in range(read4_count):\n            if total_read < n:\n                buf[total_read] = buf4[i]\n                total_read += 1\n            else:\n                break\n        if read4_count < 4:\n            break\n\n    return total_read\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "c++": "\n    ```cpp\nint read4(char *buf4);\n\nint read(char *buf, int n) {\n    int totalRead = 0;\n    char buf4[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "js": "\n    ```javascript\nfunction read4(buf4) {\n    // Implemented elsewhere\n}\n\nfunction read(buf, n) {\n    let totalRead = 0;\n    const buf4 = new Array(4);\n\n    while (totalRead < n) {\n        const read4Count = read4(buf4);\n        for(let i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    "
    },
    {
        "id": 158,
        "title": "Read N Characters Given read4 II - Call Multiple Times",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method `read` to read `n` characters. Your method `read` may be **called multiple times**.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The read function may be **called multiple times**.\n*   Please remember to **RESET** your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see [here](https://leetcode.com/faq/) for more details.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.\n*   It is guaranteed that in a given test case the same buffer `buf` is called by `read`.",
            "examples": [
                "**Example 1:**\n\n**Input:** file =  \"abc \", queries = \\[1,2,1\\]\n**Output:** \\[1,2,0\\]\n**Explanation:** The test case represents the following scenario:\nFile file( \"abc \");\nSolution sol;\nsol.read(buf, 1); // After calling your read method, buf should contain  \"a \". We read a total of 1 character from the file, so return 1.\nsol.read(buf, 2); // Now buf should contain  \"bc \". We read a total of 2 characters from the file, so return 2.\nsol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.\nAssume buf is allocated and guaranteed to have enough space for storing all characters from the file.\n\n",
                "**Example 2:**\n\n**Input:** file =  \"abc \", queries = \\[4,1\\]\n**Output:** \\[3,0\\]\n**Explanation:** The test case represents the following scenario:\nFile file( \"abc \");\nSolution sol;\nsol.read(buf, 4); // After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nsol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= queries.length <= 10`\n*   `1 <= queries[i] <= 500`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abc\",[1,2,1]",
                "output": "[1,2,0]"
            },
            {
                "input": "\"abc\",[4,1]",
                "output": "[3,0]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    private int buffer_index = 0;\n    private int buffer_len = 0;\n    private char[] buf4 = new char[4];\n\n    public int read(char[] buf, int n) {\n        int cnt = 0;\n        while (cnt < n) {\n            if (buffer_index == buffer_len) {\n                buffer_len = read4(buf4);\n                buffer_index = 0;\n            }\n            if (buffer_len == 0) break;\n            while (cnt < n && buffer_index < buffer_len) {\n                buf[cnt++] = buf4[buffer_index++];\n            }\n        }\n        return cnt;\n    }\n\n    //dummy method\n    private int read4(char[] buf4) {\n        return 0;\n    }\n}\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def __init__(self):\n        self.buffer_index = 0\n        self.buffer_len = 0\n        self.buf4 = [None] * 4\n\n    def read(self, buf, n):\n        cnt = 0\n        while cnt < n:\n            if self.buffer_index == self.buffer_len:\n                self.buffer_len = self.read4(self.buf4)\n                self.buffer_index = 0\n            if self.buffer_len == 0:\n                break\n            while cnt < n and self.buffer_index < self.buffer_len:\n                buf[cnt] = self.buf4[self.buffer_index]\n                cnt += 1\n                self.buffer_index += 1\n        return cnt\n\n    def read4(self, buf4):\n        return 0\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\n    int buffer_index = 0;\n    int buffer_len = 0;\n    char buf4[4];\n\npublic:\n    int read(char* buf, int n) {\n        int cnt = 0;\n        while (cnt < n) {\n            if (buffer_index == buffer_len) {\n                buffer_len = read4(buf4);\n                buffer_index = 0;\n            }\n            if (buffer_len == 0) break;\n            while (cnt < n && buffer_index < buffer_len) {\n                buf[cnt++] = buf4[buffer_index++];\n            }\n        }\n        return cnt;\n    }\n};\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    constructor() {\n        this.buffer_index = 0;\n        this.buffer_len = 0;\n        this.buf4 = new Array(4);\n    }\n\n    read(buf, n) {\n        let cnt = 0;\n        while (cnt < n) {\n            if (this.buffer_index === this.buffer_len) {\n                this.buffer_len = this.read4(this.buf4);\n                this.buffer_index = 0;\n            }\n            if (this.buffer_len === 0) break;\n            while (cnt < n && this.buffer_index < this.buffer_len) {\n                buf[cnt++] = this.buf4[this.buffer_index++];\n            }\n        }\n        return cnt;\n    }\n\n    read4(buf4) {\n        return 0;\n    }\n}\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    "
    },
    {
        "id": 159,
        "title": "Longest Substring with At Most Two Distinct Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"eceba \"\n**Output:** 3\n**Explanation:** The substring is  \"ece \" which its length is 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ccaabbb \"\n**Output:** 5\n**Explanation:** The substring is  \"aabbb \" which its length is 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"eceba\"",
                "output": "3"
            },
            {
                "input": "\"ccaabbb\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "python": "\n    ```python\ndef lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLongestSubstringTwoDistinct(string s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        char_count[s[r]]++;\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count[s[l]]--;\n                if (char_count[s[l]] == 0) {\n                    char_count.erase(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLongestSubstringTwoDistinct(s) {\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < s.length) {\n        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(s[l], char_count.get(s[l]) - 1);\n                if (char_count.get(s[l]) === 0) {\n                    char_count.delete(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    "
    },
    {
        "id": 160,
        "title": "Intersection of Two Linked Lists",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the heads of two singly linked-lists `headA` and `headB`, return _the node at which the two lists intersect_. If the two linked lists have no intersection at all, return `null`.\n\nFor example, the following two linked lists begin to intersect at node `c1`:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n**Note** that the linked lists must **retain their original structure** after the function returns.\n\n**Custom Judge:**\n\nThe inputs to the **judge** are given as follows (your program is **not** given these inputs):\n\n*   `intersectVal` - The value of the node where the intersection occurs. This is `0` if there is no intersected node.\n*   `listA` - The first linked list.\n*   `listB` - The second linked list.\n*   `skipA` - The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.\n*   `skipB` - The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, `headA` and `headB` to your program. If you correctly return the intersected node, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** intersectVal = 8, listA = \\[4,1,8,4,5\\], listB = \\[5,6,1,8,4,5\\], skipA = 2, skipB = 3\n**Output:** Intersected at '8'\n**Explanation:** The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as \\[4,1,8,4,5\\]. From the head of B, it reads as \\[5,6,1,8,4,5\\]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n\n",
                "**Example 2:**\n\n**Input:** intersectVal = 2, listA = \\[1,9,1,2,4\\], listB = \\[3,2,4\\], skipA = 3, skipB = 1\n**Output:** Intersected at '2'\n**Explanation:** The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as \\[1,9,1,2,4\\]. From the head of B, it reads as \\[3,2,4\\]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n",
                "**Example 3:**\n\n**Input:** intersectVal = 0, listA = \\[2,6,4\\], listB = \\[1,5\\], skipA = 3, skipB = 2\n**Output:** No intersection\n**Explanation:** From the head of A, it reads as \\[2,6,4\\]. From the head of B, it reads as \\[1,5\\]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes of `listA` is in the `m`.\n*   The number of nodes of `listB` is in the `n`.\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= Node.val <= 105`\n*   `0 <= skipA < m`\n*   `0 <= skipB < n`\n*   `intersectVal` is `0` if `listA` and `listB` do not intersect.\n*   `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.\n\n**",
            "follow_up": "Follow up:** Could you write a solution that runs in `O(m + n)` time and use only `O(1)` memory?"
        },
        "tag": [
            "Hash Table",
            "Linked List",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "8,[4,1,8,4,5],[5,6,1,8,4,5],2,3",
                "output": "Intersectedat'8'"
            },
            {
                "input": "2,[1,9,1,2,4],[3,2,4],3,1",
                "output": "Intersectedat'2'"
            },
            {
                "input": "0,[2,6,4],[1,5],3,2",
                "output": "Nointersection"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n        next = null;\n    }\n}\n\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode pA = headA, pB = headB;\n    while (pA != pB) {\n        pA = pA != null ? pA.next : headB;\n        pB = pB != null ? pB.next : headA;\n    }\n    return pA;\n}\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef getIntersectionNode(headA, headB):\n    pA, pB = headA, headB\n    while pA is not pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    return pA\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode *pA = headA, *pB = headB;\n    while (pA != pB) {\n        pA = pA ? pA->next : headB;\n        pB = pB ? pB->next : headA;\n    }\n    return pA;\n}\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction getIntersectionNode(headA, headB) {\n    let pA = headA, pB = headB;\n    while (pA !== pB) {\n        pA = pA !== null ? pA.next : headB;\n        pB = pB !== null ? pB.next : headA;\n    }\n    return pA;\n}\n```\n\n    \n    The algorithm uses two pointers, one for each linked list head (headA and headB). The pointers traverse through the lists such that they traverse the sum of the node count of both lists. If the lists intersect at a node, the pointers will eventually meet at this intersection node because they will have traversed the same number of total nodes. If the lists do not intersect, the pointers will meet at the end of the lists, resulting in both pointers being null, and the function will return null.\n    "
    },
    {
        "id": 162,
        "title": "Find Peak Element",
        "difficulty": "Medium",
        "content": {
            "problem": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -∞`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in `O(log n)` time.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 2\n**Explanation:** 3 is a peak element and your function should return the index number 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,3,5,6,4\\]\n**Output:** 5\n**Explanation:** Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `nums[i] != nums[i + 1]` for all valid `i`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[1,2,3,1]",
                "output": "2"
            },
            {
                "input": "[1,2,1,3,5,6,4]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int findPeakElement(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "python": "\n    ```python\ndef findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "c++": "\n    ```cpp\nint findPeakElement(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "js": "\n    ```javascript\nfunction findPeakElement(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    "
    },
    {
        "id": 163,
        "title": "Missing Ranges",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an inclusive range `[lower, upper]` and a **sorted unique** integer array `nums`, where all elements are in the inclusive range.\n\nA number `x` is considered **missing** if `x` is in the range `[lower, upper]` and `x` is not in `nums`.\n\nReturn _the **smallest sorted** list of ranges that **cover every missing number exactly**_. That is, no element of `nums` is in any of the ranges, and each missing number is in one of the ranges.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,3,50,75\\], lower = 0, upper = 99\n**Output:** \\[ \"2 \", \"4->49 \", \"51->74 \", \"76->99 \"\\]\n**Explanation:** The ranges are:\n\\[2,2\\] -->  \"2 \"\n\\[4,49\\] -->  \"4->49 \"\n\\[51,74\\] -->  \"51->74 \"\n\\[76,99\\] -->  \"76->99 \"\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1\\], lower = -1, upper = -1\n**Output:** \\[\\]\n**Explanation:** There are no missing ranges since there are no missing numbers."
            ],
            "constraints": "**Constraints:**\n\n*   `-109 <= lower <= upper <= 109`\n*   `0 <= nums.length <= 100`\n*   `lower <= nums[i] <= upper`\n*   All the values of `nums` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,3,50,75],0,99",
                "output": "[\"2\",\"4->49\",\"51->74\",\"76->99\"]"
            },
            {
                "input": "[-1],-1,-1",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findMissingRanges(int[] nums, int lower, int upper) {\n    List<String> result = new ArrayList<>();\n    long prev = (long) lower - 1;\n\n    for (int i = 0; i <= nums.length; ++i) {\n        long cur = (i == nums.length) ? (long) upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.add(Long.toString(prev + 1) + (cur - prev == 2 ? \"\" : \"->\") + Long.toString(cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:\n    result = []\n    prev = lower - 1\n\n    for i, num in enumerate(nums + [upper + 1]):\n        if num - prev >= 2:\n            result.append(f\"{prev + 1}\" + (\"\" if num - prev == 2 else \"->\") + f\"{num - 1}\")\n        prev = num\n\n    return result\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findMissingRanges(std::vector<int>& nums, int lower, int upper) {\n    std::vector<std::string> result;\n    long prev = (long)lower - 1;\n\n    for (int i = 0; i <= nums.size(); ++i) {\n        long cur = (i == nums.size()) ? (long)upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.push_back(std::to_string(prev + 1) + (cur - prev == 2 ? \"\" : \"->\") + std::to_string(cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    ",
        "js": "\n    ```javascript\nfunction findMissingRanges(nums, lower, upper) {\n    let result = [];\n    let prev = lower - 1;\n\n    for (let i = 0; i <= nums.length; ++i) {\n        let cur = (i === nums.length) ? upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.push((prev + 1) + (cur - prev === 2 ? \"\" : \"->\") + (cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    "
    },
    {
        "id": 164,
        "title": "Maximum Gap",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the maximum difference between two successive elements in its sorted form_. If the array contains less than two elements, return `0`.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,6,9,1\\]\n**Output:** 3\n**Explanation:** The sorted form of the array is \\[1,3,6,9\\], either (3,6) or (6,9) has the maximum difference 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10\\]\n**Output:** 0\n**Explanation:** The array contains less than 2 elements, therefore return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Bucket Sort",
            "Radix Sort"
        ],
        "example": [
            {
                "input": "[3,6,9,1]",
                "output": "3"
            },
            {
                "input": "[10]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "python": "\n    ```python\ndef maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    "
    },
    {
        "id": 165,
        "title": "Compare Version Numbers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two version numbers, `version1` and `version2`, compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.\n\nTo compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.\n\n_Return the following:_\n\n*   If `version1 < version2`, return `-1`.\n*   If `version1 > version2`, return `1`.\n*   Otherwise, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** version1 =  \"1.01 \", version2 =  \"1.001 \"\n**Output:** 0\n**Explanation:** Ignoring leading zeroes, both  \"01 \" and  \"001 \" represent the same integer  \"1 \".\n\n",
                "**Example 2:**\n\n**Input:** version1 =  \"1.0 \", version2 =  \"1.0.0 \"\n**Output:** 0\n**Explanation:** version1 does not specify revision 2, which means it is treated as  \"0 \".\n\n",
                "**Example 3:**\n\n**Input:** version1 =  \"0.1 \", version2 =  \"1.1 \"\n**Output:** -1\n**Explanation:** version1's revision 0 is  \"0 \", while version2's revision 0 is  \"1 \". 0 < 1, so version1 < version2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= version1.length, version2.length <= 500`\n*   `version1` and `version2` only contain digits and `'.'`.\n*   `version1` and `version2` **are valid version numbers**.\n*   All the given revisions in `version1` and `version2` can be stored in a **32-bit integer**.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"1.01\",\"1.001\"",
                "output": "0"
            },
            {
                "input": "\"1.0\",\"1.0.0\"",
                "output": "0"
            },
            {
                "input": "\"0.1\",\"1.1\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int compareVersion(String version1, String version2) {\n    int i = 0, j = 0;\n    while (i < version1.length() || j < version2.length()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.length() && version1.charAt(i) != '.') {\n            num1 = num1 * 10 + (version1.charAt(i++) - '0');\n        }\n        while (j < version2.length() && version2.charAt(j) != '.') {\n            num2 = num2 * 10 + (version2.charAt(j++) - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "python": "\n    ```python\ndef compare_version(version1, version2):\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n        \n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "c++": "\n    ```cpp\nint compareVersion(string version1, string version2) {\n    int i = 0, j = 0;\n    while (i < version1.size() || j < version2.size()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.size() && version1[i] != '.') {\n            num1 = num1 * 10 + (version1[i++] - '0');\n        }\n        while (j < version2.size() && version2[j] != '.') {\n            num2 = num2 * 10 + (version2[j++] - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "js": "\n    ```javascript\nfunction compareVersion(version1, version2) {\n    const v1 = version1.split('.');\n    const v2 = version2.split('.');\n    \n    while (v1.length > 0 || v2.length > 0) {\n        const num1 = v1.length > 0 ? parseInt(v1.shift()) : 0;\n        const num2 = v2.length > 0 ? parseInt(v2.shift()) : 0;\n        \n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n    }\n    return 0;\n}\n```\n\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    "
    },
    {
        "id": 167,
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** numbers = \\[2,7,11,15\\], target = 9\n**Output:** \\[1,2\\]\n**Explanation:** The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return \\[1, 2\\].\n\n",
                "**Example 2:**\n\n**Input:** numbers = \\[2,3,4\\], target = 6\n**Output:** \\[1,3\\]\n**Explanation:** The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return \\[1, 3\\].\n\n",
                "**Example 3:**\n\n**Input:** numbers = \\[\\-1,0\\], target = -1\n**Output:** \\[1,2\\]\n**Explanation:** The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return \\[1, 2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= numbers.length <= 3 * 104`\n*   `-1000 <= numbers[i] <= 1000`\n*   `numbers` is sorted in **non-decreasing order**.\n*   `-1000 <= target <= 1000`\n*   The tests are generated such that there is **exactly one solution**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,7,11,15],9",
                "output": "[1,2]"
            },
            {
                "input": "[2,3,4],6",
                "output": "[1,3]"
            },
            {
                "input": "[-1,0],-1",
                "output": "[1,2]"
            }
        ],
        "java": "\n    ```java\npublic int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return new int[]{left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{};\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "python": "\n    ```python\ndef twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int left = 0, right = numbers.size() - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return {left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return {};\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "js": "\n    ```javascript\nfunction twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    while (left < right) {\n        let current_sum = numbers[left] + numbers[right];\n        if (current_sum === target) {\n            return [left + 1, right + 1];\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return [];\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    "
    },
    {
        "id": 169,
        "title": "Majority Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,1,1,1,2,2\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**",
            "follow_up": "Follow-up:** Could you solve the problem in linear time and in `O(1)` space?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[3,2,3]",
                "output": "3"
            },
            {
                "input": "[2,2,1,1,1,2,2]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int majorityElement(int[] nums) {\n    int count = 0;\n    Integer candidate = null;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "python": "\n    ```python\ndef majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "c++": "\n    ```cpp\nint majorityElement(vector<int>& nums) {\n    int count = 0;\n    int candidate;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "js": "\n    ```javascript\nfunction majorityElement(nums) {\n    let count = 0;\n    let candidate = null;\n\n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        count += (num === candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    "
    },
    {
        "id": 170,
        "title": "Two Sum III - Data structure design",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.\n\nImplement the `TwoSum` class:\n\n*   `TwoSum()` Initializes the `TwoSum` object, with an empty array initially.\n*   `void add(int number)` Adds `number` to the data structure.\n*   `boolean find(int value)` Returns `true` if there exists any pair of numbers whose sum is equal to `value`, otherwise, it returns `false`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"TwoSum \",  \"add \",  \"add \",  \"add \",  \"find \",  \"find \"\\]\n\\[\\[\\], \\[1\\], \\[3\\], \\[5\\], \\[4\\], \\[7\\]\\]\n**Output**\n\\[null, null, null, null, true, false\\]\n\n**Explanation**\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // \\[\\] --> \\[1\\]\ntwoSum.add(3);   // \\[1\\] --> \\[1,3\\]\ntwoSum.add(5);   // \\[1,3\\] --> \\[1,3,5\\]\ntwoSum.find(4);  // 1 + 3 = 4, return true\ntwoSum.find(7);  // No two integers sum up to 7, return false"
            ],
            "constraints": "**Constraints:**\n\n*   `-105 <= number <= 105`\n*   `-231 <= value <= 231 - 1`\n*   At most `104` calls will be made to `add` and `find`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,null,true,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass TwoSum {\n    private HashMap<Integer, Integer> nums;\n\n    public TwoSum() {\n        nums = new HashMap<>();\n    }\n\n    public void add(int number) {\n        nums.put(number, nums.getOrDefault(number, 0) + 1);\n    }\n\n    public boolean find(int value) {\n        for (Integer i : nums.keySet()) {\n            int complement = value - i;\n            if (nums.containsKey(complement)) {\n                if (i != complement || nums.get(i) > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    ",
        "python": "\n    ```python\nclass TwoSum:\n\n    def __init__(self):\n        self.nums = {}\n\n    def add(self, number: int) -> None:\n        if number in self.nums:\n            self.nums[number] += 1\n        else:\n            self.nums[number] = 1\n\n    def find(self, value: int) -> bool:\n        for num in self.nums:\n            target = value - num\n            if target in self.nums:\n                if target != num or self.nums[num] > 1:\n                    return True\n        return False\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    ",
        "c++": "\n    ```cpp\nclass TwoSum {\npublic:\n    unordered_map<int, int> m;\n\n    TwoSum() {\n\n    }\n\n    void add(int number) {\n        m[number]++;\n    }\n\n    bool find(int value) {\n        for (auto &pair : m) {\n            int num1 = pair.first;\n            int num2 = value - num1;\n            if (num1 == num2 && pair.second > 1 || num1 != num2 && m.count(num2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    ",
        "js": "\n    ```javascript\nclass TwoSum {\n    constructor() {\n        this.nums = {};\n    }\n\n    add(number) {\n        if (this.nums.hasOwnProperty(number)) {\n            this.nums[number]++;\n        } else {\n            this.nums[number] = 1;\n        }\n    }\n\n    find(value) {\n        for (let num in this.nums) {\n            let target = value - num;\n            if (this.nums.hasOwnProperty(target)) {\n                if (target !== num || this.nums[num] > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    "
    },
    {
        "id": 171,
        "title": "Excel Sheet Column Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return _its corresponding column number_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
            "examples": [
                "**Example 1:**\n\n**Input:** columnTitle =  \"A \"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** columnTitle =  \"AB \"\n**Output:** 28\n\n",
                "**Example 3:**\n\n**Input:** columnTitle =  \"ZY \"\n**Output:** 701"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= columnTitle.length <= 7`\n*   `columnTitle` consists only of uppercase English letters.\n*   `columnTitle` is in the range `[ \"A \", \"FXSHRXW \"]`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"A\"",
                "output": "1"
            },
            {
                "input": "\"AB\"",
                "output": "28"
            },
            {
                "input": "\"ZY\"",
                "output": "701"
            }
        ],
        "java": "\n    ```java\npublic int titleToNumber(String columnTitle) {\n    int result = 0;\n    for (char c : columnTitle.toCharArray()) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "python": "\n    ```python\ndef title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "c++": "\n    ```cpp\nint titleToNumber(string columnTitle) {\n    int result = 0;\n    for (char c : columnTitle) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "js": "\n    ```javascript\nfunction titleToNumber(columnTitle) {\n    let result = 0;\n    for (let c of columnTitle) {\n        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    "
    },
    {
        "id": 172,
        "title": "Factorial Trailing Zeroes",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the number of trailing zeroes in_ `n!`.\n\nNote that `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 0\n**Explanation:** 3! = 6, no trailing zero.\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** 1\n**Explanation:** 5! = 120, one trailing zero.\n\n",
                "**Example 3:**\n\n**Input:** n = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 104`\n\n**",
            "follow_up": "Follow up:** Could you write a solution that works in logarithmic time complexity?"
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "3",
                "output": "0"
            },
            {
                "input": "5",
                "output": "1"
            },
            {
                "input": "0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n / 5;\n        count += n;\n    }\n    return count;\n}\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "python": "\n    ```python\ndef trailing_zeroes(n: int) -> int:\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "c++": "\n    ```cpp\nint trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n /= 5;\n        count += n;\n    }\n    return count;\n}\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "js": "\n    ```javascript\nfunction trailingZeroes(n) {\n    let count = 0;\n    while (n > 0) {\n        n = Math.floor(n / 5);\n        count += n;\n    }\n    return count;\n}\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    "
    },
    {
        "id": 174,
        "title": "Dungeon Game",
        "difficulty": "Hard",
        "content": {
            "problem": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",
            "examples": [
                "**Example 1:**\n\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n",
                "**Example 2:**\n\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[-2,-3,3],[-5,-10,1],[10,30,-5]]",
                "output": "7"
            },
            {
                "input": "[[0]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "python": "\n    ```python\ndef calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "js": "\n    ```javascript\nfunction calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    "
    },
    {
        "id": 178,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n",
                "**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "2,[2,4,1]",
                "output": "2"
            },
            {
                "input": "2,[3,2,6,5,0,3]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "python": "\n    ```python\ndef maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    "
    },
    {
        "id": 180,
        "title": "Reverse Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Reverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n\n",
                "**Example 2:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:**   3221225471 (10111111111111111111111111111111)\n**Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**."
            ],
            "constraints": "**Constraints:**\n\n*   The input must be a **binary string** of length `32`\n\n**",
            "follow_up": "Follow up:** If this function is called many times, how would you optimize it?"
        },
        "tag": [
            "Divide and Conquer",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "00000010100101000001111010011100",
                "output": "964176192(00111001011110000010100101000000)"
            },
            {
                "input": "11111111111111111111111111111101",
                "output": "3221225471(10111111111111111111111111111111)"
            }
        ],
        "java": "\n    ```java\npublic int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "python": "\n    ```python\ndef reverse_bits(n: int) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "c++": "\n    ```cpp\nunsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "js": "\n    ```javascript\nfunction reverseBits(n) {\n    let res = 0;\n    for (let i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res >>> 0;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    "
    },
    {
        "id": 181,
        "title": "Number of 1 Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 00000000000000000000000000001011\n**Output:** 3\n**Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n\n",
                "**Example 2:**\n\n**Input:** n = 00000000000000000000000010000000\n**Output:** 1\n**Explanation:** The input binary string **00000000000000000000000010000000** has a total of one '1' bit.\n\n",
                "**Example 3:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:** 31\n**Explanation:** The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits."
            ],
            "constraints": "**Constraints:**\n\n*   The input must be a **binary string** of length `32`.\n\n**",
            "follow_up": "Follow up:** If this function is called many times, how would you optimize it?"
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "00000000000000000000000000001011",
                "output": "3"
            },
            {
                "input": "00000000000000000000000010000000",
                "output": "1"
            },
            {
                "input": "11111111111111111111111111111101",
                "output": "31"
            }
        ],
        "java": "\n    ```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "python": "\n    ```python\ndef hamming_weight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "c++": "\n    ```cpp\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "js": "\n    ```javascript\nfunction hammingWeight(n) {\n    let count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    "
    },
    {
        "id": 182,
        "title": "House Robber",
        "difficulty": "Medium",
        "content": {
            "problem": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,2,3,1]",
                "output": "4"
            },
            {
                "input": "[2,7,9,3,1]",
                "output": "12"
            }
        ],
        "java": "\n    ```java\npublic int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "python": "\n    ```python\ndef rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "c++": "\n    ```cpp\nint rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for (const auto& num : nums) {\n        int tmp = prev1;\n        prev1 = max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "js": "\n    ```javascript\nfunction rob(nums) {\n    let prev1 = 0, prev2 = 0;\n    for (let num of nums) {\n        let temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    "
    },
    {
        "id": 185,
        "title": "Bitwise AND of Numbers Range",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers `left` and `right` that represent the range `[left, right]`, return _the bitwise AND of all numbers in this range, inclusive_.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 5, right = 7\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** left = 0, right = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** left = 1, right = 2147483647\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= left <= right <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "5,7",
                "output": "4"
            },
            {
                "input": "0,0",
                "output": "0"
            },
            {
                "input": "1,2147483647",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "python": "\n    ```python\ndef range_bitwise_and(left: int, right: int) -> int:\n    shift = 0\n    while left != right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "c++": "\n    ```cpp\nint rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        ++shift;\n    }\n    return left << shift;\n}\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "js": "\n    ```javascript\nfunction rangeBitwiseAnd(left, right) {\n    let shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    "
    },
    {
        "id": 186,
        "title": "Happy Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Write an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 19\n**Output:** true\n**Explanation:**\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "19",
                "output": "true"
            },
            {
                "input": "2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\npublic boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "python": "\n    ```python\ndef get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "c++": "\n    ```cpp\nint getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "js": "\n    ```javascript\nfunction getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n, fast = getNext(n);\n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast === 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    "
    },
    {
        "id": 187,
        "title": "Remove Linked List Elements",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return _the new head_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,6,3,4,5,6\\], val = 6\n**Output:** \\[1,2,3,4,5\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[\\], val = 1\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** head = \\[7,7,7,7\\], val = 7\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 104]`.\n*   `1 <= Node.val <= 50`\n*   `0 <= val <= 50`",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,6,3,4,5,6],6",
                "output": "[1,2,3,4,5]"
            },
            {
                "input": "[],1",
                "output": "[]"
            },
            {
                "input": "[7,7,7,7],7",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode removeElements(ListNode head, int val) {\n    ListNode sentinel = new ListNode(0);\n    sentinel.next = head;\n    ListNode prev = sentinel, curr = head;\n\n    while (curr != null) {\n        if (curr.val == val) {\n            prev.next = curr.next;\n        } else {\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n\n    return sentinel.next;\n}\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_elements(head, val):\n    sentinel = ListNode(0)\n    sentinel.next = head\n    prev, curr = sentinel, head\n\n    while curr:\n        if curr.val == val:\n            prev.next = curr.next\n        else:\n            prev = curr\n        curr = curr.next\n\n    return sentinel.next\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* removeElements(ListNode* head, int val) {\n    ListNode** current = &head;\n\n    while (*current != NULL) {\n        if ((*current)->val == val) {\n            ListNode* next = (*current)->next;\n            delete *current;\n            *current = next;\n        } else {\n            current = &(*current)->next;\n        }\n    }\n\n    return head;\n}\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction removeElements(head, val) {\n    let sentinel = new ListNode(0);\n    sentinel.next = head;\n    let prev = sentinel, curr = head;\n\n    while (curr !== null) {\n        if (curr.val === val) {\n            prev.next = curr.next;\n        } else {\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n\n    return sentinel.next;\n}\n```\n    \n    The algorithm for removing elements with a specific value from a linked list involves iterating through the list and maintaining two pointers `prev` and `curr`. The `prev` pointer will point to the previous node in the list, whereas the `curr` pointer will point to the current node that is being processed.\n\n- First, create a sentinel node to handle edge cases for the head node.\n- Assign the `next` attribute of the sentinel node to the given head node.\n- Set the `prev` pointer to the sentinel node and the `curr` pointer to the head node.\n- Loop through the linked list:\n  - If the value of the current node matches the given value, remove it by updating the `next` attribute of the previous node.\n  - Otherwise, move the `prev` pointer to the current node.\n  - Move the `curr` pointer to the next node.\n- After the loop, the new head of the linked list is found in the sentinel node's `next` attribute.\n\nNote that in C++, due to manual memory management, we have to delete the nodes to avoid memory leaks.\n    "
    },
    {
        "id": 188,
        "title": "Count Primes",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the number of prime numbers that are strictly less than_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 5 * 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "example": [
            {
                "input": "10",
                "output": "4"
            },
            {
                "input": "0",
                "output": "0"
            },
            {
                "input": "1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countPrimes(int n) {\n    if (n <= 2) return 0;\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int count = 0;\n    for (boolean prime : isPrime) {\n        if (prime) count++;\n    }\n    return count;\n}\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "python": "\n    ```python\ndef countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "c++": "\n    ```cpp\nint countPrimes(int n) {\n    if (n <= 2) return 0;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "js": "\n    ```javascript\nfunction countPrimes(n) {\n    if (n <= 2) return 0;\n    const isPrime = Array(n).fill(true);\n    isPrime[0] = isPrime[1] = false;\n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return isPrime.filter(prime => prime).length;\n}\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    "
    },
    {
        "id": 189,
        "title": "Isomorphic Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"egg\", t = \"add\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"foo\", t = \"bar\"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s = \"paper\", t = \"title\"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `t.length == s.length`\n*   `s` and `t` consist of any valid ascii character.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"egg\",\"add\"",
                "output": "true"
            },
            {
                "input": "\"foo\",\"bar\"",
                "output": "false"
            },
            {
                "input": "\"paper\",\"title\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "python": "\n    ```python\ndef is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "js": "\n    ```javascript\nfunction isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    "
    },
    {
        "id": 190,
        "title": "Reverse Linked List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[5,4,3,2,1\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** \\[2,1\\]\n\n",
                "**Example 3:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n\n**",
            "follow_up": "Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?"
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5]",
                "output": "[5,4,3,2,1]"
            },
            {
                "input": "[1,2]",
                "output": "[2,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n}\n\npublic ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode current = head;\n    ListNode next = null;\n    while (current != null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n};\n\nListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    ListNode* next = nullptr;\n    while (current != nullptr) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseList(head) {\n    let prev = null;\n    let current = head;\n    let next = null;\n    while (current !== null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n```\n    \n    The algorithm for reversing a singly linked list involves maintaining three pointers: `prev`, `current`, and `next`. \n1. Initialize `prev` to null and `current` to the head of the linked list.\n2. Iterate through the linked list until `current` becomes null.\n3. In each iteration, set `next` to be the next node of `current`.\n4. Point the `next` of `current` to `prev`.\n5. Move `prev` one step forward by setting it to `current`.\n6. Finally, move `current` one step forward by setting it to `next`.\n7. The reversed linked list is obtained when `current` becomes null, and `prev` will be the head of the new reversed list.\n    "
    },
    {
        "id": 193,
        "title": "Minimum Size Subarray Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _subarray_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 7, nums = \\[2,3,1,2,4,3\\]\n**Output:** 2\n**Explanation:** The subarray \\[4,3\\] has the minimal length under the problem constraint.\n\n",
                "**Example 2:**\n\n**Input:** target = 4, nums = \\[1,4,4\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** target = 11, nums = \\[1,1,1,1,1,1,1,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target <= 109`\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n\n**",
            "follow_up": "Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`."
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "7,[2,3,1,2,4,3]",
                "output": "2"
            },
            {
                "input": "4,[1,4,4]",
                "output": "1"
            },
            {
                "input": "11,[1,1,1,1,1,1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "python": "\n    ```python\ndef minSubArrayLen(target: int, nums: List[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "c++": "\n    ```cpp\n#include <climits>\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "js": "\n    ```javascript\nfunction minSubArrayLen(target, nums) {\n    let left = 0, cur_sum = 0, min_len = Number.MAX_VALUE;\n    for (let right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len === Number.MAX_VALUE ? 0 : min_len;\n}\n```\n\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    "
    },
    {
        "id": 196,
        "title": "Word Search II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.\n\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"o \", \"a \", \"a \", \"n \"\\],\\[ \"e \", \"t \", \"a \", \"e \"\\],\\[ \"i \", \"h \", \"k \", \"r \"\\],\\[ \"i \", \"f \", \"l \", \"v \"\\]\\], words = \\[ \"oath \", \"pea \", \"eat \", \"rain \"\\]\n**Output:** \\[ \"eat \", \"oath \"\\]\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \"a \", \"b \"\\],\\[ \"c \", \"d \"\\]\\], words = \\[ \"abcb \"\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 12`\n*   `board[i][j]` is a lowercase English letter.\n*   `1 <= words.length <= 3 * 104`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are unique.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Backtracking",
            "Trie",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]],[\"oath\",\"pea\",\"eat\",\"rain\"]",
                "output": "[\"eat\",\"oath\"]"
            },
            {
                "input": "[[\"a\",\"b\"],[\"c\",\"d\"]],[\"abcb\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}\n\nprivate boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, 0, i, j, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean found =\n            dfs(board, word, index + 1, i - 1, j, visited) ||\n            dfs(board, word, index + 1, i + 1, j, visited) ||\n            dfs(board, word, index + 1, i, j - 1, visited) ||\n            dfs(board, word, index + 1, i, j + 1, visited);\n    visited[i][j] = false;\n    return found;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "python": "\n    ```python\ndef findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){\n    if (index == word.length()) {\n        found = true;\n        return;\n    }\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){\n        return;\n    }\n    visited[i][j] = true;\n    dfs(board, word, index + 1, i - 1, j, visited, found);\n    dfs(board, word, index + 1, i + 1, j, visited, found);\n    dfs(board, word, index + 1, i, j - 1, visited, found);\n    dfs(board, word, index + 1, i, j + 1, visited, found);\n    visited[i][j] = false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "js": "\n    ```javascript\nfunction findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    "
    },
    {
        "id": 197,
        "title": "House Robber II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[2,3,2]",
                "output": "3"
            },
            {
                "input": "[1,2,3,1]",
                "output": "4"
            },
            {
                "input": "[1,2,3]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int rob(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.length - 1; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.length; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "python": "\n    ```python\ndef rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "c++": "\n    ```cpp\nint rob(vector<int>& nums) {\n    if (nums.size() == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.size() - 1; i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "js": "\n    ```javascript\nfunction rob(nums) {\n    if (nums.length === 1) return nums[0];\n    let prev = 0, curr = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    let res = curr;\n    prev = 0;\n    curr = 0;\n    for (let i = 1; i < nums.length; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    "
    },
    {
        "id": 199,
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,1,5,6,4\\], k = 2\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,3,1,2,4,5,5,6\\], k = 4\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Sorting",
            "Heap (Priority Queue)",
            "Quickselect"
        ],
        "example": [
            {
                "input": "[3,2,1,5,6,4],2",
                "output": "5"
            },
            {
                "input": "[3,2,3,1,2,4,5,5,6],4",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int num : nums) {\n        minHeap.add(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n    return minHeap.poll();\n}\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "python": "\n    ```python\ndef findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint findKthLargest(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\n    return nums[k-1];\n}\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "js": "\n    ```javascript\nfunction findKthLargest(nums, k) {\n    nums.sort((a, b) => b - a);\n    return nums[k - 1];\n}\n```\n\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    "
    },
    {
        "id": 200,
        "title": "Combination Sum III",
        "difficulty": "Medium",
        "content": {
            "problem": "Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n*   Only numbers `1` through `9` are used.\n*   Each number is used **at most once**.\n\nReturn _a list of all possible valid combinations_. The list must not contain the same combination twice, and the combinations may be returned in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 3, n = 7\n**Output:** \\[\\[1,2,4\\]\\]\n**Explanation:**\n1 + 2 + 4 = 7\nThere are no other valid combinations.\n\n",
                "**Example 2:**\n\n**Input:** k = 3, n = 9\n**Output:** \\[\\[1,2,6\\],\\[1,3,5\\],\\[2,3,4\\]\\]\n**Explanation:**\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n\n",
                "**Example 3:**\n\n**Input:** k = 4, n = 1\n**Output:** \\[\\]\n**Explanation:** There are no valid combinations.\nUsing 4 different numbers in the range \\[1,9\\], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= k <= 9`\n*   `1 <= n <= 60`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking"
        ],
        "example": [
            {
                "input": "3,7",
                "output": "[[1,2,4]]"
            },
            {
                "input": "3,9",
                "output": "[[1,2,6],[1,3,5],[2,3,4]]"
            },
            {
                "input": "4,1",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void helper(int k, int n, int current, List<Integer> currentComb, List<List<Integer>> result) {\n    if (k == 0 && n == 0) {\n        result.add(new ArrayList<>(currentComb));\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; i++) {\n            currentComb.add(i);\n            helper(k - 1, n - i, i, currentComb, result);\n            currentComb.remove(currentComb.size() - 1);\n        }\n    }\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "python": "\n    ```python\ndef combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "js": "\n    ```javascript\nfunction combinationSum3(k, n) {\n  function helper(k, n, current, currentComb, result) {\n    if (k === 0 && n === 0) {\n      result.push([...currentComb]);\n    } else if (k > 0 && n > 0) {\n      for (let i = current + 1; i <= 9; i++) {\n        currentComb.push(i);\n        helper(k - 1, n - i, i, currentComb, result);\n        currentComb.pop();\n      }\n    }\n  }\n\n  const result = [];\n  helper(k, n, 0, [], result);\n  return result;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    "
    },
    {
        "id": 201,
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,3,3,4,3,2,4,2\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3,1]",
                "output": "true"
            },
            {
                "input": "[1,2,3,4]",
                "output": "false"
            },
            {
                "input": "[1,1,1,3,3,4,3,2,4,2]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction containsDuplicate(nums) {\n    const set = new Set();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    "
    },
    {
        "id": 202,
        "title": "The Skyline Problem",
        "difficulty": "Hard",
        "content": {
            "problem": "A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return _the **skyline** formed by these buildings collectively_.\n\nThe geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n\n*   `lefti` is the x coordinate of the left edge of the `ith` building.\n*   `righti` is the x coordinate of the right edge of the `ith` building.\n*   `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n\nThe **skyline** should be represented as a list of \"key points \" **sorted by their x-coordinate** in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n**Note:** There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`",
            "examples": [
                "**Example 1:**\n\n**Input:** buildings = \\[\\[2,9,10\\],\\[3,7,15\\],\\[5,12,12\\],\\[15,20,10\\],\\[19,24,8\\]\\]\n**Output:** \\[\\[2,10\\],\\[3,15\\],\\[7,12\\],\\[12,0\\],\\[15,10\\],\\[20,8\\],\\[24,0\\]\\]\n**Explanation:**\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n",
                "**Example 2:**\n\n**Input:** buildings = \\[\\[0,2,3\\],\\[2,5,3\\]\\]\n**Output:** \\[\\[0,3\\],\\[5,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= buildings.length <= 104`\n*   `0 <= lefti < righti <= 231 - 1`\n*   `1 <= heighti <= 231 - 1`\n*   `buildings` is sorted by `lefti` in non-decreasing order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Line Sweep",
            "Heap (Priority Queue)",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]",
                "output": "[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]"
            },
            {
                "input": "[[0,2,3],[2,5,3]]",
                "output": "[[0,3],[5,0]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<int[]> points = new ArrayList<>();\n        for (int[] b : buildings) {\n            points.add(new int[]{b[0], -b[2]});\n            points.add(new int[]{b[1], b[2]});\n        }\n        Collections.sort(points, (a, b) -> a[0] - b[0]);\n        TreeSet<Integer> heights = new TreeSet<>(Collections.reverseOrder());\n        heights.add(0);\n        int prev = 0;\n        List<List<Integer>> skyline = new ArrayList<>();\n        for (int[] point : points) {\n            int x = point[0], h = point[1];\n            if (h < 0)\n                heights.add(-h);\n            else\n                heights.remove(h);\n            int cur = heights.first();\n            if (cur != prev) {\n                skyline.add(Arrays.asList(x, cur));\n                prev = cur;\n            }\n        }\n        return skyline;\n    }\n}\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef getSkyline(buildings):\n    points = []\n    for l, r, h in buildings:\n        points.append((l, -h))\n        points.append((r, h))\n    points.sort()\n    heights = SortedList([0])\n    prev = 0\n    skyline = []\n    for x, h in points:\n        if h < 0:\n            heights.add(-h)\n        else:\n            heights.remove(h)\n        cur = heights[-1]\n        if cur != prev:\n            skyline.append([x, cur])\n            prev = cur\n    return skyline\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n    vector<pair<int, int>> points;\n    for (const auto &b : buildings) {\n        points.emplace_back(b[0], -b[2]);\n        points.emplace_back(b[1], b[2]);\n    }\n    sort(points.begin(), points.end());\n    multiset<int> heights = {0};\n    int prev = 0;\n    vector<vector<int>> skyline;\n    for (const auto &[x, h] : points) {\n        if (h < 0)\n            heights.insert(-h);\n        else\n            heights.erase(heights.find(h));\n        int cur = *heights.rbegin();\n        if (cur != prev) {\n            skyline.push_back({x, cur});\n            prev = cur;\n        }\n    }\n    return skyline;\n}\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    ",
        "js": "\n    ```javascript\nfunction getSkyline(buildings) {\n    const points = [];\n    for (const [l, r, h] of buildings) {\n        points.push([l, -h]);\n        points.push([r, h]);\n    }\n    points.sort((a, b) => a[0] - b[0]);\n    const heights = new SortedSet([0]);\n    let prev = 0;\n    const skyline = [];\n    for (const [x, h] of points) {\n        if (h < 0) {\n            heights.add(-h);\n        } else {\n            heights.delete(h);\n        }\n        const cur = heights.last();\n        if (cur !== prev) {\n            skyline.push([x, cur]);\n            prev = cur;\n        }\n    }\n    return skyline;\n}\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    "
    },
    {
        "id": 203,
        "title": "Contains Duplicate II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return `true` _if there are two **distinct indices**_ `i` _and_ `j` _in the array such that_ `nums[i] == nums[j]` _and_ `abs(i - j) <= k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], k = 3\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1\\], k = 1\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,1,2,3\\], k = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `0 <= k <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[1,2,3,1],3",
                "output": "true"
            },
            {
                "input": "[1,0,1,1],1",
                "output": "true"
            },
            {
                "input": "[1,2,3,1,2,3],2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.put(nums[i], i);\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "python": "\n    ```python\ndef containsNearbyDuplicate(nums, k):\n    value_index_map = {}\n    for i, num in enumerate(nums):\n        if num in value_index_map and i - value_index_map[num] <= k:\n            return True\n        value_index_map[num] = i\n    return False\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "c++": "\n    ```cpp\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int, int> valueIndexMap;\n    for (int i = 0; i < nums.size(); i++) {\n        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {\n            return true;\n        }\n        valueIndexMap[nums[i]] = i;\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "js": "\n    ```javascript\nfunction containsNearbyDuplicate(nums, k) {\n    const valueIndexMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (valueIndexMap.has(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.set(nums[i], i);\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    "
    },
    {
        "id": 204,
        "title": "Contains Duplicate III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and two integers `indexDiff` and `valueDiff`.\n\nFind a pair of indices `(i, j)` such that:\n\n*   `i != j`,\n*   `abs(i - j) <= indexDiff`.\n*   `abs(nums[i] - nums[j]) <= valueDiff`, and\n\nReturn `true` _if such pair exists or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], indexDiff = 3, valueDiff = 0\n**Output:** true\n**Explanation:** We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums\\[i\\] - nums\\[j\\]) <= valueDiff --> abs(1 - 1) <= 0\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,9,1,5,9\\], indexDiff = 2, valueDiff = 3\n**Output:** false\n**Explanation:** After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `1 <= indexDiff <= nums.length`\n*   `0 <= valueDiff <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sliding Window",
            "Sorting",
            "Bucket Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[1,2,3,1],3,0",
                "output": "true"
            },
            {
                "input": "[1,5,9,1,5,9],2,3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Long> window = new TreeSet<>();\n    for(int i = 0; i < nums.length; i++) {\n        if(i > k) {\n            window.remove((long)nums[i - k - 1]);\n        }\n        Long ceil = window.ceiling((long)nums[i] - t);\n        if(ceil != null && ceil - nums[i] <= t) {\n            return true;\n        }\n        window.add((long)nums[i]);\n    }\n    return false;\n}\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    window = SortedList()\n    for i in range(len(nums)):\n        if i > k:\n            window.remove(nums[i - k - 1])\n        pos = window.bisect_left(nums[i] - t)\n        if pos != len(window) and window[pos] - nums[i] <= t:\n            return True\n        window.add(nums[i])\n    return False\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    set<long> window;\n    for (int i = 0; i < nums.size(); i++) {\n        if (i > k) {\n            window.erase(nums[i - k - 1]);\n        }\n        auto pos = window.lower_bound((long)nums[i] - t);\n        if (pos != window.end() && *pos - nums[i] <= t) {\n            return true;\n        }\n        window.insert(nums[i]);\n    }\n    return false;\n}\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    ",
        "js": "\n    ```javascript\nfunction containsNearbyAlmostDuplicate(nums, k, t) {\n    let window = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        if (i > k) {\n            window.delete(nums[i - k - 1]);\n        }\n        for (const num of window) {\n            if (Math.abs(num - nums[i]) <= t) {\n                return true;\n            }\n        }\n        window.add(nums[i]);\n    }\n    return false;\n}\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    "
    },
    {
        "id": 205,
        "title": "Maximal Square",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \", \"1 \"\\],\\[ \"1 \", \"0 \"\\]\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                "output": "4"
            },
            {
                "input": "[[\"0\",\"1\"],[\"1\",\"0\"]]",
                "output": "1"
            },
            {
                "input": "[[\"0\"]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maximalSquare(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "python": "\n    ```python\ndef maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "c++": "\n    ```cpp\nint maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                maxSize = max(maxSize, dp[i][j]);\n            }\n        }\n    }\n    \n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "js": "\n    ```javascript\nfunction maximalSquare(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxSize = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    "
    },
    {
        "id": 207,
        "title": "Rectangle Area",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the coordinates of two **rectilinear** rectangles in a 2D plane, return _the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1, ay1)` and its **top-right** corner `(ax2, ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1, by1)` and its **top-right** corner `(bx2, by2)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n**Output:** 45\n\n",
                "**Example 2:**\n\n**Input:** ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n**Output:** 16"
            ],
            "constraints": "**Constraints:**\n\n*   `-104 <= ax1 <= ax2 <= 104`\n*   `-104 <= ay1 <= ay2 <= 104`\n*   `-104 <= bx1 <= bx2 <= 104`\n*   `-104 <= by1 <= by2 <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "-3,0,3,4,0,-1,9,2",
                "output": "45"
            },
            {
                "input": "-2,-2,2,2,-2,-2,2,2",
                "output": "16"
            }
        ],
        "java": "\n    ```java\npublic int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n\n    int overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    int overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n\n    int overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "python": "\n    ```python\ndef total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n\n    return area1 + area2 - overlap_area\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "c++": "\n    ```cpp\nint totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n\n    int overlapWidth = min(ax2, bx2) - max(ax1, bx1);\n    int overlapHeight = min(ay2, by2) - max(ay1, by1);\n\n    int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "js": "\n    ```javascript\nfunction totalArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\n    const area2 = (bx2 - bx1) * (by2 - by1);\n\n    const overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    const overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n\n    const overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    "
    },
    {
        "id": 209,
        "title": "Implement Stack using Queues",
        "difficulty": "Easy",
        "content": {
            "problem": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).\n\nImplement the `MyStack` class:\n\n*   `void push(int x)` Pushes element x to the top of the stack.\n*   `int pop()` Removes the element on the top of the stack and returns it.\n*   `int top()` Returns the element on the top of the stack.\n*   `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.\n\n**Notes:**\n\n*   You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.\n*   Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyStack \",  \"push \",  \"push \",  \"top \",  \"pop \",  \"empty \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 2, 2, false\\]\n\n**Explanation**\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= x <= 9`\n*   At most `100` calls will be made to `push`, `pop`, `top`, and `empty`.\n*   All the calls to `pop` and `top` are valid.\n\n**",
            "follow_up": "Follow-up:** Can you implement the stack using only one queue?"
        },
        "tag": [
            "Stack",
            "Design",
            "Queue"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,2,2,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass MyStack {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n\n    public void push(int x) {\n        q2.add(x);\n        while (!q1.isEmpty()) {\n            q2.add(q1.remove());\n        }\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n\n    public int pop() {\n        return q1.remove();\n    }\n\n    public int top() {\n        return q1.peek();\n    }\n\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n\nclass MyStack {\npublic:\n    std::queue<int> q1, q2;\n\n    void push(int x) {\n        q2.push(x);\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        std::swap(q1, q2);\n    }\n\n    int pop() {\n        int top = q1.front();\n        q1.pop();\n        return top;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n};\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    ",
        "js": "\n    ```javascript\nclass MyStack {\n    constructor() {\n        this.q1 = [];\n        this.q2 = [];\n    }\n\n    push(x) {\n        this.q2.push(x);\n        while (this.q1.length > 0) {\n            this.q2.push(this.q1.shift());\n        }\n        [this.q1, this.q2] = [this.q2, this.q1];\n    }\n\n    pop() {\n        return this.q1.shift();\n    }\n\n    top() {\n        return this.q1[0];\n    }\n\n    empty() {\n        return this.q1.length === 0;\n    }\n}\n```\n    \n    We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1).\n    "
    },
    {
        "id": 210,
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, invert the tree, and return _its root_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3,6,9\\]\n**Output:** \\[4,7,2,9,6,3,1\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,3,1\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[4,2,7,1,3,6,9]",
                "output": "[4,7,2,9,6,3,1]"
            },
            {
                "input": "[2,1,3]",
                "output": "[2,3,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode invertTree(TreeNode root) {\n    if (root == null) {\n        return null;\n    }    \n    TreeNode temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    return root;\n}\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invert_tree(root):\n    if root is None:\n        return None\n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* invertTree(TreeNode* root) {\n    if (root == nullptr) {\n        return nullptr;\n    }    \n    TreeNode* temp = root->left;\n    root->left = invertTree(root->right);\n    root->right = invertTree(temp);\n    return root;\n}\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction invertTree(root) {\n    if (root === null) {\n        return null;\n    }\n    let temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    return root;\n}\n```\n    \n    This recursive algorithm traverses the tree in depth-first search order. At each visited node, we swap its left child with its right child. Then we apply the same process for the children.\n    "
    },
    {
        "id": 212,
        "title": "Summary Ranges",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **sorted unique** integer array `nums`.\n\nA **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive).\n\nReturn _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,4,5,7\\]\n**Output:** \\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n**Explanation:** The ranges are:\n\\[0,2\\] -->  \"0->2 \"\n\\[4,5\\] -->  \"4->5 \"\n\\[7,7\\] -->  \"7 \"\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,2,3,4,6,8,9\\]\n**Output:** \\[ \"0 \", \"2->4 \", \"6 \", \"8->9 \"\\]\n**Explanation:** The ranges are:\n\\[0,0\\] -->  \"0 \"\n\\[2,4\\] -->  \"2->4 \"\n\\[6,6\\] -->  \"6 \"\n\\[8,9\\] -->  \"8->9 \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 20`\n*   `-231 <= nums[i] <= 231 - 1`\n*   All the values of `nums` are **unique**.\n*   `nums` is sorted in ascending order.",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[0,1,2,4,5,7]",
                "output": "[\"0->2\",\"4->5\",\"7\"]"
            },
            {
                "input": "[0,2,3,4,6,8,9]",
                "output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums) {\n    List<String> result = new ArrayList<>();\n    int n = nums.length;\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.add(Integer.toString(start));\n            else\n                result.add(start + \"->\" + nums[i-1]);\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.add(Integer.toString(start));\n    else\n        result.add(start + \"->\" + nums[n-1]);\n\n    return result;\n}\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums) {\n    std::vector<std::string> result;\n    int n = nums.size();\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.push_back(std::to_string(start));\n            else\n                result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i-1]));\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.push_back(std::to_string(start));\n    else\n        result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[n-1]));\n\n    return result;\n}\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    ",
        "js": "\n    ```javascript\nfunction findRanges(nums) {\n    const result = [];\n    const n = nums.length;\n    if (n === 0) return result;\n\n    let start = nums[0];\n    for (let i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1] + 1) {\n            if (start === nums[i - 1])\n                result.push(`${start}`);\n            else\n                result.push(`${start}->${nums[i - 1]}`);\n            start = nums[i];\n        }\n    }\n\n    if (start === nums[n - 1])\n        result.push(`${start}`);\n    else\n        result.push(`${start}->${nums[n - 1]}`);\n\n    return result;\n}\n```\n    \n    The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array.\n    "
    },
    {
        "id": 213,
        "title": "Majority Element II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** \\[3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** \\[1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**",
            "follow_up": "Follow up:** Could you solve the problem in linear time and in `O(1)` space?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[3,2,3]",
                "output": "[3]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            },
            {
                "input": "[1,2]",
                "output": "[1,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> majorityElement(int[] nums) {\n    int n = nums.length;\n    HashMap<Integer, Integer> count = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n        if (count.get(num) > n / 3 && !result.contains(num)) {\n            result.add(num);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "python": "\n    ```python\ndef majorityElement(nums):\n    n = len(nums)\n    count = {}\n    result = []\n\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n        if count[num] > n / 3 and num not in result:\n            result.append(num)\n\n    return result\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> majorityElement(vector<int>& nums) {\n    int n = nums.size();\n    unordered_map<int, int> count;\n    vector<int> result;\n\n    for (int num : nums) {\n        if (count.find(num) == count.end()) {\n            count[num] = 1;\n        } else {\n            count[num]++;\n        }\n        if (count[num] > n / 3 && find(result.begin(), result.end(), num) == result.end()) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "js": "\n    ```javascript\nfunction majorityElement(nums) {\n    const n = nums.length;\n    const count = {};\n    const result = [];\n\n    for (const num of nums) {\n        if (count.hasOwnProperty(num)) {\n            count[num]++;\n        } else {\n            count[num] = 1;\n        }\n        if (count[num] > n / 3 && !result.includes(num)) {\n            result.push(num);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    "
    },
    {
        "id": 215,
        "title": "Power of Two",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of two. Otherwise, return `false`_.\n\nAn integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 20 = 1\n\n",
                "**Example 2:**\n\n**Input:** n = 16\n**Output:** true\n**Explanation:** 24 = 16\n\n",
                "**Example 3:**\n\n**Input:** n = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "tag": [
            "Math",
            "Bit Manipulation",
            "Recursion"
        ],
        "example": [
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "16",
                "output": "true"
            },
            {
                "input": "3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "python": "\n    ```python\ndef is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "js": "\n    ```javascript\nfunction isPowerOfTwo(n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    "
    },
    {
        "id": 216,
        "title": "Implement Queue using Stacks",
        "difficulty": "Easy",
        "content": {
            "problem": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n*   `void push(int x)` Pushes element x to the back of the queue.\n*   `int pop()` Removes the element from the front of the queue and returns it.\n*   `int peek()` Returns the element at the front of the queue.\n*   `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n**Notes:**\n\n*   You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n*   Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyQueue \",  \"push \",  \"push \",  \"peek \",  \"pop \",  \"empty \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 1, 1, false\\]\n\n**Explanation**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: \\[1\\]\nmyQueue.push(2); // queue is: \\[1, 2\\] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is \\[2\\]\nmyQueue.empty(); // return false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= x <= 9`\n*   At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.\n*   All the calls to `pop` and `peek` are valid.\n\n**",
            "follow_up": "Follow-up:** Can you implement the queue such that each operation is **[amortized](https://en.wikipedia.org/wiki/Amortized_analysis)** `O(1)` time complexity? In other words, performing `n` operations will take overall `O(n)` time even if one of those operations may take longer."
        },
        "tag": [
            "Stack",
            "Design",
            "Queue"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,1,1,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    ",
        "python": "\n    ```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    ",
        "c++": "\n    ```cpp\nclass MyQueue {\npublic:\n    stack<int> stack1, stack2;\n\n    MyQueue() {\n    }\n\n    void push(int x) {\n        stack1.push(x);\n    }\n\n    int pop() {\n        if (stack2.empty()) {\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        int top_element = stack2.top();\n        stack2.pop();\n        return top_element;\n    }\n\n    int peek() {\n        if (stack2.empty()) {\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        return stack2.top();\n    }\n\n    bool empty() {\n        return stack1.empty() && stack2.empty();\n    }\n};\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    ",
        "js": "\n    ```javascript\nclass MyQueue {\n    constructor() {\n        this.stack1 = [];\n        this.stack2 = [];\n    }\n\n    push(x) {\n        this.stack1.push(x);\n    }\n\n    pop() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n        return this.stack2.pop();\n    }\n\n    peek() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty() {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n}\n```\n    \n    We can use two stacks(stack1 and stack2) to simulate a queue's functionality. Each time we push an element into the queue, we push it to stack1. \n\nWhen we need to pop or peek the front element, we check if stack2 is empty; if so, pop all elements from stack1 and push them to stack2. The front element of the queue then would be on the top of the stack2. If stack2 is not empty, just pop or peek the top element of stack2.\n\nTo check if the queue is empty, we just need to check if both the stacks are empty.\n\nBy doing this, we are maintaining stack2 as the reversed version of stack1, which allows us to access the elements in the correct order for a queue (FIFO).\n    "
    },
    {
        "id": 217,
        "title": "Number of Digit One",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Recursion"
        ],
        "example": [
            {
                "input": "13",
                "output": "6"
            },
            {
                "input": "0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "python": "\n    ```python\ndef countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "c++": "\n    ```cpp\nint countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "js": "\n    ```javascript\nfunction countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    "
    },
    {
        "id": 218,
        "title": "Palindrome Linked List",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `head` of a singly linked list, return `true` _if it is a_ _palindrome_ _or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,2,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 105]`.\n*   `0 <= Node.val <= 9`\n\n**",
            "follow_up": "Follow up:** Could you do it in `O(n)` time and `O(1)` space?"
        },
        "tag": [
            "Linked List",
            "Two Pointers",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,2,1]",
                "output": "true"
            },
            {
                "input": "[1,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic boolean isPalindrome(ListNode head) {\n    if (head == null || head.next == null) return true;\n\n    ListNode fast = head, slow = head, prev = null;\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        ListNode temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    \n    if (fast != null) slow = slow.next;\n\n    while (prev != null && prev.val == slow.val) {\n        prev = prev.next;\n        slow = slow.next;\n    }\n\n    return prev == null;\n}\n```\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef isPalindrome(head):\n    if not head or not head.next:\n        return True\n\n    fast, slow, prev = head, head, None\n    while fast and fast.next:\n        fast = fast.next.next\n        temp = slow.next\n        slow.next = prev\n        prev = slow\n        slow = temp\n\n    if fast:\n        slow = slow.next\n\n    while prev and prev.val == slow.val:\n        prev = prev.next\n        slow = slow.next\n\n    return prev == None\n```\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nbool isPalindrome(ListNode* head) {\n    if (!head || !head->next) return true;\n\n    ListNode *fast = head, *slow = head, *prev = NULL;\n    while (fast && fast->next) {\n        fast = fast->next->next;\n        ListNode *temp = slow->next;\n        slow->next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    \n    if (fast) slow = slow->next;\n\n    while (prev && prev->val == slow->val) {\n        prev = prev->next;\n        slow = slow->next;\n    }\n\n    return prev == NULL;\n}\n```\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next) {\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    }\n}\n\nfunction isPalindrome(head) {\n    if (!head || !head.next) return true;\n\n    let fast = head, slow = head, prev = null;\n    while (fast && fast.next) {\n        fast = fast.next.next;\n        let temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n\n    if (fast) slow = slow.next;\n\n    while (prev && prev.val === slow.val) {\n        prev = prev.next;\n        slow = slow.next;\n    }\n\n    return prev === null;\n}\n```\n\n    \n    The function uses the slow and fast pointers approach to find the middle of the linked list. It simultaneously reverses the first half of the linked list. At the end of this process, slow will be at the middle and prev will be the reversed first half of the list. If the list has an odd length, slow moves one step forward (skipping the middle element). Finally, we compare the elements of the reversed first half (using prev) and the rest of the list (starting from slow). If they match, it means the list is a palindrome.\n    "
    },
    {
        "id": 223,
        "title": "Sliding Window Maximum",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn _the max sliding window_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,-1,-3,5,3,6,7\\], k = 3\n**Output:** \\[3,3,5,5,6,7\\]\n**Explanation:** \nWindow position                Max\n---------------               -----\n\\[1  3  -1\\] -3  5  3  6  7       **3**\n 1 \\[3  -1  -3\\] 5  3  6  7       **3**\n 1  3 \\[-1  -3  5\\] 3  6  7      ** 5**\n 1  3  -1 \\[-3  5  3\\] 6  7       **5**\n 1  3  -1  -3 \\[5  3  6\\] 7       **6**\n 1  3  -1  -3  5 \\[3  6  7\\]      **7**\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[1,3,-1,-3,5,3,6,7],3",
                "output": "[3,3,5,5,6,7]"
            },
            {
                "input": "[1],1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Deque;\n\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    if (nums == null || nums.length == 0) return new int[0];\n    int[] result = new int[nums.length - k + 1];\n    int idx = 0;\n    Deque<Integer> deque = new LinkedList<Integer>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        if (!deque.isEmpty() && deque.peekFirst() == i - k) deque.poll();\n            \n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.removeLast();\n        }    \n            \n        deque.offer(i);\n        if (i >= k - 1) {\n            result[idx++] = nums[deque.peek()];\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n\n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n\n        dq.append(i)\n\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <deque>\n\nstd::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n    std::vector<int> result;\n    std::deque<int> dq;\n\n    for (int i = 0; i < nums.size(); i++) {\n        while (!dq.empty() && dq.front() < i - k + 1) {\n            dq.pop_front();\n        }\n\n        while (!dq.empty() && nums[dq.back()] < nums[i]) {\n            dq.pop_back();\n        }\n\n        dq.push_back(i);\n\n        if (i >= k - 1) {\n            result.push_back(nums[dq.front()]);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    ",
        "js": "\n    ```javascript\nfunction maxSlidingWindow(nums, k) {\n  let result = [];\n  let dq = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    while (dq.length && dq[0] < i - k + 1) {\n      dq.shift();\n    }\n\n    while (dq.length && nums[dq[dq.length - 1]] < nums[i]) {\n      dq.pop();\n    }\n\n    dq.push(i);\n\n    if (i >= k - 1) {\n      result.push(nums[dq[0]]);\n    }\n  }\n\n  return result;\n}\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    "
    },
    {
        "id": 226,
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"anagram\", t = \"nagaram\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"rat\", t = \"car\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 5 * 104`\n*   `s` and `t` consist of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?"
        },
        "tag": [
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"anagram\",\"nagaram\"",
                "output": "true"
            },
            {
                "input": "\"rat\",\"car\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isAnagram(String s, String t) {\n    if(s.length() != t.length())\n        return false;\n\n    int[] counts = new int[26];\n    for(char c : s.toCharArray())\n        counts[c - 'a']++;\n\n    for(char c : t.toCharArray()) {\n        if(counts[c - 'a'] == 0)\n            return false;\n        counts[c - 'a']--;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "python": "\n    ```python\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n\n    for c in t:\n        if c not in counts or counts[c] == 0:\n            return False\n        counts[c] -= 1\n\n    return True\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "c++": "\n    ```cpp\nbool isAnagram(std::string s, std::string t) {\n    if(s.size() != t.size())\n        return false;\n    \n    std::unordered_map<char, int> counts;\n    for(char c : s)\n        counts[c]++;\n        \n    for(char c : t) {\n        if(counts[c] == 0)\n            return false;\n        counts[c]--;\n    }\n    \n    return true;\n}\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "js": "\n    ```javascript\nfunction isAnagram(s, t) {\n    if (s.length !== t.length)\n        return false;\n\n    const counts = {};\n    for (let c of s)\n        counts[c] = (counts[c] || 0) + 1;\n\n    for (let c of t) {\n        if (counts[c] === 0 || !counts[c])\n            return false;\n        counts[c]--;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    "
    },
    {
        "id": 230,
        "title": "Strobogrammatic Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `num` which represents an integer, return `true` _if_ `num` _is a **strobogrammatic number**_.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"69 \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** num =  \"88 \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** num =  \"962 \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 50`\n*   `num` consists of only digits.\n*   `num` does not contain any leading zeros except for zero itself.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"69\"",
                "output": "true"
            },
            {
                "input": "\"88\"",
                "output": "true"
            },
            {
                "input": "\"962\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "python": "\n    ```python\ndef isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "c++": "\n    ```cpp\nbool isStrobogrammatic(string num) {\n    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int left = 0, right = num.size() - 1;\n    while(left <= right) {\n        if(lookup[num[left]] != num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "js": "\n    ```javascript\nfunction isStrobogrammatic(num) {\n    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};\n    let left = 0, right = num.length - 1;\n    while(left <= right) {\n        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    "
    },
    {
        "id": 236,
        "title": "Meeting Rooms",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,30],[5,10],[15,20]]",
                "output": "false"
            },
            {
                "input": "[[7,10],[2,4]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    for (int i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "python": "\n    ```python\ndef can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    \n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "js": "\n    ```javascript\nfunction canAttendMeetings(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    "
    },
    {
        "id": 240,
        "title": "Paint House",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n\n",
                "**Example 2:**\n\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[17,2,17],[16,16,5],[14,3,19]]",
                "output": "10"
            },
            {
                "input": "[[7,6,2]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minCost(int[][] costs) {\n    if (costs.length == 0) return 0;\n    for (int i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], Math.min(costs[costs.length - 1][1], costs[costs.length - 1][2]));\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "python": "\n    ```python\ndef minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n    for (int i = 1; i < costs.size(); ++i) {\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return min(costs.back()[0], min(costs.back()[1], costs.back()[2]));\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "js": "\n    ```javascript\nfunction minCost(costs) {\n    if (costs.length === 0) return 0;\n    for (let i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1], costs[costs.length - 1][2]);\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    "
    },
    {
        "id": 241,
        "title": "Binary Tree Paths",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _all root-to-leaf paths in **any order**_.\n\nA **leaf** is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,null,5\\]\n**Output:** \\[ \"1->2->5 \", \"1->3 \"\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[ \"1 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,null,5]",
                "output": "[\"1->2->5\",\"1->3\"]"
            },
            {
                "input": "[1]",
                "output": "[\"1\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> paths = new ArrayList<>();\n    if (root == null) {\n        return paths;\n    }\n    if (root.left == null && root.right == null) {\n        paths.add(Integer.toString(root.val));\n        return paths;\n    }\n    for (String path : binaryTreePaths(root.left)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    for (String path : binaryTreePaths(root.right)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    return paths;\n}\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef binary_tree_paths(root: TreeNode):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    paths = []\n    for path in binary_tree_paths(root.left):\n        paths.append(str(root.val) + \"->\" + path)\n    for path in binary_tree_paths(root.right):\n        paths.append(str(root.val) + \"->\" + path)\n    return paths\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::string> binaryTreePaths(TreeNode* root) {\n    std::vector<std::string> paths;\n    if (!root)\n        return paths;\n    if (!root->left && !root->right) {\n        paths.push_back(std::to_string(root->val));\n        return paths;\n    }\n    for (const std::string &path : binaryTreePaths(root->left)) {\n      paths.push_back(std::to_string(root->val) + \"->\" + path);\n    }\n    for (const std::string &path : binaryTreePaths(root->right)) {\n      paths.push_back(std::to_string(root->val) + \"->\" + path);\n    }\n    return paths;\n}\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction binaryTreePaths(root) {\n    if (!root) {\n        return [];\n    }\n    if (!root.left && !root.right) {\n        return [`${root.val}`];\n    }\n    let paths = [];\n    for (let path of binaryTreePaths(root.left)) {\n        paths.push(`${root.val}->${path}`);\n    }\n    for (let path of binaryTreePaths(root.right)) {\n        paths.push(`${root.val}->${path}`);\n    }\n    return paths;\n}\n```\n    \n    The algorithm is a simple recursive algorithm that explores depth-first each node of the binary tree. Initially, if the root is `null`, it returns an empty result. Next, if it's a leaf node, it returns the node's value as a string. If it's not a leaf node, it iteratively calls the `binary_tree_paths()` function for the left child and then the right child, appending the current node's value and a \" -> \" separator at the beginning of each path. Finally, it aggregates and returns all the resulting paths of the recursive calls. The language-specific implementations are all very similar, with only slight syntax adjustments across languages.\n    "
    },
    {
        "id": 242,
        "title": "Add Digits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 38\n**Output:** 2\n**Explanation:** The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it.\n\n",
                "**Example 2:**\n\n**Input:** num = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you do it without any loop/recursion in `O(1)` runtime?"
        },
        "tag": [
            "Math",
            "Simulation",
            "Number Theory"
        ],
        "example": [
            {
                "input": "38",
                "output": "2"
            },
            {
                "input": "0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "python": "\n    ```python\ndef addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "c++": "\n    ```cpp\nint addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "js": "\n    ```javascript\nfunction addDigits(num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    "
    },
    {
        "id": 243,
        "title": "3Sum Smaller",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,0,1,3\\], target = 2\n**Output:** 2\n**Explanation:** Because there are two triplets which sums are less than 2:\n\\[-2,0,1\\]\n\\[-2,0,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0\\], target = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `0 <= n <= 3500`\n*   `-100 <= nums[i] <= 100`\n*   `-100 <= target <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[-2,0,1,3],2",
                "output": "2"
            },
            {
                "input": "[],0",
                "output": "0"
            },
            {
                "input": "[0],0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int threeSumSmaller(int[] nums, int target) {\n    int count = 0;\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length; ++i) {\n        int j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "python": "\n    ```python\ndef threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "c++": "\n    ```cpp\nint threeSumSmaller(vector<int>& nums, int target) {\n    int count = 0;\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < nums.size(); ++i) {\n        int j = i + 1, k = nums.size() - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "js": "\n    ```javascript\nfunction threeSumSmaller(nums, target) {\n    let count = 0;\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; ++i) {\n        let j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    "
    },
    {
        "id": 246,
        "title": "Ugly Number",
        "difficulty": "Easy",
        "content": {
            "problem": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6\n**Output:** true\n**Explanation:** 6 = 2 \\* 3\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n",
                "**Example 3:**\n\n**Input:** n = 14\n**Output:** false\n**Explanation:** 14 is not ugly since it includes the prime factor 7."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "6",
                "output": "true"
            },
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "14",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "python": "\n    ```python\ndef is_ugly(n: int) -> bool:\n    if n <= 0:\n        return False\n    for factor in [2, 3, 5]:\n        while n % factor == 0:\n            n //= factor\n    return n == 1\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "c++": "\n    ```cpp\nbool isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "js": "\n    ```javascript\nfunction isUgly(n) {\n    if (n <= 0) return false;\n    while (n % 2 === 0) n /= 2;\n    while (n % 3 === 0) n /= 3;\n    while (n % 5 === 0) n /= 5;\n    return n === 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    "
    },
    {
        "id": 249,
        "title": "Palindrome Permutation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return `true` _if a permutation of the string could form a_ _**palindrome**_ _and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"code \"\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aab \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"carerac \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5000`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"code\"",
                "output": "false"
            },
            {
                "input": "\"aab\"",
                "output": "true"
            },
            {
                "input": "\"carerac\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean canPermutePalindrome(String s) {\n    HashMap<Character, Integer> count = new HashMap<>();\n    for(char c : s.toCharArray()) {\n        count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n    int odd_count = 0;\n    for(int value : count.values()) {\n        if (value % 2 != 0) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef canPermutePalindrome(s: str) -> bool:\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    odd_count = 0\n    for value in count.values():\n        if value % 2:\n            odd_count += 1\n    return odd_count <= 1\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool canPermutePalindrome(string s) {\n    unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n    int odd_count = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        if (it->second % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction canPermutePalindrome(s) {\n    const count = {}\n    for (const c of s) {\n        if (c in count) {\n            count[c]++;\n        } else {\n            count[c] = 1;\n        }\n    }\n    let odd_count = 0;\n    for (const value of Object.values(count)) {\n        if (value % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    "
    },
    {
        "id": 251,
        "title": "Missing Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n\n**",
            "follow_up": "Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Bit Manipulation",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,0,1]",
                "output": "2"
            },
            {
                "input": "[0,1]",
                "output": "2"
            },
            {
                "input": "[9,6,4,2,3,5,7,0,1]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int missingNumber(int[] nums) {\n    int n = nums.length;\n    int expectedSum = (n * (n + 1)) / 2;\n    int actualSum = 0;\n    for (int num : nums) {\n        actualSum += num;\n    }\n    return expectedSum - actualSum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "python": "\n    ```python\ndef missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "c++": "\n    ```cpp\nint missingNumber(vector<int>& nums) {\n    int n = nums.size();\n    int expected_sum = (n * (n + 1)) / 2;\n    int actual_sum = 0;\n    for (int num : nums) {\n        actual_sum += num;\n    }\n    return expected_sum - actual_sum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "js": "\n    ```javascript\nfunction missingNumber(nums) {\n    const n = nums.length;\n    const expectedSum = (n * (n + 1)) / 2;\n    const actualSum = nums.reduce((acc, num) => acc + num, 0);\n    return expectedSum - actualSum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    "
    },
    {
        "id": 252,
        "title": "Alien Dictionary",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language.\n\nReturn _a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules._ If there is no solution, return `\" \"`_._ If there are multiple solutions, return _**any of them**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"wrt \", \"wrf \", \"er \", \"ett \", \"rftt \"\\]\n**Output:**  \"wertf \"\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"z \", \"x \"\\]\n**Output:**  \"zx \"\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"z \", \"x \", \"z \"\\]\n**Output:**  \" \"\n**Explanation:** The order is invalid, so return ` \" \"`."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
                "output": "\"wertf\""
            },
            {
                "input": "[\"z\",\"x\"]",
                "output": "\"zx\""
            },
            {
                "input": "[\"z\",\"x\",\"z\"]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String alienOrder(String[] words) {\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    Map<Character, Integer> inDegree = new HashMap<>();\n    \n    for (String word : words) {\n        for (char c : word.toCharArray())\n            inDegree.put(c, 0);\n    }\n    \n    for (int i = 0; i < words.length - 1; i++) {\n        String word1 = words[i], word2 = words[i + 1];\n        \n        boolean found = false;\n        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n            char c1 = word1.charAt(j), c2 = word2.charAt(j);\n            if (c1 != c2) {\n                graph.putIfAbsent(c1, new HashSet<>());\n                if (!graph.get(c1).contains(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.put(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length() > word2.length())\n            return \"\";\n    }\n\n    Queue<Character> q = new LinkedList<>();\n    for (Map.Entry<Character, Integer> entry : inDegree.entrySet())\n        if (entry.getValue() == 0)\n            q.offer(entry.getKey());\n    \n    StringBuilder result = new StringBuilder();\n    while (!q.isEmpty()) {\n        char c = q.poll();\n        result.append(c);\n        \n        if (graph.containsKey(c)) {\n            for (char neigh : graph.get(c)) {\n                inDegree.put(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) == 0)\n                    q.offer(neigh);\n            }\n        }\n    }\n    \n    if (result.length() < inDegree.size())\n        return \"\";\n    \n    return result.toString();\n}\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    ",
        "python": "\n    ```python\nfrom collections import deque, defaultdict, Counter\n\ndef alienOrder(words):\n    graph = defaultdict(set)\n    in_degree = Counter({c: 0 for word in words for c in word})\n    \n    for word1, word2 in zip(words, words[1:]):\n        found = False\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    in_degree[c2] += 1\n                found = True\n                break\n        if not found and len(word1) > len(word2):\n            return \"\"\n    \n    q = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    while q:\n        c = q.popleft()\n        result.append(c)\n        \n        for neigh in graph[c]:\n            in_degree[neigh] -= 1\n            if in_degree[neigh] == 0:\n                q.append(neigh)\n                 \n    if len(result) < len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nstd::string alienOrder(std::vector<std::string> &words) {\n    std::unordered_map<char, std::unordered_set<char>> graph;\n    std::unordered_map<char, int> inDegree;\n    \n    for (const std::string &word : words)\n        for (char c : word)\n            inDegree[c] = 0;\n    \n    for (int i = 0; i < words.size() - 1; i++) {\n        std::string word1 = words[i], word2 = words[i + 1];\n        \n        bool found = false;\n        for (int j = 0; j < std::min(word1.size(), word2.size()); j++) {\n            char c1 = word1[j], c2 = word2[j];\n            if (c1 != c2) {\n                if (!graph[c1].count(c2)) {\n                    graph[c1].insert(c2);\n                    inDegree[c2]++;\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.size() > word2.size())\n            return \"\";\n    }\n\n    std::queue<char> q;\n    for (auto &[c, deg] : inDegree)\n        if (deg == 0)\n            q.push(c);\n    \n    std::string result;\n    while (!q.empty()) {\n        char c = q.front();\n        q.pop();\n        result += c;\n        \n        for (char neigh : graph[c]) {\n            inDegree[neigh]--;\n            if (inDegree[neigh] == 0)\n                q.push(neigh);\n        }\n    }\n    \n    if (result.size() < inDegree.size())\n        return \"\";\n    \n    return result;\n}\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    ",
        "js": "\n    ```javascript\nfunction alienOrder(words) {\n    const graph = new Map();\n    const inDegree = new Map();\n    \n    for (const word of words)\n        for (const c of word)\n            inDegree.set(c, 0);\n    \n    for (let i = 0; i < words.length - 1; i++) {\n        const word1 = words[i], word2 = words[i + 1];\n        \n        let found = false;\n        for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n            const c1 = word1[j], c2 = word2[j];\n            if (c1 !== c2) {\n                if (!graph.has(c1)) graph.set(c1, new Set());\n                if (!graph.get(c1).has(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.set(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length > word2.length)\n            return \"\";\n    }\n\n    const q = [];\n    for (const [c, deg] of inDegree.entries())\n        if (deg === 0)\n            q.push(c);\n    \n    let result = \"\";\n    while (q.length) {\n        const c = q.shift();\n        result += c;\n        \n        if (graph.has(c)) {\n            for (const neigh of graph.get(c)) {\n                inDegree.set(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) === 0)\n                    q.push(neigh);\n            }\n        }\n    }\n    \n    if (result.length < inDegree.size)\n        return \"\";\n    \n    return result;\n}\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    "
    },
    {
        "id": 253,
        "title": "Closest Binary Search Tree Value",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree and a `target` value, return _the value in the BST that is closest to the_ `target`. If there are multiple answers, print the smallest.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\], target = 3.714286\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\], target = 4.428571\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 109`\n*   `-109 <= target <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,5,1,3],3.714286",
                "output": "4"
            },
            {
                "input": "[1],4.428571",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public int closestValue(TreeNode root, double target) {\n        int closest = root.val;\n        while (root != null) {\n            if (Math.abs(target - closest) > Math.abs(target - root.val)) {\n                closest = root.val;\n            }\n            root = target < root.val ? root.left : root.right;\n        }\n        return closest;\n    }\n}\n```\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def closestValue(self, root: TreeNode, target: float) -> int:\n        closest = root.val\n        while root:\n            if abs(target - closest) > abs(target - root.val):\n                closest = root.val\n            root = root.left if target < root.val else root.right\n        return closest\n```\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        int closest = root->val;\n        while (root != nullptr) {\n            if (abs(target - closest) > abs(target - root->val)) {\n                closest = root->val;\n            }\n            root = target < root->val ? root->left : root->right;\n        }\n        return closest;\n    }\n};\n```\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    ",
        "js": "\n    ```javascript\nvar closestValue = function(root, target) {\n    let closest = root.val;\n    while (root !== null) {\n        if (Math.abs(target - closest) > Math.abs(target - root.val)) {\n            closest = root.val;\n        }\n        root = target < root.val ? root.left : root.right;\n    }\n    return closest;\n};\n```\n\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    "
    },
    {
        "id": 255,
        "title": "Closest Binary Search Tree Value II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the `root` of a binary search tree, a `target` value, and an integer `k`, return _the_ `k` _values in the BST that are closest to the_ `target`. You may return the answer in **any order**.\n\nYou are **guaranteed** to have only one unique set of `k` values in the BST that are closest to the `target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\], target = 3.714286, k = 2\n**Output:** \\[4,3\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\], target = 0.000000, k = 1\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`.\n*   `0 <= Node.val <= 109`\n*   `-109 <= target <= 109`\n\n**",
            "follow_up": "Follow up:** Assume that the BST is balanced. Could you solve it in less than `O(n)` runtime (where `n = total nodes`)?"
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,5,1,3],3.714286,2",
                "output": "[4,3]"
            },
            {
                "input": "[1],0.000000,1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> closestKValues(TreeNode root, double target, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));\n    List<Integer> values = new ArrayList<>();\n\n    inorderTraversal(root, target, k, maxHeap);\n\n    while (!maxHeap.isEmpty()) {\n        values.add(maxHeap.poll()[0]);\n    }\n    return values;\n}\n\nvoid inorderTraversal(TreeNode node, double target, int k, PriorityQueue<int[]> maxHeap) {\n    if (node == null) return;\n\n    inorderTraversal(node.left, target, k, maxHeap);\n    maxHeap.offer(new int[]{node.val, Math.abs(node.val - target)});\n    if (maxHeap.size() > k) maxHeap.poll();\n    inorderTraversal(node.right, target, k, maxHeap);\n}\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef closestKValues(root, target, k):\n    values = []\n    max_heap = []\n\n    def inorder_traverse(node):\n        if not node:\n            return\n        inorder_traverse(node.left)\n        heappush(max_heap, (-abs(node.val - target), node.val))\n        if len(max_heap) > k:\n            heappop(max_heap)\n        inorder_traverse(node.right)\n\n    inorder_traverse(root)\n    while max_heap:\n        _, val = heappop(max_heap)\n        values.append(val)\n    return values\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvector<int> closestKValues(TreeNode* root, double target, int k) {\n    vector<int> values;\n    priority_queue<pair<double, int>> maxHeap;\n\n    function<void(TreeNode*)> inorderTraverse = [&](TreeNode* node) {\n        if (!node) return;\n        inorderTraverse(node->left);\n        maxHeap.push(make_pair(fabs(node->val - target), node->val));\n        if (maxHeap.size() > k) maxHeap.pop();\n        inorderTraverse(node->right);\n    };\n\n    inorderTraverse(root);\n    while (!maxHeap.empty()) {\n        values.push_back(maxHeap.top().second);\n        maxHeap.pop();\n    }\n    return values;\n}\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction closestKValues(root, target, k) {\n    const values = [];\n    const maxHeap = [];\n\n    function inorderTraversal(node) {\n        if (!node) return;\n        inorderTraversal(node.left);\n        maxHeap.push({diff: Math.abs(node.val - target), val: node.val});\n        maxHeap.sort((a, b) => b.diff - a.diff);\n        if (maxHeap.length > k) maxHeap.pop();\n        inorderTraversal(node.right);\n    }\n\n    inorderTraversal(root);\n    for (let item of maxHeap) {\n        values.push(item.val);\n    }\n    return values;\n}\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    "
    },
    {
        "id": 256,
        "title": "Integer to English Words",
        "difficulty": "Hard",
        "content": {
            "problem": "Convert a non-negative integer `num` to its English words representation.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 123\n**Output:**  \"One Hundred Twenty Three \"\n\n",
                "**Example 2:**\n\n**Input:** num = 12345\n**Output:**  \"Twelve Thousand Three Hundred Forty Five \"\n\n",
                "**Example 3:**\n\n**Input:** num = 1234567\n**Output:**  \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Recursion"
        ],
        "example": [
            {
                "input": "123",
                "output": "\"OneHundredTwentyThree\""
            },
            {
                "input": "12345",
                "output": "\"TwelveThousandThreeHundredFortyFive\""
            },
            {
                "input": "1234567",
                "output": "\"OneMillionTwoHundredThirtyFourThousandFiveHundredSixtySeven\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    private final String[] LESS_THAN_20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    private final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    private final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        StringBuilder result = new StringBuilder();\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result.insert(0, helper(num % 1000) + THOUSANDS[i] + \" \");\n            }\n            num /= 1000;\n            i++;\n        }\n        return result.toString().trim();\n    }\n\n    private String helper(int num) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return LESS_THAN_20[num] + \" \";\n        } else if (num < 100) {\n            return TENS[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n}\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return LESS_THAN_20[num] + \" \"\n            elif num < 100:\n                return TENS[num // 10] + \" \" + helper(num % 10)\n            else:\n                return LESS_THAN_20[num // 100] + \" Hundred \" + helper(num % 100)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    std::string numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        std::string result;\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result;\n            }\n            num /= 1000;\n            i++;\n        }\n        return trim(result);\n    }\n\nprivate:\n    std::vector<std::string> LESS_THAN_20 = {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\n    };\n    std::vector<std::string> TENS = {\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\n    };\n    std::vector<std::string> THOUSANDS = {\n        \"\", \"Thousand\", \"Million\", \"Billion\"\n    };\n\n    std::string helper(int num) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return LESS_THAN_20[num] + \" \";\n        } else if (num < 100) {\n            return TENS[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n\n    std::string trim(const std::string& str) {\n        return str.substr(0, str.find_last_not_of(' ') + 1);\n    }\n};\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    numberToWords(num) {\n        if (num === 0) return \"Zero\";\n\n        const LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\n        const TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\n        const THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"];\n\n        function helper(num) {\n            if (num === 0) {\n                return \"\";\n            } else if (num < 20) {\n                return LESS_THAN_20[num] + \" \";\n            } else if (num < 100) {\n                return TENS[Math.floor(num / 10)] + \" \" + helper(num % 10);\n            } else {\n                return LESS_THAN_20[Math.floor(num / 100)] + \" Hundred \" + helper(num % 100);\n            }\n        }\n\n        let result = \"\";\n        let i = 0;\n        while (num > 0) {\n            if (num % 1000 !== 0) {\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result;\n            }\n            num = Math.floor(num / 1000);\n            i++;\n        }\n        return result.trim();\n    }\n}\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    "
    },
    {
        "id": 257,
        "title": "H-Index",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.",
            "examples": [
                "**Example 1:**\n\n**Input:** citations = \\[3,0,6,1,5\\]\n**Output:** 3\n**Explanation:** \\[3,0,6,1,5\\] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n",
                "**Example 2:**\n\n**Input:** citations = \\[1,3,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 5000`\n*   `0 <= citations[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Counting Sort"
        ],
        "example": [
            {
                "input": "[3,0,6,1,5]",
                "output": "3"
            },
            {
                "input": "[1,3,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int hIndex(int[] citations) {\n    Arrays.sort(citations);\n    int h = 0;\n    for (int i = citations.length - 1; i >= 0; i--) {\n        int rank = citations.length - i;\n        if (citations[i] >= rank) {\n            h = rank;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "python": "\n    ```python\ndef hIndex(citations: List[int]) -> int:\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "c++": "\n    ```cpp\nint hIndex(vector<int>& citations) {\n    sort(citations.begin(), citations.end(), greater<int>());\n    int h = 0;\n    for (int i = 0; i < citations.size(); ++i) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "js": "\n    ```javascript\nfunction hIndex(citations) {\n    citations.sort((a, b) => b - a);\n    let h = 0;\n    for (let i = 0; i < citations.length; i++) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    "
    },
    {
        "id": 258,
        "title": "H-Index II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in **ascending order**, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\nYou must write an algorithm that runs in logarithmic time.",
            "examples": [
                "**Example 1:**\n\n**Input:** citations = \\[0,1,3,5,6\\]\n**Output:** 3\n**Explanation:** \\[0,1,3,5,6\\] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n",
                "**Example 2:**\n\n**Input:** citations = \\[1,2,100\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 105`\n*   `0 <= citations[i] <= 1000`\n*   `citations` is sorted in **ascending order**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[0,1,3,5,6]",
                "output": "3"
            },
            {
                "input": "[1,2,100]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int hIndex(int[] citations) {\n    int n = citations.length;\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "python": "\n    ```python\ndef hIndex(citations: List[int]) -> int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if citations[mid] == n - mid:\n            return n - mid\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return n - left\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "c++": "\n    ```cpp\nint hIndex(vector<int>& citations) {\n    int n = citations.size();\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "js": "\n    ```javascript\nfunction hIndex(citations) {\n    const n = citations.length;\n    let left = 0, right = n - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (citations[mid] === n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    "
    },
    {
        "id": 259,
        "title": "Paint Fence",
        "difficulty": "Medium",
        "content": {
            "problem": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 6\n**Explanation:** All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** n = 7, k = 2\n**Output:** 42"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= k <= 105`\n*   The testcases are generated such that the answer is in the range `[0, 231 - 1]` for the given `n` and `k`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,2",
                "output": "6"
            },
            {
                "input": "1,1",
                "output": "1"
            },
            {
                "input": "7,2",
                "output": "42"
            }
        ],
        "java": "\n    ```java\npublic int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "python": "\n    ```python\ndef numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "c++": "\n    ```cpp\nint numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "js": "\n    ```javascript\nfunction numWays(n, k) {\n    if (n === 0) return 0;\n    if (n === 1) return k;\n\n    let same = k;\n    let different = k * (k - 1);\n    for (let i = 2; i < n; ++i) {\n        const temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    "
    },
    {
        "id": 261,
        "title": "First Bad Version",
        "difficulty": "Easy",
        "content": {
            "problem": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Binary Search",
            "Interactive"
        ],
        "example": [
            {
                "input": "5,4",
                "output": "4"
            },
            {
                "input": "1,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "python": "\n    ```python\ndef first_bad_version(n):\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "c++": "\n    ```cpp\nint firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "js": "\n    ```javascript\nfunction firstBadVersion(n) {\n    let left = 1;\n    let right = n;\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    "
    },
    {
        "id": 265,
        "title": "Expression Add Operators",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `num` that contains only digits and an integer `target`, return _**all possibilities** to insert the binary operators_ `'+'`_,_ `'-'`_, and/or_ `'*'` _between the digits of_ `num` _so that the resultant expression evaluates to the_ `target` _value_.\n\nNote that operands in the returned expressions **should not** contain leading zeros.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"123 \", target = 6\n**Output:** \\[ \"1\\*2\\*3 \", \"1+2+3 \"\\]\n**Explanation:** Both  \"1\\*2\\*3 \" and  \"1+2+3 \" evaluate to 6.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"232 \", target = 8\n**Output:** \\[ \"2\\*3+2 \", \"2+3\\*2 \"\\]\n**Explanation:** Both  \"2\\*3+2 \" and  \"2+3\\*2 \" evaluate to 8.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"3456237490 \", target = 9191\n**Output:** \\[\\]\n**Explanation:** There are no expressions that can be created from  \"3456237490 \" to evaluate to 9191."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 10`\n*   `num` consists of only digits.\n*   `-231 <= target <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Backtracking"
        ],
        "example": [
            {
                "input": "\"123\",6",
                "output": "[\"1*2*3\",\"1+2+3\"]"
            },
            {
                "input": "\"232\",8",
                "output": "[\"2*3+2\",\"2+3*2\"]"
            },
            {
                "input": "\"3456237490\",9191",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> addOperators(String num, int target) {\n    List<String> res = new ArrayList<>();\n    helper(num, target, 0, 0, 0, \"\", res);\n    return res;\n}\n\nprivate void helper(String num, int target, int pos, long currVal, long prevVal, String currExpr, List<String> res) {\n    if (pos == num.length()) {\n        if (currVal == target) {\n            res.add(currExpr);\n        }\n        return;\n    }\n\n    for (int i = pos; i < num.length(); ++i) {\n        if (i != pos && num.charAt(pos) == '0') break;\n        long val = Long.parseLong(num.substring(pos, i + 1));\n        if (pos == 0) {\n            helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1), res);\n        } else {\n            helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substring(pos, i + 1), res);\n            helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substring(pos, i + 1), res);\n            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substring(pos, i + 1), res);\n        }\n    }\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef addOperators(num: str, target: int) -> List[str]:\n    def helper(num, target, pos, currVal, prevVal, currExpr):\n        if pos == len(num):\n            if currVal == target:\n                res.append(currExpr)\n            return\n\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':\n                break\n\n            val = int(num[pos:i + 1])\n            if pos == 0:\n                helper(num, target, i + 1, val, val, currExpr + num[pos:i + 1])\n            else:\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num[pos:i + 1])\n\n    res = []\n    helper(num, target, 0, 0, 0, \"\")\n    return res\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nvoid helper(const std::string &num, int target, int pos, long long currVal, long long prevVal, std::string currExpr, std::vector<std::string> &res) {\n    if (pos == num.size()) {\n        if (currVal == target) {\n            res.push_back(currExpr);\n        }\n        return;\n    }\n\n    for (int i = pos; i < num.size(); ++i) {\n        if (i != pos && num[pos] == '0') break;\n        long long val = std::stoll(num.substr(pos, i - pos + 1));\n        if (pos == 0) {\n            helper(num, target, i + 1, val, val, currExpr + num.substr(pos, i - pos + 1), res);\n        } else {\n            helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substr(pos, i - pos + 1), res);\n            helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substr(pos, i - pos + 1), res);\n            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substr(pos, i - pos + 1), res);\n        }\n    }\n}\n\nstd::vector<std::string> addOperators(std::string num, int target) {\n    std::vector<std::string> res;\n    helper(num, target, 0, 0, 0, \"\", res);\n    return res;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    ",
        "js": "\n    ```javascript\nvar addOperators = function(num, target) {\n    const res = [];\n    const helper = (num, target, pos, currVal, prevVal, currExpr) => {\n        if (pos === num.length) {\n            if (currVal === target) {\n                res.push(currExpr);\n            }\n            return;\n        }\n\n        for (let i = pos; i < num.length; ++i) {\n            if (i !== pos && num[pos] === '0') break;\n\n            const val = parseInt(num.substring(pos, i + 1));\n            if (pos === 0) {\n                helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1));\n            } else {\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substring(pos, i + 1));\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substring(pos, i + 1));\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substring(pos, i + 1));\n            }\n        }\n    }\n\n    helper(num, target, 0, 0, 0, \"\");\n    return res;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    "
    },
    {
        "id": 266,
        "title": "Move Zeroes",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n\n**Note** that you must do this in-place without making a copy of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,0,3,12\\]\n**Output:** \\[1,3,12,0,0\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you minimize the total number of operations done?"
        },
        "tag": [
            "Array",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[0,1,0,3,12]",
                "output": "[1,3,12,0,0]"
            },
            {
                "input": "[0]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\npublic void moveZeroes(int[] nums) {\n    int index = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "python": "\n    ```python\ndef moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "c++": "\n    ```cpp\nvoid moveZeroes(vector<int>& nums) {\n    int index = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "js": "\n    ```javascript\nfunction moveZeroes(nums) {\n    let index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (let i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    "
    },
    {
        "id": 270,
        "title": "Find the Duplicate Number",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in `nums`, return _this repeated number_.\n\nYou must solve the problem **without** modifying the array `nums` and uses only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,4,2,2\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,1,3,4,2\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `nums.length == n + 1`\n*   `1 <= nums[i] <= n`\n*   All the integers in `nums` appear only **once** except for **precisely one integer** which appears **two or more** times.\n\n**",
            "follow_up": "Follow up:**\n\n*   How can we prove that at least one duplicate number must exist in `nums`?\n*   Can you solve the problem in linear runtime complexity?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,3,4,2,2]",
                "output": "2"
            },
            {
                "input": "[3,1,3,4,2]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findDuplicate(int[] nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "python": "\n    ```python\ndef findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "c++": "\n    ```cpp\nint findDuplicate(vector<int>& nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "js": "\n    ```javascript\nfunction findDuplicate(nums) {\n    let slow = nums[0];\n    let fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow !== fast);\n\n    slow = nums[0];\n\n    while (slow !== fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    "
    },
    {
        "id": 273,
        "title": "Word Pattern",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat dog \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat fish \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** pattern =  \"aaaa \", s =  \"dog cat cat dog \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pattern.length <= 300`\n*   `pattern` contains only lower-case English letters.\n*   `1 <= s.length <= 3000`\n*   `s` contains only lowercase English letters and spaces `' '`.\n*   `s` **does not contain** any leading or trailing spaces.\n*   All the words in `s` are separated by a **single space**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"abba\",\"dogcatcatdog\"",
                "output": "true"
            },
            {
                "input": "\"abba\",\"dogcatcatfish\"",
                "output": "false"
            },
            {
                "input": "\"aaaa\",\"dogcatcatdog\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    if (pattern.length() != words.length) return false;\n\n    Map<Character, String> charMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        String word = words[i];\n        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {\n            charMap.put(c, word);\n            wordMap.put(word, c);\n        } else {\n            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "python": "\n    ```python\ndef word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_map, word_map = {}, {}\n    for c, word in zip(pattern, words):\n        if c not in char_map and word not in word_map:\n            char_map[c] = word\n            word_map[word] = c\n        else:\n            if char_map.get(c) != word or word_map.get(word) != c:\n                return False\n\n    return True\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nbool wordPattern(string pattern, string s) {\n    unordered_map<char, string> char_map;\n    unordered_map<string, char> word_map;\n    stringstream ss(s);\n\n    int i = 0;\n    for (string word; ss >> word; ++i) {\n        if (i == pattern.size()) return false;\n        char c = pattern[i];\n        if (char_map.count(c) == 0 && word_map.count(word) == 0) {\n            char_map[c] = word;\n            word_map[word] = c;\n        } else {\n            if (char_map[c] != word || word_map[word] != c) return false;\n        }\n    }\n\n    return i == pattern.size();\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "js": "\n    ```javascript\nfunction wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const charMap = new Map();\n    const wordMap = new Map();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const c = pattern[i];\n        const word = words[i];\n        if (!charMap.has(c) && !wordMap.has(word)) {\n            charMap.set(c, word);\n            wordMap.set(word, c);\n        } else {\n            if (charMap.get(c) !== word || wordMap.get(word) !== c) return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    "
    },
    {
        "id": 275,
        "title": "Nim Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are playing the following Nim Game with your friend:\n\n*   Initially, there is a heap of stones on the table.\n*   You and your friend will alternate taking turns, and **you go first**.\n*   On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n*   The one who removes the last stone is the winner.\n\nGiven `n`, the number of stones in the heap, return `true` _if you can win the game assuming both you and your friend play optimally, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** false\n**Explanation:** These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Brainteaser",
            "Game Theory"
        ],
        "example": [
            {
                "input": "4",
                "output": "false"
            },
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "2",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean canWinNim(int n) {\n    return n % 4 != 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "python": "\n    ```python\ndef canWinNim(n):\n    return n % 4 != 0\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "c++": "\n    ```cpp\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "js": "\n    ```javascript\nfunction canWinNim(n) {\n    return n % 4 !== 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    "
    },
    {
        "id": 276,
        "title": "Flip Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn all possible states of the string `currentState` after **one valid move**. You may return the answer in **any order**. If there is no valid move, return an empty list `[]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** \\[ \"--++ \", \"+--+ \", \"++-- \"\\]\n\n",
                "**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= currentState.length <= 500`\n*   `currentState[i]` is either `'+'` or `'-'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"++++\"",
                "output": "[\"--++\",\"+--+\",\"++--\"]"
            },
            {
                "input": "\"+\"",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generatePossibleNextMoves(String currentState) {\n    List<String> result = new ArrayList<>();\n    for (int i = 1; i < currentState.length(); i++) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {\n            result.add(currentState.substring(0, i - 1) + \"--\" + currentState.substring(i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "python": "\n    ```python\ndef generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState) {\n    std::vector<std::string> result;\n    for (int i = 1; i < currentState.size(); ++i) {\n        if (currentState[i] == '+' && currentState[i - 1] == '+') {\n            currentState[i] = currentState[i - 1] = '-';\n            result.push_back(currentState);\n            currentState[i] = currentState[i - 1] = '+';\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "js": "\n    ```javascript\nfunction generatePossibleNextMoves(currentState) {\n    const result = [];\n    for (let i = 1; i < currentState.length; i++) {\n        if (currentState[i] === '+' && currentState[i - 1] === '+') {\n            result.push(currentState.slice(0, i - 1) + '--' + currentState.slice(i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    "
    },
    {
        "id": 278,
        "title": "Find Median from Data Stream",
        "difficulty": "Hard",
        "content": {
            "problem": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n*   For example, for `arr = [2,3,4]`, the median is `3`.\n*   For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n\n*   `MedianFinder()` initializes the `MedianFinder` object.\n*   `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n*   `double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MedianFinder \",  \"addNum \",  \"addNum \",  \"findMedian \",  \"addNum \",  \"findMedian \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[3\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 1.5, null, 2.0\\]\n\n**Explanation**\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = \\[1\\]\nmedianFinder.addNum(2);    // arr = \\[1, 2\\]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr\\[1, 2, 3\\]\nmedianFinder.findMedian(); // return 2.0"
            ],
            "constraints": "**Constraints:**\n\n*   `-105 <= num <= 105`\n*   There will be at least one element in the data structure before calling `findMedian`.\n*   At most `5 * 104` calls will be made to `addNum` and `findMedian`.\n\n**",
            "follow_up": "Follow up:**\n\n*   If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?\n*   If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?"
        },
        "tag": [
            "Two Pointers",
            "Design",
            "Sorting",
            "Heap (Priority Queue)",
            "Data Stream"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,1.5,null,2.0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass MedianFinder {\n    PriorityQueue<Integer> left;\n    PriorityQueue<Integer> right;\n\n    public MedianFinder() {\n        left = new PriorityQueue<>((a, b) -> b.compareTo(a));\n        right = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        if (left.isEmpty() || num <= left.peek()) {\n            left.offer(num);\n        } else {\n            right.offer(num);\n        }\n        \n        if (left.size() < right.size()) {\n            left.offer(right.poll());\n        } else if (left.size() > right.size() + 1) {\n            right.offer(left.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (left.size() == right.size()) {\n            return (left.peek() + right.peek()) / 2.0;\n        } else {\n            return left.peek();\n        }\n    }\n}\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    ",
        "python": "\n    ```python\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.left = []  # max heap\n        self.right = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        if not self.left or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n        else:\n            heapq.heappush(self.right, num)\n        \n        if len(self.left) < len(self.right):\n            heapq.heappush(self.left, -heapq.heappop(self.right))\n        elif len(self.left) > len(self.right) + 1:\n            heapq.heappush(self.right, -heapq.heappop(self.left))\n\n    def findMedian(self) -> float:\n        if len(self.left) == len(self.right):\n            return (-self.left[0] + self.right[0]) / 2\n        else:\n            return -self.left[0]\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\nusing namespace std;\n\nclass MedianFinder {\npublic:\n    /** initialize your data structure here. */\n    priority_queue<int> left;\n    priority_queue<int, vector<int>, greater<int> > right;\n    \n    MedianFinder() {}\n    \n    void addNum(int num) {\n        if (left.empty() || num <= left.top()) {\n            left.push(num);\n        } else {\n            right.push(num);\n        }\n        \n        if (left.size() < right.size()) {\n            left.push(right.top());\n            right.pop();\n        } else if (left.size() > right.size() + 1) {\n            right.push(left.top());\n            left.pop();\n        }\n    }\n    \n    double findMedian() {\n        if(left.size() == right.size()){\n            return ((double)left.top() + (double)right.top()) / 2;\n        }\n        else{\n            return left.top();\n        }\n    }\n};\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    ",
        "js": "\n    ```javascript\nclass MedianFinder {\n    constructor() {\n        this.left = new MaxPriorityQueue();\n        this.right = new MinPriorityQueue();\n    }\n    \n    addNum(num) {\n        if (this.left.isEmpty() || num <= this.left.peek().element) {\n            this.left.enqueue(num);\n        } else {\n            this.right.enqueue(num);\n        }\n        \n        if (this.left.size() < this.right.size()) {\n            this.left.enqueue(this.right.dequeue().element);\n        } else if (this.left.size() > this.right.size() + 1) {\n            this.right.enqueue(this.left.dequeue().element);\n        }\n    }\n    \n    findMedian() {\n        if (this.left.size() === this.right.size()) {\n            return (this.left.peek().element + this.right.peek().element) / 2.0;\n        } else {\n            return this.left.peek().element;\n        }\n    }\n}\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    "
    },
    {
        "id": 280,
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,null,null,4,5\\]\n**Output:** \\[1,2,3,null,null,4,5\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Design",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,null,null,4,5]",
                "output": "[1,2,3,null,null,4,5]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Arrays;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic String serialize(TreeNode root) {\n    if (root == null) return \"null,\";\n    return root.val + \",\" + serialize(root.left) + serialize(root.right);\n}\n\npublic TreeNode deserialize(String data) {\n    Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n    return deserializeHelper(queue);\n}\n\nprivate TreeNode deserializeHelper(Queue<String> queue) {\n    String val = queue.poll();\n    if (val.equals(\"null\")) return null;\n    TreeNode root = new TreeNode(Integer.parseInt(val));\n    root.left = deserializeHelper(queue);\n    root.right = deserializeHelper(queue);\n    return root;\n}\n```\n\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root: return \"null,\"\n    return str(root.val) + \",\" + serialize(root.left) + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = values.pop(0)\n        if val == 'null': return None\n        root = TreeNode(int(val))\n        root.left = deserialize_helper(values)\n        root.right = deserialize_helper(values)\n        return root\n\n    values = data.split(\",\")\n    return deserialize_helper(values[:-1])  # Excluding the last empty element\n```\n\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    ",
        "c++": "\n    ```cpp\n#include <sstream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstring serialize(TreeNode* root) {\n    if (!root) return \"null,\";\n    return to_string(root->val) + \",\" + serialize(root->left) + serialize(root->right);\n}\n\nTreeNode* deserialize(string data) {\n    istringstream is(data);\n    return deserializeHelper(is);\n}\n\nTreeNode* deserializeHelper(istringstream& is) {\n    string val;\n    if (!getline(is, val, ',')) return nullptr;\n    if (val == \"null\") return nullptr;\n    TreeNode* root = new TreeNode(stoi(val));\n    root->left = deserializeHelper(is);\n    root->right = deserializeHelper(is);\n    return root;\n}\n```\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction serialize(root) {\n    if (!root) return \"null,\";\n    return root.val + \",\" + serialize(root.left) + serialize(root.right);\n}\n\nfunction deserialize(data) {\n    const values = data.split(\",\");\n\n    function deserializeHelper() {\n        const val = values.shift();\n        if (val === \"null\") return null;\n        const root = new TreeNode(parseInt(val));\n        root.left = deserializeHelper();\n        root.right = deserializeHelper();\n        return root;\n    }\n\n    return deserializeHelper();\n}\n```\n\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    "
    },
    {
        "id": 283,
        "title": "Longest Increasing Subsequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[10,9,2,5,3,7,101,18\\]\n**Output:** 4\n**Explanation:** The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,0,3,2,3\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,7,7,7,7,7,7\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2500`\n*   `-104 <= nums[i] <= 104`\n\n**",
            "follow_up": "Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?"
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[10,9,2,5,3,7,101,18]",
                "output": "4"
            },
            {
                "input": "[0,1,0,3,2,3]",
                "output": "4"
            },
            {
                "input": "[7,7,7,7,7,7,7]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int max_length = 1;\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "python": "\n    ```python\ndef lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLIS(vector<int>& nums) {\n    vector<int> dp(nums.size(), 1);\n    int max_length = 1;\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLIS(nums) {\n    const dp = new Array(nums.length).fill(1);\n    let max_length = 1;\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    "
    },
    {
        "id": 284,
        "title": "Remove Invalid Parentheses",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\nReturn _a list of **unique strings** that are valid with the minimum number of removals_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"()())() \"\n**Output:** \\[ \"(())() \", \"()()() \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"(a)())() \"\n**Output:** \\[ \"(a())() \", \"(a)()() \"\\]\n\n",
                "**Example 3:**\n\n**Input:** s =  \")( \"\n**Output:** \\[ \" \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 25`\n*   `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n*   There will be at most `20` parentheses in `s`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"()())()\"",
                "output": "[\"(())()\",\"()()()\"]"
            },
            {
                "input": "\"(a)())()\"",
                "output": "[\"(a())()\",\"(a)()()\"]"
            },
            {
                "input": "\")(\"",
                "output": "[\"\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        List<String> result = new ArrayList<>();\n        boolean found = false;\n\n        visited.add(s);\n        queue.offer(s);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n\n            if (isValid(current)) {\n                found = true;\n                result.add(current);\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < current.length(); i++) {\n                if (current.charAt(i) == '(' || current.charAt(i) == ')') {\n                    String next = current.substring(0, i) + current.substring(i + 1);\n                    if (!visited.contains(next)) {\n                        visited.add(next);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isValid(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        visited = set()\n        queue = deque([s])\n        result = []\n        found = False\n\n        while queue:\n            cur = queue.popleft()\n\n            if self.is_valid(cur):\n                found = True\n                result.append(cur)\n\n            if found: continue\n\n            for i in range(len(cur)):\n                if cur[i] == '(' or cur[i] == ')':\n                    next_str = cur[:i] + cur[i+1:]\n                    if next_str not in visited:\n                        visited.add(next_str)\n                        queue.append(next_str)\n\n        return result\n\n    def is_valid(self, s: str) -> bool:\n        count = 0\n        for c in s:\n            if c == '(': count += 1\n            if c == ')':\n                count -= 1\n                if count < 0: return False\n        return count == 0\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        set<string> visited;\n        queue<string> q;\n        vector<string> result;\n        bool found = false;\n\n        visited.insert(s);\n        q.push(s);\n\n        while (!q.empty()) {\n            string cur = q.front();\n            q.pop();\n\n            if (isValid(cur)) {\n                found = true;\n                result.push_back(cur);\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < cur.length(); ++i) {\n                if (cur[i] == '(' || cur[i] == ')') {\n                    string next = cur.substr(0, i) + cur.substr(i+1);\n                    if (visited.find(next) == visited.end()) {\n                        visited.insert(next);\n                        q.push(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    bool isValid(const string &s) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n};\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    removeInvalidParentheses(s) {\n        let visited = new Set();\n        let queue = [s];\n        let result = [];\n        let found = false;\n\n        while (queue.length > 0) {\n            let cur = queue.shift();\n\n            if (this.isValid(cur)) {\n                found = true;\n                result.push(cur);\n            }\n\n            if (found) continue;\n\n            for (let i = 0; i < cur.length; i++) {\n                if (cur[i] === '(' || cur[i] === ')') {\n                    let next = cur.slice(0, i) + cur.slice(i + 1);\n                    if (!visited.has(next)) {\n                        visited.add(next);\n                        queue.push(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    isValid(s) {\n        let count = 0;\n        for (let c of s) {\n            if (c === '(') count++;\n            if (c === ')') count--;\n            if (count < 0) return false;\n        }\n        return count === 0;\n    }\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    "
    },
    {
        "id": 286,
        "title": "Range Sum Query - Immutable",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, handle multiple queries of the following type:\n\n1.  Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n*   `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n*   `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"NumArray \",  \"sumRange \",  \"sumRange \",  \"sumRange \"\\]\n\\[\\[\\[-2, 0, 3, -5, 2, -1\\]\\], \\[0, 2\\], \\[2, 5\\], \\[0, 5\\]\\]\n**Output**\n\\[null, 1, -1, -3\\]\n\n**Explanation**\nNumArray numArray = new NumArray(\\[-2, 0, 3, -5, 2, -1\\]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n*   `0 <= left <= right < nums.length`\n*   At most `104` calls will be made to `sumRange`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[0,2],[2,5],[0,5]]",
                "output": "**Output**\n[null,1,-1,-3]"
            }
        ],
        "java": "\n    ```java\nclass NumArray {\n    int[] pSum;\n\n    public NumArray(int[] nums) {\n        pSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            pSum[i + 1] = pSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return pSum[right + 1] - pSum[left];\n    }\n}\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    ",
        "python": "\n    ```python\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.pSum = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            self.pSum[i + 1] = self.pSum[i] + num\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.pSum[right + 1] - self.pSum[left]\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nclass NumArray {\npublic:\n    std::vector<int> pSum;\n\n    NumArray(std::vector<int> &nums) {\n        pSum.resize(nums.size() + 1);\n        for (int i = 0; i < nums.size(); i++) {\n            pSum[i + 1] = pSum[i] + nums[i];\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return pSum[right + 1] - pSum[left];\n    }\n};\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    ",
        "js": "\n    ```javascript\nclass NumArray {\n    constructor(nums) {\n        this.pSum = new Array(nums.length + 1).fill(0);\n        for (let i = 0; i < nums.length; i++) {\n            this.pSum[i + 1] = this.pSum[i] + nums[i];\n        }\n    }\n\n    sumRange(left, right) {\n        return this.pSum[right + 1] - this.pSum[left];\n    }\n}\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    "
    },
    {
        "id": 291,
        "title": "Range Sum Query 2D - Mutable",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a 2D matrix `matrix`, handle multiple queries of the following types:\n\n1.  **Update** the value of a cell in `matrix`.\n2.  Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nImplement the NumMatrix class:\n\n*   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.\n*   `void update(int row, int col, int val)` **Updates** the value of `matrix[row][col]` to be `val`.\n*   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"NumMatrix \",  \"sumRegion \",  \"update \",  \"sumRegion \"\\]\n\\[\\[\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]\\], \\[2, 1, 4, 3\\], \\[3, 2, 2\\], \\[2, 1, 4, 3\\]\\]\n**Output**\n\\[null, 8, null, 10\\]\n\n**Explanation**\nNumMatrix numMatrix = new NumMatrix(\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)\nnumMatrix.update(3, 2, 2);       // matrix changes from left image to right image\nnumMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= matrix[i][j] <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\n*   `-1000 <= val <= 1000`\n*   `0 <= row1 <= row2 < m`\n*   `0 <= col1 <= col2 < n`\n*   At most `5000` calls will be made to `sumRegion` and `update`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],]]],[2,1,4,3],[3,2,2],[2,1,4,3]]",
                "output": "**Output**\n[null,8,null,10]"
            }
        ],
        "java": "\n    ```java\nclass NumMatrix {\n    int[][] dp;\n    public NumMatrix(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        dp = new int[m + 1][n + 1];\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    public void update(int row, int col, int val) {\n        int oldValue = dp[row + 1][col + 1] - dp[row + 1][col] - dp[row][col + 1] + dp[row][col];\n        int delta = val - oldValue;\n        for(int i = row + 1; i < dp.length; i++)\n            for(int j = col + 1; j < dp[0].length; j++)\n                dp[i][j] += delta;\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];\n    }\n}\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    ",
        "python": "\n    ```python\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        self.dp = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                self.dp[i + 1][j + 1] = self.dp[i + 1][j] + self.dp[i][j + 1] - self.dp[i][j] + matrix[i][j]\n                \n    def update(self, row: int, col: int, val: int) -> None:\n        oldValue = self.dp[row + 1][col + 1] - self.dp[row + 1][col] - self.dp[row][col + 1] + self.dp[row][col]\n        delta = val - oldValue\n        for i in range(row + 1, len(self.dp)):\n            for j in range(col + 1, len(self.dp[0])):\n                self.dp[i][j] += delta\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    ",
        "c++": "\n    ```cpp\nclass NumMatrix {\npublic:\n    vector<vector<int>> dp;\n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        dp.resize(m + 1, vector<int>(n + 1, 0));\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    void update(int row, int col, int val) {\n        int oldValue = dp[row + 1][col + 1] - dp[row + 1][col] - dp[row][col + 1] + dp[row][col];\n        int delta = val - oldValue;\n        for(int i = row + 1; i < dp.size(); i++)\n            for(int j = col + 1; j < dp[0].size(); j++)\n                dp[i][j] += delta;\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];\n    }\n};\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    ",
        "js": "\n    ```javascript\nclass NumMatrix {\n    constructor(matrix) {\n        this.dp = new Array(matrix.length + 1).fill().map(() => new Array(matrix[0].length + 1).fill(0));\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                this.dp[i + 1][j + 1] = this.dp[i + 1][j] + this.dp[i][j + 1] - this.dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    update(row, col, val) {\n        let oldValue = this.dp[row + 1][col + 1] - this.dp[row + 1][col] - this.dp[row][col + 1] + this.dp[row][col];\n        let delta = val - oldValue;\n        for (let i = row + 1; i < this.dp.length; i++) {\n            for (let j = col + 1; j < this.dp[0].length; j++) {\n                this.dp[i][j] += delta;\n            }\n        }\n    }\n\n    sumRegion(row1, col1, row2, col2) {\n        return this.dp[row2 + 1][col2 + 1] - this.dp[row2 + 1][col1] - this.dp[row1][col2 + 1] + this.dp[row1][col1];\n    }\n}\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    "
    },
    {
        "id": 292,
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,2,3,0,2]",
                "output": "3"
            },
            {
                "input": "[1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.size(); ++i) {\n        profit += max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(prices) {\n    let profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    "
    },
    {
        "id": 294,
        "title": "Sparse Matrix Multiplication",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat1 = \\[\\[1,0,0\\],\\[-1,0,3\\]\\], mat2 = \\[\\[7,0,0\\],\\[0,0,0\\],\\[0,0,1\\]\\]\n**Output:** \\[\\[7,0,0\\],\\[-7,0,3\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat1 = \\[\\[0\\]\\], mat2 = \\[\\[0\\]\\]\n**Output:** \\[\\[0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat1.length`\n*   `k == mat1[i].length == mat2.length`\n*   `n == mat2[i].length`\n*   `1 <= m, n, k <= 100`\n*   `-100 <= mat1[i][j], mat2[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,0,0],[-1,0,3]],[[7,0,0],[0,0,0],[0,0,1]]",
                "output": "[[7,0,0],[-7,0,3]]"
            },
            {
                "input": "[[0]],[[0]]",
                "output": "[[0]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] multiply(int[][] mat1, int[][] mat2) {\n    int m = mat1.length;\n    int k = mat1[0].length;\n    int n = mat2[0].length;\n    int[][] result = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "python": "\n    ```python\ndef multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {\n    int m = mat1.size();\n    int k = mat1[0].size();\n    int n = mat2[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "js": "\n    ```javascript\nfunction multiply(mat1, mat2) {\n    const m = mat1.length;\n    const k = mat1[0].length;\n    const n = mat2[0].length;\n    const result = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < k; j++) {\n            if (mat1[i][j] !== 0) {\n                for (let l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    "
    },
    {
        "id": 295,
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,5,8\\]\n**Output:** 167\n**Explanation:**\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 10"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[3,1,5,8]",
                "output": "167"
            },
            {
                "input": "[1,5]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "python": "\n    ```python\ndef maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "c++": "\n    ```cpp\nint maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "js": "\n    ```javascript\nfunction maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    "
    },
    {
        "id": 299,
        "title": "Remove Duplicate Letters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"bcabc \"\n**Output:**  \"abc \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"cbacdcbc \"\n**Output:**  \"acdb \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n\n**Note:** This question is the same as 1081: [https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "\"bcabc\"",
                "output": "\"abc\""
            },
            {
                "input": "\"cbacdcbc\"",
                "output": "\"acdb\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n        Stack<Character> st = new Stack<>();\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]++;\n        }\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]--;\n            if (visited[ch]) continue;\n            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {\n                visited[st.pop()] = false;\n            }\n            st.push(ch);\n            visited[ch] = true;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!st.empty()) {\n            result.append(st.pop());\n        }\n        return result.reverse().toString();\n    }\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "python": "\n    ```python\ndef removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)   \n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n    vector<int> count(256, 0);\n    vector<bool> visited(256, false);\n    stack<char> st;\n    \n    for (char ch : s) {\n        count[ch]++;\n    }\n    \n    for (char ch : s) {\n        count[ch]--;\n        if (visited[ch]) continue;\n        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {\n            visited[st.top()] = false;\n            st.pop();\n        }\n        st.push(ch);\n        visited[ch] = true;\n    }\n    \n    string result = \"\";\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    return result;\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "js": "\n    ```javascript\nfunction removeDuplicateLetters(s) {\n    let count = new Array(256).fill(0);\n    let visited = new Array(256).fill(false);\n    let st = [];\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]++;\n    }\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]--;\n        if (visited[ch.charCodeAt(0)]) continue;\n        while (st.length > 0 && ch < st[st.length - 1] && count[st[st.length - 1].charCodeAt(0)] > 0) {\n            visited[st.pop().charCodeAt(0)] = false;\n        }\n        st.push(ch);\n        visited[ch.charCodeAt(0)] = true;\n    }\n\n    return st.join(\"\");\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    "
    },
    {
        "id": 301,
        "title": "Maximum Product of Word Lengths",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string array `words`, return _the maximum value of_ `length(word[i]) * length(word[j])` _where the two words do not share common letters_. If no such two words exist, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abcw \", \"baz \", \"foo \", \"bar \", \"xtfn \", \"abcdef \"\\]\n**Output:** 16\n**Explanation:** The two words can be  \"abcw \",  \"xtfn \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"ab \", \"abc \", \"d \", \"cd \", \"bcd \", \"abcd \"\\]\n**Output:** 4\n**Explanation:** The two words can be  \"ab \",  \"cd \".\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"a \", \"aa \", \"aaa \", \"aaaa \"\\]\n**Output:** 0\n**Explanation:** No such pair of words."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   `words[i]` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
                "output": "16"
            },
            {
                "input": "[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
                "output": "4"
            },
            {
                "input": "[\"a\",\"aa\",\"aaa\",\"aaaa\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int maxProduct(String[] words) {\n        int n = words.length;\n        int[] mask = new int[n];\n        for (int i = 0; i < n; i++) {\n            for (char c : words[i].toCharArray()) {\n                mask[i] |= (1 << (c - 'a'));\n            }\n        }\n\n        int maxProduct = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((mask[i] & mask[j]) == 0) {\n                    maxProduct = Math.max(maxProduct, words[i].length() * words[j].length());\n                }\n            }\n        }\n\n        return maxProduct;\n    }\n}\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "python": "\n    ```python\ndef maxProduct(words):\n    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n    \n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n    \n    return max_product\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint maxProduct(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<int> mask(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (char c : words[i]) {\n            mask[i] |= (1 << (c - 'a'));\n        }\n    }\n\n    int max_product = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if ((mask[i] & mask[j]) == 0) {\n                max_product = std::max(max_product, int(words[i].length() * words[j].length()));\n            }\n        }\n    }\n\n    return max_product;\n}\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "js": "\n    ```javascript\nfunction maxProduct(words) {\n    const n = words.length;\n    const mask = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (const c of words[i]) {\n            mask[i] |= (1 << (c.charCodeAt(0) - 'a'.charCodeAt(0)));\n        }\n    }\n\n    let maxProduct = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if ((mask[i] & mask[j]) === 0) {\n                maxProduct = Math.max(maxProduct, words[i].length * words[j].length);\n            }\n        }\n    }\n\n    return maxProduct;\n}\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    "
    },
    {
        "id": 302,
        "title": "Bulb Switcher",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 1\n**Explanation:** At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on.\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Brainteaser"
        ],
        "example": [
            {
                "input": "3",
                "output": "1"
            },
            {
                "input": "0",
                "output": "0"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int bulbSwitch(int n) {\n    return (int)Math.sqrt(n);\n}\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "python": "\n    ```python\ndef bulbSwitch(n):\n    return int(n**0.5)\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "c++": "\n    ```cpp\nint bulbSwitch(int n) {\n    return sqrt(n);\n}\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "js": "\n    ```javascript\nfunction bulbSwitch(n) {\n    return Math.floor(Math.sqrt(n));\n}\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    "
    },
    {
        "id": 305,
        "title": "Coin Change",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
            "examples": [
                "**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n",
                "**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "[1,2,5],11",
                "output": "3"
            },
            {
                "input": "[2],3",
                "output": "-1"
            },
            {
                "input": "[1],0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    \n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "python": "\n    ```python\ndef coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint coinChange(std::vector<int>& coins, int amount) {\n    std::vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n    \n    for (int i = 0; i < coins.size(); i++) {\n        for (int j = coins[i]; j <= amount; j++) {\n            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "js": "\n    ```javascript\nfunction coinChange(coins, amount) {\n    const dp = new Array(amount + 1).fill(amount + 1);\n    dp[0] = 0;\n\n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    "
    },
    {
        "id": 306,
        "title": "Number of Connected Components in an Undirected Graph",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,1],[1,2],[3,4]]",
                "output": "2"
            },
            {
                "input": "5,[[0,1],[1,2],[2,3],[3,4]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int countComponents(int n, int[][] edges) {\n    List<List<Integer>> adjList = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, visited, adjList);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\n    visited[node] = true;\n    for (int neighbor : adjList.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adjList);\n        }\n    }\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "python": "\n    ```python\ndef countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint countComponents(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> adjList(n);\n    for (const auto& edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n    }\n    \n    std::vector<bool> visited(n, false);\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            std::function<void(int)> dfs = [&](int node) {\n                visited[node] = true;\n                for (int neighbor : adjList[node]) {\n                    if (!visited[neighbor]) {\n                        dfs(neighbor);\n                    }\n                }\n            };\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "js": "\n    ```javascript\nfunction countComponents(n, edges) {\n    const adjList = new Array(n).fill(0).map(() => []);\n    for (const edge of edges) {\n        adjList[edge[0]].push(edge[1]);\n        adjList[edge[1]].push(edge[0]);\n    }\n\n    const visited = new Array(n).fill(false);\n    let connectedComponents = 0;\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of adjList[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    "
    },
    {
        "id": 308,
        "title": "Maximum Size Subarray Sum Equals k",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the maximum length of a_ _subarray_ _that sums to_ `k`. If there is not one, return `0` instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,-1,5,-2,3\\], k = 3\n**Output:** 4\n**Explanation:** The subarray \\[1, -1, 5, -2\\] sums to 3 and is the longest.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-2,-1,2,1\\], k = 1\n**Output:** 2\n**Explanation:** The subarray \\[-1, 2\\] sums to 1 and is the longest."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 105`\n*   `-104 <= nums[i] <= 104`\n*   `-109 <= k <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,-1,5,-2,3],3",
                "output": "4"
            },
            {
                "input": "[-2,-1,2,1],1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int maxSubArrayLen(int[] nums, int k) {\n    Map<Integer, Integer> sumIndex = new HashMap<>();\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum == k) maxLength = i + 1;\n        if (sumIndex.containsKey(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.containsKey(sum)) sumIndex.put(sum, i);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "python": "\n    ```python\ndef maxSubArrayLen(nums: List[int], k: int) -> int:\n    sum_index = {}\n    maxLength = sum = 0\n    for i, num in enumerate(nums):\n        sum += num\n        if sum == k:\n            maxLength = i + 1\n        if sum - k in sum_index:\n            maxLength = max(maxLength, i - sum_index[sum - k])\n        if sum not in sum_index:\n            sum_index[sum] = i\n    return maxLength\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "c++": "\n    ```cpp\nint maxSubArrayLen(vector<int>& nums, int k) {\n    unordered_map<int, int> sumIndex;\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.size(); i++) {\n        sum += nums[i];\n        if(sum == k) maxLength = i + 1;\n        if(sumIndex.count(sum - k)) maxLength = max(maxLength, i - sumIndex[sum - k]);\n        if(!sumIndex.count(sum)) sumIndex[sum] = i;\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "js": "\n    ```javascript\nfunction maxSubArrayLen(nums, k) {\n    let sumIndex = new Map();\n    let maxLength = 0, sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum === k) maxLength = i + 1;\n        if (sumIndex.has(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.has(sum)) sumIndex.set(sum, i);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    "
    },
    {
        "id": 321,
        "title": "Counting Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,1\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[0,1,1,2,1,2\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 105`\n\n**",
            "follow_up": "Follow up:**\n\n*   It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?\n*   Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?"
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "2",
                "output": "[0,1,1]"
            },
            {
                "input": "5",
                "output": "[0,1,1,2,1,2]"
            }
        ],
        "java": "\n    ```java\npublic int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "python": "\n    ```python\ndef countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    vector<int> ans(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "js": "\n    ```javascript\nfunction countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    "
    },
    {
        "id": 323,
        "title": "Longest Substring with At Most K Distinct Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"eceba \", k = 2\n**Output:** 3\n**Explanation:** The substring is  \"ece \" with length 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", k = 1\n**Output:** 2\n**Explanation:** The substring is  \"aa \" with length 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `0 <= k <= 50`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"eceba\",2",
                "output": "3"
            },
            {
                "input": "\"aa\",1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); ++right) {\n        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n\n        while (charCount.size() > k) {\n            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n            if (charCount.get(s.charAt(left)) == 0) {\n                charCount.remove(s.charAt(left));\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "python": "\n    ```python\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <algorithm>\n\nint lengthOfLongestSubstringKDistinct(std::string s, int k) {\n    std::unordered_map<char, int> charCount;\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.size(); ++right) {\n        charCount[s[right]]++;\n\n        while (charCount.size() > k) {\n            charCount[s[left]]--;\n            if (charCount[s[left]] == 0) {\n                charCount.erase(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = std::max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLongestSubstringKDistinct(s, k) {\n    const charCount = new Map();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; ++right) {\n        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n        while (charCount.size > k) {\n            charCount.set(s[left], charCount.get(s[left]) - 1);\n            if (charCount.get(s[left]) === 0) {\n                charCount.delete(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    "
    },
    {
        "id": 328,
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in both lower and upper cases, more than once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"hello\"\n**Output:** \"holle\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"leetcode\"\n**Output:** \"leotcede\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consist of **printable ASCII** characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"hello\"",
                "output": "\"holle\""
            },
            {
                "input": "\"leetcode\"",
                "output": "\"leotcede\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic String reverseVowels(String s) {\n    int i = 0, j = s.length() - 1;\n    char[] result = new char[s.length()];\n    Set<Character> vowels = new HashSet<>();\n    for (char c : \"aeiouAEIOU\".toCharArray()) {\n        vowels.add(c);\n    }\n    while (i <= j) {\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci)) {\n            result[i++] = ci;\n        } else if (!vowels.contains(cj)) {\n            result[j--] = cj;\n        } else {\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "python": "\n    ```python\ndef reverseVowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int i = 0, j = s.size() - 1;\n    while (i < j) {\n        if (!isVowel(s[i])) {\n            i++;\n        } else if (!isVowel(s[j])) {\n            j--;\n        } else {\n            std::swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n    return s;\n}\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "js": "\n    ```javascript\nfunction reverseVowels(s) {\n    const vowels = new Set('aeiouAEIOU');\n    let chars = Array.from(s);\n    let i = 0, j = s.length - 1;\n    while (i < j) {\n        if (!vowels.has(chars[i])) {\n            i++;\n        } else if (!vowels.has(chars[j])) {\n            j--;\n        } else {\n            [chars[i], chars[j]] = [chars[j], chars[i]];\n            i++;\n            j--;\n        }\n    }\n    return chars.join('');\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    "
    },
    {
        "id": 332,
        "title": "Intersection of Two Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must be **unique** and you may return the result in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[9,4\\]\n**Explanation:** \\[4,9\\] is also accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,2,1],[2,2]",
                "output": "[2]"
            },
            {
                "input": "[4,9,5],[9,4,9,8,4]",
                "output": "[9,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> set1 = new HashSet<>();\n    for (int num : nums1) {\n        set1.add(num);\n    }\n    \n    Set<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n        if (set1.contains(num)) {\n            resultSet.add(num);\n        }\n    }\n    \n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) {\n        result[i++] = num;\n    }\n    return result;\n}\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "python": "\n    ```python\ndef intersection(nums1, nums2):\n    set1 = set(nums1)\n    result = set1.intersection(nums2)\n    return list(result)\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::set<int> set1(nums1.begin(), nums1.end());\n    std::set<int> result;\n    for (int num : nums2) {\n        if (set1.count(num)) {\n            result.insert(num);\n        }\n    }\n    return std::vector<int>(result.begin(), result.end());\n}\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "js": "\n    ```javascript\nfunction intersection(nums1, nums2) {\n    const set1 = new Set(nums1);\n    const resultSet = new Set();\n\n    for (const num of nums2) {\n        if (set1.has(num)) {\n            resultSet.add(num);\n        }\n    }\n\n    return Array.from(resultSet);\n}\n```\n\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    "
    },
    {
        "id": 333,
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[4,9\\]\n**Explanation:** \\[9,4\\] is also accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`\n\n**",
            "follow_up": "Follow up:**\n\n*   What if the given array is already sorted? How would you optimize your algorithm?\n*   What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n*   What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,2,1],[2,2]",
                "output": "[2,2]"
            },
            {
                "input": "[4,9,5],[9,4,9,8,4]",
                "output": "[4,9]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> countMap = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n    \n    for (int num : nums1) {\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n    }\n    \n    for (int num : nums2) {\n        if (countMap.getOrDefault(num, 0) > 0) {\n            result.add(num);\n            countMap.put(num, countMap.get(num) - 1);\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "python": "\n    ```python\ndef intersect(nums1, nums2):\n    count_map = {}\n    result = []\n    \n    for num in nums1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    for num in nums2:\n        if count_map.get(num, 0) > 0:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> count_map;\n    std::vector<int> result;\n    \n    for (int num : nums1) {\n        count_map[num]++;\n    }\n    \n    for (int num : nums2) {\n        if (count_map[num] > 0) {\n            result.push_back(num);\n            count_map[num]--;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "js": "\n    ```javascript\nfunction intersect(nums1, nums2) {\n    const countMap = {};\n    const result = [];\n    \n    for (const num of nums1) {\n        countMap[num] = (countMap[num] || 0) + 1;\n    }\n    \n    for (const num of nums2) {\n        if (countMap[num] > 0) {\n            result.push(num);\n            countMap[num]--;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    "
    },
    {
        "id": 340,
        "title": "Count Numbers with Unique Digits",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 91\n**Explanation:** The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 8`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Backtracking"
        ],
        "example": [
            {
                "input": "2",
                "output": "91"
            },
            {
                "input": "0",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "python": "\n    ```python\ndef countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "c++": "\n    ```cpp\nint countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n    \n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n    \n    while(n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n    \n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "js": "\n    ```javascript\nfunction countNumbersWithUniqueDigits(n) {\n    if (n === 0) return 1;\n\n    let total = 10;\n    let uniqueDigits = 9;\n    let currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    "
    },
    {
        "id": 353,
        "title": "Range Addition",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.\n\nYou have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.\n\nReturn `arr` _after applying all the_ `updates`.",
            "examples": [
                "**Example 1:**\n\n**Input:** length = 5, updates = \\[\\[1,3,2\\],\\[2,4,3\\],\\[0,2,-2\\]\\]\n**Output:** \\[-2,0,3,5,3\\]\n\n",
                "**Example 2:**\n\n**Input:** length = 10, updates = \\[\\[2,4,6\\],\\[5,6,8\\],\\[1,9,-4\\]\\]\n**Output:** \\[0,-4,2,2,2,4,4,-4,-4,-4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= length <= 105`\n*   `0 <= updates.length <= 104`\n*   `0 <= startIdxi <= endIdxi < length`\n*   `-1000 <= inci <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[1,3,2],[2,4,3],[0,2,-2]]",
                "output": "[-2,0,3,5,3]"
            },
            {
                "input": "10,[[2,4,6],[5,6,8],[1,9,-4]]",
                "output": "[0,-4,2,2,2,4,4,-4,-4,-4]"
            }
        ],
        "java": "\n    ```java\npublic int[] getUpdatedArray(int length, int[][] updates) {\n    int[] arr = new int[length];\n\n    for (int[] update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "python": "\n    ```python\ndef get_updated_array(length, updates):\n    arr = [0] * length\n\n    for start, end, inc in updates:\n        arr[start] += inc\n        if end + 1 < length:\n            arr[end + 1] -= inc\n\n    for i in range(1, length):\n        arr[i] += arr[i - 1]\n\n    return arr\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getUpdatedArray(int length, vector<vector<int>>& updates) {\n    vector<int> arr(length, 0);\n\n    for (const auto& update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "js": "\n    ```javascript\nfunction getUpdatedArray(length, updates) {\n    const arr = new Array(length).fill(0);\n\n    for (const [start, end, inc] of updates) {\n        arr[start] += inc;\n        if (end + 1 < length) {\n            arr[end + 1] -= inc;\n        }\n    }\n\n    for (let i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n\n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    "
    },
    {
        "id": 354,
        "title": "Sum of Two Integers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers `a` and `b`, return _the sum of the two integers without using the operators_ `+` _and_ `-`.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = 1, b = 2\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** a = 2, b = 3\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `-1000 <= a, b <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "1,2",
                "output": "3"
            },
            {
                "input": "2,3",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "python": "\n    ```python\ndef add(a, b):\n    MAX = 0x7FFFFFFF\n    MASK = 0xFFFFFFFF\n    while b:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    return a if a <= MAX else ~(a ^ MASK)\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "c++": "\n    ```cpp\nint add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "js": "\n    ```javascript\nfunction add(a, b) {\n    while (b) {\n        let carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    "
    },
    {
        "id": 370,
        "title": "First Unique Character in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, _find the first non-repeating character in it and return its index_. If it does not exist, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"leetcode\"\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** s = \"loveleetcode\"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** s = \"aabb\"\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Queue",
            "Counting"
        ],
        "example": [
            {
                "input": "\"leetcode\"",
                "output": "0"
            },
            {
                "input": "\"loveleetcode\"",
                "output": "2"
            },
            {
                "input": "\"aabb\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int firstUniqChar(String s) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    for (char c : s.toCharArray())\n        charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    for (int i = 0; i < s.length(); i++)\n        if (charCount.get(s.charAt(i)) == 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "python": "\n    ```python\ndef firstUniqChar(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "c++": "\n    ```cpp\nint firstUniqChar(std::string s) {\n    std::unordered_map<char, int> charCount;\n    for (char c : s)\n        charCount[c]++;\n    for (int i = 0; i < s.length(); i++)\n        if (charCount[s[i]] == 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "js": "\n    ```javascript\nfunction firstUniqChar(s) {\n    let charCount = {};\n    for (let c of s)\n        charCount[c] = (charCount[c] || 0) + 1;\n    for (let i = 0; i < s.length; i++)\n        if (charCount[s[i]] === 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    "
    },
    {
        "id": 372,
        "title": "Find the Difference",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `s` and `t`.\n\nString `t` is generated by random shuffling string `s` and then add one more letter at a random position.\n\nReturn the letter that was added to `t`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcd \", t =  \"abcde \"\n**Output:**  \"e \"\n**Explanation:** 'e' is the letter that was added.\n\n",
                "**Example 2:**\n\n**Input:** s =  \" \", t =  \"y \"\n**Output:**  \"y \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 1000`\n*   `t.length == s.length + 1`\n*   `s` and `t` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"abcd\",\"abcde\"",
                "output": "\"e\""
            },
            {
                "input": "\"\",\"y\"",
                "output": "\"y\""
            }
        ],
        "java": "\n    ```java\npublic char findTheDifference(String s, String t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s.toCharArray()) sum_s += c;\n    for(char c : t.toCharArray()) sum_t += c;\n    return (char)(sum_t - sum_s);\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "python": "\n    ```python\ndef findTheDifference(s: str, t: str) -> str:\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "c++": "\n    ```cpp\nchar findTheDifference(std::string s, std::string t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s) sum_s += c;\n    for(char c : t) sum_t += c;\n    return sum_t - sum_s;\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "js": "\n    ```javascript\nfunction findTheDifference(s, t) {\n    let sum_s = 0, sum_t = 0;\n    for(let c of s) sum_s += c.charCodeAt(0);\n    for(let c of t) sum_t += c.charCodeAt(0);\n    return String.fromCharCode(sum_t - sum_s);\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    "
    },
    {
        "id": 373,
        "title": "Elimination Game",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`:\n\n*   Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n*   Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n*   Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nGiven the integer `n`, return _the last number that remains in_ `arr`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 9\n**Output:** 6\n**Explanation:**\narr = \\[1, 2, 3, 4, 5, 6, 7, 8, 9\\]\narr = \\[2, 4, 6, 8\\]\narr = \\[2, 6\\]\narr = \\[6\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Recursion"
        ],
        "example": [
            {
                "input": "9",
                "output": "6"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int lastRemaining(int n) {\n    boolean direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "python": "\n    ```python\ndef last_remaining(n: int) -> int:\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "c++": "\n    ```cpp\nint lastRemaining(int n) {\n    bool direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "js": "\n    ```javascript\nfunction lastRemaining(n) {\n    let direction = true;\n    let head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 === 1) {\n            head += step;\n        }\n        remaining = Math.floor(remaining / 2);\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    "
    },
    {
        "id": 377,
        "title": "Decode String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\n\nThe test cases are generated so that the length of the output will never exceed `105`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"3\\[a\\]2\\[bc\\] \"\n**Output:**  \"aaabcbc \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"3\\[a2\\[c\\]\\] \"\n**Output:**  \"accaccacc \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"2\\[abc\\]3\\[cd\\]ef \"\n**Output:**  \"abcabccdcdcdef \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 30`\n*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.\n*   `s` is guaranteed to be **a valid** input.\n*   All the integers in `s` are in the range `[1, 300]`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"3[a]2[bc]\"",
                "output": "\"aaabcbc\""
            },
            {
                "input": "\"3[a2[c]]\"",
                "output": "\"accaccacc\""
            },
            {
                "input": "\"2[abc]3[cd]ef\"",
                "output": "\"abcabccdcdcdef\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> counts = new Stack<>();\n        Stack<String> results = new Stack<>();\n        String current = \"\";\n        int ptr = 0;\n\n        while (ptr < s.length()) {\n            if (Character.isDigit(s.charAt(ptr))) {\n                int count = 0;\n                while (Character.isDigit(s.charAt(ptr))) {\n                    count = count * 10 + (s.charAt(ptr) - '0');\n                    ptr++;\n                }\n                counts.push(count);\n            } else if (s.charAt(ptr) == '[') {\n                results.push(current);\n                current = \"\";\n                ptr++;\n            } else if (s.charAt(ptr) == ']') {\n                String prev = results.pop();\n                int count = counts.pop();\n                for (int i = 0; i < count; i++) {\n                    prev += current;\n                }\n                current = prev;\n                ptr++;\n            } else {\n                current += s.charAt(ptr);\n                ptr++;\n            }\n        }\n\n        return current;\n    }\n}\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "python": "\n    ```python\ndef decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string decodeString(const std::string &s) {\n    std::stack<int> counts;\n    std::stack<std::string> results;\n    std::string current;\n    int ptr = 0;\n\n    while (ptr < s.size()) {\n        if (isdigit(s[ptr])) {\n            int count = 0;\n            while (isdigit(s[ptr])) {\n                count = count * 10 + (s[ptr] - '0');\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] == '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] == ']') {\n            std::string prev = results.top();\n            results.pop();\n            int count = counts.top();\n            counts.pop();\n            for (int i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "js": "\n    ```javascript\nfunction decodeString(s) {\n    const counts = [];\n    const results = [];\n    let current = \"\";\n    let ptr = 0;\n\n    while (ptr < s.length) {\n        if (s[ptr].match(/\\d/)) {\n            let count = 0;\n            while (s[ptr].match(/\\d/)) {\n                count = count * 10 + parseInt(s[ptr]);\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] === '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] === ']') {\n            const prev = results.pop();\n            const count = counts.pop();\n            for (let i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    "
    },
    {
        "id": 380,
        "title": "Integer Replacement",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Greedy",
            "Bit Manipulation",
            "Memoization"
        ],
        "example": [
            {
                "input": "8",
                "output": "3"
            },
            {
                "input": "7",
                "output": "4"
            },
            {
                "input": "4",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "python": "\n    ```python\ndef min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "c++": "\n    ```cpp\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "js": "\n    ```javascript\nfunction minOperations(n) {\n    let steps = 0;\n    while(n > 1) {\n        n = (n % 2 === 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    "
    },
    {
        "id": 392,
        "title": "Longest Palindrome",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` which consists of lowercase or uppercase letters, return _the length of the **longest palindrome**_ that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa \"` is not considered a palindrome here.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abccccdd \"\n**Output:** 7\n**Explanation:** One longest palindrome that can be built is  \"dccaccd \", whose length is 7.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** The longest palindrome that can be built is  \"a \", whose length is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase **and/or** uppercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abccccdd\"",
                "output": "7"
            },
            {
                "input": "\"a\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int longestPalindrome(String s) {\n    int[] charCount = new int[128];\n    int result = 0;\n    for (char c : s.toCharArray())\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "python": "\n    ```python\ndef longestPalindrome(s: str) -> int:\n    charCount = [0] * 128\n    result = 0\n    for c in s:\n        charCount[ord(c)] += 1\n    for count in charCount:\n        result += count // 2 * 2\n        if result % 2 == 0 and count % 2 == 1:\n            result += 1\n    return result\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "c++": "\n    ```cpp\nint longestPalindrome(string s) {\n    int charCount[128] = {0};\n    int result = 0;\n    for (char c : s)\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "js": "\n    ```javascript\nfunction longestPalindrome(s) {\n    let charCount = new Array(128).fill(0);\n    let result = 0;\n    for (let c of s)\n        charCount[c.charCodeAt(0)]++;\n    for (let count of charCount) {\n        result += Math.floor(count / 2) * 2;\n        if (result % 2 === 0 && count % 2 === 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    "
    },
    {
        "id": 393,
        "title": "Split Array Largest Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[7,2,5,10,8],2",
                "output": "18"
            },
            {
                "input": "[1,2,3,4,5],2",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int splitArray(int[] nums, int m) {\n    long left = 0, right = 0;\n    for (int num : nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        long mid = (left + right) / 2;\n        int count = 1;\n        long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "python": "\n    ```python\ndef splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "c++": "\n    ```cpp\nint splitArray(vector<int>& nums, int m) {\n    long long left = 0, right = 0;\n    for (int num : nums) {\n        left = max(left, (long long)num);\n        right += num;\n    }\n\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        int count = 1;\n        long long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "js": "\n    ```javascript\nfunction splitArray(nums, m) {\n    let left = 0, right = 0;\n    for (let num of nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curSum = 0;\n        for (let num of nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    "
    },
    {
        "id": 397,
        "title": "Third Maximum Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the **third distinct maximum** number in this array. If the third maximum does not exist, return the **maximum** number_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 2\n**Explanation:**\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,2,3,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Can you find an `O(n)` solution?"
        },
        "tag": [
            "Array",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,2,1]",
                "output": "1"
            },
            {
                "input": "[1,2]",
                "output": "2"
            },
            {
                "input": "[2,2,3,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic int thirdMax(int[] nums) {\n    TreeSet<Integer> top3 = new TreeSet<>();\n    for (int num : nums) {\n        top3.add(num);\n        if (top3.size() > 3) {\n            top3.remove(top3.first());\n        }\n    }\n    return top3.size() == 3 ? top3.first() : top3.last();\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "python": "\n    ```python\ndef third_max(nums):\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n    return min(top3) if len(top3) == 3 else max(top3)\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n\nint thirdMax(vector<int>& nums) {\n    set<int> top3;\n    for (int num : nums) {\n        top3.insert(num);\n        if (top3.size() > 3) {\n            top3.erase(top3.begin());\n        }\n    }\n    return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "js": "\n    ```javascript\nfunction thirdMax(nums) {\n    const top3 = new Set();\n    for (const num of nums) {\n        top3.add(num);\n        if (top3.size > 3) {\n            top3.delete(Math.min(...top3));\n        }\n    }\n    return top3.size === 3 ? Math.min(...top3) : Math.max(...top3);\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    "
    },
    {
        "id": 398,
        "title": "Add Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two non-negative integers, `num1` and `num2` represented as string, return _the sum of_ `num1` _and_ `num2` _as a string_.\n\nYou must solve the problem without using any built-in library for handling large integers (such as `BigInteger`). You must also not convert the inputs to integers directly.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 =  \"11 \", num2 =  \"123 \"\n**Output:**  \"134 \"\n\n",
                "**Example 2:**\n\n**Input:** num1 =  \"456 \", num2 =  \"77 \"\n**Output:**  \"533 \"\n\n",
                "**Example 3:**\n\n**Input:** num1 =  \"0 \", num2 =  \"0 \"\n**Output:**  \"0 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 104`\n*   `num1` and `num2` consist of only digits.\n*   `num1` and `num2` don't have any leading zeros except for the zero itself.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"11\",\"123\"",
                "output": "\"134\""
            },
            {
                "input": "\"456\",\"77\"",
                "output": "\"533\""
            },
            {
                "input": "\"0\",\"0\"",
                "output": "\"0\""
            }
        ],
        "java": "\n    ```java\npublic String addStrings(String num1, String num2) {\n    int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n    StringBuilder result = new StringBuilder();\n\n    while (i >= 0 || j >= 0 || carry != 0) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1.charAt(i) - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2.charAt(j) - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.append(sum % 10);\n    }\n\n    return result.reverse().toString();\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "python": "\n    ```python\ndef addStrings(num1: str, num2: str) -> str:\n    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []\n\n    while i >= 0 or j >= 0 or carry:\n        sum = carry\n\n        if i >= 0:\n            sum += int(num1[i])\n            i -= 1\n        if j >= 0:\n            sum += int(num2[j])\n            j -= 1\n\n        carry = sum // 10\n        result.append(str(sum % 10))\n\n    return ''.join(result[::-1])\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "c++": "\n    ```cpp\nstd::string addStrings(std::string num1, std::string num2) {\n    int i = num1.size() - 1, j = num2.size() - 1, carry = 0;\n    std::string result;\n\n    while (i >= 0 || j >= 0 || carry) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1[i] - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2[j] - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.push_back(sum % 10 + '0');\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "js": "\n    ```javascript\nfunction addStrings(num1, num2) {\n    let i = num1.length - 1, j = num2.length - 1, carry = 0;\n    let result = [];\n\n    while (i >= 0 || j >= 0 || carry) {\n        let sum = carry;\n\n        if (i >= 0) {\n            sum += parseInt(num1[i]);\n            --i;\n        }\n        if (j >= 0) {\n            sum += parseInt(num2[j]);\n            --j;\n        }\n\n        carry = Math.floor(sum / 10);\n        result.push(sum % 10);\n    }\n\n    return result.reverse().join('');\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    "
    },
    {
        "id": 402,
        "title": "Battleships in a Board",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \". \"\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is either `'.'` or `'X'`.\n\n**",
            "follow_up": "Follow up:** Could you do it in one-pass, using only `O(1)` extra memory and without modifying the values `board`?"
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]",
                "output": "2"
            },
            {
                "input": "[[\".\"]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countBattleships(char[][] board) {\n    int count = 0;\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[i].length; j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "python": "\n    ```python\ndef countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "c++": "\n    ```cpp\nint countBattleships(vector<vector<char>>& board) {\n    int count = 0;\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[i].size(); j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "js": "\n    ```javascript\nfunction countBattleships(board) {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === 'X' &&\n                (i === 0 || board[i - 1][j] === '.') &&\n                (j === 0 || board[i][j - 1] === '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    "
    },
    {
        "id": 403,
        "title": "Strong Password Checker",
        "difficulty": "Hard",
        "content": {
            "problem": "A password is considered strong if the below conditions are all met:\n\n*   It has at least `6` characters and at most `20` characters.\n*   It contains at least **one lowercase** letter, at least **one uppercase** letter, and at least **one digit**.\n*   It does not contain three repeating characters in a row (i.e., `\"B**aaa**bb0 \"` is weak, but `\"B**aa**b**a**0 \"` is strong).\n\nGiven a string `password`, return _the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`._\n\nIn one step, you can:\n\n*   Insert one character to `password`,\n*   Delete one character from `password`, or\n*   Replace one character of `password` with another character.",
            "examples": [
                "**Example 1:**\n\n**Input:** password = \"a\"\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** password = \"aA1\"\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** password = \"1337C0d3\"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= password.length <= 50`\n*   `password` consists of letters, digits, dot `'.'` or exclamation mark `'!'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "\"a\"",
                "output": "5"
            },
            {
                "input": "\"aA1\"",
                "output": "3"
            },
            {
                "input": "\"1337C0d3\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint strongPassword(String password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = password.length();\n    for (char c : password.toCharArray()) {\n        if (Character.isLowerCase(c)) missingLower = 0;\n        if (Character.isUpperCase(c)) missingUpper = 0;\n        if (Character.isDigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "python": "\n    ```python\ndef strong_password(password):\n    missing_lower = 1\n    missing_upper = 1\n    missing_digit = 1\n    total = len(password)\n    \n    for c in password:\n        if c.islower(): missing_lower = 0\n        if c.isupper(): missing_upper = 0\n        if c.isdigit(): missing_digit = 0\n    \n    missing = missing_lower + missing_upper + missing_digit\n    if total < 6: return max(missing, 6 - total)\n    if total > 20: return missing + total - 20\n\n    return missing\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\nint strongPassword(string password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = (int)password.size();\n    for (char c : password) {\n        if (islower(c)) missingLower = 0;\n        if (isupper(c)) missingUpper = 0;\n        if (isdigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "js": "\n    ```javascript\nfunction strongPassword(password) {\n    let missingLower = 1, missingUpper = 1, missingDigit = 1;\n    let total = password.length;\n    for (const c of password) {\n        if (c.match(/[a-z]/)) missingLower = 0;\n        if (c.match(/[A-Z]/)) missingUpper = 0;\n        if (c.match(/[0-9]/)) missingDigit = 0;\n    }\n    let missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    "
    },
    {
        "id": 407,
        "title": "Longest Repeating Character Replacement",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn _the length of the longest substring containing the same letter you can get after performing the above operations_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ABAB \", k = 2\n**Output:** 4\n**Explanation:** Replace the two 'A's with two 'B's or vice versa.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"AABABBA \", k = 1\n**Output:** 4\n**Explanation:** Replace the one 'A' in the middle with 'B' and form  \"AABBBBA \".\nThe substring  \"BBBB \" has the longest repeating letters, which is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only uppercase English letters.\n*   `0 <= k <= s.length`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"ABAB\",2",
                "output": "4"
            },
            {
                "input": "\"AABABBA\",1",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int characterReplacement(String s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int[] freq = new int[26];\n    \n    for (right = 0; right < n; right++) {\n        freq[s.charAt(right) - 'A']++;\n        maxFreq = Math.max(maxFreq, freq[s.charAt(right) - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charAt(left) - 'A']--;\n            left++;\n        }\n        \n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "python": "\n    ```python\ndef characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint characterReplacement(string s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int freq[26] = {0};\n    \n    for (right = 0; right < n; right++) {\n        freq[s[right] - 'A']++;\n        maxFreq = max(maxFreq, freq[s[right] - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s[left] - 'A']--;\n            left++;\n        }\n        \n        result = max(result, right - left + 1);\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "js": "\n    ```javascript\nfunction characterReplacement(s, k) {\n    let n = s.length;\n    let left = 0, right = 0, maxFreq = 0, result = 0;\n    let freq = new Array(26).fill(0);\n\n    for (right = 0; right < n; right++) {\n        freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]++;\n        maxFreq = Math.max(maxFreq, freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]);\n\n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charCodeAt(left) - 'A'.charCodeAt(0)]--;\n            left++;\n        }\n\n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    "
    },
    {
        "id": 418,
        "title": "Non-overlapping Intervals",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,3\\]\\]\n**Output:** 1\n**Explanation:** \\[1,3\\] can be removed and the rest of the intervals are non-overlapping.\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[1,2\\],\\[1,2\\]\\]\n**Output:** 2\n**Explanation:** You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping.\n\n",
                "**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 0\n**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `-5 * 104 <= starti < endi <= 5 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[3,4],[1,3]]",
                "output": "1"
            },
            {
                "input": "[[1,2],[1,2],[1,2]]",
                "output": "2"
            },
            {
                "input": "[[1,2],[2,3]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int prev_end = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "python": "\n    ```python\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n    \n    std::sort(intervals.begin(), intervals.end(), compare);\n    \n    int count = 0;\n    int prev_end = intervals[0][1];\n    \n    for (size_t i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "js": "\n    ```javascript\nfunction eraseOverlapIntervals(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let prev_end = intervals[0][1];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    "
    },
    {
        "id": 421,
        "title": "Find All Anagrams in a String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `s` and `p`, return _an array of all the start indices of_ `p`_'s anagrams in_ `s`. You may return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"cbaebabacd \", p =  \"abc \"\n**Output:** \\[0,6\\]\n**Explanation:**\nThe substring with start index = 0 is  \"cba \", which is an anagram of  \"abc \".\nThe substring with start index = 6 is  \"bac \", which is an anagram of  \"abc \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abab \", p =  \"ab \"\n**Output:** \\[0,1,2\\]\n**Explanation:**\nThe substring with start index = 0 is  \"ab \", which is an anagram of  \"ab \".\nThe substring with start index = 1 is  \"ba \", which is an anagram of  \"ab \".\nThe substring with start index = 2 is  \"ab \", which is an anagram of  \"ab \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, p.length <= 3 * 104`\n*   `s` and `p` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"cbaebabacd\",\"abc\"",
                "output": "[0,6]"
            },
            {
                "input": "\"abab\",\"ab\"",
                "output": "[0,1,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> findAnagrams(String s, String p) {\n    List<Integer> result = new ArrayList<>();\n    if (s.length() < p.length()) return result;\n\n    int[] s_count = new int[26];\n    int[] p_count = new int[26];\n    for (char c : p.toCharArray()) p_count[c - 'a']++;\n\n    for (int i = 0; i < s.length(); i++) {\n        s_count[s.charAt(i) - 'a']++;\n        if (i >= p.length()) s_count[s.charAt(i - p.length()) - 'a']--;\n        if (java.util.Arrays.equals(s_count, p_count)) result.add(i - p.length() + 1);\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "python": "\n    ```python\ndef find_anagrams(s, p):\n    if len(s) < len(p):\n        return []\n\n    s_count = [0] * 26\n    p_count = [0] * 26\n    for c in p:\n        p_count[ord(c) - ord('a')] += 1\n\n    result = []\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n\n    return result\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> findAnagrams(std::string s, std::string p) {\n    std::vector<int> result;\n    if (s.size() < p.size()) return result;\n\n    std::vector<int> s_count(26, 0), p_count(26, 0);\n    for (char c : p) p_count[c - 'a']++;\n\n    for (int i = 0; i < s.size(); i++) {\n        s_count[s[i] - 'a']++;\n        if (i >= p.size()) s_count[s[i - p.size()] - 'a']--;\n        if (s_count == p_count) result.push_back(i - p.size() + 1);\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "js": "\n    ```javascript\nfunction findAnagrams(s, p) {\n    if (s.length < p.length) return [];\n\n    const s_count = new Array(26).fill(0);\n    const p_count = new Array(26).fill(0);\n    for (const c of p) p_count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    const result = [];\n    for (let i = 0; i < s.length; i++) {\n        s_count[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        if (i >= p.length) s_count[s.charCodeAt(i - p.length) - 'a'.charCodeAt(0)]--;\n        if (s_count.join(',') === p_count.join(',')) result.push(i - p.length + 1);\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    "
    },
    {
        "id": 424,
        "title": "Arranging Coins",
        "difficulty": "Easy",
        "content": {
            "problem": "You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.\n\nGiven the integer `n`, return _the number of **complete rows** of the staircase you will build_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** Because the 3rd row is incomplete, we return 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** Because the 4th row is incomplete, we return 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "5",
                "output": "2"
            },
            {
                "input": "8",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "python": "\n    ```python\ndef arrange_coins(n: int) -> int:\n    k = 0\n    while n > k:\n        k += 1\n        n -= k\n    return k\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "c++": "\n    ```cpp\nint arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "js": "\n    ```javascript\nfunction arrangeCoins(n) {\n    let k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    "
    },
    {
        "id": 425,
        "title": "Find All Duplicates in an Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, return _an array of all the integers that appears **twice**_.\n\nYou must write an algorithm that runs in `O(n)` time and uses only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,7,8,2,3,1\\]\n**Output:** \\[2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= n`\n*   Each element in `nums` appears **once** or **twice**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[4,3,2,7,8,2,3,1]",
                "output": "[2,3]"
            },
            {
                "input": "[1,1,2]",
                "output": "[1]"
            },
            {
                "input": "[1]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDuplicates(int[] nums) {\n    List<Integer> duplicates = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.add(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "python": "\n    ```python\ndef find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums) {\n    std::vector<int> duplicates;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push_back(abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "js": "\n    ```javascript\nfunction findDuplicates(nums) {\n    let duplicates = [];\n    for (let i = 0; i < nums.length; i++) {\n        let index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    "
    },
    {
        "id": 430,
        "title": "Number of Boomerangs",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.\n\nReturn _the number of boomerangs_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 2\n**Explanation:** The two boomerangs are \\[\\[1,0\\],\\[0,0\\],\\[2,0\\]\\] and \\[\\[1,0\\],\\[2,0\\],\\[0,0\\]\\].\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** points = \\[\\[1,1\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 500`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the points are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math"
        ],
        "example": [
            {
                "input": "[[0,0],[1,0],[2,0]]",
                "output": "2"
            },
            {
                "input": "[[1,1],[2,2],[3,3]]",
                "output": "2"
            },
            {
                "input": "[[1,1]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int numberOfBoomerangs(int[][] points) {\n    int count = 0;\n\n    for (int[] i : points) {\n        HashMap<Integer, Integer> group_count = new HashMap<>();\n        for (int[] j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n\n            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);\n        }\n\n        for (int g : group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "python": "\n    ```python\ndef numberOfBoomerangs(points):\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint numberOfBoomerangs(vector<vector<int>>& points) {\n    int count = 0;\n\n    for (auto& i : points) {\n        unordered_map<int, int> group_count;\n        for (auto& j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n            group_count[dist]++;\n        }\n\n        for (auto& g : group_count) {\n            count += g.second * (g.second - 1);\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "js": "\n    ```javascript\nfunction numberOfBoomerangs(points) {\n    let count = 0;\n\n    for (let i of points) {\n        let group_count = new Map();\n        for (let j of points) {\n            let dx = i[0] - j[0], dy = i[1] - j[1];\n            let dist = dx * dx + dy * dy;\n            group_count.set(dist, (group_count.get(dist) || 0) + 1);\n        }\n\n        for (let g of group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    "
    },
    {
        "id": 431,
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return _an array of all the integers in the range_ `[1, n]` _that do not appear in_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,7,8,2,3,1\\]\n**Output:** \\[5,6\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= n`\n\n**",
            "follow_up": "Follow up:** Could you do it without extra space and in `O(n)` runtime? You may assume the returned list does not count as extra space."
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[4,3,2,7,8,2,3,1]",
                "output": "[5,6]"
            },
            {
                "input": "[1,1]",
                "output": "[2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "python": "\n    ```python\ndef find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums) {\n    vector<int> result;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        int index = abs(nums[i]) - 1;\n        nums[index] = -abs(nums[index]);\n    }\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "js": "\n    ```javascript\nfunction findDisappearedNumbers(nums) {\n    const result = [];\n\n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    "
    },
    {
        "id": 432,
        "title": "Serialize and Deserialize BST",
        "difficulty": "Medium",
        "content": {
            "problem": "Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a **binary search tree**. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.\n\n**The encoded string should be as compact as possible.**",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,1,3\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `0 <= Node.val <= 104`\n*   The input tree is **guaranteed** to be a binary search tree.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Design",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[2,1,3]",
                "output": "[2,1,3]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Codec {\n\n    public String serialize(TreeNode root) {\n        if (root == null) return \"#\";\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return deserializeHelper(queue);\n    }\n\n    private TreeNode deserializeHelper(Queue<String> queue) {\n        String val = queue.poll();\n        if (\"#\".equals(val)) return null;\n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        node.left = deserializeHelper(queue);\n        node.right = deserializeHelper(queue);\n        return node;\n    }\n}\n```\n\n    \n    The algorithm utilizes a pre-order traversal to serialize the binary search tree. When the tree is serialized, the val of each TreeNode is visited before its children. Empty nodes are represented by \"#\" and commas are used to separate values in the serialized string.\n\nTo deserialize, the function processes the serialized string and reconstructs the tree using the pre-order traversal pattern. When an empty node is encountered (indicated by \"#\"), it returns null. Otherwise, it constructs a TreeNode for the current value, recursively deserializes the left and right children, and returns the constructed node. \n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root:\n        return \"#\"\n    return str(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = next(values)\n        if val == \"#\":\n            return None\n        node = TreeNode(int(val))\n        node.left = deserialize_helper(values)\n        node.right = deserialize_helper(values)\n        return node\n\n    values = iter(data.split(\",\"))\n    return deserialize_helper(values)\n```\n\n    \n    The algorithm utilizes a pre-order traversal to serialize the binary search tree. When the tree is serialized, the val of each TreeNode is visited before its children. Empty nodes are represented by \"#\" and commas are used to separate values in the serialized string.\n\nTo deserialize, the function processes the serialized string and reconstructs the tree using the pre-order traversal pattern. When an empty node is encountered (indicated by \"#\"), it returns null. Otherwise, it constructs a TreeNode for the current value, recursively deserializes the left and right children, and returns the constructed node. \n    ",
        "c++": "\n    ```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstd::string serialize(TreeNode* root) {\n    if (!root) return \"#\";\n    return std::to_string(root->val) + ',' + serialize(root->left) + ',' + serialize(root->right);\n}\n\nTreeNode* deserialize(std::string data) {\n    std::istringstream data_stream(data);\n    return deserialize_helper(data_stream);\n}\n\nTreeNode* deserialize_helper(std::istringstream& data_stream) {\n    std::string val;\n    std::getline(data_stream, val, ',');\n\n    if (val == \"#\") return nullptr;\n    TreeNode* node = new TreeNode(std::stoi(val));\n    node->left = deserialize_helper(data_stream);\n    node->right = deserialize_helper(data_stream);\n    return node;\n}\n```\n\n    \n    The algorithm utilizes a pre-order traversal to serialize the binary search tree. When the tree is serialized, the val of each TreeNode is visited before its children. Empty nodes are represented by \"#\" and commas are used to separate values in the serialized string.\n\nTo deserialize, the function processes the serialized string and reconstructs the tree using the pre-order traversal pattern. When an empty node is encountered (indicated by \"#\"), it returns null. Otherwise, it constructs a TreeNode for the current value, recursively deserializes the left and right children, and returns the constructed node. \n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n}\n\nfunction serialize(root) {\n    if (!root) return \"#\";\n    return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n}\n\nfunction deserialize(data) {\n    const values = data.split(\",\");\n\n    function deserialize_helper() {\n        const val = values.shift();\n\n        if (val === \"#\") return null;\n        const node = new TreeNode(parseInt(val));\n        node.left = deserialize_helper();\n        node.right = deserialize_helper();\n        return node;\n    }\n\n    return deserialize_helper();\n}\n```\n\n    \n    The algorithm utilizes a pre-order traversal to serialize the binary search tree. When the tree is serialized, the val of each TreeNode is visited before its children. Empty nodes are represented by \"#\" and commas are used to separate values in the serialized string.\n\nTo deserialize, the function processes the serialized string and reconstructs the tree using the pre-order traversal pattern. When an empty node is encountered (indicated by \"#\"), it returns null. Otherwise, it constructs a TreeNode for the current value, recursively deserializes the left and right children, and returns the constructed node. \n    "
    },
    {
        "id": 435,
        "title": "Minimum Number of Arrows to Burst Balloons",
        "difficulty": "Medium",
        "content": {
            "problem": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[10,16\\],\\[2,8\\],\\[1,6\\],\\[7,12\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons \\[2,8\\] and \\[1,6\\].\n- Shoot an arrow at x = 11, bursting the balloons \\[10,16\\] and \\[7,12\\].\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\],\\[7,8\\]\\]\n**Output:** 4\n**Explanation:** One arrow needs to be shot for each balloon for a total of 4 arrows.\n\n",
                "**Example 3:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons \\[1,2\\] and \\[2,3\\].\n- Shoot an arrow at x = 4, bursting the balloons \\[3,4\\] and \\[4,5\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-231 <= xstart < xend <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[10,16],[2,8],[1,6],[7,12]]",
                "output": "2"
            },
            {
                "input": "[[1,2],[3,4],[5,6],[7,8]]",
                "output": "4"
            },
            {
                "input": "[[1,2],[2,3],[3,4],[4,5]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findMinArrowShots(int[][] points) {\n    if (points.length == 0) return 0;\n    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ",
        "python": "\n    ```python\ndef findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points) {\n    if (points.empty()) return 0;\n    std::sort(points.begin(), points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    ",
        "js": "\n    ```javascript\nfunction findMinArrowShots(points) {\n    if (points.length === 0) return 0;\n    points.sort((a, b) => a[1] - b[1]);\n\n    let arrows = 1;\n    let end = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n```\n    \n    The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. \n    "
    },
    {
        "id": 436,
        "title": "Minimum Moves to Equal Array Elements",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.\n\nIn one move, you can increment `n - 1` elements of the array by `1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n**Explanation:** Only three moves are needed (remember each move increments two elements):\n\\[1,2,3\\]  =>  \\[2,3,3\\]  =>  \\[3,4,3\\]  =>  \\[4,4,4\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   The answer is guaranteed to fit in a **32-bit** integer.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "3"
            },
            {
                "input": "[1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minMoves(int[] nums) {\n    int min_element = nums[0];\n    for (int num : nums) {\n        min_element = Math.min(min_element, num);\n    }\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1).\n    ",
        "python": "\n    ```python\ndef min_moves(nums):\n    min_element = min(nums)\n    moves = sum(num - min_element for num in nums)\n    return moves\n```\n\n    \n    The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1).\n    ",
        "c++": "\n    ```cpp\nint minMoves(vector<int>& nums) {\n    int min_element = *min_element(nums.begin(), nums.end());\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1).\n    ",
        "js": "\n    ```javascript\nfunction minMoves(nums) {\n    let min_element = Math.min(...nums);\n    let moves = nums.reduce((acc, num) => acc + (num - min_element), 0);\n    return moves;\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1).\n    "
    },
    {
        "id": 437,
        "title": "4Sum II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4` all of length `n`, return the number of tuples `(i, j, k, l)` such that:\n\n*   `0 <= i, j, k, l < n`\n*   `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[-2,-1\\], nums3 = \\[-1,2\\], nums4 = \\[0,2\\]\n**Output:** 2\n**Explanation:**\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1\\[0\\] + nums2\\[0\\] + nums3\\[0\\] + nums4\\[1\\] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1\\[1\\] + nums2\\[1\\] + nums3\\[0\\] + nums4\\[0\\] = 2 + (-1) + (-1) + 0 = 0\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[0\\], nums2 = \\[0\\], nums3 = \\[0\\], nums4 = \\[0\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length`\n*   `n == nums2.length`\n*   `n == nums3.length`\n*   `n == nums4.length`\n*   `1 <= n <= 200`\n*   `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2],[-2,-1],[-1,2],[0,2]",
                "output": "2"
            },
            {
                "input": "[0],[0],[0],[0]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    int count = 0;\n\n    for (int i : nums1) {\n        for (int j : nums2) {\n            hashMap.put(i + j, hashMap.getOrDefault(i + j, 0) + 1);\n        }\n    }\n\n    for (int k : nums3) {\n        for (int l : nums4) {\n            count += hashMap.getOrDefault(-(k + l), 0);\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm follows these steps to solve the problem:\n1. Create an empty hashmap to store the sum of two integers and their frequency.\n2. Iterate through the first two arrays nums1 and nums2, calculate their sum and store their frequency in the hashmap.\n3. Iterate through the third and fourth arrays nums3 and nums4, and for each pair of elements, calculate their sum, and check if the negative of this sum exists in the hashmap. If it exists, add the frequency of that sum to the result count.\n4. Finally, return the count.\n    ",
        "python": "\n    ```python\ndef fourSumCount(nums1, nums2, nums3, nums4):\n    hashMap = {}\n    count = 0\n\n    for i in nums1:\n        for j in nums2:\n            hashMap[i + j] = hashMap.get(i + j, 0) + 1\n\n    for k in nums3:\n        for l in nums4:\n            count += hashMap.get(-(k + l), 0)\n\n    return count\n```\n    \n    The algorithm follows these steps to solve the problem:\n1. Create an empty hashmap to store the sum of two integers and their frequency.\n2. Iterate through the first two arrays nums1 and nums2, calculate their sum and store their frequency in the hashmap.\n3. Iterate through the third and fourth arrays nums3 and nums4, and for each pair of elements, calculate their sum, and check if the negative of this sum exists in the hashmap. If it exists, add the frequency of that sum to the result count.\n4. Finally, return the count.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n    unordered_map<int, int> hashMap;\n    int count = 0;\n    \n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            hashMap[i + j]++;\n        }\n    }\n    \n    for (auto k : nums3) {\n        for (auto l : nums4) {\n            count += hashMap[-(k + l)];\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm follows these steps to solve the problem:\n1. Create an empty hashmap to store the sum of two integers and their frequency.\n2. Iterate through the first two arrays nums1 and nums2, calculate their sum and store their frequency in the hashmap.\n3. Iterate through the third and fourth arrays nums3 and nums4, and for each pair of elements, calculate their sum, and check if the negative of this sum exists in the hashmap. If it exists, add the frequency of that sum to the result count.\n4. Finally, return the count.\n    ",
        "js": "\n    ```javascript\nfunction fourSumCount(nums1, nums2, nums3, nums4) {\n    const hashMap = new Map();\n    let count = 0;\n\n    for (const i of nums1) {\n        for (const j of nums2) {\n            hashMap.set(i + j, (hashMap.get(i + j) || 0) + 1);\n        }\n    }\n\n    for (const k of nums3) {\n        for (const l of nums4) {\n            count += hashMap.get(-(k + l)) || 0;\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm follows these steps to solve the problem:\n1. Create an empty hashmap to store the sum of two integers and their frequency.\n2. Iterate through the first two arrays nums1 and nums2, calculate their sum and store their frequency in the hashmap.\n3. Iterate through the third and fourth arrays nums3 and nums4, and for each pair of elements, calculate their sum, and check if the negative of this sum exists in the hashmap. If it exists, add the frequency of that sum to the result count.\n4. Finally, return the count.\n    "
    },
    {
        "id": 438,
        "title": "Assign Cookies",
        "difficulty": "Easy",
        "content": {
            "problem": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.",
            "examples": [
                "**Example 1:**\n\n**Input:** g = \\[1,2,3\\], s = \\[1,1\\]\n**Output:** 1\n**Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n",
                "**Example 2:**\n\n**Input:** g = \\[1,2\\], s = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= g.length <= 3 * 104`\n*   `0 <= s.length <= 3 * 104`\n*   `1 <= g[i], s[j] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3],[1,1]",
                "output": "1"
            },
            {
                "input": "[1,2],[1,2,3]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "python": "\n    ```python\ndef find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s) {\n    std::sort(g.begin(), g.end());\n    std::sort(s.begin(), s.end());\n    int i = 0, j = 0;\n\n    while (i < g.size() && j < s.size()) {\n      if (s[j] >= g[i]) {\n        i++;\n      }\n\n      j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "js": "\n    ```javascript\nfunction findContentChildren(g, s) {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    "
    },
    {
        "id": 444,
        "title": "Hamming Distance",
        "difficulty": "Easy",
        "content": {
            "problem": "The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers `x` and `y`, return _the **Hamming distance** between them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 1, y = 4\n**Output:** 2\n**Explanation:**\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\nThe above arrows point to positions where the corresponding bits are different.\n\n",
                "**Example 2:**\n\n**Input:** x = 3, y = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= x, y <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "1,4",
                "output": "2"
            },
            {
                "input": "3,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "python": "\n    ```python\ndef hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "c++": "\n    ```cpp\nint hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "js": "\n    ```javascript\nfunction hammingDistance(x, y) {\n    let dist = 0;\n    let xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    "
    },
    {
        "id": 445,
        "title": "Minimum Moves to Equal Array Elements II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.\n\nIn one move, you can increment or decrement an element of the array by `1`.\n\nTest cases are designed so that the answer will fit in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 2\n**Explanation:**\nOnly two moves are needed (remember each move increments or decrements one element):\n\\[1,2,3\\]  =>  \\[2,2,3\\]  =>  \\[2,2,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,10,2,9\\]\n**Output:** 16"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "2"
            },
            {
                "input": "[1,10,2,9]",
                "output": "16"
            }
        ],
        "java": "\n    ```java\npublic int minMoves2(int[] nums) {\n    Arrays.sort(nums);\n    int mid = nums[nums.length / 2];\n    int moves = 0;\n    for (int num : nums) {\n        moves += Math.abs(num - mid);\n    }\n    return moves;\n}\n```\n    \n    1. Sort the array `nums` in ascending order.\n2. Find the middle element (median) of the sorted array.\n3. Initialize a variable `moves` to store the number of moves required.\n4. Iterate through the array, and for each element, calculate the absolute difference between the element and the median. Add this difference to the `moves` variable.\n5. Return the total `moves`.\n\nThe algorithm takes advantage of the fact that the optimal solution is to move all elements towards the median, as it minimizes the total distance between the elements.\n    ",
        "python": "\n    ```python\ndef min_moves2(nums):\n    nums.sort()\n    mid = nums[len(nums) // 2]\n    moves = 0\n    for num in nums:\n        moves += abs(num - mid)\n    return moves\n```\n    \n    1. Sort the array `nums` in ascending order.\n2. Find the middle element (median) of the sorted array.\n3. Initialize a variable `moves` to store the number of moves required.\n4. Iterate through the array, and for each element, calculate the absolute difference between the element and the median. Add this difference to the `moves` variable.\n5. Return the total `moves`.\n\nThe algorithm takes advantage of the fact that the optimal solution is to move all elements towards the median, as it minimizes the total distance between the elements.\n    ",
        "c++": "\n    ```cpp\nint minMoves2(vector<int>& nums) {\n    int n = nums.size();\n    sort(nums.begin(), nums.end());\n    int mid = nums[n / 2];\n    int moves = 0;\n    for (int i = 0; i < n; i++) {\n        moves += abs(nums[i] - mid);\n    }\n    return moves;\n}\n```\n    \n    1. Sort the array `nums` in ascending order.\n2. Find the middle element (median) of the sorted array.\n3. Initialize a variable `moves` to store the number of moves required.\n4. Iterate through the array, and for each element, calculate the absolute difference between the element and the median. Add this difference to the `moves` variable.\n5. Return the total `moves`.\n\nThe algorithm takes advantage of the fact that the optimal solution is to move all elements towards the median, as it minimizes the total distance between the elements.\n    ",
        "js": "\n    ```javascript\nfunction minMoves2(nums) {\n    nums.sort((a, b) => a - b);\n    const mid = nums[Math.floor(nums.length / 2)];\n    let moves = 0;\n    for (const num of nums) {\n        moves += Math.abs(num - mid);\n    }\n    return moves;\n}\n```\n    \n    1. Sort the array `nums` in ascending order.\n2. Find the middle element (median) of the sorted array.\n3. Initialize a variable `moves` to store the number of moves required.\n4. Iterate through the array, and for each element, calculate the absolute difference between the element and the median. Add this difference to the `moves` variable.\n5. Return the total `moves`.\n\nThe algorithm takes advantage of the fact that the optimal solution is to move all elements towards the median, as it minimizes the total distance between the elements.\n    "
    },
    {
        "id": 446,
        "title": "Island Perimeter",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]",
                "output": "16"
            },
            {
                "input": "[[1]]",
                "output": "4"
            },
            {
                "input": "[[1,0]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "python": "\n    ```python\ndef islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "c++": "\n    ```cpp\nint islandPerimeter(vector<vector<int>>& grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.size(); row++) {\n        for (int col = 0; col < grid[row].size(); col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "js": "\n    ```javascript\nfunction islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    "
    },
    {
        "id": 450,
        "title": "Unique Substrings in Wraparound String",
        "difficulty": "Medium",
        "content": {
            "problem": "We define the string `base` to be the infinite wraparound string of `\"abcdefghijklmnopqrstuvwxyz \"`, so `base` will look like this:\n\n*   `\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.... \"`.\n\nGiven a string `s`, return _the number of **unique non-empty substrings** of_ `s` _are present in_ `base`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** Only the substring  \"a \" of s is in base.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"cac \"\n**Output:** 2\n**Explanation:** There are two substrings ( \"a \",  \"c \") of s in base.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"zab \"\n**Output:** 6\n**Explanation:** There are six substrings ( \"z \",  \"a \",  \"b \",  \"za \",  \"ab \", and  \"zab \") of s in base."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"a\"",
                "output": "1"
            },
            {
                "input": "\"cac\"",
                "output": "2"
            },
            {
                "input": "\"zab\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int findSubstringInWraproundString(String p) {\n    int[] cnt = new int[26];\n    int length = 0;\n\n    for (int i = 0; i < p.length(); i++) {\n        if (i > 0 && (p.charAt(i) == p.charAt(i - 1) + 1 || p.charAt(i - 1) - p.charAt(i) == 25)) {\n            length++;\n        } else {\n            length = 1;\n        }\n        cnt[p.charAt(i) - 'a'] = Math.max(cnt[p.charAt(i) - 'a'], length);\n    }\n\n    int sum = 0;\n    for (int v : cnt) {\n        sum += v;\n    }\n    return sum;\n}\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ",
        "python": "\n    ```python\ndef findSubstringInWraproundString(p: str) -> int:\n    cnt = [0] * 26\n    length = 0\n\n    for i in range(len(p)):\n        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):\n            length += 1\n        else:\n            length = 1\n        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)\n\n    return sum(cnt)\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint findSubstringInWraproundString(const std::string& p) {\n    std::vector<int> cnt(26, 0);\n    int length = 0;\n\n    for (int i = 0; i < p.size(); i++) {\n        if (i > 0 && (p[i] == p[i - 1] + 1 || p[i - 1] - p[i] == 25)) {\n            length++;\n        } else {\n            length = 1;\n        }\n        cnt[p[i] - 'a'] = std::max(cnt[p[i] - 'a'], length);\n    }\n\n    return std::accumulate(cnt.begin(), cnt.end(), 0);\n}\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    ",
        "js": "\n    ```javascript\nfunction findSubstringInWraproundString(p) {\n    const cnt = new Array(26).fill(0);\n    let length = 0;\n\n    for (let i = 0; i < p.length; i++) {\n        if (i > 0 && (p.charCodeAt(i) === p.charCodeAt(i - 1) + 1 || p.charCodeAt(i - 1) - p.charCodeAt(i) === 25)) {\n            length++;\n        } else {\n            length = 1;\n        }\n        cnt[p.charCodeAt(i) - 'a'.charCodeAt(0)] = Math.max(cnt[p.charCodeAt(i) - 'a'.charCodeAt(0)], length);\n    }\n\n    return cnt.reduce((a, b) => a + b, 0);\n}\n```\n\n    \n    1. Initialize an array cnt of size 26 to keep the count of the maximum length of contiguous characters ending with a given character.\n2. Initialize a variable length to keep track of the current count of contiguous characters.\n3. Iterate through the given string p.\n   - If the current character is the next character of the previous one or wraps around from 'z' to 'a', increment length by 1.\n   - Otherwise, reset length to 1.\n   - Update cnt for the current character with the maximum of its current value and length.\n4. Return the sum of all the counts in cnt.\n    "
    },
    {
        "id": 457,
        "title": "Ones and Zeroes",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of binary strings `strs` and two integers `m` and `n`.\n\nReturn _the size of the largest subset of `strs` such that there are **at most**_ `m` `0`_'s and_ `n` `1`_'s in the subset_.\n\nA set `x` is a **subset** of a set `y` if all elements of `x` are also elements of `y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"10 \", \"0001 \", \"111001 \", \"1 \", \"0 \"\\], m = 5, n = 3\n**Output:** 4\n**Explanation:** The largest subset with at most 5 0's and 3 1's is { \"10 \",  \"0001 \",  \"1 \",  \"0 \"}, so the answer is 4.\nOther valid but smaller subsets include { \"0001 \",  \"1 \"} and { \"10 \",  \"1 \",  \"0 \"}.\n{ \"111001 \"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"10 \", \"0 \", \"1 \"\\], m = 1, n = 1\n**Output:** 2\n**Explanation:** The largest subset is { \"0 \",  \"1 \"}, so the answer is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 600`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists only of digits `'0'` and `'1'`.\n*   `1 <= m, n <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[\"10\",\"0001\",\"111001\",\"1\",\"0\"],5,3",
                "output": "4"
            },
            {
                "input": "[\"10\",\"0\",\"1\"],1,1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findMaxForm(String[] strs, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (String str: strs) {\n        int ones = (int) str.chars().filter(ch -> ch == '1').count();\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ",
        "python": "\n    ```python\ndef findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint findMaxForm(std::vector<std::string>& strs, int m, int n) {\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n    \n    for (const std::string& str: strs) {\n        int ones = std::count(str.begin(), str.end(), '1');\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = std::max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    ",
        "js": "\n    ```javascript\nfunction findMaxForm(strs, m, n) {\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (const str of strs) {\n        const ones = str.split('').filter(ch => ch === '1').length;\n        const zeros = str.length - ones;\n        \n        for (let i = m; i >= zeros; --i) {\n            for (let j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's.\n    "
    },
    {
        "id": 464,
        "title": "Magical String",
        "difficulty": "Medium",
        "content": {
            "problem": "A magical string `s` consists of only `'1'` and `'2'` and obeys the following rules:\n\n*   The string s is magical because concatenating the number of contiguous occurrences of characters `'1'` and `'2'` generates the string `s` itself.\n\nThe first few elements of `s` is `s = \"1221121221221121122...... \"`. If we group the consecutive `1`'s and `2`'s in `s`, it will be `\"1 22 11 2 1 22 1 22 11 2 11 22 ...... \"` and the occurrences of `1`'s or `2`'s in each group are `\"1 2 2 1 1 2 1 2 2 1 2 2 ...... \"`. You can see that the occurrence sequence is `s` itself.\n\nGiven an integer `n`, return the number of `1`'s in the first `n` number in the magical string `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6\n**Output:** 3\n**Explanation:** The first 6 elements of magical string s is  \"122112 \" and it contains three 1's, so return 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "6",
                "output": "3"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    int[] magic = new int[n + 1];\n    magic[0] = 1;\n    magic[1] = 2;\n    magic[2] = 2;\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (index < n) {\n        for (int i = 0; i < magic[index] && index < n; i++) {\n            magic[++index] = value;\n            if (value == 1) count_ones++;\n        }\n        value = 3 - value;\n    }\n    \n    return count_ones;\n}\n```\n\n    \n    1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable.\n    ",
        "python": "\n    ```python\ndef magical_string(n: int) -> int:\n    if n == 0:\n        return 0\n    if n <= 3:\n        return 1\n\n    magic = [1, 2, 2]\n    count_ones = 1\n    index = 2\n    value = 1\n\n    while len(magic) < n:\n        for _ in range(magic[index]):\n            magic.append(value)\n            if value == 1 and len(magic) <= n:\n                count_ones += 1\n        value = 3 - value\n        index += 1\n\n    return count_ones\n```\n\n    \n    1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable.\n    ",
        "c++": "\n    ```cpp\nint magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    vector<int> magic = {1, 2, 2};\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (magic.size() < n) {\n        for (int i = 0; i < magic[index]; ++i) {\n            magic.push_back(value);\n            if (value == 1 && magic.size() <= n) count_ones++;\n        }\n        value = 3 - value;\n        index++;\n    }\n    \n    return count_ones;\n}\n```\n\n    \n    1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable.\n    ",
        "js": "\n    ```javascript\nfunction magicalString(n) {\n    if (n === 0) return 0;\n    if (n <= 3) return 1;\n\n    let magic = [1, 2, 2];\n    let countOnes = 1;\n    let index = 2;\n    let value = 1;\n\n    while (magic.length < n) {\n        for (let i = 0; i < magic[index]; i++) {\n            magic.push(value);\n            if (value === 1 && magic.length <= n) countOnes++;\n        }\n        value = 3 - value;\n        index++;\n    }\n\n    return countOnes;\n}\n```\n\n    \n    1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable.\n    "
    },
    {
        "id": 468,
        "title": "Max Consecutive Ones",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,0,1,1,1\\]\n**Output:** 3\n**Explanation:** The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1,0,1\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,1,0,1,1,1]",
                "output": "3"
            },
            {
                "input": "[1,0,1,1,0,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "python": "\n    ```python\ndef findMaxConsecutiveOnes(nums):\n    max_consecutive, current_consecutive = 0, 0\n    for num in nums:\n        current_consecutive = current_consecutive + 1 if num == 1 else 0\n        max_consecutive = max(max_consecutive, current_consecutive)\n    return max_consecutive\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "c++": "\n    ```cpp\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "js": "\n    ```javascript\nfunction findMaxConsecutiveOnes(nums) {\n    let maxConsecutive = 0, currentConsecutive = 0;\n    for (let num of nums) {\n        currentConsecutive = (num === 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    "
    },
    {
        "id": 478,
        "title": "Teemo Attacking",
        "difficulty": "Easy",
        "content": {
            "problem": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.\n\nReturn _the **total** number of seconds that Ashe is poisoned_.",
            "examples": [
                "**Example 1:**\n\n**Input:** timeSeries = \\[1,4\\], duration = 2\n**Output:** 4\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n\n",
                "**Example 2:**\n\n**Input:** timeSeries = \\[1,2\\], duration = 2\n**Output:** 3\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= timeSeries.length <= 104`\n*   `0 <= timeSeries[i], duration <= 107`\n*   `timeSeries` is sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[1,4],2",
                "output": "4"
            },
            {
                "input": "[1,2],2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findPoisonedDuration(int[] timeSeries, int duration) {\n    if (timeSeries.length == 0) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "python": "\n    ```python\ndef find_poisoned_duration(time_series, duration):\n    if not time_series:\n        return 0\n    total = 0\n    for i in range(1, len(time_series)):\n        total += min(time_series[i] - time_series[i - 1], duration)\n    return total + duration\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "c++": "\n    ```cpp\nint findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (timeSeries.empty()) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.size(); ++i) {\n        total += min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "js": "\n    ```javascript\nfunction findPoisonedDuration(timeSeries, duration) {\n    if (timeSeries.length === 0) return 0;\n    let total = 0;\n    for (let i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    "
    },
    {
        "id": 479,
        "title": "Next Greater Element I",
        "difficulty": "Easy",
        "content": {
            "problem": "The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.\n\nYou are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.\n\nFor each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.\n\nReturn _an array_ `ans` _of length_ `nums1.length` _such that_ `ans[i]` _is the **next greater element** as described above._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[4,1,2\\], nums2 = \\[1,3,4,2\\]\n**Output:** \\[-1,3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = \\[1,3,4,2\\]. The next greater element is 3.\n- 2 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[2,4\\], nums2 = \\[1,2,3,4\\]\n**Output:** \\[3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = \\[1,2,3,4\\]. The next greater element is 3.\n- 4 is underlined in nums2 = \\[1,2,3,4\\]. There is no next greater element, so the answer is -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length <= nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 104`\n*   All integers in `nums1` and `nums2` are **unique**.\n*   All the integers of `nums1` also appear in `nums2`.\n\n**",
            "follow_up": "Follow up:** Could you find an `O(nums1.length + nums2.length)` solution?"
        },
        "tag": [
            "Array",
            "Hash Table",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[4,1,2],[1,3,4,2]",
                "output": "[-1,3,-1]"
            },
            {
                "input": "[2,4],[1,2,3,4]",
                "output": "[3,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "python": "\n    ```python\ndef next_greater_element(nums1, nums2):\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "js": "\n    ```javascript\nfunction nextGreaterElement(nums1, nums2) {\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    return nums1.map(n => nextGreater.get(n) || -1);\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    "
    },
    {
        "id": 487,
        "title": "Base 7",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, return _a string of its **base 7** representation_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 100\n**Output:** \"202\"\n\n",
                "**Example 2:**\n\n**Input:** num = -7\n**Output:** \"-10\""
            ],
            "constraints": "**Constraints:**\n\n*   `-107 <= num <= 107`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "100",
                "output": "\"202\""
            },
            {
                "input": "-7",
                "output": "\"-10\""
            }
        ],
        "java": "\n    ```java\npublic String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "python": "\n    ```python\ndef convert_to_base7(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    result = \"\"\n    negative = num < 0\n    if negative:\n        num *= -1\n    while num > 0:\n        result = str(num % 7) + result\n        num //= 7\n    return \"-\" + result if negative else result\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "c++": "\n    ```cpp\nstd::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "js": "\n    ```javascript\nfunction convertToBase7(num) {\n    if (num === 0) return \"0\";\n    let result = \"\";\n    let negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = (num % 7).toString() + result;\n        num = Math.floor(num / 7);\n    }\n    return negative ? \"-\" + result : result;\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    "
    },
    {
        "id": 492,
        "title": "Fibonacci Number",
        "difficulty": "Easy",
        "content": {
            "problem": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 30`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Recursion",
            "Memoization"
        ],
        "example": [
            {
                "input": "2",
                "output": "1"
            },
            {
                "input": "3",
                "output": "2"
            },
            {
                "input": "4",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "python": "\n    ```python\ndef fib(n: int) -> int:\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "c++": "\n    ```cpp\nint fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "js": "\n    ```javascript\nfunction fib(n) {\n    if(n < 2) {\n        return n;\n    }\n    let a = 0, b = 1, c;\n    for(let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    "
    },
    {
        "id": 499,
        "title": "Coin Change II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the number of combinations that make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is **guaranteed** to fit into a signed **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** amount = 5, coins = \\[1,2,5\\]\n**Output:** 4\n**Explanation:** there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\n",
                "**Example 2:**\n\n**Input:** amount = 3, coins = \\[2\\]\n**Output:** 0\n**Explanation:** the amount of 3 cannot be made up just with coins of 2.\n\n",
                "**Example 3:**\n\n**Input:** amount = 10, coins = \\[10\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= coins.length <= 300`\n*   `1 <= coins[i] <= 5000`\n*   All the values of `coins` are **unique**.\n*   `0 <= amount <= 5000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "5,[1,2,5]",
                "output": "4"
            },
            {
                "input": "3,[2]",
                "output": "0"
            },
            {
                "input": "10,[10]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ",
        "python": "\n    ```python\ndef change(amount, coins):\n    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ",
        "c++": "\n    ```cpp\nint change(int amount, vector<int>& coins) {\n    vector<int> dp(amount + 1, 0);\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    ",
        "js": "\n    ```javascript\nfunction change(amount, coins) {\n    let dp = new Array(amount + 1).fill(0);\n    dp[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n```\n    \n    1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount.\n    "
    },
    {
        "id": 502,
        "title": "Longest Uncommon Subsequence I",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `a` and `b`, return _the length of the **longest uncommon subsequence** between_ `a` _and_ `b`. If the longest uncommon subsequence does not exist, return `-1`.\n\nAn **uncommon subsequence** between two strings is a string that is a **subsequence of one but not the other**.\n\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string).",
            "examples": [
                "**Example 1:**\n\n**Input:** a =  \"aba \", b =  \"cdc \"\n**Output:** 3\n**Explanation:** One longest uncommon subsequence is  \"aba \" because  \"aba \" is a subsequence of  \"aba \" but not  \"cdc \".\nNote that  \"cdc \" is also a longest uncommon subsequence.\n\n",
                "**Example 2:**\n\n**Input:** a =  \"aaa \", b =  \"bbb \"\n**Output:** 3\n**Explanation:** The longest uncommon subsequences are  \"aaa \" and  \"bbb \".\n\n",
                "**Example 3:**\n\n**Input:** a =  \"aaa \", b =  \"aaa \"\n**Output:** -1\n**Explanation:** Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a.length, b.length <= 100`\n*   `a` and `b` consist of lower-case English letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"aba\",\"cdc\"",
                "output": "3"
            },
            {
                "input": "\"aaa\",\"bbb\"",
                "output": "3"
            },
            {
                "input": "\"aaa\",\"aaa\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findLUSlength(String a, String b) {\n    if (a.equals(b)) {\n        return -1;\n    }\n    return Math.max(a.length(), b.length());\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "python": "\n    ```python\ndef findLUSlength(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "c++": "\n    ```cpp\nint findLUSlength(string a, string b) {\n    if (a == b) {\n        return -1;\n    }\n    return max(a.length(), b.length());\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "js": "\n    ```javascript\nfunction findLUSlength(a, b) {\n    if (a === b) {\n        return -1;\n    }\n    return Math.max(a.length, b.length);\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    "
    },
    {
        "id": 506,
        "title": "Contiguous Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a binary array `nums`, return _the maximum length of a contiguous subarray with an equal number of_ `0` _and_ `1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** \\[0, 1\\] is the longest contiguous subarray with an equal number of 0 and 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,0\\]\n**Output:** 2\n**Explanation:** \\[0, 1\\] (or \\[1, 0\\]) is a longest contiguous subarray with equal number of 0 and 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[0,1]",
                "output": "2"
            },
            {
                "input": "[0,1,0]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int findMaxLength(int[] nums) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    counts.put(0, -1);\n    int max_len = 0, count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        count += (nums[i] == 1) ? 1 : -1;\n        if (counts.containsKey(count))\n            max_len = Math.max(max_len, i - counts.get(count));\n        else\n            counts.put(count, i);\n    }\n    return max_len;\n}\n```\n\n    \n    This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present.\n    ",
        "python": "\n    ```python\ndef findMaxLength(nums):\n    counts = {0: -1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counts:\n            max_len = max(max_len, i - counts[count])\n        else:\n            counts[count] = i\n    return max_len\n```\n    \n    This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present.\n    ",
        "c++": "\n    ```cpp\nint findMaxLength(vector<int>& nums) {\n    unordered_map<int, int> counts;\n    counts[0] = -1;\n    int max_len = 0, count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        count += (nums[i] == 1) ? 1 : -1;\n        if (counts.count(count))\n            max_len = max(max_len, i - counts[count]);\n        else\n            counts[count] = i;\n    }\n    return max_len;\n}\n```\n    \n    This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present.\n    ",
        "js": "\n    ```javascript\nfunction findMaxLength(nums) {\n    let counts = new Map();\n    counts.set(0, -1);\n    let max_len = 0, count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        count += (nums[i] === 1) ? 1 : -1;\n        if (counts.has(count))\n            max_len = Math.max(max_len, i - counts.get(count));\n        else\n            counts.set(count, i);\n    }\n    return max_len;\n}\n```\n    \n    This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present.\n    "
    },
    {
        "id": 512,
        "title": "Lonely Pixel I",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position where the same row and same column don't have **any other** black pixels.",
            "examples": [
                "**Example 1:**\n\n**Input:** picture = \\[\\[ \"W \", \"W \", \"B \"\\],\\[ \"W \", \"B \", \"W \"\\],\\[ \"B \", \"W \", \"W \"\\]\\]\n**Output:** 3\n**Explanation:** All the three 'B's are black lonely pixels.\n\n",
                "**Example 2:**\n\n**Input:** picture = \\[\\[ \"B \", \"B \", \"B \"\\],\\[ \"B \", \"B \", \"W \"\\],\\[ \"B \", \"B \", \"B \"\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == picture.length`\n*   `n == picture[i].length`\n*   `1 <= m, n <= 500`\n*   `picture[i][j]` is `'W'` or `'B'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"W\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"W\"]]",
                "output": "3"
            },
            {
                "input": "[[\"B\",\"B\",\"B\"],[\"B\",\"B\",\"W\"],[\"B\",\"B\",\"B\"]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int findLonelyPixel(char[][] picture) {\n    int m = picture.length, n = picture[0].length;\n    int[] row = new int[m], col = new int[n];\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "python": "\n    ```python\ndef findLonelyPixel(picture):\n    m, n = len(picture), len(picture[0])\n    row, col = [0] * m, [0] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row[i] += 1\n                col[j] += 1\n                \n    lonely = 0\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:\n                lonely += 1\n                \n    return lonely\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "c++": "\n    ```cpp\nint findLonelyPixel(vector<vector<char>>& picture) {\n    int m = picture.size(), n = picture[0].size();\n    vector<int> row(m, 0), col(n, 0);\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "js": "\n    ```javascript\nfunction findLonelyPixel(picture) {\n    let m = picture.length, n = picture[0].length;\n    let row = new Array(m).fill(0), col = new Array(n).fill(0);\n    \n    for(let i = 0; i < m; ++i) {\n        for(let j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    let lonely = 0;\n    for(let i = 0; i < m; ++i) {\n        for(let j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    "
    },
    {
        "id": 515,
        "title": "Encode and Decode TinyURL",
        "difficulty": "Medium",
        "content": {
            "problem": "> Note: This is a companion problem to the [System Design](https://leetcode.com/discuss/interview-question/system-design/) problem: [Design TinyURL](https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/).\n\nTinyURL is a URL shortening service where you enter a URL such as `https://leetcode.com/problems/design-tinyurl` and it returns a short URL such as `http://tinyurl.com/4e9iAk`. Design a class to encode a URL and decode a tiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\nImplement the `Solution` class:\n\n*   `Solution()` Initializes the object of the system.\n*   `String encode(String longUrl)` Returns a tiny URL for the given `longUrl`.\n*   `String decode(String shortUrl)` Returns the original long URL for the given `shortUrl`. It is guaranteed that the given `shortUrl` was encoded by the same object.",
            "examples": [
                "**Example 1:**\n\n**Input:** url =  \"https://leetcode.com/problems/design-tinyurl \"\n**Output:**  \"https://leetcode.com/problems/design-tinyurl \"\n\n**Explanation:**\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= url.length <= 104`\n*   `url` is guranteed to be a valid URL.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Design",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"https://leetcode.com/problems/design-tinyurl\"",
                "output": "\"https://leetcode.com/problems/design-tinyurl\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Random;\n\npublic class Solution {\n    HashMap<String, String> urlMap = new HashMap<>();\n    String alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    public String encode(String longUrl) {\n        StringBuilder keyBuilder;\n        String key;\n\n        do {\n            keyBuilder = new StringBuilder();\n\n            for (int i = 0; i < 6; i++) {\n                keyBuilder.append(alphabet.charAt(new Random().nextInt(alphabet.length())));\n            }\n\n            key = keyBuilder.toString();\n        } while (urlMap.containsKey(key));\n\n        urlMap.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return urlMap.get(shortUrl.substring(19));\n    }\n}\n```\n    \n    The algorithm generates a random 6-character key using a combination of lowercase, uppercase letters, and digits. It then checks if the generated key already exists in the mapping. If not, it adds the long URL and its corresponding key into the mapping. The shortened URL is created by appending the key to a fixed base URL (e.g., \"http://tinyurl.com/\"). When decoding, it obtains the key from the given shortened URL and looks up the original long URL from the mapping. This algorithm ensures that every long URL has its unique shortened URL, and it's capable of encoding and decoding URLs successfully.\n    ",
        "python": "\n    ```python\nimport random\nimport string\n\nclass Solution:\n    def __init__(self):\n        self.url_map = {}\n        self.alphabet = string.ascii_letters + string.digits\n\n    def encode(self, longUrl: str) -> str:\n        key = ''.join(random.choices(self.alphabet, k=6))\n\n        while key in self.url_map:\n            key = ''.join(random.choices(self.alphabet, k=6))\n\n        self.url_map[key] = longUrl\n        return \"http://tinyurl.com/\" + key\n\n    def decode(self, shortUrl: str) -> str:\n        return self.url_map[shortUrl[-6:]]\n```\n    \n    The algorithm generates a random 6-character key using a combination of lowercase, uppercase letters, and digits. It then checks if the generated key already exists in the mapping. If not, it adds the long URL and its corresponding key into the mapping. The shortened URL is created by appending the key to a fixed base URL (e.g., \"http://tinyurl.com/\"). When decoding, it obtains the key from the given shortened URL and looks up the original long URL from the mapping. This algorithm ensures that every long URL has its unique shortened URL, and it's capable of encoding and decoding URLs successfully.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\n#include <random>\n\nclass Solution {\npublic:\n    std::unordered_map<std::string, std::string> map;\n    std::string alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    // Encodes a URL to a shortened URL.\n    std::string encode(std::string longUrl) {\n        std::string key;\n        while (true) {\n            key.clear();\n            for (int i = 0; i < 6; i++) {\n                key += alphabet[rand() % alphabet.length()];\n            }\n            if (map.count(key) == 0) {\n                map[key] = longUrl;\n                break;\n            }\n        }\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    std::string decode(std::string shortUrl) {\n        return map[shortUrl.substr(19, 6)];\n    }\n};\n```\n    \n    The algorithm generates a random 6-character key using a combination of lowercase, uppercase letters, and digits. It then checks if the generated key already exists in the mapping. If not, it adds the long URL and its corresponding key into the mapping. The shortened URL is created by appending the key to a fixed base URL (e.g., \"http://tinyurl.com/\"). When decoding, it obtains the key from the given shortened URL and looks up the original long URL from the mapping. This algorithm ensures that every long URL has its unique shortened URL, and it's capable of encoding and decoding URLs successfully.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    constructor() {\n        this.urlMap = new Map();\n        this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    }\n\n    encode(longUrl) {\n        let key;\n\n        do {\n            key = Array.from({ length: 6 }, () => this.alphabet.charAt(Math.floor(Math.random() * this.alphabet.length))).join('');\n        } while (this.urlMap.has(key));\n\n        this.urlMap.set(key, longUrl);\n\n        return 'http://tinyurl.com/' + key;\n    }\n\n    decode(shortUrl) {\n        return this.urlMap.get(shortUrl.substr(-6));\n    }\n}\n```\n    \n    The algorithm generates a random 6-character key using a combination of lowercase, uppercase letters, and digits. It then checks if the generated key already exists in the mapping. If not, it adds the long URL and its corresponding key into the mapping. The shortened URL is created by appending the key to a fixed base URL (e.g., \"http://tinyurl.com/\"). When decoding, it obtains the key from the given shortened URL and looks up the original long URL from the mapping. This algorithm ensures that every long URL has its unique shortened URL, and it's capable of encoding and decoding URLs successfully.\n    "
    },
    {
        "id": 517,
        "title": "Complex Number Multiplication",
        "difficulty": "Medium",
        "content": {
            "problem": "A [complex number](https://en.wikipedia.org/wiki/Complex_number) can be represented as a string on the form `\"**real**+**imaginary**i \"` where:\n\n*   `real` is the real part and is an integer in the range `[-100, 100]`.\n*   `imaginary` is the imaginary part and is an integer in the range `[-100, 100]`.\n*   `i2 == -1`.\n\nGiven two complex numbers `num1` and `num2` as strings, return _a string of the complex number that represents their multiplications_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 =  \"1+1i \", num2 =  \"1+1i \"\n**Output:**  \"0+2i \"\n**Explanation:** (1 + i) \\* (1 + i) = 1 + i2 + 2 \\* i = 2i, and you need convert it to the form of 0+2i.\n\n",
                "**Example 2:**\n\n**Input:** num1 =  \"1+-1i \", num2 =  \"1+-1i \"\n**Output:**  \"0+-2i \"\n**Explanation:** (1 - i) \\* (1 - i) = 1 + i2 - 2 \\* i = -2i, and you need convert it to the form of 0+-2i."
            ],
            "constraints": "**Constraints:**\n\n*   `num1` and `num2` are valid complex numbers.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"1+1i\",\"1+1i\"",
                "output": "\"0+2i\""
            },
            {
                "input": "\"1+-1i\",\"1+-1i\"",
                "output": "\"0+-2i\""
            }
        ],
        "java": "\n    ```java\npublic String complexNumberMultiply(String num1, String num2) {\n    String[] tokens1 = num1.split(\"\\\\+|i\");\n    String[] tokens2 = num2.split(\"\\\\+|i\");\n    int real1 = Integer.parseInt(tokens1[0]);\n    int imag1 = Integer.parseInt(tokens1[1]);\n    int real2 = Integer.parseInt(tokens2[0]);\n    int imag2 = Integer.parseInt(tokens2[1]);\n\n    int real = real1 * real2 - imag1 * imag2;\n    int imag = real1 * imag2 + real2 * imag1;\n\n    return real + \"+\" + imag + \"i\";\n}\n```\n    \n    The algorithm first extracts the real and imaginary parts of the input complex numbers. In C++, sscanf is used to read formatted data from a string. In Java, we use split with a regex that matches both \"+\" and \"i\". In Python and JavaScript, we use split and map for the conversions.\n\nOnce we have real and imaginary parts of both numbers, we multiply the complex numbers using the formula:\n(real1 * real2 - imag1 * imag2) + (real1 * imag2 + real2 * imag1)i\n\nFinally, we convert the result into a string in the required format and return it.\n    ",
        "python": "\n    ```python\ndef complexNumberMultiply(num1: str, num2: str) -> str:\n    real1, imag1 = map(int, num1[:-1].split('+'))\n    real2, imag2 = map(int, num2[:-1].split('+'))\n\n    real = real1 * real2 - imag1 * imag2\n    imag = real1 * imag2 + real2 * imag1\n\n    return f\"{real}+{imag}i\"\n```\n    \n    The algorithm first extracts the real and imaginary parts of the input complex numbers. In C++, sscanf is used to read formatted data from a string. In Java, we use split with a regex that matches both \"+\" and \"i\". In Python and JavaScript, we use split and map for the conversions.\n\nOnce we have real and imaginary parts of both numbers, we multiply the complex numbers using the formula:\n(real1 * real2 - imag1 * imag2) + (real1 * imag2 + real2 * imag1)i\n\nFinally, we convert the result into a string in the required format and return it.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n\nstd::string complexNumberMultiply(std::string num1, std::string num2) {\n    int real1, imag1, real2, imag2;\n    sscanf(num1.c_str(), \"%d+%di\", &real1, &imag1);\n    sscanf(num2.c_str(), \"%d+%di\", &real2, &imag2);\n   \n    int real = real1 * real2 - imag1 * imag2;\n    int imag = real1 * imag2 + real2 * imag1;\n   \n    return std::to_string(real) + \"+\" + std::to_string(imag) + \"i\";\n}\n```\n    \n    The algorithm first extracts the real and imaginary parts of the input complex numbers. In C++, sscanf is used to read formatted data from a string. In Java, we use split with a regex that matches both \"+\" and \"i\". In Python and JavaScript, we use split and map for the conversions.\n\nOnce we have real and imaginary parts of both numbers, we multiply the complex numbers using the formula:\n(real1 * real2 - imag1 * imag2) + (real1 * imag2 + real2 * imag1)i\n\nFinally, we convert the result into a string in the required format and return it.\n    ",
        "js": "\n    ```javascript\nfunction complexNumberMultiply(num1, num2) {\n    const [real1, imag1] = num1.slice(0, -1).split('+').map(Number);\n    const [real2, imag2] = num2.slice(0, -1).split('+').map(Number);\n\n    const real = real1 * real2 - imag1 * imag2;\n    const imag = real1 * imag2 + real2 * imag1;\n\n    return `${real}+${imag}i`;\n}\n```\n    \n    The algorithm first extracts the real and imaginary parts of the input complex numbers. In C++, sscanf is used to read formatted data from a string. In Java, we use split with a regex that matches both \"+\" and \"i\". In Python and JavaScript, we use split and map for the conversions.\n\nOnce we have real and imaginary parts of both numbers, we multiply the complex numbers using the formula:\n(real1 * real2 - imag1 * imag2) + (real1 * imag2 + real2 * imag1)i\n\nFinally, we convert the result into a string in the required format and return it.\n    "
    },
    {
        "id": 519,
        "title": "Minimum Time Difference",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a list of 24-hour clock time points in **\"HH:MM \"** format, return _the minimum **minutes** difference between any two time-points in the list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** timePoints = \\[\"23:59\",\"00:00\"\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** timePoints = \\[\"00:00\",\"23:59\",\"00:00\"\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= timePoints.length <= 2 * 104`\n*   `timePoints[i]` is in the format **\"HH:MM \"**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "[\"23:59\",\"00:00\"]",
                "output": "1"
            },
            {
                "input": "[\"00:00\",\"23:59\",\"00:00\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic int findMinDifference(List<String> timePoints) {\n    Collections.sort(timePoints);\n    int minDifference = Integer.MAX_VALUE;\n\n    for (int i = 0; i < timePoints.size(); ++i) {\n        int curDifference = Math.abs((Integer.parseInt(timePoints.get(i).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(i).substring(3, 5))) - (Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(3, 5))));\n        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}\n```\n    \n    1. Sort the given timePoints list.\n2. Initialize variable minDifference with the maximum value possible to keep track of the minimum difference.\n3. Loop through the timePoints list and for each pair of consecutive times (including the last time and the first time in the list):\n    - Calculate the absolute difference between the time in minutes.\n    - If the difference is greater than 720 (half of 1440 minutes in a day), take the complementary difference (i.e., 1440 - curDifference).\n    - Update the minDifference variable with the minimum of the previous minDifference and the calculated difference.\n4. After the loop, the minDifference variable will hold the minimum minutes difference between any two time-points in the list. Return it.\n    ",
        "python": "\n    ```python\ndef findMinDifference(timePoints):\n    timePoints.sort()\n    min_difference = float('inf')\n\n    for i in range(len(timePoints)):\n        h1, m1 = map(int, timePoints[i].split(':'))\n        h2, m2 = map(int, timePoints[(i+1)%len(timePoints)].split(':'))\n        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))\n        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)\n\n    return min_difference\n```\n    \n    1. Sort the given timePoints list.\n2. Initialize variable minDifference with the maximum value possible to keep track of the minimum difference.\n3. Loop through the timePoints list and for each pair of consecutive times (including the last time and the first time in the list):\n    - Calculate the absolute difference between the time in minutes.\n    - If the difference is greater than 720 (half of 1440 minutes in a day), take the complementary difference (i.e., 1440 - curDifference).\n    - Update the minDifference variable with the minimum of the previous minDifference and the calculated difference.\n4. After the loop, the minDifference variable will hold the minimum minutes difference between any two time-points in the list. Return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nint findMinDifference(std::vector<std::string>& timePoints) {\n    std::sort(timePoints.begin(), timePoints.end());\n    int minDifference = INT_MAX;\n\n    for (int i = 0; i < timePoints.size(); ++i) {\n        int curDifference = abs((stoi(timePoints[i].substr(0, 2)) * 60 + stoi(timePoints[i].substr(3, 2))) - (stoi(timePoints[(i + 1) % timePoints.size()].substr(0, 2)) * 60 + stoi(timePoints[(i + 1) % timePoints.size()].substr(3, 2))));\n        minDifference = std::min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}\n```\n    \n    1. Sort the given timePoints list.\n2. Initialize variable minDifference with the maximum value possible to keep track of the minimum difference.\n3. Loop through the timePoints list and for each pair of consecutive times (including the last time and the first time in the list):\n    - Calculate the absolute difference between the time in minutes.\n    - If the difference is greater than 720 (half of 1440 minutes in a day), take the complementary difference (i.e., 1440 - curDifference).\n    - Update the minDifference variable with the minimum of the previous minDifference and the calculated difference.\n4. After the loop, the minDifference variable will hold the minimum minutes difference between any two time-points in the list. Return it.\n    ",
        "js": "\n    ```javascript\nfunction findMinDifference(timePoints) {\n    timePoints.sort();\n    let minDifference = Infinity;\n\n    for (let i = 0; i < timePoints.length; ++i) {\n        const [h1, m1] = timePoints[i].split(':').map(Number);\n        const [h2, m2] = timePoints[(i + 1) % timePoints.length].split(':').map(Number);\n        const curDifference = Math.abs((h1 * 60 + m1) - (h2 * 60 + m2));\n        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}\n```\n    \n    1. Sort the given timePoints list.\n2. Initialize variable minDifference with the maximum value possible to keep track of the minimum difference.\n3. Loop through the timePoints list and for each pair of consecutive times (including the last time and the first time in the list):\n    - Calculate the absolute difference between the time in minutes.\n    - If the difference is greater than 720 (half of 1440 minutes in a day), take the complementary difference (i.e., 1440 - curDifference).\n    - Update the minDifference variable with the minimum of the previous minDifference and the calculated difference.\n4. After the loop, the minDifference variable will hold the minimum minutes difference between any two time-points in the list. Return it.\n    "
    },
    {
        "id": 520,
        "title": "Single Element in a Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn _the single element that appears only once_.\n\nYour solution must run in `O(log n)` time and `O(1)` space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2,3,3,4,4,8,8\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,3,7,7,10,11,11\\]\n**Output:** 10"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[1,1,2,3,3,4,4,8,8]",
                "output": "2"
            },
            {
                "input": "[3,3,7,7,10,11,11]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int singleNonDuplicate(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (mid % 2 == 1)\n            mid--;\n        if (nums[mid] == nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}\n```\n    \n    The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element.\n    ",
        "python": "\n    ```python\ndef singleNonDuplicate(nums):\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]\n```\n    \n    The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element.\n    ",
        "c++": "\n    ```cpp\nint singleNonDuplicate(vector<int>& nums) {\n    int low = 0, high = nums.size() - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (mid % 2 == 1)\n            mid--;\n        if (nums[mid] == nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}\n```\n    \n    The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element.\n    ",
        "js": "\n    ```javascript\nfunction singleNonDuplicate(nums) {\n    let low = 0, high = nums.length - 1;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (mid % 2 === 1)\n            mid--;\n        if (nums[mid] === nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}\n```\n    \n    The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element.\n    "
    },
    {
        "id": 521,
        "title": "Reverse String II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.\n\nIf there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abcdefg\", k = 2\n**Output:** \"bacdfeg\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\", k = 2\n**Output:** \"bacd\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"abcdefg\",2",
                "output": "\"bacdfeg\""
            },
            {
                "input": "\"abcd\",2",
                "output": "\"bacd\""
            }
        ],
        "java": "\n    ```java\npublic String reverseStr(String s, int k) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i += 2 * k) {\n        int left = i;\n        int right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            char temp = chars[left];\n            chars[left++] = chars[right];\n            chars[right--] = temp;\n        }\n    }\n    return new String(chars);\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "python": "\n    ```python\ndef reverseStr(s, k):\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        chars[i:i + k] = reversed(chars[i:i + k])\n    return \"\".join(chars)\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring reverseStr(string s, int k) {\n    for (int i = 0; i < s.size(); i += 2*k) {\n        if (i + k <= s.size()) {\n            reverse(s.begin() + i, s.begin() + i + k);\n        } else {\n            reverse(s.begin() + i, s.end());\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "js": "\n    ```javascript\nfunction reverseStr(s, k) {\n    let chars = s.split(\"\");\n    for (let i = 0; i < chars.length; i += 2 * k) {\n        let left = i;\n        let right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            [chars[left++], chars[right--]] = [chars[right], chars[left]];\n        }\n    }\n    return chars.join(\"\");\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    "
    },
    {
        "id": 527,
        "title": "Number of Provinces",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.\n\nA **province** is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.\n\nReturn _the total number of **provinces**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** isConnected = \\[\\[1,1,0\\],\\[1,1,0\\],\\[0,0,1\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** isConnected = \\[\\[1,0,0\\],\\[0,1,0\\],\\[0,0,1\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n == isConnected.length`\n*   `n == isConnected[i].length`\n*   `isConnected[i][j]` is `1` or `0`.\n*   `isConnected[i][i] == 1`\n*   `isConnected[i][j] == isConnected[j][i]`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "[[1,1,0],[1,1,0],[0,0,1]]",
                "output": "2"
            },
            {
                "input": "[[1,0,0],[0,1,0],[0,0,1]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findCircleNum(int[][] isConnected) {\n    int provinces = 0;\n    boolean[] visited = new boolean[isConnected.length];\n    for (int i = 0; i < isConnected.length; i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n\nprivate void dfs(int[][] isConnected, boolean[] visited, int i) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.length; j++) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, visited, j);\n        }\n    }\n}\n```\n    \n    We can solve this problem by using Depth First Search (DFS) to traverse the graph of cities:\n\n1. Create a boolean array `visited` of size n (the number of cities) initialized with `false` values.\n2. Initialize a counter variable `provinces` to count the number of provinces and set it to 0.\n3. Iterate through each city from 0 to n-1.\n   - If the city has not been visited, call a DFS helper function to traverse the connected components.\n   - Increment the `provinces` counter for every new group of connected cities.\n4. In the DFS helper function, mark the given city `i` as visited.\n5. Iterate through all other cities from 0 to n-1.\n   - If the cities `i` and `j` are directly connected (isConnected[i][j] == 1) and city `j` has not been visited, call the DFS helper function with city `j`.\n6. Return the total number of provinces.\n\nThis algorithm ensures that all directly and indirectly connected cities are visited, and their connected components are counted as provinces. The time complexity of this algorithm is O(n^2) as in the worst case, we might have to visit all possible edge connections between cities.\n    ",
        "python": "\n    ```python\ndef findCircleNum(isConnected):\n    def dfs(isConnected, visited, i):\n        visited[i] = True\n        for j in range(len(isConnected)):\n            if isConnected[i][j] == 1 and not visited[j]:\n                dfs(isConnected, visited, j)\n\n    provinces = 0\n    visited = [False] * len(isConnected)\n    for i in range(len(isConnected)):\n        if not visited[i]:\n            dfs(isConnected, visited, i)\n            provinces += 1\n    return provinces\n```\n    \n    We can solve this problem by using Depth First Search (DFS) to traverse the graph of cities:\n\n1. Create a boolean array `visited` of size n (the number of cities) initialized with `false` values.\n2. Initialize a counter variable `provinces` to count the number of provinces and set it to 0.\n3. Iterate through each city from 0 to n-1.\n   - If the city has not been visited, call a DFS helper function to traverse the connected components.\n   - Increment the `provinces` counter for every new group of connected cities.\n4. In the DFS helper function, mark the given city `i` as visited.\n5. Iterate through all other cities from 0 to n-1.\n   - If the cities `i` and `j` are directly connected (isConnected[i][j] == 1) and city `j` has not been visited, call the DFS helper function with city `j`.\n6. Return the total number of provinces.\n\nThis algorithm ensures that all directly and indirectly connected cities are visited, and their connected components are counted as provinces. The time complexity of this algorithm is O(n^2) as in the worst case, we might have to visit all possible edge connections between cities.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nusing std::vector;\n\nvoid dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.size(); j++) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, visited, j);\n        }\n    }\n}\n\nint findCircleNum(vector<vector<int>>& isConnected) {\n    int provinces = 0;\n    vector<bool> visited(isConnected.size(), false);\n    for (int i = 0; i < isConnected.size(); i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n```\n    \n    We can solve this problem by using Depth First Search (DFS) to traverse the graph of cities:\n\n1. Create a boolean array `visited` of size n (the number of cities) initialized with `false` values.\n2. Initialize a counter variable `provinces` to count the number of provinces and set it to 0.\n3. Iterate through each city from 0 to n-1.\n   - If the city has not been visited, call a DFS helper function to traverse the connected components.\n   - Increment the `provinces` counter for every new group of connected cities.\n4. In the DFS helper function, mark the given city `i` as visited.\n5. Iterate through all other cities from 0 to n-1.\n   - If the cities `i` and `j` are directly connected (isConnected[i][j] == 1) and city `j` has not been visited, call the DFS helper function with city `j`.\n6. Return the total number of provinces.\n\nThis algorithm ensures that all directly and indirectly connected cities are visited, and their connected components are counted as provinces. The time complexity of this algorithm is O(n^2) as in the worst case, we might have to visit all possible edge connections between cities.\n    ",
        "js": "\n    ```javascript\nfunction findCircleNum(isConnected) {\n    function dfs(isConnected, visited, i) {\n        visited[i] = true;\n        for (let j = 0; j < isConnected.length; j++) {\n            if (isConnected[i][j] === 1 && !visited[j]) {\n                dfs(isConnected, visited, j);\n            }\n        }\n    }\n\n    let provinces = 0;\n    const visited = new Array(isConnected.length).fill(false);\n    for (let i = 0; i < isConnected.length; i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n```\n    \n    We can solve this problem by using Depth First Search (DFS) to traverse the graph of cities:\n\n1. Create a boolean array `visited` of size n (the number of cities) initialized with `false` values.\n2. Initialize a counter variable `provinces` to count the number of provinces and set it to 0.\n3. Iterate through each city from 0 to n-1.\n   - If the city has not been visited, call a DFS helper function to traverse the connected components.\n   - Increment the `provinces` counter for every new group of connected cities.\n4. In the DFS helper function, mark the given city `i` as visited.\n5. Iterate through all other cities from 0 to n-1.\n   - If the cities `i` and `j` are directly connected (isConnected[i][j] == 1) and city `j` has not been visited, call the DFS helper function with city `j`.\n6. Return the total number of provinces.\n\nThis algorithm ensures that all directly and indirectly connected cities are visited, and their connected components are counted as provinces. The time complexity of this algorithm is O(n^2) as in the worst case, we might have to visit all possible edge connections between cities.\n    "
    },
    {
        "id": 532,
        "title": "Optimal Division",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums`. The adjacent integers in `nums` will perform the float division.\n\n*   For example, for `nums = [2,3,4]`, we will evaluate the expression `\"2/3/4 \"`.\n\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n\nReturn _the corresponding expression that has the maximum value in string format_.\n\n**Note:** your expression should not contain redundant parenthesis.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1000,100,10,2\\]\n**Output:**  \"1000/(100/10/2) \"\n**Explanation:** 1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in  \"1000/(**(**100/10**)**/2) \" are redundant since they do not influence the operation priority.\nSo you should return  \"1000/(100/10/2) \".\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,4\\]\n**Output:**  \"2/(3/4) \"\n**Explanation:** (2/(3/4)) = 8/3 = 2.667\nIt can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `2 <= nums[i] <= 1000`\n*   There is only one optimal division for the given input.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1000,100,10,2]",
                "output": "\"1000/(100/10/2)\""
            },
            {
                "input": "[2,3,4]",
                "output": "\"2/(3/4)\""
            }
        ],
        "java": "\n    ```java\npublic String optimalDivision(int[] nums) {\n    int n = nums.length;\n    if (n == 1) return Integer.toString(nums[0]);\n    if (n == 2) return Integer.toString(nums[0]) + \"/\" + Integer.toString(nums[1]);\n    StringBuilder res = new StringBuilder(Integer.toString(nums[0]) + \"/(\");\n    for (int i = 1; i < n - 1; ++i) {\n        res.append(Integer.toString(nums[i])).append(\"/\");\n    }\n    res.append(Integer.toString(nums[n - 1])).append(\")\");\n    return res.toString();\n}\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ",
        "python": "\n    ```python\ndef optimal_division(nums):\n    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n    return res\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string optimalDivision(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 1) return std::to_string(nums[0]);\n    if (n == 2) return std::to_string(nums[0]) + \"/\" + std::to_string(nums[1]);\n    std::string res = std::to_string(nums[0]) + \"/(\";\n    for (int i = 1; i < n - 1; ++i) {\n        res += std::to_string(nums[i]) + \"/\";\n    }\n    res += std::to_string(nums[n - 1]) + \")\";\n    return res;\n}\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    ",
        "js": "\n    ```javascript\nfunction optimalDivision(nums) {\n    const n = nums.length;\n    if (n === 1) return nums[0].toString();\n    if (n === 2) return nums[0].toString() + '/' + nums[1].toString();\n    let res = nums[0].toString() + '/(';\n    for (let i = 1; i < n - 1; ++i) {\n        res += nums[i].toString() + '/';\n    }\n    res += nums[n - 1].toString() + ')';\n    return res;\n}\n```\n\n    \n    The key to maximizing the result of the division expression is to minimize the divisors by grouping them together in parentheses. Since we want the entire array of numbers divided by the smallest possible divisor, we essentially want to maximize the division by ensuring the numbers in the array are divided by each other in sequence, from left to right.\n\nThe algorithm goes as follows:\n1. If there's only one number, return that number.\n2. If there are two numbers, a and b, just return \"a/b\" as the division expression.\n3. For three or more numbers, create a string with the first number followed by \"/(\".\n4. Iterate through the rest of the numbers, adding each number to the string followed by a \"/\". Stop at the second-to-last number in the array.\n5. Add the very last number to the string followed by a closing parenthesis.\n6. Return the constructed string.\n\nThis way, we get the maximum value for the division operation.\n    "
    },
    {
        "id": 539,
        "title": "Subarray Sum Equals K",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `nums` and an integer `k`, return _the total number of subarrays whose sum equals to_ `k`.\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,1\\], k = 2\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\], k = 3\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-1000 <= nums[i] <= 1000`\n*   `-107 <= k <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,1,1],2",
                "output": "2"
            },
            {
                "input": "[1,2,3],3",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int subarraySum(int[] nums, int k) {\n    Map<Integer, Integer> prefixSumFrequency = new HashMap<>();\n    prefixSumFrequency.put(0, 1);\n    int prefixSum = 0, result = 0;\n    \n    for (int num : nums) {\n        prefixSum += num;\n        result += prefixSumFrequency.getOrDefault(prefixSum - k, 0);\n        prefixSumFrequency.put(prefixSum, prefixSumFrequency.getOrDefault(prefixSum, 0) + 1);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm utilizes a hash map to store the frequency of the prefix sum up to the current element in the array. We start by initializing the hash map with a key-value pair (0, 1), which represents the empty subarray sum. Then we iterate through the input array, updating the prefix sum and result.\n\nFor each element in the array, we increment the prefix sum by the value of the element. We then increment the result by the value of the key (prefix sum - k) in the hash map, using a default value of 0 if the key is not found. This represents the number of subarrays ending at the current index with the sum equal to k. Finally, we increment the value of the prefix sum key in the hash map.\n\nThe time complexity of the algorithm is O(n), where n is the length of the input array. This is because we iterate through the array once and perform constant time operations for each element. The space complexity is O(n), which comes from using the hash map to store frequency of prefix sums.\n    ",
        "python": "\n    ```python\ndef subarraySum(nums, k):\n    prefix_sum_frequency = {0: 1}\n    prefix_sum, result = 0, 0\n    \n    for num in nums:\n        prefix_sum += num\n        result += prefix_sum_frequency.get(prefix_sum - k, 0)\n        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1\n\n    return result\n```\n    \n    The algorithm utilizes a hash map to store the frequency of the prefix sum up to the current element in the array. We start by initializing the hash map with a key-value pair (0, 1), which represents the empty subarray sum. Then we iterate through the input array, updating the prefix sum and result.\n\nFor each element in the array, we increment the prefix sum by the value of the element. We then increment the result by the value of the key (prefix sum - k) in the hash map, using a default value of 0 if the key is not found. This represents the number of subarrays ending at the current index with the sum equal to k. Finally, we increment the value of the prefix sum key in the hash map.\n\nThe time complexity of the algorithm is O(n), where n is the length of the input array. This is because we iterate through the array once and perform constant time operations for each element. The space complexity is O(n), which comes from using the hash map to store frequency of prefix sums.\n    ",
        "c++": "\n    ```cpp\nint subarraySum(vector<int>& nums, int k) {\n    unordered_map<int, int> prefixSumFrequency;\n    prefixSumFrequency[0] = 1;\n    int prefixSum = 0, result = 0;\n    \n    for (int num : nums) {\n        prefixSum += num;\n        result += prefixSumFrequency[prefixSum - k];\n        prefixSumFrequency[prefixSum]++;\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm utilizes a hash map to store the frequency of the prefix sum up to the current element in the array. We start by initializing the hash map with a key-value pair (0, 1), which represents the empty subarray sum. Then we iterate through the input array, updating the prefix sum and result.\n\nFor each element in the array, we increment the prefix sum by the value of the element. We then increment the result by the value of the key (prefix sum - k) in the hash map, using a default value of 0 if the key is not found. This represents the number of subarrays ending at the current index with the sum equal to k. Finally, we increment the value of the prefix sum key in the hash map.\n\nThe time complexity of the algorithm is O(n), where n is the length of the input array. This is because we iterate through the array once and perform constant time operations for each element. The space complexity is O(n), which comes from using the hash map to store frequency of prefix sums.\n    ",
        "js": "\n    ```javascript\nfunction subarraySum(nums, k) {\n    const prefixSumFrequency = {0: 1};\n    let prefixSum = 0, result = 0;\n    \n    for (const num of nums) {\n        prefixSum += num;\n        result += (prefixSumFrequency[prefixSum - k] || 0);\n        prefixSumFrequency[prefixSum] = (prefixSumFrequency[prefixSum] || 0) + 1;\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm utilizes a hash map to store the frequency of the prefix sum up to the current element in the array. We start by initializing the hash map with a key-value pair (0, 1), which represents the empty subarray sum. Then we iterate through the input array, updating the prefix sum and result.\n\nFor each element in the array, we increment the prefix sum by the value of the element. We then increment the result by the value of the key (prefix sum - k) in the hash map, using a default value of 0 if the key is not found. This represents the number of subarrays ending at the current index with the sum equal to k. Finally, we increment the value of the prefix sum key in the hash map.\n\nThe time complexity of the algorithm is O(n), where n is the length of the input array. This is because we iterate through the array once and perform constant time operations for each element. The space complexity is O(n), which comes from using the hash map to store frequency of prefix sums.\n    "
    },
    {
        "id": 544,
        "title": "Array Nesting",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` of length `n` where `nums` is a permutation of the numbers in the range `[0, n - 1]`.\n\nYou should build a set `s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }` subjected to the following rule:\n\n*   The first element in `s[k]` starts with the selection of the element `nums[k]` of `index = k`.\n*   The next element in `s[k]` should be `nums[nums[k]]`, and then `nums[nums[nums[k]]]`, and so on.\n*   We stop adding right before a duplicate element occurs in `s[k]`.\n\nReturn _the longest length of a set_ `s[k]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,4,0,3,1,6,2\\]\n**Output:** 4\n**Explanation:** \nnums\\[0\\] = 5, nums\\[1\\] = 4, nums\\[2\\] = 0, nums\\[3\\] = 3, nums\\[4\\] = 1, nums\\[5\\] = 6, nums\\[6\\] = 2.\nOne of the longest sets s\\[k\\]:\ns\\[0\\] = {nums\\[0\\], nums\\[5\\], nums\\[6\\], nums\\[2\\]} = {5, 6, 2, 0}\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,2\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] < nums.length`\n*   All the values of `nums` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search"
        ],
        "example": [
            {
                "input": "[5,4,0,3,1,6,2]",
                "output": "4"
            },
            {
                "input": "[0,1,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int arrayNesting(int[] nums) {\n    int n = nums.length;\n    int max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != -1) {       \n            int start = nums[i];\n            int count = 0;\n            while (nums[start] != -1) {\n                int temp = start;\n                start = nums[start];\n                count++;\n                nums[temp]=-1;\n            }\n            max_len = Math.max(max_len, count);\n        }\n    }\n    return max_len;\n}\n```\n    \n    This algorithm iterates through the given `nums` array. During the iteration, when the current element `nums[i]` is not equal to -1, it initializes a new set by setting `start` to `nums[i]` and sets the `count` to 0. Then, in the inner while loop, it keeps following the chain as described in the problem statement and sets the visited element to -1. After completing the chain for the current element, it calculates the maximum length found so far and assigns it to `max_len`. This process is repeated for all elements in the `nums` array. Finally, the algorithm returns the longest length of a set `s[k]` found.\n    ",
        "python": "\n    ```python\ndef arrayNesting(nums):\n    n = len(nums)\n    max_len = 0\n    for i in range(n):\n        if nums[i] != -1:\n            start = nums[i]\n            count = 0\n            while nums[start] != -1:\n                temp = start\n                start = nums[start]\n                count += 1\n                nums[temp] = -1\n            max_len = max(max_len, count)\n    return max_len\n```\n    \n    This algorithm iterates through the given `nums` array. During the iteration, when the current element `nums[i]` is not equal to -1, it initializes a new set by setting `start` to `nums[i]` and sets the `count` to 0. Then, in the inner while loop, it keeps following the chain as described in the problem statement and sets the visited element to -1. After completing the chain for the current element, it calculates the maximum length found so far and assigns it to `max_len`. This process is repeated for all elements in the `nums` array. Finally, the algorithm returns the longest length of a set `s[k]` found.\n    ",
        "c++": "\n    ```cpp\nint arrayNesting(vector<int>& nums) {\n    int n = nums.size();\n    int max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != -1) {       \n            int start = nums[i];\n            int count = 0;\n            while (nums[start] != -1) {\n                int temp = start;\n                start = nums[start];\n                count++;\n                nums[temp]=-1;\n            }\n            max_len = max(max_len, count);\n        }\n    }\n    return max_len;\n}\n```\n    \n    This algorithm iterates through the given `nums` array. During the iteration, when the current element `nums[i]` is not equal to -1, it initializes a new set by setting `start` to `nums[i]` and sets the `count` to 0. Then, in the inner while loop, it keeps following the chain as described in the problem statement and sets the visited element to -1. After completing the chain for the current element, it calculates the maximum length found so far and assigns it to `max_len`. This process is repeated for all elements in the `nums` array. Finally, the algorithm returns the longest length of a set `s[k]` found.\n    ",
        "js": "\n    ```javascript\nfunction arrayNesting(nums) {\n    let n = nums.length;\n    let max_len = 0;\n    for (let i = 0; i < n; ++i) {\n        if (nums[i] !== -1) {       \n            let start = nums[i];\n            let count = 0;\n            while (nums[start] !== -1) {\n                let temp = start;\n                start = nums[start];\n                count++;\n                nums[temp] = -1;\n            }\n            max_len = Math.max(max_len, count);\n        }\n    }\n    return max_len;\n}\n```\n    \n    This algorithm iterates through the given `nums` array. During the iteration, when the current element `nums[i]` is not equal to -1, it initializes a new set by setting `start` to `nums[i]` and sets the `count` to 0. Then, in the inner while loop, it keeps following the chain as described in the problem statement and sets the visited element to -1. After completing the chain for the current element, it calculates the maximum length found so far and assigns it to `max_len`. This process is repeated for all elements in the `nums` array. Finally, the algorithm returns the longest length of a set `s[k]` found.\n    "
    },
    {
        "id": 545,
        "title": "Reshape the Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "In MATLAB, there is a handy function called `reshape` which can reshape an `m x n` matrix into a new one with a different size `r x c` keeping its original data.\n\nYou are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix.\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\nIf the `reshape` operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,2\\],\\[3,4\\]\\], r = 1, c = 4\n**Output:** \\[\\[1,2,3,4\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,2\\],\\[3,4\\]\\], r = 2, c = 4\n**Output:** \\[\\[1,2\\],\\[3,4\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 100`\n*   `-1000 <= mat[i][j] <= 1000`\n*   `1 <= r, c <= 300`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[1,2],[3,4]],1,4",
                "output": "[[1,2,3,4]]"
            },
            {
                "input": "[[1,2],[3,4]],2,4",
                "output": "[[1,2],[3,4]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\n    int m = mat.length;\n    int n = mat[0].length;\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    int[][] reshaped = new int[r][c];\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n\n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "python": "\n    ```python\ndef matrixReshape(mat, r, c):\n    m, n = len(mat), len(mat[0])\n    if m * n != r * c:\n        return mat\n\n    reshaped = [[0] * c for _ in range(r)]\n    for i in range(m * n):\n        reshaped[i // c][i % c] = mat[i // n][i % n]\n\n    return reshaped\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\n    int m = mat.size();\n    int n = mat[0].size();\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    vector<vector<int>> reshaped(r, vector<int>(c));\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n    \n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "js": "\n    ```javascript\nfunction matrixReshape(mat, r, c) {\n    const m = mat.length;\n    const n = mat[0].length;\n    if (m * n !== r * c) {\n        return mat;\n    }\n\n    const reshaped = new Array(r).fill(null).map(() => new Array(c));\n    for (let i = 0; i < m * n; ++i) {\n        reshaped[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n];\n    }\n\n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    "
    },
    {
        "id": 552,
        "title": "Shortest Unsorted Continuous Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, you need to find one **continuous subarray** that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\n\nReturn _the shortest such subarray and output its length_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,6,4,8,10,9,15\\]\n**Output:** 5\n**Explanation:** You need to sort \\[6, 4, 8, 10, 9\\] in ascending order to make the whole array sorted in ascending order.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n\n**",
            "follow_up": "Follow up:** Can you solve it in `O(n)` time complexity?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Stack",
            "Greedy",
            "Sorting",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[2,6,4,8,10,9,15]",
                "output": "5"
            },
            {
                "input": "[1,2,3,4]",
                "output": "0"
            },
            {
                "input": "[1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findUnsortedSubarray(int[] nums) {\n    int[] sortedNums = nums.clone();\n    Arrays.sort(sortedNums);\n    int start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] == sortedNums[start]) start++;\n    while (end > start && nums[end] == sortedNums[end]) end--;\n    return end - start + 1;\n}\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ",
        "python": "\n    ```python\ndef findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    start, end = 0, len(nums) - 1\n    while start < len(nums) and nums[start] == sorted_nums[start]:\n        start += 1\n    while end > start and nums[end] == sorted_nums[end]:\n        end -= 1\n    return end - start + 1\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findUnsortedSubarray(vector<int>& nums) {\n    vector<int> sorted_nums(nums);\n    sort(sorted_nums.begin(), sorted_nums.end());\n    int start = 0, end = nums.size() - 1;\n    while (start < nums.size() && nums[start] == sorted_nums[start]) start++;\n    while (end > start && nums[end] == sorted_nums[end]) end--;\n    return end - start + 1;\n}\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    ",
        "js": "\n    ```javascript\nfunction findUnsortedSubarray(nums) {\n    const sortedNums = [...nums].sort((a, b) => a - b);\n    let start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] === sortedNums[start]) start++;\n    while (end > start && nums[end] === sortedNums[end]) end--;\n    return end - start + 1;\n}\n```\n    \n    1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`.\n    "
    },
    {
        "id": 554,
        "title": "Delete Operation for Two Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `word1` and `word2`, return _the minimum number of **steps** required to make_ `word1` _and_ `word2` _the same_.\n\nIn one **step**, you can delete exactly one character in either string.",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"sea \", word2 =  \"eat \"\n**Output:** 2\n**Explanation:** You need one step to make  \"sea \" to  \"ea \" and another step to make  \"eat \" to  \"ea \".\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"leetcode \", word2 =  \"etco \"\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"sea\",\"eat\"",
                "output": "2"
            },
            {
                "input": "\"leetcode\",\"etco\"",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m+1][n+1];\n\n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) == word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ",
        "python": "\n    ```python\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            elif word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ",
        "c++": "\n    ```cpp\nint minDistance(std::string word1, std::string word2) {\n    int m = word1.length(), n = word2.length();\n    std::vector<std::vector<int>> dp(m+1, std::vector<int>(n+1, 0));\n    \n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1[i-1] == word2[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + std::min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    ",
        "js": "\n    ```javascript\nfunction minDistance(word1, word2) {\n    let m = word1.length, n = word2.length;\n    let dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));\n\n    for(let i = 0; i <= m; i++) {\n        for(let j = 0; j <= n; j++) {\n            if(i === 0 || j === 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) === word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal.\n    "
    },
    {
        "id": 562,
        "title": "Longest Harmonious Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is **exactly** `1`.\n\nGiven an integer array `nums`, return _the length of its longest harmonious subsequence among all its possible subsequences_.\n\nA **subsequence** of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,2,5,2,3,7\\]\n**Output:** 5\n**Explanation:** The longest harmonious subsequence is \\[3,2,2,2,3\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,3,2,2,5,2,3,7]",
                "output": "5"
            },
            {
                "input": "[1,2,3,4]",
                "output": "2"
            },
            {
                "input": "[1,1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int findLHS(int[] nums) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    for (int num : nums)\n        count.put(num, count.getOrDefault(num, 0) + 1);\n\n    int longest_sequence = 0;\n    for (int key : count.keySet()) {\n        if (count.containsKey(key + 1))\n            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n    }\n    \n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "python": "\n    ```python\ndef findLHS(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    longest_sequence = 0\n    for key in count:\n        if key + 1 in count:\n            longest_sequence = max(longest_sequence, count[key] + count[key + 1])\n\n    return longest_sequence\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint findLHS(vector<int>& nums) {\n    unordered_map<int, int> count;\n    for (int num : nums)\n        count[num]++;\n    \n    int longest_sequence = 0;\n    for (auto &elem : count) {\n        if (count.find(elem.first + 1) != count.end())\n            longest_sequence = max(longest_sequence, elem.second + count[elem.first + 1]);\n    }\n    \n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "js": "\n    ```javascript\nfunction findLHS(nums) {\n    const count = new Map();\n    for (const num of nums) {\n        count.set(num, (count.get(num) || 0) + 1);\n    }\n\n    let longest_sequence = 0;\n    for (const key of count.keys()) {\n        if (count.has(key + 1)) {\n            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n        }\n    }\n\n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    "
    },
    {
        "id": 563,
        "title": "Range Addition II",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.\n\nCount and return _the number of maximum integers in the matrix after performing all the operations_.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 4\n**Explanation:** The maximum integer in M is 2, and there are four of it in M. So return 4.\n\n",
                "**Example 2:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\]\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** m = 3, n = 3, ops = \\[\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 4 * 104`\n*   `0 <= ops.length <= 104`\n*   `ops[i].length == 2`\n*   `1 <= ai <= m`\n*   `1 <= bi <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "3,3,[[2,2],[3,3]]",
                "output": "4"
            },
            {
                "input": "3,3,[[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]",
                "output": "4"
            },
            {
                "input": "3,3,[]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int maxCount(int m, int n, int[][] ops) {\n    for (int[] op : ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "python": "\n    ```python\ndef maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint maxCount(int m, int n, vector<vector<int>>& ops) {\n    for (vector<int>& op : ops) {\n        m = min(m, op[0]);\n        n = min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "js": "\n    ```javascript\nfunction maxCount(m, n, ops) {\n    for (let op of ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    "
    },
    {
        "id": 578,
        "title": "Maximum Product of Three Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, _find three numbers whose product is maximum and return the maximum product_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 24\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,-2,-3\\]\n**Output:** -6"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "6"
            },
            {
                "input": "[1,2,3,4]",
                "output": "24"
            },
            {
                "input": "[-1,-2,-3]",
                "output": "-6"
            }
        ],
        "java": "\n    ```java\npublic int maximumProduct(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "python": "\n    ```python\ndef maximumProduct(nums):\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "c++": "\n    ```cpp\nint maximumProduct(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "js": "\n    ```javascript\nfunction maximumProduct(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    "
    },
    {
        "id": 586,
        "title": "Exclusive Time of Functions",
        "difficulty": "Medium",
        "content": {
            "problem": "On a **single-threaded** CPU, we execute a program containing `n` functions. Each function has a unique ID between `0` and `n-1`.\n\nFunction calls are **stored in a [call stack](https://en.wikipedia.org/wiki/Call_stack)**: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is **the current function being executed**. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n\nYou are given a list `logs`, where `logs[i]` represents the `ith` log message formatted as a string `\"{function_id}:{ \"start \" | \"end \"}:{timestamp} \"`. For example, `\"0:start:3 \"` means a function call with function ID `0` **started at the beginning** of timestamp `3`, and `\"1:end:2 \"` means a function call with function ID `1` **ended at the end** of timestamp `2`. Note that a function can be called **multiple times, possibly recursively**.\n\nA function's **exclusive time** is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for `2` time units and another call executing for `1` time unit, the **exclusive time** is `2 + 1 = 3`.\n\nReturn _the **exclusive time** of each function in an array, where the value at the_ `ith` _index represents the exclusive time for the function with ID_ `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, logs = \\[ \"0:start:0 \", \"1:start:2 \", \"1:end:5 \", \"0:end:6 \"\\]\n**Output:** \\[3,4\\]\n**Explanation:**\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, logs = \\[ \"0:start:0 \", \"0:start:2 \", \"0:end:5 \", \"0:start:6 \", \"0:end:6 \", \"0:end:7 \"\\]\n**Output:** \\[8\\]\n**Explanation:**\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n\n",
                "**Example 3:**\n\n**Input:** n = 2, logs = \\[ \"0:start:0 \", \"0:start:2 \", \"0:end:5 \", \"1:start:6 \", \"1:end:6 \", \"0:end:7 \"\\]\n**Output:** \\[7,1\\]\n**Explanation:**\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`\n*   `1 <= logs.length <= 500`\n*   `0 <= function_id < n`\n*   `0 <= timestamp <= 109`\n*   No two start events will happen at the same timestamp.\n*   No two end events will happen at the same timestamp.\n*   Each function has an `\"end \"` log for each `\"start \"` log.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack"
        ],
        "example": [
            {
                "input": "2,[\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]",
                "output": "[3,4]"
            },
            {
                "input": "1,[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]",
                "output": "[8]"
            },
            {
                "input": "2,[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]",
                "output": "[7,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.Stack;\n\npublic int[] exclusiveTime(int n, List<String> logs) {\n    int[] res = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    int prevTime = 0;\n\n    for (String log : logs) {\n        String[] parts = log.split(\":\");\n        int id = Integer.parseInt(parts[0]);\n        String type = parts[1];\n        int time = Integer.parseInt(parts[2]);\n\n        if (type.equals(\"start\")) {\n            if (!stack.isEmpty()) {\n                res[stack.peek()] += time - prevTime;\n            }\n            stack.push(id);\n            prevTime = time;\n        } else {\n            res[stack.pop()] += time - prevTime + 1;\n            prevTime = time + 1;\n        }\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a stack to keep track of the active function calls. We iterate through the logs and parse each log to obtain the `id`, `type`, and `timestamp`. \n\nIf the current log type is \"start\", we check if the stack is not empty, and if so, we update the result entry for the function at the top of the stack by adding the time elapsed since the previous timestamp, `time - prev_time`. Then we push the new function's ID onto the stack and update the `prev_time` to the current `time`.\n\nIf the current log type is \"end\", we update the result entry for the function at the top of the stack by adding the time elapsed plus one, `time - prev_time + 1`. Then we pop the function's ID off the stack and update the `prev_time` to `time + 1`.\n\nAfter processing all logs, the result array contains the exclusive time for each function.\n    ",
        "python": "\n    ```python\ndef exclusiveTime(n, logs):\n    res = [0] * n\n    stack = []\n    prev_time = 0\n\n    for log in logs:\n        parts = log.split(':')\n        id = int(parts[0])\n        type = parts[1]\n        time = int(parts[2])\n\n        if type == \"start\":\n            if stack:\n                res[stack[-1]] += time - prev_time\n            stack.append(id)\n            prev_time = time\n        else:\n            res[stack.pop()] += time - prev_time + 1\n            prev_time = time + 1\n\n    return res\n```\n    \n    The algorithm uses a stack to keep track of the active function calls. We iterate through the logs and parse each log to obtain the `id`, `type`, and `timestamp`. \n\nIf the current log type is \"start\", we check if the stack is not empty, and if so, we update the result entry for the function at the top of the stack by adding the time elapsed since the previous timestamp, `time - prev_time`. Then we push the new function's ID onto the stack and update the `prev_time` to the current `time`.\n\nIf the current log type is \"end\", we update the result entry for the function at the top of the stack by adding the time elapsed plus one, `time - prev_time + 1`. Then we pop the function's ID off the stack and update the `prev_time` to `time + 1`.\n\nAfter processing all logs, the result array contains the exclusive time for each function.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<int> exclusiveTime(int n, std::vector<std::string>& logs) {\n    std::vector<int> res(n, 0);\n    std::stack<int> s;\n    int prev_time = 0;\n    \n    for (const auto& log : logs) {\n        auto colon1 = log.find(':');\n        auto colon2 = log.rfind(':');\n        \n        int id = std::stoi(log.substr(0, colon1));\n        std::string type = log.substr(colon1 + 1, colon2 - colon1 - 1);\n        int time = std::stoi(log.substr(colon2 + 1));\n        \n        if (type == \"start\") {\n            if (!s.empty()) {\n                res[s.top()] += time - prev_time;\n            }\n            s.push(id);\n            prev_time = time;\n        } else {\n            res[s.top()] += time - prev_time + 1;\n            s.pop();\n            prev_time = time + 1;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm uses a stack to keep track of the active function calls. We iterate through the logs and parse each log to obtain the `id`, `type`, and `timestamp`. \n\nIf the current log type is \"start\", we check if the stack is not empty, and if so, we update the result entry for the function at the top of the stack by adding the time elapsed since the previous timestamp, `time - prev_time`. Then we push the new function's ID onto the stack and update the `prev_time` to the current `time`.\n\nIf the current log type is \"end\", we update the result entry for the function at the top of the stack by adding the time elapsed plus one, `time - prev_time + 1`. Then we pop the function's ID off the stack and update the `prev_time` to `time + 1`.\n\nAfter processing all logs, the result array contains the exclusive time for each function.\n    ",
        "js": "\n    ```javascript\nfunction exclusiveTime(n, logs) {\n    const res = new Array(n).fill(0);\n    const stack = [];\n    let prevTime = 0;\n\n    for (const log of logs) {\n        const parts = log.split(':');\n        const id = parseInt(parts[0]);\n        const type = parts[1];\n        const time = parseInt(parts[2]);\n\n        if (type === \"start\") {\n            if (stack.length > 0) {\n                res[stack[stack.length - 1]] += time - prevTime;\n            }\n            stack.push(id);\n            prevTime = time;\n        } else {\n            res[stack.pop()] += time - prevTime + 1;\n            prevTime = time + 1;\n        }\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a stack to keep track of the active function calls. We iterate through the logs and parse each log to obtain the `id`, `type`, and `timestamp`. \n\nIf the current log type is \"start\", we check if the stack is not empty, and if so, we update the result entry for the function at the top of the stack by adding the time elapsed since the previous timestamp, `time - prev_time`. Then we push the new function's ID onto the stack and update the `prev_time` to the current `time`.\n\nIf the current log type is \"end\", we update the result entry for the function at the top of the stack by adding the time elapsed plus one, `time - prev_time + 1`. Then we pop the function's ID off the stack and update the `prev_time` to `time + 1`.\n\nAfter processing all logs, the result array contains the exclusive time for each function.\n    "
    },
    {
        "id": 594,
        "title": "Maximum Average Subarray II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is greater than or equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,12,-5,-6,50,3\\], k = 4\n**Output:** 12.75000\n**Explanation:**\n\\- When the length is 4, averages are \\[0.5, 12.75, 10.5\\] and the maximum average is 12.75\n- When the length is 5, averages are \\[10.4, 10.8\\] and the maximum average is 10.8\n- When the length is 6, averages are \\[9.16667\\] and the maximum average is 9.16667\nThe maximum average is when we choose a subarray of length 4 (i.e., the sub array \\[12, -5, -6, 50\\]) which has the max average 12.75, so we return 12.75\nNote that we do not consider the subarrays of length < 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5\\], k = 1\n**Output:** 5.00000"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= k <= n <= 104`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,12,-5,-6,50,3],4",
                "output": "12.75000"
            },
            {
                "input": "[5],1",
                "output": "5.00000"
            }
        ],
        "java": "\n    ```java\npublic double findMaxAverage(int[] nums, int k) {\n    long sum = 0;\n    for(int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    double max_avg = (double) sum / k;\n    \n    for(int i = k; i < nums.length; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = Math.max(max_avg, (double) sum / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "python": "\n    ```python\ndef findMaxAverage(nums, k):\n    total = sum(nums[:k])\n    max_avg = total / k\n    for i in range(k, len(nums)):\n        total += nums[i] - nums[i - k]\n        max_avg = max(max_avg, total / k)\n    return max_avg\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "c++": "\n    ```cpp\ndouble findMaxAverage(vector<int>& nums, int k) {\n    long sum = 0;\n    int n = nums.size();\n    for(int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    double max_avg = static_cast<double>(sum) / k;\n    \n    for(int i = k; i < n; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = max(max_avg, static_cast<double>(sum) / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "js": "\n    ```javascript\nfunction findMaxAverage(nums, k) {\n    let sum = 0;\n    for(let i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    let max_avg = sum / k;\n    \n    for(let i = k; i < nums.length; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    "
    },
    {
        "id": 596,
        "title": "Maximum Length of Pair Chain",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** The longest chain is \\[1,2\\] -> \\[3,4\\].\n\n",
                "**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[7,8\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** The longest chain is \\[1,2\\] -> \\[4,5\\] -> \\[7,8\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == pairs.length`\n*   `1 <= n <= 1000`\n*   `-1000 <= lefti < righti <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[3,4]]",
                "output": "2"
            },
            {
                "input": "[[1,2],[7,8],[4,5]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));\n\n    int max_chain_length = 0, last_right = Integer.MIN_VALUE;\n    for (int[] pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ",
        "python": "\n    ```python\ndef findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findLongestChain(std::vector<std::vector<int>>& pairs) {\n    std::sort(pairs.begin(), pairs.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int max_chain_length = 0, last_right = INT_MIN;\n    for (const auto& pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    ",
        "js": "\n    ```javascript\nfunction findLongestChain(pairs) {\n    pairs.sort((a, b) => a[1] - b[1]);\n\n    let max_chain_length = 0, last_right = Number.MIN_SAFE_INTEGER;\n    for (const pair of pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n\n    return max_chain_length;\n}\n```\n\n    \n    The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n.\n    "
    },
    {
        "id": 597,
        "title": "Palindromic Substrings",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the number of **palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 3\n**Explanation:** Three palindromic strings:  \"a \",  \"b \",  \"c \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaa \"\n**Output:** 6\n**Explanation:** Six palindromic strings:  \"a \",  \"a \",  \"a \",  \"aa \",  \"aa \",  \"aaa \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Rolling Hash",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"abc\"",
                "output": "3"
            },
            {
                "input": "\"aaa\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int countSubstrings(String s) {\n    int n = s.length(), count = 0;\n    for (int center = 0; center < 2 * n - 1; ++center) {\n        int left = center / 2;\n        int right = left + center % 2;\n        while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {\n            ++count;\n            --left;\n            ++right;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ",
        "python": "\n    ```python\ndef countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ",
        "c++": "\n    ```cpp\nint countSubstrings(std::string s) {\n    int n = s.size(), count = 0;\n    for (int center = 0; center < 2 * n - 1; ++center) {\n        int left = center / 2;\n        int right = left + center % 2;\n        while (left >= 0 && right < n && s[left] == s[right]) {\n            ++count;\n            --left;\n            ++right;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    ",
        "js": "\n    ```javascript\nfunction countSubstrings(s) {\n    const n = s.length;\n    let count = 0;\n    for (let center = 0; center < 2 * n - 1; ++center) {\n        let left = Math.floor(center / 2);\n        let right = left + center % 2;\n        while (left >= 0 && right < n && s[left] === s[right]) {\n            ++count;\n            --left;\n            ++right;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is based on the idea of expanding a palindromic substring out from its center. There can be 2 * n - 1 possible centers for a string of length n. For each center, the algorithm initializes two pointers, left and right. Initially, left = center / 2, and right = left + center % 2. This ensures that both odd- and even-length palindromic substrings are covered. Then, for each center, the algorithm checks if characters at left and right are equal. If so, increment the count, move left pointer one position to the left, and right pointer one position to the right. The process continues until conditions are no longer satisfied, ensuring all palindromic substrings are taken into account. Finally, the count is returned as the answer.\n    "
    },
    {
        "id": 611,
        "title": "Image Smoother",
        "difficulty": "Easy",
        "content": {
            "problem": "An **image smoother** is a filter of the size `3 x 3` that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\nGiven an `m x n` integer matrix `img` representing the grayscale of an image, return _the image after applying the smoother on each cell of it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** img = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:**\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n",
                "**Example 2:**\n\n**Input:** img = \\[\\[100,200,100\\],\\[200,50,200\\],\\[100,200,100\\]\\]\n**Output:** \\[\\[137,141,137\\],\\[141,138,141\\],\\[137,141,137\\]\\]\n**Explanation:**\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138"
            ],
            "constraints": "**Constraints:**\n\n*   `m == img.length`\n*   `n == img[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= img[i][j] <= 255`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                "output": "[[0,0,0],[0,0,0],[0,0,0]]"
            },
            {
                "input": "[[100,200,100],[200,50,200],[100,200,100]]",
                "output": "[[137,141,137],[141,138,141],[137,141,137]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] imageSmoother(int[][] img) {\n    int m = img.length, n = img[0].length;\n    int[][] result = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "python": "\n    ```python\ndef imageSmoother(img):\n    m, n = len(img), len(img[0])\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            count, total = 0, 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n:\n                        total += img[x][y]\n                        count += 1\n            result[i][j] = total // count\n\n    return result\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n    int m = img.size(), n = img[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "js": "\n    ```javascript\nfunction imageSmoother(img) {\n    const m = img.length, n = img[0].length;\n    const result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let count = 0, sum = 0;\n\n            for (let x = i - 1; x <= i + 1; x++) {\n                for (let y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = Math.floor(sum / count);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    "
    },
    {
        "id": 618,
        "title": "Kth Smallest Number in Multiplication Table",
        "difficulty": "Hard",
        "content": {
            "problem": "Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).\n\nGiven three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, k = 5\n**Output:** 3\n**Explanation:** The 5th smallest number is 3.\n\n",
                "**Example 2:**\n\n**Input:** m = 2, n = 3, k = 6\n**Output:** 6\n**Explanation:** The 6th smallest number is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= k <= m * n`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "3,3,5",
                "output": "3"
            },
            {
                "input": "2,3,6",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "python": "\n    ```python\ndef findKthNumber(m, n, k):\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "c++": "\n    ```cpp\nint findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += std::min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "js": "\n    ```javascript\nfunction findKthNumber(m, n, k) {\n    let low = 1, high = m * n;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        let count = 0;\n        for (let i = 1; i <= m; i++) {\n            count += Math.min(Math.floor(mid / i), n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    "
    },
    {
        "id": 623,
        "title": "Number of Longest Increasing Subsequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of longest increasing subsequences._\n\n**Notice** that the sequence has to be **strictly** increasing.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 2\n**Explanation:** The two longest increasing subsequences are \\[1, 3, 4, 7\\] and \\[1, 3, 5, 7\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 5\n**Explanation:** The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `-106 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Binary Indexed Tree",
            "Segment Tree"
        ],
        "example": [
            {
                "input": "[1,3,5,4,7]",
                "output": "2"
            },
            {
                "input": "[2,2,2,2,2]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int findNumberOfLIS(int[] nums) {\n    int n = nums.length, maxLength = 0, ans = 0;\n    int[] length = new int[n];\n    int[] count = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ",
        "python": "\n    ```python\ndef findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint findNumberOfLIS(std::vector<int>& nums) {\n    int n = nums.size(), maxLength = 0, ans = 0;\n    std::vector<int> length(n, 0), count(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    ",
        "js": "\n    ```javascript\nfunction findNumberOfLIS(nums) {\n    const n = nums.length;\n    let maxLength = 0, ans = 0;\n    const length = new Array(n).fill(1);\n    const count = new Array(n).fill(1);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] === length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength === length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n).\n    "
    },
    {
        "id": 624,
        "title": "Longest Continuous Increasing Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an unsorted array of integers `nums`, return _the length of the longest **continuous increasing subsequence** (i.e. subarray)_. The subsequence must be **strictly** increasing.\n\nA **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 3\n**Explanation:** The longest continuous increasing subsequence is \\[1,3,5\\] with length 3.\nEven though \\[1,3,5,7\\] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 1\n**Explanation:** The longest continuous increasing subsequence is \\[2\\] with length 1. Note that it must be strictly\nincreasing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[1,3,5,4,7]",
                "output": "3"
            },
            {
                "input": "[2,2,2,2,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findLengthOfLCIS(int[] nums) {\n    if (nums.length == 0) return 0;\n    int result = 1, current = 1;\n    for (int i = 1; i < nums.length; ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = Math.max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef findLengthOfLCIS(nums):\n    if not nums:\n        return 0\n    result, current = 1, 1\n    for i in range(1, len(nums)):\n        current = current + 1 if nums[i] > nums[i - 1] else 1\n        result = max(result, current)\n    return result\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint findLengthOfLCIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int result = 1, current = 1;\n    for (int i = 1; i < nums.size(); ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction findLengthOfLCIS(nums) {\n    if (nums.length === 0) return 0;\n    let result = 1, current = 1;\n    for (let i = 1; i < nums.length; ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = Math.max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    "
    },
    {
        "id": 632,
        "title": "Baseball Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:\n\n*   An integer `x`.\n    *   Record a new score of `x`.\n*   `'+'`.\n    *   Record a new score that is the sum of the previous two scores.\n*   `'D'`.\n    *   Record a new score that is the double of the previous score.\n*   `'C'`.\n    *   Invalidate the previous score, removing it from the record.\n\nReturn _the sum of all the scores on the record after applying all the operations_.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer and that all operations are valid.",
            "examples": [
                "**Example 1:**\n\n**Input:** ops = \\[ \"5 \", \"2 \", \"C \", \"D \", \"+ \"\\]\n**Output:** 30\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"2 \" - Add 2 to the record, record is now \\[5, 2\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5\\].\n \"D \" - Add 2 \\* 5 = 10 to the record, record is now \\[5, 10\\].\n \"+ \" - Add 5 + 10 = 15 to the record, record is now \\[5, 10, 15\\].\nThe total sum is 5 + 10 + 15 = 30.\n\n",
                "**Example 2:**\n\n**Input:** ops = \\[ \"5 \", \"-2 \", \"4 \", \"C \", \"D \", \"9 \", \"+ \", \"+ \"\\]\n**Output:** 27\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"-2 \" - Add -2 to the record, record is now \\[5, -2\\].\n \"4 \" - Add 4 to the record, record is now \\[5, -2, 4\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5, -2\\].\n \"D \" - Add 2 \\* -2 = -4 to the record, record is now \\[5, -2, -4\\].\n \"9 \" - Add 9 to the record, record is now \\[5, -2, -4, 9\\].\n \"+ \" - Add -4 + 9 = 5 to the record, record is now \\[5, -2, -4, 9, 5\\].\n \"+ \" - Add 9 + 5 = 14 to the record, record is now \\[5, -2, -4, 9, 5, 14\\].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n",
                "**Example 3:**\n\n**Input:** ops = \\[ \"1 \", \"C \"\\]\n**Output:** 0\n**Explanation:**\n \"1 \" - Add 1 to the record, record is now \\[1\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[\\].\nSince the record is empty, the total sum is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= operations.length <= 1000`\n*   `operations[i]` is `\"C \"`, `\"D \"`, `\"+ \"`, or a string representing an integer in the range `[-3 * 104, 3 * 104]`.\n*   For operation `\"+ \"`, there will always be at least two previous scores on the record.\n*   For operations `\"C \"` and `\"D \"`, there will always be at least one previous score on the record.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Simulation"
        ],
        "example": [
            {
                "input": "[\"5\",\"2\",\"C\",\"D\",\"+\"]",
                "output": "30"
            },
            {
                "input": "[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
                "output": "27"
            },
            {
                "input": "[\"1\",\"C\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int calPoints(String[] ops) {\n        LinkedList<Integer> record = new LinkedList<>();\n        for (String op : ops) {\n            if (op.equals(\"+\")) {\n                record.add(record.getLast() + record.get(record.size() - 2));\n            } else if (op.equals(\"D\")) {\n                record.add(record.getLast() * 2);\n            } else if (op.equals(\"C\")) {\n                record.removeLast();\n            } else {\n                record.add(Integer.parseInt(op));\n            }\n        }\n        return record.stream().mapToInt(Integer::intValue).sum();\n    }\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "python": "\n    ```python\ndef calPoints(ops):\n    record = []\n    for op in ops:\n        if op == '+':\n            record.append(record[-1] + record[-2])\n        elif op == 'D':\n            record.append(record[-1] * 2)\n        elif op == 'C':\n            record.pop()\n        else:\n            record.append(int(op))\n    return sum(record)\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint calPoints(std::vector<std::string>& ops) {\n    std::vector<int> record;\n    for (const std::string& op : ops) {\n        if (op == \"+\") {\n            record.push_back(record[record.size() - 1] + record[record.size() - 2]);\n        } else if (op == \"D\") {\n            record.push_back(2 * record.back());\n        } else if (op == \"C\") {\n            record.pop_back();\n        } else {\n            record.push_back(stoi(op));\n        }\n    }\n    return std::accumulate(record.begin(), record.end(), 0);\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "js": "\n    ```javascript\nfunction calPoints(ops) {\n    let record = [];\n    for (let op of ops) {\n        if (op === '+') {\n            record.push(record[record.length - 1] + record[record.length - 2]);\n        } else if (op === 'D') {\n            record.push(record[record.length - 1] * 2);\n        } else if (op === 'C') {\n            record.pop();\n        } else {\n            record.push(parseInt(op));\n        }\n    }\n    return record.reduce((a, b) => a + b, 0);\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    "
    },
    {
        "id": 645,
        "title": "Max Area of Island",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1,0,0,0,0,1,0,0,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,1,1,0,1,0,0,0,0,0,0,0,0\\],\\[0,1,0,0,1,1,0,0,1,0,1,0,0\\],\\[0,1,0,0,1,1,0,0,1,1,1,0,0\\],\\[0,0,0,0,0,0,0,0,0,0,1,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,0,0,0,0\\]\\]\n**Output:** 6\n**Explanation:** The answer is not 11, because the island must be connected 4-directionally.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]",
                "output": "6"
            },
            {
                "input": "[[0,0,0,0,0,0,0,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxAreaOfIsland(int[][] grid) {\n    int maxArea = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1) {\n                maxArea = Math.max(maxArea, dfs(grid, i, j));\n            }\n        }\n    }\n    return maxArea;\n}\n\nprivate int dfs(int[][] grid, int i, int j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\n        return 0;\n    }\n    grid[i][j] = 0;\n    return 1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\n}\n```\n    \n    The algorithm uses DFS (Depth-First Search) to iterate through each cell of the given matrix.\n1. Initialize a variable, max_area, to store the maximum area found.\n2. Define a DFS function, which receives coordinates (i, j) as arguments. \n   - If the cell at (i, j) is out of bounds or has a value of 0, return 0.\n   - Otherwise, mark the cell at (i, j) as visited by setting its value to 0.\n   - Recursively call the DFS function for the adjacent cells (above, below, left, and right) and sum their returned values. Add 1 (for the current cell) and return the result.\n3. Iterate through each cell in the matrix. If the cell contains a 1 (land), invoke the DFS function with the current coordinates.\n   - Update max_area with the maximum of its current value and the value returned by the DFS function.\n4. After the loop, return max_area as the maximum area of an island in the grid.\n    ",
        "python": "\n    ```python\ndef maxAreaOfIsland(grid):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area\n```\n    \n    The algorithm uses DFS (Depth-First Search) to iterate through each cell of the given matrix.\n1. Initialize a variable, max_area, to store the maximum area found.\n2. Define a DFS function, which receives coordinates (i, j) as arguments. \n   - If the cell at (i, j) is out of bounds or has a value of 0, return 0.\n   - Otherwise, mark the cell at (i, j) as visited by setting its value to 0.\n   - Recursively call the DFS function for the adjacent cells (above, below, left, and right) and sum their returned values. Add 1 (for the current cell) and return the result.\n3. Iterate through each cell in the matrix. If the cell contains a 1 (land), invoke the DFS function with the current coordinates.\n   - Update max_area with the maximum of its current value and the value returned by the DFS function.\n4. After the loop, return max_area as the maximum area of an island in the grid.\n    ",
        "c++": "\n    ```cpp\nint maxAreaOfIsland(vector<vector<int>>& grid) {\n    int max_area = 0;\n\n    function<int(int, int)> dfs = [&](int i, int j) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) {\n            return 0;\n        }\n        grid[i][j] = 0;\n        return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\n    };\n\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j]) {\n                max_area = max(max_area, dfs(i, j));\n            }\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses DFS (Depth-First Search) to iterate through each cell of the given matrix.\n1. Initialize a variable, max_area, to store the maximum area found.\n2. Define a DFS function, which receives coordinates (i, j) as arguments. \n   - If the cell at (i, j) is out of bounds or has a value of 0, return 0.\n   - Otherwise, mark the cell at (i, j) as visited by setting its value to 0.\n   - Recursively call the DFS function for the adjacent cells (above, below, left, and right) and sum their returned values. Add 1 (for the current cell) and return the result.\n3. Iterate through each cell in the matrix. If the cell contains a 1 (land), invoke the DFS function with the current coordinates.\n   - Update max_area with the maximum of its current value and the value returned by the DFS function.\n4. After the loop, return max_area as the maximum area of an island in the grid.\n    ",
        "js": "\n    ```javascript\nvar maxAreaOfIsland = function(grid) {\n    let maxArea = 0;\n    \n    function dfs(i, j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0) {\n            return 0;\n        }\n        grid[i][j] = 0;\n        return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\n    }\n    \n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === 1) {\n                maxArea = Math.max(maxArea, dfs(i, j));\n            }\n        }\n    }\n\n    return maxArea;\n};\n```\n\n    \n    The algorithm uses DFS (Depth-First Search) to iterate through each cell of the given matrix.\n1. Initialize a variable, max_area, to store the maximum area found.\n2. Define a DFS function, which receives coordinates (i, j) as arguments. \n   - If the cell at (i, j) is out of bounds or has a value of 0, return 0.\n   - Otherwise, mark the cell at (i, j) as visited by setting its value to 0.\n   - Recursively call the DFS function for the adjacent cells (above, below, left, and right) and sum their returned values. Add 1 (for the current cell) and return the result.\n3. Iterate through each cell in the matrix. If the cell contains a 1 (land), invoke the DFS function with the current coordinates.\n   - Update max_area with the maximum of its current value and the value returned by the DFS function.\n4. After the loop, return max_area as the maximum area of an island in the grid.\n    "
    },
    {
        "id": 646,
        "title": "Count Binary Substrings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"00110011 \"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's:  \"0011 \",  \"01 \",  \"1100 \",  \"10 \",  \"0011 \", and  \"01 \".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso,  \"00110011 \" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10101 \"\n**Output:** 4\n**Explanation:** There are 4 substrings:  \"10 \",  \"01 \",  \"10 \",  \"01 \" that have equal number of consecutive 1's and 0's."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"00110011\"",
                "output": "6"
            },
            {
                "input": "\"10101\"",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int countBinarySubstrings(String s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "python": "\n    ```python\ndef count_binary_substrings(s: str) -> int:\n    prev, curr, result = 0, 1, 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            curr += 1\n        else:\n            result += min(prev, curr)\n            prev, curr = curr, 1\n    return result + min(prev, curr)\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "c++": "\n    ```cpp\nint countBinarySubstrings(string s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            curr++;\n        } else {\n            result += min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "js": "\n    ```javascript\nfunction countBinarySubstrings(s) {\n    let prev = 0, curr = 1, result = 0;\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    "
    },
    {
        "id": 654,
        "title": "Binary Search",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 9\n**Output:** 4\n**Explanation:** 9 exists in nums and its index is 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in nums so return -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 < nums[i], target < 104`\n*   All the integers in `nums` are **unique**.\n*   `nums` is sorted in ascending order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[-1,0,3,5,9,12],9",
                "output": "4"
            },
            {
                "input": "[-1,0,3,5,9,12],2",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "python": "\n    ```python\ndef search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "c++": "\n    ```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "js": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    "
    },
    {
        "id": 659,
        "title": "To Lower Case",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the string after replacing every uppercase letter with the same lowercase letter_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello \"\n**Output:**  \"hello \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"here \"\n**Output:**  \"here \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LOVELY \"\n**Output:**  \"lovely \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of printable ASCII characters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"Hello\"",
                "output": "\"hello\""
            },
            {
                "input": "\"here\"",
                "output": "\"here\""
            },
            {
                "input": "\"LOVELY\"",
                "output": "\"lovely\""
            }
        ],
        "java": "\n    ```java\npublic String toLowerCase(String s) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        if (chars[i] >= 'A' && chars[i] <= 'Z') {\n            chars[i] = (char)(chars[i] - 'A' + 'a');\n        }\n    }\n    return new String(chars);\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "python": "\n    ```python\ndef toLowerCase(s: str) -> str:\n    return s.lower()\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string toLowerCase(std::string s) {\n    for (char& c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "js": "\n    ```javascript\nfunction toLowerCase(s) {\n    let result = '';\n    for (let i = 0; i < s.length; i++) {\n        let charCode = s.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 90) {\n            charCode += 32;\n        }\n        result += String.fromCharCode(charCode);\n    }\n    return result;\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    "
    },
    {
        "id": 662,
        "title": "Minimum ASCII Delete Sum for Two Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `s1` and `s2`, return _the lowest **ASCII** sum of deleted characters to make two strings equal_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"sea \", s2 =  \"eat \"\n**Output:** 231\n**Explanation:** Deleting  \"s \" from  \"sea \" adds the ASCII value of  \"s \" (115) to the sum.\nDeleting  \"t \" from  \"eat \" adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"delete \", s2 =  \"leet \"\n**Output:** 403\n**Explanation:** Deleting  \"dee \" from  \"delete \" to turn the string into  \"let \",\nadds 100\\[d\\] + 101\\[e\\] + 101\\[e\\] to the sum.\nDeleting  \"e \" from  \"leet \" adds 101\\[e\\] to the sum.\nAt the end, both strings are equal to  \"let \", and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into  \"lee \" or  \"eet \", we would get answers of 433 or 417, which are higher."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 1000`\n*   `s1` and `s2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"sea\",\"eat\"",
                "output": "231"
            },
            {
                "input": "\"delete\",\"leet\"",
                "output": "403"
            }
        ],
        "java": "\n    ```java\npublic int minimumDeleteSum(String s1, String s2) {\n    int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n    for (int i = 1; i <= s1.length(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\n    }\n    for (int j = 1; j <= s2.length(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\n    }\n    for (int i = 1; i <= s1.length(); i++) {\n        for (int j = 1; j <= s2.length(); j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length()][s2.length()];\n}\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ",
        "python": "\n    ```python\ndef minimumDeleteSum(s1: str, s2: str) -> int:\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ",
        "c++": "\n    ```cpp\nint minimumDeleteSum(std::string s1, std::string s2) {\n    int dp[1001][1001] = {0};\n    for (int i = 1; i <= s1.size(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1[i - 1];\n    }\n    for (int j = 1; j <= s2.size(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2[j - 1];\n    }\n    for (int i = 1; i <= s1.size(); i++) {\n        for (int j = 1; j <= s2.size(); j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = std::min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n            }\n        }\n    }\n    return dp[s1.size()][s2.size()];\n}\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    ",
        "js": "\n    ```javascript\nfunction minimumDeleteSum(s1, s2) {\n    const dp = Array.from({ length: s1.length + 1 }, () => Array(s2.length + 1).fill(0));\n    for (let i = 1; i <= s1.length; i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charCodeAt(i - 1);\n    }\n    for (let j = 1; j <= s2.length; j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charCodeAt(j - 1);\n    }\n    for (let i = 1; i <= s1.length; i++) {\n        for (let j = 1; j <= s2.length; j++) {\n            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charCodeAt(i - 1), dp[i][j - 1] + s2.charCodeAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length][s2.length];\n}\n```\n    \n    For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal.\n    "
    },
    {
        "id": 663,
        "title": "Subarray Product Less Than K",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[10,5,2,6\\], k = 100\n**Output:** 8\n**Explanation:** The 8 subarrays that have product less than 100 are:\n\\[10\\], \\[5\\], \\[2\\], \\[6\\], \\[10, 5\\], \\[5, 2\\], \\[2, 6\\], \\[5, 2, 6\\]\nNote that \\[10, 5, 2\\] is not included as the product of 100 is not strictly less than k.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\], k = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `1 <= nums[i] <= 1000`\n*   `0 <= k <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[10,5,2,6],100",
                "output": "8"
            },
            {
                "input": "[1,2,3],0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\n    if (k <= 1) return 0;\n    int prod = 1, count = 0, left = 0;\n    for (int right = 0; right < nums.length; right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a sliding window approach to find the contiguous subarrays with the product less than k. It initializes a product variable to 1, and count variable to 0.  We also have left and right pointers for our sliding window.\n\nFor each number in the array, we multiply the product by the current number. Inside a loop, we check if the product is greater than or equal to k; if it is, we divide the product by the number at the left pointer and move the left pointer to the right.\n\nAfter adjusting the product and the left pointer, we can calculate the length of the current window. We increment the count by the length of the window.\n\nAt the end, we return the total count of subarrays with product less than k.\n    ",
        "python": "\n    ```python\ndef numSubarrayProductLessThanK(nums, k):\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count\n```\n    \n    The algorithm uses a sliding window approach to find the contiguous subarrays with the product less than k. It initializes a product variable to 1, and count variable to 0.  We also have left and right pointers for our sliding window.\n\nFor each number in the array, we multiply the product by the current number. Inside a loop, we check if the product is greater than or equal to k; if it is, we divide the product by the number at the left pointer and move the left pointer to the right.\n\nAfter adjusting the product and the left pointer, we can calculate the length of the current window. We increment the count by the length of the window.\n\nAt the end, we return the total count of subarrays with product less than k.\n    ",
        "c++": "\n    ```cpp\nint numSubarrayProductLessThanK(vector<int>& nums, int k) {\n    if (k <= 1) return 0;\n    int prod = 1, count = 0, left = 0;\n    for (int right = 0; right < nums.size(); right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a sliding window approach to find the contiguous subarrays with the product less than k. It initializes a product variable to 1, and count variable to 0.  We also have left and right pointers for our sliding window.\n\nFor each number in the array, we multiply the product by the current number. Inside a loop, we check if the product is greater than or equal to k; if it is, we divide the product by the number at the left pointer and move the left pointer to the right.\n\nAfter adjusting the product and the left pointer, we can calculate the length of the current window. We increment the count by the length of the window.\n\nAt the end, we return the total count of subarrays with product less than k.\n    ",
        "js": "\n    ```javascript\nfunction numSubarrayProductLessThanK(nums, k) {\n    if (k <= 1) return 0;\n    let prod = 1, count = 0, left = 0;\n    for (let right = 0; right < nums.length; right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a sliding window approach to find the contiguous subarrays with the product less than k. It initializes a product variable to 1, and count variable to 0.  We also have left and right pointers for our sliding window.\n\nFor each number in the array, we multiply the product by the current number. Inside a loop, we check if the product is greater than or equal to k; if it is, we divide the product by the number at the left pointer and move the left pointer to the right.\n\nAfter adjusting the product and the left pointer, we can calculate the length of the current window. We increment the count by the length of the window.\n\nAt the end, we return the total count of subarrays with product less than k.\n    "
    },
    {
        "id": 664,
        "title": "Best Time to Buy and Sell Stock with Transaction Fee",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[1,3,2,8,4,9\\], fee = 2\n**Output:** 8\n**Explanation:** The maximum profit can be achieved by:\n- Buying at prices\\[0\\] = 1\n- Selling at prices\\[3\\] = 8\n- Buying at prices\\[4\\] = 4\n- Selling at prices\\[5\\] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1,3,7,5,10,3\\], fee = 3\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 5 * 104`\n*   `1 <= prices[i] < 5 * 104`\n*   `0 <= fee < 5 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,3,2,8,4,9],2",
                "output": "8"
            },
            {
                "input": "[1,3,7,5,10,3],3",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int[] prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = max(cash, hold + price - fee);\n        hold = max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(prices, fee) {\n    let cash = 0, hold = -prices[0];\n    for (const price of prices) {\n        let temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n```\n    \n    The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit.\n    "
    },
    {
        "id": 667,
        "title": "Maximum Length of Repeated Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _the maximum length of a subarray that appears in **both** arrays_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,2,1\\], nums2 = \\[3,2,1,4,7\\]\n**Output:** 3\n**Explanation:** The repeated subarray with maximum length is \\[3,2,1\\].\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[0,0,0,0,0\\], nums2 = \\[0,0,0,0,0\\]\n**Output:** 5\n**Explanation:** The repeated subarray with maximum length is \\[0,0,0,0,0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sliding Window",
            "Rolling Hash",
            "Hash Function"
        ],
        "example": [
            {
                "input": "[1,2,3,2,1],[3,2,1,4,7]",
                "output": "3"
            },
            {
                "input": "[0,0,0,0,0],[0,0,0,0,0]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int findLength(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ",
        "python": "\n    ```python\ndef findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ",
        "c++": "\n    ```cpp\nint findLength(vector<int>& nums1, vector<int>& nums2) {\n    int m = nums1.size();\n    int n = nums2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    ",
        "js": "\n    ```javascript\nfunction findLength(nums1, nums2) {\n    const m = nums1.length;\n    const n = nums2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxLength = 0;\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (nums1[i] === nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary.\n    "
    },
    {
        "id": 673,
        "title": "Find Pivot Index",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, calculate the **pivot index** of this array.\n\nThe **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn _the **leftmost pivot index**_. If no such index exists, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,7,3,6,5,6\\]\n**Output:** 3\n**Explanation:**\nThe pivot index is 3.\nLeft sum = nums\\[0\\] + nums\\[1\\] + nums\\[2\\] = 1 + 7 + 3 = 11\nRight sum = nums\\[4\\] + nums\\[5\\] = 5 + 6 = 11\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** -1\n**Explanation:**\nThere is no index that satisfies the conditions in the problem statement.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,1,-1\\]\n**Output:** 0\n**Explanation:**\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums\\[1\\] + nums\\[2\\] = 1 + -1 = 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`\n\n**Note:** This question is the same as 1991: [https://leetcode.com/problems/find-the-middle-index-in-array/](https://leetcode.com/problems/find-the-middle-index-in-array/)",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,7,3,6,5,6]",
                "output": "3"
            },
            {
                "input": "[1,2,3]",
                "output": "-1"
            },
            {
                "input": "[2,1,-1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int pivotIndex(int[] nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.length; ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "python": "\n    ```python\ndef pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "c++": "\n    ```cpp\nint pivotIndex(vector<int>& nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "js": "\n    ```javascript\nfunction pivotIndex(nums) {\n    const total_sum = nums.reduce((a, b) => a + b, 0);\n    let left_sum = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (left_sum === total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    "
    },
    {
        "id": 682,
        "title": "Flood Fill",
        "difficulty": "Easy",
        "content": {
            "problem": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image."
            ],
            "constraints": "**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1,1],[1,1,0],[1,0,1]],1,1,2",
                "output": "[[2,2,2],[2,2,0],[2,0,1]]"
            },
            {
                "input": "[[0,0,0],[0,0,0]],0,0,0",
                "output": "[[0,0,0],[0,0,0]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    int startColor = image[sr][sc];\n    fill(image, sr, sc, newColor, startColor);\n    return image;\n}\n\nprivate void fill(int[][] image, int sr, int sc, int newColor, int startColor) {\n    if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\n    image[sr][sc] = newColor;\n    fill(image, sr - 1, sc, newColor, startColor);\n    fill(image, sr + 1, sc, newColor, startColor);\n    fill(image, sr, sc - 1, newColor, startColor);\n    fill(image, sr, sc + 1, newColor, startColor);\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "python": "\n    ```python\ndef floodFill(image, sr, sc, newColor):\n    startColor = image[sr][sc]\n    def fill(sr, sc):\n        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: \n            return\n        image[sr][sc] = newColor\n        fill(sr - 1, sc)\n        fill(sr + 1, sc)\n        fill(sr, sc - 1)\n        fill(sr, sc + 1)\n    \n    fill(sr, sc)\n    return image\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {\n    if (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\n    image[sr][sc] = newColor;\n    fill(image, sr - 1, sc, newColor, startColor);\n    fill(image, sr + 1, sc, newColor, startColor);\n    fill(image, sr, sc - 1, newColor, startColor);\n    fill(image, sr, sc + 1, newColor, startColor);\n}\n\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n    int startColor = image[sr][sc];\n    fill(image, sr, sc, newColor, startColor);\n    return image;\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "js": "\n    ```javascript\nfunction floodFill(image, sr, sc, newColor) {\n    let startColor = image[sr][sc];\n    function fill(sr, sc) {\n        if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] !== startColor || image[sr][sc] === newColor) return;\n        image[sr][sc] = newColor;\n        fill(sr - 1, sc);\n        fill(sr + 1, sc);\n        fill(sr, sc - 1);\n        fill(sr, sc + 1);\n    }\n    fill(sr, sc);\n    return image;\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    "
    },
    {
        "id": 684,
        "title": "Asteroid Collision",
        "difficulty": "Medium",
        "content": {
            "problem": "We are given an array `asteroids` of integers representing asteroids in a row.\n\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\n\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.",
            "examples": [
                "**Example 1:**\n\n**Input:** asteroids = \\[5,10,-5\\]\n**Output:** \\[5,10\\]\n**Explanation:** The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n\n",
                "**Example 2:**\n\n**Input:** asteroids = \\[8,-8\\]\n**Output:** \\[\\]\n**Explanation:** The 8 and -8 collide exploding each other.\n\n",
                "**Example 3:**\n\n**Input:** asteroids = \\[10,2,-5\\]\n**Output:** \\[10\\]\n**Explanation:** The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= asteroids.length <= 104`\n*   `-1000 <= asteroids[i] <= 1000`\n*   `asteroids[i] != 0`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Simulation"
        ],
        "example": [
            {
                "input": "[5,10,-5]",
                "output": "[5,10]"
            },
            {
                "input": "[8,-8]",
                "output": "[]"
            },
            {
                "input": "[10,2,-5]",
                "output": "[10]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\nclass Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> s = new Stack<>();\n        for (int i = 0; i < asteroids.length; i++) {\n            if (asteroids[i] > 0 || s.isEmpty() || s.peek() < 0) {\n                s.push(asteroids[i]);\n            } else if (s.peek() <= -asteroids[i]) {\n                if (s.peek() < -asteroids[i]) i--;\n                s.pop();\n            }\n        }\n        int[] ans = new int[s.size()];\n        for (int i = ans.length - 1; i >= 0; i--) {\n            ans[i] = s.pop();\n        }\n        return ans;\n    }\n}\n```\n\n    \n    The algorithm uses a stack data structure to track the asteroids. For each asteroid, if it is moving to the right, or if the stack is empty, or if the top of the stack has an asteroid with a negative value (moving left), then we can simply push the current asteroid onto the stack.\n\nIf the top of the stack has an asteroid with a positive value and the current asteroid has a negative value (meaning they will collide), compare their absolute values. If the top of the stack has a smaller value, decrement the iterator and pop the stack, so that the current asteroid will be considered again. If both have the same value, simply pop the stack without decrementing the iterator. Otherwise, if the top of the stack has a larger value, ignore the current asteroid, and proceed to the next asteroid.\n\nThe final stack will have the remaining asteroids after all the collisions. In the case of Java, the stack is converted to an array before returning the result.\n    ",
        "python": "\n    ```python\ndef asteroidCollision(asteroids):\n    s = []\n    for num in asteroids:\n        if num > 0 or not s or s[-1] < 0:\n            s.append(num)\n        elif s[-1] <= -num:\n            if s[-1] < -num:\n                s.pop()\n                s.append(num)\n            else:\n                s.pop()\n    return s\n```\n\n    \n    The algorithm uses a stack data structure to track the asteroids. For each asteroid, if it is moving to the right, or if the stack is empty, or if the top of the stack has an asteroid with a negative value (moving left), then we can simply push the current asteroid onto the stack.\n\nIf the top of the stack has an asteroid with a positive value and the current asteroid has a negative value (meaning they will collide), compare their absolute values. If the top of the stack has a smaller value, decrement the iterator and pop the stack, so that the current asteroid will be considered again. If both have the same value, simply pop the stack without decrementing the iterator. Otherwise, if the top of the stack has a larger value, ignore the current asteroid, and proceed to the next asteroid.\n\nThe final stack will have the remaining asteroids after all the collisions. In the case of Java, the stack is converted to an array before returning the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> asteroidCollision(vector<int>& asteroids) {\n    vector<int> s;\n    for (int i = 0; i < asteroids.size(); i++) {\n        if (asteroids[i] > 0 || s.empty() || s.back() < 0) {\n            s.push_back(asteroids[i]);\n        } else if (s.back() <= -asteroids[i]) {\n            if (s.back() < -asteroids[i]) i--;\n            s.pop_back();\n        }\n    }\n    return s;\n}\n```\n\n    \n    The algorithm uses a stack data structure to track the asteroids. For each asteroid, if it is moving to the right, or if the stack is empty, or if the top of the stack has an asteroid with a negative value (moving left), then we can simply push the current asteroid onto the stack.\n\nIf the top of the stack has an asteroid with a positive value and the current asteroid has a negative value (meaning they will collide), compare their absolute values. If the top of the stack has a smaller value, decrement the iterator and pop the stack, so that the current asteroid will be considered again. If both have the same value, simply pop the stack without decrementing the iterator. Otherwise, if the top of the stack has a larger value, ignore the current asteroid, and proceed to the next asteroid.\n\nThe final stack will have the remaining asteroids after all the collisions. In the case of Java, the stack is converted to an array before returning the result.\n    ",
        "js": "\n    ```javascript\nfunction asteroidCollision(asteroids) {\n    const s = [];\n    for (let i = 0; i < asteroids.length; i++) {\n        if (asteroids[i] > 0 || !s.length || s[s.length - 1] < 0) {\n            s.push(asteroids[i]);\n        } else if (s[s.length - 1] <= -asteroids[i]) {\n            if (s[s.length - 1] < -asteroids[i]) i--;\n            s.pop();\n        }\n    }\n    return s;\n}\n```\n\n    \n    The algorithm uses a stack data structure to track the asteroids. For each asteroid, if it is moving to the right, or if the stack is empty, or if the top of the stack has an asteroid with a negative value (moving left), then we can simply push the current asteroid onto the stack.\n\nIf the top of the stack has an asteroid with a positive value and the current asteroid has a negative value (meaning they will collide), compare their absolute values. If the top of the stack has a smaller value, decrement the iterator and pop the stack, so that the current asteroid will be considered again. If both have the same value, simply pop the stack without decrementing the iterator. Otherwise, if the top of the stack has a larger value, ignore the current asteroid, and proceed to the next asteroid.\n\nThe final stack will have the remaining asteroids after all the collisions. In the case of Java, the stack is converted to an array before returning the result.\n    "
    },
    {
        "id": 687,
        "title": "Monotone Increasing Digits",
        "difficulty": "Medium",
        "content": {
            "problem": "An integer has **monotone increasing digits** if and only if each pair of adjacent digits `x` and `y` satisfy `x <= y`.\n\nGiven an integer `n`, return _the largest number that is less than or equal to_ `n` _with **monotone increasing digits**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10\n**Output:** 9\n\n",
                "**Example 2:**\n\n**Input:** n = 1234\n**Output:** 1234\n\n",
                "**Example 3:**\n\n**Input:** n = 332\n**Output:** 299"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "10",
                "output": "9"
            },
            {
                "input": "1234",
                "output": "1234"
            },
            {
                "input": "332",
                "output": "299"
            }
        ],
        "java": "\n    ```java\npublic int monotoneIncreasingDigits(int n) {\n    char[] n_str = String.valueOf(n).toCharArray();\n    int n_len = n_str.length;\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return Integer.parseInt(new String(n_str));\n}\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ",
        "python": "\n    ```python\ndef monotoneIncreasingDigits(n: int) -> int:\n    n_str = [c for c in str(n)]\n\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n\n    return int(''.join(n_str))\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ",
        "c++": "\n    ```cpp\nint monotoneIncreasingDigits(int n) {\n    string n_str = to_string(n);\n    int n_len = n_str.size();\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return stoi(n_str);\n}\n```\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    ",
        "js": "\n    ```javascript\nfunction monotoneIncreasingDigits(n) {\n    let n_str = n.toString();\n    let n_len = n_str.length;\n\n    let i = n_len - 1;\n    while (i > 0) {\n        if (n_str.charAt(i) < n_str.charAt(i - 1)) {\n            n_str = n_str.slice(0, i-1) + String.fromCharCode(n_str.charCodeAt(i-1) - 1) + '9'.repeat(n_len - i);\n        }\n        --i;\n    }\n\n    return parseInt(n_str);\n}\n```\n\n    \n    1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it.\n    "
    },
    {
        "id": 688,
        "title": "Daily Temperatures",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** temperatures = \\[73,74,75,71,69,72,76,73\\]\n**Output:** \\[1,1,4,2,1,1,0,0\\]\n\n",
                "**Example 2:**\n\n**Input:** temperatures = \\[30,40,50,60\\]\n**Output:** \\[1,1,1,0\\]\n\n",
                "**Example 3:**\n\n**Input:** temperatures = \\[30,60,90\\]\n**Output:** \\[1,1,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= temperatures.length <= 105`\n*   `30 <= temperatures[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[73,74,75,71,69,72,76,73]",
                "output": "[1,1,4,2,1,1,0,0]"
            },
            {
                "input": "[30,40,50,60]",
                "output": "[1,1,1,0]"
            },
            {
                "input": "[30,60,90]",
                "output": "[1,1,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int[] dailyTemperatures(int[] temperatures) {\n    int[] result = new int[temperatures.length];\n    Stack<Integer> stack = new Stack<>();\n\n    for (int i = 0; i < temperatures.length; i++) {\n        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n            int idx = stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack that stores indices of the temperatures array. We iterate through the temperatures checking if the current temperature is greater than the temperature at the top of the stack. If it is, we pop the stack, and update the result array with the difference of the current index and the popped index, which represents the number of days to wait.\n\nIf the current temperature is not greater than the top of the stack, or the stack is empty, we push the current index onto the stack.\n\nAt the end, any remaining indices in the stack represent days without a warmer day, and their values in the result array will remain as 0 (initialized earlier).\n\nThe time complexity of the algorithm is O(N), since each index will be pushed and popped only once throughout the entire loop.\n    ",
        "python": "\n    ```python\ndef daily_temperatures(temperatures):\n    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    return result\n```\n    \n    The algorithm uses a stack that stores indices of the temperatures array. We iterate through the temperatures checking if the current temperature is greater than the temperature at the top of the stack. If it is, we pop the stack, and update the result array with the difference of the current index and the popped index, which represents the number of days to wait.\n\nIf the current temperature is not greater than the top of the stack, or the stack is empty, we push the current index onto the stack.\n\nAt the end, any remaining indices in the stack represent days without a warmer day, and their values in the result array will remain as 0 (initialized earlier).\n\nThe time complexity of the algorithm is O(N), since each index will be pushed and popped only once throughout the entire loop.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n\nstd::vector<int> dailyTemperatures(std::vector<int>& temperatures) {\n    std::vector<int> result(temperatures.size(), 0);\n    std::stack<int> stack;\n\n    for (size_t i = 0; i < temperatures.size(); ++i) {\n        while (!stack.empty() && temperatures[i] > temperatures[stack.top()]) {\n            int idx = stack.top();\n            stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack that stores indices of the temperatures array. We iterate through the temperatures checking if the current temperature is greater than the temperature at the top of the stack. If it is, we pop the stack, and update the result array with the difference of the current index and the popped index, which represents the number of days to wait.\n\nIf the current temperature is not greater than the top of the stack, or the stack is empty, we push the current index onto the stack.\n\nAt the end, any remaining indices in the stack represent days without a warmer day, and their values in the result array will remain as 0 (initialized earlier).\n\nThe time complexity of the algorithm is O(N), since each index will be pushed and popped only once throughout the entire loop.\n    ",
        "js": "\n    ```javascript\nfunction dailyTemperatures(temperatures) {\n    const result = new Array(temperatures.length).fill(0);\n    const stack = [];\n\n    for (let i = 0; i < temperatures.length; i++) {\n        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {\n            const idx = stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack that stores indices of the temperatures array. We iterate through the temperatures checking if the current temperature is greater than the temperature at the top of the stack. If it is, we pop the stack, and update the result array with the difference of the current index and the popped index, which represents the number of days to wait.\n\nIf the current temperature is not greater than the top of the stack, or the stack is empty, we push the current index onto the stack.\n\nAt the end, any remaining indices in the stack represent days without a warmer day, and their values in the result array will remain as 0 (initialized earlier).\n\nThe time complexity of the algorithm is O(N), since each index will be pushed and popped only once throughout the entire loop.\n    "
    },
    {
        "id": 697,
        "title": "Shortest Completing Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `licensePlate` and an array of strings `words`, find the **shortest completing** word in `words`.\n\nA **completing** word is a word that **contains all the letters** in `licensePlate`. **Ignore numbers and spaces** in `licensePlate`, and treat letters as **case insensitive**. If a letter appears more than once in `licensePlate`, then it must appear in the word the same number of times or more.\n\nFor example, if `licensePlate` `= \"aBc 12c \"`, then it contains letters `'a'`, `'b'` (ignoring case), and `'c'` twice. Possible **completing** words are `\"abccdef \"`, `\"caaacab \"`, and `\"cbca \"`.\n\nReturn _the shortest **completing** word in_ `words`_._ It is guaranteed an answer exists. If there are multiple shortest **completing** words, return the **first** one that occurs in `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** licensePlate =  \"1s3 PSt \", words = \\[ \"step \", \"steps \", \"stripe \", \"stepple \"\\]\n**Output:**  \"steps \"\n**Explanation:** licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n \"step \" contains 't' and 'p', but only contains 1 's'.\n \"steps \" contains 't', 'p', and both 's' characters.\n \"stripe \" is missing an 's'.\n \"stepple \" is missing an 's'.\nSince  \"steps \" is the only word containing all the letters, that is the answer.\n\n",
                "**Example 2:**\n\n**Input:** licensePlate =  \"1s3 456 \", words = \\[ \"looks \", \"pest \", \"stew \", \"show \"\\]\n**Output:**  \"pest \"\n**Explanation:** licensePlate only contains the letter 's'. All the words contain 's', but among these  \"pest \",  \"stew \", and  \"show \" are shortest. The answer is  \"pest \" because it is the word that appears earliest of the 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= licensePlate.length <= 7`\n*   `licensePlate` contains digits, letters (uppercase or lowercase), or space `' '`.\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 15`\n*   `words[i]` consists of lower case English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"1s3PSt\",[\"step\",\"steps\",\"stripe\",\"stepple\"]",
                "output": "\"steps\""
            },
            {
                "input": "\"1s3456\",[\"looks\",\"pest\",\"stew\",\"show\"]",
                "output": "\"pest\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String shortestCompletingWord(String licensePlate, String[] words) {\n    HashMap<Character, Integer> lpCount = new HashMap<>();\n    for (char c : licensePlate.toCharArray()) {\n        if (Character.isLetter(c)) {\n            char lower = Character.toLowerCase(c);\n            lpCount.put(lower, lpCount.getOrDefault(lower, 0) + 1);\n        }\n    }\n\n    String result = \"\";\n    for (String word : words) {\n        HashMap<Character, Integer> wordCount = new HashMap<>();\n        for (char c : word.toCharArray()) {\n            wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);\n        }\n\n        boolean valid = true;\n        for (char ch : lpCount.keySet()) {\n            if (wordCount.getOrDefault(ch, 0) < lpCount.get(ch)) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid && (result.isEmpty() || word.length() < result.length())) {\n            result = word;\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "python": "\n    ```python\ndef shortestCompletingWord(licensePlate: str, words: list[str]) -> str:\n    from collections import Counter\n\n    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n    result = \"\"\n    for word in words:\n        word_count = Counter(word)\n\n        valid = all(word_count[ch] >= count for ch, count in lp_count.items())\n\n        if valid and (not result or len(word) < len(result)):\n            result = word\n\n    return result\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nstd::string shortestCompletingWord(std::string licensePlate, std::vector<std::string>& words) {\n    std::unordered_map<char, int> lp_count;\n    for (char c : licensePlate)\n        if (isalpha(c))\n            lp_count[tolower(c)]++;\n\n    std::string result = \"\";\n    for (const std::string& word : words) {\n        std::unordered_map<char, int> word_count;\n        for (char c : word)\n            word_count[c]++;\n\n        bool valid = true;\n        for (const auto& [ch, count] : lp_count)\n            if (word_count[ch] < count) {\n                valid = false;\n                break;\n            }\n\n        if (valid && (result.empty() || word.length() < result.length()))\n            result = word;\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "js": "\n    ```javascript\nfunction shortestCompletingWord(licensePlate, words) {\n  const lpCount = new Map();\n  for (const c of licensePlate)\n    if (c.match(/[a-zA-Z]/))\n      lpCount.set(c.toLowerCase(), (lpCount.get(c.toLowerCase()) || 0) + 1);\n\n  let result = \"\";\n  for (const word of words) {\n    const wordCount = new Map();\n    for (const c of word)\n      wordCount.set(c, (wordCount.get(c) || 0) + 1);\n\n    let valid = true;\n    for (const [ch, count] of lpCount)\n      if ((wordCount.get(ch) || 0) < count) {\n        valid = false;\n        break;\n      }\n\n    if (valid && (!result || word.length < result.length))\n      result = word;\n  }\n  return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    "
    },
    {
        "id": 709,
        "title": "Find Anagram Mappings",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2` where `nums2` is **an anagram** of `nums1`. Both arrays may contain duplicates.\n\nReturn _an index mapping array_ `mapping` _from_ `nums1` _to_ `nums2` _where_ `mapping[i] = j` _means the_ `ith` _element in_ `nums1` _appears in_ `nums2` _at index_ `j`. If there are multiple answers, return **any of them**.\n\nAn array `a` is **an anagram** of an array `b` means `b` is made by randomizing the order of the elements in `a`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[12,28,46,32,50\\], nums2 = \\[50,12,32,46,28\\]\n**Output:** \\[1,4,3,2,0\\]\n**Explanation:** As mapping\\[0\\] = 1 because the 0th element of nums1 appears at nums2\\[1\\], and mapping\\[1\\] = 4 because the 1st element of nums1 appears at nums2\\[4\\], and so on.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[84,46\\], nums2 = \\[84,46\\]\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length <= 100`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 105`\n*   `nums2` is an anagram of `nums1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[12,28,46,32,50],[50,12,32,46,28]",
                "output": "[1,4,3,2,0]"
            },
            {
                "input": "[84,46],[84,46]",
                "output": "[0,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] anagramMappings(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> num_map = new HashMap<>();\n    for (int i = 0; i < nums2.length; i++) {\n        num_map.put(nums2[i], i);\n    }\n    int[] mapping = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "python": "\n    ```python\ndef anagramMappings(nums1, nums2):\n    num_map = {num: i for i, num in enumerate(nums2)}\n    mapping = [num_map[num] for num in nums1]\n    return mapping\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int, int> num_map;\n    for (int i = 0; i < nums2.size(); i++) {\n        num_map[nums2[i]] = i;\n    }\n    vector<int> mapping(nums1.size());\n    for (int i = 0; i < nums1.size(); i++) {\n        mapping[i] = num_map[nums1[i]];\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "js": "\n    ```javascript\nfunction anagramMappings(nums1, nums2) {\n    let num_map = new Map();\n    for (let i = 0; i < nums2.length; i++) {\n        num_map.set(nums2[i], i);\n    }\n    let mapping = new Array(nums1.length);\n    for (let i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    "
    },
    {
        "id": 710,
        "title": "Special Binary String",
        "difficulty": "Hard",
        "content": {
            "problem": "**Special binary strings** are binary strings with the following two properties:\n\n*   The number of `0`'s is equal to the number of `1`'s.\n*   Every prefix of the binary string has at least as many `1`'s as `0`'s.\n\nYou are given a **special binary** string `s`.\n\nA move consists of choosing two consecutive, non-empty, special substrings of `s`, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\n\nReturn _the lexicographically largest resulting string possible after applying the mentioned operations on the string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"11011000 \"\n**Output:**  \"11100100 \"\n**Explanation:** The strings  \"10 \" \\[occuring at s\\[1\\]\\] and  \"1100 \" \\[at s\\[3\\]\\] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10 \"\n**Output:**  \"10 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 50`\n*   `s[i]` is either `'0'` or `'1'`.\n*   `s` is a special binary string.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"11011000\"",
                "output": "\"11100100\""
            },
            {
                "input": "\"10\"",
                "output": "\"10\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String makeLargestSpecial(String s) {\n    int count = 0;\n    int i = 0;\n    List<String> subs = new ArrayList<>();\n\n    for (int j = 0; j < s.length(); j++) {\n        if (s.charAt(j) == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.add(\"1\" + makeLargestSpecial(s.substring(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    Collections.sort(subs, Collections.reverseOrder());\n    StringBuilder res = new StringBuilder();\n    for (String sub : subs) {\n        res.append(sub);\n    }\n    return res.toString();\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "python": "\n    ```python\ndef makeLargestSpecial(s: str) -> str:\n    count, i = 0, 0\n    subs = []\n\n    for j in range(len(s)):\n        if s[j] == '1':\n            count += 1\n        else:\n            count -= 1\n\n        if count == 0:\n            subs.append(\"1\" + makeLargestSpecial(s[i+1:j]) + \"0\")\n            i = j + 1\n\n    subs.sort(reverse=True)\n    return \"\".join(subs)\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string makeLargestSpecial(std::string s) {\n    int count = 0, i = 0;\n    std::vector<std::string> subs;\n\n    for (int j = 0; j < s.size(); j++) {\n        if (s[j] == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.push_back('1' + makeLargestSpecial(s.substr(i+1, j-i-1)) + '0');\n            i = j + 1;\n        }\n    }\n\n    std::sort(subs.rbegin(), subs.rend());\n    std::string res;\n    for (const auto& sub : subs) {\n        res += sub;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "js": "\n    ```javascript\nfunction makeLargestSpecial(s) {\n    let count = 0, i = 0;\n    let subs = [];\n\n    for (let j = 0; j < s.length; j++) {\n        if (s[j] === '1') count++;\n        else count--;\n\n        if (count === 0) {\n            subs.push(\"1\" + makeLargestSpecial(s.slice(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    subs.sort((a, b) => b.localeCompare(a));\n    return subs.join('');\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    "
    },
    {
        "id": 712,
        "title": "Partition Labels",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn _a list of integers representing the size of these parts_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ababcbacadefegdehijhklij \"\n**Output:** \\[9,7,8\\]\n**Explanation:**\nThe partition is  \"ababcbaca \",  \"defegde \",  \"hijhklij \".\nThis is a partition so that each letter appears in at most one part.\nA partition like  \"ababcbacadefegde \",  \"hijhklij \" is incorrect, because it splits s into less parts.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"eccbbbbdec \"\n**Output:** \\[10\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"ababcbacadefegdehijhklij\"",
                "output": "[9,7,8]"
            },
            {
                "input": "\"eccbbbbdec\"",
                "output": "[10]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> partitionLabels(String s) {\n    Map<Character, Integer> last = new HashMap<>();\n    for (int i = 0; i < s.length(); i++) {\n        last.put(s.charAt(i), i);\n    }\n    List<Integer> ans = new ArrayList<>();\n    int j = 0, anchor = 0;\n    for (int i = 0; i < s.length(); i++) {\n        j = Math.max(j, last.get(s.charAt(i)));\n        if (i == j) {\n            ans.add(i - anchor + 1);\n            anchor = i + 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ",
        "python": "\n    ```python\ndef partition_labels(s):\n    last = {c:i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n    return ans\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> partitionLabels(std::string s) {\n    std::unordered_map<char, int> last;\n    for (int i = 0; i < s.size(); i++) {\n        last[s[i]] = i;\n    }\n    std::vector<int> ans;\n    int j = 0, anchor = 0;\n    for (int i = 0; i < s.size(); i++) {\n        j = std::max(j, last[s[i]]);\n        if (i == j) {\n            ans.push_back(i - anchor + 1);\n            anchor = i + 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    ",
        "js": "\n    ```javascript\nfunction partitionLabels(s) {\n    const last = {};\n    for (let i = 0; i < s.length; i++) {\n        last[s[i]] = i;\n    }\n    const ans = [];\n    let j = 0, anchor = 0;\n    for (let i = 0; i < s.length; i++) {\n        j = Math.max(j, last[s[i]]);\n        if (i === j) {\n            ans.push(i - anchor + 1);\n            anchor = i + 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a greedy approach to solve the problem. In the first step, we loop through the input string and keep track of the last index of each character in a dictionary/hashmap. Then, we loop through the string again and keep track of the farthest index of the encountered characters. If the current index is equal to the farthest index of the encountered characters, then we know that we can partition the string at this index. We append the partition length to the answer list and update the anchor variable to the index after the current index. We continue this process for the entire input string and return the list of partition lengths.\n    "
    },
    {
        "id": 714,
        "title": "Couples Holding Hands",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.",
            "examples": [
                "**Example 1:**\n\n**Input:** row = \\[0,2,1,3\\]\n**Output:** 1\n**Explanation:** We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person.\n\n",
                "**Example 2:**\n\n**Input:** row = \\[3,2,0,1\\]\n**Output:** 0\n**Explanation:** All couples are already seated side by side."
            ],
            "constraints": "**Constraints:**\n\n*   `2n == row.length`\n*   `2 <= n <= 30`\n*   `n` is even.\n*   `0 <= row[i] < 2n`\n*   All the elements of `row` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Greedy",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "[0,2,1,3]",
                "output": "1"
            },
            {
                "input": "[3,2,0,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minSwapsCouples(int[] row) {\n    int n = row.length;\n    int[] position = new int[n];\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            int temp = row[position[partner]];\n            row[position[partner]] = row[i + 1];\n            row[i + 1] = temp;\n            \n            temp = position[row[i + 1]];\n            position[row[i + 1]] = position[partner];\n            position[partner] = temp;\n            \n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "python": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "c++": "\n    ```cpp\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size();\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            swap(row[position[partner]], row[i + 1]);\n            swap(position[row[i + 1]], position[partner]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "js": "\n    ```javascript\nfunction minSwapsCouples(row) {\n    const n = row.length;\n    const position = new Array(n);\n    for (let i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    let swaps = 0;\n    for (let i = 0; i < n; i += 2) {\n        const partner = row[i] % 2 === 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== partner) {\n            [row[position[partner]], row[i + 1]] = [row[i + 1], row[position[partner]]];\n            [position[row[i + 1]], position[partner]] = [position[partner], position[row[i + 1]]];\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    "
    },
    {
        "id": 720,
        "title": "Jewels and Stones",
        "difficulty": "Easy",
        "content": {
            "problem": "You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\nLetters are case sensitive, so `\"a \"` is considered a different type of stone from `\"A \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** jewels = \"aA\", stones = \"aAAbbbb\"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** jewels = \"z\", stones = \"ZZ\"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= jewels.length, stones.length <= 50`\n*   `jewels` and `stones` consist of only English letters.\n*   All the characters of `jewels` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"aA\",\"aAAbbbb\"",
                "output": "3"
            },
            {
                "input": "\"z\",\"ZZ\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char stone : stones.toCharArray()) {\n        if (jewels.indexOf(stone) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "python": "\n    ```python\ndef num_jewels_in_stones(jewels: str, stones: str) -> int:\n    count = 0\n    for stone in stones:\n        if stone in jewels:\n            count += 1\n    return count\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "c++": "\n    ```cpp\nint numJewelsInStones(string jewels, string stones) {\n    int count = 0;\n    for (char stone : stones) {\n        if (jewels.find(stone) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "js": "\n    ```javascript\nfunction numJewelsInStones(jewels, stones) {\n    let count = 0;\n    for (let stone of stones) {\n        if (jewels.indexOf(stone) !== -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    "
    },
    {
        "id": 737,
        "title": "Rotated Digits",
        "difficulty": "Medium",
        "content": {
            "problem": "An integer `x` is a **good** if after rotating each digit individually by 180 degrees, we get a valid number that is different from `x`. Each digit must be rotated - we cannot choose to leave it alone.\n\nA number is valid if each digit remains a digit after rotation. For example:\n\n*   `0`, `1`, and `8` rotate to themselves,\n*   `2` and `5` rotate to each other (in this case they are rotated in a different direction, in other words, `2` or `5` gets mirrored),\n*   `6` and `9` rotate to each other, and\n*   the rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer `n`, return _the number of **good** integers in the range_ `[1, n]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** There are four good numbers in the range \\[1, 10\\] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "10",
                "output": "4"
            },
            {
                "input": "1",
                "output": "0"
            },
            {
                "input": "2",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int rotatedDigits(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (isGood(i))\n            count++;\n    }\n    return count;\n}\n\nprivate boolean isGood(int num) {\n    boolean changed = false;\n    while (num != 0) {\n        int digit = num % 10;\n        if (digit == 3 || digit == 4 || digit == 7) return false;\n        if (digit == 2 || digit == 5 || digit == 6 || digit == 9) changed = true;\n        num /= 10;\n    }\n    return changed;\n}\n```\n    \n    The algorithm will use two main functions, one to check if a number is a good number (`isGood`) and the main one to count such numbers (`rotatedDigits`).\n\n1. Create a variable called `count` to store the count of good numbers.\n2. Iterate from 1 to the given number `n`.\n3. For each number, call the `isGood` function to check if it's a good number.\n4. If it is a good number, increment the `count`.\n5. The `isGood` function takes an integer as input and checks if it's a good number:\n    - Check each digit of the number while the number is greater than 0.\n    - If the digit is 3, 4 or 7, then the number is not a good number (return false).\n    - If the digit is 2, 5, 6 or 9, then the number is changed after rotation, set the `changed` flag as true.\n    - Remove the last digit of the number by dividing it by 10.\n    - If the `changed` flag is true, then the number is a good number (return true), otherwise return false.\n6. Return the `count`.\n    ",
        "python": "\n    ```python\ndef rotatedDigits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if isGood(i):\n            count += 1\n    return count\n\ndef isGood(num: int) -> bool:\n    changed = False\n    while num:\n        digit = num % 10\n        if digit in (3, 4, 7):\n            return False\n        if digit in (2, 5, 6, 9):\n            changed = True\n        num //= 10\n    return changed\n```\n    \n    The algorithm will use two main functions, one to check if a number is a good number (`isGood`) and the main one to count such numbers (`rotatedDigits`).\n\n1. Create a variable called `count` to store the count of good numbers.\n2. Iterate from 1 to the given number `n`.\n3. For each number, call the `isGood` function to check if it's a good number.\n4. If it is a good number, increment the `count`.\n5. The `isGood` function takes an integer as input and checks if it's a good number:\n    - Check each digit of the number while the number is greater than 0.\n    - If the digit is 3, 4 or 7, then the number is not a good number (return false).\n    - If the digit is 2, 5, 6 or 9, then the number is changed after rotation, set the `changed` flag as true.\n    - Remove the last digit of the number by dividing it by 10.\n    - If the `changed` flag is true, then the number is a good number (return true), otherwise return false.\n6. Return the `count`.\n    ",
        "c++": "\n    ```cpp\nint rotatedDigits(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (isGood(i))\n            count++;\n    }\n    return count;\n}\n\nbool isGood(int num) {\n    bool changed = false;\n    while (num) {\n        int digit = num % 10;\n        if (digit == 3 || digit == 4 || digit == 7) return false;\n        if (digit == 2 || digit == 5 || digit == 6 || digit == 9) changed = true;\n        num /= 10;\n    }\n    return changed;\n}\n```\n    \n    The algorithm will use two main functions, one to check if a number is a good number (`isGood`) and the main one to count such numbers (`rotatedDigits`).\n\n1. Create a variable called `count` to store the count of good numbers.\n2. Iterate from 1 to the given number `n`.\n3. For each number, call the `isGood` function to check if it's a good number.\n4. If it is a good number, increment the `count`.\n5. The `isGood` function takes an integer as input and checks if it's a good number:\n    - Check each digit of the number while the number is greater than 0.\n    - If the digit is 3, 4 or 7, then the number is not a good number (return false).\n    - If the digit is 2, 5, 6 or 9, then the number is changed after rotation, set the `changed` flag as true.\n    - Remove the last digit of the number by dividing it by 10.\n    - If the `changed` flag is true, then the number is a good number (return true), otherwise return false.\n6. Return the `count`.\n    ",
        "js": "\n    ```javascript\nfunction rotatedDigits(n) {\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        if (isGood(i))\n            count++;\n    }\n    return count;\n}\n\nfunction isGood(num) {\n    let changed = false;\n    while (num) {\n        let digit = num % 10;\n        if (digit === 3 || digit === 4 || digit === 7) return false;\n        if (digit === 2 || digit === 5 || digit === 6 || digit === 9) changed = true;\n        num = Math.floor(num / 10);\n    }\n    return changed;\n}\n```\n    \n    The algorithm will use two main functions, one to check if a number is a good number (`isGood`) and the main one to count such numbers (`rotatedDigits`).\n\n1. Create a variable called `count` to store the count of good numbers.\n2. Iterate from 1 to the given number `n`.\n3. For each number, call the `isGood` function to check if it's a good number.\n4. If it is a good number, increment the `count`.\n5. The `isGood` function takes an integer as input and checks if it's a good number:\n    - Check each digit of the number while the number is greater than 0.\n    - If the digit is 3, 4 or 7, then the number is not a good number (return false).\n    - If the digit is 2, 5, 6 or 9, then the number is changed after rotation, set the `changed` flag as true.\n    - Remove the last digit of the number by dividing it by 10.\n    - If the `changed` flag is true, then the number is a good number (return true), otherwise return false.\n6. Return the `count`.\n    "
    },
    {
        "id": 740,
        "title": "Custom Sort String",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two strings order and s. All the characters of `order` are **unique** and were sorted in some custom order previously.\n\nPermute the characters of `s` so that they match the order that `order` was sorted. More specifically, if a character `x` occurs before a character `y` in `order`, then `x` should occur before `y` in the permuted string.\n\nReturn _any permutation of_ `s` _that satisfies this property_.",
            "examples": [
                "**Example 1:**\n\n**Input:** order =  \"cba \", s =  \"abcd \"\n**Output:**  \"cbad \"\n**Explanation:** \n \"a \",  \"b \",  \"c \" appear in order, so the order of  \"a \",  \"b \",  \"c \" should be  \"c \",  \"b \", and  \"a \". \nSince  \"d \" does not appear in order, it can be at any position in the returned string.  \"dcba \",  \"cdba \",  \"cbda \" are also valid outputs.\n\n",
                "**Example 2:**\n\n**Input:** order =  \"cbafg \", s =  \"abcd \"\n**Output:**  \"cbad \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= order.length <= 26`\n*   `1 <= s.length <= 200`\n*   `order` and `s` consist of lowercase English letters.\n*   All the characters of `order` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"cba\",\"abcd\"",
                "output": "\"cbad\""
            },
            {
                "input": "\"cbafg\",\"abcd\"",
                "output": "\"cbad\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String customSortString(String order, String s) {\n    HashMap<Character, Integer> priority = new HashMap<>();\n    for (int i = 0; i < order.length(); i++) {\n        priority.put(order.charAt(i), i);\n    }\n\n    Character[] sChars = s.chars().mapToObj(c -> (char) c).toArray(Character[]::new);\n    Arrays.sort(sChars, (a, b) -> priority.getOrDefault(a, 0) - priority.getOrDefault(b, 0));\n    return Arrays.stream(sChars).map(String::valueOf).collect(Collectors.joining());\n}\n```\n    \n    1. Create a hash map or dictionary `priority`, where the key is the character from the `order` string, and the value is its position.\n2. Sort the characters in the input string `s` based on the values in the `priority` hash map. If a character is not found in the map, set its priority to 0.\n3. Join the sorted characters to form the resulting string and return it.\n    ",
        "python": "\n    ```python\ndef customSortString(order, s):\n    priority = {char: idx for idx, char in enumerate(order)}\n    return \"\".join(sorted(s, key=lambda x: priority.get(x, 0)))\n```\n    \n    1. Create a hash map or dictionary `priority`, where the key is the character from the `order` string, and the value is its position.\n2. Sort the characters in the input string `s` based on the values in the `priority` hash map. If a character is not found in the map, set its priority to 0.\n3. Join the sorted characters to form the resulting string and return it.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n#include <unordered_map>\n\nstd::string customSortString(const std::string& order, std::string& s) {\n    std::unordered_map<char, int> priority;\n    for (int i = 0; i < order.size(); i++) {\n        priority[order[i]] = i;\n    }\n\n    std::sort(s.begin(), s.end(), [&](char a, char b) {\n        return priority[a] < priority[b];\n    });\n\n    return s;\n}\n```\n    \n    1. Create a hash map or dictionary `priority`, where the key is the character from the `order` string, and the value is its position.\n2. Sort the characters in the input string `s` based on the values in the `priority` hash map. If a character is not found in the map, set its priority to 0.\n3. Join the sorted characters to form the resulting string and return it.\n    ",
        "js": "\n    ```javascript\nfunction customSortString(order, s) {\n    const priority = new Map();\n    for (let i = 0; i < order.length; i++) {\n        priority.set(order[i], i);\n    }\n\n    const sArr = Array.from(s);\n    sArr.sort((a, b) => (priority.has(a) ? priority.get(a) : 0) - (priority.has(b) ? priority.get(b) : 0));\n    return sArr.join('');\n}\n```\n    \n    1. Create a hash map or dictionary `priority`, where the key is the character from the `order` string, and the value is its position.\n2. Sort the characters in the input string `s` based on the values in the `priority` hash map. If a character is not found in the map, set its priority to 0.\n3. Join the sorted characters to form the resulting string and return it.\n    "
    },
    {
        "id": 794,
        "title": "Longest Mountain in Array",
        "difficulty": "Medium",
        "content": {
            "problem": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,1,4,7,3,2,5\\]\n**Output:** 5\n**Explanation:** The largest mountain is \\[1,4,7,3,2\\] which has length 5.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[2,2,2\\]\n**Output:** 0\n**Explanation:** There is no mountain."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\n\n**",
            "follow_up": "Follow up:**\n\n*   Can you solve it using only one pass?\n*   Can you solve it in `O(1)` space?"
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[2,1,4,7,3,2,5]",
                "output": "5"
            },
            {
                "input": "[2,2,2]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int longestMountain(int[] arr) {\n    int n = arr.length;\n    int res = 0, up = 0, down = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if ((down != 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i]) {\n            up = down = 0;\n        }\n\n        if (arr[i - 1] < arr[i]) up++;\n        if (arr[i - 1] > arr[i]) down++;\n\n        if (up != 0 && down != 0) {\n            res = Math.max(res, up + down + 1);\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm uses one pass with two pointers and maintains two counters, \"up\" and \"down\". It begins at the 1st index, iterating through the array. If the current element is greater than the previous, it increases the \"up\" counter; otherwise, if it's less than the previous, it increases the \"down\" counter. Every time a mountain is identified (when both \"up\" and \"down\" are non-zero), the maximum length is updated. If some conditions are met, such as a new ascending sequence interruption or equal adjacent elements, reset the \"up\" and \"down\" counters to zero. Finally, return the maximum length of a mountain subarray found.\n\nThis solution executes in O(n) time with O(1) space complexity.\n    ",
        "python": "\n    ```python\ndef longestMountain(arr):\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res\n```\n    \n    The algorithm uses one pass with two pointers and maintains two counters, \"up\" and \"down\". It begins at the 1st index, iterating through the array. If the current element is greater than the previous, it increases the \"up\" counter; otherwise, if it's less than the previous, it increases the \"down\" counter. Every time a mountain is identified (when both \"up\" and \"down\" are non-zero), the maximum length is updated. If some conditions are met, such as a new ascending sequence interruption or equal adjacent elements, reset the \"up\" and \"down\" counters to zero. Finally, return the maximum length of a mountain subarray found.\n\nThis solution executes in O(n) time with O(1) space complexity.\n    ",
        "c++": "\n    ```cpp\nint longestMountain(vector<int>& arr) {\n    int n = arr.size(), res = 0, up = 0, down = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (down && arr[i - 1] < arr[i] || arr[i - 1] == arr[i]) {\n            up = down = 0;\n        }\n\n        up += arr[i - 1] < arr[i];\n        down += arr[i - 1] > arr[i];\n\n        if (up && down) {\n            res = max(res, up + down + 1);\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm uses one pass with two pointers and maintains two counters, \"up\" and \"down\". It begins at the 1st index, iterating through the array. If the current element is greater than the previous, it increases the \"up\" counter; otherwise, if it's less than the previous, it increases the \"down\" counter. Every time a mountain is identified (when both \"up\" and \"down\" are non-zero), the maximum length is updated. If some conditions are met, such as a new ascending sequence interruption or equal adjacent elements, reset the \"up\" and \"down\" counters to zero. Finally, return the maximum length of a mountain subarray found.\n\nThis solution executes in O(n) time with O(1) space complexity.\n    ",
        "js": "\n    ```javascript\nfunction longestMountain(arr) {\n    let n = arr.length, res = 0, up = 0, down = 0;\n\n    for (let i = 1; i < n; ++i) {\n        if (down && arr[i - 1] < arr[i] || arr[i - 1] == arr[i]) {\n            up = down = 0;\n        }\n\n        if (arr[i - 1] < arr[i]) up++;\n        if (arr[i - 1] > arr[i]) down++;\n\n        if (up && down) {\n            res = Math.max(res, up + down + 1);\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm uses one pass with two pointers and maintains two counters, \"up\" and \"down\". It begins at the 1st index, iterating through the array. If the current element is greater than the previous, it increases the \"up\" counter; otherwise, if it's less than the previous, it increases the \"down\" counter. Every time a mountain is identified (when both \"up\" and \"down\" are non-zero), the maximum length is updated. If some conditions are met, such as a new ascending sequence interruption or equal adjacent elements, reset the \"up\" and \"down\" counters to zero. Finally, return the maximum length of a mountain subarray found.\n\nThis solution executes in O(n) time with O(1) space complexity.\n    "
    },
    {
        "id": 923,
        "title": "Subarray Sums Divisible by K",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the number of non-empty **subarrays** that have a sum divisible by_ `k`.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,5,0,-2,-3,1\\], k = 5\n**Output:** 7\n**Explanation:** There are 7 subarrays with a sum divisible by k = 5:\n\\[4, 5, 0, -2, -3, 1\\], \\[5\\], \\[5, 0\\], \\[5, 0, -2, -3\\], \\[0\\], \\[0, -2, -3\\], \\[-2, -3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5\\], k = 9\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-104 <= nums[i] <= 104`\n*   `2 <= k <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[4,5,0,-2,-3,1],5",
                "output": "7"
            },
            {
                "input": "[5],9",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int subarraysDivByK(int[] nums, int k) {\n    int[] prefixSumsModK = new int[k];\n    prefixSumsModK[0] = 1;\n    int runningSum = 0;\n    int count = 0;\n    \n    for (int i = 0; i < nums.length; ++i) {\n        runningSum += nums[i];\n        int mod = (runningSum % k + k) % k;\n        count += prefixSumsModK[mod]++;\n    }\n    \n    return count;\n}\n```\n    \n    1. Initialize a list (or array) called `prefixSumsModK` with a size `k` and value 0. Set the first element of `prefixSumsModK` to 1.\n2. Initialize variables `runningSum` and `count` both equal to 0.\n3. Iterate through the input array `nums`.\n4. For each element, add it to `runningSum`.\n5. Calculate the modulus of `runningSum` divided by `k`. To ensure the result is positive, add `k` to the result and calculate the modulus again.\n6. Increment the count by the value at the index `mod` in the `prefixSumsModK` list.\n7. Increment the value at the index `mod` in the `prefixSumsModK` list.\n8. Return `count` after the loop.\n\nThis algorithm uses the prefix sum with mod k to efficiently count the subarrays with a sum divisible by k.\n    ",
        "python": "\n    ```python\ndef subarraysDivByK(nums, k):\n    prefix_sums_mod_k = [0] * k\n    prefix_sums_mod_k[0] = 1\n    running_sum = 0\n    count = 0\n    \n    for num in nums:\n        running_sum += num\n        mod = (running_sum % k + k) % k\n        count += prefix_sums_mod_k[mod]\n        prefix_sums_mod_k[mod] += 1\n    \n    return count\n```\n    \n    1. Initialize a list (or array) called `prefixSumsModK` with a size `k` and value 0. Set the first element of `prefixSumsModK` to 1.\n2. Initialize variables `runningSum` and `count` both equal to 0.\n3. Iterate through the input array `nums`.\n4. For each element, add it to `runningSum`.\n5. Calculate the modulus of `runningSum` divided by `k`. To ensure the result is positive, add `k` to the result and calculate the modulus again.\n6. Increment the count by the value at the index `mod` in the `prefixSumsModK` list.\n7. Increment the value at the index `mod` in the `prefixSumsModK` list.\n8. Return `count` after the loop.\n\nThis algorithm uses the prefix sum with mod k to efficiently count the subarrays with a sum divisible by k.\n    ",
        "c++": "\n    ```cpp\nint subarraysDivByK(vector<int>& nums, int k) {\n    vector<int> prefixSumsModK(k, 0);\n    prefixSumsModK[0] = 1;\n    int runningSum = 0;\n    int count = 0;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        runningSum += nums[i];\n        int mod = (runningSum % k + k) % k;\n        count += prefixSumsModK[mod]++;\n    }\n    \n    return count;\n}\n```\n    \n    1. Initialize a list (or array) called `prefixSumsModK` with a size `k` and value 0. Set the first element of `prefixSumsModK` to 1.\n2. Initialize variables `runningSum` and `count` both equal to 0.\n3. Iterate through the input array `nums`.\n4. For each element, add it to `runningSum`.\n5. Calculate the modulus of `runningSum` divided by `k`. To ensure the result is positive, add `k` to the result and calculate the modulus again.\n6. Increment the count by the value at the index `mod` in the `prefixSumsModK` list.\n7. Increment the value at the index `mod` in the `prefixSumsModK` list.\n8. Return `count` after the loop.\n\nThis algorithm uses the prefix sum with mod k to efficiently count the subarrays with a sum divisible by k.\n    ",
        "js": "\n    ```javascript\nfunction subarraysDivByK(nums, k) {\n    let prefixSumsModK = new Array(k).fill(0);\n    prefixSumsModK[0] = 1;\n    let runningSum = 0;\n    let count = 0;\n    \n    for (let i = 0; i < nums.length; ++i) {\n        runningSum += nums[i];\n        let mod = (runningSum % k + k) % k;\n        count += prefixSumsModK[mod]++;\n    }\n    \n    return count;\n}\n```\n    \n    1. Initialize a list (or array) called `prefixSumsModK` with a size `k` and value 0. Set the first element of `prefixSumsModK` to 1.\n2. Initialize variables `runningSum` and `count` both equal to 0.\n3. Iterate through the input array `nums`.\n4. For each element, add it to `runningSum`.\n5. Calculate the modulus of `runningSum` divided by `k`. To ensure the result is positive, add `k` to the result and calculate the modulus again.\n6. Increment the count by the value at the index `mod` in the `prefixSumsModK` list.\n7. Increment the value at the index `mod` in the `prefixSumsModK` list.\n8. Return `count` after the loop.\n\nThis algorithm uses the prefix sum with mod k to efficiently count the subarrays with a sum divisible by k.\n    "
    },
    {
        "id": 946,
        "title": "Find the Town Judge",
        "difficulty": "Easy",
        "content": {
            "problem": "In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n\n1.  The town judge trusts nobody.\n2.  Everybody (except for the town judge) trusts the town judge.\n3.  There is exactly one person that satisfies properties **1** and **2**.\n\nYou are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. If a trust relationship does not exist in `trust` array, then such a trust relationship does not exist.\n\nReturn _the label of the town judge if the town judge exists and can be identified, or return_ `-1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, trust = \\[\\[1,2\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 3, trust = \\[\\[1,3\\],\\[2,3\\]\\]\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** n = 3, trust = \\[\\[1,3\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= trust.length <= 104`\n*   `trust[i].length == 2`\n*   All the pairs of `trust` are **unique**.\n*   `ai != bi`\n*   `1 <= ai, bi <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Graph"
        ],
        "example": [
            {
                "input": "2,[[1,2]]",
                "output": "2"
            },
            {
                "input": "3,[[1,3],[2,3]]",
                "output": "3"
            },
            {
                "input": "3,[[1,3],[2,3],[3,1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findJudge(int n, int[][] trust) {\n    int[] trustCounts = new int[n + 1];\n    for (int[] t : trust) {\n        trustCounts[t[0]]--;\n        trustCounts[t[1]]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "python": "\n    ```python\ndef findJudge(n, trust):\n    trust_counts = [0] * (n + 1)\n    for a, b in trust:\n        trust_counts[a] -= 1\n        trust_counts[b] += 1\n    for i in range(1, n + 1):\n        if trust_counts[i] == n - 1:\n            return i\n    return -1\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint findJudge(int n, vector<vector<int>>& trust) {\n    vector<int> trustCounts(n + 1, 0);\n    for (auto& t : trust) {\n        trustCounts[t[0]]--;\n        trustCounts[t[1]]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findJudge(n, trust) {\n    let trustCounts = new Array(n + 1).fill(0);\n    for (let [a, b] of trust) {\n        trustCounts[a]--;\n        trustCounts[b]++;\n    }\n    for (let i = 1; i <= n; i++) {\n        if (trustCounts[i] === n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    "
    },
    {
        "id": 964,
        "title": "Smallest Integer Divisible by K",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a positive integer `k`, you need to find the **length** of the **smallest** positive integer `n` such that `n` is divisible by `k`, and `n` only contains the digit `1`.\n\nReturn _the **length** of_ `n`. If there is no such `n`, return -1.\n\n**Note:** `n` may not fit in a 64-bit signed integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 1\n**Output:** 1\n**Explanation:** The smallest answer is n = 1, which has length 1.\n\n",
                "**Example 2:**\n\n**Input:** k = 2\n**Output:** -1\n**Explanation:** There is no such positive integer n divisible by 2.\n\n",
                "**Example 3:**\n\n**Input:** k = 3\n**Output:** 3\n**Explanation:** The smallest answer is n = 111, which has length 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 105`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math"
        ],
        "example": [
            {
                "input": "1",
                "output": "1"
            },
            {
                "input": "2",
                "output": "-1"
            },
            {
                "input": "3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int smallestRepunitDivByK(int k) {\n    if (k % 2 == 0 || k % 5 == 0) return -1;\n    int n = 0;\n    for (int i = 1; i <= k; i++) {\n        n = (n * 10 + 1) % k;\n        if (n == 0) return i;\n    }\n    return -1;\n}\n```\n    \n    The algorithm starts by checking if k is divisible by 2 or 5. If it is, we return -1, because no number consisting of only the digit 1 can be divisible by 2 or 5. Then, we initialize a variable `n` to 0. We loop from 1 to k, and at each iteration, we multiply the current `n` by 10, add 1, and take the remainder when divided by k. If the remainder becomes 0, we return the current iteration index, since this indicates that we've found the smallest number consisting of only the digit 1 that is divisible by k. If after the loop, we haven't found such a number, we return -1.\n    ",
        "python": "\n    ```python\ndef smallestRepunitDivByK(k: int) -> int:\n    if k % 2 == 0 or k % 5 == 0:\n        return -1\n    n = 0\n    for i in range(1, k + 1):\n        n = (n * 10 + 1) % k\n        if n == 0:\n            return i\n    return -1\n```\n    \n    The algorithm starts by checking if k is divisible by 2 or 5. If it is, we return -1, because no number consisting of only the digit 1 can be divisible by 2 or 5. Then, we initialize a variable `n` to 0. We loop from 1 to k, and at each iteration, we multiply the current `n` by 10, add 1, and take the remainder when divided by k. If the remainder becomes 0, we return the current iteration index, since this indicates that we've found the smallest number consisting of only the digit 1 that is divisible by k. If after the loop, we haven't found such a number, we return -1.\n    ",
        "c++": "\n    ```cpp\nint smallestRepunitDivByK(int k) {\n    if (k % 2 == 0 || k % 5 == 0) return -1;\n    int n = 0;\n    for (int i = 1; i <= k; i++) {\n        n = (n * 10 + 1) % k;\n        if (n == 0) return i;\n    }\n    return -1;\n}\n```\n    \n    The algorithm starts by checking if k is divisible by 2 or 5. If it is, we return -1, because no number consisting of only the digit 1 can be divisible by 2 or 5. Then, we initialize a variable `n` to 0. We loop from 1 to k, and at each iteration, we multiply the current `n` by 10, add 1, and take the remainder when divided by k. If the remainder becomes 0, we return the current iteration index, since this indicates that we've found the smallest number consisting of only the digit 1 that is divisible by k. If after the loop, we haven't found such a number, we return -1.\n    ",
        "js": "\n    ```javascript\nfunction smallestRepunitDivByK(k) {\n    if (k % 2 === 0 || k % 5 === 0) return -1;\n    let n = 0;\n    for (let i = 1; i <= k; i++) {\n        n = (n * 10 + 1) % k;\n        if (n === 0) return i;\n    }\n    return -1;\n}\n```\n    \n    The algorithm starts by checking if k is divisible by 2 or 5. If it is, we return -1, because no number consisting of only the digit 1 can be divisible by 2 or 5. Then, we initialize a variable `n` to 0. We loop from 1 to k, and at each iteration, we multiply the current `n` by 10, add 1, and take the remainder when divided by k. If the remainder becomes 0, we return the current iteration index, since this indicates that we've found the smallest number consisting of only the digit 1 that is divisible by k. If after the loop, we haven't found such a number, we return -1.\n    "
    },
    {
        "id": 998,
        "title": "Height Checker",
        "difficulty": "Easy",
        "content": {
            "problem": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in **non-decreasing order** by height. Let this ordering be represented by the integer array `expected` where `expected[i]` is the expected height of the `ith` student in line.\n\nYou are given an integer array `heights` representing the **current order** that the students are standing in. Each `heights[i]` is the height of the `ith` student in line (**0-indexed**).\n\nReturn _the **number of indices** where_ `heights[i] != expected[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[1,1,4,2,1,3\\]\n**Output:** 3\n**Explanation:** \nheights:  \\[1,1,4,2,1,3\\]\nexpected: \\[1,1,1,2,3,4\\]\nIndices 2, 4, and 5 do not match.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[5,1,2,3,4\\]\n**Output:** 5\n**Explanation:**\nheights:  \\[5,1,2,3,4\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices do not match.\n\n",
                "**Example 3:**\n\n**Input:** heights = \\[1,2,3,4,5\\]\n**Output:** 0\n**Explanation:**\nheights:  \\[1,2,3,4,5\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices match."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 100`\n*   `1 <= heights[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Counting Sort"
        ],
        "example": [
            {
                "input": "[1,1,4,2,1,3]",
                "output": "3"
            },
            {
                "input": "[5,1,2,3,4]",
                "output": "5"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int heightChecker(int[] heights) {\n    int[] expected = heights.clone();\n    Arrays.sort(expected);\n\n    int count = 0;\n    for (int i = 0; i < heights.length; ++i) {\n        if (heights[i] != expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "python": "\n    ```python\ndef height_checker(heights):\n    expected = sorted(heights)\n    \n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n            \n    return count\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> expected = heights;\n    std::sort(expected.begin(), expected.end());\n\n    int count = 0;\n    for (int i = 0; i < heights.size(); ++i) {\n        if (heights[i] != expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "js": "\n    ```javascript\nfunction heightChecker(heights) {\n    const expected = [...heights].sort((a, b) => a - b);\n\n    let count = 0;\n    for (let i = 0; i < heights.length; ++i) {\n        if (heights[i] !== expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    "
    },
    {
        "id": 999,
        "title": "Grumpy Bookstore Owner",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a bookstore owner that has a store open for `n` minutes. Every minute, some number of customers enter the store. You are given an integer array `customers` of length `n` where `customers[i]` is the number of the customer that enters the store at the start of the `ith` minute and all those customers leave after the end of that minute.\n\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where `grumpy[i]` is `1` if the bookstore owner is grumpy during the `ith` minute, and is `0` otherwise.\n\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n\nThe bookstore owner knows a secret technique to keep themselves not grumpy for `minutes` consecutive minutes, but can only use it once.\n\nReturn _the maximum number of customers that can be satisfied throughout the day_.",
            "examples": [
                "**Example 1:**\n\n**Input:** customers = \\[1,0,1,2,1,1,7,5\\], grumpy = \\[0,1,0,1,0,1,0,1\\], minutes = 3\n**Output:** 16\n**Explanation:** The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n",
                "**Example 2:**\n\n**Input:** customers = \\[1\\], grumpy = \\[0\\], minutes = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == customers.length == grumpy.length`\n*   `1 <= minutes <= n <= 2 * 104`\n*   `0 <= customers[i] <= 1000`\n*   `grumpy[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[1,0,1,2,1,1,7,5],[0,1,0,1,0,1,0,1],3",
                "output": "16"
            },
            {
                "input": "[1],[0],1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\n    int total_customers = 0, max_extra_customers = 0, extra_customers = 0;\n    for (int i = 0; i < customers.length; ++i) {\n        if (grumpy[i] == 0) {\n            total_customers += customers[i];\n        }\n        if (i < minutes) {\n            extra_customers += customers[i] * grumpy[i];\n        } else {\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes]);\n        }\n        max_extra_customers = Math.max(max_extra_customers, extra_customers);\n    }\n    return total_customers + max_extra_customers;\n}\n```\n\n    \n    First, we need to calculate the initial sum of satisfied customers which we do by looping through the `customers` array and checking if the bookstore owner is grumpy at that minute, i.e., `grumpy[i] == 0`. If the bookstore owner is not grumpy, we add the customers at that minute to `total_customers`. \n\nThen, we need to find the maximum possible number of extra customers that can be satisfied by using the secret technique for `minutes` minutes. Initialise two variables, `max_extra_customers` and `extra_customers`, to 0. Iterate through the `customers` array again. If the current minute, `i`, is less than `minutes`, increment `extra_customers` by the product of `customers[i]` and `grumpy[i]`. Otherwise, increment `extra_customers` by adding the product of `customers[i]` and `grumpy[i]` and subtracting the product of `customers[i - minutes]` and `grumpy[i - minutes]`. \n\nUpdate `max_extra_customers` with the maximum of its current value and `extra_customers`. After the iteration, return the sum of `total_customers` and `max_extra_customers` as the maximum number of satisfied customers throughout the day.\n    ",
        "python": "\n    ```python\ndef maxSatisfied(customers, grumpy, minutes):\n    total_customers = 0\n    max_extra_customers = 0\n    extra_customers = 0\n    for i in range(len(customers)):\n        if grumpy[i] == 0:\n            total_customers += customers[i]\n        if i < minutes:\n            extra_customers += customers[i] * grumpy[i]\n        else:\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])\n        max_extra_customers = max(max_extra_customers, extra_customers)\n    return total_customers + max_extra_customers\n```\n\n    \n    First, we need to calculate the initial sum of satisfied customers which we do by looping through the `customers` array and checking if the bookstore owner is grumpy at that minute, i.e., `grumpy[i] == 0`. If the bookstore owner is not grumpy, we add the customers at that minute to `total_customers`. \n\nThen, we need to find the maximum possible number of extra customers that can be satisfied by using the secret technique for `minutes` minutes. Initialise two variables, `max_extra_customers` and `extra_customers`, to 0. Iterate through the `customers` array again. If the current minute, `i`, is less than `minutes`, increment `extra_customers` by the product of `customers[i]` and `grumpy[i]`. Otherwise, increment `extra_customers` by adding the product of `customers[i]` and `grumpy[i]` and subtracting the product of `customers[i - minutes]` and `grumpy[i - minutes]`. \n\nUpdate `max_extra_customers` with the maximum of its current value and `extra_customers`. After the iteration, return the sum of `total_customers` and `max_extra_customers` as the maximum number of satisfied customers throughout the day.\n    ",
        "c++": "\n    ```cpp\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\n    int total_customers = 0, max_extra_customers = 0, extra_customers = 0;\n    for (int i = 0; i < customers.size(); ++i) {\n        if (grumpy[i] == 0) {\n            total_customers += customers[i];\n        }\n        if (i < minutes) {\n            extra_customers += customers[i] * grumpy[i];\n        } else {\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes]);\n        }\n        max_extra_customers = max(max_extra_customers, extra_customers);\n    }\n    return total_customers + max_extra_customers;\n}\n```\n\n    \n    First, we need to calculate the initial sum of satisfied customers which we do by looping through the `customers` array and checking if the bookstore owner is grumpy at that minute, i.e., `grumpy[i] == 0`. If the bookstore owner is not grumpy, we add the customers at that minute to `total_customers`. \n\nThen, we need to find the maximum possible number of extra customers that can be satisfied by using the secret technique for `minutes` minutes. Initialise two variables, `max_extra_customers` and `extra_customers`, to 0. Iterate through the `customers` array again. If the current minute, `i`, is less than `minutes`, increment `extra_customers` by the product of `customers[i]` and `grumpy[i]`. Otherwise, increment `extra_customers` by adding the product of `customers[i]` and `grumpy[i]` and subtracting the product of `customers[i - minutes]` and `grumpy[i - minutes]`. \n\nUpdate `max_extra_customers` with the maximum of its current value and `extra_customers`. After the iteration, return the sum of `total_customers` and `max_extra_customers` as the maximum number of satisfied customers throughout the day.\n    ",
        "js": "\n    ```javascript\nfunction maxSatisfied(customers, grumpy, minutes) {\n    let total_customers = 0, max_extra_customers = 0, extra_customers = 0;\n    for (let i = 0; i < customers.length; ++i) {\n        if (grumpy[i] === 0) {\n            total_customers += customers[i];\n        }\n        if (i < minutes) {\n            extra_customers += customers[i] * grumpy[i];\n        } else {\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes]);\n        }\n        max_extra_customers = Math.max(max_extra_customers, extra_customers);\n    }\n    return total_customers + max_extra_customers;\n}\n```\n\n    \n    First, we need to calculate the initial sum of satisfied customers which we do by looping through the `customers` array and checking if the bookstore owner is grumpy at that minute, i.e., `grumpy[i] == 0`. If the bookstore owner is not grumpy, we add the customers at that minute to `total_customers`. \n\nThen, we need to find the maximum possible number of extra customers that can be satisfied by using the secret technique for `minutes` minutes. Initialise two variables, `max_extra_customers` and `extra_customers`, to 0. Iterate through the `customers` array again. If the current minute, `i`, is less than `minutes`, increment `extra_customers` by the product of `customers[i]` and `grumpy[i]`. Otherwise, increment `extra_customers` by adding the product of `customers[i]` and `grumpy[i]` and subtracting the product of `customers[i - minutes]` and `grumpy[i - minutes]`. \n\nUpdate `max_extra_customers` with the maximum of its current value and `extra_customers`. After the iteration, return the sum of `total_customers` and `max_extra_customers` as the maximum number of satisfied customers throughout the day.\n    "
    },
    {
        "id": 1000,
        "title": "Previous Permutation With One Swap",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of positive integers `arr` (not necessarily distinct), return _the_ _lexicographically_ _largest permutation that is smaller than_ `arr`, that can be **made with exactly one swap**. If it cannot be done, then return the same array.\n\n**Note** that a _swap_ exchanges the positions of two numbers `arr[i]` and `arr[j]`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[3,2,1\\]\n**Output:** \\[3,1,2\\]\n**Explanation:** Swapping 2 and 1.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,1,5\\]\n**Output:** \\[1,1,5\\]\n**Explanation:** This is already the smallest permutation.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[1,9,4,6,7\\]\n**Output:** \\[1,7,4,6,9\\]\n**Explanation:** Swapping 9 and 7."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `1 <= arr[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[3,2,1]",
                "output": "[3,1,2]"
            },
            {
                "input": "[1,1,5]",
                "output": "[1,1,5]"
            },
            {
                "input": "[1,9,4,6,7]",
                "output": "[1,7,4,6,9]"
            }
        ],
        "java": "\n    ```java\npublic int[] prevPermOpt1(int[] arr) {\n    int n = arr.length;\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            int j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            int temp = arr[i];\n            arr[i] = arr[j - 1];\n            arr[j - 1] = temp;\n            break;\n        }\n    }\n    return arr;\n}\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ",
        "python": "\n    ```python\ndef prevPermOpt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            break\n    return arr\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> prevPermOpt1(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            int j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            swap(arr[i], arr[j - 1]);\n            break;\n        }\n    }\n    return arr;\n}\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    ",
        "js": "\n    ```javascript\nfunction prevPermOpt1(arr) {\n    const n = arr.length;\n    for (let i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            let j = i + 1;\n            while (j < n && arr[j] < arr[i]) j++;\n            [arr[i], arr[j - 1]] = [arr[j - 1], arr[i]];\n            break;\n        }\n    }\n    return arr;\n}\n```\n\n    \n    The algorithm consists of iterating through the array from right to left to find the first number `arr[i]` that's greater than its immediate right adjacent number, `arr[i + 1]`. Then, it iterates rightwards starting from the `arr[i]` until it finds the number just smaller than `arr[i]`, and it swaps them. This gives the lexicographically largest permutation smaller than `arr` in exactly one swap. If no such number `arr[i]` is found, it means the given array `arr` is already the smallest permutation possible, and the same array is returned.\n    "
    },
    {
        "id": 1009,
        "title": "Longest Repeating Substring",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest repeating substrings_. If no repeating substring exists, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcd \"\n**Output:** 0\n**Explanation:** There is no repeating substring.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abbaba \"\n**Output:** 2\n**Explanation:** The longest repeating substrings are  \"ab \" and  \"ba \", each of which occurs twice.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aabcaabdaab \"\n**Output:** 3\n**Explanation:** The longest repeating substring is  \"aab \", which occurs `3` times."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcd\"",
                "output": "0"
            },
            {
                "input": "\"abbaba\"",
                "output": "2"
            },
            {
                "input": "\"aabcaabdaab\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findLongestRepeatingSubstring(String s) {\n    int n = s.length();\n    int maxSubstrLength = 0;\n    for (int len = 1; len <= n / 2; ++len) {\n        int maxRepeatCount = 0, repeatCount = 0;\n        for (int i = 0; i < n - len; ++i) {\n            if (s.substring(i, i + len).equals(s.substring(i + len, i + 2 * len))) {\n                repeatCount++;\n            } else {\n                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);\n                repeatCount = 0;\n            }\n        }\n        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);\n    }\n    return maxSubstrLength;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ",
        "python": "\n    ```python\ndef find_longest_repeating_substring(s: str) -> int:\n    n = len(s)\n    max_substr_length = 0\n    for length in range(1, n // 2 + 1):\n        max_repeat_count = repeat_count = 0\n        for i in range(n - length):\n            if s[i:i + length] == s[i + length:i + 2 * length]:\n                repeat_count += 1\n            else:\n                max_repeat_count = max(max_repeat_count, repeat_count)\n                repeat_count = 0\n        max_substr_length = max(max_substr_length, max_repeat_count * length)\n    return max_substr_length\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ",
        "c++": "\n    ```cpp\nint findLongestRepeatingSubstring(const std::string &s) {\n    int n = s.length();\n    int max_substr_length = 0;\n    for (int len = 1; len <= n/2; ++len) {\n        int max_repeat_count = 0, repeat_count = 0;\n        for (int i = 0; i < n - len; ++i) {\n            if (s.substr(i, len) == s.substr(i + len, len)) {\n                repeat_count++;\n            } else {\n                max_repeat_count = std::max(max_repeat_count, repeat_count);\n                repeat_count = 0;\n            }\n        }\n        max_substr_length = std::max(max_substr_length, max_repeat_count * len);\n    }\n    return max_substr_length;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ",
        "js": "\n    ```javascript\nfunction findLongestRepeatingSubstring(s) {\n    let n = s.length;\n    let maxSubstrLength = 0;\n    for (let len = 1; len <= n / 2; ++len) {\n        let maxRepeatCount = 0, repeatCount = 0;\n        for (let i = 0; i < n - len; ++i) {\n            if (s.substring(i, i + len) === s.substring(i + len, i + 2 * len)) {\n                repeatCount++;\n            } else {\n                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);\n                repeatCount = 0;\n            }\n        }\n        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);\n    }\n    return maxSubstrLength;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    "
    },
    {
        "id": 1014,
        "title": "Digit Count in Range",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a single-digit integer `d` and two integers `low` and `high`, return _the number of times that_ `d` _occurs as a digit in all integers in the inclusive range_ `[low, high]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** d = 1, low = 1, high = 13\n**Output:** 6\n**Explanation:** The digit d = 1 occurs 6 times in 1, 10, 11, 12, 13.\nNote that the digit d = 1 occurs twice in the number 11.\n\n",
                "**Example 2:**\n\n**Input:** d = 3, low = 100, high = 250\n**Output:** 35\n**Explanation:** The digit d = 3 occurs 35 times in 103,113,123,130,131,...,238,239,243."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= d <= 9`\n*   `1 <= low <= high <= 2 * 108`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1,1,13",
                "output": "6"
            },
            {
                "input": "3,100,250",
                "output": "35"
            }
        ],
        "java": "\n    ```java\npublic int countDigit(int d, int low, int high) {\n    int count = 0;\n    for (int i = low; i <= high; i++) {\n        int num = i;\n        while (num > 0) {\n            if (num % 10 == d) {\n                count++;\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    ",
        "python": "\n    ```python\ndef count_digit(d, low, high):\n    count = 0\n    for i in range(low, high + 1):\n        num = i\n        while num > 0:\n            if num % 10 == d:\n                count += 1\n            num //= 10\n    return count\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    ",
        "c++": "\n    ```cpp\nint countDigit(int d, int low, int high) {\n    int count = 0;\n    for (int i = low; i <= high; ++i) {\n        int num = i;\n        while (num) {\n            if (num % 10 == d) {\n                count++;\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    ",
        "js": "\n    ```javascript\nfunction countDigit(d, low, high) {\n    let count = 0;\n    for (let i = low; i <= high; i++) {\n        let num = i;\n        while (num > 0) {\n            if (num % 10 === d) {\n                count++;\n            }\n            num = Math.floor(num / 10);\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    "
    },
    {
        "id": 1023,
        "title": "Sum of Digits in the Minimum Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `0` _if the sum of the digits of the minimum integer in_ `nums` _is odd, or_ `1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\]\n**Output:** 0\n**Explanation:** The minimal element is 1, and the sum of those digits is 1 which is odd, so the answer is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[99,77,33,66,55\\]\n**Output:** 1\n**Explanation:** The minimal element is 33, and the sum of those digits is 3 + 3 = 6 which is even, so the answer is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[34,23,1,24,75,33,54,8]",
                "output": "0"
            },
            {
                "input": "[99,77,33,66,55]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int sumOfDigits(int[] nums) {\n    int minVal = Arrays.stream(nums).min().getAsInt();\n    int digitSum = 0;\n    while (minVal > 0) {\n        digitSum += minVal % 10;\n        minVal /= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "python": "\n    ```python\ndef sum_of_digits(nums):\n    min_val = min(nums)\n    digit_sum = sum(int(digit) for digit in str(min_val))\n    return 1 if digit_sum % 2 == 0 else 0\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "c++": "\n    ```cpp\nint sumOfDigits(vector<int>& nums) {\n    int minVal = *min_element(nums.begin(), nums.end());\n    int digitSum = 0;\n    while (minVal > 0) {\n        digitSum += minVal % 10;\n        minVal /= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "js": "\n    ```javascript\nfunction sumOfDigits(nums) {\n    const minVal = Math.min(...nums);\n    let digitSum = 0;\n    let temp = minVal;\n    while (temp > 0) {\n        digitSum += temp % 10;\n        temp = Math.floor(temp / 10);\n    }\n    return digitSum % 2 === 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    "
    },
    {
        "id": 1035,
        "title": "Two Sum Less Than K",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\], k = 60\n**Output:** 58\n**Explanation:** We can use 34 and 24 to sum 58 which is less than 60.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,20,30\\], k = 15\n**Output:** -1\n**Explanation:** In this case it is not possible to get a pair sum less that 15."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 1000`\n*   `1 <= k <= 2000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[34,23,1,24,75,33,54,8],60",
                "output": "58"
            },
            {
                "input": "[10,20,30],15",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int maxSumUnderK(int[] nums, int k) {\n    int maxSum = -1;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            int sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "python": "\n    ```python\ndef max_sum_under_k(nums, k):\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "c++": "\n    ```cpp\nint maxSumUnderK(vector<int>& nums, int k) {\n    int maxSum = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            int sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "js": "\n    ```javascript\nfunction maxSumUnderK(nums, k) {\n    let maxSum = -1;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            let sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    "
    },
    {
        "id": 1036,
        "title": "Find K-Length Substrings With No Repeated Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return _the number of substrings in_ `s` _of length_ `k` _with no repeated characters_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"havefunonleetcode \", k = 5\n**Output:** 6\n**Explanation:** There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"home \", k = 5\n**Output:** 0\n**Explanation:** Notice k can be larger than the length of s. In this case, it is not possible to find any substring."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"havefunonleetcode\",5",
                "output": "6"
            },
            {
                "input": "\"home\",5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numKLenSubstrNoRepeats(String s, int k) {\n    int n = s.length();\n    if (k > n) return 0;\n    \n    int result = 0;\n    HashSet<Character> window = new HashSet<>();\n    \n    for (int i = 0, j = 0; j < n; ++j) {\n        while (window.contains(s.charAt(j))) {\n            window.remove(s.charAt(i++));\n        }\n        window.add(s.charAt(j));\n        if (j - i + 1 == k) {\n            ++result;\n            window.remove(s.charAt(i++));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "python": "\n    ```python\ndef num_k_len_substr_no_repeats(s: str, k: int) -> int:\n    n = len(s)\n    if k > n:\n        return 0\n\n    result = 0\n    window = set()\n\n    i = 0\n    for j in range(n):\n        while s[j] in window:\n            window.remove(s[i])\n            i += 1\n        window.add(s[j])\n        if j - i + 1 == k:\n            result += 1\n            window.remove(s[i])\n            i += 1\n\n    return result\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "c++": "\n    ```cpp\nint numKLenSubstrNoRepeats(string s, int k) {\n    int n = s.length();\n    if (k > n) return 0;\n    \n    int result = 0;\n    unordered_set<char> window;\n    \n    for (int i = 0, j = 0; j < n; ++j) {\n        while (window.find(s[j]) != window.end()) {\n            window.erase(s[i++]);\n        }\n        window.insert(s[j]);\n        if (j - i + 1 == k) {\n            ++result;\n            window.erase(s[i++]);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "js": "\n    ```javascript\nfunction numKLenSubstrNoRepeats(s, k) {\n    const n = s.length;\n    if (k > n) return 0;\n    \n    let result = 0;\n    const window = new Set();\n    \n    for (let i = 0, j = 0; j < n; ++j) {\n        while (window.has(s[j])) {\n            window.delete(s[i++]);\n        }\n        window.add(s[j]);\n        if (j - i + 1 === k) {\n            ++result;\n            window.delete(s[i++]);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    "
    },
    {
        "id": 1043,
        "title": "Defanging an IP Address",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a valid (IPv4) IP `address`, return a defanged version of that IP address.\n\nA _defanged IP address_ replaces every period `\". \"` with `\"[.] \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** address = \"1.1.1.1\"\n**Output:** \"1\\[.\\]1\\[.\\]1\\[.\\]1\"\n\n",
                "**Example 2:**\n\n**Input:** address = \"255.100.50.0\"\n**Output:** \"255\\[.\\]100\\[.\\]50\\[.\\]0\""
            ],
            "constraints": "**Constraints:**\n\n*   The given `address` is a valid IPv4 address.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"1.1.1.1\"",
                "output": "\"1[.]1[.]1[.]1\""
            },
            {
                "input": "\"255.100.50.0\"",
                "output": "\"255[.]100[.]50[.]0\""
            }
        ],
        "java": "\n    ```java\npublic String defangIPaddr(String address) {\n    StringBuilder defanged = new StringBuilder();\n    for (char c : address.toCharArray()) {\n        if (c == '.')\n            defanged.append(\"[.]\");\n        else\n            defanged.append(c);\n    }\n    return defanged.toString();\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "python": "\n    ```python\ndef defangIPaddr(address: str) -> str:\n    return address.replace('.', '[.]')\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring defangIPaddr(string address) {\n    string defanged = \"\";\n    for (char c : address) {\n        if (c == '.')\n            defanged += \"[.]\";\n        else\n            defanged += c;\n    }\n    return defanged;\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "js": "\n    ```javascript\nfunction defangIPaddr(address) {\n    return address.split('.').join('[.]');\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    "
    },
    {
        "id": 1044,
        "title": "Corporate Flight Bookings",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` flights that are labeled from `1` to `n`.\n\nYou are given an array of flight bookings `bookings`, where `bookings[i] = [firsti, lasti, seatsi]` represents a booking for flights `firsti` through `lasti` (**inclusive**) with `seatsi` seats reserved for **each flight** in the range.\n\nReturn _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the total number of seats reserved for flight_ `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** bookings = \\[\\[1,2,10\\],\\[2,3,20\\],\\[2,5,25\\]\\], n = 5\n**Output:** \\[10,55,45,25,25\\]\n**Explanation:**\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = \\[10,55,45,25,25\\]\n\n",
                "**Example 2:**\n\n**Input:** bookings = \\[\\[1,2,10\\],\\[2,2,15\\]\\], n = 2\n**Output:** \\[10,25\\]\n**Explanation:**\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = \\[10,25\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `1 <= bookings.length <= 2 * 104`\n*   `bookings[i].length == 3`\n*   `1 <= firsti <= lasti <= n`\n*   `1 <= seatsi <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1,2,10],[2,3,20],[2,5,25]],5",
                "output": "[10,55,45,25,25]"
            },
            {
                "input": "[[1,2,10],[2,2,15]],2",
                "output": "[10,25]"
            }
        ],
        "java": "\n    ```java\npublic int[] corpFlightBookings(int[][] bookings, int n) {\n    int[] seats = new int[n];\n    for (int[] booking : bookings) {\n        seats[booking[0] - 1] += booking[2];\n        if (booking[1] < n) {\n            seats[booking[1]] -= booking[2];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        seats[i] += seats[i - 1];\n    }\n    return seats;\n}\n```\n    \n    The algorithm initializes an array of `n` elements with all elements set to `0`. Then it iterates through the `bookings` array and for each booking, it adds the `seats` at the position `first_i - 1` and subtracts the `seats` at `last_i` if `last_i` is within the range of the array. This process gives us an initial array representing the change in seats for each flight. Finally, it iterates through the array adjusting the count for each flight by summing the previous flight count to get the total count. This gives the desired output with a time complexity of `O(n)` where `n` is the number of flights.\n    ",
        "python": "\n    ```python\ndef corpFlightBookings(bookings, n):\n    seats = [0] * n\n    for booking in bookings:\n        seats[booking[0] - 1] += booking[2]\n        if booking[1] < n:\n            seats[booking[1]] -= booking[2]\n    for i in range(1, n):\n        seats[i] += seats[i - 1]\n    return seats\n```\n    \n    The algorithm initializes an array of `n` elements with all elements set to `0`. Then it iterates through the `bookings` array and for each booking, it adds the `seats` at the position `first_i - 1` and subtracts the `seats` at `last_i` if `last_i` is within the range of the array. This process gives us an initial array representing the change in seats for each flight. Finally, it iterates through the array adjusting the count for each flight by summing the previous flight count to get the total count. This gives the desired output with a time complexity of `O(n)` where `n` is the number of flights.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {\n    vector<int> seats(n, 0);\n    for (auto& booking : bookings) {\n        seats[booking[0] - 1] += booking[2];\n        if (booking[1] < n) {\n            seats[booking[1]] -= booking[2];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        seats[i] += seats[i - 1];\n    }\n    return seats;\n}\n```\n    \n    The algorithm initializes an array of `n` elements with all elements set to `0`. Then it iterates through the `bookings` array and for each booking, it adds the `seats` at the position `first_i - 1` and subtracts the `seats` at `last_i` if `last_i` is within the range of the array. This process gives us an initial array representing the change in seats for each flight. Finally, it iterates through the array adjusting the count for each flight by summing the previous flight count to get the total count. This gives the desired output with a time complexity of `O(n)` where `n` is the number of flights.\n    ",
        "js": "\n    ```javascript\nfunction corpFlightBookings(bookings, n) {\n    const seats = new Array(n).fill(0);\n    for (const booking of bookings) {\n        seats[booking[0] - 1] += booking[2];\n        if (booking[1] < n) {\n            seats[booking[1]] -= booking[2];\n        }\n    }\n    for (let i = 1; i < n; ++i) {\n        seats[i] += seats[i - 1];\n    }\n    return seats;\n}\n```\n    \n    The algorithm initializes an array of `n` elements with all elements set to `0`. Then it iterates through the `bookings` array and for each booking, it adds the `seats` at the position `first_i - 1` and subtracts the `seats` at `last_i` if `last_i` is within the range of the array. This process gives us an initial array representing the change in seats for each flight. Finally, it iterates through the array adjusting the count for each flight by summing the previous flight count to get the total count. This gives the desired output with a time complexity of `O(n)` where `n` is the number of flights.\n    "
    },
    {
        "id": 1047,
        "title": "Number of Days in a Month",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a year `year` and a month `month`, return _the number of days of that month_.",
            "examples": [
                "**Example 1:**\n\n**Input:** year = 1992, month = 7\n**Output:** 31\n\n",
                "**Example 2:**\n\n**Input:** year = 2000, month = 2\n**Output:** 29\n\n",
                "**Example 3:**\n\n**Input:** year = 1900, month = 2\n**Output:** 28"
            ],
            "constraints": "**Constraints:**\n\n*   `1583 <= year <= 2100`\n*   `1 <= month <= 12`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1992,7",
                "output": "31"
            },
            {
                "input": "2000,2",
                "output": "29"
            },
            {
                "input": "1900,2",
                "output": "28"
            }
        ],
        "java": "\n    ```java\nint numberOfDays(int year, int month) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "python": "\n    ```python\ndef number_of_days(year, month):\n    if month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            return 29\n        return 28\n    if month in [4, 6, 9, 11]:\n        return 30\n    return 31\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "c++": "\n    ```cpp\nint numberOfDays(int year, int month) {\n    if(month == 2) {\n        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if(month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "js": "\n    ```javascript\nfunction numberOfDays(year, month) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    "
    },
    {
        "id": 1058,
        "title": "Maximum of Absolute Value Expression",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two arrays of integers with equal lengths, return the maximum value of:\n\n`|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|`\n\nwhere the maximum is taken over all `0 <= i, j < arr1.length`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[1,2,3,4\\], arr2 = \\[-1,4,5,6\\]\n**Output:** 13\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[1,-2,-5,0,10\\], arr2 = \\[0,-2,-1,-7,-4\\]\n**Output:** 20"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= arr1.length == arr2.length <= 40000`\n*   `-10^6 <= arr1[i], arr2[i] <= 10^6`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,2,3,4],[-1,4,5,6]",
                "output": "13"
            },
            {
                "input": "[1,-2,-5,0,10],[0,-2,-1,-7,-4]",
                "output": "20"
            }
        ],
        "java": "\n    ```java\npublic int maxAbsValExpr(int[] arr1, int[] arr2) {\n    int result = 0;\n    int[] max_sum = new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE};\n\n    for (int i = 0; i < arr1.length; ++i) {\n        max_sum[0] = Math.max(max_sum[0], arr1[i] + arr2[i] + i);\n        max_sum[1] = Math.max(max_sum[1], arr1[i] - arr2[i] + i);\n        max_sum[2] = Math.max(max_sum[2], -arr1[i] + arr2[i] + i);\n        max_sum[3] = Math.max(max_sum[3], -arr1[i] - arr2[i] + i);\n    }\n\n    for (int i = 0; i < arr1.length; ++i) {\n        result = Math.max(result, max_sum[0] - arr1[i] - arr2[i] - i);\n        result = Math.max(result, max_sum[1] - arr1[i] + arr2[i] - i);\n        result = Math.max(result, max_sum[2] + arr1[i] - arr2[i] - i);\n        result = Math.max(result, max_sum[3] + arr1[i] + arr2[i] - i);\n    }\n\n    return result;\n}\n```\n    \n    The problem asks to find the maximum value of the given expression, and since we have the absolute values involved, we can simplify this expression using 4 different combinations. These combinations are formed by considering both positive and negative variations of `arr1` and `arr2` components in the expression. So, we calculate the maximum values of these 4 expressions for the whole range of indices.\n\nNow, for each index, we take the difference of the calculated max values and the newly calculated expressions. After this step, we find the maximum of these 4 differences and update the result variable, which ultimately gives the required result after iterating through the entire index range.\n    ",
        "python": "\n    ```python\ndef maxAbsValExpr(arr1, arr2):\n    result = 0\n    max_sum = [float('-inf')] * 4\n\n    for i in range(len(arr1)):\n        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i)\n        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i)\n        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i)\n        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i)\n\n    for i in range(len(arr1)):\n        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i)\n        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i)\n        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i)\n\n    return result\n```\n    \n    The problem asks to find the maximum value of the given expression, and since we have the absolute values involved, we can simplify this expression using 4 different combinations. These combinations are formed by considering both positive and negative variations of `arr1` and `arr2` components in the expression. So, we calculate the maximum values of these 4 expressions for the whole range of indices.\n\nNow, for each index, we take the difference of the calculated max values and the newly calculated expressions. After this step, we find the maximum of these 4 differences and update the result variable, which ultimately gives the required result after iterating through the entire index range.\n    ",
        "c++": "\n    ```cpp\nint maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {\n    int result = 0;\n    int max_sum[4] = {INT_MIN, INT_MIN, INT_MIN, INT_MIN};\n\n    for (int i = 0; i < arr1.size(); ++i) {\n        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i);\n        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i);\n        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i);\n        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i);\n    }\n\n    for (int i = 0; i < arr1.size(); ++i) {\n        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i);\n        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i);\n        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i);\n        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i);\n    }\n\n    return result;\n}\n```\n    \n    The problem asks to find the maximum value of the given expression, and since we have the absolute values involved, we can simplify this expression using 4 different combinations. These combinations are formed by considering both positive and negative variations of `arr1` and `arr2` components in the expression. So, we calculate the maximum values of these 4 expressions for the whole range of indices.\n\nNow, for each index, we take the difference of the calculated max values and the newly calculated expressions. After this step, we find the maximum of these 4 differences and update the result variable, which ultimately gives the required result after iterating through the entire index range.\n    ",
        "js": "\n    ```javascript\nfunction maxAbsValExpr(arr1, arr2) {\n    let result = 0;\n    let max_sum = [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];\n\n    for (let i = 0; i < arr1.length; ++i) {\n        max_sum[0] = Math.max(max_sum[0], arr1[i] + arr2[i] + i);\n        max_sum[1] = Math.max(max_sum[1], arr1[i] - arr2[i] + i);\n        max_sum[2] = Math.max(max_sum[2], -arr1[i] + arr2[i] + i);\n        max_sum[3] = Math.max(max_sum[3], -arr1[i] - arr2[i] + i);\n    }\n\n    for (let i = 0; i < arr1.length; ++i) {\n        result = Math.max(result, max_sum[0] - arr1[i] - arr2[i] - i);\n        result = Math.max(result, max_sum[1] - arr1[i] + arr2[i] - i);\n        result = Math.max(result, max_sum[2] + arr1[i] - arr2[i] - i);\n        result = Math.max(result, max_sum[3] + arr1[i] + arr2[i] - i);\n    }\n\n    return result;\n}\n```\n    \n    The problem asks to find the maximum value of the given expression, and since we have the absolute values involved, we can simplify this expression using 4 different combinations. These combinations are formed by considering both positive and negative variations of `arr1` and `arr2` components in the expression. So, we calculate the maximum values of these 4 expressions for the whole range of indices.\n\nNow, for each index, we take the difference of the calculated max values and the newly calculated expressions. After this step, we find the maximum of these 4 differences and update the result variable, which ultimately gives the required result after iterating through the entire index range.\n    "
    },
    {
        "id": 1062,
        "title": "Parallel Courses",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`.\n\nIn one semester, you can take **any number** of courses as long as you have taken all the prerequisites in the **previous** semester for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. If there is no way to take all the courses, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\]\n**Output:** 2\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 1 and 2.\nIn the second semester, you can take course 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, relations = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1\n**Explanation:** No course can be studied because they are prerequisites of each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `1 <= relations.length <= 5000`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,[[1,3],[2,3]]",
                "output": "2"
            },
            {
                "input": "3,[[1,2],[2,3],[3,1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minimumSemesters(int n, int[][] relations) {\n    int[] in_degree = new int[n + 1];\n    List<List<Integer>> graph = new ArrayList<>();\n\n    for (int i = 0; i <= n; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] relation : relations) {\n        graph.get(relation[0]).add(relation[1]);\n        in_degree[relation[1]]++;\n    }\n\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.offer(i);\n        }\n    }\n\n    int semesters = 0;\n    while (!q.isEmpty()) {\n        int size = q.size();\n        semesters++;\n        for (int i = 0; i < size; i++) {\n            int course = q.poll();\n            n--;\n\n            for (int next : graph.get(course)) {\n                if (--in_degree[next] == 0) {\n                    q.offer(next);\n                }\n            }\n        }\n    }\n\n    return n == 0 ? semesters : -1;\n}\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "python": "\n    ```python\ndef minimum_semesters(n: int, relations: List[List[int]]) -> int:\n    in_degree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev, next in relations:\n        graph[prev].append(next)\n        in_degree[next] += 1\n\n    q = [i for i in range(1, n + 1) if in_degree[i] == 0]\n    semesters = 0\n\n    while q:\n        next_q = []\n        semesters += 1\n        for course in q:\n            n -= 1\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    next_q.append(next_course)\n        q = next_q\n\n    return semesters if n == 0 else -1\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "c++": "\n    ```cpp\nint minimumSemesters(int n, vector<vector<int>>& relations) {\n    vector<int> in_degree(n + 1, 0);\n    vector<vector<int>> graph(n + 1);\n\n    for (auto& relation : relations) {\n        graph[relation[0]].push_back(relation[1]);\n        in_degree[relation[1]]++;\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    int semesters = 0;\n    while (!q.empty()) {\n        int size = q.size();\n        semesters++;\n        while (size--) {\n            int course = q.front();\n            q.pop();\n            n--;\n\n            for (int next : graph[course]) {\n                if (--in_degree[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    return n == 0 ? semesters : -1;\n}\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "js": "\n    ```javascript\nfunction minimumSemesters(n, relations) {\n    const in_degree = new Array(n + 1).fill(0);\n    const graph = new Array(n + 1).fill(null).map(() => []);\n\n    for (let [prev, next] of relations) {\n        graph[prev].push(next);\n        in_degree[next]++;\n    }\n\n    const q = [];\n    for (let i = 1; i <= n; i++) {\n        if (in_degree[i] === 0) {\n            q.push(i);\n        }\n    }\n\n    let semesters = 0;\n    while (q.length) {\n        const size = q.length;\n        semesters++;\n        for (let i = 0; i < size; i++) {\n            const course = q.shift();\n            n--;\n\n            for (let next of graph[course]) {\n                in_degree[next]--;\n                if (in_degree[next] === 0) {\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    return n === 0 ? semesters : -1;\n}\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    "
    },
    {
        "id": 1067,
        "title": "Longest Common Subsequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `text1` and `text2`, return _the length of their longest **common subsequence**._ If there is no **common subsequence**, return `0`.\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n*   For example, `\"ace \"` is a subsequence of `\"abcde \"`.\n\nA **common subsequence** of two strings is a subsequence that is common to both strings.",
            "examples": [
                "**Example 1:**\n\n**Input:** text1 =  \"abcde \", text2 =  \"ace \" \n**Output:** 3  \n**Explanation:** The longest common subsequence is  \"ace \" and its length is 3.\n\n",
                "**Example 2:**\n\n**Input:** text1 =  \"abc \", text2 =  \"abc \"\n**Output:** 3\n**Explanation:** The longest common subsequence is  \"abc \" and its length is 3.\n\n",
                "**Example 3:**\n\n**Input:** text1 =  \"abc \", text2 =  \"def \"\n**Output:** 0\n**Explanation:** There is no such common subsequence, so the result is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text1.length, text2.length <= 1000`\n*   `text1` and `text2` consist of only lowercase English characters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"abcde\",\"ace\"",
                "output": "3"
            },
            {
                "input": "\"abc\",\"abc\"",
                "output": "3"
            },
            {
                "input": "\"abc\",\"def\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length();\n    int n = text2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    We will use dynamic programming to solve this problem. The idea is to create a 2D array `dp` with dimensions `text1.length + 1` and `text2.length + 1`. The indices `(i, j)` of the array will store the length of the longest common subsequence of the substrings `text1` and `text2` until index `i` and `j` respectively.\n\nWe loop through the two strings and compare their characters at positions `i - 1` and `j - 1` (since indices are 0-based). If the characters are the same, the value of `dp[i][j]` will be equal to the `dp[i - 1][j - 1]` + 1; otherwise, we set `dp[i][j]` equal to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n\nAfter iterating through both strings, the result will be stored at `dp[m][n]` where `m` and `n` are the lengths of `text1` and `text2`.\n    ",
        "python": "\n    ```python\ndef longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n```\n    \n    We will use dynamic programming to solve this problem. The idea is to create a 2D array `dp` with dimensions `text1.length + 1` and `text2.length + 1`. The indices `(i, j)` of the array will store the length of the longest common subsequence of the substrings `text1` and `text2` until index `i` and `j` respectively.\n\nWe loop through the two strings and compare their characters at positions `i - 1` and `j - 1` (since indices are 0-based). If the characters are the same, the value of `dp[i][j]` will be equal to the `dp[i - 1][j - 1]` + 1; otherwise, we set `dp[i][j]` equal to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n\nAfter iterating through both strings, the result will be stored at `dp[m][n]` where `m` and `n` are the lengths of `text1` and `text2`.\n    ",
        "c++": "\n    ```cpp\nint longestCommonSubsequence(string text1, string text2) {\n    int m = text1.size();\n    int n = text2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1[i - 1] == text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    We will use dynamic programming to solve this problem. The idea is to create a 2D array `dp` with dimensions `text1.length + 1` and `text2.length + 1`. The indices `(i, j)` of the array will store the length of the longest common subsequence of the substrings `text1` and `text2` until index `i` and `j` respectively.\n\nWe loop through the two strings and compare their characters at positions `i - 1` and `j - 1` (since indices are 0-based). If the characters are the same, the value of `dp[i][j]` will be equal to the `dp[i - 1][j - 1]` + 1; otherwise, we set `dp[i][j]` equal to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n\nAfter iterating through both strings, the result will be stored at `dp[m][n]` where `m` and `n` are the lengths of `text1` and `text2`.\n    ",
        "js": "\n    ```javascript\nfunction longestCommonSubsequence(text1, text2) {\n    const m = text1.length;\n    const n = text2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array.from({ length: n + 1 }, () => 0));\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n```\n    \n    We will use dynamic programming to solve this problem. The idea is to create a 2D array `dp` with dimensions `text1.length + 1` and `text2.length + 1`. The indices `(i, j)` of the array will store the length of the longest common subsequence of the substrings `text1` and `text2` until index `i` and `j` respectively.\n\nWe loop through the two strings and compare their characters at positions `i - 1` and `j - 1` (since indices are 0-based). If the characters are the same, the value of `dp[i][j]` will be equal to the `dp[i - 1][j - 1]` + 1; otherwise, we set `dp[i][j]` equal to the maximum of `dp[i - 1][j]` and `dp[i][j - 1]`.\n\nAfter iterating through both strings, the result will be stored at `dp[m][n]` where `m` and `n` are the lengths of `text1` and `text2`.\n    "
    },
    {
        "id": 1093,
        "title": "Diet Plan Performance",
        "difficulty": "Easy",
        "content": {
            "problem": "A dieter consumes `calories[i]` calories on the `i`\\-th day.\n\nGiven an integer `k`, for **every** consecutive sequence of `k` days (`calories[i], calories[i+1], ..., calories[i+k-1]` for all `0 <= i <= n-k`), they look at _T_, the total calories consumed during that sequence of `k` days (`calories[i] + calories[i+1] + ... + calories[i+k-1]`):\n\n*   If `T < lower`, they performed poorly on their diet and lose 1 point;\n*   If `T > upper`, they performed well on their diet and gain 1 point;\n*   Otherwise, they performed normally and there is no change in points.\n\nInitially, the dieter has zero points. Return the total number of points the dieter has after dieting for `calories.length` days.\n\nNote that the total points can be negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** calories = \\[1,2,3,4,5\\], k = 1, lower = 3, upper = 3\n**Output:** 0\n**Explanation**: Since k = 1, we consider each element of the array separately and compare it to lower and upper.\ncalories\\[0\\] and calories\\[1\\] are less than lower so 2 points are lost.\ncalories\\[3\\] and calories\\[4\\] are greater than upper so 2 points are gained.\n\n",
                "**Example 2:**\n\n**Input:** calories = \\[3,2\\], k = 2, lower = 0, upper = 1\n**Output:** 1\n**Explanation**: Since k = 2, we consider subarrays of length 2.\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\n\n",
                "**Example 3:**\n\n**Input:** calories = \\[6,5,0,0\\], k = 2, lower = 1, upper = 5\n**Output:** 0\n**Explanation**:\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\nlower <= calories\\[1\\] + calories\\[2\\] <= upper so no change in points.\ncalories\\[2\\] + calories\\[3\\] < lower so 1 point is lost."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= calories.length <= 10^5`\n*   `0 <= calories[i] <= 20000`\n*   `0 <= lower <= upper`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5],1,3,3",
                "output": "0"
            },
            {
                "input": "[3,2],2,0,1",
                "output": "1"
            },
            {
                "input": "[6,5,0,0],2,1,5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int dietPlanPerformance(int[] calories, int k, int lower, int upper) {\n    int points = 0;\n    int T = 0;\n\n    for(int i = 0; i < calories.length; i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "python": "\n    ```python\ndef dietPlanPerformance(calories, k, lower, upper):\n    points = 0\n    T = 0\n\n    for i in range(len(calories)):\n        T += calories[i]\n        if i >= k:\n            T -= calories[i-k]\n        if i >= k-1:\n            if T < lower: points -= 1\n            if T > upper: points += 1\n\n    return points\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "c++": "\n    ```cpp\nint dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) {\n    int points = 0;\n    int T = 0;\n\n    for(int i = 0; i < calories.size(); i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "js": "\n    ```javascript\nfunction dietPlanPerformance(calories, k, lower, upper) {\n    let points = 0;\n    let T = 0;\n\n    for(let i = 0; i < calories.length; i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    "
    },
    {
        "id": 1096,
        "title": "Count Substrings with Only One Distinct Letter",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the number of substrings that have only **one distinct** letter_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaaba \"\n**Output:** 8\n**Explanation:** The substrings with one distinct letter are  \"aaa \",  \"aa \",  \"a \",  \"b \".\n \"aaa \" occurs 1 time.\n \"aa \" occurs 2 times.\n \"a \" occurs 4 times.\n \"b \" occurs 1 time.\nSo the answer is 1 + 2 + 4 + 1 = 8.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaaaaaaaaa \"\n**Output:** 55"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aaaba\"",
                "output": "8"
            },
            {
                "input": "\"aaaaaaaaaa\"",
                "output": "55"
            }
        ],
        "java": "\n    ```java\npublic int countLetters(String s) {\n    int count = 0, current = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "python": "\n    ```python\ndef count_letters(s: str) -> int:\n    count = 0\n    current = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current += 1\n        else:\n            count += (current * (current + 1)) // 2\n            current = 1\n\n    count += (current * (current + 1)) // 2\n    return count\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "c++": "\n    ```cpp\nint countLetters(string s) {\n    int count = 0, current = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "js": "\n    ```javascript\nfunction countLetters(s) {\n    let count = 0;\n    let current = 1;\n\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    "
    },
    {
        "id": 1104,
        "title": "Maximum Number of Balloons",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `text`, you want to use the characters of `text` to form as many instances of the word **\"balloon \"** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"nlaebolko \"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** text =  \"loonbalxballpoon \"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** text =  \"leetcode \"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 104`\n*   `text` consists of lower case English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Counting"
        ],
        "example": [
            {
                "input": "\"nlaebolko\"",
                "output": "1"
            },
            {
                "input": "\"loonbalxballpoon\"",
                "output": "2"
            },
            {
                "input": "\"leetcode\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxNumberOfBalloons(String text) {\n    int[] letter_count = new int[5];\n    for (char c : text.toCharArray()) {\n        if (c == 'b') letter_count[0]++;\n        if (c == 'a') letter_count[1]++;\n        if (c == 'l') letter_count[2]++;\n        if (c == 'o') letter_count[3]++;\n        if (c == 'n') letter_count[4]++;\n    }\n    letter_count[2] /= 2;\n    letter_count[3] /= 2;\n    return Arrays.stream(letter_count).min().getAsInt();\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "python": "\n    ```python\ndef max_number_of_balloons(text: str) -> int:\n    letter_count = [0] * 5\n    for c in text:\n        if c == 'b': letter_count[0] += 1\n        if c == 'a': letter_count[1] += 1\n        if c == 'l': letter_count[2] += 1\n        if c == 'o': letter_count[3] += 1\n        if c == 'n': letter_count[4] += 1\n    letter_count[2] //= 2\n    letter_count[3] //= 2\n    return min(letter_count)\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "c++": "\n    ```cpp\nint maxNumberOfBalloons(string text) {\n    int letter_count[5] = {0};\n    for (char c : text) {\n        if (c == 'b') letter_count[0]++;\n        if (c == 'a') letter_count[1]++;\n        if (c == 'l') letter_count[2]++;\n        if (c == 'o') letter_count[3]++;\n        if (c == 'n') letter_count[4]++;\n    }\n    letter_count[2] /= 2;\n    letter_count[3] /= 2;\n    return *min_element(letter_count, letter_count + 5);\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberOfBalloons(text) {\n    const letter_count = [0, 0, 0, 0, 0];\n    for (let c of text) {\n        if (c === 'b') letter_count[0]++;\n        if (c === 'a') letter_count[1]++;\n        if (c === 'l') letter_count[2]++;\n        if (c === 'o') letter_count[3]++;\n        if (c === 'n') letter_count[4]++;\n    }\n    letter_count[2] = Math.floor(letter_count[2] / 2);\n    letter_count[3] = Math.floor(letter_count[3] / 2);\n    return Math.min(...letter_count);\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    "
    },
    {
        "id": 1110,
        "title": "Find Smallest Common Element in All Rows",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` matrix `mat` where every row is sorted in **strictly** **increasing** order, return _the **smallest common element** in all rows_.\n\nIf there is no common element, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,2,3,4,5\\],\\[2,4,5,8,10\\],\\[3,5,7,9,11\\],\\[1,3,5,7,9\\]\\]\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,2,3\\],\\[2,3,4\\],\\[2,3,5\\]\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 500`\n*   `1 <= mat[i][j] <= 104`\n*   `mat[i]` is sorted in strictly increasing order.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]",
                "output": "5"
            },
            {
                "input": "[[1,2,3],[2,3,4],[2,3,5]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int smallestCommonElement(int[][] mat) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    for (int[] row : mat) {\n        for (int num : row) {\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\n            if (counts.get(num) == mat.length) {\n                return num;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "python": "\n    ```python\ndef smallest_common_element(mat):\n    counts = {}\n    for row in mat:\n        for num in row:\n            counts[num] = counts.get(num, 0) + 1\n            if counts[num] == len(mat):\n                return num\n    return -1\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "c++": "\n    ```cpp\nint smallestCommonElement(vector<vector<int>>& mat) {\n    unordered_map<int, int> counts;\n    for (const auto& row : mat) {\n        for (int num : row) {\n            ++counts[num];\n            if (counts[num] == mat.size()) {\n                return num;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "js": "\n    ```javascript\nfunction smallestCommonElement(mat) {\n    const counts = new Map();\n    for (const row of mat) {\n        for (const num of row) {\n            counts.set(num, (counts.get(num) || 0) + 1);\n            if (counts.get(num) === mat.length) {\n                return num;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    "
    },
    {
        "id": 1119,
        "title": "Remove All Adjacent Duplicates in String II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s` and an integer `k`, a `k` **duplicate removal** consists of choosing `k` adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together.\n\nWe repeatedly make `k` **duplicate removals** on `s` until we no longer can.\n\nReturn _the final string after all such duplicate removals have been made_. It is guaranteed that the answer is **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcd \", k = 2\n**Output:**  \"abcd \"\n**Explanation:** There's nothing to delete.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"deeedbbcccbdaa \", k = 3\n**Output:**  \"aa \"\n**Explanation:** \nFirst delete  \"eee \" and  \"ccc \", get  \"ddbbbdaa \"\nThen delete  \"bbb \", get  \"dddaa \"\nFinally delete  \"ddd \", get  \"aa \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"pbbcggttciiippooaais \", k = 2\n**Output:**  \"ps \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `2 <= k <= 104`\n*   `s` only contains lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"abcd\",2",
                "output": "\"abcd\""
            },
            {
                "input": "\"deeedbbcccbdaa\",3",
                "output": "\"aa\""
            },
            {
                "input": "\"pbbcggttciiippooaais\",2",
                "output": "\"ps\""
            }
        ],
        "java": "\n    ```java\npublic String removeDuplicates(String s, int k) {\n    Stack<int[]> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (stack.isEmpty() || stack.peek()[0] != c) {\n            stack.push(new int[]{c, 1});\n        } else if (++stack.peek()[1] == k) {\n            stack.pop();\n        }\n    }\n    StringBuilder result = new StringBuilder();\n    while (!stack.isEmpty()) {\n        int[] elem = stack.pop();\n        for (int i = 0; i < elem[1]; i++) {\n            result.append((char) elem[0]);\n        }\n    }\n    return result.reverse().toString();\n}\n```\n\n    \n    The algorithm makes use of a stack that stores the characters and their counts. For each character in the input string `s`, we check if the stack is empty or if the top of the stack has a different character. If either of these cases is true, we push the new character onto the stack along with a count of 1.\n\nIf the character is the same as the one on the top of the stack, we increment the count of that character. If the count reaches the value of `k`, we remove the character from the stack (its count is reset). We repeat this process for each character in the input string.\n\nAfter iteration, we construct the final result string from the stack contents. Each character is repeated as many times as the count associated with it on the stack. This string is the result after all of the `k`-duplicate removals have been made.\n    ",
        "python": "\n    ```python\ndef removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if not stack or stack[-1][0] != c:\n            stack.append((c, 1))\n        elif stack[-1][1] + 1 != k:\n            stack[-1] = (c, stack[-1][1] + 1)\n        else:\n            stack.pop()\n    return ''.join(c * count for c, count in stack)\n```\n\n    \n    The algorithm makes use of a stack that stores the characters and their counts. For each character in the input string `s`, we check if the stack is empty or if the top of the stack has a different character. If either of these cases is true, we push the new character onto the stack along with a count of 1.\n\nIf the character is the same as the one on the top of the stack, we increment the count of that character. If the count reaches the value of `k`, we remove the character from the stack (its count is reset). We repeat this process for each character in the input string.\n\nAfter iteration, we construct the final result string from the stack contents. Each character is repeated as many times as the count associated with it on the stack. This string is the result after all of the `k`-duplicate removals have been made.\n    ",
        "c++": "\n    ```cpp\nstd::string removeDuplicates(std::string s, int k) {\n    std::vector<std::pair<char, int>> stack;\n    for (char c : s) {\n        if (stack.empty() || stack.back().first != c) {\n            stack.push_back({c, 1});\n        } else if (++stack.back().second == k) {\n            stack.pop_back();\n        }\n    }\n    std::string result;\n    for (auto &pair : stack) {\n        result.append(pair.second, pair.first);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm makes use of a stack that stores the characters and their counts. For each character in the input string `s`, we check if the stack is empty or if the top of the stack has a different character. If either of these cases is true, we push the new character onto the stack along with a count of 1.\n\nIf the character is the same as the one on the top of the stack, we increment the count of that character. If the count reaches the value of `k`, we remove the character from the stack (its count is reset). We repeat this process for each character in the input string.\n\nAfter iteration, we construct the final result string from the stack contents. Each character is repeated as many times as the count associated with it on the stack. This string is the result after all of the `k`-duplicate removals have been made.\n    ",
        "js": "\n    ```javascript\nfunction removeDuplicates(s, k) {\n    let stack = [];\n    for (let c of s) {\n        if (stack.length === 0 || stack[stack.length - 1][0] !== c) {\n            stack.push([c, 1]);\n        } else if (++stack[stack.length - 1][1] === k) {\n            stack.pop();\n        }\n    }\n    let result = \"\";\n    for (let pair of stack) {\n        result += pair[0].repeat(pair[1]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm makes use of a stack that stores the characters and their counts. For each character in the input string `s`, we check if the stack is empty or if the top of the stack has a different character. If either of these cases is true, we push the new character onto the stack along with a count of 1.\n\nIf the character is the same as the one on the top of the stack, we increment the count of that character. If the count reaches the value of `k`, we remove the character from the stack (its count is reset). We repeat this process for each character in the input string.\n\nAfter iteration, we construct the final result string from the stack contents. Each character is repeated as many times as the count associated with it on the stack. This string is the result after all of the `k`-duplicate removals have been made.\n    "
    },
    {
        "id": 1121,
        "title": "Intersection of Three Sorted Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[1,2,3,4,5\\], arr2 = \\[1,2,5,7,9\\], arr3 = \\[1,3,4,5,8\\]\n**Output:** \\[1,5\\]\n**Explanation:** Only 1 and 5 appeared in the three arrays.\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[197,418,523,876,1356\\], arr2 = \\[501,880,1593,1710,1870\\], arr3 = \\[521,682,1337,1395,1764\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length, arr3.length <= 1000`\n*   `1 <= arr1[i], arr2[i], arr3[i] <= 2000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5],[1,2,5,7,9],[1,3,4,5,8]",
                "output": "[1,5]"
            },
            {
                "input": "[197,418,523,876,1356],[501,880,1593,1710,1870],[521,682,1337,1395,1764]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {\n    int i = 0, j = 0, k = 0;\n    ArrayList<Integer> result = new ArrayList<>();\n    while (i < arr1.length && j < arr2.length && k < arr3.length) {\n        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {\n            result.add(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "python": "\n    ```python\ndef arraysIntersection(arr1, arr2, arr3):\n    i, j, k = 0, 0, 0\n    result = []\n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:\n            result.append(arr1[i])\n            i, j, k = i + 1, j + 1, k + 1\n        else:\n            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:\n                i += 1\n            elif arr2[j] <= arr3[k]:\n                j += 1\n            else:\n                k += 1\n    return result\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) {\n    int i = 0, j = 0, k = 0;\n    vector<int> result;\n    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {\n        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {\n            result.push_back(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "js": "\n    ```javascript\nfunction arraysIntersection(arr1, arr2, arr3) {\n    let i = 0, j = 0, k = 0;\n    let result = [];\n    while (i < arr1.length && j < arr2.length && k < arr3.length) {\n        if (arr1[i] === arr2[j] && arr2[j] === arr3[k]) {\n            result.push(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    "
    },
    {
        "id": 1156,
        "title": "Number of Closed Islands",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a 2D `grid` consists of `0s` (land) and `1s` (water). An _island_ is a maximal 4-directionally connected group of `0s` and a _closed island_ is an island **totally** (all left, top, right, bottom) surrounded by `1s.`\n\nReturn the number of _closed islands_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1,1,1,1,1,0\\],\\[1,0,0,0,0,1,1,0\\],\\[1,0,1,0,1,1,1,0\\],\\[1,0,0,0,0,1,0,1\\],\\[1,1,1,1,1,1,1,0\\]\\]\n**Output:** 2\n**Explanation:** \nIslands in gray are closed because they are completely surrounded by water (group of 1s).\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,0,1,0,0\\],\\[0,1,0,1,0\\],\\[0,1,1,1,0\\]\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,1,1,1\\],\n               \\[1,0,0,0,0,0,1\\],\n               \\[1,0,1,1,1,0,1\\],\n               \\[1,0,1,0,1,0,1\\],\n               \\[1,0,1,1,1,0,1\\],\n               \\[1,0,0,0,0,0,1\\],\n               \\[1,1,1,1,1,1,1\\]\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= grid.length, grid[0].length <= 100`\n*   `0 <= grid[i][j] <=1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]",
                "output": "2"
            },
            {
                "input": "[[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]",
                "output": "1"
            },
            {
                "input": "[[1,1,1,1,1,1,1],\n[1,0,0,0,0,0,1],\n[1,0,1,1,1,0,1],\n[1,0,1,0,1,0,1],\n[1,0,1,1,1,0,1],\n[1,0,0,0,0,0,1],\n[1,1,1,1,1,1,1]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int closedIsland(int[][] grid) {\n    int count = 0;\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 0 && dfs(grid, i, j)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nprivate boolean dfs(int[][] grid, int i, int j) {\n    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {\n        return false;\n    }\n\n    if (grid[i][j] == 1) {\n        return true;\n    }\n\n    grid[i][j] = 1;\n\n    boolean up = dfs(grid, i - 1, j);\n    boolean down = dfs(grid, i + 1, j);\n    boolean left = dfs(grid, i, j - 1);\n    boolean right = dfs(grid, i, j + 1);\n\n    return up && down && left && right;\n}\n```\n\n    \n    The algorithm uses Depth-first Search (DFS) to traverse islands of 0s (land). If the DFS function returns false, then the current cell is on the edge and it is not a closed island. If the DFS function returns true, then the current cell is surrounded by 1s (water), and the current island is a closed island.\n\nFor each cell that contains a 0 (land), we call the DFS function to explore the island. If the DFS function returns true for all directions (up, down, left, and right), then it is a closed island. We increment the count for each closed island found.\n\nFinally, we return the total count of closed islands.\n    ",
        "python": "\n    ```python\ndef closedIsland(grid):\n    def dfs(grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n            return False\n\n        if grid[i][j] == 1:\n            return True\n\n        grid[i][j] = 1\n\n        up = dfs(grid, i - 1, j)\n        down = dfs(grid, i + 1, j)\n        left = dfs(grid, i, j - 1)\n        right = dfs(grid, i, j + 1)\n\n        return up and down and left and right\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0 and dfs(grid, i, j):\n                count += 1\n\n    return count\n```\n\n    \n    The algorithm uses Depth-first Search (DFS) to traverse islands of 0s (land). If the DFS function returns false, then the current cell is on the edge and it is not a closed island. If the DFS function returns true, then the current cell is surrounded by 1s (water), and the current island is a closed island.\n\nFor each cell that contains a 0 (land), we call the DFS function to explore the island. If the DFS function returns true for all directions (up, down, left, and right), then it is a closed island. We increment the count for each closed island found.\n\nFinally, we return the total count of closed islands.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool dfs(std::vector<std::vector<int>>& grid, int i, int j) {\n    if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\n        return false;\n    }\n\n    if (grid[i][j] == 1) {\n        return true;\n    }\n\n    grid[i][j] = 1;\n\n    bool up = dfs(grid, i - 1, j);\n    bool down = dfs(grid, i + 1, j);\n    bool left = dfs(grid, i, j - 1);\n    bool right = dfs(grid, i, j + 1);\n\n    return up && down && left && right;\n}\n\nint closedIsland(std::vector<std::vector<int>>& grid) {\n    int count = 0;\n\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0 && dfs(grid, i, j)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    The algorithm uses Depth-first Search (DFS) to traverse islands of 0s (land). If the DFS function returns false, then the current cell is on the edge and it is not a closed island. If the DFS function returns true, then the current cell is surrounded by 1s (water), and the current island is a closed island.\n\nFor each cell that contains a 0 (land), we call the DFS function to explore the island. If the DFS function returns true for all directions (up, down, left, and right), then it is a closed island. We increment the count for each closed island found.\n\nFinally, we return the total count of closed islands.\n    ",
        "js": "\n    ```javascript\nfunction closedIsland(grid) {\n    function dfs(grid, i, j) {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {\n            return false;\n        }\n\n        if (grid[i][j] == 1) {\n            return true;\n        }\n\n        grid[i][j] = 1;\n\n        const up = dfs(grid, i - 1, j);\n        const down = dfs(grid, i + 1, j);\n        const left = dfs(grid, i, j - 1);\n        const right = dfs(grid, i, j + 1);\n\n        return up && down && left && right;\n    }\n\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 0 && dfs(grid, i, j)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    The algorithm uses Depth-first Search (DFS) to traverse islands of 0s (land). If the DFS function returns false, then the current cell is on the edge and it is not a closed island. If the DFS function returns true, then the current cell is surrounded by 1s (water), and the current island is a closed island.\n\nFor each cell that contains a 0 (land), we call the DFS function to explore the island. If the DFS function returns true for all directions (up, down, left, and right), then it is a closed island. We increment the count for each closed island found.\n\nFinally, we return the total count of closed islands.\n    "
    },
    {
        "id": 1167,
        "title": "Minimum Time Visiting All Points",
        "difficulty": "Easy",
        "content": {
            "problem": "On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`.\n\nYou can move according to these rules:\n\n*   In `1` second, you can either:\n    *   move vertically by one unit,\n    *   move horizontally by one unit, or\n    *   move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).\n*   You have to visit the points in the same order as they appear in the array.\n*   You are allowed to pass through points that appear later in the order, but these do not count as visits.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,4\\],\\[-1,0\\]\\]\n**Output:** 7\n**Explanation:** One optimal path is **\\[1,1\\]** -> \\[2,2\\] -> \\[3,3\\] -> **\\[3,4\\]** \\-> \\[2,3\\] -> \\[1,2\\] -> \\[0,1\\] -> **\\[-1,0\\]**   \nTime from \\[1,1\\] to \\[3,4\\] = 3 seconds \nTime from \\[3,4\\] to \\[-1,0\\] = 4 seconds\nTotal time = 7 seconds\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[3,2\\],\\[-2,2\\]\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `points.length == n`\n*   `1 <= n <= 100`\n*   `points[i].length == 2`\n*   `-1000 <= points[i][0], points[i][1] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,1],[3,4],[-1,0]]",
                "output": "7"
            },
            {
                "input": "[[3,2],[-2,2]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minTimeToVisitAllPoints(int[][] points) {\n    int time = 0;\n    for (int i = 1; i < points.length; i++) {\n        int dx = Math.abs(points[i][0] - points[i - 1][0]);\n        int dy = Math.abs(points[i][1] - points[i - 1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "python": "\n    ```python\ndef minTimeToVisitAllPoints(points):\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i - 1][0])\n        dy = abs(points[i][1] - points[i - 1][1])\n        time += max(dx, dy)\n    return time\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "c++": "\n    ```cpp\nint minTimeToVisitAllPoints(vector<vector<int>>& points) {\n    int time = 0;\n    for (int i = 1; i < points.size(); i++) {\n        int dx = abs(points[i][0] - points[i - 1][0]);\n        int dy = abs(points[i][1] - points[i - 1][1]);\n        time += max(dx, dy);\n    }\n    return time;\n}\n```\n\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "js": "\n    ```javascript\nfunction minTimeToVisitAllPoints(points) {\n    let time = 0;\n    for (let i = 1; i < points.length; i++) {\n        let dx = Math.abs(points[i][0] - points[i - 1][0]);\n        let dy = Math.abs(points[i][1] - points[i - 1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    "
    },
    {
        "id": 1171,
        "title": "Hexspeak",
        "difficulty": "Easy",
        "content": {
            "problem": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"257 \"\n**Output:**  \"IOI \"\n**Explanation:** 257 is 101 in hexadecimal.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"3 \"\n**Output:**  \"ERROR \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 12`\n*   `num` does not contain leading zeros.\n*   num represents an integer in the range `[1, 1012]`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"257\"",
                "output": "\"IOI\""
            },
            {
                "input": "\"3\"",
                "output": "\"ERROR\""
            }
        ],
        "java": "\n    ```java\npublic String toHexspeak(String num) {\n    long n = Long.parseLong(num);\n    StringBuilder hex = new StringBuilder();\n    while (n != 0) {\n        int rem = (int)(n % 16);\n        if (rem == 1) hex.insert(0, 'I');\n        else if (rem == 0) hex.insert(0, 'O');\n        else if (rem > 9) hex.insert(0, (char)(rem - 10 + 'A'));\n        else return \"ERROR\";\n        n /= 16;\n    }\n    return hex.toString();\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "python": "\n    ```python\ndef to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string toHexspeak(std::string num) {\n    long n = std::stol(num);\n    std::string hex = \"\";\n    while (n) {\n        int rem = n % 16;\n        if (rem == 1) hex = \"I\" + hex;\n        else if (rem == 0) hex = \"O\" + hex;\n        else if (rem > 9) hex = (char)(rem - 10 + 'A') + hex;\n        else return \"ERROR\";\n        n /= 16;\n    }\n    return hex;\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "js": "\n    ```javascript\nfunction toHexspeak(num) {\n    let n = BigInt(num);\n    let hex = '';\n    while (n) {\n        let rem = Number(n % 16n);\n        if (rem === 1) hex = 'I' + hex;\n        else if (rem === 0) hex = 'O' + hex;\n        else if (rem > 9) hex = String.fromCharCode(rem - 10 + 'A'.charCodeAt(0)) + hex;\n        else return 'ERROR';\n        n /= 16n;\n    }\n    return hex;\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    "
    },
    {
        "id": 1208,
        "title": "Matrix Block Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `m x n` matrix `mat` and an integer `k`, return _a matrix_ `answer` _where each_ `answer[i][j]` _is the sum of all elements_ `mat[r][c]` _for_:\n\n*   `i - k <= r <= i + k,`\n*   `j - k <= c <= j + k`, and\n*   `(r, c)` is a valid position in the matrix.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 1\n**Output:** \\[\\[12,21,16\\],\\[27,45,33\\],\\[24,39,28\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 2\n**Output:** \\[\\[45,45,45\\],\\[45,45,45\\],\\[45,45,45\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n, k <= 100`\n*   `1 <= mat[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]],1",
                "output": "[[12,21,16],[27,45,33],[24,39,28]]"
            },
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]],2",
                "output": "[[45,45,45],[45,45,45],[45,45,45]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] matrixBlockSum(int[][] mat, int k) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][] answer = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int r = Math.max(0, i - k); r <= Math.min(m - 1, i + k); r++) {\n                for (int c = Math.max(0, j - k); c <= Math.min(n - 1, j + k); c++) {\n                    answer[i][j] += mat[r][c];\n                }\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    This algorithm iterates through each cell of the input matrix `mat`. For each cell, it calculates the sum of all elements in the given sub-matrix range. The sub-matrix `mat[r][c]` is represented by the conditions `i - k <= r <= i + k` and `j - k <= c <= j + k`. It checks if `(r, c)` is a valid position. If it's valid, the sum will be stored in the `answer` matrix at the same index (i, j). The complexity of this algorithm is O(m * n * k^2), where m is the number of rows, n is the number of columns, and k is the range.\n    ",
        "python": "\n    ```python\ndef matrix_block_sum(mat, k):\n    m, n = len(mat), len(mat[0])\n    answer = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for r in range(max(0, i - k), min(m, i + k + 1)):\n                for c in range(max(0, j - k), min(n, j + k + 1)):\n                    answer[i][j] += mat[r][c]\n                    \n    return answer\n```\n    \n    This algorithm iterates through each cell of the input matrix `mat`. For each cell, it calculates the sum of all elements in the given sub-matrix range. The sub-matrix `mat[r][c]` is represented by the conditions `i - k <= r <= i + k` and `j - k <= c <= j + k`. It checks if `(r, c)` is a valid position. If it's valid, the sum will be stored in the `answer` matrix at the same index (i, j). The complexity of this algorithm is O(m * n * k^2), where m is the number of rows, n is the number of columns, and k is the range.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<vector<int>> answer(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int r = max(0, i - k); r <= min(m - 1, i + k); ++r) {\n                for (int c = max(0, j - k); c <= min(n - 1, j + k); ++c) {\n                    answer[i][j] += mat[r][c];\n                }\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    This algorithm iterates through each cell of the input matrix `mat`. For each cell, it calculates the sum of all elements in the given sub-matrix range. The sub-matrix `mat[r][c]` is represented by the conditions `i - k <= r <= i + k` and `j - k <= c <= j + k`. It checks if `(r, c)` is a valid position. If it's valid, the sum will be stored in the `answer` matrix at the same index (i, j). The complexity of this algorithm is O(m * n * k^2), where m is the number of rows, n is the number of columns, and k is the range.\n    ",
        "js": "\n    ```javascript\nfunction matrixBlockSum(mat, k) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const answer = new Array(m).fill(null).map(() => new Array(n).fill(0));\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            for (let r = Math.max(0, i - k); r <= Math.min(m - 1, i + k); r++) {\n                for (let c = Math.max(0, j - k); c <= Math.min(n - 1, j + k); c++) {\n                    answer[i][j] += mat[r][c];\n                }\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    This algorithm iterates through each cell of the input matrix `mat`. For each cell, it calculates the sum of all elements in the given sub-matrix range. The sub-matrix `mat[r][c]` is represented by the conditions `i - k <= r <= i + k` and `j - k <= c <= j + k`. It checks if `(r, c)` is a valid position. If it's valid, the sum will be stored in the `answer` matrix at the same index (i, j). The complexity of this algorithm is O(m * n * k^2), where m is the number of rows, n is the number of columns, and k is the range.\n    "
    },
    {
        "id": 1210,
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "difficulty": "Easy",
        "content": {
            "problem": "**No-Zero integer** is a positive integer that **does not contain any `0`** in its decimal representation.\n\nGiven an integer `n`, return _a list of two integers_ `[a, b]` _where_:\n\n*   `a` and `b` are **No-Zero integers**.\n*   `a + b = n`\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[1,1\\]\n**Explanation:** Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.\n\n",
                "**Example 2:**\n\n**Input:** n = 11\n**Output:** \\[2,9\\]\n**Explanation:** Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 9 = n.\nNote that there are other valid answers as \\[8, 3\\] that can be accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "2",
                "output": "[1,1]"
            },
            {
                "input": "11",
                "output": "[2,9]"
            }
        ],
        "java": "\n    ```java\npublic int[] noZeroIntegers(int n) {\n    for (int a = 1; a < n; ++a) {\n        if (Integer.toString(a).indexOf('0') == -1 &&\n            Integer.toString(n - a).indexOf('0') == -1) {\n            return new int[]{a, n - a};\n        }\n    }\n    return new int[]{0, 0}; // never gets here\n}\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "python": "\n    ```python\ndef no_zero_integers(n: int):\n    for a in range(1, n):\n        if '0' not in str(a) and '0' not in str(n - a):\n            return [a, n - a]\n    return [0, 0]  # never gets here\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "c++": "\n    ```cpp\nstd::vector<int> noZeroIntegers(int n) {\n    for (int a = 1; a < n; ++a) {\n        if (std::to_string(a).find('0') == std::string::npos &&\n            std::to_string(n - a).find('0') == std::string::npos) {\n            return {a, n - a};\n        }\n    }\n    return {0, 0}; // never gets here\n}\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    ",
        "js": "\n    ```javascript\nfunction noZeroIntegers(n) {\n    for (let a = 1; a < n; ++a) {\n        if (!String(a).includes('0') && !String(n - a).includes('0')) {\n            return [a, n - a];\n        }\n    }\n    return [0, 0]; // never gets here\n}\n```\n    \n    We will write a function that receives an integer `n` as the input. The algorithm then iterates over all integers from `1` to `n-1` as a candidate for value `a` in the result `[a, b]`. For each candidate `a`, we check if both `a` and `n-a` (which would be `b`) are No-Zero integers by ensuring that neither of the strings representation have a '0'. If both strings don't have a '0', we found a valid answer and return a list containing `[a, n-a]`. The loop should always find a valid answer for the given constraints.\n    "
    },
    {
        "id": 1214,
        "title": "Maximum 69 Number",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer `num` consisting only of digits `6` and `9`.\n\nReturn _the maximum number you can get by changing **at most** one digit (_`6` _becomes_ `9`_, and_ `9` _becomes_ `6`_)_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 9669\n**Output:** 9969\n**Explanation:** \nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666.\nThe maximum number is 9969.\n\n",
                "**Example 2:**\n\n**Input:** num = 9996\n**Output:** 9999\n**Explanation:** Changing the last digit 6 to 9 results in the maximum number.\n\n",
                "**Example 3:**\n\n**Input:** num = 9999\n**Output:** 9999\n**Explanation:** It is better not to apply any change."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 104`\n*   `num` consists of only `6` and `9` digits.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "9669",
                "output": "9969"
            },
            {
                "input": "9996",
                "output": "9999"
            },
            {
                "input": "9999",
                "output": "9999"
            }
        ],
        "java": "\n    ```java\npublic int maximum69Number (int num) {\n    String numStr = Integer.toString(num);\n    char[] numArr = numStr.toCharArray();\n    for (int i = 0; i < numArr.length; i++) {\n        if (numArr[i] == '6') {\n            numArr[i] = '9';\n            break;\n        }\n    }\n    return Integer.parseInt(new String(numArr));\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "python": "\n    ```python\ndef maximum69Number(num: int) -> int:\n    num_str = list(str(num))\n    for i in range(len(num_str)):\n        if num_str[i] == '6':\n            num_str[i] = '9'\n            break\n    return int(''.join(num_str))\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "c++": "\n    ```cpp\nint maximum69Number (int num) {\n    string numStr = to_string(num);\n    for (char &c : numStr) {\n        if (c == '6') {\n            c = '9';\n            break;\n        }\n    }\n    return stoi(numStr);\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    ",
        "js": "\n    ```javascript\nfunction maximum69Number(num) {\n    let numStr = num.toString();\n    let numArr = Array.from(numStr);\n    for (let i = 0; i < numArr.length; i++) {\n        if (numArr[i] == '6') {\n            numArr[i] = '9';\n            break;\n        }\n    }\n    return parseInt(numArr.join(''));\n}\n```\n    \n    The algorithm to solve this problem is simple:\n\n1. Convert the integer `num` to a string, so that we can easily manipulate individual digits.\n2. Iterate through the string, looking for the first occurrence of the digit '6'.\n3. When the digit '6' is found, change it to '9' and exit the loop.\n4. Convert the modified string back to an integer and return it.\n\nThis algorithm guarantees that only one digit will be modified at most, and the result will be the maximum value possible under the given constraints.\n    "
    },
    {
        "id": 1218,
        "title": "Break a Palindrome",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a palindromic string of lowercase English letters `palindrome`, replace **exactly one** character with any lowercase English letter so that the resulting string is **not** a palindrome and that it is the **lexicographically smallest** one possible.\n\nReturn _the resulting string. If there is no way to replace a character to make it not a palindrome, return an **empty string**._\n\nA string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly smaller than the corresponding character in `b`. For example, `\"abcc \"` is lexicographically smaller than `\"abcd \"` because the first position they differ is at the fourth character, and `'c'` is smaller than `'d'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** palindrome =  \"abccba \"\n**Output:**  \"aaccba \"\n**Explanation:** There are many ways to make  \"abccba \" not a palindrome, such as  \"zbccba \",  \"aaccba \", and  \"abacba \".\nOf all the ways,  \"aaccba \" is the lexicographically smallest.\n\n",
                "**Example 2:**\n\n**Input:** palindrome =  \"a \"\n**Output:**  \" \"\n**Explanation:** There is no way to replace a single character to make  \"a \" not a palindrome, so return an empty string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= palindrome.length <= 1000`\n*   `palindrome` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abccba\"",
                "output": "\"aaccba\""
            },
            {
                "input": "\"a\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String breakPalindrome(String palindrome) {\n    int length = palindrome.length();\n    if (length == 1) return \"\";\n    \n    char[] chars = palindrome.toCharArray();\n    for (int i = 0; i < length / 2; i++) {\n        if (chars[i] != 'a') {\n            chars[i] = 'a';\n            return String.valueOf(chars);\n        }\n    }\n    \n    chars[length - 1] = 'b';\n    return String.valueOf(chars);\n}\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ",
        "python": "\n    ```python\ndef breakPalindrome(palindrome: str) -> str:\n    length = len(palindrome)\n    if length == 1:\n        return \"\"\n    \n    chars = list(palindrome)\n    for i in range(length // 2):\n        if chars[i] != 'a':\n            chars[i] = 'a'\n            return \"\".join(chars)\n    \n    chars[length - 1] = 'b'\n    return \"\".join(chars)\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string breakPalindrome(std::string palindrome) {\n    int length = palindrome.length();\n    if (length == 1) return \"\";\n    \n    for (int i = 0; i < length / 2; i++) {\n        if (palindrome[i] != 'a') {\n            palindrome[i] = 'a';\n            return palindrome;\n        }\n    }\n    \n    palindrome[length - 1] = 'b';\n    return palindrome;\n}\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    ",
        "js": "\n    ```javascript\nfunction breakPalindrome(palindrome) {\n    const length = palindrome.length;\n    if (length === 1) return \"\";\n    \n    let chars = palindrome.split(\"\");\n    for (let i = 0; i < Math.floor(length / 2); i++) {\n        if (chars[i] !== 'a') {\n            chars[i] = 'a';\n            return chars.join(\"\");\n        }\n    }\n    \n    chars[length - 1] = 'b';\n    return chars.join(\"\");\n}\n```\n    \n    To find the lexicographically smallest non-palindromic string, we first check if the length of the input string is 1. If it is, we return an empty string since we can't change a single character to make it a non-palindrome. Otherwise, we iterate through the first half of the string and look for any character not equal to `'a'`. If we find one, we change it to `'a'` and return the new string.\n\nIf we reach the end of the loop without finding a non-`'a'` character, it means that the string is composed of only `'a'` characters. In this case, we can change the last character to `'b'` to create a non-palindrome, and return the result. This ensures the lexicographically smallest string since it only changes one character and does so as early in the string as possible.\n    "
    },
    {
        "id": 1250,
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the array `nums`, for each `nums[i]` find out how many numbers in the array are smaller than it. That is, for each `nums[i]` you have to count the number of valid `j's` such that `j != i` **and** `nums[j] < nums[i]`.\n\nReturn the answer in an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[8,1,2,2,3\\]\n**Output:** \\[4,0,1,1,3\\]\n**Explanation:** \nFor nums\\[0\\]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums\\[1\\]=1 does not exist any smaller number than it.\nFor nums\\[2\\]=2 there exist one smaller number than it (1). \nFor nums\\[3\\]=2 there exist one smaller number than it (1). \nFor nums\\[4\\]=3 there exist three smaller numbers than it (1, 2 and 2).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,5,4,8\\]\n**Output:** \\[2,1,0,3\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,7,7,7\\]\n**Output:** \\[0,0,0,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 500`\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Counting"
        ],
        "example": [
            {
                "input": "[8,1,2,2,3]",
                "output": "[4,0,1,1,3]"
            },
            {
                "input": "[6,5,4,8]",
                "output": "[2,1,0,3]"
            },
            {
                "input": "[7,7,7,7]",
                "output": "[0,0,0,0]"
            }
        ],
        "java": "\n    ```java\npublic int[] smallerNumbersThanCurrent(int[] nums) {\n    int[] result = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n        int count = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (i != j && nums[j] < nums[i]) {\n                count++;\n            }\n        }\n        result[i] = count;\n    }\n    return result;\n}\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    ",
        "python": "\n    ```python\ndef smallerNumbersThanCurrent(nums):\n    result = []\n    for i in range(len(nums)):\n        count = 0\n        for j in range(len(nums)):\n            if i != j and nums[j] < nums[i]:\n                count += 1\n        result.append(count)\n    return result\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n    vector<int> result(nums.size());\n    for (int i = 0; i < nums.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < nums.size(); j++) {\n            if (i != j && nums[j] < nums[i]) {\n                count++;\n            }\n        }\n        result[i] = count;\n    }\n    return result;\n}\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    ",
        "js": "\n    ```javascript\nfunction smallerNumbersThanCurrent(nums) {\n    let result = [];\n    for (let i = 0; i < nums.length; i++) {\n        let count = 0;\n        for (let j = 0; j < nums.length; j++) {\n            if (i !== j && nums[j] < nums[i]) {\n                count++;\n            }\n        }\n        result.push(count);\n    }\n    return result;\n}\n```\n    \n    The algorithm implements a simple nested loop. For each element `nums[i]` in the input array `nums`, compare it to all other elements in the array. If any element `nums[j]` is smaller than `nums[i]` and `j` is not equal to `i`, increment a counter. After iterating through all elements, store the value of the counter in the result array at the same index as the current element `nums[i]`. Finally, return the result array.\n    "
    },
    {
        "id": 1260,
        "title": "Time Needed to Inform All Employees",
        "difficulty": "Medium",
        "content": {
            "problem": "A company has `n` employees with a unique ID for each employee from `0` to `n - 1`. The head of the company is the one with `headID`.\n\nEach employee has one direct manager given in the `manager` array where `manager[i]` is the direct manager of the `i-th` employee, `manager[headID] = -1`. Also, it is guaranteed that the subordination relationships have a tree structure.\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\nThe `i-th` employee needs `informTime[i]` minutes to inform all of his direct subordinates (i.e., After informTime\\[i\\] minutes, all his direct subordinates can start spreading the news).\n\nReturn _the number of minutes_ needed to inform all the employees about the urgent news.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1, headID = 0, manager = \\[-1\\], informTime = \\[0\\]\n**Output:** 0\n**Explanation:** The head of the company is the only employee in the company.\n\n",
                "**Example 2:**\n\n**Input:** n = 6, headID = 2, manager = \\[2,2,-1,2,2,2\\], informTime = \\[0,0,1,0,0,0\\]\n**Output:** 1\n**Explanation:** The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `0 <= headID < n`\n*   `manager.length == n`\n*   `0 <= manager[i] < n`\n*   `manager[headID] == -1`\n*   `informTime.length == n`\n*   `0 <= informTime[i] <= 1000`\n*   `informTime[i] == 0` if employee `i` has no subordinates.\n*   It is **guaranteed** that all the employees can be informed.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "1,0,[-1],[0]",
                "output": "0"
            },
            {
                "input": "6,2,[2,2,-1,2,2,2],[0,0,1,0,0,0]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\n    List<List<Integer>> subordinates = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n        subordinates.add(new ArrayList<>());\n    }\n    for (int i = 0; i < n; ++i) {\n        if (manager[i] != -1) {\n            subordinates.get(manager[i]).add(i);\n        }\n    }\n    return dfs(headID, subordinates, informTime);\n}\n\nprivate int dfs(int employee, List<List<Integer>> subordinates, int[] informTime) {\n    if (informTime[employee] == 0) {\n        return 0;\n    }\n    int max_time = 0;\n    for (int i : subordinates.get(employee)) {\n        max_time = Math.max(max_time, dfs(i, subordinates, informTime));\n    }\n    return max_time + informTime[employee];\n}\n```\n\n    \n    The algorithm first builds a data structure (adjacency list) to represent the tree of subordinates, and then performs a depth-first search from the headID to find the maximum time taken to inform all employees. In each step of the DFS, it iterates through the direct subordinates of the current employee and calculates the time required for that employee to inform everyone. The maximum time from all possible subordinates is added to the current employee's informTime and returned. This continues recursively until the entire organization is processed.\n    ",
        "python": "\n    ```python\ndef numOfMinutes(n, headID, manager, informTime):\n    subordinates = [[] for _ in range(n)]\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n    return dfs(headID, subordinates, informTime)\n\ndef dfs(employee, subordinates, informTime):\n    if informTime[employee] == 0:\n        return 0\n    max_time = 0\n    for i in subordinates[employee]:\n        max_time = max(max_time, dfs(i, subordinates, informTime))\n    return max_time + informTime[employee]\n```\n\n    \n    The algorithm first builds a data structure (adjacency list) to represent the tree of subordinates, and then performs a depth-first search from the headID to find the maximum time taken to inform all employees. In each step of the DFS, it iterates through the direct subordinates of the current employee and calculates the time required for that employee to inform everyone. The maximum time from all possible subordinates is added to the current employee's informTime and returned. This continues recursively until the entire organization is processed.\n    ",
        "c++": "\n    ```cpp\nint numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n    vector<vector<int>> subordinates(n);\n    for (int i = 0; i < n; ++i) {\n        if (manager[i] != -1) {\n            subordinates[manager[i]].push_back(i);\n        }\n    }\n    return dfs(headID, subordinates, informTime);\n}\n\nint dfs(int employee, vector<vector<int>>& subordinates, vector<int>& informTime) {\n    if (informTime[employee] == 0) {\n        return 0;\n    }\n    int max_time = 0;\n    for (int i : subordinates[employee]) {\n        max_time = max(max_time, dfs(i, subordinates, informTime));\n    }\n    return max_time + informTime[employee];\n}\n```\n\n    \n    The algorithm first builds a data structure (adjacency list) to represent the tree of subordinates, and then performs a depth-first search from the headID to find the maximum time taken to inform all employees. In each step of the DFS, it iterates through the direct subordinates of the current employee and calculates the time required for that employee to inform everyone. The maximum time from all possible subordinates is added to the current employee's informTime and returned. This continues recursively until the entire organization is processed.\n    ",
        "js": "\n    ```javascript\nfunction numOfMinutes(n, headID, manager, informTime) {\n    const subordinates = Array.from({length: n}, () => []);\n    for (let i = 0; i < n; ++i) {\n        if (manager[i] !== -1) {\n            subordinates[manager[i]].push(i);\n        }\n    }\n    return dfs(headID, subordinates, informTime);\n}\n\nfunction dfs(employee, subordinates, informTime) {\n    if (informTime[employee] === 0) {\n        return 0;\n    }\n    let max_time = 0;\n    for (const i of subordinates[employee]) {\n        max_time = Math.max(max_time, dfs(i, subordinates, informTime));\n    }\n    return max_time + informTime[employee];\n}\n```\n\n    \n    The algorithm first builds a data structure (adjacency list) to represent the tree of subordinates, and then performs a depth-first search from the headID to find the maximum time taken to inform all employees. In each step of the DFS, it iterates through the direct subordinates of the current employee and calculates the time required for that employee to inform everyone. The maximum time from all possible subordinates is added to the current employee's informTime and returned. This continues recursively until the entire organization is processed.\n    "
    },
    {
        "id": 1267,
        "title": "Find the Distance Value Between Two Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `arr1` and `arr2`, and the integer `d`, _return the distance value between the two arrays_.\n\nThe distance value is defined as the number of elements `arr1[i]` such that there is not any element `arr2[j]` where `|arr1[i]-arr2[j]| <= d`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[4,5,8\\], arr2 = \\[10,9,1,8\\], d = 2\n**Output:** 2\n**Explanation:** \nFor arr1\\[0\\]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1\\[1\\]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1\\[2\\]=8 we have:\n**|8-10|=2 <= d=2**\n**|8-9|=1 <= d=2**\n|8-1|=7 > d=2\n**|8-8|=0 <= d=2**\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[1,4,2,3\\], arr2 = \\[-4,-3,6,10,20,30\\], d = 3\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** arr1 = \\[2,1,100,3\\], arr2 = \\[-5,-2,10,-3,7\\], d = 6\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 500`\n*   `-1000 <= arr1[i], arr2[j] <= 1000`\n*   `0 <= d <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,5,8],[10,9,1,8],2",
                "output": "2"
            },
            {
                "input": "[1,4,2,3],[-4,-3,6,10,20,30],3",
                "output": "2"
            },
            {
                "input": "[2,1,100,3],[-5,-2,10,-3,7],6",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\n    int distance = 0;\n    for (int a : arr1) {\n        boolean found = true;\n        for (int b : arr2) {\n            if (Math.abs(a - b) <= d) {\n                found = false;\n                break;\n            }\n        }\n        if (found) distance++;\n    }\n    return distance;\n}\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    ",
        "python": "\n    ```python\ndef findTheDistanceValue(arr1, arr2, d):\n    distance = 0\n    for a in arr1:\n        found = True\n        for b in arr2:\n            if abs(a - b) <= d:\n                found = False\n                break\n        if found:\n            distance += 1\n    return distance\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    ",
        "c++": "\n    ```cpp\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n    int distance = 0;\n    for (int a : arr1) {\n        bool found = true;\n        for (int b : arr2) {\n            if (abs(a - b) <= d) {\n                found = false;\n                break;\n            }\n        }\n        if (found) distance++;\n    }\n    return distance;\n}\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    ",
        "js": "\n    ```javascript\nfunction findTheDistanceValue(arr1, arr2, d) {\n    let distance = 0;\n    for (let a of arr1) {\n        let found = true;\n        for (let b of arr2) {\n            if (Math.abs(a - b) <= d) {\n                found = false;\n                break;\n            }\n        }\n        if (found) distance++;\n    }\n    return distance;\n}\n```\n    \n    For each element `a` in array `arr1`, we iterate through all elements `b` in array `arr2` and check the condition `|a-b| <= d`. If we find an element `b` that satisfies the condition, we stop searching and move to the next element of `arr1`. If we haven't found any such element, we increment the distance value. Finally, we return the distance value after processing all elements of `arr1`.\n    "
    },
    {
        "id": 1270,
        "title": "Four Divisors",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _the sum of divisors of the integers in that array that have exactly four divisors_. If there is no such integer in the array, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[21,4,7\\]\n**Output:** 32\n**Explanation:** \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[21,21\\]\n**Output:** 64\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[21,4,7]",
                "output": "32"
            },
            {
                "input": "[21,21]",
                "output": "64"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int sumOfFourDivisors(int[] nums) {\n    int sum = 0;\n    for (int num : nums) {\n        int count = 0;\n        int div_sum = 0;\n        for (int i = 1; i * i <= num; ++i) {\n            if (num % i == 0) {\n                count += (i * i == num) ? 1 : 2;\n                div_sum += i + (num / i);\n                if (count > 4) break;\n            }\n        }\n        if (count == 4) sum += div_sum;\n    }\n    return sum;\n}\n```\n    \n    The algorithm iterates through each number in the `nums` array. For each number, it calculates the number of divisors and their sum. If a number has a square root, the count of divisors is incremented once, instead of twice, and the divisor sum is incremented by that number and its corresponding divisor, except when the loop finds a square root divisor. When the count of divisors exceeds 4, the loop breaks. If a number has exactly 4 divisors, the sum of its divisors is added to the final answer. The result is returned after processing all the numbers in the input array.\n    ",
        "python": "\n    ```python\ndef sum_of_four_divisors(nums):\n    total_sum = 0\n    for num in nums:\n        count = 0\n        div_sum = 0\n        i = 1\n        while i * i <= num:\n            if num % i == 0:\n                count += 1 if i * i == num else 2\n                div_sum += i + (num // i)\n                if count > 4:\n                    break\n            i += 1\n        if count == 4:\n            total_sum += div_sum\n    return total_sum\n```\n    \n    The algorithm iterates through each number in the `nums` array. For each number, it calculates the number of divisors and their sum. If a number has a square root, the count of divisors is incremented once, instead of twice, and the divisor sum is incremented by that number and its corresponding divisor, except when the loop finds a square root divisor. When the count of divisors exceeds 4, the loop breaks. If a number has exactly 4 divisors, the sum of its divisors is added to the final answer. The result is returned after processing all the numbers in the input array.\n    ",
        "c++": "\n    ```cpp\nint sumOfFourDivisors(std::vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        int count = 0;\n        int div_sum = 0;\n        for (int i = 1; i * i <= num; ++i) {\n            if (num % i == 0) {\n                count += (i * i == num) ? 1 : 2;\n                div_sum += i + (num / i);\n                if (count > 4) break;\n            }\n        }\n        if (count == 4) sum += div_sum;\n    }\n    return sum;\n}\n```\n    \n    The algorithm iterates through each number in the `nums` array. For each number, it calculates the number of divisors and their sum. If a number has a square root, the count of divisors is incremented once, instead of twice, and the divisor sum is incremented by that number and its corresponding divisor, except when the loop finds a square root divisor. When the count of divisors exceeds 4, the loop breaks. If a number has exactly 4 divisors, the sum of its divisors is added to the final answer. The result is returned after processing all the numbers in the input array.\n    ",
        "js": "\n    ```javascript\nfunction sumOfFourDivisors(nums) {\n    let sum = 0;\n    for (let num of nums) {\n        let count = 0;\n        let div_sum = 0;\n        for (let i = 1; i * i <= num; ++i) {\n            if (num % i === 0) {\n                count += (i * i === num) ? 1 : 2;\n                div_sum += i + (num / i);\n                if (count > 4) break;\n            }\n        }\n        if (count === 4) sum += div_sum;\n    }\n    return sum;\n}\n```\n    \n    The algorithm iterates through each number in the `nums` array. For each number, it calculates the number of divisors and their sum. If a number has a square root, the count of divisors is incremented once, instead of twice, and the divisor sum is incremented by that number and its corresponding divisor, except when the loop finds a square root divisor. When the count of divisors exceeds 4, the loop breaks. If a number has exactly 4 divisors, the sum of its divisors is added to the final answer. The result is returned after processing all the numbers in the input array.\n    "
    },
    {
        "id": 1272,
        "title": "Find Lucky Integer in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, a **lucky integer** is an integer that has a frequency in the array equal to its value.\n\nReturn _the largest **lucky integer** in the array_. If there is no **lucky integer** return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,2,3,4\\]\n**Output:** 2\n**Explanation:** The only lucky number in the array is 2 because frequency\\[2\\] == 2.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,2,3,3,3\\]\n**Output:** 3\n**Explanation:** 1, 2 and 3 are all lucky numbers, return the largest of them.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[2,2,2,3,3\\]\n**Output:** -1\n**Explanation:** There are no lucky numbers in the array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 500`\n*   `1 <= arr[i] <= 500`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[2,2,3,4]",
                "output": "2"
            },
            {
                "input": "[1,2,2,3,3,3]",
                "output": "3"
            },
            {
                "input": "[2,2,2,3,3]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findLucky(int[] arr) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int num : arr) {\n        freq.put(num, freq.getOrDefault(num, 0) + 1);\n    }\n    int maxLucky = -1;\n    for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n        if (entry.getKey().equals(entry.getValue())) {\n            maxLucky = Math.max(maxLucky, entry.getKey());\n        }\n    }\n    return maxLucky;\n}\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    ",
        "python": "\n    ```python\ndef find_lucky(arr):\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    max_lucky = -1\n    for num, count in freq.items():\n        if num == count:\n            max_lucky = max(max_lucky, num)\n    return max_lucky\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    ",
        "c++": "\n    ```cpp\nint findLucky(vector<int>& arr) {\n    unordered_map<int, int> freq;\n    for (int num : arr) {\n        freq[num]++;\n    }\n    int maxLucky = -1;\n    for (auto& pair : freq) {\n        if (pair.first == pair.second) {\n            maxLucky = max(maxLucky, pair.first);\n        }\n    }\n    return maxLucky;\n}\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    ",
        "js": "\n    ```javascript\nfunction findLucky(arr) {\n    const freq = {};\n    for (const num of arr) {\n        if (!freq[num]) {\n            freq[num] = 0;\n        }\n        freq[num]++;\n    }\n    let maxLucky = -1;\n    for (const [num, count] of Object.entries(freq)) {\n        if ( parseInt(num) === count) {\n            maxLucky = Math.max(maxLucky, parseInt(num));\n        }\n    }\n    return maxLucky;\n}\n```\n    \n    The algorithm iterates over the input array, computing the frequency of each number. It then iterates through the frequencies and checks if the number and its frequency match. If they do, it keeps track of the maximum such number. Finally, the algorithm returns the maximum lucky integer. If no lucky integer is found, the function returns -1.\n    "
    },
    {
        "id": 1276,
        "title": "Count Largest Group",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `n`.\n\nEach number from `1` to `n` is grouped according to the sum of its digits.\n\nReturn _the number of groups that have the largest size_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13\n**Output:** 4\n**Explanation:** There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n\\[1,10\\], \\[2,11\\], \\[3,12\\], \\[4,13\\], \\[5\\], \\[6\\], \\[7\\], \\[8\\], \\[9\\].\nThere are 4 groups with largest size.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are 2 groups \\[1\\], \\[2\\] of size 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math"
        ],
        "example": [
            {
                "input": "13",
                "output": "4"
            },
            {
                "input": "2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countLargestGroup(int n) {\n    int[] groups = new int[37];\n    int largest_group_size = 0;\n    int count_largest_groups = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int sum = 0, num = i;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        groups[sum]++;\n        if (groups[sum] > largest_group_size) {\n            largest_group_size = groups[sum];\n            count_largest_groups = 1;\n        } else if (groups[sum] == largest_group_size) {\n            count_largest_groups++;\n        }\n    }\n    return count_largest_groups;\n}\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "python": "\n    ```python\ndef countLargestGroup(n: int) -> int:\n    groups = [0] * 37\n    largest_group_size = 0\n    count_largest_groups = 0\n\n    for i in range(1, n + 1):\n        sum_of_digits = sum(map(int, str(i)))\n        groups[sum_of_digits] += 1\n        if groups[sum_of_digits] > largest_group_size:\n            largest_group_size = groups[sum_of_digits]\n            count_largest_groups = 1\n        elif groups[sum_of_digits] == largest_group_size:\n            count_largest_groups += 1\n\n    return count_largest_groups\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "c++": "\n    ```cpp\nint countLargestGroup(int n) {\n    std::vector<int> groups(37, 0);\n    int largest_group_size = 0;\n    int count_largest_groups = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        int sum = 0, num = i;\n        while (num) {\n            sum += num % 10;\n            num /= 10;\n        }\n        groups[sum]++;\n        if (groups[sum] > largest_group_size) {\n            largest_group_size = groups[sum];\n            count_largest_groups = 1;\n        } else if (groups[sum] == largest_group_size) {\n            count_largest_groups++;\n        }\n    }\n    return count_largest_groups;\n}\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    ",
        "js": "\n    ```javascript\nfunction countLargestGroup(n) {\n    const groups = new Array(37).fill(0);\n    let largest_group_size = 0;\n    let count_largest_groups = 0;\n\n    for (let i = 1; i <= n; i++) {\n        const sum = i.toString().split('').reduce((a, b) => a + parseInt(b), 0);\n        groups[sum]++;\n        if (groups[sum] > largest_group_size) {\n            largest_group_size = groups[sum];\n            count_largest_groups = 1;\n        } else if (groups[sum] === largest_group_size) {\n            count_largest_groups++;\n        }\n    }\n    return count_largest_groups;\n};\n```\n    \n    The algorithm iterates through every number from 1 to n. For each number, calculate the sum of its digits. Increment the count for the group corresponding to that sum of digits. Update the largest group size if the current group becomes larger than the previous largest group. If the current group size is equal to the largest group size, increment the count of largest groups.\n\nThe algorithm has a time complexity of O(n), as it processes each number from 1 to n once.\n    "
    },
    {
        "id": 1347,
        "title": "Running Sum of 1d Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums`. We define a running sum of an array as `runningSum[i] = sum(nums[0]...nums[i])`.\n\nReturn the running sum of `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[1,3,6,10\\]\n**Explanation:** Running sum is obtained as follows: \\[1, 1+2, 1+2+3, 1+2+3+4\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,1\\]\n**Output:** \\[1,2,3,4,5\\]\n**Explanation:** Running sum is obtained as follows: \\[1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,1,2,10,1\\]\n**Output:** \\[3,4,6,16,17\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-10^6 <= nums[i] <= 10^6`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "[1,3,6,10]"
            },
            {
                "input": "[1,1,1,1,1]",
                "output": "[1,2,3,4,5]"
            },
            {
                "input": "[3,1,2,10,1]",
                "output": "[3,4,6,16,17]"
            }
        ],
        "java": "\n    ```java\npublic int[] runningSum(int[] nums) {\n    for(int i = 1; i < nums.length; i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    ",
        "python": "\n    ```python\ndef runningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    return nums\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nstd::vector<int> runningSum(std::vector<int>& nums) {\n    for(int i = 1; i < nums.size(); i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    ",
        "js": "\n    ```javascript\nfunction runningSum(nums) {\n    for(let i = 1; i < nums.length; i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n```\n    \n    The solution for this problem is to iterate through the input array `nums` starting from the second element (index 1). In each iteration, we add the preceding element to the current element using the formula `nums[i] += nums[i - 1]`. After finishing the loop, the modified input array is the running sum of the original array.\n\nThe logic is exactly the same across all languages; we just have to appropriately manage syntax differences.\n    "
    },
    {
        "id": 1367,
        "title": "Count Submatrices With All Ones",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` binary matrix `mat`, _return the number of **submatrices** that have all ones_.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,0,1\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 13\n**Explanation:** \nThere are 6 rectangles of side 1x1.\nThere are 2 rectangles of side 1x2.\nThere are 3 rectangles of side 2x1.\nThere is 1 rectangle of side 2x2. \nThere is 1 rectangle of side 3x1.\nTotal number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[0,1,1,0\\],\\[0,1,1,1\\],\\[1,1,1,0\\]\\]\n**Output:** 24\n**Explanation:** \nThere are 8 rectangles of side 1x1.\nThere are 5 rectangles of side 1x2.\nThere are 2 rectangles of side 1x3. \nThere are 4 rectangles of side 2x1.\nThere are 2 rectangles of side 2x2. \nThere are 2 rectangles of side 3x1. \nThere is 1 rectangle of side 3x2. \nTotal number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 150`\n*   `mat[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Stack",
            "Matrix",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[[1,0,1],[1,1,0],[1,1,0]]",
                "output": "13"
            },
            {
                "input": "[[0,1,1,0],[0,1,1,1],[1,1,1,0]]",
                "output": "24"
            }
        ],
        "java": "\n    ```java\npublic int numSubmat(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    int[][] dp = new int[m][n];\n    int ans = 0;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 1) {\n                dp[i][j] = j == 0 ? 1 : dp[i][j-1] + 1;\n                int width = dp[i][j];\n                for (int k = i; k >= 0; k--) {\n                    width = Math.min(width, dp[k][j]);\n                    ans += width;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We first create a 2D array `dp` of the same size as `mat`. Then, we iterate through each element `mat[i][j]`. If `mat[i][j]` is 1, we calculate the value of `dp[i][j]`. The value `dp[i][j]` represents the number of continuous 1s in the row from the current position to the left. Thus, `dp[i][j] = 1` if `j == 0` (i.e., this is the first element in the row), otherwise `dp[i][j] = dp[i][j-1] + 1`.\n\nThen, we iterate from the current row `i` to the first row (0) and calculate the minimum width of the continuous 1s in the columns at position `j` for each row. The sum of these minimum widths gives the total number of submatrices containing all 1s.\n\nFinally, the function returns the sum of all submatrices.\n\nTime complexity: O(m * n * m) since we have to iterate through all the elements in the matrix and then again for each row from the current row to the first.\nSpace complexity: O(m * n) for the `dp` array.\n    ",
        "python": "\n    ```python\ndef numSubmat(mat: List[List[int]]) -> int:\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    ans = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if mat[i][j]:\n                dp[i][j] = 1 if j == 0 else dp[i][j-1] + 1\n                width = dp[i][j]\n                for k in range(i, -1, -1):\n                    width = min(width, dp[k][j])\n                    ans += width\n    \n    return ans\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We first create a 2D array `dp` of the same size as `mat`. Then, we iterate through each element `mat[i][j]`. If `mat[i][j]` is 1, we calculate the value of `dp[i][j]`. The value `dp[i][j]` represents the number of continuous 1s in the row from the current position to the left. Thus, `dp[i][j] = 1` if `j == 0` (i.e., this is the first element in the row), otherwise `dp[i][j] = dp[i][j-1] + 1`.\n\nThen, we iterate from the current row `i` to the first row (0) and calculate the minimum width of the continuous 1s in the columns at position `j` for each row. The sum of these minimum widths gives the total number of submatrices containing all 1s.\n\nFinally, the function returns the sum of all submatrices.\n\nTime complexity: O(m * n * m) since we have to iterate through all the elements in the matrix and then again for each row from the current row to the first.\nSpace complexity: O(m * n) for the `dp` array.\n    ",
        "c++": "\n    ```cpp\nint numSubmat(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n    int ans = 0;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j]) {\n                dp[i][j] = j == 0 ? 1 : dp[i][j-1] + 1;\n                int width = dp[i][j];\n                for (int k = i; k >= 0; k--) {\n                    width = min(width, dp[k][j]);\n                    ans += width;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We first create a 2D array `dp` of the same size as `mat`. Then, we iterate through each element `mat[i][j]`. If `mat[i][j]` is 1, we calculate the value of `dp[i][j]`. The value `dp[i][j]` represents the number of continuous 1s in the row from the current position to the left. Thus, `dp[i][j] = 1` if `j == 0` (i.e., this is the first element in the row), otherwise `dp[i][j] = dp[i][j-1] + 1`.\n\nThen, we iterate from the current row `i` to the first row (0) and calculate the minimum width of the continuous 1s in the columns at position `j` for each row. The sum of these minimum widths gives the total number of submatrices containing all 1s.\n\nFinally, the function returns the sum of all submatrices.\n\nTime complexity: O(m * n * m) since we have to iterate through all the elements in the matrix and then again for each row from the current row to the first.\nSpace complexity: O(m * n) for the `dp` array.\n    ",
        "js": "\n    ```javascript\nfunction numSubmat(mat) {\n    const m = mat.length, n = mat[0].length;\n    const dp = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\n    let ans = 0;\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (mat[i][j] === 1) {\n                dp[i][j] = j === 0 ? 1 : dp[i][j-1] + 1;\n                let width = dp[i][j];\n                for (let k = i; k >= 0; k--) {\n                    width = Math.min(width, dp[k][j]);\n                    ans += width;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We first create a 2D array `dp` of the same size as `mat`. Then, we iterate through each element `mat[i][j]`. If `mat[i][j]` is 1, we calculate the value of `dp[i][j]`. The value `dp[i][j]` represents the number of continuous 1s in the row from the current position to the left. Thus, `dp[i][j] = 1` if `j == 0` (i.e., this is the first element in the row), otherwise `dp[i][j] = dp[i][j-1] + 1`.\n\nThen, we iterate from the current row `i` to the first row (0) and calculate the minimum width of the continuous 1s in the columns at position `j` for each row. The sum of these minimum widths gives the total number of submatrices containing all 1s.\n\nFinally, the function returns the sum of all submatrices.\n\nTime complexity: O(m * n * m) since we have to iterate through all the elements in the matrix and then again for each row from the current row to the first.\nSpace complexity: O(m * n) for the `dp` array.\n    "
    },
    {
        "id": 1372,
        "title": "Minimum Difference Between Largest and Smallest Value in Three Moves",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,3,2,4\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes \\[5,3,3,4\\].\nIn the second move, change 4 to 3. nums becomes \\[5,3,3,3\\].\nIn the third move, change 5 to 3. nums becomes \\[3,3,3,3\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,0,10,14\\]\n**Output:** 1\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes \\[1,0,0,10,14\\].\nIn the second move, change 10 to 0. nums becomes \\[1,0,0,0,14\\].\nIn the third move, change 14 to 1. nums becomes \\[1,0,0,0,1\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.\nIt can be shown that there is no way to make the difference 0 in 3 moves.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,100,20\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes \\[4,7,20\\].\nIn the second move, change 20 to 7. nums becomes \\[4,7,7\\].\nIn the third move, change 4 to 3. nums becomes \\[7,7,7\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[5,3,2,4]",
                "output": "0"
            },
            {
                "input": "[1,5,0,10,14]",
                "output": "1"
            },
            {
                "input": "[3,100,20]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minDifference(int[] nums) {\n    int n = nums.length;\n    if (n <= 4) return 0;\n    Arrays.sort(nums);\n    int res = Integer.MAX_VALUE;\n    for (int i = 0; i <= 3; ++i)\n        res = Math.min(res, nums[n - 4 + i] - nums[i]);\n    return res;\n}\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ",
        "python": "\n    ```python\ndef minDifference(nums):\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ",
        "c++": "\n    ```cpp\nint minDifference(vector<int>& nums) {\n    int n = nums.size();\n    if (n <= 4) return 0;\n    sort(nums.begin(), nums.end());\n    int res = INT_MAX;\n    for (int i = 0; i <= 3; ++i)\n        res = min(res, nums[n - 4 + i] - nums[i]);\n    return res;\n}\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    ",
        "js": "\n    ```javascript\nfunction minDifference(nums) {\n    let n = nums.length;\n    if (n <= 4) return 0;\n    nums.sort((a, b) => a - b);\n    let res = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i <= 3; ++i)\n        res = Math.min(res, nums[n - 4 + i] - nums[i]);\n    return res;\n}\n```\n    \n    1. First, check if the length of the input array is less than or equal to 4. If it is, return 0 since there's no need to perform any operation on this input.\n2. Sort the input array in ascending order.\n3. Initialize the result (minimum difference) as the maximum value possible.\n4. Loop through the array from the 0-th element to the 3-rd element (inclusive). For each iteration, find the difference between the (n - 4 + i)-th element and the i-th element in the sorted array, where n is the length of the input array. Update the result as the minimum of the current and previous minimum differences.\n5. After the loop, return the resulting minimum difference.\n    "
    },
    {
        "id": 1379,
        "title": "Water Bottles",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `numBottles` water bottles that are initially full of water. You can exchange `numExchange` empty water bottles from the market with one full water bottle.\n\nThe operation of drinking a full water bottle turns it into an empty bottle.\n\nGiven the two integers `numBottles` and `numExchange`, return _the **maximum** number of water bottles you can drink_.",
            "examples": [
                "**Example 1:**\n\n**Input:** numBottles = 9, numExchange = 3\n**Output:** 13\n**Explanation:** You can exchange 3 empty bottles to get 1 full water bottle.\nNumber of water bottles you can drink: 9 + 3 + 1 = 13.\n\n",
                "**Example 2:**\n\n**Input:** numBottles = 15, numExchange = 4\n**Output:** 19\n**Explanation:** You can exchange 4 empty bottles to get 1 full water bottle. \nNumber of water bottles you can drink: 15 + 3 + 1 = 19."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= numBottles <= 100`\n*   `2 <= numExchange <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "9,3",
                "output": "13"
            },
            {
                "input": "15,4",
                "output": "19"
            }
        ],
        "java": "\n    ```java\npublic int numWaterBottles(int numBottles, int numExchange) {\n    int totalBottles = numBottles;\n    while (numBottles >= numExchange) {\n        int newBottles = numBottles / numExchange;\n        totalBottles += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return totalBottles;\n}\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    ",
        "python": "\n    ```python\ndef numWaterBottles(numBottles: int, numExchange: int) -> int:\n    totalBottles = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        totalBottles += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return totalBottles\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    ",
        "c++": "\n    ```cpp\nint numWaterBottles(int numBottles, int numExchange) {\n    int totalBottles = numBottles;\n    while (numBottles >= numExchange) {\n        int newBottles = numBottles / numExchange;\n        totalBottles += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return totalBottles;\n}\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    ",
        "js": "\n    ```javascript\nfunction numWaterBottles(numBottles, numExchange) {\n    let totalBottles = numBottles;\n    while (numBottles >= numExchange) {\n        let newBottles = Math.floor(numBottles / numExchange);\n        totalBottles += newBottles;\n        numBottles = newBottles + numBottles % numExchange;\n    }\n    return totalBottles;\n}\n```\n    \n    The algorithm initializes the totalBottles variable with the value of numBottles. It then uses a while loop to repeatedly calculate the number of new full bottles the person can get by exchanging the current number of empty bottles.\n\nIn each iteration, the loop calculates the new number of full bottles by dividing numBottles by numExchange and flooring the result. It then adds these new bottles to the totalBottles variable. The loop also updates the number of empty bottles by adding the new full bottles and the remainder of numBottles divided by numExchange.\n\nOnce the number of empty bottles is less than the required numExchange, the loop terminates, and the function returns the value of totalBottles as the maximum number of water bottles the person can drink.\n    "
    },
    {
        "id": 1384,
        "title": "Count Odd Numbers in an Interval Range",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two non-negative integers `low` and `high`. Return the _count of odd numbers between_ `low` _and_ `high` _(inclusive)_.",
            "examples": [
                "**Example 1:**\n\n**Input:** low = 3, high = 7\n**Output:** 3\n**Explanation:** The odd numbers between 3 and 7 are \\[3,5,7\\].\n\n",
                "**Example 2:**\n\n**Input:** low = 8, high = 10\n**Output:** 1\n**Explanation:** The odd numbers between 8 and 10 are \\[9\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= low <= high <= 10^9`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "3,7",
                "output": "3"
            },
            {
                "input": "8,10",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int countOdds(int low, int high) {\n    return (high - low) / 2 + ((low % 2 == 1 || high % 2 == 1) ? 1 : 0);\n}\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "python": "\n    ```python\ndef count_odds(low, high):\n    return (high - low) // 2 + (1 if low % 2 == 1 or high % 2 == 1 else 0)\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "c++": "\n    ```cpp\nint count_odds(int low, int high) {\n    return (high - low) / 2 + ((low % 2 == 1 || high % 2 == 1) ? 1 : 0);\n}\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    ",
        "js": "\n    ```javascript\nfunction countOdds(low, high) {\n    return Math.floor((high - low) / 2) + ((low % 2 === 1 || high % 2 === 1) ? 1 : 0);\n}\n```\n    \n    The algorithm first calculates the total number of integer values between `low` and `high`, using the difference divided by 2. Then, it checks whether `low` or `high` is odd (remainder when divided by 2 equals 1). If either of them is odd, it means we have one more odd number to include, so we add 1 to the result. Otherwise, we don't add anything, as the range does not include an extra odd number. This algorithm is efficient and will directly provide the count of odd numbers within the range without any looping. \n    "
    },
    {
        "id": 1430,
        "title": "Minimum Time to Make Rope Colorful",
        "difficulty": "Medium",
        "content": {
            "problem": "Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.\n\nAlice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.\n\nReturn _the **minimum time** Bob needs to make the rope **colorful**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** colors =  \"abaac \", neededTime = \\[1,2,3,4,5\\]\n**Output:** 3\n**Explanation:** In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n\n",
                "**Example 2:**\n\n**Input:** colors =  \"abc \", neededTime = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** The rope is already colorful. Bob does not need to remove any balloons from the rope.\n\n",
                "**Example 3:**\n\n**Input:** colors =  \"aabaa \", neededTime = \\[1,2,3,4,1\\]\n**Output:** 2\n**Explanation:** Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2."
            ],
            "constraints": "**Constraints:**\n\n*   `n == colors.length == neededTime.length`\n*   `1 <= n <= 105`\n*   `1 <= neededTime[i] <= 104`\n*   `colors` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abaac\",[1,2,3,4,5]",
                "output": "3"
            },
            {
                "input": "\"abc\",[1,2,3]",
                "output": "0"
            },
            {
                "input": "\"aabaa\",[1,2,3,4,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minTime(String colors, int[] neededTime) {\n    int res = 0, prev = -1;\n    for (int i = 0; i < colors.length() - 1; i++) {\n        if (colors.charAt(i) == colors.charAt(i + 1)) {\n            if (prev == -1 || neededTime[i] < neededTime[prev]) prev = i;\n            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;\n            res += neededTime[prev];\n            neededTime[prev] = 1000000;\n            prev = -1;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ",
        "python": "\n    ```python\ndef minTime(colors: str, neededTime: List[int]) -> int:\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ",
        "c++": "\n    ```cpp\nint minTime(string colors, vector<int>& neededTime) {\n    int res = 0, prev = -1;\n    for (int i = 0; i < colors.length() - 1; i++) {\n        if (colors[i] == colors[i + 1]) {\n            if (prev == -1 || neededTime[i] < neededTime[prev]) prev = i;\n            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;\n            res += neededTime[prev];\n            neededTime[prev] = 1000000;\n            prev = -1;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    ",
        "js": "\n    ```javascript\nfunction minTime(colors, neededTime) {\n    let res = 0, prev = -1;\n    for (let i = 0; i < colors.length - 1; i++) {\n        if (colors[i] === colors[i + 1]) {\n            if (prev === -1 || neededTime[i] < neededTime[prev]) prev = i;\n            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;\n            res += neededTime[prev];\n            neededTime[prev] = 1000000;\n            prev = -1;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm needs to find the minimum time to remove consecutive balloons with the same color. It iterates through the colors array, and for each pair of consecutive colors that are the same, it checks which of the two balloons takes the least time to remove, and removes it. Then, it updates the `neededTime` array by setting the removed balloon's needed time to a large number (1000000) and sums up the needed time for each removed balloon in the `res` variable. Finally, it returns the total time spent (the value of `res`).\n    "
    },
    {
        "id": 1438,
        "title": "Sum of All Odd Length Subarrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of positive integers `arr`, return _the sum of all possible **odd-length subarrays** of_ `arr`.\n\nA **subarray** is a contiguous subsequence of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,4,2,5,3\\]\n**Output:** 58\n**Explanation:** The odd-length subarrays of arr and their sums are:\n\\[1\\] = 1\n\\[4\\] = 4\n\\[2\\] = 2\n\\[5\\] = 5\n\\[3\\] = 3\n\\[1,4,2\\] = 7\n\\[4,2,5\\] = 11\n\\[2,5,3\\] = 10\n\\[1,4,2,5,3\\] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2\\]\n**Output:** 3\n**Explanation:** There are only 2 subarrays of odd length, \\[1\\] and \\[2\\]. Their sum is 3.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[10,11,12\\]\n**Output:** 66"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 100`\n*   `1 <= arr[i] <= 1000`\n\n**",
            "follow_up": "Follow up:**\n\nCould you solve this problem in O(n) time complexity?"
        },
        "tag": [
            "Array",
            "Math",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,4,2,5,3]",
                "output": "58"
            },
            {
                "input": "[1,2]",
                "output": "3"
            },
            {
                "input": "[10,11,12]",
                "output": "66"
            }
        ],
        "java": "\n    ```java\npublic int sumOddLengthSubarrays(int[] arr) {\n    int sum = 0, n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int oddSubarrays = ((i + 1) * (n - i) + 1) / 2;\n        sum += arr[i] * oddSubarrays;\n    }\n    return sum;\n}\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef sumOddLengthSubarrays(arr):\n    sum = 0\n    n = len(arr)\n    for i in range(n):\n        oddSubarrays = ((i + 1) * (n - i) + 1) // 2\n        sum += arr[i] * oddSubarrays\n    return sum\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint sumOddLengthSubarrays(vector<int>& arr) {\n    int sum = 0, n = arr.size();\n    for (int i = 0; i < n; i++) {\n        int oddSubarrays = ((i + 1) * (n - i) + 1) / 2;\n        sum += arr[i] * oddSubarrays;\n    }\n    return sum;\n}\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction sumOddLengthSubarrays(arr) {\n    let sum = 0, n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let oddSubarrays = Math.floor(((i + 1) * (n - i) + 1) / 2);\n        sum += arr[i] * oddSubarrays;\n    }\n    return sum;\n}\n```\n    \n    First, we loop through the input array with index `i`. For each element `arr[i]`, calculate how many odd-length subarrays it appears in by using the formula `((i + 1) * (n - i) + 1) / 2`, where `n` is the length of the array. This gives us the number of odd-length subarrays that have `arr[i]` in them.\n\nThen, add the product of `arr[i]` and the number of odd-length subarrays it appears in to the total sum. Finally, return the total sum.\n\nThis algorithm runs in O(n) time complexity, where n is the length of the input array.\n    "
    },
    {
        "id": 1442,
        "title": "Rearrange Spaces Between Words",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `text` of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that `text` **contains at least one word**.\n\nRearrange the spaces so that there is an **equal** number of spaces between every pair of adjacent words and that number is **maximized**. If you cannot redistribute all the spaces equally, place the **extra spaces at the end**, meaning the returned string should be the same length as `text`.\n\nReturn _the string after rearranging the spaces_.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"  this   is  a sentence  \"\n**Output:**  \"this   is   a   sentence \"\n**Explanation:** There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.\n\n",
                "**Example 2:**\n\n**Input:** text =  \" practice   makes   perfect \"\n**Output:**  \"practice   makes   perfect  \"\n**Explanation:** There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 100`\n*   `text` consists of lowercase English letters and `' '`.\n*   `text` contains at least one word.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"thisisasentence\"",
                "output": "\"thisisasentence\""
            },
            {
                "input": "\"practicemakesperfect\"",
                "output": "\"practicemakesperfect\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String reorderSpaces(String text) {\n    int spaces = 0, words = 0;\n\n    for (char c : text.toCharArray()) {\n        if (c == ' ') spaces++;\n    }\n    \n    String[] splitText = text.trim().split(\"\\\\s+\");\n    List<String> wordList = new ArrayList<>();\n    for (String word : splitText) {\n        wordList.add(word);\n        words++;\n    }\n    \n    int spacesBetweenWords = words == 1 ? 0 : spaces / (words - 1);\n    int extraSpaces = words == 1 ? spaces : spaces % (words - 1);\n    \n    StringBuilder result = new StringBuilder();\n\n    for (int i = 0; i < words; i++) {\n        result.append(wordList.get(i));\n        if (i != words - 1) {\n            result.append(\" \".repeat(spacesBetweenWords));\n        } else {\n            result.append(\" \".repeat(extraSpaces));\n        }\n    }\n    \n    return result.toString();\n}\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    ",
        "python": "\n    ```python\ndef reorderSpaces(text):\n    spaces = text.count(' ')\n    words = text.split()\n    num_words = len(words)\n    \n    if num_words == 1:\n        spaces_between_words = 0\n    else:\n        spaces_between_words = spaces // (num_words - 1)\n    \n    extra_spaces = spaces - spaces_between_words * (num_words - 1)\n\n    return (' ' * spaces_between_words).join(words) + ' ' * extra_spaces\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string reorderSpaces(std::string text) {\n    int spaces = 0, words = 0;\n\n    for (char c : text) {\n        if (c == ' ') spaces++;\n    }\n    \n    std::istringstream iss(text);\n    std::vector<std::string> wordList;\n    std::string word;\n\n    while (iss >> word) {\n        wordList.push_back(word);\n        words++;\n    }\n    \n    int spacesBetweenWords = words == 1 ? 0 : spaces / (words - 1);\n    int extraSpaces = words == 1 ? spaces : spaces % (words - 1);\n    \n    std::string result;\n\n    for (int i = 0; i < words; i++) {\n        result += wordList[i];\n        if (i != words - 1) {\n            result.append(spacesBetweenWords, ' ');\n        } else {\n            result.append(extraSpaces, ' ');\n        }\n    }\n    \n    return result;\n}\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    ",
        "js": "\n    ```javascript\nfunction reorderSpaces(text) {\n    const spaces = text.split(' ').length - 1;\n    const words = text.trim().split(/\\s+/);\n    const numWords = words.length;\n    \n    const spacesBetweenWords = numWords === 1 ? 0 : Math.floor(spaces / (numWords - 1));\n    const extraSpaces = spaces - spacesBetweenWords * (numWords - 1);\n    \n    return words.join(' '.repeat(spacesBetweenWords)) + ' '.repeat(extraSpaces);\n}\n```\n    \n    To solve this problem, first we need to count the number of spaces and words in the input `text`. We iterate through the `text` and count the spaces. Then, we split the `text` into words, and count the number of words.\n\nNext, we need to calculate the number of spaces between words and the extra spaces that will be placed at the end. If there is only one word, then all spaces will be used as extra spaces. Otherwise, we divide the total number of spaces by the number of words minus 1 (to get the spaces between words), and calculate the remainder (i.e., the extra spaces).\n\nAfter that, we construct the result by joining the words with the calculated space between them and then adding the extra spaces at the end of the last word.\n\nIn all four implementations, the core logic and step-by-step procedure are the same, only the syntax and library functions vary according to the language being used.\n    "
    },
    {
        "id": 1447,
        "title": "Crawler Log Folder",
        "difficulty": "Easy",
        "content": {
            "problem": "The Leetcode file system keeps a log each time some user performs a _change folder_ operation.\n\nThe operations are described below:\n\n*   `\"../ \"` : Move to the parent folder of the current folder. (If you are already in the main folder, **remain in the same folder**).\n*   `\"./ \"` : Remain in the same folder.\n*   `\"x/ \"` : Move to the child folder named `x` (This folder is **guaranteed to always exist**).\n\nYou are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step.\n\nThe file system starts in the main folder, then the operations in `logs` are performed.\n\nReturn _the minimum number of operations needed to go back to the main folder after the change folder operations._",
            "examples": [
                "**Example 1:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"../ \", \"d21/ \", \"./ \"\\]\n**Output:** 2\n**Explanation:** Use this change folder operation  \"../ \" 2 times and go back to the main folder.\n\n",
                "**Example 2:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"./ \", \"d3/ \", \"../ \", \"d31/ \"\\]\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** logs = \\[ \"d1/ \", \"../ \", \"../ \", \"../ \"\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= logs.length <= 103`\n*   `2 <= logs[i].length <= 10`\n*   `logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`.\n*   `logs[i]` follows the format described in the statement.\n*   Folder names consist of lowercase English letters and digits.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "[\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]",
                "output": "2"
            },
            {
                "input": "[\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]",
                "output": "3"
            },
            {
                "input": "[\"d1/\",\"../\",\"../\",\"../\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(String[] logs) {\n    int depth = 0;\n    for (String log : logs) {\n        if (log.equals(\"../\")) {\n            depth = Math.max(0, depth - 1);\n        } else if (!log.equals(\"./\")) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    ",
        "python": "\n    ```python\ndef minOperations(logs):\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            depth = max(0, depth - 1)\n        elif log != \"./\":\n            depth += 1\n    return depth\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<string>& logs) {\n    int depth = 0;\n    for (const string& log : logs) {\n        if (log == \"../\") {\n            depth = max(0, depth - 1);\n        } else if (log != \"./\") {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(logs) {\n    let depth = 0;\n    for (const log of logs) {\n        if (log === \"../\") {\n            depth = Math.max(0, depth - 1);\n        } else if (log !== \"./\") {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n```\n    \n    The algorithm iterates through each log entry, incrementing the `depth` variable whenever it encounters a non-relative move (`\"x/\"`). If it encounters a move to the parent directory (`\"../\"`) it decreases the `depth` variable by 1, but only if the depth is greater than 0 to make sure we don't go beyond the main folder. It ignores relative moves (`\"./\"`). Finally, it returns the number of operations needed to go back to the main folder, which is the final value of `depth`.\n    "
    },
    {
        "id": 1461,
        "title": "Maximum Nesting Depth of the Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "A string is a **valid parentheses string** (denoted **VPS**) if it meets one of the following:\n\n*   It is an empty string `\" \"`, or a single character not equal to `\"( \"` or `\") \"`,\n*   It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are **VPS**'s, or\n*   It can be written as `(A)`, where `A` is a **VPS**.\n\nWe can similarly define the **nesting depth** `depth(S)` of any VPS `S` as follows:\n\n*   `depth( \" \") = 0`\n*   `depth(C) = 0`, where `C` is a string with a single character not equal to `\"( \"` or `\") \"`.\n*   `depth(A + B) = max(depth(A), depth(B))`, where `A` and `B` are **VPS**'s.\n*   `depth( \"( \" + A + \") \") = 1 + depth(A)`, where `A` is a **VPS**.\n\nFor example, `\" \"`, `\"()() \"`, and `\"()(()()) \"` are **VPS**'s (with nesting depths 0, 1, and 2), and `\")( \"` and `\"(() \"` are not **VPS**'s.\n\nGiven a **VPS** represented as string `s`, return _the **nesting depth** of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(1+(2\\*3)+((8)/4))+1 \"\n**Output:** 3\n**Explanation:** Digit 8 is inside of 3 nested parentheses in the string.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"(1)+((2))+(((3))) \"\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of digits `0-9` and characters `'+'`, `'-'`, `'*'`, `'/'`, `'('`, and `')'`.\n*   It is guaranteed that parentheses expression `s` is a **VPS**.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"(1+(2*3)+((8)/4))+1\"",
                "output": "3"
            },
            {
                "input": "\"(1)+((2))+(((3)))\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int maxDepth(String s) {\n    int depth = 0, maxDepth = 0;\n\n    for (char c : s.toCharArray()) {\n        if (c == '(') {\n            depth++;\n            maxDepth = Math.max(depth, maxDepth);\n        } else if (c == ')') {\n            depth--;\n        }\n    }\n\n    return maxDepth;\n}\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    ",
        "python": "\n    ```python\ndef maxDepth(s: str) -> int:\n    depth = 0\n    max_depth = 0\n\n    for c in s:\n        if c == '(':\n            depth += 1\n            max_depth = max(depth, max_depth)\n        elif c == ')':\n            depth -= 1\n\n    return max_depth\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    ",
        "c++": "\n    ```cpp\nint maxDepth(std::string s) {\n    int depth = 0, max_depth = 0;\n\n    for (char c : s) {\n        if (c == '(') {\n            depth++;\n            max_depth = std::max(depth, max_depth);\n        } else if (c == ')') {\n            depth--;\n        }\n    }\n\n    return max_depth;\n}\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    ",
        "js": "\n    ```javascript\nfunction maxDepth(s) {\n    let depth = 0, maxDepth = 0;\n\n    for (const c of s) {\n        if (c === '(') {\n            depth++;\n            maxDepth = Math.max(depth, maxDepth);\n        } else if (c === ')') {\n            depth--;\n        }\n    }\n\n    return maxDepth;\n}\n```\n    \n    Iterate through the string `s`. When an opening parenthesis '(' is encountered, increment the `depth` value, update the `max_depth` with the maximum between the current `max_depth` and the `depth`. In contrast, when a closing parenthesis ')' is encountered, decrement the `depth`. The `max_depth` will be the nesting depth of the given valid parentheses string.\n    "
    },
    {
        "id": 1470,
        "title": "Largest Substring Between Two Equal Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest substring between two equal characters, excluding the two characters._ If there is no such substring return `-1`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \"\n**Output:** 0\n**Explanation:** The optimal substring here is an empty substring between the two `'a's`.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abca \"\n**Output:** 2\n**Explanation:** The optimal substring here is  \"bc \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"cbzxy \"\n**Output:** -1\n**Explanation:** There are no characters that appear twice in s."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `s` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"aa\"",
                "output": "0"
            },
            {
                "input": "\"abca\"",
                "output": "2"
            },
            {
                "input": "\"cbzxy\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int maxLengthBetweenEqualCharacters(String s) {\n    int result = -1;\n    HashMap<Character, Integer> char_map = new HashMap<>();\n\n    for (int i = 0; i < s.length(); ++i) {\n        if (!char_map.containsKey(s.charAt(i))) {\n            char_map.put(s.charAt(i), i);\n        } else {\n            result = Math.max(result, i - char_map.get(s.charAt(i)) - 1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "python": "\n    ```python\ndef maxLengthBetweenEqualCharacters(s: str) -> int:\n    result = -1\n    char_map = {}\n\n    for i, c in enumerate(s):\n        if c not in char_map:\n            char_map[c] = i\n        else:\n            result = max(result, i - char_map[c] - 1)\n\n    return result\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "c++": "\n    ```cpp\nint maxLengthBetweenEqualCharacters(std::string s) {\n    int result = -1;\n    std::unordered_map<char, int> char_map;\n\n    for (int i = 0; i < s.length(); ++i) {\n        if (char_map.find(s[i]) == char_map.end()) {\n            char_map[s[i]] = i;\n        } else {\n            result = std::max(result, i - char_map[s[i]] - 1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    ",
        "js": "\n    ```javascript\nfunction maxLengthBetweenEqualCharacters(s) {\n    let result = -1;\n    let char_map = {};\n\n    for (let i = 0; i < s.length; ++i) {\n        let c = s.charAt(i);\n        if (!char_map.hasOwnProperty(c)) {\n            char_map[c] = i;\n        } else {\n            result = Math.max(result, i - char_map[c] - 1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a hash map to store the index of the first occurrence of each character in the string. It then iterates through the string, and for each character, checks if it's present in the hash map. If it's not, the character is added to the hash map with its index. If it is present, the length of the substring between the two occurrences of the character is calculated as (current index - stored index - 1). The result is updated as the maximum length between equal characters found so far.\n    "
    },
    {
        "id": 1511,
        "title": "Minimum Number of Removals to Make Mountain Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `nums`​​​, return _the **minimum** number of elements to remove to make_ `nums_​​​_` _a **mountain array**._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,1\\]\n**Output:** 0\n**Explanation:** The array itself is a mountain array so we do not need to remove any elements.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,1,1,5,6,2,3,1\\]\n**Output:** 3\n**Explanation:** One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \\[1,5,6,3,1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 109`\n*   It is guaranteed that you can make a mountain array out of `nums`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,3,1]",
                "output": "0"
            },
            {
                "input": "[2,1,1,5,6,2,3,1]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minimumMountainRemovals(int[] nums) {\n    int n = nums.length;\n    int[] left = new int[n], right = new int[n];\n    for (int i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);\n    }\n    int ans = n - 3;\n    for (int i = 1; i < n - 1; ++i) {\n        ans = Math.min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ",
        "python": "\n    ```python\ndef minimumMountainRemovals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])\n        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])\n    ans = n - 3\n    for i in range(1, n - 1):\n        ans = min(ans, n - 1 - left[i] - right[i])\n    return ans\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ",
        "c++": "\n    ```cpp\nint minimumMountainRemovals(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> left(n), right(n);\n    for (int i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1]);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i]);\n    }\n    int ans = n - 3;\n    for (int i = 1; i < n - 1; ++i) {\n        ans = min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ",
        "js": "\n    ```javascript\nfunction minimumMountainRemovals(nums) {\n    const n = nums.length;\n    const left = new Array(n).fill(0);\n    const right = new Array(n).fill(0);\n    for (let i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);\n    }\n    let ans = n - 3;\n    for (let i = 1; i < n - 1; ++i) {\n        ans = Math.min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    "
    },
    {
        "id": 1512,
        "title": "Richest Customer Wealth",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the amount of money the `i​​​​​​​​​​​th​​​​` customer has in the `j​​​​​​​​​​​th`​​​​ bank. Return _the **wealth** that the richest customer has._\n\nA customer's **wealth** is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum **wealth**.",
            "examples": [
                "**Example 1:**\n\n**Input:** accounts = \\[\\[1,2,3\\],\\[3,2,1\\]\\]\n**Output:** 6\n**Explanation****:**\n`1st customer has wealth = 1 + 2 + 3 = 6`\n`2nd customer has wealth = 3 + 2 + 1 = 6`\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\n",
                "**Example 2:**\n\n**Input:** accounts = \\[\\[1,5\\],\\[7,3\\],\\[3,5\\]\\]\n**Output:** 10\n**Explanation**: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\n\n",
                "**Example 3:**\n\n**Input:** accounts = \\[\\[2,8,7\\],\\[7,1,3\\],\\[1,9,5\\]\\]\n**Output:** 17"
            ],
            "constraints": "**Constraints:**\n\n*   `m == accounts.length`\n*   `n == accounts[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= accounts[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[3,2,1]]",
                "output": "6"
            },
            {
                "input": "[[1,5],[7,3],[3,5]]",
                "output": "10"
            },
            {
                "input": "[[2,8,7],[7,1,3],[1,9,5]]",
                "output": "17"
            }
        ],
        "java": "\n    ```java\npublic int maximumWealth(int[][] accounts) {\n    int maxWealth = 0;\n    for (int[] customer : accounts) {\n        int wealth = 0;\n        for (int account : customer) {\n            wealth += account;\n        }\n        maxWealth = Math.max(maxWealth, wealth);\n    }\n    return maxWealth;\n}\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "python": "\n    ```python\ndef maximumWealth(accounts):\n    max_wealth = 0\n    for customer in accounts:\n        wealth = sum(customer)\n        max_wealth = max(max_wealth, wealth)\n    return max_wealth\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "c++": "\n    ```cpp\nint maximumWealth(vector<vector<int>>& accounts) {\n    int max_wealth = 0;\n    for (auto& customer : accounts) {\n        int wealth = 0;\n        for (int account : customer) {\n            wealth += account;\n        }\n        max_wealth = max(max_wealth, wealth);\n    }\n    return max_wealth;\n}\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    ",
        "js": "\n    ```javascript\nfunction maximumWealth(accounts) {\n    let maxWealth = 0;\n    for (let customer of accounts) {\n        let wealth = 0;\n        for (let account of customer) {\n            wealth += account;\n        }\n        maxWealth = Math.max(maxWealth, wealth);\n    }\n    return maxWealth;\n}\n```\n    \n    The algorithm iterates through each customer in the given grid (accounts) and calculates their total wealth by summing the values in their bank accounts. After calculating the wealth for a customer, the algorithm checks if it is greater than the current maximum wealth, and if so, the maximum wealth gets updated to the new wealth value. After all iterations, the algorithm returns the maximum wealth found.\n\nThe approach is the same for each language, just with minor syntactical differences between them.\n    "
    },
    {
        "id": 1525,
        "title": "Count of Matches in Tournament",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `n`, the number of teams in a tournament that has strange rules:\n\n*   If the current number of teams is **even**, each team gets paired with another team. A total of `n / 2` matches are played, and `n / 2` teams advance to the next round.\n*   If the current number of teams is **odd**, one team randomly advances in the tournament, and the rest gets paired. A total of `(n - 1) / 2` matches are played, and `(n - 1) / 2 + 1` teams advance to the next round.\n\nReturn _the number of matches played in the tournament until a winner is decided._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7\n**Output:** 6\n**Explanation:** Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n\n",
                "**Example 2:**\n\n**Input:** n = 14\n**Output:** 13\n**Explanation:** Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 200`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Simulation"
        ],
        "example": [
            {
                "input": "7",
                "output": "6"
            },
            {
                "input": "14",
                "output": "13"
            }
        ],
        "java": "\n    ```java\npublic int numberOfMatches(int n) {\n    int matches = 0;\n    while (n > 1) {\n        matches += n / 2;\n        n = (n + 1) / 2;\n    }\n    return matches;\n}\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "python": "\n    ```python\ndef numberOfMatches(n: int) -> int:\n    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "c++": "\n    ```cpp\nint numberOfMatches(int n) {\n    int matches = 0;\n    while (n > 1) {\n        matches += n / 2;\n        n = (n + 1) / 2;\n    }\n    return matches;\n}\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    ",
        "js": "\n    ```javascript\nfunction numberOfMatches(n) {\n    let matches = 0;\n    while (n > 1) {\n        matches += Math.floor(n / 2);\n        n = Math.floor((n + 1) / 2);\n    }\n    return matches;\n}\n```\n    \n    The algorithm starts with `n` teams and initializes a `matches` counter with 0. In each iteration of the loop, it calculates the number of matches played in the current round and adds it to the `matches` counter. Then, the number of teams advancing to the next round is calculated as `(n + 1) / 2`. The loop continues until there is a single winner left, i.e., `n === 1`. Finally, the total number of matches played throughout the tournament is returned.\n    "
    },
    {
        "id": 1577,
        "title": "Maximum Absolute Sum of Any Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums`. The **absolute sum** of a subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is `abs(numsl + numsl+1 + ... + numsr-1 + numsr)`.\n\nReturn _the **maximum** absolute sum of any **(possibly empty)** subarray of_ `nums`.\n\nNote that `abs(x)` is defined as follows:\n\n*   If `x` is a negative integer, then `abs(x) = -x`.\n*   If `x` is a non-negative integer, then `abs(x) = x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,-3,2,3,-4\\]\n**Output:** 5\n**Explanation:** The subarray \\[2,3\\] has absolute sum = abs(2+3) = abs(5) = 5.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,-5,1,-4,3,-2\\]\n**Output:** 8\n**Explanation:** The subarray \\[-5,1,-4\\] has absolute sum = abs(-5+1-4) = abs(-8) = 8."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,-3,2,3,-4]",
                "output": "5"
            },
            {
                "input": "[2,-5,1,-4,3,-2]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int maxAbsoluteSum(int[] nums) {\n    int max_sum = 0, min_sum = 0, max_end = 0, min_end = 0;\n    for (int num : nums) {\n        max_end = Math.max(max_end + num, num);\n        min_end = Math.min(min_end + num, num);\n        max_sum = Math.max(max_sum, max_end);\n        min_sum = Math.min(min_sum, min_end);\n    }\n    return Math.max(max_sum, -min_sum);\n}\n```\n    \n    We use the Kadane's algorithm to maintain both the maximum sum subarray (max_end) and the minimum sum subarray (min_end) ending at the current position.\n\n1. Iterate through the given array nums\n2. For each number in nums:\n   1. Update max_end to be the maximum of max_end + num and num\n   2. Update min_end to be the minimum of min_end + num and num\n   3. Update max_sum to be the maximum of max_sum and max_end\n   4. Update min_sum to be the minimum of min_sum and min_end\n3. Return the maximum of max_sum and -min_sum.\n\nKeep in mind that empty subarray is allowed, but in practice we won't need any additional code to handle empty subarray since the minimum absolute sum is always 0 (which can be the result of an empty subarray).\n    ",
        "python": "\n    ```python\ndef maxAbsoluteSum(nums):\n    max_sum = max_end = min_sum = min_end = 0\n    for num in nums:\n        max_end = max(max_end + num, num)\n        min_end = min(min_end + num, num)\n        max_sum = max(max_sum, max_end)\n        min_sum = min(min_sum, min_end)\n    return max(max_sum, -min_sum)\n```\n    \n    We use the Kadane's algorithm to maintain both the maximum sum subarray (max_end) and the minimum sum subarray (min_end) ending at the current position.\n\n1. Iterate through the given array nums\n2. For each number in nums:\n   1. Update max_end to be the maximum of max_end + num and num\n   2. Update min_end to be the minimum of min_end + num and num\n   3. Update max_sum to be the maximum of max_sum and max_end\n   4. Update min_sum to be the minimum of min_sum and min_end\n3. Return the maximum of max_sum and -min_sum.\n\nKeep in mind that empty subarray is allowed, but in practice we won't need any additional code to handle empty subarray since the minimum absolute sum is always 0 (which can be the result of an empty subarray).\n    ",
        "c++": "\n    ```cpp\nint maxAbsoluteSum(vector<int>& nums) {\n    int max_sum = 0, min_sum = 0, max_end = 0, min_end = 0;\n    for (int num : nums) {\n        max_end = max(max_end + num, num);\n        min_end = min(min_end + num, num);\n        max_sum = max(max_sum, max_end);\n        min_sum = min(min_sum, min_end);\n    }\n    return max(max_sum, -min_sum);\n}\n```\n    \n    We use the Kadane's algorithm to maintain both the maximum sum subarray (max_end) and the minimum sum subarray (min_end) ending at the current position.\n\n1. Iterate through the given array nums\n2. For each number in nums:\n   1. Update max_end to be the maximum of max_end + num and num\n   2. Update min_end to be the minimum of min_end + num and num\n   3. Update max_sum to be the maximum of max_sum and max_end\n   4. Update min_sum to be the minimum of min_sum and min_end\n3. Return the maximum of max_sum and -min_sum.\n\nKeep in mind that empty subarray is allowed, but in practice we won't need any additional code to handle empty subarray since the minimum absolute sum is always 0 (which can be the result of an empty subarray).\n    ",
        "js": "\n    ```javascript\nfunction maxAbsoluteSum(nums) {\n    let max_sum = 0, min_sum = 0, max_end = 0, min_end = 0;\n    for (let num of nums) {\n        max_end = Math.max(max_end + num, num);\n        min_end = Math.min(min_end + num, num);\n        max_sum = Math.max(max_sum, max_end);\n        min_sum = Math.min(min_sum, min_end);\n    }\n    return Math.max(max_sum, -min_sum);\n}\n```\n    \n    We use the Kadane's algorithm to maintain both the maximum sum subarray (max_end) and the minimum sum subarray (min_end) ending at the current position.\n\n1. Iterate through the given array nums\n2. For each number in nums:\n   1. Update max_end to be the maximum of max_end + num and num\n   2. Update min_end to be the minimum of min_end + num and num\n   3. Update max_sum to be the maximum of max_sum and max_end\n   4. Update min_sum to be the minimum of min_sum and min_end\n3. Return the maximum of max_sum and -min_sum.\n\nKeep in mind that empty subarray is allowed, but in practice we won't need any additional code to handle empty subarray since the minimum absolute sum is always 0 (which can be the result of an empty subarray).\n    "
    },
    {
        "id": 1578,
        "title": "Minimum Length of String After Deleting Similar Ends",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` consisting only of characters `'a'`, `'b'`, and `'c'`. You are asked to apply the following algorithm on the string any number of times:\n\n1.  Pick a **non-empty** prefix from the string `s` where all the characters in the prefix are equal.\n2.  Pick a **non-empty** suffix from the string `s` where all the characters in this suffix are equal.\n3.  The prefix and the suffix should not intersect at any index.\n4.  The characters from the prefix and suffix must be the same.\n5.  Delete both the prefix and the suffix.\n\nReturn _the **minimum length** of_ `s` _after performing the above operation any number of times (possibly zero times)_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ca \"\n**Output:** 2\n**Explanation:** You can't remove any characters, so the string stays as is.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"cabaabac \"\n**Output:** 0\n**Explanation:** An optimal sequence of operations is:\n- Take prefix =  \"c \" and suffix =  \"c \" and remove them, s =  \"abaaba \".\n- Take prefix =  \"a \" and suffix =  \"a \" and remove them, s =  \"baab \".\n- Take prefix =  \"b \" and suffix =  \"b \" and remove them, s =  \"aa \".\n- Take prefix =  \"a \" and suffix =  \"a \" and remove them, s =  \" \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aabccabba \"\n**Output:** 3\n**Explanation:** An optimal sequence of operations is:\n- Take prefix =  \"aa \" and suffix =  \"a \" and remove them, s =  \"bccabb \".\n- Take prefix =  \"b \" and suffix =  \"bb \" and remove them, s =  \"cca \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` only consists of characters `'a'`, `'b'`, and `'c'`.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"ca\"",
                "output": "2"
            },
            {
                "input": "\"cabaabac\"",
                "output": "0"
            },
            {
                "input": "\"aabccabba\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minimumLength(String s) {\n    if(s.isEmpty()) return 0;\n    int i = 0, j = s.length() - 1;\n    while(i < j){\n        if(s.charAt(i) != s.charAt(j)) break;\n        char remove_char = s.charAt(i);\n        while(i < s.length() && s.charAt(i) == remove_char) i++;\n        while(j >= 0 && s.charAt(j) == remove_char) j--;\n    }\n    return Math.max(0, j - i + 1);\n}\n```\n    \n    The algorithm involves the use of two pointers, one at the beginning and the other at the end of the string. While the characters at the positions of both pointers are the same, we increment the first pointer (i) until a different character is found in the string, and decrement the second pointer (j) until a different character is found. We then return the difference between j and i plus 1, or 0 if the result is negative, as the minimum length after performing the operations.\n    ",
        "python": "\n    ```python\ndef minimumLength(s: str) -> int:\n    if not s: return 0\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]: break\n        remove_char = s[i]\n        while i < len(s) and s[i] == remove_char: i += 1\n        while j >= 0 and s[j] == remove_char: j -= 1\n    return max(0, j - i + 1)\n```\n    \n    The algorithm involves the use of two pointers, one at the beginning and the other at the end of the string. While the characters at the positions of both pointers are the same, we increment the first pointer (i) until a different character is found in the string, and decrement the second pointer (j) until a different character is found. We then return the difference between j and i plus 1, or 0 if the result is negative, as the minimum length after performing the operations.\n    ",
        "c++": "\n    ```cpp\nint minimumLength(string s) {\n    if(s.empty()) return 0;\n    int i = 0, j = s.length() - 1;\n    while(i < j){\n        if(s[i] != s[j]) break;\n        char remove_char = s[i];\n        while(i < s.length() && s[i] == remove_char) i++;\n        while(j >= 0 && s[j] == remove_char) j--;\n    }\n    return max(0, j - i + 1);\n}\n```\n    \n    The algorithm involves the use of two pointers, one at the beginning and the other at the end of the string. While the characters at the positions of both pointers are the same, we increment the first pointer (i) until a different character is found in the string, and decrement the second pointer (j) until a different character is found. We then return the difference between j and i plus 1, or 0 if the result is negative, as the minimum length after performing the operations.\n    ",
        "js": "\n    ```javascript\nfunction minimumLength(s) {\n    if(s.isEmpty()) return 0;\n    let i = 0, j = s.length - 1;\n    while(i < j){\n        if(s[i] != s[j]) break;\n        let remove_char = s[i];\n        while(i < s.length && s[i] == remove_char) i++;\n        while(j >= 0 && s[j] == remove_char) j--;\n    }\n    return Math.max(0, j - i + 1);\n}\n```\n    \n    The algorithm involves the use of two pointers, one at the beginning and the other at the end of the string. While the characters at the positions of both pointers are the same, we increment the first pointer (i) until a different character is found in the string, and decrement the second pointer (j) until a different character is found. We then return the difference between j and i plus 1, or 0 if the result is negative, as the minimum length after performing the operations.\n    "
    },
    {
        "id": 1582,
        "title": "Largest Merge Of Two Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two strings `word1` and `word2`. You want to construct a string `merge` in the following way: while either `word1` or `word2` are non-empty, choose **one** of the following options:\n\n*   If `word1` is non-empty, append the **first** character in `word1` to `merge` and delete it from `word1`.\n    *   For example, if `word1 = \"abc \"` and `merge = \"dv \"`, then after choosing this operation, `word1 = \"bc \"` and `merge = \"dva \"`.\n*   If `word2` is non-empty, append the **first** character in `word2` to `merge` and delete it from `word2`.\n    *   For example, if `word2 = \"abc \"` and `merge = \" \"`, then after choosing this operation, `word2 = \"bc \"` and `merge = \"a \"`.\n\nReturn _the lexicographically **largest**_ `merge` _you can construct_.\n\nA string `a` is lexicographically larger than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly larger than the corresponding character in `b`. For example, `\"abcd \"` is lexicographically larger than `\"abcc \"` because the first position they differ is at the fourth character, and `d` is greater than `c`.",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"cabaa \", word2 =  \"bcaaa \"\n**Output:**  \"cbcabaaaaa \"\n**Explanation:** One way to get the lexicographically largest merge is:\n- Take from word1: merge =  \"c \", word1 =  \"abaa \", word2 =  \"bcaaa \"\n- Take from word2: merge =  \"cb \", word1 =  \"abaa \", word2 =  \"caaa \"\n- Take from word2: merge =  \"cbc \", word1 =  \"abaa \", word2 =  \"aaa \"\n- Take from word1: merge =  \"cbca \", word1 =  \"baa \", word2 =  \"aaa \"\n- Take from word1: merge =  \"cbcab \", word1 =  \"aa \", word2 =  \"aaa \"\n- Append the remaining 5 a's from word1 and word2 at the end of merge.\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"abcabc \", word2 =  \"abdcaba \"\n**Output:**  \"abdcabcabcaba \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 3000`\n*   `word1` and `word2` consist only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"cabaa\",\"bcaaa\"",
                "output": "\"cbcabaaaaa\""
            },
            {
                "input": "\"abcabc\",\"abdcaba\"",
                "output": "\"abdcabcabcaba\""
            }
        ],
        "java": "\n    ```java\npublic String largestMerge(String word1, String word2) {\n    StringBuilder result = new StringBuilder();\n    while (!word1.isEmpty() || !word2.isEmpty()) {\n        if (word1.compareTo(word2) > 0) {\n            result.append(word1.charAt(0));\n            word1 = word1.substring(1);\n        } else {\n            result.append(word2.charAt(0));\n            word2 = word2.substring(1);\n        }\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ",
        "python": "\n    ```python\ndef largest_merge(word1: str, word2: str) -> str:\n    merge = []\n    while word1 or word2:\n        if word1 > word2:\n            merge.append(word1[0])\n            word1 = word1[1:]\n        else:\n            merge.append(word2[0])\n            word2 = word2[1:]\n    return ''.join(merge)\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ",
        "c++": "\n    ```cpp\nstd::string largestMerge(std::string word1, std::string word2) {\n    std::string result;\n    while (!word1.empty() || !word2.empty()) {\n        if (word1 > word2) {\n            result += word1[0];\n            word1.erase(word1.begin());\n        } else {\n            result += word2[0];\n            word2.erase(word2.begin());\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    ",
        "js": "\n    ```javascript\nfunction largestMerge(word1, word2) {\n    let result = '';\n    while (word1.length > 0 || word2.length > 0) {\n        if (word1 > word2) {\n            result += word1[0];\n            word1 = word1.slice(1);\n        } else {\n            result += word2[0];\n            word2 = word2.slice(1);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through both `word1` and `word2` until they are both empty. At each step, it compares the two strings and appends the first character of the lexicographically larger string to the `result` string. It then removes that character from its respective string (using `erase` in C++, `substring` in Java, slicing in Python, and `slice` in JavaScript). Once both `word1` and `word2` are empty, the loop ends, and the constructed `result` string is returned.\n\nThis algorithm ensures that we prioritize the lexicographically larger character when appending to the result, always creating the largest possible merged string.\n    "
    },
    {
        "id": 1594,
        "title": "Merge Strings Alternately",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\nReturn _the merged string._",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"abc \", word2 =  \"pqr \"\n**Output:**  \"apbqcr \"\n**Explanation:** The merged string will be merged as so:\nword1:  a   b   c\nword2:    p   q   r\nmerged: a p b q c r\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"ab \", word2 =  \"pqrs \"\n**Output:**  \"apbqrs \"\n**Explanation:** Notice that as word2 is longer,  \"rs \" is appended to the end.\nword1:  a   b \nword2:    p   q   r   s\nmerged: a p b q   r   s\n\n",
                "**Example 3:**\n\n**Input:** word1 =  \"abcd \", word2 =  \"pq \"\n**Output:**  \"apbqcd \"\n**Explanation:** Notice that as word1 is longer,  \"cd \" is appended to the end.\nword1:  a   b   c   d\nword2:    p   q \nmerged: a p b q c   d"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 100`\n*   `word1` and `word2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"abc\",\"pqr\"",
                "output": "\"apbqcr\""
            },
            {
                "input": "\"ab\",\"pqrs\"",
                "output": "\"apbqrs\""
            },
            {
                "input": "\"abcd\",\"pq\"",
                "output": "\"apbqcd\""
            }
        ],
        "java": "\n    ```java\npublic String mergeAlternately(String word1, String word2) {\n    StringBuilder result = new StringBuilder();\n    int i = 0, j = 0;\n    while (i < word1.length() && j < word2.length()) {\n        result.append(word1.charAt(i++));\n        result.append(word2.charAt(j++));\n    }\n    while (i < word1.length()) result.append(word1.charAt(i++));\n    while (j < word2.length()) result.append(word2.charAt(j++));\n    return result.toString();\n}\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    ",
        "python": "\n    ```python\ndef mergeAlternately(word1: str, word2: str) -> str:\n    result = []\n    i, j = 0, 0\n    while i < len(word1) and j < len(word2):\n        result.append(word1[i])\n        result.append(word2[j])\n        i += 1\n        j += 1\n    result += word1[i:]\n    result += word2[j:]\n    return \"\".join(result)\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    ",
        "c++": "\n    ```cpp\nstd::string mergeAlternately(std::string word1, std::string word2) {\n    std::string result = \"\";\n    int i = 0, j = 0;\n    while (i < word1.length() && j < word2.length()) {\n        result += word1[i++];\n        result += word2[j++];\n    }\n    while (i < word1.length()) result += word1[i++];\n    while (j < word2.length()) result += word2[j++];\n    return result;\n}\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    ",
        "js": "\n    ```javascript\nfunction mergeAlternately(word1, word2) {\n    let result = \"\";\n    let i = 0, j = 0;\n    while (i < word1.length && j < word2.length) {\n        result += word1[i++];\n        result += word2[j++];\n    }\n    while (i < word1.length) result += word1[i++];\n    while (j < word2.length) result += word2[j++];\n    return result;\n}\n```\n    \n    The algorithm initializes the result as an empty string (or an empty list in Python) and two pointers `i` and `j` to track the index of the current element in `word1` and `word2`, respectively. Then, it iterates through the words, adding one character from each of the input words alternatively to the result. The loop stops when one of the words run out of characters.\n\nAfter the loop, the remaining characters in the input strings (if any) are appended to the result. In Python, the result is converted back to a string using the `join()` method.\n    "
    },
    {
        "id": 1599,
        "title": "Count Items Matching a Rule",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `items`, where each `items[i] = [typei, colori, namei]` describes the type, color, and name of the `ith` item. You are also given a rule represented by two strings, `ruleKey` and `ruleValue`.\n\nThe `ith` item is said to match the rule if **one** of the following is true:\n\n*   `ruleKey == \"type \"` and `ruleValue == typei`.\n*   `ruleKey == \"color \"` and `ruleValue == colori`.\n*   `ruleKey == \"name \"` and `ruleValue == namei`.\n\nReturn _the number of items that match the given rule_.",
            "examples": [
                "**Example 1:**\n\n**Input:** items = \\[\\[ \"phone \", \"blue \", \"pixel \"\\],\\[ \"computer \", \"silver \", \"lenovo \"\\],\\[ \"phone \", \"gold \", \"iphone \"\\]\\], ruleKey =  \"color \", ruleValue =  \"silver \"\n**Output:** 1\n**Explanation:** There is only one item matching the given rule, which is \\[ \"computer \", \"silver \", \"lenovo \"\\].\n\n",
                "**Example 2:**\n\n**Input:** items = \\[\\[ \"phone \", \"blue \", \"pixel \"\\],\\[ \"computer \", \"silver \", \"phone \"\\],\\[ \"phone \", \"gold \", \"iphone \"\\]\\], ruleKey =  \"type \", ruleValue =  \"phone \"\n**Output:** 2\n**Explanation:** There are only two items matching the given rule, which are \\[ \"phone \", \"blue \", \"pixel \"\\] and \\[ \"phone \", \"gold \", \"iphone \"\\]. Note that the item \\[ \"computer \", \"silver \", \"phone \"\\] does not match."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= items.length <= 104`\n*   `1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10`\n*   `ruleKey` is equal to either `\"type \"`, `\"color \"`, or `\"name \"`.\n*   All strings consist only of lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]],\"color\",\"silver\"",
                "output": "1"
            },
            {
                "input": "[[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]],\"type\",\"phone\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n    int count = 0;\n    int index = ruleKey.equals(\"type\") ? 0 : (ruleKey.equals(\"color\") ? 1 : 2);\n    for (List<String> item : items) {\n        if (item.get(index).equals(ruleValue))\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "python": "\n    ```python\ndef countMatches(items, ruleKey, ruleValue):\n    count = 0\n    index = {\"type\": 0, \"color\": 1, \"name\": 2}[ruleKey]\n    for item in items:\n        if item[index] == ruleValue:\n            count += 1\n    return count\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) {\n    int count = 0;\n    int index = (ruleKey == \"type\" ? 0 : (ruleKey == \"color\" ? 1 : 2));\n    for (const auto& item : items) {\n        if (item[index] == ruleValue)\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    ",
        "js": "\n    ```javascript\nfunction countMatches(items, ruleKey, ruleValue) {\n    let count = 0;\n    let index = ruleKey === \"type\" ? 0 : (ruleKey === \"color\" ? 1 : 2);\n    for (let item of items) {\n        if (item[index] === ruleValue)\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm first finds the index of the attribute to be compared based on the `ruleKey`. Then, it iterates over the `items` array and compares the attribute at the calculated index with `ruleValue`. If there is a match, it increments a `count` variable. Finally, it returns the `count` representing the number of items matching the given rule.\n    "
    },
    {
        "id": 1604,
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integers, `x` and `y`, which represent your current location on a Cartesian grid: `(x, y)`. You are also given an array `points` where each `points[i] = [ai, bi]` represents that a point exists at `(ai, bi)`. A point is **valid** if it shares the same x-coordinate or the same y-coordinate as your location.\n\nReturn _the index **(0-indexed)** of the **valid** point with the smallest **Manhattan distance** from your current location_. If there are multiple, return _the valid point with the **smallest** index_. If there are no valid points, return `-1`.\n\nThe **Manhattan distance** between two points `(x1, y1)` and `(x2, y2)` is `abs(x1 - x2) + abs(y1 - y2)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 3, y = 4, points = \\[\\[1,2\\],\\[3,1\\],\\[2,4\\],\\[2,3\\],\\[4,4\\]\\]\n**Output:** 2\n**Explanation:** Of all the points, only \\[3,1\\], \\[2,4\\] and \\[4,4\\] are valid. Of the valid points, \\[2,4\\] and \\[4,4\\] have the smallest Manhattan distance from your current location, with a distance of 1. \\[2,4\\] has the smallest index, so return 2.\n\n",
                "**Example 2:**\n\n**Input:** x = 3, y = 4, points = \\[\\[3,4\\]\\]\n**Output:** 0\n**Explanation:** The answer is allowed to be on the same location as your current location.\n\n",
                "**Example 3:**\n\n**Input:** x = 3, y = 4, points = \\[\\[2,3\\]\\]\n**Output:** -1\n**Explanation:** There are no valid points."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 104`\n*   `points[i].length == 2`\n*   `1 <= x, y, ai, bi <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "3,4,[[1,2],[3,1],[2,4],[2,3],[4,4]]",
                "output": "2"
            },
            {
                "input": "3,4,[[3,4]]",
                "output": "0"
            },
            {
                "input": "3,4,[[2,3]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int nearestValidPoint(int x, int y, int[][] points) {\n    int min_distance = Integer.MAX_VALUE, index = -1;\n    for (int i = 0; i < points.length; i++) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < min_distance) {\n                min_distance = distance;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    ",
        "python": "\n    ```python\ndef nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\n    min_distance = float(\"inf\")\n    index = -1\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                index = i\n    return index\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    ",
        "c++": "\n    ```cpp\nint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\n    int min_distance = INT_MAX, index = -1;\n    for (int i = 0; i < points.size(); i++) {\n        if (x == points[i][0] || y == points[i][1]) {\n            int distance = abs(x - points[i][0]) + abs(y - points[i][1]);\n            if (distance < min_distance) {\n                min_distance = distance;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    ",
        "js": "\n    ```javascript\nfunction nearestValidPoint(x, y, points) {\n    let min_distance = Number.MAX_VALUE, index = -1;\n    for (let i = 0; i < points.length; i++) {\n        if (x === points[i][0] || y === points[i][1]) {\n            const distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if (distance < min_distance) {\n                min_distance = distance;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    Iterate through each point in the `points` array, checking if its x or y coordinate is the same as the input x or y coordinate, making the point a valid point. If the point is valid, calculate the Manhattan distance between the input point and the current point. If the calculated distance is smaller than the current minimum distance, update the minimum distance and store the index of the current point. After iterating through all points, return the index of the point with the smallest Manhattan distance. If no point is valid, return -1.\n    "
    },
    {
        "id": 1609,
        "title": "Minimum Elements to Add to Form a Given Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` and two integers `limit` and `goal`. The array `nums` has an interesting property that `abs(nums[i]) <= limit`.\n\nReturn _the minimum number of elements you need to add to make the sum of the array equal to_ `goal`. The array must maintain its property that `abs(nums[i]) <= limit`.\n\nNote that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,-1,1\\], limit = 3, goal = -4\n**Output:** 2\n**Explanation:** You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,-10,9,1\\], limit = 100, goal = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= limit <= 106`\n*   `-limit <= nums[i] <= limit`\n*   `-109 <= goal <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,-1,1],3,-4",
                "output": "2"
            },
            {
                "input": "[1,-10,9,1],100,0",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minElements(int[] nums, int limit, int goal) {\n    long sum = 0;\n    for (int num : nums) sum += num;\n    long diff = Math.abs(goal - sum);\n    \n    return (int)((diff + limit - 1) / limit);\n}\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ",
        "python": "\n    ```python\ndef minElements(nums, limit, goal):\n    sum_nums = sum(nums)\n    diff = abs(goal - sum_nums)\n    \n    return (diff + limit - 1) // limit\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ",
        "c++": "\n    ```cpp\nint minElements(vector<int>& nums, int limit, int goal) {\n    long long sum = 0;\n    for (int num : nums) sum += num;\n    long long diff = abs(goal - sum);\n    \n    return (diff + limit - 1) / limit;\n}\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    ",
        "js": "\n    ```javascript\nfunction minElements(nums, limit, goal) {\n    let sum = nums.reduce((a, b) => a + b, 0);\n    let diff = Math.abs(goal - sum);\n    \n    return Math.ceil(diff / limit);\n}\n```\n\n    \n    1. Calculate the sum of the elements in the input array `nums`. \n2. Calculate the absolute difference between the `goal` and the sum of `nums`. \n3. Divide the absolute difference by the `limit`, rounding up to the nearest integer. This gives the minimum number of elements needed to add to make the sum of the array `nums` equal to `goal` while maintaining the property that `abs(nums[i]) <= limit`.\n    "
    },
    {
        "id": 1618,
        "title": "Second Largest Digit in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an alphanumeric string `s`, return _the **second largest** numerical digit that appears in_ `s`_, or_ `-1` _if it does not exist_.\n\nAn **alphanumeric** string is a string consisting of lowercase English letters and digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"dfa12321afd \"\n**Output:** 2\n**Explanation:** The digits that appear in s are \\[1, 2, 3\\]. The second largest digit is 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abc1111 \"\n**Output:** -1\n**Explanation:** The digits that appear in s are \\[1\\]. There is no second largest digit."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of only lowercase English letters and/or digits.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "\"dfa12321afd\"",
                "output": "2"
            },
            {
                "input": "\"abc1111\"",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int secondHighest(String s) {\n    int largest = -1, second_largest = -1;\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            int d = c - '0';\n            if (d > largest) {\n                second_largest = largest;\n                largest = d;\n            } else if (d < largest && d > second_largest) {\n                second_largest = d;\n            }\n        }\n    }\n    return second_largest;\n}\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "python": "\n    ```python\ndef second_highest(s: str) -> int:\n    largest = -1\n    second_largest = -1\n    for c in s:\n        if c.isdigit():\n            d = int(c)\n            if d > largest:\n                second_largest = largest\n                largest = d\n            elif d < largest and d > second_largest:\n                second_largest = d\n    return second_largest\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "c++": "\n    ```cpp\nint secondHighest(string s) {\n    int largest = -1, second_largest = -1;\n    for (char c : s) {\n        if (isdigit(c)) {\n            int d = c - '0';\n            if (d > largest) {\n                second_largest = largest;\n                largest = d;\n            } else if (d < largest && d > second_largest) {\n                second_largest = d;\n            }\n        }\n    }\n    return second_largest;\n}\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    ",
        "js": "\n    ```javascript\nfunction secondHighest(s) {\n    let largest = -1, second_largest = -1;\n    for (let c of s) {\n        if (!isNaN(c)) {\n            let d = parseInt(c);\n            if (d > largest) {\n                second_largest = largest;\n                largest = d;\n            } else if (d < largest && d > second_largest) {\n                second_largest = d;\n            }\n        }\n    }\n    return second_largest;\n}\n```\n    \n    To solve this problem, we keep track of the largest and second largest numerical digit, initializing them to -1.\nWe iterate through each character in the input string, check if it's a digit using `isdigit` function in C++, `Character.isDigit` in Java, `c.isdigit()` in Python, and `!isNaN(c)` in JavaScript. If it's a digit, we convert it to an integer and then compare it with the current largest and second largest values.\n1. If the digit is greater than largest, we update second_largest to the largest value, and set largest to the digit.\n2. If the digit is not equal to the largest value and greater than second_largest, we update second_largest to the digit.\nAfter the loop, we return the second_largest value. If no second largest digit exists, the value will still be -1.\n    "
    },
    {
        "id": 1645,
        "title": "Minimum Operations to Make the Array Increasing",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` (**0-indexed**). In one operation, you can choose an element of the array and increment it by `1`.\n\n*   For example, if `nums = [1,2,3]`, you can choose to increment `nums[1]` to make `nums = [1,**3**,3]`.\n\nReturn _the **minimum** number of operations needed to make_ `nums` _**strictly** **increasing**._\n\nAn array `nums` is **strictly increasing** if `nums[i] < nums[i+1]` for all `0 <= i < nums.length - 1`. An array of length `1` is trivially strictly increasing.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 3\n**Explanation:** You can do the following operations:\n1) Increment nums\\[2\\], so nums becomes \\[1,1,**2**\\].\n2) Increment nums\\[1\\], so nums becomes \\[1,**2**,2\\].\n3) Increment nums\\[2\\], so nums becomes \\[1,2,**3**\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,2,4,1\\]\n**Output:** 14\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[8\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `1 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,1,1]",
                "output": "3"
            },
            {
                "input": "[1,5,2,4,1]",
                "output": "14"
            },
            {
                "input": "[8]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += (nums[i - 1] - nums[i]) + 1\n            nums[i] = nums[i - 1] + 1\n    return operations\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ",
        "c++": "\n    ```cpp\nint min_operations(vector<int>& nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    let operations = 0;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += (nums[i - 1] - nums[i]) + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm iterates through the input array `nums` from the second element (index 1) to the end. For each element, if it is less than or equal to its previous element, we need to increment it to make the array strictly increasing. We calculate the difference between the current element and the previous element and add 1 to it to find the required number of increments. We then update both the element in the array and the total count of operations. At the end, we return the total count of operations.\n    "
    },
    {
        "id": 1646,
        "title": "Queries on Number of Points Inside a Circle",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the `ith` point on a 2D plane. Multiple points can have the **same** coordinates.\n\nYou are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle centered at `(xj, yj)` with a radius of `rj`.\n\nFor each query `queries[j]`, compute the number of points **inside** the `jth` circle. Points **on the border** of the circle are considered **inside**.\n\nReturn _an array_ `answer`_, where_ `answer[j]` _is the answer to the_ `jth` _query_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[3,3\\],\\[5,3\\],\\[2,2\\]\\], queries = \\[\\[2,3,1\\],\\[4,3,1\\],\\[1,1,2\\]\\]\n**Output:** \\[3,2,2\\]\n**Explanation:** The points and circles are shown above.\nqueries\\[0\\] is the green circle, queries\\[1\\] is the red circle, and queries\\[2\\] is the blue circle.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\], queries = \\[\\[1,2,2\\],\\[2,2,2\\],\\[4,3,2\\],\\[4,3,3\\]\\]\n**Output:** \\[2,3,2,4\\]\n**Explanation:** The points and circles are shown above.\nqueries\\[0\\] is green, queries\\[1\\] is red, queries\\[2\\] is blue, and queries\\[3\\] is purple."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 500`\n*   `points[i].length == 2`\n*   `0 <= x​​​​​​i, y​​​​​​i <= 500`\n*   `1 <= queries.length <= 500`\n*   `queries[j].length == 3`\n*   `0 <= xj, yj <= 500`\n*   `1 <= rj <= 500`\n*   All coordinates are integers.\n\n**",
            "follow_up": "Follow up:** Could you find the answer for each query in better complexity than `O(n)`?"
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,3],[3,3],[5,3],[2,2]],[[2,3,1],[4,3,1],[1,1,2]]",
                "output": "[3,2,2]"
            },
            {
                "input": "[[1,1],[2,2],[3,3],[4,4],[5,5]],[[1,2,2],[2,2,2],[4,3,2],[4,3,3]]",
                "output": "[2,3,2,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int[] countPoints(int[][] points, int[][] queries) {\n    int[] answer = new int[queries.length];\n    for (int i = 0; i < queries.length; i++) {\n        int inside = 0;\n        for (int[] point : points) {\n            int dx = point[0] - queries[i][0];\n            int dy = point[1] - queries[i][1];\n            if (dx * dx + dy * dy <= queries[i][2] * queries[i][2]) {\n                inside++;\n            }\n        }\n        answer[i] = inside;\n    }\n    return answer;\n}\n```\n\n    \n    For each query circle, we iterate over each point to check if it lies inside the circle. To check if a point is inside the circle, we calculate the squared distance (dx * dx + dy * dy) between the point and the center of the circle. If the squared distance is less than or equal to the squared radius of the circle, that means the point is inside the circle or on its border. We increment an `inside` counter for each point that satisfies this condition. The counter gets added to the `answer` array after iterating over all the points for the current circle. We repeat this process for all query circles and return the array of `inside` counts.\n    ",
        "python": "\n    ```python\ndef countPoints(points, queries):\n    answer = []\n    for query in queries:\n        inside = 0\n        for point in points:\n            dx = point[0] - query[0]\n            dy = point[1] - query[1]\n            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1\n        answer.append(inside)\n    return answer\n```\n\n    \n    For each query circle, we iterate over each point to check if it lies inside the circle. To check if a point is inside the circle, we calculate the squared distance (dx * dx + dy * dy) between the point and the center of the circle. If the squared distance is less than or equal to the squared radius of the circle, that means the point is inside the circle or on its border. We increment an `inside` counter for each point that satisfies this condition. The counter gets added to the `answer` array after iterating over all the points for the current circle. We repeat this process for all query circles and return the array of `inside` counts.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n    vector<int> answer;\n    for (auto& query : queries) {\n        int inside = 0;\n        for (auto& point : points) {\n            int dx = point[0] - query[0];\n            int dy = point[1] - query[1];\n            if (dx * dx + dy * dy <= query[2] * query[2]) {\n                inside++;\n            }\n        }\n        answer.push_back(inside);\n    }\n    return answer;\n}\n```\n\n    \n    For each query circle, we iterate over each point to check if it lies inside the circle. To check if a point is inside the circle, we calculate the squared distance (dx * dx + dy * dy) between the point and the center of the circle. If the squared distance is less than or equal to the squared radius of the circle, that means the point is inside the circle or on its border. We increment an `inside` counter for each point that satisfies this condition. The counter gets added to the `answer` array after iterating over all the points for the current circle. We repeat this process for all query circles and return the array of `inside` counts.\n    ",
        "js": "\n    ```javascript\nfunction countPoints(points, queries) {\n    const answer = [];\n    for (const query of queries) {\n        let inside = 0;\n        for (const point of points) {\n            const dx = point[0] - query[0];\n            const dy = point[1] - query[1];\n            if (dx * dx + dy * dy <= query[2] * query[2]) {\n                inside++;\n            }\n        }\n        answer.push(inside);\n    }\n    return answer;\n}\n```\n\n    \n    For each query circle, we iterate over each point to check if it lies inside the circle. To check if a point is inside the circle, we calculate the squared distance (dx * dx + dy * dy) between the point and the center of the circle. If the squared distance is less than or equal to the squared radius of the circle, that means the point is inside the circle or on its border. We increment an `inside` counter for each point that satisfies this condition. The counter gets added to the `answer` array after iterating over all the points for the current circle. We repeat this process for all query circles and return the array of `inside` counts.\n    "
    },
    {
        "id": 1661,
        "title": "Maximum Element After Decreasing and Rearranging",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of positive integers `arr`. Perform some operations (possibly none) on `arr` so that it satisfies these conditions:\n\n*   The value of the **first** element in `arr` must be `1`.\n*   The absolute difference between any 2 adjacent elements must be **less than or equal to** `1`. In other words, `abs(arr[i] - arr[i - 1]) <= 1` for each `i` where `1 <= i < arr.length` (**0-indexed**). `abs(x)` is the absolute value of `x`.\n\nThere are 2 types of operations that you can perform any number of times:\n\n*   **Decrease** the value of any element of `arr` to a **smaller positive integer**.\n*   **Rearrange** the elements of `arr` to be in any order.\n\nReturn _the **maximum** possible value of an element in_ `arr` _after performing the operations to satisfy the conditions_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,2,1,2,1\\]\n**Output:** 2\n**Explanation:** \nWe can satisfy the conditions by rearranging `arr` so it becomes `[1,2,2,2,1]`.\nThe largest element in `arr` is 2.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[100,1,1000\\]\n**Output:** 3\n**Explanation:** \nOne possible way to satisfy the conditions is by doing the following:\n1. Rearrange `arr` so it becomes `[1,100,1000]`.\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow `arr = [1,2,3], which` satisfies the conditions.\nThe largest element in `arr is 3.`\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[1,2,3,4,5\\]\n**Output:** 5\n**Explanation:** The array already satisfies the conditions, and the largest element is 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[2,2,1,2,1]",
                "output": "2"
            },
            {
                "input": "[100,1,1000]",
                "output": "3"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int maximumElementAfterDecrementingAndRearranging(int[] arr) {\n    Arrays.sort(arr);\n    arr[0] = 1;\n    for (int i = 1; i < arr.length; i++) {\n        arr[i] = Math.min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.length - 1];\n}\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ",
        "python": "\n    ```python\ndef maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:\n    arr.sort()\n    arr[0] = 1\n    for i in range(1, len(arr)):\n        arr[i] = min(arr[i], arr[i - 1] + 1)\n    return arr[-1]\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ",
        "c++": "\n    ```cpp\nint maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {\n    sort(arr.begin(), arr.end());\n    arr[0] = 1;\n    for (int i = 1; i < arr.size(); i++) {\n        arr[i] = min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.size() - 1];\n}\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    ",
        "js": "\n    ```javascript\nfunction maximumElementAfterDecrementingAndRearranging(arr) {\n    arr.sort((a, b) => a - b);\n    arr[0] = 1;\n    for (let i = 1; i < arr.length; i++) {\n        arr[i] = Math.min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.length - 1];\n}\n```\n    \n    The main idea of this algorithm is to sort the array and modify it following these steps:\n1. Set the first element to 1.\n2. Iterate through the array starting from the second element. For each element, set its value to the minimum of its current value and the value of the previous element plus one.\n\nSince we sort the array, the absolute difference between adjacent elements after this transformation will always satisfy the conditions. Sorting ensures that we decrement the values as little as possible.\n\nOur goal is to return the maximum value, which will be the last element of the array after modifying it in this way.\n    "
    },
    {
        "id": 1668,
        "title": "Maximum Population Year",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die.\n\nReturn _the **earliest** year with the **maximum population**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** logs = \\[\\[1993,1999\\],\\[2000,2010\\]\\]\n**Output:** 1993\n**Explanation:** The maximum population is 1, and 1993 is the earliest year with this population.\n\n",
                "**Example 2:**\n\n**Input:** logs = \\[\\[1950,1961\\],\\[1960,1971\\],\\[1970,1981\\]\\]\n**Output:** 1960\n**Explanation:** \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= logs.length <= 100`\n*   `1950 <= birthi < deathi <= 2050`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Counting",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1993,1999],[2000,2010]]",
                "output": "1993"
            },
            {
                "input": "[[1950,1961],[1960,1971],[1970,1981]]",
                "output": "1960"
            }
        ],
        "java": "\n    ```java\npublic int maxAliveYear(int[][] logs) {\n    int[] years = new int[101];\n    for (int[] log : logs) {\n        years[log[0] - 1950]++;\n        years[log[1] - 1950]--;\n    }\n    int max_population = years[0];\n    int max_year = 1950;\n    for (int i = 1; i < 101; i++) {\n        years[i] += years[i - 1];\n        if (years[i] > max_population) {\n            max_population = years[i];\n            max_year = i + 1950;\n        }\n    }\n    return max_year;\n}\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    ",
        "python": "\n    ```python\ndef maxAliveYear(logs):\n    years = [0] * 101\n    for log in logs:\n        years[log[0] - 1950] += 1\n        years[log[1] - 1950] -= 1\n    max_population = years[0]\n    max_year = 1950\n    for i in range(1, 101):\n        years[i] += years[i - 1]\n        if years[i] > max_population:\n            max_population = years[i]\n            max_year = i + 1950\n    return max_year\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    ",
        "c++": "\n    ```cpp\nint maxAliveYear(vector<vector<int>>& logs) {\n    vector<int> years(101, 0);\n    for (vector<int> log : logs) {\n        years[log[0] - 1950]++;\n        years[log[1] - 1950]--;\n    }\n    int max_population = years[0];\n    int max_year = 1950;\n    for (int i = 1; i < 101; i++) {\n        years[i] += years[i - 1];\n        if (years[i] > max_population) {\n            max_population = years[i];\n            max_year = i + 1950;\n        }\n    }\n    return max_year;\n}\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    ",
        "js": "\n    ```javascript\nfunction maxAliveYear(logs) {\n    let years = new Array(101).fill(0);\n    for (let log of logs) {\n        years[log[0] - 1950]++;\n        years[log[1] - 1950]--;\n    }\n    let max_population = years[0];\n    let max_year = 1950;\n    for (let i = 1; i < 101; i++) {\n        years[i] += years[i - 1];\n        if (years[i] > max_population) {\n            max_population = years[i];\n            max_year = i + 1950;\n        }\n    }\n    return max_year;\n}\n```\n    \n    The algorithm iterates through the logs and increments the birth year and decrements the death year in the years array. Then, starting from the first year, it accumulates the population for each year by summing up the previous year's population with the current year's population. After that, it checks which year has the maximum population and returns that year.\n    "
    },
    {
        "id": 1677,
        "title": "Sum of All Subset XOR Totals",
        "difficulty": "Easy",
        "content": {
            "problem": "The **XOR total** of an array is defined as the bitwise `XOR` of **all its elements**, or `0` if the array is **empty**.\n\n*   For example, the **XOR total** of the array `[2,5,6]` is `2 XOR 5 XOR 6 = 1`.\n\nGiven an array `nums`, return _the **sum** of all **XOR totals** for every **subset** of_ `nums`.\n\n**Note:** Subsets with the **same** elements should be counted **multiple** times.\n\nAn array `a` is a **subset** of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3\\]\n**Output:** 6\n**Explanation:** The 4 subsets of \\[1,3\\] are:\n- The empty subset has an XOR total of 0.\n- \\[1\\] has an XOR total of 1.\n- \\[3\\] has an XOR total of 3.\n- \\[1,3\\] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,1,6\\]\n**Output:** 28\n**Explanation:** The 8 subsets of \\[5,1,6\\] are:\n- The empty subset has an XOR total of 0.\n- \\[5\\] has an XOR total of 5.\n- \\[1\\] has an XOR total of 1.\n- \\[6\\] has an XOR total of 6.\n- \\[5,1\\] has an XOR total of 5 XOR 1 = 4.\n- \\[5,6\\] has an XOR total of 5 XOR 6 = 3.\n- \\[1,6\\] has an XOR total of 1 XOR 6 = 7.\n- \\[5,1,6\\] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,4,5,6,7,8\\]\n**Output:** 480\n**Explanation:** The sum of all XOR totals for every subset is 480."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 12`\n*   `1 <= nums[i] <= 20`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Backtracking",
            "Bit Manipulation",
            "Combinatorics",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[1,3]",
                "output": "6"
            },
            {
                "input": "[5,1,6]",
                "output": "28"
            },
            {
                "input": "[3,4,5,6,7,8]",
                "output": "480"
            }
        ],
        "java": "\n    ```java\npublic int subsetXORSum(int[] nums) {\n    int ans = 0, n = nums.length, max_val = 1 << n;\n    for (int i = 1; i < max_val; i++) {\n        int xor_total = 0;\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j)) > 0) {\n                xor_total ^= nums[j];\n            }\n        }\n        ans += xor_total;\n    }\n    return ans;\n}\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    ",
        "python": "\n    ```python\ndef subsetXORSum(nums):\n    ans = 0\n    n = len(nums)\n    max_val = 1 << n\n    for i in range(1, max_val):\n        xor_total = 0\n        for j in range(n):\n            if i & (1 << j):\n                xor_total ^= nums[j]\n        ans += xor_total\n    return ans\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    ",
        "c++": "\n    ```cpp\nint subsetXORSum(vector<int>& nums) {\n    int ans = 0, n = nums.size(), max_val = 1 << n;\n    for (int i = 1; i < max_val; i++) {\n        int xor_total = 0;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                xor_total ^= nums[j];\n            }\n        }\n        ans += xor_total;\n    }\n    return ans;\n}\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    ",
        "js": "\n    ```javascript\nfunction subsetXORSum(nums) {\n    let ans = 0, n = nums.length, max_val = 1 << n;\n    for (let i = 1; i < max_val; i++) {\n        let xor_total = 0;\n        for (let j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                xor_total ^= nums[j];\n            }\n        }\n        ans += xor_total;\n    }\n    return ans;\n}\n```\n    \n    Loop through all 2^N possible subsets of `nums`, which can be represented as binary numbers from 0 to 2^N - 1. A bit set to 1 at position i indicates that nums[i] is part of the subset. Calculate the XOR total for each of these subsets and accumulate it. Finally, return the total sum. Note that the starting position of the loop is 1 since we skip the empty subset.\n    "
    },
    {
        "id": 1688,
        "title": "Minimize Maximum Pair Sum in Array",
        "difficulty": "Medium",
        "content": {
            "problem": "The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs.\n\n*   For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.\n\nGiven an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:\n\n*   Each element of `nums` is in **exactly one** pair, and\n*   The **maximum pair sum** is **minimized**.\n\nReturn _the minimized **maximum pair sum** after optimally pairing up the elements_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,5,2,3\\]\n**Output:** 7\n**Explanation:** The elements can be paired up into pairs (3,3) and (5,2).\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,5,4,2,4,6\\]\n**Output:** 8\n**Explanation:** The elements can be paired up into pairs (3,5), (4,4), and (6,2).\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 105`\n*   `n` is **even**.\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[3,5,2,3]",
                "output": "7"
            },
            {
                "input": "[3,5,4,2,4,6]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int minPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int maxSum = 0;\n    for (int i = 0; i < nums.length / 2; i++)\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - 1 - i]);\n    return maxSum;\n}\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ",
        "python": "\n    ```python\ndef minPairSum(nums):\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ",
        "c++": "\n    ```cpp\nint minPairSum(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int max_sum = 0;\n    for (int i = 0; i < nums.size() / 2; ++i)\n        max_sum = max(max_sum, nums[i] + nums[nums.size() - 1 - i]);\n    return max_sum;\n}\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    ",
        "js": "\n    ```javascript\nfunction minPairSum(nums) {\n    nums.sort((a, b) => a - b);\n    let maxSum = 0;\n    for (let i = 0; i < nums.length / 2; i++)\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - 1 - i]);\n    return maxSum;\n}\n```\n    \n    First, we sort the nums array in ascending order. Then, we iterate through the first half of the nums and use the two-pointer technique to find pairs of elements that minimize the maximum pair sum. For each pair, we calculate the sum of the current element and the element at the opposite end of the array (last element minus the index). We then update max_sum with the max value between the current max_sum and the pair sum for each iteration. Finally, we return the max_sum.\n    "
    },
    {
        "id": 1711,
        "title": "Largest Odd Number in String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `num`, representing a large integer. Return _the **largest-valued odd** integer (as a string) that is a **non-empty substring** of_ `num`_, or an empty string_ `\" \"` _if no odd integer exists_.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"52 \"\n**Output:**  \"5 \"\n**Explanation:** The only non-empty substrings are  \"5 \",  \"2 \", and  \"52 \".  \"5 \" is the only odd number.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"4206 \"\n**Output:**  \" \"\n**Explanation:** There are no odd numbers in  \"4206 \".\n\n",
                "**Example 3:**\n\n**Input:** num =  \"35427 \"\n**Output:**  \"35427 \"\n**Explanation:**  \"35427 \" is already an odd number."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 105`\n*   `num` only consists of digits and does not contain any leading zeros.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"52\"",
                "output": "\"5\""
            },
            {
                "input": "\"4206\"",
                "output": "\"\""
            },
            {
                "input": "\"35427\"",
                "output": "\"35427\""
            }
        ],
        "java": "\n    ```java\npublic String largestOddNumber(String num) {\n    for (int i = num.length() - 1; i >= 0; i--) {\n        if ((num.charAt(i) - '0') % 2 != 0) {\n            return num.substring(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ",
        "python": "\n    ```python\ndef largest_odd_number(num: str) -> str:\n    for i in range(len(num) - 1, -1, -1):\n        if int(num[i]) % 2 != 0:\n            return num[:i + 1]\n    return \"\"\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ",
        "c++": "\n    ```cpp\nstd::string largestOddNumber(std::string num) {\n    for (int i = num.length() - 1; i >= 0; i--) {\n        if ((num[i] - '0') % 2 != 0) {\n            return num.substr(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    ",
        "js": "\n    ```javascript\nfunction largestOddNumber(num) {\n    for (let i = num.length - 1; i >= 0; i--) {\n        if ((num.charCodeAt(i) - '0'.charCodeAt(0)) % 2 !== 0) {\n            return num.slice(0, i + 1);\n        }\n    }\n    return \"\";\n}\n```\n    \n    The algorithm starts iterating through the given string `num` from the last character to the first one. Since we only need the largest odd number as a substring, we only need to find the first odd digit when iterating from right to left. When we find an odd digit, that means the current non-empty substring is the largest odd number, and we return that substring. If no odd digits are found, the function returns an empty string. The time complexity is O(n), where n is the length of the string `num`.\n    "
    },
    {
        "id": 1784,
        "title": "Find the Middle Index in Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, find the **leftmost** `middleIndex` (i.e., the smallest amongst all the possible ones).\n\nA `middleIndex` is an index where `nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]`.\n\nIf `middleIndex == 0`, the left side sum is considered to be `0`. Similarly, if `middleIndex == nums.length - 1`, the right side sum is considered to be `0`.\n\nReturn _the **leftmost**_ `middleIndex` _that satisfies the condition, or_ `-1` _if there is no such index_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,-1,8,4\\]\n**Output:** 3\n**Explanation:** The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,-1,4\\]\n**Output:** 2\n**Explanation:** The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,5\\]\n**Output:** -1\n**Explanation:** There is no valid middleIndex."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `-1000 <= nums[i] <= 1000`\n\n**Note:** This question is the same as 724: [https://leetcode.com/problems/find-pivot-index/](https://leetcode.com/problems/find-pivot-index/)",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,3,-1,8,4]",
                "output": "3"
            },
            {
                "input": "[1,-1,4]",
                "output": "2"
            },
            {
                "input": "[2,5]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findMiddleIndex(int[] nums) {\n    int totalSum = 0, leftSum = 0;\n\n    for (int num : nums) {\n        totalSum += num;\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (leftSum == totalSum - leftSum - nums[i]) {\n            return i;\n        }\n        leftSum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    ",
        "python": "\n    ```python\ndef findMiddleIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n\n    return -1\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint findMiddleIndex(vector<int>& nums) {\n    int total_sum = 0, left_sum = 0;\n\n    for (int num : nums) {\n        total_sum += num;\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        if (left_sum == total_sum - left_sum - nums[i]) {\n            return i;\n        }\n        left_sum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findMiddleIndex(nums) {\n    let totalSum = 0, leftSum = 0;\n\n    nums.forEach(num => {\n        totalSum += num;\n    });\n\n    for (let i = 0; i < nums.length; i++) {\n        if (leftSum === totalSum - leftSum - nums[i]) {\n            return i;\n        }\n        leftSum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    Initially, calculate the total sum of the array elements. Iterate through the array and track the left_sum at every index. If the left_sum matches the updated sum of elements (total_sum - left_sum - current_number), then the current index is the middle index. If no such index is found, return -1.\n    "
    },
    {
        "id": 1843,
        "title": "Smallest Index With Equal Value",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, return _the **smallest** index_ `i` _of_ `nums` _such that_ `i mod 10 == nums[i]`_, or_ `-1` _if such index does not exist_.\n\n`x mod y` denotes the **remainder** when `x` is divided by `y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2\\]\n**Output:** 0\n**Explanation:** \ni=0: 0 mod 10 = 0 == nums\\[0\\].\ni=1: 1 mod 10 = 1 == nums\\[1\\].\ni=2: 2 mod 10 = 2 == nums\\[2\\].\nAll indices have i mod 10 == nums\\[i\\], so we return the smallest index 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,3,2,1\\]\n**Output:** 2\n**Explanation:** \ni=0: 0 mod 10 = 0 != nums\\[0\\].\ni=1: 1 mod 10 = 1 != nums\\[1\\].\ni=2: 2 mod 10 = 2 == nums\\[2\\].\ni=3: 3 mod 10 = 3 != nums\\[3\\].\n2 is the only index which has i mod 10 == nums\\[i\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9,0\\]\n**Output:** -1\n**Explanation:** No index satisfies i mod 10 == nums\\[i\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array"
        ],
        "example": [
            {
                "input": "[0,1,2]",
                "output": "0"
            },
            {
                "input": "[4,3,2,1]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4,5,6,7,8,9,0]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int smallestIndex(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        if (i % 10 == nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    ",
        "python": "\n    ```python\ndef smallest_index(nums):\n    for i, num in enumerate(nums):\n        if i % 10 == num:\n            return i\n    return -1\n```\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    ",
        "c++": "\n    ```cpp\nint smallestIndex(std::vector<int>& nums) {\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (i % 10 == nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    ",
        "js": "\n    ```javascript\nfunction smallestIndex(nums) {\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 10 === nums[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm iterates through the elements of the input array (nums) and checks whether the current index (i) of the element satisfies the condition `i mod 10 == nums[i]`. If the condition is satisfied, it returns the index (i). If the loop finishes without finding an index that satisfies the condition, it returns -1.\n\nThe algorithm has a time complexity of O(n), where n is the length of the input array. This is because the algorithm iterates through the array once.\n    "
    },
    {
        "id": 1857,
        "title": "Time Needed to Buy Tickets",
        "difficulty": "Easy",
        "content": {
            "problem": "There are `n` people in a line queuing to buy tickets, where the `0th` person is at the **front** of the line and the `(n - 1)th` person is at the **back** of the line.\n\nYou are given a **0-indexed** integer array `tickets` of length `n` where the number of tickets that the `ith` person would like to buy is `tickets[i]`.\n\nEach person takes **exactly 1 second** to buy a ticket. A person can only buy **1 ticket at a time** and has to go back to **the end** of the line (which happens **instantaneously**) in order to buy more tickets. If a person does not have any tickets left to buy, the person will **leave** the line.\n\nReturn _the **time taken** for the person at position_ `k` **_(0-indexed)_** _to finish buying tickets_.",
            "examples": [
                "**Example 1:**\n\n**Input:** tickets = \\[2,3,2\\], k = 2\n**Output:** 6\n**Explanation:** \n- In the first pass, everyone in the line buys a ticket and the line becomes \\[1, 2, 1\\].\n- In the second pass, everyone in the line buys a ticket and the line becomes \\[0, 1, 0\\].\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n\n",
                "**Example 2:**\n\n**Input:** tickets = \\[5,1,1,1\\], k = 0\n**Output:** 8\n**Explanation:**\n- In the first pass, everyone in the line buys a ticket and the line becomes \\[4, 0, 0, 0\\].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds."
            ],
            "constraints": "**Constraints:**\n\n*   `n == tickets.length`\n*   `1 <= n <= 100`\n*   `1 <= tickets[i] <= 100`\n*   `0 <= k < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Queue",
            "Simulation"
        ],
        "example": [
            {
                "input": "[2,3,2],2",
                "output": "6"
            },
            {
                "input": "[5,1,1,1],0",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int timeToBuyTickets(int[] tickets, int k) {\n    int time = 0;\n    while (tickets[k] > 0) {\n        for (int i = 0; i < tickets.length; ++i) {\n            if (tickets[i] > 0) {\n                --tickets[i];\n                ++time;\n                if (i == k && tickets[k] == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    return time;\n}\n```\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    ",
        "python": "\n    ```python\ndef time_to_buy_tickets(tickets, k):\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n                if i == k and tickets[k] == 0:\n                    break\n    return time\n```\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    ",
        "c++": "\n    ```cpp\nint time_to_buy_tickets(vector<int>& tickets, int k) {\n    int time = 0;\n    while (tickets[k] > 0) {\n        for (int i = 0; i < tickets.size(); ++i) {\n            if (tickets[i] > 0) {\n                --tickets[i];\n                ++time;\n                if (i == k && tickets[k] == 0) {\n                    break;\n                }\n            }\n        }\n    }\n    return time;\n}\n```\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    ",
        "js": "\n    ```javascript\nfunction timeToBuyTickets(tickets, k) {\n    let time = 0;\n    while (tickets[k] > 0) {\n        for (let i = 0; i < tickets.length; ++i) {\n            if (tickets[i] > 0) {\n                --tickets[i];\n                ++time;\n                if (i === k && tickets[k] === 0) {\n                    break;\n                }\n            }\n        }\n    }\n    return time;\n}\n```\n\n    \n    The algorithm starts with a variable `time` set to 0. It then enters into a loop that will continue until the person at position `k` has bought all their tickets (`tickets[k] > 0`). \n\nInside the loop, we iterate through each person in the queue. If the person has remaining tickets to buy, we decrement the number of tickets they need to buy (`tickets[i]`), increment the `time` variable, and check if the person is the one at position `k` and has finished buying all their tickets. If so, we break out of the inner loop.\n\nAfter the person at position `k` has bought all their tickets, the algorithm will exit the outer loop and return the `time` variable.\n    "
    },
    {
        "id": 1920,
        "title": "Maximum Running Time of N Computers",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "2,[3,3,3]",
                "output": "4"
            },
            {
                "input": "2,[1,1,1,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int max_computer_runtime(int n, int[] batteries) {\n    Arrays.sort(batteries);\n    int result = 0;\n    for (int i = 0; i < batteries.length; i++) {\n        result = Math.max(result, Math.min(n, batteries.length - i) * batteries[i]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    ",
        "python": "\n    ```python\ndef max_computer_runtime(n, batteries):\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    ",
        "c++": "\n    ```cpp\nint max_computer_runtime(int n, vector<int>& batteries) {\n    sort(batteries.begin(), batteries.end());\n    int result = 0;\n    for (int i = 0; i < batteries.size(); ++i) {\n        result = max(result, min(n, int(batteries.size()) - i) * batteries[i]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    ",
        "js": "\n    ```javascript\nfunction max_computer_runtime(n, batteries) {\n    batteries.sort((a, b) => a - b);\n    let result = 0;\n    for (let i = 0; i < batteries.length; i++) {\n        result = Math.max(result, Math.min(n, batteries.length - i) * batteries[i]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    "
    },
    {
        "id": 2021,
        "title": "Remove Digit From Number to Maximize Result",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `number` representing a **positive integer** and a character `digit`.\n\nReturn _the resulting string after removing **exactly one occurrence** of_ `digit` _from_ `number` _such that the value of the resulting string in **decimal** form is **maximized**_. The test cases are generated such that `digit` occurs at least once in `number`.",
            "examples": [
                "**Example 1:**\n\n**Input:** number =  \"123 \", digit =  \"3 \"\n**Output:**  \"12 \"\n**Explanation:** There is only one '3' in  \"123 \". After removing '3', the result is  \"12 \".\n\n",
                "**Example 2:**\n\n**Input:** number =  \"1231 \", digit =  \"1 \"\n**Output:**  \"231 \"\n**Explanation:** We can remove the first '1' to get  \"231 \" or remove the second '1' to get  \"123 \".\nSince 231 > 123, we return  \"231 \".\n\n",
                "**Example 3:**\n\n**Input:** number =  \"551 \", digit =  \"5 \"\n**Output:**  \"51 \"\n**Explanation:** We can remove either the first or second '5' from  \"551 \".\nBoth result in the string  \"51 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= number.length <= 100`\n*   `number` consists of digits from `'1'` to `'9'`.\n*   `digit` is a digit from `'1'` to `'9'`.\n*   `digit` occurs at least once in `number`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Enumeration"
        ],
        "example": [
            {
                "input": "\"123\",\"3\"",
                "output": "\"12\""
            },
            {
                "input": "\"1231\",\"1\"",
                "output": "\"231\""
            },
            {
                "input": "\"551\",\"5\"",
                "output": "\"51\""
            }
        ],
        "java": "\n    ```java\npublic String maxNumberAfterRemoveDigit(String number, char digit) {\n    int index = number.indexOf(digit);\n    return number.substring(0, index) + number.substring(index + 1);\n}\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    ",
        "python": "\n    ```python\ndef max_number_after_remove_digit(number: str, digit: str) -> str:\n    index = number.find(digit)\n    return number[:index] + number[index + 1:]\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    ",
        "c++": "\n    ```cpp\nstd::string maxNumberAfterRemoveDigit(const std::string& number, const char digit) {\n    size_t index = number.find(digit);\n    std::string result = number;\n    result.erase(index, 1);\n    return result;\n}\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberAfterRemoveDigit(number, digit) {\n    const index = number.indexOf(digit);\n    return number.slice(0, index) + number.slice(index + 1);\n}\n```\n    \n    The algorithm for all the implementations is as follows:\n\n1. Find the index of the first occurrence of the `digit` in the `number` string.\n2. Make a copy of the `number` string (this is done implicitly for Java, Python, and JavaScript when manipulating strings), removing the digit at the found index.\n3. Return the new string as the result.\n\nIn all language implementations, we first use string methods like `find`, `indexOf`, or `search` to find the index of the first occurrence of the digit in the number string. After that, we create a new string by removing the digit at that index using different string methods like `erase` (in C++), `substring` (in Java), string slicing (in Python), or `slice` method (in JavaScript).\n\nThe time complexity for this algorithm is O(n) where n is the length of the number string. This is because finding the index of the digit and removing the digit from the string takes linear time.\n    "
    },
    {
        "id": 2026,
        "title": "Largest 3-Same-Digit Number in String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `num` representing a large integer. An integer is **good** if it meets the following conditions:\n\n*   It is a **substring** of `num` with length `3`.\n*   It consists of only one unique digit.\n\nReturn _the **maximum good** integer as a **string** or an empty string_ `\" \"` _if no such integer exists_.\n\nNote:\n\n*   A **substring** is a contiguous sequence of characters within a string.\n*   There may be **leading zeroes** in `num` or a good integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"6**777**133339 \"\n**Output:**  \"777 \"\n**Explanation:** There are two distinct good integers:  \"777 \" and  \"333 \".\n \"777 \" is the largest, so we return  \"777 \".\n\n",
                "**Example 2:**\n\n**Input:** num =  \"23**000**19 \"\n**Output:**  \"000 \"\n**Explanation:**  \"000 \" is the only good integer.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"42352338 \"\n**Output:**  \" \"\n**Explanation:** No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= num.length <= 1000`\n*   `num` only consists of digits.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"6**777**133339\"",
                "output": "\"777\""
            },
            {
                "input": "\"23**000**19\"",
                "output": "\"000\""
            },
            {
                "input": "\"42352338\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nint splitAndMinimize(int num) {\n    int a = num / 1000;\n    int b = (num % 1000) / 100;\n    int c = (num % 100) / 10;\n    int d = num % 10;\n    return ((a * 10 + c) * 10 + b) * 10 + d;\n}\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    ",
        "python": "\n    ```python\ndef split_and_minimize(num):\n    a = num // 1000\n    b = (num % 1000) // 100\n    c = (num % 100) // 10\n    d = num % 10\n    return ((a * 10 + c) * 10 + b) * 10 + d\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    ",
        "c++": "\n    ```cpp\nint splitAndMinimize(int num) {\n    int a = num / 1000;\n    int b = (num % 1000) / 100;\n    int c = (num % 100) / 10;\n    int d = num % 10;\n    return ((a * 10 + c) * 10 + b) * 10 + d;\n}\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    ",
        "js": "\n    ```javascript\nfunction splitAndMinimize(num) {\n    let a = Math.floor(num / 1000);\n    let b = Math.floor((num % 1000) / 100);\n    let c = Math.floor((num % 100) / 10);\n    let d = num % 10;\n    return ((a * 10 + c) * 10 + b) * 10 + d;\n}\n```\n    \n    First, we split the given four-digit number 'num' into its individual digits a, b, c, and d.\nThen, we create two new numbers by changing the positioning of the digits in the following manner:\n\n- new1 = a*10 + c (i.e., the first and the third digits of the original number)\n- new2 = b*10 + d (i.e., the second and the fourth digits of the original number)\n\nFinally, we return the sum of these two new numbers as the minimum possible sum of new1 and new2.\n    "
    },
    {
        "id": 2035,
        "title": "Find Resultant Array After Removing Anagrams",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** string array `words`, where `words[i]` consists of lowercase English letters.\n\nIn one operation, select any index `i` such that `0 < i < words.length` and `words[i - 1]` and `words[i]` are **anagrams**, and **delete** `words[i]` from `words`. Keep performing this operation as long as you can select an index that satisfies the conditions.\n\nReturn `words` _after performing all operations_. It can be shown that selecting the indices for each operation in **any** arbitrary order will lead to the same result.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, `\"dacb \"` is an anagram of `\"abdc \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abba \", \"baba \", \"bbaa \", \"cd \", \"cd \"\\]\n**Output:** \\[ \"abba \", \"cd \"\\]\n**Explanation:**\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words\\[2\\] =  \"bbaa \" and words\\[1\\] =  \"baba \" are anagrams, we choose index 2 and delete words\\[2\\].\n  Now words = \\[ \"abba \", \"baba \", \"cd \", \"cd \"\\].\n- Since words\\[1\\] =  \"baba \" and words\\[0\\] =  \"abba \" are anagrams, we choose index 1 and delete words\\[1\\].\n  Now words = \\[ \"abba \", \"cd \", \"cd \"\\].\n- Since words\\[2\\] =  \"cd \" and words\\[1\\] =  \"cd \" are anagrams, we choose index 2 and delete words\\[2\\].\n  Now words = \\[ \"abba \", \"cd \"\\].\nWe can no longer perform any operations, so \\[ \"abba \", \"cd \"\\] is the final answer.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"b \", \"c \", \"d \", \"e \"\\]\n**Output:** \\[ \"a \", \"b \", \"c \", \"d \", \"e \"\\]\n**Explanation:**\nNo two adjacent strings in words are anagrams of each other, so no operations are performed."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "[\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]",
                "output": "[\"abba\",\"cd\"]"
            },
            {
                "input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
                "output": "[\"a\",\"b\",\"c\",\"d\",\"e\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<String> anagramOperations(String[] words) {\n    List<String> result = new ArrayList<>();\n    result.add(words[0]);\n    \n    for (int i = 1; i < words.length; i++) {\n        char[] first = words[i].toCharArray();\n        char[] second = words[i - 1].toCharArray();\n        Arrays.sort(first);\n        Arrays.sort(second);\n        \n        if (!Arrays.equals(first, second)) {\n            result.add(words[i]);\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    ",
        "python": "\n    ```python\ndef anagramOperations(words):\n    i = 1\n    while i < len(words):\n        word1 = sorted(words[i])\n        word2 = sorted(words[i - 1])\n        if word1 == word2:\n            del words[i]\n        else:\n            i += 1\n    return words\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> anagramOperations(std::vector<std::string> &words) {\n    for (int i = 1; i < words.size(); ++i) {\n        std::string s1 = words[i];\n        std::string s2 = words[i - 1];\n        std::sort(s1.begin(), s1.end());\n        std::sort(s2.begin(), s2.end());\n        if (s1 == s2) {\n            words.erase(words.begin() + i);\n            --i;\n        }\n    }\n    return words;\n}\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    ",
        "js": "\n    ```javascript\nfunction anagramOperations(words) {\n  let i = 1;\n  while (i < words.length) {\n    let word1 = words[i].split('').sort().join('');\n    let word2 = words[i - 1].split('').sort().join('');\n    \n    if (word1 === word2) {\n      words.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n  return words;\n}\n```\n\n    \n    The algorithm iterates through the input array `words` starting from index 1. For each index `i` it checks if `words[i]` and `words[i-1]` are anagrams by sorting the characters within the two strings and comparing if they are equal (sorting and comparing their characters arrays in Java and JavaScript). If they are anagrams, it removes `words[i]` from the array and decrements index `i`. If not, it increments `i`. This continues until `i` reaches the end of the array. The resulting array will have no adjacent strings that are anagrams, since it iterated through all adjacent pairs and removed anagrams where possible.\n    "
    },
    {
        "id": 2061,
        "title": "Count Subarrays With Score Less Than K",
        "difficulty": "Hard",
        "content": {
            "problem": "The **score** of an array is defined as the **product** of its sum and its length.\n\n*   For example, the score of `[1, 2, 3, 4, 5]` is `(1 + 2 + 3 + 4 + 5) * 5 = 75`.\n\nGiven a positive integer array `nums` and an integer `k`, return _the **number of non-empty subarrays** of_ `nums` _whose score is **strictly less** than_ `k`.\n\nA **subarray** is a contiguous sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,4,3,5\\], k = 10\n**Output:** 6\n**Explanation:**\nThe 6 subarrays having scores less than 10 are:\n- \\[2\\] with score 2 \\* 1 = 2.\n- \\[1\\] with score 1 \\* 1 = 1.\n- \\[4\\] with score 4 \\* 1 = 4.\n- \\[3\\] with score 3 \\* 1 = 3. \n- \\[5\\] with score 5 \\* 1 = 5.\n- \\[2,1\\] with score (2 + 1) \\* 2 = 6.\nNote that subarrays such as \\[1,4\\] and \\[4,3,5\\] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\], k = 5\n**Output:** 5\n**Explanation:**\nEvery subarray except \\[1,1,1\\] has a score less than 5.\n\\[1,1,1\\] has a score (1 + 1 + 1) \\* 3 = 9, which is greater than 5.\nThus, there are 5 subarrays having scores less than 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\n*   `1 <= k <= 1015`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,1,4,3,5],10",
                "output": "6"
            },
            {
                "input": "[1,1,1],5",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int countSubarrays(int[] nums, long k) {\n    int n = nums.length;\n    int left = 0, right = 0;\n    long sum = 0, count = 0;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) >= k) {\n            sum -= nums[left];\n            left++;\n        }\n        count += right - left + 1;\n        right++;\n    }\n\n    return (int)count;\n}\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "python": "\n    ```python\ndef countSubarrays(nums: List[int], k: int) -> int:\n    n = len(nums)\n    left, right = 0, 0\n    sum_, count = 0, 0\n\n    while right < n:\n        sum_ += nums[right]\n        while sum_ * (right - left + 1) >= k:\n            sum_ -= nums[left]\n            left += 1\n        count += right - left + 1\n        right += 1\n\n    return count\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "c++": "\n    ```cpp\nint countSubarrays(vector<int>& nums, long long k) {\n    int n = nums.size();\n    int left = 0, right = 0;\n    long long sum = 0, count = 0;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) >= k) {\n            sum -= nums[left];\n            left++;\n        }\n        count += right - left + 1;\n        right++;\n    }\n\n    return count;\n}\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "js": "\n    ```javascript\nfunction countSubarrays(nums, k) {\n    let n = nums.length;\n    let left = 0, right = 0;\n    let sum = 0, count = 0;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) >= k) {\n            sum -= nums[left];\n            left++;\n        }\n        count += right - left + 1;\n        right++;\n    }\n\n    return count;\n}\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    "
    },
    {
        "id": 2062,
        "title": "Calculate Amount Paid in Taxes",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `brackets` where `brackets[i] = [upperi, percenti]` means that the `ith` tax bracket has an upper bound of `upperi` and is taxed at a rate of `percenti`. The brackets are **sorted** by upper bound (i.e. `upperi-1 < upperi` for `0 < i < brackets.length`).\n\nTax is calculated as follows:\n\n*   The first `upper0` dollars earned are taxed at a rate of `percent0`.\n*   The next `upper1 - upper0` dollars earned are taxed at a rate of `percent1`.\n*   The next `upper2 - upper1` dollars earned are taxed at a rate of `percent2`.\n*   And so on.\n\nYou are given an integer `income` representing the amount of money you earned. Return _the amount of money that you have to pay in taxes._ Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** brackets = \\[\\[3,50\\],\\[7,10\\],\\[12,25\\]\\], income = 10\n**Output:** 2.65000\n**Explanation:**\nBased on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.\nThe tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.\nIn total, you pay $3 \\* 50% + $4 \\* 10% + $3 \\* 25% = $2.65 in taxes.\n\n",
                "**Example 2:**\n\n**Input:** brackets = \\[\\[1,0\\],\\[4,25\\],\\[5,50\\]\\], income = 2\n**Output:** 0.25000\n**Explanation:**\nBased on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket.\nThe tax rate for the two tax brackets is 0% and 25%, respectively.\nIn total, you pay $1 \\* 0% + $1 \\* 25% = $0.25 in taxes.\n\n",
                "**Example 3:**\n\n**Input:** brackets = \\[\\[2,50\\]\\], income = 0\n**Output:** 0.00000\n**Explanation:**\nYou have no income to tax, so you have to pay a total of $0 in taxes."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= brackets.length <= 100`\n*   `1 <= upperi <= 1000`\n*   `0 <= percenti <= 100`\n*   `0 <= income <= 1000`\n*   `upperi` is sorted in ascending order.\n*   All the values of `upperi` are **unique**.\n*   The upper bound of the last tax bracket is greater than or equal to `income`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[3,50],[7,10],[12,25]],10",
                "output": "2.65000"
            },
            {
                "input": "[[1,0],[4,25],[5,50]],2",
                "output": "0.25000"
            },
            {
                "input": "[[2,50]],0",
                "output": "0.00000"
            }
        ],
        "java": "\n    ```java\ndouble taxAmount(int[][] brackets, int income) {\n    double tax = 0;\n    int prev_upper = 0;\n    for (int[] bracket : brackets) {\n        int upper = bracket[0];\n        double percent = bracket[1] / 100.0;\n        tax += (Math.min(upper, income) - prev_upper) * percent;\n        prev_upper = upper;\n        if (income <= upper) break;\n    }\n    return tax;\n}\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    ",
        "python": "\n    ```python\ndef tax_amount(brackets, income):\n    tax = 0\n    prev_upper = 0\n    for upper, percent in brackets:\n        tax += (min(upper, income) - prev_upper) * (percent / 100)\n        prev_upper = upper\n        if income <= upper:\n            break\n    return tax\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    ",
        "c++": "\n    ```cpp\ndouble taxAmount(vector<vector<int>>& brackets, int income) {\n    double tax = 0;\n    int prev_upper = 0;\n    for (vector<int>& bracket : brackets) {\n        int upper = bracket[0];\n        double percent = bracket[1] / 100.0;\n        tax += (min(upper, income) - prev_upper) * percent;\n        prev_upper = upper;\n        if (income <= upper) break;\n    }\n    return tax;\n}\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    ",
        "js": "\n    ```javascript\nfunction taxAmount(brackets, income) {\n    let tax = 0;\n    let prev_upper = 0;\n    for (let bracket of brackets) {\n        let upper = bracket[0];\n        let percent = bracket[1] / 100;\n        tax += (Math.min(upper, income) - prev_upper) * percent;\n        prev_upper = upper;\n        if (income <= upper) break;\n    }\n    return tax;\n}\n```\n    \n    The algorithm loops through the tax brackets and calculates the tax for each segment. The tax amount for each segment is calculated as `(min(upper, income) - prev_upper) * percent`. We also need to keep track of the previous upper bound, which is why `prev_upper` is initialized to 0 and updated in each iteration. If the income is less than or equal to the current upper bound, we can break out of the loop as the remaining tax segments don't matter.\n\nThe time complexity of this algorithm is O(n), where n is the number of tax brackets.\n    "
    },
    {
        "id": 2104,
        "title": "First Letter to Appear Twice",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` consisting of lowercase English letters, return _the first letter to appear **twice**_.\n\n**Note**:\n\n*   A letter `a` appears twice before another letter `b` if the **second** occurrence of `a` is before the **second** occurrence of `b`.\n*   `s` will contain at least one letter that appears twice.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abccbaacz \"\n**Output:**  \"c \"\n**Explanation:**\nThe letter 'a' appears on the indexes 0, 5 and 6.\nThe letter 'b' appears on the indexes 1 and 4.\nThe letter 'c' appears on the indexes 2, 3 and 7.\nThe letter 'z' appears on the index 8.\nThe letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdd \"\n**Output:**  \"d \"\n**Explanation:**\nThe only letter that appears twice is 'd' so we return 'd'."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 100`\n*   `s` consists of lowercase English letters.\n*   `s` has at least one repeated letter.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Counting"
        ],
        "example": [
            {
                "input": "\"abccbaacz\"",
                "output": "\"c\""
            },
            {
                "input": "\"abcdd\"",
                "output": "\"d\""
            }
        ],
        "java": "\n    ```java\npublic char firstLetterToAppearTwice(String s) {\n    int[] occurrences = new int[26];\n    for (char c : s.toCharArray()) {\n        occurrences[c - 'a']++;\n        if (occurrences[c - 'a'] == 2) {\n            return c;\n        }\n    }\n    return '?';\n}\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    ",
        "python": "\n    ```python\ndef first_letter_to_appear_twice(s: str) -> str:\n    occurrences = [0] * 26\n    for c in s:\n        occurrences[ord(c) - ord('a')] += 1\n        if occurrences[ord(c) - ord('a')] == 2:\n            return c\n    return '?'\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    ",
        "c++": "\n    ```cpp\nchar firstLetterToAppearTwice(std::string s) {\n    std::array<int, 26> occurrences;\n    occurrences.fill(0);\n    for (char c : s) {\n        occurrences[c - 'a']++;\n        if (occurrences[c - 'a'] == 2) {\n            return c;\n        }\n    }\n    return '?';\n}\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    ",
        "js": "\n    ```javascript\nfunction firstLetterToAppearTwice(s) {\n    const occurrences = new Array(26).fill(0);\n    for (let c of s) {\n        occurrences[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        if (occurrences[c.charCodeAt(0) - 'a'.charCodeAt(0)] == 2) {\n            return c;\n        }\n    }\n    return '?';\n}\n```\n    \n    The solution in each programming language follows the same algorithm. First, we create an array to store the occurrences of each lowercase English letter. Then, we iterate through the given string, incrementing the count of the current character in the occurrences array. If an element in the occurrences array reaches 2, that means we've found a letter that appears twice, so we return that letter.\n    "
    },
    {
        "id": 2112,
        "title": "Longest Cycle in a Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.\n\nReturn _the length of the **longest** cycle in the graph_. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the **same** node.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[3,3,4,2,3\\]\n**Output:** 3\n**Explanation:** The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[2,-1,3,1\\]\n**Output:** -1\n**Explanation:** There are no cycles in this graph."
            ],
            "constraints": "**Constraints:**\n\n*   `n == edges.length`\n*   `2 <= n <= 105`\n*   `-1 <= edges[i] < n`\n*   `edges[i] != i`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "[3,3,4,2,3]",
                "output": "3"
            },
            {
                "input": "[2,-1,3,1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findLongestCycle(int[] edges) {\n    int n = edges.length;\n    boolean[] visited = new boolean[n];\n    int longest_cycle = -1;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int length = 0;\n            int node = i;\n\n            while (!visited[node] && edges[node] != -1) {\n                visited[node] = true;\n                length++;\n                node = edges[node];\n            }\n\n            if (edges[node] == i) {\n                longest_cycle = Math.max(longest_cycle, length);\n            }\n        }\n    }\n\n    return longest_cycle;\n}\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    ",
        "python": "\n    ```python\ndef findLongestCycle(edges):\n    n = len(edges)\n    visited = [False] * n\n    longest_cycle = -1\n\n    for i in range(n):\n        if not visited[i]:\n            length = 0\n            node = i\n\n            while not visited[node] and edges[node] != -1:\n                visited[node] = True\n                length += 1\n                node = edges[node]\n\n            if edges[node] == i:\n                longest_cycle = max(longest_cycle, length)\n\n    return longest_cycle\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    ",
        "c++": "\n    ```cpp\nint findLongestCycle(vector<int>& edges) {\n    int n = edges.size();\n    vector<bool> visited(n, false);\n    int longest_cycle = -1;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int length = 0;\n            int node = i;\n\n            while (!visited[node] && edges[node] != -1) {\n                visited[node] = true;\n                length++;\n                node = edges[node];\n            }\n\n            if (edges[node] == i) {\n                longest_cycle = max(longest_cycle, length);\n            }\n        }\n    }\n\n    return longest_cycle;\n}\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    ",
        "js": "\n    ```javascript\nfunction findLongestCycle(edges) {\n    const n = edges.length;\n    const visited = new Array(n).fill(false);\n    let longest_cycle = -1;\n\n    for (let i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            let length = 0;\n            let node = i;\n\n            while (!visited[node] && edges[node] !== -1) {\n                visited[node] = true;\n                length++;\n                node = edges[node];\n            }\n\n            if (edges[node] === i) {\n                longest_cycle = Math.max(longest_cycle, length);\n            }\n        }\n    }\n\n    return longest_cycle;\n}\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    "
    },
    {
        "id": 2118,
        "title": "Number of Arithmetic Triplets",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed**, **strictly increasing** integer array `nums` and a positive integer `diff`. A triplet `(i, j, k)` is an **arithmetic triplet** if the following conditions are met:\n\n*   `i < j < k`,\n*   `nums[j] - nums[i] == diff`, and\n*   `nums[k] - nums[j] == diff`.\n\nReturn _the number of unique **arithmetic triplets**._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,4,6,7,10\\], diff = 3\n**Output:** 2\n**Explanation:**\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,8,9\\], diff = 2\n**Output:** 2\n**Explanation:**\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 200`\n*   `0 <= nums[i] <= 200`\n*   `1 <= diff <= 50`\n*   `nums` is **strictly** increasing.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[0,1,4,6,7,10],3",
                "output": "2"
            },
            {
                "input": "[4,5,6,7,8,9],2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countArithmeticTriplets(int[] nums, int diff) {\n    int count = 0;\n    HashMap<Integer, Integer> mp = new HashMap<>();\n    for (int num : nums) {\n        if (mp.containsKey(num - diff))\n            count += mp.get(num - diff);\n        mp.put(num, mp.getOrDefault(num, 0) + 1);\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    ",
        "python": "\n    ```python\ndef count_arithmetic_triplets(nums, diff):\n    count = 0\n    mp = {}\n    for num in nums:\n        if num - diff in mp:\n            count += mp[num - diff]\n        mp[num] = mp.get(num, 0) + 1\n    return count\n```\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    ",
        "c++": "\n    ```cpp\nint countArithmeticTriplets(vector<int> &nums, int diff) {\n    int count = 0;\n    unordered_map<int, int> mp;\n    for (int num : nums) {\n        if (mp.count(num - diff))\n            count += mp[num - diff];\n        mp[num]++;\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    ",
        "js": "\n    ```javascript\nfunction countArithmeticTriplets(nums, diff) {\n    let count = 0;\n    const mp = new Map();\n    for (const num of nums) {\n        if (mp.has(num - diff))\n            count += mp.get(num - diff);\n        mp.set(num, (mp.get(num) || 0) + 1);\n    }\n    return count;\n}\n```\n\n    \n    The algorithm uses a hashmap to store the number of occurrences of the elements in the given array. For each element, we check if the hashmap contains the element minus the given difference (i.e., `num - diff`). If it does, that means we have found a valid arithmetic triplet, so we increment the count by the number of occurrences of that element minus the difference. Finally, we update the number of occurrences of the current element in the hashmap. \n\nThis algorithm has a time complexity of O(n), where n is the size of the given array, since we iterate through the array once and perform lookups, insertions, and updates on the hashmap in constant time.\n\n\n    "
    },
    {
        "id": 2123,
        "title": "Largest Local Values in a Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `n x n` integer matrix `grid`.\n\nGenerate an integer matrix `maxLocal` of size `(n - 2) x (n - 2)` such that:\n\n*   `maxLocal[i][j]` is equal to the **largest** value of the `3 x 3` matrix in `grid` centered around row `i + 1` and column `j + 1`.\n\nIn other words, we want to find the largest value in every contiguous `3 x 3` matrix in `grid`.\n\nReturn _the generated matrix_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[9,9,8,1\\],\\[5,6,2,6\\],\\[8,2,6,4\\],\\[6,2,2,2\\]\\]\n**Output:** \\[\\[9,9\\],\\[8,6\\]\\]\n**Explanation:** The diagram above shows the original matrix and the generated matrix.\nNotice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1,1,1\\],\\[1,1,1,1,1\\],\\[1,1,2,1,1\\],\\[1,1,1,1,1\\],\\[1,1,1,1,1\\]\\]\n**Output:** \\[\\[2,2,2\\],\\[2,2,2\\],\\[2,2,2\\]\\]\n**Explanation:** Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid."
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `3 <= n <= 100`\n*   `1 <= grid[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]",
                "output": "[[9,9],[8,6]]"
            },
            {
                "input": "[[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]",
                "output": "[[2,2,2],[2,2,2],[2,2,2]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic ArrayList<ArrayList<Integer>> largestMatrix(int[][] grid) {\n    int n = grid.length;\n    ArrayList<ArrayList<Integer>> maxLocal = new ArrayList<>();\n\n    for (int i = 1; i < n - 1; ++i) {\n        maxLocal.add(new ArrayList<>());\n        for (int j = 1; j < n - 1; ++j) {\n            int max_val = grid[i - 1][j - 1];\n            for (int x = -1; x <= 1; ++x) {\n                for (int y = -1; y <= 1; ++y) {\n                    max_val = Math.max(max_val, grid[i + x][j + y]);\n                }\n            }\n            maxLocal.get(i - 1).add(max_val);\n        }\n    }\n\n    return maxLocal;\n}\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    ",
        "python": "\n    ```python\ndef largest_matrix(grid):\n    n = len(grid)\n    maxLocal = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            max_val = grid[i - 1][j - 1]\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    max_val = max(max_val, grid[i + x][j + y])\n            maxLocal[i - 1][j - 1] = max_val\n\n    return maxLocal\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> largestMatrix(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    std::vector<std::vector<int>> maxLocal(n - 2, std::vector<int>(n - 2));\n    \n    for (int i = 1; i < n - 1; ++i) {\n        for (int j = 1; j < n - 1; ++j) {\n            int max_val = grid[i - 1][j - 1];\n            for (int x = -1; x <= 1; ++x) {\n                for (int y = -1; y <= 1; ++y) {\n                    max_val = std::max(max_val, grid[i + x][j + y]);\n                }\n            }\n            maxLocal[i - 1][j - 1] = max_val;\n        }\n    }\n    \n    return maxLocal;\n}\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    ",
        "js": "\n    ```javascript\nfunction largestMatrix(grid) {\n    const n = grid.length;\n    const maxLocal = Array.from({ length: n - 2 }, () => Array(n - 2).fill(0));\n\n    for (let i = 1; i < n - 1; ++i) {\n        for (let j = 1; j < n - 1; ++j) {\n            let max_val = grid[i - 1][j - 1];\n            for (let x = -1; x <= 1; ++x) {\n                for (let y = -1; y <= 1; ++y) {\n                    max_val = Math.max(max_val, grid[i + x][j + y]);\n                }\n            }\n            maxLocal[i - 1][j - 1] = max_val;\n        }\n    }\n\n    return maxLocal;\n}\n```\n    \n    The algorithm iterates through each cell of the input grid, and for each cell, it considers the 3x3 submatrix centered around that cell. It finds the maximum value in that submatrix and saves it in the corresponding position in the maxLocal matrix. To obtain the largest value from the 3x3 submatrix, nested loops iterate through all positions of the submatrix, comparing the value of each position with a variable max_val, which is then updated with the largest value found. The generated maxLocal matrix is returned as the output.\n    "
    },
    {
        "id": 2129,
        "title": "Time Needed to Rearrange a Binary String",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a binary string `s`. In one second, **all** occurrences of `\"01 \"` are **simultaneously** replaced with `\"10 \"`. This process **repeats** until no occurrences of `\"01 \"` exist.\n\nReturn _the number of seconds needed to complete this process._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"0110101 \"\n**Output:** 4\n**Explanation:** \nAfter one second, s becomes  \"1011010 \".\nAfter another second, s becomes  \"1101100 \".\nAfter the third second, s becomes  \"1110100 \".\nAfter the fourth second, s becomes  \"1111000 \".\nNo occurrence of  \"01 \" exists any longer, and the process needed 4 seconds to complete,\nso we return 4.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"11100 \"\n**Output:** 0\n**Explanation:**\nNo occurrence of  \"01 \" exists in s, and the processes needed 0 seconds to complete,\nso we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'0'` or `'1'`.\n\n**",
            "follow_up": "Follow up:**\n\nCan you solve this problem in O(n) time complexity?"
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"0110101\"",
                "output": "4"
            },
            {
                "input": "\"11100\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint findSecondsToTransform(String s) {\n    int cnt0 = 0, cnt1 = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '0') cnt0++;\n        else cnt1++;\n    }\n    return Math.min(cnt0, cnt1);\n}\n```\n    \n    The minimum number of operations needed to complete the transformation is equal to the minimum of the count of '0's and the count of '1's in the given string `s`. We loop through the string and count the number of '0's and '1's. Finally, we simply return the minimum of the counts as the result.\n    ",
        "python": "\n    ```python\ndef find_seconds_to_transform(s: str) -> int:\n    cnt_0, cnt_1 = 0, 0\n    for c in s:\n        if c == '0': cnt_0 += 1\n        else: cnt_1 += 1\n    return min(cnt_0, cnt_1)\n```\n    \n    The minimum number of operations needed to complete the transformation is equal to the minimum of the count of '0's and the count of '1's in the given string `s`. We loop through the string and count the number of '0's and '1's. Finally, we simply return the minimum of the counts as the result.\n    ",
        "c++": "\n    ```cpp\nint find_seconds_to_transform(const std::string &s) {\n    int cnt_0 = 0, cnt_1 = 0;\n    for (char c : s) {\n        if (c == '0') cnt_0++;\n        else cnt_1++;\n    }\n    return std::min(cnt_0, cnt_1);\n}\n```\n    \n    The minimum number of operations needed to complete the transformation is equal to the minimum of the count of '0's and the count of '1's in the given string `s`. We loop through the string and count the number of '0's and '1's. Finally, we simply return the minimum of the counts as the result.\n    ",
        "js": "\n    ```javascript\nfunction findSecondsToTransform(s) {\n    let cnt0 = 0, cnt1 = 0;\n    for (let c of s) {\n        if (c === '0') cnt0++;\n        else cnt1++;\n    }\n    return Math.min(cnt0, cnt1);\n}\n```\n    \n    The minimum number of operations needed to complete the transformation is equal to the minimum of the count of '0's and the count of '1's in the given string `s`. We loop through the string and count the number of '0's and '1's. Finally, we simply return the minimum of the counts as the result.\n    "
    },
    {
        "id": 2136,
        "title": "Removing Stars From a String",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s`, which contains stars `*`.\n\nIn one operation, you can:\n\n*   Choose a star in `s`.\n*   Remove the closest **non-star** character to its **left**, as well as remove the star itself.\n\nReturn _the string after **all** stars have been removed_.\n\n**Note:**\n\n*   The input will be generated such that the operation is always possible.\n*   It can be shown that the resulting string will always be unique.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leet\\*\\*cod\\*e \"\n**Output:**  \"lecoe \"\n**Explanation:** Performing the removals from left to right:\n- The closest character to the 1st star is 't' in  \"lee**t**\\*\\*cod\\*e \". s becomes  \"lee\\*cod\\*e \".\n- The closest character to the 2nd star is 'e' in  \"le**e**\\*cod\\*e \". s becomes  \"lecod\\*e \".\n- The closest character to the 3rd star is 'd' in  \"leco**d**\\*e \". s becomes  \"lecoe \".\nThere are no more stars, so we return  \"lecoe \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"erase\\*\\*\\*\\*\\* \"\n**Output:**  \" \"\n**Explanation:** The entire string is removed, so we return an empty string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters and stars `*`.\n*   The operation above can be performed on `s`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack",
            "Simulation"
        ],
        "example": [
            {
                "input": "\"leet**cod*e\"",
                "output": "\"lecoe\""
            },
            {
                "input": "\"erase*****\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String removeStars(String s) {\n    StringBuilder result = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (c == '*') {\n            if (result.length() > 0) {\n                result.deleteCharAt(result.length() - 1);\n            }\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    For each character in the given string `s`, we iterate through the characters. If the character is a star, we remove the last character of the `result` only if `result` is not empty. Otherwise, we append the character to the `result`. Finally, we return the `result` as a string. This algorithm simulates the removal operation described in the question. Since we always remove characters that are closest to the stars, the order of operations does not matter, and the algorithm produces the unique possible output.\n    ",
        "python": "\n    ```python\ndef remove_stars(s: str) -> str:\n    result = []\n    for c in s:\n        if c == '*':\n            if result:\n                result.pop()\n        else:\n            result.append(c)\n    return ''.join(result)\n```\n\n    \n    For each character in the given string `s`, we iterate through the characters. If the character is a star, we remove the last character of the `result` only if `result` is not empty. Otherwise, we append the character to the `result`. Finally, we return the `result` as a string. This algorithm simulates the removal operation described in the question. Since we always remove characters that are closest to the stars, the order of operations does not matter, and the algorithm produces the unique possible output.\n    ",
        "c++": "\n    ```cpp\nstd::string removeStars(std::string s) {\n    std::string result;\n    int stars = 0;\n    for (char c : s) {\n        if (c == '*') {\n            if (!result.empty()) {\n                result.pop_back();\n            }\n        } else {\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n```\n\n    \n    For each character in the given string `s`, we iterate through the characters. If the character is a star, we remove the last character of the `result` only if `result` is not empty. Otherwise, we append the character to the `result`. Finally, we return the `result` as a string. This algorithm simulates the removal operation described in the question. Since we always remove characters that are closest to the stars, the order of operations does not matter, and the algorithm produces the unique possible output.\n    ",
        "js": "\n    ```javascript\nfunction removeStars(s) {\n    let result = [];\n    for (let c of s) {\n        if (c === '*') {\n            if (result.length > 0) {\n                result.pop();\n            }\n        } else {\n            result.push(c);\n        }\n    }\n    return result.join('');\n}\n```\n\n    \n    For each character in the given string `s`, we iterate through the characters. If the character is a star, we remove the last character of the `result` only if `result` is not empty. Otherwise, we append the character to the `result`. Finally, we return the `result` as a string. This algorithm simulates the removal operation described in the question. Since we always remove characters that are closest to the stars, the order of operations does not matter, and the algorithm produces the unique possible output.\n    "
    },
    {
        "id": 2149,
        "title": "Most Frequent Even Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the most frequent even element_.\n\nIf there is a tie, return the **smallest** one. If there is no such element, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,2,4,4,1\\]\n**Output:** 2\n**Explanation:**\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,4,4,9,2,4\\]\n**Output:** 4\n**Explanation:** 4 is the even element appears the most.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[29,47,21,41,13,37,25,7\\]\n**Output:** -1\n**Explanation:** There is no even element."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `0 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting"
        ],
        "example": [
            {
                "input": "[0,1,2,2,4,4,1]",
                "output": "2"
            },
            {
                "input": "[4,4,4,9,2,4]",
                "output": "4"
            },
            {
                "input": "[29,47,21,41,13,37,25,7]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int mostFrequentEven(int[] nums) {\n    Map<Integer, Integer> count = new HashMap<>();\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n    }\n    int maxCount = Integer.MIN_VALUE;\n    int mostFrequent = -1;\n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n        int num = entry.getKey();\n        int freq = entry.getValue();\n        if (freq > maxCount || (freq == maxCount && num < mostFrequent)) {\n            maxCount = freq;\n            mostFrequent = num;\n        }\n    }\n    return mostFrequent;\n}\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    ",
        "python": "\n    ```python\ndef most_frequent_even(nums):\n    count = {}\n    for num in nums:\n        if num % 2 == 0:\n            count[num] = count.get(num, 0) + 1\n    max_count = float('-inf')\n    most_frequent = -1\n    for num, freq in count.items():\n        if freq > max_count or (freq == max_count and num < most_frequent):\n            max_count = freq\n            most_frequent = num\n    return most_frequent\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    ",
        "c++": "\n    ```cpp\nint mostFrequentEven(vector<int>& nums) {\n    unordered_map<int, int> count;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            count[num]++;\n        }\n    }\n    int max_count = INT_MIN;\n    int most_frequent = -1;\n    for (auto& [num, freq] : count) {\n        if (freq > max_count || (freq == max_count && num < most_frequent)) {\n            max_count = freq;\n            most_frequent = num;\n        }\n    }\n    return most_frequent;\n}\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    ",
        "js": "\n    ```javascript\nfunction mostFrequentEven(nums) {\n    let count = {};\n    for (let num of nums) {\n        if (num % 2 === 0) {\n            count[num] = (count[num] || 0) + 1;\n        }\n    }\n    let maxCount = Number.MIN_SAFE_INTEGER;\n    let mostFrequent = -1;\n    for (let num in count) {\n        let freq = count[num];\n        if (freq > maxCount || (freq === maxCount && parseInt(num) < mostFrequent)) {\n            maxCount = freq;\n            mostFrequent = parseInt(num);\n        }\n    }\n    return mostFrequent;\n}\n```\n\n    \n    The algorithm uses a hash map to count the frequency of even numbers in the given array. The hash map is iterated and the even number with the highest frequency is stored as the most frequent. If there is a tie, the smaller number is chosen as the most frequent. If no even number is found, the algorithm returns -1.\n    "
    },
    {
        "id": 2150,
        "title": "Optimal Partition of String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, partition the string into one or more **substrings** such that the characters in each substring are **unique**. That is, no letter appears in a single substring more than **once**.\n\nReturn _the **minimum** number of substrings in such a partition._\n\nNote that each character should belong to exactly one substring in a partition.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abacaba \"\n**Output:** 4\n**Explanation:**\nTwo possible partitions are ( \"a \", \"ba \", \"cab \", \"a \") and ( \"ab \", \"a \", \"ca \", \"ba \").\nIt can be shown that 4 is the minimum number of substrings needed.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ssssss \"\n**Output:** 6\n**Explanation:**\nThe only valid partition is ( \"s \", \"s \", \"s \", \"s \", \"s \", \"s \")."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only English lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abacaba\"",
                "output": "4"
            },
            {
                "input": "\"ssssss\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\n\npublic int min_substrs(String s) {\n    HashSet<Character> seen = new HashSet<>();\n    int count = 0;\n    for (char c : s.toCharArray()) {\n        if (seen.contains(c)) {\n            count++;\n            seen.clear();\n        }\n        seen.add(c);\n    }\n    return count + (seen.isEmpty() ? 0 : 1);\n}\n```\n    \n    The algorithm iterates through the characters of the input string `s`. It uses a set `seen` to store the unique characters encountered so far in the current substring. When a character is found that already exists in the set, we increment the `count` and clear the set. This indicates that a new unique substring should start. \n\nAt the end, if there are still characters left in the `seen` set, it means there is one last unique substring, so we add 1 to the count.\n\nThe time complexity of this algorithm is O(N) where N is the length of the input string, since we iterate through the input string once, and set operations (add, clear, etc.) take constant time on average.\n    ",
        "python": "\n    ```python\ndef min_substrs(s: str) -> int:\n    seen = set()\n    count = 0\n    for c in s:\n        if c in seen:\n            count += 1\n            seen.clear()\n        seen.add(c)\n    return count + int(bool(seen))\n```\n    \n    The algorithm iterates through the characters of the input string `s`. It uses a set `seen` to store the unique characters encountered so far in the current substring. When a character is found that already exists in the set, we increment the `count` and clear the set. This indicates that a new unique substring should start. \n\nAt the end, if there are still characters left in the `seen` set, it means there is one last unique substring, so we add 1 to the count.\n\nThe time complexity of this algorithm is O(N) where N is the length of the input string, since we iterate through the input string once, and set operations (add, clear, etc.) take constant time on average.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint min_substrs(string s) {\n    unordered_set<char> seen;\n    int count = 0;\n    for (char c : s) {\n        if (seen.find(c) != seen.end()) {\n            count++;\n            seen.clear();\n        }\n        seen.insert(c);\n    }\n    return count + !seen.empty();\n}\n```\n    \n    The algorithm iterates through the characters of the input string `s`. It uses a set `seen` to store the unique characters encountered so far in the current substring. When a character is found that already exists in the set, we increment the `count` and clear the set. This indicates that a new unique substring should start. \n\nAt the end, if there are still characters left in the `seen` set, it means there is one last unique substring, so we add 1 to the count.\n\nThe time complexity of this algorithm is O(N) where N is the length of the input string, since we iterate through the input string once, and set operations (add, clear, etc.) take constant time on average.\n    ",
        "js": "\n    ```javascript\nfunction min_substrs(s) {\n    const seen = new Set();\n    let count = 0;\n    for (const c of s) {\n        if (seen.has(c)) {\n            count++;\n            seen.clear();\n        }\n        seen.add(c);\n    }\n    return count + (seen.size > 0 ? 1 : 0);\n}\n```\n    \n    The algorithm iterates through the characters of the input string `s`. It uses a set `seen` to store the unique characters encountered so far in the current substring. When a character is found that already exists in the set, we increment the `count` and clear the set. This indicates that a new unique substring should start. \n\nAt the end, if there are still characters left in the `seen` set, it means there is one last unique substring, so we add 1 to the count.\n\nThe time complexity of this algorithm is O(N) where N is the length of the input string, since we iterate through the input string once, and set operations (add, clear, etc.) take constant time on average.\n    "
    },
    {
        "id": 2155,
        "title": "Maximum Matching of Players With Trainers",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0-indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer.\n\nThe `ith` player can **match** with the `jth` trainer if the player's ability is **less than or equal to** the trainer's training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player.\n\nReturn _the **maximum** number of matchings between_ `players` _and_ `trainers` _that satisfy these conditions._",
            "examples": [
                "**Example 1:**\n\n**Input:** players = \\[4,7,9\\], trainers = \\[8,2,5,8\\]\n**Output:** 2\n**Explanation:**\nOne of the ways we can form two matchings is as follows:\n- players\\[0\\] can be matched with trainers\\[0\\] since 4 <= 8.\n- players\\[1\\] can be matched with trainers\\[3\\] since 7 <= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n\n",
                "**Example 2:**\n\n**Input:** players = \\[1,1,1\\], trainers = \\[10\\]\n**Output:** 1\n**Explanation:**\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= players.length, trainers.length <= 105`\n*   `1 <= players[i], trainers[j] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,7,9],[8,2,5,8]",
                "output": "2"
            },
            {
                "input": "[1,1,1],[10]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxMatchings(int[] players, int[] trainers) {\n    Arrays.sort(players);\n    Arrays.sort(trainers);\n\n    int playerIndex = 0, trainerIndex = 0, matchCount = 0;\n    while (playerIndex < players.length && trainerIndex < trainers.length) {\n        if (players[playerIndex] <= trainers[trainerIndex]) {\n            matchCount++;\n            playerIndex++;\n            trainerIndex++;\n        } else {\n            trainerIndex++;\n        }\n    }\n\n    return matchCount;\n}\n```\n\n    \n    1. Sort the `players` and `trainers` arrays in ascending order.\n2. Initialize variables `playerIndex`, `trainerIndex`, and `matchCount` to 0.\n3. Loop through the `players` and `trainers` arrays while `playerIndex` is less than the `players` length and `trainerIndex` is less than the `trainers` length.\n   a. If the current `player`'s ability is less than or equal to the current `trainer`'s training capacity, increase the `matchCount`, increment both `playerIndex` and `trainerIndex`.\n   b. If not, increment `trainerIndex` only.\n4. After the loop, the final `matchCount` value is the maximum number of matchings that satisfy the conditions.\n    ",
        "python": "\n    ```python\ndef max_matchings(players, trainers):\n    players.sort()\n    trainers.sort()\n\n    player_index, trainer_index, match_count = 0, 0, 0\n    while (player_index < len(players)) and (trainer_index < len(trainers)):\n        if players[player_index] <= trainers[trainer_index]:\n            match_count += 1\n            player_index += 1\n            trainer_index += 1\n        else:\n            trainer_index += 1\n\n    return match_count\n```\n\n    \n    1. Sort the `players` and `trainers` arrays in ascending order.\n2. Initialize variables `playerIndex`, `trainerIndex`, and `matchCount` to 0.\n3. Loop through the `players` and `trainers` arrays while `playerIndex` is less than the `players` length and `trainerIndex` is less than the `trainers` length.\n   a. If the current `player`'s ability is less than or equal to the current `trainer`'s training capacity, increase the `matchCount`, increment both `playerIndex` and `trainerIndex`.\n   b. If not, increment `trainerIndex` only.\n4. After the loop, the final `matchCount` value is the maximum number of matchings that satisfy the conditions.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxMatchings(std::vector<int>& players, std::vector<int>& trainers) {\n    std::sort(players.begin(), players.end());\n    std::sort(trainers.begin(), trainers.end());\n\n    int playerIndex = 0, trainerIndex = 0, matchCount = 0;\n    while (playerIndex < players.size() && trainerIndex < trainers.size()) {\n        if (players[playerIndex] <= trainers[trainerIndex]) {\n            matchCount++;\n            playerIndex++;\n            trainerIndex++;\n        } else {\n            trainerIndex++;\n        }\n    }\n    \n    return matchCount;\n}\n```\n\n    \n    1. Sort the `players` and `trainers` arrays in ascending order.\n2. Initialize variables `playerIndex`, `trainerIndex`, and `matchCount` to 0.\n3. Loop through the `players` and `trainers` arrays while `playerIndex` is less than the `players` length and `trainerIndex` is less than the `trainers` length.\n   a. If the current `player`'s ability is less than or equal to the current `trainer`'s training capacity, increase the `matchCount`, increment both `playerIndex` and `trainerIndex`.\n   b. If not, increment `trainerIndex` only.\n4. After the loop, the final `matchCount` value is the maximum number of matchings that satisfy the conditions.\n    ",
        "js": "\n    ```javascript\nfunction maxMatchings(players, trainers) {\n    players.sort((a, b) => a - b);\n    trainers.sort((a, b) => a - b);\n\n    let playerIndex = 0, trainerIndex = 0, matchCount = 0;\n    while (playerIndex < players.length && trainerIndex < trainers.length) {\n        if (players[playerIndex] <= trainers[trainerIndex]) {\n            matchCount++;\n            playerIndex++;\n            trainerIndex++;\n        } else {\n            trainerIndex++;\n        }\n    }\n\n    return matchCount;\n}\n```\n\n    \n    1. Sort the `players` and `trainers` arrays in ascending order.\n2. Initialize variables `playerIndex`, `trainerIndex`, and `matchCount` to 0.\n3. Loop through the `players` and `trainers` arrays while `playerIndex` is less than the `players` length and `trainerIndex` is less than the `trainers` length.\n   a. If the current `player`'s ability is less than or equal to the current `trainer`'s training capacity, increase the `matchCount`, increment both `playerIndex` and `trainerIndex`.\n   b. If not, increment `trainerIndex` only.\n4. After the loop, the final `matchCount` value is the maximum number of matchings that satisfy the conditions.\n    "
    },
    {
        "id": 2158,
        "title": "Smallest Even Multiple",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **positive** integer `n`, return _the smallest positive integer that is a multiple of **both**_ `2` _and_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 10\n**Explanation:** The smallest multiple of both 5 and 2 is 10.\n\n",
                "**Example 2:**\n\n**Input:** n = 6\n**Output:** 6\n**Explanation:** The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 150`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "5",
                "output": "10"
            },
            {
                "input": "6",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int smallestMultiple(int n) {\n    return n % 2 == 0 ? n : n * 2;\n}\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "python": "\n    ```python\ndef smallest_multiple(n):\n    return n if n % 2 == 0 else n * 2\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "c++": "\n    ```cpp\nint smallestMultiple(int n) {\n    return n % 2 == 0 ? n : n * 2;\n}\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    ",
        "js": "\n    ```javascript\nfunction smallestMultiple(n) {\n    return n % 2 === 0 ? n : n * 2;\n}\n```\n    \n    The algorithm to solve this problem is quite simple. The smallest positive integer that is a multiple of both 2 and `n` can be determined by checking if `n` is even or odd. If `n` is even, it means that it is already a multiple of 2, so the answer should be `n`. If `n` is odd, we need to multiply `n` by 2 to get the smallest multiple that is also divisible by 2, so the answer should be `n * 2`.\n    "
    },
    {
        "id": 2159,
        "title": "Length of the Longest Alphabetical Continuous Substring",
        "difficulty": "Medium",
        "content": {
            "problem": "An **alphabetical continuous string** is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string `\"abcdefghijklmnopqrstuvwxyz \"`.\n\n*   For example, `\"abc \"` is an alphabetical continuous string, while `\"acb \"` and `\"za \"` are not.\n\nGiven a string `s` consisting of lowercase letters only, return the _length of the **longest** alphabetical continuous substring._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abacaba \"\n**Output:** 2\n**Explanation:** There are 4 distinct continuous substrings:  \"a \",  \"b \",  \"c \" and  \"ab \".\n \"ab \" is the longest continuous substring.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcde \"\n**Output:** 5\n**Explanation:**  \"abcde \" is the longest continuous substring."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only English lowercase letters.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"abacaba\"",
                "output": "2"
            },
            {
                "input": "\"abcde\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int longestAlphabeticalContinuousSubstring(String s) {\n    int maxLength = 1, currentLength = 1;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s.charAt(i) == s.charAt(i - 1) + 1) {\n            ++currentLength;\n        } else {\n            maxLength = Math.max(maxLength, currentLength);\n            currentLength = 1;\n        }\n    }\n    return Math.max(maxLength, currentLength);\n}\n```\n    \n    1. Initialize two variables, `max_length` and `current_length` to keep track of the longest alphabetical continuous substring's length and the current alphabetical substring's length, respectively. Both are initially set to 1, as there is at least one character in the string.\n2. Iterate through the string from the second character to the end.\n3. Compare the current character and the previous character. If they are consecutive in the alphabet (i.e., the current character's Unicode code point is one greater than the previous character's code point), increment the current length.\n4. If they are not consecutive, update the maximum length by comparing it with the current length and reset the current length to 1.\n5. After finishing the loop, we need to compare the maximum length and the current length once more to make sure the last continuous substring is accounted for.\n6. Return the largest value between the two as the answer.\n    ",
        "python": "\n    ```python\ndef longest_alphabetical_continuous_substring(s: str) -> int:\n    max_length = current_length = 1\n    for i in range(1, len(s)):\n        if ord(s[i]) == ord(s[i - 1]) + 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    return max(max_length, current_length)\n```\n    \n    1. Initialize two variables, `max_length` and `current_length` to keep track of the longest alphabetical continuous substring's length and the current alphabetical substring's length, respectively. Both are initially set to 1, as there is at least one character in the string.\n2. Iterate through the string from the second character to the end.\n3. Compare the current character and the previous character. If they are consecutive in the alphabet (i.e., the current character's Unicode code point is one greater than the previous character's code point), increment the current length.\n4. If they are not consecutive, update the maximum length by comparing it with the current length and reset the current length to 1.\n5. After finishing the loop, we need to compare the maximum length and the current length once more to make sure the last continuous substring is accounted for.\n6. Return the largest value between the two as the answer.\n    ",
        "c++": "\n    ```cpp\nint longest_alphabetical_continuous_substring(string s) {\n    int max_length = 1, current_length = 1;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s[i] == s[i - 1] + 1) {\n            ++current_length;\n        } else {\n            max_length = max(max_length, current_length);\n            current_length = 1;\n        }\n    }\n    return max(max_length, current_length);\n}\n```\n    \n    1. Initialize two variables, `max_length` and `current_length` to keep track of the longest alphabetical continuous substring's length and the current alphabetical substring's length, respectively. Both are initially set to 1, as there is at least one character in the string.\n2. Iterate through the string from the second character to the end.\n3. Compare the current character and the previous character. If they are consecutive in the alphabet (i.e., the current character's Unicode code point is one greater than the previous character's code point), increment the current length.\n4. If they are not consecutive, update the maximum length by comparing it with the current length and reset the current length to 1.\n5. After finishing the loop, we need to compare the maximum length and the current length once more to make sure the last continuous substring is accounted for.\n6. Return the largest value between the two as the answer.\n    ",
        "js": "\n    ```javascript\nfunction longestAlphabeticalContinuousSubstring(s) {\n    let maxLength = 1, currentLength = 1;\n    for (let i = 1; i < s.length; ++i) {\n        if (s.charCodeAt(i) === s.charCodeAt(i - 1) + 1) {\n            ++currentLength;\n        } else {\n            maxLength = Math.max(maxLength, currentLength);\n            currentLength = 1;\n        }\n    }\n    return Math.max(maxLength, currentLength);\n}\n```\n    \n    1. Initialize two variables, `max_length` and `current_length` to keep track of the longest alphabetical continuous substring's length and the current alphabetical substring's length, respectively. Both are initially set to 1, as there is at least one character in the string.\n2. Iterate through the string from the second character to the end.\n3. Compare the current character and the previous character. If they are consecutive in the alphabet (i.e., the current character's Unicode code point is one greater than the previous character's code point), increment the current length.\n4. If they are not consecutive, update the maximum length by comparing it with the current length and reset the current length to 1.\n5. After finishing the loop, we need to compare the maximum length and the current length once more to make sure the last continuous substring is accounted for.\n6. Return the largest value between the two as the answer.\n    "
    },
    {
        "id": 2163,
        "title": "Sort the People",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of strings `names`, and an array `heights` that consists of **distinct** positive integers. Both arrays are of length `n`.\n\nFor each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person.\n\nReturn `names` _sorted in **descending** order by the people's heights_.",
            "examples": [
                "**Example 1:**\n\n**Input:** names = \\[ \"Mary \", \"John \", \"Emma \"\\], heights = \\[180,165,170\\]\n**Output:** \\[ \"Mary \", \"Emma \", \"John \"\\]\n**Explanation:** Mary is the tallest, followed by Emma and John.\n\n",
                "**Example 2:**\n\n**Input:** names = \\[ \"Alice \", \"Bob \", \"Bob \"\\], heights = \\[155,185,150\\]\n**Output:** \\[ \"Bob \", \"Alice \", \"Bob \"\\]\n**Explanation:** The first Bob is the tallest, followed by Alice and the second Bob."
            ],
            "constraints": "**Constraints:**\n\n*   `n == names.length == heights.length`\n*   `1 <= n <= 103`\n*   `1 <= names[i].length <= 20`\n*   `1 <= heights[i] <= 105`\n*   `names[i]` consists of lower and upper case English letters.\n*   All the values of `heights` are distinct.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "[\"Mary\",\"John\",\"Emma\"],[180,165,170]",
                "output": "[\"Mary\",\"Emma\",\"John\"]"
            },
            {
                "input": "[\"Alice\",\"Bob\",\"Bob\"],[155,185,150]",
                "output": "[\"Bob\",\"Alice\",\"Bob\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic List<String> sortNamesByHeight(String[] names, int[] heights) {\n    List<Pair> nameHeightPairs = new ArrayList<>();\n\n    for(int i = 0; i < names.length; i++) {\n        nameHeightPairs.add(new Pair(heights[i], names[i]));\n    }\n\n    nameHeightPairs.sort((a, b) -> b.height - a.height);\n\n    List<String> sortedNames = new ArrayList<>();\n    for(Pair pair : nameHeightPairs) {\n        sortedNames.add(pair.name);\n    }\n\n    return sortedNames;\n}\n\nclass Pair {\n    int height;\n    String name;\n\n    public Pair(int height, String name) {\n        this.height = height;\n        this.name = name;\n    }\n}\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "python": "\n    ```python\ndef sort_names_by_height(names, heights):\n    name_height_pairs = sorted(zip(heights, names), reverse=True)\n    sorted_names = [pair[1] for pair in name_height_pairs]\n    return sorted_names\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> sortNamesByHeight(std::vector<std::string>& names, std::vector<int>& heights) {\n    std::vector<std::pair<int, std::string>> name_height_pairs;\n\n    for(int i = 0; i < names.size(); i++) {\n        name_height_pairs.push_back(std::make_pair(heights[i], names[i]));\n    }\n\n    std::sort(name_height_pairs.rbegin(), name_height_pairs.rend());\n\n    std::vector<std::string> sorted_names;\n    for(auto& pair : name_height_pairs) {\n        sorted_names.push_back(pair.second);\n    }\n\n    return sorted_names;\n}\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    ",
        "js": "\n    ```javascript\nfunction sortNamesByHeight(names, heights) {\n    let nameHeightPairs = [];\n\n    for(let i = 0; i < names.length; i++) {\n        nameHeightPairs.push({name: names[i], height: heights[i]});\n    }\n\n    nameHeightPairs.sort((a, b) => b.height - a.height);\n\n    let sortedNames = nameHeightPairs.map(pair => pair.name);\n\n    return sortedNames;\n}\n```\n    \n    The algorithm starts by iterating through both input arrays (`names` and `heights`) to create an array ('name_height_pairs') of pairs (in other languages, objects with `height` and `name` properties) containing the heights and corresponding names.\n\nNext, the array of pairs is sorted in descending order (highest to lowest) based on the height values.\n\nFinally, a new array (`sorted_names`) is created containing only the names from the sorted pairs.\n\nThis process ensures that the names in the final array are sorted in descending order by the people's heights.\n    "
    },
    {
        "id": 2164,
        "title": "Longest Subarray With Maximum Bitwise AND",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` of size `n`.\n\nConsider a **non-empty** subarray from `nums` that has the **maximum** possible **bitwise AND**.\n\n*   In other words, let `k` be the maximum value of the bitwise AND of **any** subarray of `nums`. Then, only subarrays with a bitwise AND equal to `k` should be considered.\n\nReturn _the length of the **longest** such subarray_.\n\nThe bitwise AND of an array is the bitwise AND of all the numbers in it.\n\nA **subarray** is a contiguous sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,3,2,2\\]\n**Output:** 2\n**Explanation:**\nThe maximum possible bitwise AND of a subarray is 3.\nThe longest subarray with that value is \\[3,3\\], so we return 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:**\nThe maximum possible bitwise AND of a subarray is 4.\nThe longest subarray with that value is \\[4\\], so we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Brainteaser"
        ],
        "example": [
            {
                "input": "[1,2,3,3,2,2]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int longestSubarray(int[] nums) {\n    int max_and = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int temp_and = nums[i];\n        for (int j = i + 1; j < nums.length; j++) {\n            temp_and &= nums[j];\n            max_and = Math.max(max_and, temp_and);\n        }\n    }\n    \n    int longest_subarray = 0, current_length = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int temp_and = nums[i];\n        current_length = (temp_and == max_and) ? 1 : 0;\n        for (int j = i + 1; j < nums.length; j++) {\n            temp_and &= nums[j];\n            if (temp_and == max_and) {\n                current_length++;\n            } else {\n                break;\n            }\n        }\n        longest_subarray = Math.max(longest_subarray, current_length);\n    }\n    return longest_subarray;\n}\n```\n    \n    The algorithm first calculates the maximum possible bitwise AND for the given input. Then, it calculates the length of the longest subarray with that value. For each element, the algorithm checks if its bitwise AND with the next elements equals the maximum possible bitwise AND. If yes, the length of the current subarray is incremented, else the iteration for the current element is terminated. After comparing the length of each subarray, the algorithm returns the length of the longest such subarray.\n    ",
        "python": "\n    ```python\ndef longestSubarray(nums):\n    max_and = 0\n    for i in range(len(nums)):\n        temp_and = nums[i]\n        for j in range(i + 1, len(nums)):\n            temp_and &= nums[j]\n            max_and = max(max_and, temp_and)\n    \n    longest_subarray = 0\n    current_length = 0\n    for i in range(len(nums)):\n        temp_and = nums[i]\n        current_length = 1 if temp_and == max_and else 0\n        for j in range(i + 1, len(nums)):\n            temp_and &= nums[j];\n            if temp_and == max_and:\n                current_length += 1\n            else:\n                break\n        longest_subarray = max(longest_subarray, current_length)\n    return longest_subarray\n```\n    \n    The algorithm first calculates the maximum possible bitwise AND for the given input. Then, it calculates the length of the longest subarray with that value. For each element, the algorithm checks if its bitwise AND with the next elements equals the maximum possible bitwise AND. If yes, the length of the current subarray is incremented, else the iteration for the current element is terminated. After comparing the length of each subarray, the algorithm returns the length of the longest such subarray.\n    ",
        "c++": "\n    ```cpp\nint longestSubarray(vector<int>& nums) {\n    int max_and = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        int temp_and = nums[i];\n        for (int j = i + 1; j < nums.size(); j++) {\n            temp_and &= nums[j];\n            max_and = max(max_and, temp_and);\n        }\n    }\n    \n    int longest_subarray = 0, current_length = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        int temp_and = nums[i];\n        current_length = (temp_and == max_and) ? 1 : 0;\n        for (int j = i + 1; j < nums.size(); j++) {\n            temp_and &= nums[j];\n            if (temp_and == max_and) {\n                current_length++;\n            } else {\n                break;\n            }\n        }\n        longest_subarray = max(longest_subarray, current_length);\n    }\n    return longest_subarray;\n}\n```\n    \n    The algorithm first calculates the maximum possible bitwise AND for the given input. Then, it calculates the length of the longest subarray with that value. For each element, the algorithm checks if its bitwise AND with the next elements equals the maximum possible bitwise AND. If yes, the length of the current subarray is incremented, else the iteration for the current element is terminated. After comparing the length of each subarray, the algorithm returns the length of the longest such subarray.\n    ",
        "js": "\n    ```javascript\nfunction longestSubarray(nums) {\n    let max_and = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let temp_and = nums[i];\n        for (let j = i + 1; j < nums.length; j++) {\n            temp_and &= nums[j];\n            max_and = Math.max(max_and, temp_and);\n        }\n    }\n    \n    let longest_subarray = 0;\n    let current_length = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let temp_and = nums[i];\n        current_length = (temp_and === max_and) ? 1 : 0;\n        for (let j = i + 1; j < nums.length; j++) {\n            temp_and &= nums[j];\n            if (temp_and === max_and) {\n                current_length++;\n            } else {\n                break;\n            }\n        }\n        longest_subarray = Math.max(longest_subarray, current_length);\n    }\n    return longest_subarray;\n}\n```\n    \n    The algorithm first calculates the maximum possible bitwise AND for the given input. Then, it calculates the length of the longest subarray with that value. For each element, the algorithm checks if its bitwise AND with the next elements equals the maximum possible bitwise AND. If yes, the length of the current subarray is incremented, else the iteration for the current element is terminated. After comparing the length of each subarray, the algorithm returns the length of the longest such subarray.\n    "
    },
    {
        "id": 2167,
        "title": "Merge Operations to Turn Array Into a Palindrome",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `nums` consisting of **positive** integers.\n\nYou can perform the following operation on the array **any** number of times:\n\n*   Choose any two **adjacent** elements and **replace** them with their **sum**.\n    *   For example, if `nums = [1,2,3,1]`, you can apply one operation to make it `[1,5,1]`.\n\nReturn _the **minimum** number of operations needed to turn the array into a **palindrome**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,1,2,3,1\\]\n**Output:** 2\n**Explanation:** We can turn the array into a palindrome in 2 operations as follows:\n- Apply the operation on the fourth and fifth element of the array, nums becomes equal to \\[4,3,2,**3**,3,1\\].\n- Apply the operation on the fifth and sixth element of the array, nums becomes equal to \\[4,3,2,3,**4**\\].\nThe array \\[4,3,2,3,4\\] is a palindrome.\nIt can be shown that 2 is the minimum number of operations needed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 3\n**Explanation:** We do the operation 3 times in any position, we obtain the array \\[10\\] at the end which is a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,3,2,1,2,3,1]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int n = nums.length;\n    int i = 0, j = n - 1;\n    int operations = 0;\n\n    while (i < j) {\n        if (nums[i] == nums[j]) {\n            i++;\n            j--;\n        } else if (nums[i] < nums[j]) {\n            nums[i + 1] += nums[i];\n            i++;\n            operations++;\n        } else {\n            nums[j - 1] += nums[j];\n            j--;\n            operations++;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "python": "\n    ```python\ndef minOperations(nums):\n    n = len(nums)\n    i, j = 0, n - 1\n    operations = 0\n\n    while i < j:\n        if nums[i] == nums[j]:\n            i += 1\n            j -= 1\n        elif nums[i] < nums[j]:\n            nums[i + 1] += nums[i]\n            i += 1\n            operations += 1\n        else:\n            nums[j - 1] += nums[j]\n            j -= 1\n            operations += 1\n\n    return operations\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums) {\n    int n = nums.size();\n    int i = 0, j = n - 1;\n    int operations = 0;\n\n    while (i < j) {\n        if (nums[i] == nums[j]) {\n            i++;\n            j--;\n        } else if (nums[i] < nums[j]) {\n            nums[i + 1] += nums[i];\n            i++;\n            operations++;\n        } else {\n            nums[j - 1] += nums[j];\n            j--;\n            operations++;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    const n = nums.length;\n    let i = 0, j = n - 1;\n    let operations = 0;\n\n    while (i < j) {\n        if (nums[i] === nums[j]) {\n            i++;\n            j--;\n        } else if (nums[i] < nums[j]) {\n            nums[i + 1] += nums[i];\n            i++;\n            operations++;\n        } else {\n            nums[j - 1] += nums[j];\n            j--;\n            operations++;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    "
    },
    {
        "id": 2172,
        "title": "Number of Common Factors",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two positive integers `a` and `b`, return _the number of **common** factors of_ `a` _and_ `b`.\n\nAn integer `x` is a **common factor** of `a` and `b` if `x` divides both `a` and `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = 12, b = 6\n**Output:** 4\n**Explanation:** The common factors of 12 and 6 are 1, 2, 3, 6.\n\n",
                "**Example 2:**\n\n**Input:** a = 25, b = 30\n**Output:** 2\n**Explanation:** The common factors of 25 and 30 are 1, 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a, b <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration",
            "Number Theory"
        ],
        "example": [
            {
                "input": "12,6",
                "output": "4"
            },
            {
                "input": "25,30",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int commonFactors(int a, int b) {\n    int gcd = gcd(a, b);\n    int count = 0;\n    for (int i = 1; i * i <= gcd; i++) {\n        if (gcd % i == 0) {\n            count++;\n            if (i * i != gcd)\n                count++;\n        }\n    }\n    return count;\n}\n\nprivate int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    ",
        "python": "\n    ```python\ndef common_factors(a: int, b: int) -> int:\n    from math import gcd\n\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i * i != g:\n                count += 1\n    return count\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    ",
        "c++": "\n    ```cpp\nint commonFactors(int a, int b) {\n    int gcd = std::__gcd(a, b); \n    int count = 0;\n    for (int i = 1; i * i <= gcd; i++) {\n        if (gcd % i == 0) {\n            count++;\n            if (i * i != gcd)\n                count++;\n        }\n    }\n    return count;\n}\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    ",
        "js": "\n    ```javascript\nfunction commonFactors(a, b) {\n    let gcd = (a, b) => b === 0 ? a : gcd(b, a % b);\n    let g = gcd(a, b);\n    let count = 0;\n    for (let i = 1; i * i <= g; i++) {\n        if (g % i === 0) {\n            count++;\n            if (i * i !== g)\n                count++;\n        }\n    }\n    return count;\n}\n```\n    \n    1. First, we calculate the greatest common divisor (GCD) of the input integers `a` and `b` using the Euclidean algorithm.\n2. Next, we initialize a `count` variable to store the number of common factors.\n3. Then, we iterate through the numbers from 1 to the square root of the GCD.\n   - For each number `i` that is a factor of the GCD, we increment the `count`.\n   - If the square of `i` is not equal to the GCD, we increment the `count` again because there is another factor, which is `gcd // i`.\n4. Finally, we return the `count`.\n    "
    },
    {
        "id": 2173,
        "title": "Maximum Sum of an Hourglass",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` integer matrix `grid`.\n\nWe define an **hourglass** as a part of the matrix with the following form:\n\nReturn _the **maximum** sum of the elements of an hourglass_.\n\n**Note** that an hourglass cannot be rotated and must be entirely contained within the matrix.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[6,2,1,3\\],\\[4,2,1,5\\],\\[9,2,8,7\\],\\[4,1,2,9\\]\\]\n**Output:** 30\n**Explanation:** The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** 35\n**Explanation:** There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `3 <= m, n <= 150`\n*   `0 <= grid[i][j] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]",
                "output": "30"
            },
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                "output": "35"
            }
        ],
        "java": "\n    ```java\npublic int maxHourglassSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int maxSum = Integer.MIN_VALUE;\n    for(int i = 1; i < m - 1; ++i) {\n        for(int j = 1; j < n - 1; ++j) {\n            int sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\n                      + grid[i][j]\n                      + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\n            maxSum = Math.max(maxSum, sum);\n        }\n    }\n    return maxSum;\n}\n```\n\n    \n    The problem requires us to find the maximum sum of hourglasses in the given grid.\n\nWe first find the dimensions of the grid, m and n. We initialize maxSum as the smallest integer value possible (-inf for Python).\n\nSince the hourglass shape should be entirely contained within the grid, we start our traversal from (1,1), i.e., one cell shifted right and down from the top-left corner of the grid, continuing until (m-2, n-2). Both these indices are included in the traversal.\n\nIn the nested for loop, we calculate the hourglass sum for each cell by adding the values of its hourglass pattern: three cells horizontally from the cell above it, the cell itself, and three cells horizontally from the cell below it. We then compare the calculated sum with the current maxSum, keeping the larger value as the new maxSum.\n\nFinally, we return the maxSum after traversing the entire grid.\n    ",
        "python": "\n    ```python\ndef max_hourglass_sum(grid):\n    m, n = len(grid), len(grid[0])\n    max_sum = float('-inf')\n    for i in range(1, m - 1):\n        for j in range(1, n - 1):\n            sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] \\\n                  + grid[i][j] \\\n                  + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, sum)\n    return max_sum\n```\n\n    \n    The problem requires us to find the maximum sum of hourglasses in the given grid.\n\nWe first find the dimensions of the grid, m and n. We initialize maxSum as the smallest integer value possible (-inf for Python).\n\nSince the hourglass shape should be entirely contained within the grid, we start our traversal from (1,1), i.e., one cell shifted right and down from the top-left corner of the grid, continuing until (m-2, n-2). Both these indices are included in the traversal.\n\nIn the nested for loop, we calculate the hourglass sum for each cell by adding the values of its hourglass pattern: three cells horizontally from the cell above it, the cell itself, and three cells horizontally from the cell below it. We then compare the calculated sum with the current maxSum, keeping the larger value as the new maxSum.\n\nFinally, we return the maxSum after traversing the entire grid.\n    ",
        "c++": "\n    ```cpp\nint maxHourglassSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    int maxSum = INT_MIN;\n    for(int i = 1; i < m - 1; ++i) {\n        for(int j = 1; j < n - 1; ++j) {\n            int sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\n                      + grid[i][j]\n                      + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\n            maxSum = max(maxSum, sum);\n        }\n    }\n    return maxSum;\n}\n```\n\n    \n    The problem requires us to find the maximum sum of hourglasses in the given grid.\n\nWe first find the dimensions of the grid, m and n. We initialize maxSum as the smallest integer value possible (-inf for Python).\n\nSince the hourglass shape should be entirely contained within the grid, we start our traversal from (1,1), i.e., one cell shifted right and down from the top-left corner of the grid, continuing until (m-2, n-2). Both these indices are included in the traversal.\n\nIn the nested for loop, we calculate the hourglass sum for each cell by adding the values of its hourglass pattern: three cells horizontally from the cell above it, the cell itself, and three cells horizontally from the cell below it. We then compare the calculated sum with the current maxSum, keeping the larger value as the new maxSum.\n\nFinally, we return the maxSum after traversing the entire grid.\n    ",
        "js": "\n    ```javascript\nfunction maxHourglassSum(grid) {\n    let m = grid.length, n = grid[0].length;\n    let maxSum = -Infinity;\n    for(let i = 1; i < m - 1; ++i) {\n        for(let j = 1; j < n - 1; ++j) {\n            let sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1]\n                      + grid[i][j]\n                      + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1];\n            maxSum = Math.max(maxSum, sum);\n        }\n    }\n    return maxSum;\n}\n```\n\n    \n    The problem requires us to find the maximum sum of hourglasses in the given grid.\n\nWe first find the dimensions of the grid, m and n. We initialize maxSum as the smallest integer value possible (-inf for Python).\n\nSince the hourglass shape should be entirely contained within the grid, we start our traversal from (1,1), i.e., one cell shifted right and down from the top-left corner of the grid, continuing until (m-2, n-2). Both these indices are included in the traversal.\n\nIn the nested for loop, we calculate the hourglass sum for each cell by adding the values of its hourglass pattern: three cells horizontally from the cell above it, the cell itself, and three cells horizontally from the cell below it. We then compare the calculated sum with the current maxSum, keeping the larger value as the new maxSum.\n\nFinally, we return the maxSum after traversing the entire grid.\n    "
    },
    {
        "id": 2177,
        "title": "Find The Original Array of Prefix Xor",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an **integer** array `pref` of size `n`. Find and return _the array_ `arr` _of size_ `n` _that satisfies_:\n\n*   `pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]`.\n\nNote that `^` denotes the **bitwise-xor** operation.\n\nIt can be proven that the answer is **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** pref = \\[5,2,0,3,1\\]\n**Output:** \\[5,7,2,3,2\\]\n**Explanation:** From the array \\[5,7,2,3,2\\] we have the following:\n- pref\\[0\\] = 5.\n- pref\\[1\\] = 5 ^ 7 = 2.\n- pref\\[2\\] = 5 ^ 7 ^ 2 = 0.\n- pref\\[3\\] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref\\[4\\] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n",
                "**Example 2:**\n\n**Input:** pref = \\[13\\]\n**Output:** \\[13\\]\n**Explanation:** We have pref\\[0\\] = arr\\[0\\] = 13."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pref.length <= 105`\n*   `0 <= pref[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[5,2,0,3,1]",
                "output": "[5,7,2,3,2]"
            },
            {
                "input": "[13]",
                "output": "[13]"
            }
        ],
        "java": "\n    ```java\npublic int[] findArray(int[] pref) {\n    int[] arr = new int[pref.length];\n    arr[0] = pref[0];\n    for (int i = 1; i < pref.length; ++i) {\n        arr[i] = pref[i] ^ pref[i - 1];\n    }\n    return arr;\n}\n```\n    \n    The function first initializes the first element of the `arr` array to the first element of the input `pref` array. Then, for each remaining element in the `pref` array, the function calculates the corresponding `arr` element by XORing the current `pref` element with the previous `pref` element. This is based on the property of XOR, where `(a ^ b) ^ b == a`. After all elements in the `arr` array are calculated, the function returns the `arr` array.\n    ",
        "python": "\n    ```python\ndef findArray(pref):\n    arr = [pref[0]]\n    for i in range(1, len(pref)):\n        arr.append(pref[i] ^ pref[i - 1])\n    return arr\n```\n    \n    The function first initializes the first element of the `arr` array to the first element of the input `pref` array. Then, for each remaining element in the `pref` array, the function calculates the corresponding `arr` element by XORing the current `pref` element with the previous `pref` element. This is based on the property of XOR, where `(a ^ b) ^ b == a`. After all elements in the `arr` array are calculated, the function returns the `arr` array.\n    ",
        "c++": "\n    ```cpp\nvector<int> findArray(vector<int>& pref) {\n    vector<int> arr(pref.size());\n    arr[0] = pref[0];\n    for (int i = 1; i < pref.size(); ++i) {\n        arr[i] = pref[i] ^ pref[i - 1];\n    }\n    return arr;\n}\n```\n    \n    The function first initializes the first element of the `arr` array to the first element of the input `pref` array. Then, for each remaining element in the `pref` array, the function calculates the corresponding `arr` element by XORing the current `pref` element with the previous `pref` element. This is based on the property of XOR, where `(a ^ b) ^ b == a`. After all elements in the `arr` array are calculated, the function returns the `arr` array.\n    ",
        "js": "\n    ```javascript\nfunction findArray(pref) {\n    const arr = new Array(pref.length);\n    arr[0] = pref[0];\n    for (let i = 1; i < pref.length; ++i) {\n        arr[i] = pref[i] ^ pref[i - 1];\n    }\n    return arr;\n}\n```\n    \n    The function first initializes the first element of the `arr` array to the first element of the input `pref` array. Then, for each remaining element in the `pref` array, the function calculates the corresponding `arr` element by XORing the current `pref` element with the previous `pref` element. This is based on the property of XOR, where `(a ^ b) ^ b == a`. After all elements in the `arr` array are calculated, the function returns the `arr` array.\n    "
    },
    {
        "id": 2185,
        "title": "Count Number of Distinct Integers After Reverse Operations",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `nums` consisting of **positive** integers.\n\nYou have to take each integer in the array, **reverse its digits**, and add it to the end of the array. You should apply this operation to the original integers in `nums`.\n\nReturn _the number of **distinct** integers in the final array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,13,10,12,31\\]\n**Output:** 6\n**Explanation:** After including the reverse of each number, the resulting array is \\[1,13,10,12,31,1,31,1,21,13\\].\nThe reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1.\nThe number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2\\]\n**Output:** 1\n**Explanation:** After including the reverse of each number, the resulting array is \\[2,2,2,2,2,2\\].\nThe number of distinct integers in this array is 1 (The number 2)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,13,10,12,31]",
                "output": "6"
            },
            {
                "input": "[2,2,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int distinctIntegersAfterReversingAndAdding(int[] nums) {\n    Set<Integer> distinct = new HashSet<>();\n    for (int num : nums) {\n        distinct.add(num);\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n        distinct.add(reversed);\n    }\n    return distinct.size();\n}\n```\n    \n    The algorithm first initializes a set `distinct` to keep track of distinct integers in the final array. It then iterates through each integer `num` in the `nums` array, adds the integer `num` to the `distinct` set, and calculates the reversed integer by reversing the digits of `num`. The reversed integer is also added to the `distinct` set. Finally, the algorithm returns the size of the `distinct` set, which represents the number of distinct integers in the final array. The time complexity is O(n) where n is the size of the `nums` array.\n    ",
        "python": "\n    ```python\ndef distinct_integers_after_reversing_and_adding(nums):\n    distinct = set(nums)\n    for num in nums:\n        reversed_num = int(str(num)[::-1])\n        distinct.add(reversed_num)\n    return len(distinct)\n```\n    \n    The algorithm first initializes a set `distinct` to keep track of distinct integers in the final array. It then iterates through each integer `num` in the `nums` array, adds the integer `num` to the `distinct` set, and calculates the reversed integer by reversing the digits of `num`. The reversed integer is also added to the `distinct` set. Finally, the algorithm returns the size of the `distinct` set, which represents the number of distinct integers in the final array. The time complexity is O(n) where n is the size of the `nums` array.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n#include <vector>\n\nint distinctIntegersAfterReversingAndAdding(const std::vector<int>& nums) {\n    std::set<int> distinct;\n    for (int num : nums) {\n        distinct.insert(num);\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n        distinct.insert(reversed);\n    }\n    return distinct.size();\n}\n```\n    \n    The algorithm first initializes a set `distinct` to keep track of distinct integers in the final array. It then iterates through each integer `num` in the `nums` array, adds the integer `num` to the `distinct` set, and calculates the reversed integer by reversing the digits of `num`. The reversed integer is also added to the `distinct` set. Finally, the algorithm returns the size of the `distinct` set, which represents the number of distinct integers in the final array. The time complexity is O(n) where n is the size of the `nums` array.\n    ",
        "js": "\n    ```javascript\nfunction distinctIntegersAfterReversingAndAdding(nums) {\n    let distinct = new Set(nums);\n    nums.forEach(num => {\n        let reversed = parseInt(num.toString().split('').reverse().join(''));\n        distinct.add(reversed);\n    });\n    return distinct.size;\n}\n```\n    \n    The algorithm first initializes a set `distinct` to keep track of distinct integers in the final array. It then iterates through each integer `num` in the `nums` array, adds the integer `num` to the `distinct` set, and calculates the reversed integer by reversing the digits of `num`. The reversed integer is also added to the `distinct` set. Finally, the algorithm returns the size of the `distinct` set, which represents the number of distinct integers in the final array. The time complexity is O(n) where n is the size of the `nums` array.\n    "
    },
    {
        "id": 2198,
        "title": "Average Value of Even Numbers That Are Divisible by Three",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` of **positive** integers, return _the average value of all even integers that are divisible by_ `3`_._\n\nNote that the **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,6,10,12,15\\]\n**Output:** 9\n**Explanation:** 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,4,7,10\\]\n**Output:** 0\n**Explanation:** There is no single number that satisfies the requirement, so return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,3,6,10,12,15]",
                "output": "9"
            },
            {
                "input": "[1,2,4,7,10]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int averageEvenDivisibleByThree(int[] nums) {\n    int sum = 0;\n    int count = 0;\n    for (int num : nums) {\n        if (num % 2 == 0 && num % 3 == 0) {\n            sum += num;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : sum / count;\n}\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "python": "\n    ```python\ndef average_even_divisible_by_three(nums):\n    total = 0\n    count = 0\n    for num in nums:\n        if num % 2 == 0 and num % 3 == 0:\n            total += num\n            count += 1\n    return total // count if count > 0 else 0\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "c++": "\n    ```cpp\nint averageEvenDivisibleByThree(const std::vector<int>& nums) {\n    int sum = 0;\n    int count = 0;\n    for (int num : nums) {\n        if (num % 2 == 0 && num % 3 == 0) {\n            sum += num;\n            count++;\n        }\n    }\n    return count == 0 ? 0 : sum / count;\n}\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    ",
        "js": "\n    ```javascript\nfunction averageEvenDivisibleByThree(nums) {\n    let sum = 0;\n    let count = 0;\n    for (let num of nums) {\n        if (num % 2 === 0 && num % 3 === 0) {\n            sum += num;\n            count++;\n        }\n    }\n    return count === 0 ? 0 : Math.floor(sum / count);\n}\n```\n    \n    The algorithm iterates through the input array, checking if an element is even (`num % 2 == 0`) and divisible by 3 (`num % 3 == 0`). If the element satisfies both conditions, it is added to the `sum` and the `count` is incremented. After the iteration, if `count` is greater than 0, the average is calculated by dividing the `sum` by `count`. The result is returned as an integer by rounding down the division result in all languages. If `count` is 0, meaning there were no elements that satisfied the conditions, the function returns 0.\n    "
    },
    {
        "id": 2204,
        "title": "Maximum Sum of Distinct Subarrays With Length K",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `k`. Find the maximum subarray sum of all the subarrays of `nums` that meet the following conditions:\n\n*   The length of the subarray is `k`, and\n*   All the elements of the subarray are **distinct**.\n\nReturn _the maximum subarray sum of all the subarrays that meet the conditions__._ If no subarray meets the conditions, return `0`.\n\n_A **subarray** is a contiguous non-empty sequence of elements within an array._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,5,4,2,9,9,9\\], k = 3\n**Output:** 15\n**Explanation:** The subarrays of nums with length 3 are:\n- \\[1,5,4\\] which meets the requirements and has a sum of 10.\n- \\[5,4,2\\] which meets the requirements and has a sum of 11.\n- \\[4,2,9\\] which meets the requirements and has a sum of 15.\n- \\[2,9,9\\] which does not meet the requirements because the element 9 is repeated.\n- \\[9,9,9\\] which does not meet the requirements because the element 9 is repeated.\nWe return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,4,4\\], k = 3\n**Output:** 0\n**Explanation:** The subarrays of nums with length 3 are:\n- \\[4,4,4\\] which does not meet the requirements because the element 4 is repeated.\nWe return 0 because no subarrays meet the conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[1,5,4,2,9,9,9],3",
                "output": "15"
            },
            {
                "input": "[4,4,4],3",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxSubarraySumWithDistinctElements(int[] nums, int k) {\n    int max_sum = 0, window_sum = 0;\n    HashMap<Integer, Integer> freq_map = new HashMap<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        freq_map.put(nums[i], freq_map.getOrDefault(nums[i], 0) + 1);\n        window_sum += nums[i];\n        if (i >= k) {\n            freq_map.put(nums[i - k], freq_map.get(nums[i - k]) - 1);\n            window_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            boolean is_distinct = true;\n            for (Integer value : freq_map.values()) {\n                if (value > 1) {\n                    is_distinct = false;\n                    break;\n                }\n            }\n            if (is_distinct) {\n                max_sum = Math.max(max_sum, window_sum);\n            }\n        }\n    }\n    return max_sum;\n}\n```\n    \n    For each language implementation, the algorithm works as follows:\n1. Initialize a frequency map to keep track of the number of occurrences of each element in the current window of `k` elements.\n2. Iterate through the `nums` array, updating the frequency map and current `window_sum` at each step.\n3. If the current index is greater than or equal to `k`, remove the oldest element from the frequency map and `window_sum` to maintain a sliding window of size `k`.\n4. If the current index is greater than or equal to `k - 1`, check if all elements in the sliding window are distinct by ensuring no values in the frequency map are greater than 1.\n5. If the elements in the sliding window are distinct, update `max_sum` to be the maximum of the current `max_sum` and `window_sum`.\n6. After iteration is complete, return the `max_sum`.\n\nThis algorithm runs in O(n) time complexity as we iterate through the `nums` array once, and it only checks the values of elements in the frequency map at each step. The space complexity is also O(n) since we may need to store a frequency map for all distinct elements in the `nums` array.\n    ",
        "python": "\n    ```python\ndef maxSubarraySumWithDistinctElements(nums: List[int], k: int) -> int:\n    max_sum = 0\n    window_sum = 0\n    freq_map = collections.defaultdict(int)\n    \n    for i, num in enumerate(nums):\n        freq_map[num] += 1\n        window_sum += num\n        if i >= k:\n            freq_map[nums[i - k]] -= 1\n            window_sum -= nums[i - k]\n        if i >= k - 1:\n            is_distinct = all(value <= 1 for value in freq_map.values())\n            if is_distinct:\n                max_sum = max(max_sum, window_sum)\n    \n    return max_sum\n```\n    \n    For each language implementation, the algorithm works as follows:\n1. Initialize a frequency map to keep track of the number of occurrences of each element in the current window of `k` elements.\n2. Iterate through the `nums` array, updating the frequency map and current `window_sum` at each step.\n3. If the current index is greater than or equal to `k`, remove the oldest element from the frequency map and `window_sum` to maintain a sliding window of size `k`.\n4. If the current index is greater than or equal to `k - 1`, check if all elements in the sliding window are distinct by ensuring no values in the frequency map are greater than 1.\n5. If the elements in the sliding window are distinct, update `max_sum` to be the maximum of the current `max_sum` and `window_sum`.\n6. After iteration is complete, return the `max_sum`.\n\nThis algorithm runs in O(n) time complexity as we iterate through the `nums` array once, and it only checks the values of elements in the frequency map at each step. The space complexity is also O(n) since we may need to store a frequency map for all distinct elements in the `nums` array.\n    ",
        "c++": "\n    ```cpp\nint maxSubarraySumWithDistinctElements(vector<int>& nums, int k) {\n    int max_sum = 0, window_sum = 0;\n    unordered_map<int, int> freq_map;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        freq_map[nums[i]]++;\n        window_sum += nums[i];\n        if (i >= k) {\n            freq_map[nums[i - k]]--;\n            window_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            bool is_distinct = true;\n            for (const auto& pair : freq_map) {\n                if (pair.second > 1) {\n                    is_distinct = false;\n                    break;\n                }\n            }\n            if (is_distinct) {\n                max_sum = max(max_sum, window_sum);\n            }\n        }\n    }\n    return max_sum;\n}\n```\n    \n    For each language implementation, the algorithm works as follows:\n1. Initialize a frequency map to keep track of the number of occurrences of each element in the current window of `k` elements.\n2. Iterate through the `nums` array, updating the frequency map and current `window_sum` at each step.\n3. If the current index is greater than or equal to `k`, remove the oldest element from the frequency map and `window_sum` to maintain a sliding window of size `k`.\n4. If the current index is greater than or equal to `k - 1`, check if all elements in the sliding window are distinct by ensuring no values in the frequency map are greater than 1.\n5. If the elements in the sliding window are distinct, update `max_sum` to be the maximum of the current `max_sum` and `window_sum`.\n6. After iteration is complete, return the `max_sum`.\n\nThis algorithm runs in O(n) time complexity as we iterate through the `nums` array once, and it only checks the values of elements in the frequency map at each step. The space complexity is also O(n) since we may need to store a frequency map for all distinct elements in the `nums` array.\n    ",
        "js": "\n    ```javascript\nfunction maxSubarraySumWithDistinctElements(nums, k) {\n    let max_sum = 0, window_sum = 0;\n    let freq_map = new Map();\n    \n    for (let i = 0; i < nums.length; i++) {\n        freq_map.set(nums[i], (freq_map.get(nums[i]) || 0) + 1);\n        window_sum += nums[i];\n        if (i >= k) {\n            freq_map.set(nums[i - k], freq_map.get(nums[i - k]) - 1);\n            window_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            let is_distinct = true;\n            for (let value of freq_map.values()) {\n                if (value > 1) {\n                    is_distinct = false;\n                    break;\n                }\n            }\n            if (is_distinct) {\n                max_sum = Math.max(max_sum, window_sum);\n            }\n        }\n    }\n    return max_sum;\n}\n```\n    \n    For each language implementation, the algorithm works as follows:\n1. Initialize a frequency map to keep track of the number of occurrences of each element in the current window of `k` elements.\n2. Iterate through the `nums` array, updating the frequency map and current `window_sum` at each step.\n3. If the current index is greater than or equal to `k`, remove the oldest element from the frequency map and `window_sum` to maintain a sliding window of size `k`.\n4. If the current index is greater than or equal to `k - 1`, check if all elements in the sliding window are distinct by ensuring no values in the frequency map are greater than 1.\n5. If the elements in the sliding window are distinct, update `max_sum` to be the maximum of the current `max_sum` and `window_sum`.\n6. After iteration is complete, return the `max_sum`.\n\nThis algorithm runs in O(n) time complexity as we iterate through the `nums` array once, and it only checks the values of elements in the frequency map at each step. The space complexity is also O(n) since we may need to store a frequency map for all distinct elements in the `nums` array.\n    "
    },
    {
        "id": 2212,
        "title": "Convert the Temperature",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a non-negative floating point number rounded to two decimal places `celsius`, that denotes the **temperature in Celsius**.\n\nYou should convert Celsius into **Kelvin** and **Fahrenheit** and return it as an array `ans = [kelvin, fahrenheit]`.\n\nReturn _the array `ans`._ Answers within `10-5` of the actual answer will be accepted.\n\n**Note that:**\n\n*   `Kelvin = Celsius + 273.15`\n*   `Fahrenheit = Celsius * 1.80 + 32.00`",
            "examples": [
                "**Example 1:**\n\n**Input:** celsius = 36.50\n**Output:** \\[309.65000,97.70000\\]\n**Explanation:** Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.\n\n",
                "**Example 2:**\n\n**Input:** celsius = 122.11\n**Output:** \\[395.26000,251.79800\\]\n**Explanation:** Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= celsius <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "36.50",
                "output": "[309.65000,97.70000]"
            },
            {
                "input": "122.11",
                "output": "[395.26000,251.79800]"
            }
        ],
        "java": "\n    ```java\npublic double[] convertTemperature(double celsius) {\n    double kelvin = celsius + 273.15;\n    double fahrenheit = celsius * 1.80 + 32.00;\n    return new double[]{kelvin, fahrenheit};\n}\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    ",
        "python": "\n    ```python\ndef convert_temperature(celsius):\n    kelvin = celsius + 273.15\n    fahrenheit = celsius * 1.8 + 32\n    return [kelvin, fahrenheit]\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<double> convertTemperature(double celsius) {\n    double kelvin = celsius + 273.15;\n    double fahrenheit = celsius * 1.80 + 32.00;\n    return {kelvin, fahrenheit};\n}\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    ",
        "js": "\n    ```javascript\nfunction convertTemperature(celsius) {\n    const kelvin = celsius + 273.15;\n    const fahrenheit = celsius * 1.80 + 32.00;\n    return [kelvin, fahrenheit];\n}\n```\n    \n    The algorithm is quite simple. First, we calculate and store the temperature value in Kelvin by adding 273.15 to the given Celsius value. Next, we calculate the Fahrenheit value by multiplying the Celsius value by 1.8 and adding 32. Finally, we return an array with the calculated Kelvin and Fahrenheit values.\n    "
    },
    {
        "id": 2217,
        "title": "Number of Unequal Triplets in Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** array of positive integers `nums`. Find the number of triplets `(i, j, k)` that meet the following conditions:\n\n*   `0 <= i < j < k < nums.length`\n*   `nums[i]`, `nums[j]`, and `nums[k]` are **pairwise distinct**.\n    *   In other words, `nums[i] != nums[j]`, `nums[i] != nums[k]`, and `nums[j] != nums[k]`.\n\nReturn _the number of triplets that meet the conditions._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,4,2,4,3\\]\n**Output:** 3\n**Explanation:** The following triplets meet the conditions:\n- (0, 2, 4) because 4 != 2 != 3\n- (1, 2, 4) because 4 != 2 != 3\n- (2, 3, 4) because 2 != 4 != 3\nSince there are 3 triplets, we return 3.\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,1\\]\n**Output:** 0\n**Explanation:** No triplets meet the conditions so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 100`\n*   `1 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting"
        ],
        "example": [
            {
                "input": "[4,4,2,4,3]",
                "output": "3"
            },
            {
                "input": "[1,1,1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countTriplets(int[] nums) {\n    int count = 0;\n    int n = nums.length;\n\n    for(int i = 0; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n            for(int k = j + 1; k < n; k++) {\n                if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    ",
        "python": "\n    ```python\ndef countTriplets(nums):\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                    count += 1\n    \n    return count\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    ",
        "c++": "\n    ```cpp\nint countTriplets(vector<int>& nums) {\n    int count = 0;\n    int n = nums.size();\n    \n    for(int i = 0; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n            for(int k = j + 1; k < n; k++) {\n                if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    ",
        "js": "\n    ```javascript\nfunction countTriplets(nums) {\n    let count = 0;\n    let n = nums.length;\n\n    for(let i = 0; i < n; i++) {\n        for(let j = i + 1; j < n; j++) {\n            for(let k = j + 1; k < n; k++) {\n                if(nums[i] !== nums[j] && nums[i] !== nums[k] && nums[j] !== nums[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```\n    \n    The given problem can be solved by iterating over each possible triplet (i, j, k), with the range 0 <= i < j < k < nums.length, and checking if the elements at indices i, j, and k are distinct. The algorithm runs in O(n^3) time due to the nested loops, where n is the size of the input array. If the elements at i, j, and k are distinct, we increment the count by 1. Finally, we return the total count of the triplets after iterating through all possible combinations.\n\nThe algorithm remains the same across all languages; the only difference is the syntax in each language.\n    "
    },
    {
        "id": 2223,
        "title": "Difference Between Ones and Zeros in Row and Column",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** `m x n` binary matrix `grid`.\n\nA **0-indexed** `m x n` difference matrix `diff` is created with the following procedure:\n\n*   Let the number of ones in the `ith` row be `onesRowi`.\n*   Let the number of ones in the `jth` column be `onesColj`.\n*   Let the number of zeros in the `ith` row be `zerosRowi`.\n*   Let the number of zeros in the `jth` column be `zerosColj`.\n*   `diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj`\n\nReturn _the difference matrix_ `diff`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1\\],\\[1,0,1\\],\\[0,0,1\\]\\]\n**Output:** \\[\\[0,0,4\\],\\[0,0,4\\],\\[-2,-2,2\\]\\]\n**Explanation:**\n- diff\\[0\\]\\[0\\] = `onesRow0 + onesCol0 - zerosRow0 - zerosCol0` = 2 + 1 - 1 - 2 = 0 \n- diff\\[0\\]\\[1\\] = `onesRow0 + onesCol1 - zerosRow0 - zerosCol1` = 2 + 1 - 1 - 2 = 0 \n- diff\\[0\\]\\[2\\] = `onesRow0 + onesCol2 - zerosRow0 - zerosCol2` = 2 + 3 - 1 - 0 = 4 \n- diff\\[1\\]\\[0\\] = `onesRow1 + onesCol0 - zerosRow1 - zerosCol0` = 2 + 1 - 1 - 2 = 0 \n- diff\\[1\\]\\[1\\] = `onesRow1 + onesCol1 - zerosRow1 - zerosCol1` = 2 + 1 - 1 - 2 = 0 \n- diff\\[1\\]\\[2\\] = `onesRow1 + onesCol2 - zerosRow1 - zerosCol2` = 2 + 3 - 1 - 0 = 4 \n- diff\\[2\\]\\[0\\] = `onesRow2 + onesCol0 - zerosRow2 - zerosCol0` = 1 + 1 - 2 - 2 = -2\n- diff\\[2\\]\\[1\\] = `onesRow2 + onesCol1 - zerosRow2 - zerosCol1` = 1 + 1 - 2 - 2 = -2\n- diff\\[2\\]\\[2\\] = `onesRow2 + onesCol2 - zerosRow2 - zerosCol2` = 1 + 3 - 2 - 0 = 2\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[5,5,5\\],\\[5,5,5\\]\\]\n**Explanation:**\n- diff\\[0\\]\\[0\\] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff\\[0\\]\\[1\\] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff\\[0\\]\\[2\\] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n- diff\\[1\\]\\[0\\] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff\\[1\\]\\[1\\] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff\\[1\\]\\[2\\] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[0,1,1],[1,0,1],[0,0,1]]",
                "output": "[[0,0,4],[0,0,4],[-2,-2,2]]"
            },
            {
                "input": "[[1,1,1],[1,1,1]]",
                "output": "[[5,5,5],[5,5,5]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] createDifferenceMatrix(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[] onesRow = new int[m], onesCol = new int[n];\n    int[][] diff = new int[m][n];\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            onesRow[i] += grid[i][j];\n            onesCol[j] += grid[i][j];\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j]);\n        }\n    }\n\n    return diff;\n}\n```\n    \n    The algorithm consists of three main steps:\n\n1. Iterate through each cell in the input `grid`, and count the number of ones in each row and column. Store these counts in respective arrays `onesRow` and `onesCol`.\n\n2. Calculate the difference matrix `diff` by iterating through each cell in the input `grid`, and applying the formula `diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])`. \n\n3. Return the `diff` matrix.\n\nThe algorithm iterates through the input grid twice, and has O(m * n) time complexity. It requires additional storage for the `diff` matrix, `onesRow`, and `onesCol`, making the space complexity O(m + n + m * n).\n    ",
        "python": "\n    ```python\ndef create_difference_matrix(grid):\n    m, n = len(grid), len(grid[0])\n    ones_row, ones_col = [0] * m, [0] * n\n    diff = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            ones_row[i] += grid[i][j]\n            ones_col[j] += grid[i][j]\n\n    for i in range(m):\n        for j in range(n):\n            diff[i][j] = ones_row[i] + ones_col[j] - (n - ones_row[i]) - (m - ones_col[j])\n\n    return diff\n```\n    \n    The algorithm consists of three main steps:\n\n1. Iterate through each cell in the input `grid`, and count the number of ones in each row and column. Store these counts in respective arrays `onesRow` and `onesCol`.\n\n2. Calculate the difference matrix `diff` by iterating through each cell in the input `grid`, and applying the formula `diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])`. \n\n3. Return the `diff` matrix.\n\nThe algorithm iterates through the input grid twice, and has O(m * n) time complexity. It requires additional storage for the `diff` matrix, `onesRow`, and `onesCol`, making the space complexity O(m + n + m * n).\n    ",
        "c++": "\n    ```cpp\nvector<vector<int>> createDifferenceMatrix(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    vector<int> onesRow(m, 0), onesCol(n, 0);\n    vector<vector<int>> diff(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            onesRow[i] += grid[i][j];\n            onesCol[j] += grid[i][j];\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j]);\n        }\n    }\n\n    return diff;\n}\n```\n    \n    The algorithm consists of three main steps:\n\n1. Iterate through each cell in the input `grid`, and count the number of ones in each row and column. Store these counts in respective arrays `onesRow` and `onesCol`.\n\n2. Calculate the difference matrix `diff` by iterating through each cell in the input `grid`, and applying the formula `diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])`. \n\n3. Return the `diff` matrix.\n\nThe algorithm iterates through the input grid twice, and has O(m * n) time complexity. It requires additional storage for the `diff` matrix, `onesRow`, and `onesCol`, making the space complexity O(m + n + m * n).\n    ",
        "js": "\n    ```javascript\nfunction createDifferenceMatrix(grid) {\n    const m = grid.length, n = grid[0].length;\n    const onesRow = Array(m).fill(0), onesCol = Array(n).fill(0);\n    const diff = Array.from({ length: m }, () => Array(n).fill(0));\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            onesRow[i] += grid[i][j];\n            onesCol[j] += grid[i][j];\n        }\n    }\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j]);\n        }\n    }\n\n    return diff;\n}\n```\n    \n    The algorithm consists of three main steps:\n\n1. Iterate through each cell in the input `grid`, and count the number of ones in each row and column. Store these counts in respective arrays `onesRow` and `onesCol`.\n\n2. Calculate the difference matrix `diff` by iterating through each cell in the input `grid`, and applying the formula `diff[i][j] = onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j])`. \n\n3. Return the `diff` matrix.\n\nThe algorithm iterates through the input grid twice, and has O(m * n) time complexity. It requires additional storage for the `diff` matrix, `onesRow`, and `onesCol`, making the space complexity O(m + n + m * n).\n    "
    },
    {
        "id": 2236,
        "title": "Maximum Value of a String in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "The **value** of an alphanumeric string can be defined as:\n\n*   The **numeric** representation of the string in base `10`, if it comprises of digits **only**.\n*   The **length** of the string, otherwise.\n\nGiven an array `strs` of alphanumeric strings, return _the **maximum value** of any string in_ `strs`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"alic3 \", \"bob \", \"3 \", \"4 \", \"00000 \"\\]\n**Output:** 5\n**Explanation:** \n-  \"alic3 \" consists of both letters and digits, so its value is its length, i.e. 5.\n-  \"bob \" consists only of letters, so its value is also its length, i.e. 3.\n-  \"3 \" consists only of digits, so its value is its numeric equivalent, i.e. 3.\n-  \"4 \" also consists only of digits, so its value is 4.\n-  \"00000 \" consists only of digits, so its value is 0.\nHence, the maximum value is 5, of  \"alic3 \".\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"1 \", \"01 \", \"001 \", \"0001 \"\\]\n**Output:** 1\n**Explanation:** \nEach string in the array has value 1. Hence, we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 100`\n*   `1 <= strs[i].length <= 9`\n*   `strs[i]` consists of only lowercase English letters and digits.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String"
        ],
        "example": [
            {
                "input": "[\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]",
                "output": "5"
            },
            {
                "input": "[\"1\",\"01\",\"001\",\"0001\"]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int maxValue(List<String> strs) {\n    int maxValue = 0;\n    for (String str : strs) {\n        int value;\n        if (str.chars().allMatch(Character::isDigit)) {\n            value = Integer.parseInt(str);\n        } else {\n            value = str.length();\n        }\n        maxValue = Math.max(maxValue, value);\n    }\n    return maxValue;\n}\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    ",
        "python": "\n    ```python\ndef maxValue(strs) -> int:\n    max_value = 0\n    for str in strs:\n        if str.isdigit():\n            value = int(str)\n        else:\n            value = len(str)\n        max_value = max(max_value, value)\n    return max_value\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint maxValue(std::vector<std::string>& strs) {\n    int max_value = 0;\n    for (const std::string& str : strs) {\n        int value;\n        if (str.find_first_not_of(\"0123456789\") == std::string::npos) {\n            value = std::stoi(str);\n        } else {\n            value = static_cast<int>(str.length());\n        }\n        max_value = std::max(max_value, value);\n    }\n    return max_value;\n}\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(strs) {\n    let maxValue = 0;\n    for (const str of strs) {\n        let value;\n        if (/^\\d+$/.test(str)) {\n            value = parseInt(str, 10);\n        } else {\n            value = str.length;\n        }\n        maxValue = Math.max(maxValue, value);\n    }\n    return maxValue;\n}\n```\n    \n    We iterate through the input array `strs`. For each string, we check whether it contains only digits or not. If it contains only digits, we find its numeric value and store it in a variable `value`. If it contains other characters (letters), we store its length in the `value` variable. In each iteration, we update the `max_value` variable with the maximum of the current `max_value` and the `value` found.\n\nFinally, we return the `max_value`.\n    "
    },
    {
        "id": 2237,
        "title": "Maximum Star Sum of a Graph",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an undirected graph consisting of `n` nodes numbered from `0` to `n - 1`. You are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi.`\n\nA **star graph** is a subgraph of the given graph having a center node containing `0` or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\n\nThe image below shows star graphs with `3` and `4` neighbors respectively, centered at the blue node.\n\nThe **star sum** is the sum of the values of all the nodes present in the star graph.\n\nGiven an integer `k`, return _the **maximum star sum** of a star graph containing **at most**_ `k` _edges._",
            "examples": [
                "**Example 1:**\n\n**Input:** vals = \\[1,2,3,4,10,-10,-20\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\],\\[3,5\\],\\[3,6\\]\\], k = 2\n**Output:** 16\n**Explanation:** The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.\n\n",
                "**Example 2:**\n\n**Input:** vals = \\[-5\\], edges = \\[\\], k = 0\n**Output:** -5\n**Explanation:** There is only one possible star graph, which is node 0 itself.\nHence, we return -5."
            ],
            "constraints": "**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 105`\n*   `-104 <= vals[i] <= 104`\n*   `0 <= edges.length <= min(n * (n - 1) / 2``, 105)`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   `0 <= k <= n - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Graph",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[1,2,3,4,10,-10,-20],[[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]],2",
                "output": "16"
            },
            {
                "input": "[-5],[],0",
                "output": "-5"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxStarSum(int[] vals, int[][] edges, int k) {\n    List<Integer>[] adj = new ArrayList[vals.length];\n    for (int i = 0; i < vals.length; i++) {\n        adj[i] = new ArrayList<Integer>();\n    }\n\n    for (int[] edge : edges) {\n        adj[edge[0]].add(vals[edge[1]]);\n        adj[edge[1]].add(vals[edge[0]]);\n    }\n\n    int ans = Integer.MIN_VALUE;\n    for (int i = 0; i < vals.length; i++) {\n        Collections.sort(adj[i], Collections.reverseOrder());\n        int sum = vals[i];\n        for (int j = 0; j < k && j < adj[i].size(); j++) {\n            sum += adj[i].get(j);\n        }\n        ans = Math.max(ans, sum);\n    }\n\n    return ans;\n}\n```\n    \n    The basic idea of the algorithm is to find the center node and its neighbors that maximize the star sum with the given constraints. For every node, we calculate the sum of its neighbors' values sorted in decreasing order, up to `k` neighbors. We keep track of the maximum sum found for any node so far.\n\n1. Create an adjacency list `adj` to store the values of neighbors of each node.\n\n2. Iterate through the `edges` array and populate the adjacency list `adj` such that `adj[a]` contains the values of the neighbors of the node `a`.\n\n3. For each node `i`, we sort the values of its neighbors in decreasing order to process the maximum values first.\n\n4. Initiate the maximum sum variable `ans` as the minimum value possible.\n\n5. For each node `i`, calculate the sum `sum` of its value and the sum of `k` maximum neighbors' values (if any). Update the `ans` variable to the maximum of the current sum and the previously stored maximum sum.\n\n6. Return the maximum star sum, `ans`.\n    ",
        "python": "\n    ```python\ndef max_star_sum(vals, edges, k):\n    adj = [[] for _ in range(len(vals))]\n\n    for edge in edges:\n        adj[edge[0]].append(vals[edge[1]])\n        adj[edge[1]].append(vals[edge[0]])\n\n    ans = float(\"-inf\")\n    for i in range(len(vals)):\n        adj[i].sort(reverse=True)\n        ans = max(ans, vals[i] + sum(adj[i][:k]))\n\n    return ans\n```\n    \n    The basic idea of the algorithm is to find the center node and its neighbors that maximize the star sum with the given constraints. For every node, we calculate the sum of its neighbors' values sorted in decreasing order, up to `k` neighbors. We keep track of the maximum sum found for any node so far.\n\n1. Create an adjacency list `adj` to store the values of neighbors of each node.\n\n2. Iterate through the `edges` array and populate the adjacency list `adj` such that `adj[a]` contains the values of the neighbors of the node `a`.\n\n3. For each node `i`, we sort the values of its neighbors in decreasing order to process the maximum values first.\n\n4. Initiate the maximum sum variable `ans` as the minimum value possible.\n\n5. For each node `i`, calculate the sum `sum` of its value and the sum of `k` maximum neighbors' values (if any). Update the `ans` variable to the maximum of the current sum and the previously stored maximum sum.\n\n6. Return the maximum star sum, `ans`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxStarSum(const vector<int>& vals, const vector<vector<int>>& edges, int k) {\n    vector<int> adj[100000];\n    int ans = -1e9;\n\n    for (const vector<int>& edge : edges) {\n        adj[edge[0]].push_back(vals[edge[1]]);\n        adj[edge[1]].push_back(vals[edge[0]]);\n    }\n\n    for (int i = 0; i < vals.size(); i++) {\n        sort(adj[i].rbegin(), adj[i].rend());\n        int sum = vals[i];\n        for (int j = 0; j < k && j < adj[i].size(); j++) {\n            sum += adj[i][j];\n        }\n        ans = max(ans, sum);\n    }\n\n    return ans;\n}\n```\n    \n    The basic idea of the algorithm is to find the center node and its neighbors that maximize the star sum with the given constraints. For every node, we calculate the sum of its neighbors' values sorted in decreasing order, up to `k` neighbors. We keep track of the maximum sum found for any node so far.\n\n1. Create an adjacency list `adj` to store the values of neighbors of each node.\n\n2. Iterate through the `edges` array and populate the adjacency list `adj` such that `adj[a]` contains the values of the neighbors of the node `a`.\n\n3. For each node `i`, we sort the values of its neighbors in decreasing order to process the maximum values first.\n\n4. Initiate the maximum sum variable `ans` as the minimum value possible.\n\n5. For each node `i`, calculate the sum `sum` of its value and the sum of `k` maximum neighbors' values (if any). Update the `ans` variable to the maximum of the current sum and the previously stored maximum sum.\n\n6. Return the maximum star sum, `ans`.\n    ",
        "js": "\n    ```javascript\nfunction maxStarSum(vals, edges, k) {\n    const adj = Array.from({ length: vals.length }, () => []);\n\n    for (const [a, b] of edges) {\n        adj[a].push(vals[b]);\n        adj[b].push(vals[a]);\n    }\n\n    let ans = -Infinity;\n    for (let i = 0; i < vals.length; i++) {\n        adj[i].sort((a, b) => b - a);\n        const sum = vals[i] + adj[i].slice(0, k).reduce((a, b) => a + b, 0);\n        ans = Math.max(ans, sum);\n    }\n\n    return ans;\n}\n```\n    \n    The basic idea of the algorithm is to find the center node and its neighbors that maximize the star sum with the given constraints. For every node, we calculate the sum of its neighbors' values sorted in decreasing order, up to `k` neighbors. We keep track of the maximum sum found for any node so far.\n\n1. Create an adjacency list `adj` to store the values of neighbors of each node.\n\n2. Iterate through the `edges` array and populate the adjacency list `adj` such that `adj[a]` contains the values of the neighbors of the node `a`.\n\n3. For each node `i`, we sort the values of its neighbors in decreasing order to process the maximum values first.\n\n4. Initiate the maximum sum variable `ans` as the minimum value possible.\n\n5. For each node `i`, calculate the sum `sum` of its value and the sum of `k` maximum neighbors' values (if any). Update the `ans` variable to the maximum of the current sum and the previously stored maximum sum.\n\n6. Return the maximum star sum, `ans`.\n    "
    },
    {
        "id": 2259,
        "title": "Distinct Prime Factors of Product of Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of positive integers `nums`, return _the number of **distinct prime factors** in the product of the elements of_ `nums`.\n\n**Note** that:\n\n*   A number greater than `1` is called **prime** if it is divisible by only `1` and itself.\n*   An integer `val1` is a factor of another integer `val2` if `val2 / val1` is an integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,3,7,10,6\\]\n**Output:** 4\n**Explanation:**\nThe product of all the elements in nums is: 2 \\* 4 \\* 3 \\* 7 \\* 10 \\* 6 = 10080 = 25 \\* 32 \\* 5 \\* 7.\nThere are 4 distinct prime factors so we return 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,4,8,16\\]\n**Output:** 1\n**Explanation:**\nThe product of all the elements in nums is: 2 \\* 4 \\* 8 \\* 16 = 1024 = 210.\nThere is 1 distinct prime factor so we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `2 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[2,4,3,7,10,6]",
                "output": "4"
            },
            {
                "input": "[2,4,8,16]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic int countDistinctPrimeFactors(int[] nums) {\n    Set<Integer> prime_factors = new HashSet<>();\n    for (int n : nums) {\n        for (int divisor = 2; divisor * divisor <= n; ++divisor) {\n            if (n % divisor == 0) {\n                prime_factors.add(divisor);           \n                prime_factors.add(n / divisor);\n            }\n        }\n    }\n    return prime_factors.size();\n}\n```\n    \n    The algorithm iterates through each number in the input array `nums`. For each number, it computes divisors from 2 to the square root of the number. If a number is divisible by a divisor, both the divisor and its corresponding factor (n // divisor) are added to a set. Using a set ensures that only distinct factors are stored. Finally, the size of the set is returned as it contains the number of distinct prime factors in the product of the elements of `nums`.\n    ",
        "python": "\n    ```python\ndef count_distinct_prime_factors(nums):\n    prime_factors = set()\n    for n in nums:\n        for divisor in range(2, int(n**0.5) + 1):\n            if n % divisor == 0:\n                prime_factors.add(divisor)\n                prime_factors.add(n // divisor)\n    return len(prime_factors)\n```\n    \n    The algorithm iterates through each number in the input array `nums`. For each number, it computes divisors from 2 to the square root of the number. If a number is divisible by a divisor, both the divisor and its corresponding factor (n // divisor) are added to a set. Using a set ensures that only distinct factors are stored. Finally, the size of the set is returned as it contains the number of distinct prime factors in the product of the elements of `nums`.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n\nint countDistinctPrimeFactors(const std::vector<int>& nums) {\n    std::set<int> prime_factors;\n    for (const int n : nums) {\n        for (int divisor = 2; divisor * divisor <= n; ++divisor) {\n            if (n % divisor == 0) {\n                prime_factors.insert(divisor);           \n                prime_factors.insert(n / divisor);\n            }\n        }\n    }\n    return prime_factors.size();\n}\n```\n    \n    The algorithm iterates through each number in the input array `nums`. For each number, it computes divisors from 2 to the square root of the number. If a number is divisible by a divisor, both the divisor and its corresponding factor (n // divisor) are added to a set. Using a set ensures that only distinct factors are stored. Finally, the size of the set is returned as it contains the number of distinct prime factors in the product of the elements of `nums`.\n    ",
        "js": "\n    ```javascript\nfunction countDistinctPrimeFactors(nums) {\n    const prime_factors = new Set();\n    for (const n of nums) {\n        for (let divisor = 2; divisor * divisor <= n; ++divisor) {\n            if (n % divisor === 0) {\n                prime_factors.add(divisor);           \n                prime_factors.add(n / divisor);\n            }\n        }\n    }\n    return prime_factors.size;\n}\n```\n    \n    The algorithm iterates through each number in the input array `nums`. For each number, it computes divisors from 2 to the square root of the number. If a number is divisible by a divisor, both the divisor and its corresponding factor (n // divisor) are added to a set. Using a set ensures that only distinct factors are stored. Finally, the size of the set is returned as it contains the number of distinct prime factors in the product of the elements of `nums`.\n    "
    },
    {
        "id": 2267,
        "title": "Maximum Count of Positive Integer and Negative Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` sorted in **non-decreasing** order, return _the maximum between the number of positive integers and the number of negative integers._\n\n*   In other words, if the number of positive integers in `nums` is `pos` and the number of negative integers is `neg`, then return the maximum of `pos` and `neg`.\n\n**Note** that `0` is neither positive nor negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,-1,-1,1,2,3\\]\n**Output:** 3\n**Explanation:** There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-3,-2,-1,0,0,1,2\\]\n**Output:** 3\n**Explanation:** There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[5,20,66,1314\\]\n**Output:** 4\n**Explanation:** There are 4 positive integers and 0 negative integers. The maximum count among them is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `-2000 <= nums[i] <= 2000`\n*   `nums` is sorted in a **non-decreasing order**.\n\n**",
            "follow_up": "Follow up:** Can you solve the problem in `O(log(n))` time complexity?"
        },
        "tag": [
            "Array",
            "Binary Search",
            "Counting"
        ],
        "example": [
            {
                "input": "[-2,-1,-1,1,2,3]",
                "output": "3"
            },
            {
                "input": "[-3,-2,-1,0,0,1,2]",
                "output": "3"
            },
            {
                "input": "[5,20,66,1314]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxPositiveNegativeCount(int[] nums) {\n    int pos = 0;\n    while (pos < nums.length && nums[pos] < 0) {\n        pos++;\n    }\n    int neg = nums.length - pos;\n    return Math.max(pos, neg);\n}\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    ",
        "python": "\n    ```python\ndef max_positive_negative_count(nums):\n    pos = next((i for i, x in enumerate(nums) if x >= 0), len(nums))\n    neg = len(nums) - pos\n    return max(pos, neg)\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    ",
        "c++": "\n    ```cpp\nint maxPositiveNegativeCount(const vector<int>& nums) {\n    int pos = upper_bound(nums.begin(), nums.end(), -1) - nums.begin();\n    int neg = nums.size() - pos;\n    return max(pos, neg);\n}\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    ",
        "js": "\n    ```javascript\nfunction maxPositiveNegativeCount(nums) {\n    let pos = 0;\n    while (pos < nums.length && nums[pos] < 0) {\n        pos++;\n    }\n    let neg = nums.length - pos;\n    return Math.max(pos, neg);\n}\n```\n    \n    The original array is sorted in non-decreasing order. We want to find the maximum count between the number of positive integers and the number of negative integers in the array. We can find the position where the first non-negative number appears. This position is the count of negative integers in the array. The count of positive integers would be the total length of the array minus this position.\n\nIn C++, we use `upper_bound` to find the position of the first non-negative number.\nIn Java, Python, and JavaScript, we loop through the array and break when we find the first non-negative number.\n\nAfter finding the position, we calculate the counts of both positive and negative integers, and return the maximum of the two.\n    "
    },
    {
        "id": 2272,
        "title": "Difference Between Element Sum and Digit Sum of an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer array `nums`.\n\n*   The **element sum** is the sum of all the elements in `nums`.\n*   The **digit sum** is the sum of all the digits (not necessarily distinct) that appear in `nums`.\n\nReturn _the **absolute** difference between the **element sum** and **digit sum** of_ `nums`.\n\n**Note** that the absolute difference between two integers `x` and `y` is defined as `|x - y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,15,6,3\\]\n**Output:** 9\n**Explanation:** \nThe element sum of nums is 1 + 15 + 6 + 3 = 25.\nThe digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\nThe absolute difference between the element sum and digit sum is |25 - 16| = 9.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 0\n**Explanation:**\nThe element sum of nums is 1 + 2 + 3 + 4 = 10.\nThe digit sum of nums is 1 + 2 + 3 + 4 = 10.\nThe absolute difference between the element sum and digit sum is |10 - 10| = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `1 <= nums[i] <= 2000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,15,6,3]",
                "output": "9"
            },
            {
                "input": "[1,2,3,4]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int differenceBetweenElementAndDigitSum(int[] nums) {\n    int element_sum = 0, digit_sum = 0;\n    for (int num : nums) {\n        element_sum += num;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n    }\n    return Math.abs(element_sum - digit_sum);\n}\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "python": "\n    ```python\ndef difference_between_element_and_digit_sum(nums):\n    element_sum = sum(nums)\n    digit_sum = sum(sum(int(digit) for digit in str(num)) for num in nums)\n    return abs(element_sum - digit_sum)\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "c++": "\n    ```cpp\nint differenceBetweenElementAndDigitSum(vector<int>& nums) {\n    int element_sum = 0, digit_sum = 0;\n    for (int num : nums) {\n        element_sum += num;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n    }\n    return abs(element_sum - digit_sum);\n}\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    ",
        "js": "\n    ```javascript\nfunction differenceBetweenElementAndDigitSum(nums) {\n    let element_sum = 0, digit_sum = 0;\n    for (let num of nums) {\n        element_sum += num;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n    }\n    return Math.abs(element_sum - digit_sum);\n}\n```\n    \n    The idea here is to calculate the element sum and digit sum in one pass of the input list. We iterate through the input list, adding each number to the element sum. To get the digit sum, we keep dividing the number by 10 and adding the remainder to the digit sum until the number becomes 0. Once we have the element sum and digit sum, we can return the absolute difference between them. The specific implementation will vary slightly between different languages, but the overall algorithm should be the same.\n    "
    },
    {
        "id": 2273,
        "title": "Increment Submatrices by One",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a positive integer `n`, indicating that we initially have an `n x n` **0-indexed** integer matrix `mat` filled with zeroes.\n\nYou are also given a 2D integer array `query`. For each `query[i] = [row1i, col1i, row2i, col2i]`, you should do the following operation:\n\n*   Add `1` to **every element** in the submatrix with the **top left** corner `(row1i, col1i)` and the **bottom right** corner `(row2i, col2i)`. That is, add `1` to `mat[x][y]` for all `row1i <= x <= row2i` and `col1i <= y <= col2i`.\n\nReturn _the matrix_ `mat` _after performing every query._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, queries = \\[\\[1,1,2,2\\],\\[0,0,1,1\\]\\]\n**Output:** \\[\\[1,1,0\\],\\[1,2,1\\],\\[0,1,1\\]\\]\n**Explanation:** The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\n\n",
                "**Example 2:**\n\n**Input:** n = 2, queries = \\[\\[0,0,1,1\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n**Explanation:** The diagram above shows the initial matrix and the matrix after the first query.\n- In the first query we add 1 to every element in the matrix."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= queries.length <= 104`\n*   `0 <= row1i <= row2i < n`\n*   `0 <= col1i <= col2i < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Matrix",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "3,[[1,1,2,2],[0,0,1,1]]",
                "output": "[[1,1,0],[1,2,1],[0,1,1]]"
            },
            {
                "input": "2,[[0,0,1,1]]",
                "output": "[[1,1],[1,1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[][] applyQueries(int n, int[][] queries) {\n    int[][] mat = new int[n][n];\n\n    for (int[] query : queries) {\n        for (int i = query[0]; i <= query[2]; i++) {\n            for (int j = query[1]; j <= query[3]; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n\n    return mat;\n}\n```\n    \n    The algorithm simply initializes an n x n matrix filled with zeroes, then iterates through the `queries` list, and for each query, updates the elements in the submatrix as described in the problem statement by incrementing them by 1 in a nested loop. After the updates are made to the matrix, it is returned as the output.\n    ",
        "python": "\n    ```python\ndef apply_queries(n, queries):\n    mat = [[0] * n for _ in range(n)]\n\n    for query in queries:\n        for i in range(query[0], query[2] + 1):\n            for j in range(query[1], query[3] + 1):\n                mat[i][j] += 1\n\n    return mat\n```\n    \n    The algorithm simply initializes an n x n matrix filled with zeroes, then iterates through the `queries` list, and for each query, updates the elements in the submatrix as described in the problem statement by incrementing them by 1 in a nested loop. After the updates are made to the matrix, it is returned as the output.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> applyQueries(int n, std::vector<std::vector<int>>& queries) {\n    std::vector<std::vector<int>> mat(n, std::vector<int>(n, 0));\n\n    for (auto& query : queries) {\n        for (int i = query[0]; i <= query[2]; ++i) {\n            for (int j = query[1]; j <= query[3]; ++j) {\n                mat[i][j]++;\n            }\n        }\n    }\n\n    return mat;\n}\n```\n    \n    The algorithm simply initializes an n x n matrix filled with zeroes, then iterates through the `queries` list, and for each query, updates the elements in the submatrix as described in the problem statement by incrementing them by 1 in a nested loop. After the updates are made to the matrix, it is returned as the output.\n    ",
        "js": "\n    ```javascript\nfunction applyQueries(n, queries) {\n    const mat = new Array(n).fill(0).map(() => new Array(n).fill(0));\n\n    for (const query of queries) {\n        for (let i = query[0]; i <= query[2]; i++) {\n            for (let j = query[1]; j <= query[3]; j++) {\n                mat[i][j]++;\n            }\n        }\n    }\n\n    return mat;\n}\n```\n    \n    The algorithm simply initializes an n x n matrix filled with zeroes, then iterates through the `queries` list, and for each query, updates the elements in the submatrix as described in the problem statement by incrementing them by 1 in a nested loop. After the updates are made to the matrix, it is returned as the output.\n    "
    },
    {
        "id": 2280,
        "title": "Alternating Digit Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a positive integer `n`. Each digit of `n` has a sign according to the following rules:\n\n*   The **most significant digit** is assigned a **positive** sign.\n*   Each other digit has an opposite sign to its adjacent digits.\n\nReturn _the sum of all digits with their corresponding sign_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 521\n**Output:** 4\n**Explanation:** (+5) + (-2) + (+1) = 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 111\n**Output:** 1\n**Explanation:** (+1) + (-1) + (+1) = 1.\n\n",
                "**Example 3:**\n\n**Input:** n = 886996\n**Output:** 0\n**Explanation:** (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "521",
                "output": "4"
            },
            {
                "input": "111",
                "output": "1"
            },
            {
                "input": "886996",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int sumOfDigits(int n) {\n    int sum = 0;\n    boolean positive = true;\n\n    while (n > 0) {\n        int digit = n % 10;\n        n /= 10;\n\n        if (positive) {\n            sum += digit;\n        } else {\n            sum -= digit;\n        }\n\n        positive = !positive;\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    ",
        "python": "\n    ```python\ndef sum_of_digits(n: int) -> int:\n    total = 0\n    positive = True\n\n    while n > 0:\n        digit = n % 10\n        n //= 10\n\n        if positive:\n            total += digit\n        else:\n            total -= digit\n\n        positive = not positive\n\n    return total\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    ",
        "c++": "\n    ```cpp\nint sumOfDigits(int n) {\n    int sum = 0;\n    bool positive = true;\n\n    while (n > 0) {\n        int digit = n % 10;\n        n /= 10;\n\n        if (positive) {\n            sum += digit;\n        } else {\n            sum -= digit;\n        }\n\n        positive = !positive;\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    ",
        "js": "\n    ```javascript\nfunction sumOfDigits(n) {\n    let sum = 0;\n    let positive = true;\n\n    while (n > 0) {\n        let digit = n % 10;\n        n = Math.floor(n / 10);\n\n        if (positive) {\n            sum += digit;\n        } else {\n            sum -= digit;\n        }\n\n        positive = !positive;\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm is simple and works as follows:\n1. Initialize a variable, `sum`, to store the sum of the digits with their signs, and a boolean variable, `positive`, to determine whether the current digit should have a positive or negative sign.\n2. Iterate through the digits of the input number `n` by repeatedly dividing it by 10 and checking if it's greater than 0.\n   - Note that we process the digits from the least significant digit to the most significant digit.\n3. At each iteration, get the least significant digit (`digit`) of `n` by taking the remainder of the division of `n` by 10.\n4. If `positive` is true, add the digit to the sum; otherwise, subtract it from the sum.\n5. Toggle the value of `positive` for the next iteration.\n6. Return the final value of `sum`.\n\nThe algorithm has a time complexity of O(log(n)) because it processes each digit of the input number `n`.\n    "
    },
    {
        "id": 2281,
        "title": "Sort the Students by Their Kth Score",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a class with `m` students and `n` exams. You are given a **0-indexed** `m x n` integer matrix `score`, where each row represents one student and `score[i][j]` denotes the score the `ith` student got in the `jth` exam. The matrix `score` contains **distinct** integers only.\n\nYou are also given an integer `k`. Sort the students (i.e., the rows of the matrix) by their scores in the `kth` (**0-indexed**) exam from the highest to the lowest.\n\nReturn _the matrix after sorting it._",
            "examples": [
                "**Example 1:**\n\n**Input:** score = \\[\\[10,6,9,1\\],\\[7,5,11,2\\],\\[4,8,3,15\\]\\], k = 2\n**Output:** \\[\\[7,5,11,2\\],\\[10,6,9,1\\],\\[4,8,3,15\\]\\]\n**Explanation:** In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.\n- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.\n- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.\n\n",
                "**Example 2:**\n\n**Input:** score = \\[\\[3,4\\],\\[5,6\\]\\], k = 0\n**Output:** \\[\\[5,6\\],\\[3,4\\]\\]\n**Explanation:** In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.\n- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place."
            ],
            "constraints": "**Constraints:**\n\n*   `m == score.length`\n*   `n == score[i].length`\n*   `1 <= m, n <= 250`\n*   `1 <= score[i][j] <= 105`\n*   `score` consists of **distinct** integers.\n*   `0 <= k < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[10,6,9,1],[7,5,11,2],[4,8,3,15]],2",
                "output": "[[7,5,11,2],[10,6,9,1],[4,8,3,15]]"
            },
            {
                "input": "[[3,4],[5,6]],0",
                "output": "[[5,6],[3,4]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[][] sortStudents(int[][] score, int k) {\n        Arrays.sort(score, (a, b) -> b[k] - a[k]);\n        return score;\n    }\n}\n```\n\n    \n    The algorithm makes use of the given programming language's built-in sorting function (e.g., `sort` function for C++, Java, Python, and JavaScript). A custom sorting function is supplied as an argument to the built-in sort function.\n\nFor each language, the custom sorting function utilizes a lambda function that compares the `k`-th exam scores of two students (i.e., rows of the matrix). The lambda function sorts rows in descending order based on their scores in the `k`-th exam. The result is a sorted matrix where students' rows are rearranged according to their scores in the `k`-th exam.\n\nHere's an overview of the custom sorting function for each language:\n* C++: Uses lambda function `[k] (const vector<int>& a, const vector<int>& b) { return a[k] > b[k]; }`\n* Java: Uses lambda function `(a, b) -> b[k] - a[k]`\n* Python: Uses lambda function `key=lambda x: x[k], reverse=True`\n* JavaScript: Uses lambda function `(a, b) => b[k] - a[k]`\n    ",
        "python": "\n    ```python\ndef sort_students(score, k):\n    score.sort(key=lambda x: x[k], reverse=True)\n    return score\n```\n\n    \n    The algorithm makes use of the given programming language's built-in sorting function (e.g., `sort` function for C++, Java, Python, and JavaScript). A custom sorting function is supplied as an argument to the built-in sort function.\n\nFor each language, the custom sorting function utilizes a lambda function that compares the `k`-th exam scores of two students (i.e., rows of the matrix). The lambda function sorts rows in descending order based on their scores in the `k`-th exam. The result is a sorted matrix where students' rows are rearranged according to their scores in the `k`-th exam.\n\nHere's an overview of the custom sorting function for each language:\n* C++: Uses lambda function `[k] (const vector<int>& a, const vector<int>& b) { return a[k] > b[k]; }`\n* Java: Uses lambda function `(a, b) -> b[k] - a[k]`\n* Python: Uses lambda function `key=lambda x: x[k], reverse=True`\n* JavaScript: Uses lambda function `(a, b) => b[k] - a[k]`\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> sortStudents(vector<vector<int>>& score, int k) {\n    sort(score.begin(), score.end(), [k] (const vector<int>& a, const vector<int>& b) {\n        return a[k] > b[k];\n    });\n    return score;\n}\n```\n\n    \n    The algorithm makes use of the given programming language's built-in sorting function (e.g., `sort` function for C++, Java, Python, and JavaScript). A custom sorting function is supplied as an argument to the built-in sort function.\n\nFor each language, the custom sorting function utilizes a lambda function that compares the `k`-th exam scores of two students (i.e., rows of the matrix). The lambda function sorts rows in descending order based on their scores in the `k`-th exam. The result is a sorted matrix where students' rows are rearranged according to their scores in the `k`-th exam.\n\nHere's an overview of the custom sorting function for each language:\n* C++: Uses lambda function `[k] (const vector<int>& a, const vector<int>& b) { return a[k] > b[k]; }`\n* Java: Uses lambda function `(a, b) -> b[k] - a[k]`\n* Python: Uses lambda function `key=lambda x: x[k], reverse=True`\n* JavaScript: Uses lambda function `(a, b) => b[k] - a[k]`\n    ",
        "js": "\n    ```javascript\nfunction sort_students(score, k) {\n    return score.sort((a, b) => b[k] - a[k]);\n}\n```\n\n    \n    The algorithm makes use of the given programming language's built-in sorting function (e.g., `sort` function for C++, Java, Python, and JavaScript). A custom sorting function is supplied as an argument to the built-in sort function.\n\nFor each language, the custom sorting function utilizes a lambda function that compares the `k`-th exam scores of two students (i.e., rows of the matrix). The lambda function sorts rows in descending order based on their scores in the `k`-th exam. The result is a sorted matrix where students' rows are rearranged according to their scores in the `k`-th exam.\n\nHere's an overview of the custom sorting function for each language:\n* C++: Uses lambda function `[k] (const vector<int>& a, const vector<int>& b) { return a[k] > b[k]; }`\n* Java: Uses lambda function `(a, b) -> b[k] - a[k]`\n* Python: Uses lambda function `key=lambda x: x[k], reverse=True`\n* JavaScript: Uses lambda function `(a, b) => b[k] - a[k]`\n    "
    },
    {
        "id": 2298,
        "title": "Find the Array Concatenation Value",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`.\n\nThe **concatenation** of two numbers is the number formed by concatenating their numerals.\n\n*   For example, the concatenation of `15`, `49` is `1549`.\n\nThe **concatenation value** of `nums` is initially equal to `0`. Perform this operation until `nums` becomes empty:\n\n*   If there exists more than one number in `nums`, pick the first element and last element in `nums` respectively and add the value of their concatenation to the **concatenation value** of `nums`, then delete the first and last element from `nums`.\n*   If one element exists, add its value to the **concatenation value** of `nums`, then delete it.\n\nReturn _the concatenation value of the `nums`_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,52,2,4\\]\n**Output:** 596\n**Explanation:** Before performing any operation, nums is \\[7,52,2,4\\] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to \\[52,2\\].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,14,13,8,12\\]\n**Output:** 673\n**Explanation:** Before performing any operation, nums is \\[5,14,13,8,12\\] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to \\[14,13,8\\].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to \\[13\\].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;  } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Simulation"
        ],
        "example": [
            {
                "input": "[7,52,2,4]",
                "output": "596"
            },
            {
                "input": "[5,14,13,8,12]",
                "output": "673"
            }
        ],
        "java": "\n    ```java\npublic int concatenationValue(int[] nums) {\n    int value = 0;\n    int n = nums.length;\n    for (int i = 0; i < n; i += 2) {\n        if (i == n - 1 - i) {\n            value += nums[i];\n        } else {\n            value += Integer.parseInt(String.valueOf(nums[i]) + String.valueOf(nums[n - 1 - i]));\n        }\n    }\n    return value;\n}\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "python": "\n    ```python\ndef concatenationValue(nums):\n    value = 0\n    while nums:\n        n = len(nums)\n        if n == 1:\n            value += nums[0]\n            nums.pop()\n        else:\n            value += int(str(nums[0]) + str(nums[-1]))\n            nums.pop(0)\n            nums.pop()\n    return value\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "c++": "\n    ```cpp\nint concatenationValue(vector<int>& nums) {\n    int value = 0;\n    while (!nums.empty()) {\n        int n = nums.size();\n        if (n == 1) {\n            value += nums[0];\n            nums.pop_back();\n        } else {\n            value += stoi(to_string(nums[0]) + to_string(nums[n - 1]));\n            nums.erase(nums.begin());\n            nums.pop_back();\n        }\n    }\n    return value;\n}\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    ",
        "js": "\n    ```javascript\nfunction concatenationValue(nums) {\n    let value = 0;\n    while (nums.length > 0) {\n        let n = nums.length;\n        if (n === 1) {\n            value += nums[0];\n            nums.pop();\n        } else {\n            value += parseInt(nums[0].toString() + nums[n - 1].toString());\n            nums.shift();\n            nums.pop();\n        }\n    }\n    return value;\n}\n```\n    \n    The algorithm goes as follows:\n1. Initialize the concatenation value to 0.\n2. Check if the nums list is empty. If it is not:\n   a. Check if the length of the nums list is 1. If it is, add the only element in the list to the concatenation value and remove it from the list.\n   b. If there is more than one element in the nums list, concatenate the first and last elements and add this value to the concatenation value. Then, remove both elements from the list.\n3. Repeat step 2 until the nums list is empty.\n4. Return the concatenation value.\n    "
    },
    {
        "id": 2302,
        "title": "Maximum Difference by Remapping a Digit",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer `num`. You know that Danny Mittal will sneakily **remap** one of the `10` possible digits (`0` to `9`) to another digit.\n\nReturn _the difference between the maximum and minimum_ _values Danny can make by remapping **exactly** **one** digit_ _in_ `num`.\n\n**Notes:**\n\n*   When Danny remaps a digit d1 to another digit d2, Danny replaces all occurrences of `d1` in `num` with `d2`.\n*   Danny can remap a digit to itself, in which case `num` does not change.\n*   Danny can remap different digits for obtaining minimum and maximum values respectively.\n*   The resulting number after remapping can contain leading zeroes.\n*   We mentioned \"Danny Mittal \" to congratulate him on being in the top 10 in Weekly Contest 326.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 11891\n**Output:** 99009\n**Explanation:** \nTo achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899.\nTo achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890.\nThe difference between these two numbers is 99009.\n\n",
                "**Example 2:**\n\n**Input:** num = 90\n**Output:** 99\n**Explanation:**\nThe maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).\nThus, we return 99."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 108`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "11891",
                "output": "99009"
            },
            {
                "input": "90",
                "output": "99"
            }
        ],
        "java": "\n    ```java\nint diffMaxMin(int num) {\n    int maxRemap = 1, minRemap = 9;\n    String numStr = Integer.toString(num);\n    for (int i = 0; i < numStr.length(); i++) {\n        int digit = numStr.charAt(i) - '0';\n        maxRemap = Math.max(maxRemap, 9 - digit);\n        if (digit != 0) {\n            minRemap = Math.min(minRemap, digit);\n        }\n    }\n    int maxValue = num + maxRemap * (numStr.length() - numStr.replaceAll(Character.toString((char)('9' - maxRemap)), \"\").length());\n    int minValue = num - minRemap * (numStr.length() - numStr.replaceAll(Character.toString((char)(minRemap + '0')), \"\").length());\n    return maxValue - minValue;\n}\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    ",
        "python": "\n    ```python\ndef diffMaxMin(num):\n    max_remap = 1\n    min_remap = 9\n    num_str = str(num)\n    \n    for c in num_str:\n        digit = int(c)\n        max_remap = max(max_remap, 9 - digit)\n        if digit != 0:\n            min_remap = min(min_remap, digit)\n\n    max_value = num + max_remap * (len(num_str) - num_str.count(str(9 - max_remap)))\n    min_value = num - min_remap * num_str.count(str(min_remap))\n    return max_value - min_value\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    ",
        "c++": "\n    ```cpp\nint diffMaxMin(int num) {\n    int maxRemap = 1, minRemap = 9;\n    string numStr = to_string(num);\n    for (char c : numStr) {\n        int digit = c - '0';\n        maxRemap = max(maxRemap, 9 - digit);\n        if (digit != 0) {\n            minRemap = min(minRemap, digit);\n        }\n    }\n    int maxValue = num + maxRemap * (numStr.length() - count(numStr.begin(), numStr.end(), '9' - maxRemap));\n    int minValue = num - minRemap * count(numStr.begin(), numStr.end(), minRemap + '0');\n    return maxValue - minValue;\n}\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    ",
        "js": "\n    ```javascript\nfunction diffMaxMin(num) {\n    let maxRemap = 1, minRemap = 9;\n    let numStr = String(num);\n    for (const c of numStr) {\n        let digit = parseInt(c);\n        maxRemap = Math.max(maxRemap, 9 - digit);\n        if (digit !== 0) {\n            minRemap = Math.min(minRemap, digit);\n        }\n    }\n    let maxValue = num + maxRemap * (numStr.length - numStr.split('' + (9 - maxRemap)).length + 1);\n    let minValue = num - minRemap * (numStr.length - numStr.split('' + minRemap).length + 1);\n    return maxValue - minValue;\n}\n```\n    \n    1. Initialize `max_remap` to 1 and `min_remap` to 9, as well as convert `num` to a string `num_str`.\n2. Iterate through each character `c` in `num_str` and perform the following steps:\n    a. Compute the integer `digit` from the character `c`.\n    b. Update `max_remap` to be the maximum of its current value and `9 - digit`.\n    c. If `digit` is not 0, update `min_remap` to be the minimum of its current value and `digit`.\n3. Calculate `max_value` by adding `max_remap` multiplied by the number of occurrences where the digit `9 - max_remap` appears in the string `num_str`.\n4. Calculate `min_value` by subtracting `min_remap` multiplied by the number of occurrences where the digit `min_remap` appears in the string `num_str`.\n5. Return the difference between `max_value` and `min_value`.\n    "
    },
    {
        "id": 2306,
        "title": "Merge Two 2D Arrays by Summing Values",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two **2D** integer arrays `nums1` and `nums2.`\n\n*   `nums1[i] = [idi, vali]` indicate that the number with the id `idi` has a value equal to `vali`.\n*   `nums2[i] = [idi, vali]` indicate that the number with the id `idi` has a value equal to `vali`.\n\nEach array contains **unique** ids and is sorted in **ascending** order by id.\n\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\n*   Only ids that appear in at least one of the two arrays should be included in the resulting array.\n*   Each id should be included **only once** and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be `0`.\n\nReturn _the resulting array_. The returned array must be sorted in ascending order by id.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[\\[1,2\\],\\[2,3\\],\\[4,5\\]\\], nums2 = \\[\\[1,4\\],\\[3,2\\],\\[4,1\\]\\]\n**Output:** \\[\\[1,6\\],\\[2,3\\],\\[3,2\\],\\[4,6\\]\\]\n**Explanation:** The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[\\[2,4\\],\\[3,6\\],\\[5,5\\]\\], nums2 = \\[\\[1,3\\],\\[4,3\\]\\]\n**Output:** \\[\\[1,3\\],\\[2,4\\],\\[3,6\\],\\[4,3\\],\\[5,5\\]\\]\n**Explanation:** There are no common ids, so we just include each id with its value in the resulting list."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 200`\n*   `nums1[i].length == nums2[j].length == 2`\n*   `1 <= idi, vali <= 1000`\n*   Both arrays contain unique ids.\n*   Both arrays are in strictly ascending order by id.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Two Pointers"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[4,5]],[[1,4],[3,2],[4,1]]",
                "output": "[[1,6],[2,3],[3,2],[4,6]]"
            },
            {
                "input": "[[2,4],[3,6],[5,5]],[[1,3],[4,3]]",
                "output": "[[1,3],[2,4],[3,6],[4,3],[5,5]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<Integer>> merge_nums(List<List<Integer>> nums1, List<List<Integer>> nums2) {\n    Map<Integer, Integer> merged_map = new HashMap<>();;\n    List<List<Integer>> merged = new ArrayList<>();\n\n    for(List<Integer> p : nums1) {\n        merged_map.put(p.get(0), merged_map.getOrDefault(p.get(0), 0) + p.get(1));\n    }\n\n    for(List<Integer> p : nums2) {\n        merged_map.put(p.get(0), merged_map.getOrDefault(p.get(0), 0) + p.get(1));\n    }\n\n    for(Map.Entry<Integer, Integer> entry : merged_map.entrySet()) {\n        List<Integer> tmp = new ArrayList<>();\n        tmp.add(entry.getKey());\n        tmp.add(entry.getValue());\n        merged.add(tmp);\n    }\n\n    return merged;\n}\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    ",
        "python": "\n    ```python\ndef merge_nums(nums1, nums2):\n    merged_map = {}\n    merged = []\n\n    for id_val_pair in nums1:\n        id_, val_ = id_val_pair\n        if id_ not in merged_map:\n            merged_map[id_] = val_\n        else:\n            merged_map[id_] += val_\n\n    for id_val_pair in nums2:\n        id_, val_ = id_val_pair\n        if id_ not in merged_map:\n            merged_map[id_] = val_\n        else:\n            merged_map[id_] += val_\n\n    for id_, val_ in merged_map.items():\n        merged.append([id_, val_])\n    \n    return merged\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n\nstd::vector<std::vector<int>> merge_nums(std::vector<std::vector<int>>& nums1, std::vector<std::vector<int>>& nums2) {\n    std::map<int, int> merged_map;\n    std::vector<std::vector<int>> merged;\n\n    for (const auto& p : nums1) {\n        merged_map[p[0]] += p[1];\n    }\n\n    for (const auto& p : nums2) {\n        merged_map[p[0]] += p[1];\n    }\n\n    for (const auto& p : merged_map) {\n        merged.push_back({p.first, p.second});\n    }\n\n    return merged;\n}\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    ",
        "js": "\n    ```javascript\nfunction merge_nums(nums1, nums2) {\n    const merged_map = new Map();\n    const merged = [];\n\n    for(const [id, val] of nums1) {\n        merged_map.set(id, (merged_map.get(id) || 0) + val);\n    }\n\n    for(const [id, val] of nums2) {\n        merged_map.set(id, (merged_map.get(id) || 0) + val);\n    }\n\n    for(const [id, val] of merged_map.entries()) {\n        merged.push([id, val]);\n    }\n\n    return merged;\n}\n```\n    \n    1. Create an empty map `merged_map` and an empty list `merged` that will store the final result.\n2. Iterate through both `nums1` and `nums2`, and for each id and value pair:\n   i. Check if the id exists in `merged_map`. If it does, add the value to the existing value in `merged_map`.\n  ii. If the id does not exist in `merged_map`, insert the id into the map and set its value to the current value.\n3. After both arrays have been processed, iterate through `merged_map` and append each id-value pair as a list to the `merged` list.\n4. Return the `merged` list.\n    "
    },
    {
        "id": 2311,
        "title": "Find the Divisibility Array of a String",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** string `word` of length `n` consisting of digits, and a positive integer `m`.\n\nThe **divisibility array** `div` of `word` is an integer array of length `n` such that:\n\n*   `div[i] = 1` if the **numeric value** of `word[0,...,i]` is divisible by `m`, or\n*   `div[i] = 0` otherwise.\n\nReturn _the divisibility array of_ `word`.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"998244353 \", m = 3\n**Output:** \\[1,1,0,0,0,1,1,0,0\\]\n**Explanation:** There are only 4 prefixes that are divisible by 3:  \"9 \",  \"99 \",  \"998244 \", and  \"9982443 \".\n\n",
                "**Example 2:**\n\n**Input:** word =  \"1010 \", m = 10\n**Output:** \\[0,1,0,1\\]\n**Explanation:** There are only 2 prefixes that are divisible by 10:  \"10 \", and  \"1010 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `word.length == n`\n*   `word` consists of digits from `0` to `9`\n*   `1 <= m <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"998244353\",3",
                "output": "[1,1,0,0,0,1,1,0,0]"
            },
            {
                "input": "\"1010\",10",
                "output": "[0,1,0,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic ArrayList<Integer> divisibilityArray(String word, int m) {\n    ArrayList<Integer> div = new ArrayList<>(word.length());\n    int value = 0;\n    for(int i = 0; i < word.length(); ++i) {\n        value = (value * 10 + (word.charAt(i) - '0')) % m;\n        div.add((value == 0) ? 1 : 0);\n    }\n    return div;\n}\n```\n    \n    We initialize an empty divisibility array and a variable value to store the current numeric value. We iterate through the characters in the input string word. For each character, we multiply the value variable by 10 and add the numeric value of the character by subtracting the ASCII value of '0' from the ASCII value of the character, then taking the remainder with m. If the value is equal to 0, we push 1 in our array, and otherwise, we push 0. Finally, we return the divisibility array.\n    ",
        "python": "\n    ```python\ndef divisibility_array(word: str, m: int) -> list[int]:\n    div = []\n    value = 0\n    for c in word:\n        value = (value * 10 + int(c)) % m\n        div.append(1 if value == 0 else 0)\n    return div\n```\n    \n    We initialize an empty divisibility array and a variable value to store the current numeric value. We iterate through the characters in the input string word. For each character, we multiply the value variable by 10 and add the numeric value of the character by subtracting the ASCII value of '0' from the ASCII value of the character, then taking the remainder with m. If the value is equal to 0, we push 1 in our array, and otherwise, we push 0. Finally, we return the divisibility array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> divisibilityArray(std::string word, int m) {\n    std::vector<int> div(word.size());\n    int value = 0;\n    for(size_t i = 0; i < word.length(); ++i) {\n        value = (value * 10 + (word[i] - '0')) % m;\n        div[i] = (value == 0) ? 1 : 0;\n    }\n    return div;\n}\n```\n    \n    We initialize an empty divisibility array and a variable value to store the current numeric value. We iterate through the characters in the input string word. For each character, we multiply the value variable by 10 and add the numeric value of the character by subtracting the ASCII value of '0' from the ASCII value of the character, then taking the remainder with m. If the value is equal to 0, we push 1 in our array, and otherwise, we push 0. Finally, we return the divisibility array.\n    ",
        "js": "\n    ```javascript\nfunction divisibilityArray(word, m) {\n    let div = [];\n    let value = 0;\n    for (let i = 0; i < word.length; ++i) {\n        value = (value * 10 + (word.charCodeAt(i) - '0'.charCodeAt(0))) % m;\n        div.push((value === 0) ? 1 : 0);\n    }\n    return div;\n}\n```\n    \n    We initialize an empty divisibility array and a variable value to store the current numeric value. We iterate through the characters in the input string word. For each character, we multiply the value variable by 10 and add the numeric value of the character by subtracting the ASCII value of '0' from the ASCII value of the character, then taking the remainder with m. If the value is equal to 0, we push 1 in our array, and otherwise, we push 0. Finally, we return the divisibility array.\n    "
    },
    {
        "id": 2314,
        "title": "Count Total Number of Colored Cells",
        "difficulty": "Medium",
        "content": {
            "problem": "There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer `n`, indicating that you must do the following routine for `n` minutes:\n\n*   At the first minute, color **any** arbitrary unit cell blue.\n*   Every minute thereafter, color blue **every** uncolored cell that touches a blue cell.\n\nBelow is a pictorial representation of the state of the grid after minutes 1, 2, and 3.\n\nReturn _the number of **colored cells** at the end of_ `n` _minutes_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** After 1 minute, there is only 1 blue cell, so we return 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 5\n**Explanation:** After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "1",
                "output": "1"
            },
            {
                "input": "2",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nint numberOfColoredCells(int n) {\n    return n * n + (n - 1) * (n - 1);\n}\n```\n    \n    For each minute, the boundary of colored cells expands outward in a square pattern. To get the total number of colored cells, we consider two squares - the inner square formed by the cells that were colored at minute n-1, and the outer square formed by the cells that were colored at minute n. \n\nThe inner square has dimensions (n-1)x(n-1), while the outer square has dimensions nxn. The number of colored cells is the sum of the areas of these two squares.\n\nWe compute this as `n * n + (n - 1) * (n - 1)`.\n    ",
        "python": "\n    ```python\ndef number_of_colored_cells(n):\n    return n * n + (n - 1) * (n - 1)\n```\n    \n    For each minute, the boundary of colored cells expands outward in a square pattern. To get the total number of colored cells, we consider two squares - the inner square formed by the cells that were colored at minute n-1, and the outer square formed by the cells that were colored at minute n. \n\nThe inner square has dimensions (n-1)x(n-1), while the outer square has dimensions nxn. The number of colored cells is the sum of the areas of these two squares.\n\nWe compute this as `n * n + (n - 1) * (n - 1)`.\n    ",
        "c++": "\n    ```cpp\nint numberOfColoredCells(int n) {\n    return n * n + (n - 1) * (n - 1);\n}\n```\n    \n    For each minute, the boundary of colored cells expands outward in a square pattern. To get the total number of colored cells, we consider two squares - the inner square formed by the cells that were colored at minute n-1, and the outer square formed by the cells that were colored at minute n. \n\nThe inner square has dimensions (n-1)x(n-1), while the outer square has dimensions nxn. The number of colored cells is the sum of the areas of these two squares.\n\nWe compute this as `n * n + (n - 1) * (n - 1)`.\n    ",
        "js": "\n    ```javascript\nfunction numberOfColoredCells(n) {\n    return n * n + (n - 1) * (n - 1);\n}\n```\n    \n    For each minute, the boundary of colored cells expands outward in a square pattern. To get the total number of colored cells, we consider two squares - the inner square formed by the cells that were colored at minute n-1, and the outer square formed by the cells that were colored at minute n. \n\nThe inner square has dimensions (n-1)x(n-1), while the outer square has dimensions nxn. The number of colored cells is the sum of the areas of these two squares.\n\nWe compute this as `n * n + (n - 1) * (n - 1)`.\n    "
    },
    {
        "id": 2322,
        "title": "Rearrange Array to Maximize Prefix Score",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. You can rearrange the elements of `nums` to **any order** (including the given order).\n\nLet `prefix` be the array containing the prefix sums of `nums` after rearranging it. In other words, `prefix[i]` is the sum of the elements from `0` to `i` in `nums` after rearranging it. The **score** of `nums` is the number of positive integers in the array `prefix`.\n\nReturn _the maximum score you can achieve_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,-1,0,1,-3,3,-3\\]\n**Output:** 6\n**Explanation:** We can rearrange the array into nums = \\[2,3,1,-1,-3,0,-3\\].\nprefix = \\[2,5,6,5,2,2,-1\\], so the score is 6.\nIt can be shown that 6 is the maximum score we can obtain.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-2,-3,0\\]\n**Output:** 0\n**Explanation:** Any rearrangement of the array will result in a score of 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-106 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,-1,0,1,-3,3,-3]",
                "output": "6"
            },
            {
                "input": "[-2,-3,0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int[] nums) {\n    Arrays.sort(nums);\n    int result = 0, prefixSum = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        if (prefixSum + nums[i] > 0) {\n            ++result;\n            prefixSum += nums[i];\n        }\n    }\n    return result;\n}\n```\n    \n    We want to maximize the score of the array which is the number of positive integers in the prefix sums. Since we can reorder the elements, we should always keep the prefix sums positive. Negative numbers should be taken only after some positive numbers, otherwise we will not get to make the prefix sum positive again.\n\n1. Sort the array.\n2. Initialize the result and prefix sums to 0.\n3. Iterate through the sorted array and for each element, if adding that element to the prefix sum results in a positive number, increment the result and add the element to the prefix sum.\n\nThe reason we're sorting the array is that by doing that, we can iterate through and naturally structure the rearrangement of the array to maximize the prefix sums while remaining positive. Sorting the array also helps us to find the optimal result easily without needing to explore exhaustive rearrangements.\n\nAt the end, we'll have the maximum score.\n    ",
        "python": "\n    ```python\ndef maxScore(nums: List[int]) -> int:\n    nums.sort()\n    result, prefixSum = 0, 0\n    for i in range(len(nums)):\n        if prefixSum + nums[i] > 0:\n            result += 1\n            prefixSum += nums[i]\n    return result\n```\n    \n    We want to maximize the score of the array which is the number of positive integers in the prefix sums. Since we can reorder the elements, we should always keep the prefix sums positive. Negative numbers should be taken only after some positive numbers, otherwise we will not get to make the prefix sum positive again.\n\n1. Sort the array.\n2. Initialize the result and prefix sums to 0.\n3. Iterate through the sorted array and for each element, if adding that element to the prefix sum results in a positive number, increment the result and add the element to the prefix sum.\n\nThe reason we're sorting the array is that by doing that, we can iterate through and naturally structure the rearrangement of the array to maximize the prefix sums while remaining positive. Sorting the array also helps us to find the optimal result easily without needing to explore exhaustive rearrangements.\n\nAt the end, we'll have the maximum score.\n    ",
        "c++": "\n    ```cpp\nint maxScore(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int result = 0, prefixSum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (prefixSum + nums[i] > 0) {\n            ++result;\n            prefixSum += nums[i];\n        }\n    }\n    return result;\n}\n```\n    \n    We want to maximize the score of the array which is the number of positive integers in the prefix sums. Since we can reorder the elements, we should always keep the prefix sums positive. Negative numbers should be taken only after some positive numbers, otherwise we will not get to make the prefix sum positive again.\n\n1. Sort the array.\n2. Initialize the result and prefix sums to 0.\n3. Iterate through the sorted array and for each element, if adding that element to the prefix sum results in a positive number, increment the result and add the element to the prefix sum.\n\nThe reason we're sorting the array is that by doing that, we can iterate through and naturally structure the rearrangement of the array to maximize the prefix sums while remaining positive. Sorting the array also helps us to find the optimal result easily without needing to explore exhaustive rearrangements.\n\nAt the end, we'll have the maximum score.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(nums) {\n    nums.sort((a, b) => a - b);\n    let result = 0, prefixSum = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (prefixSum + nums[i] > 0) {\n            ++result;\n            prefixSum += nums[i];\n        }\n    }\n    return result;\n}\n```\n    \n    We want to maximize the score of the array which is the number of positive integers in the prefix sums. Since we can reorder the elements, we should always keep the prefix sums positive. Negative numbers should be taken only after some positive numbers, otherwise we will not get to make the prefix sum positive again.\n\n1. Sort the array.\n2. Initialize the result and prefix sums to 0.\n3. Iterate through the sorted array and for each element, if adding that element to the prefix sum results in a positive number, increment the result and add the element to the prefix sum.\n\nThe reason we're sorting the array is that by doing that, we can iterate through and naturally structure the rearrangement of the array to maximize the prefix sums while remaining positive. Sorting the array also helps us to find the optimal result easily without needing to explore exhaustive rearrangements.\n\nAt the end, we'll have the maximum score.\n    "
    },
    {
        "id": 2341,
        "title": "Find the Substring With Maximum Cost",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s`, a string `chars` of **distinct** characters and an integer array `vals` of the same length as `chars`.\n\nThe **cost of the substring** is the sum of the values of each character in the substring. The cost of an empty string is considered `0`.\n\nThe **value of the character** is defined in the following way:\n\n*   If the character is not in the string `chars`, then its value is its corresponding position **(1-indexed)** in the alphabet.\n    *   For example, the value of `'a'` is `1`, the value of `'b'` is `2`, and so on. The value of `'z'` is `26`.\n*   Otherwise, assuming `i` is the index where the character occurs in the string `chars`, then its value is `vals[i]`.\n\nReturn _the maximum cost among all substrings of the string_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"adaa \", chars =  \"d \", vals = \\[-1000\\]\n**Output:** 2\n**Explanation:** The value of the characters  \"a \" and  \"d \" is 1 and -1000 respectively.\nThe substring with the maximum cost is  \"aa \" and its cost is 1 + 1 = 2.\nIt can be proven that 2 is the maximum cost.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abc \", chars =  \"abc \", vals = \\[-1,-1,-1\\]\n**Output:** 0\n**Explanation:** The value of the characters  \"a \",  \"b \" and  \"c \" is -1, -1, and -1 respectively.\nThe substring with the maximum cost is the empty substring  \" \" and its cost is 0.\nIt can be proven that 0 is the maximum cost."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consist of lowercase English letters.\n*   `1 <= chars.length <= 26`\n*   `chars` consist of **distinct** lowercase English letters.\n*   `vals.length == chars.length`\n*   `-1000 <= vals[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"adaa\",\"d\",[-1000]",
                "output": "2"
            },
            {
                "input": "\"abc\",\"abc\",[-1,-1,-1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxValueSubstring(String s, String chars, int[] vals) {\n    Map<Character, Integer> values = new HashMap<>();\n\t\n    for (int i = 0; i < chars.length(); i++) {\n        values.put(chars.charAt(i), vals[i]);\n    }\n\n    int max_cost = 0;\n    int cost = 0;\n\n    for (char c : s.toCharArray()) {\n        int value = values.containsKey(c) ? values.get(c) : (c - 'a' + 1);\n\n        cost = Math.max(0, cost + value);\n        max_cost = Math.max(max_cost, cost);\n    }\n\n    return max_cost;\n}\n```\n\n    \n    1. Create a dictionary (hash_map/hash_table) to store the custom values of the characters provided in 'chars' and 'vals'.\n2. Initialize variables 'max_cost' and 'cost' to 0.\n3. Iterate through each character in the input string 's'.\n4. Inside the loop, calculate the value of the current character\n   - If it is in the custom values dictionary, use the custom value.\n   - If it is not in the custom values dictionary, use the position of the character in the alphabet (1-indexed).\n5. Update the cost by adding the value: `cost = max(0, cost + value)`. By setting it to max, we are taking into account the largest continuous substring cost.\n6. Update the max_cost with the maximum value between the current max_cost and the current cost.\n7. Return the max_cost after the loop ends.\n    ",
        "python": "\n    ```python\ndef max_value_substring(s, chars, vals):\n    values = {key: val for key, val in zip(chars, vals)}\n\n    max_cost = 0\n    cost = 0\n\n    for c in s:\n        value = values.get(c) if c in values else ord(c) - ord('a') + 1\n\n        cost = max(0, cost + value)\n        max_cost = max(max_cost, cost)\n\n    return max_cost\n```\n\n    \n    1. Create a dictionary (hash_map/hash_table) to store the custom values of the characters provided in 'chars' and 'vals'.\n2. Initialize variables 'max_cost' and 'cost' to 0.\n3. Iterate through each character in the input string 's'.\n4. Inside the loop, calculate the value of the current character\n   - If it is in the custom values dictionary, use the custom value.\n   - If it is not in the custom values dictionary, use the position of the character in the alphabet (1-indexed).\n5. Update the cost by adding the value: `cost = max(0, cost + value)`. By setting it to max, we are taking into account the largest continuous substring cost.\n6. Update the max_cost with the maximum value between the current max_cost and the current cost.\n7. Return the max_cost after the loop ends.\n    ",
        "c++": "\n    ```cpp\nint maxValueSubstring(std::string s, std::string chars, std::vector<int> vals) {\n    std::unordered_map<char, int> values;\n\n    for (int i = 0; i < chars.length(); i++) {\n        values[chars[i]] = vals[i];\n    }\n\n    int max_cost = 0;\n    int cost = 0;\n\n    for (char c : s) {\n        int value = values.count(c) ? values[c] : static_cast<int>(c - 'a' + 1);\n\n        cost = std::max(0, cost + value);\n        max_cost = std::max(max_cost, cost);\n    }\n\n    return max_cost;\n}\n```\n\n    \n    1. Create a dictionary (hash_map/hash_table) to store the custom values of the characters provided in 'chars' and 'vals'.\n2. Initialize variables 'max_cost' and 'cost' to 0.\n3. Iterate through each character in the input string 's'.\n4. Inside the loop, calculate the value of the current character\n   - If it is in the custom values dictionary, use the custom value.\n   - If it is not in the custom values dictionary, use the position of the character in the alphabet (1-indexed).\n5. Update the cost by adding the value: `cost = max(0, cost + value)`. By setting it to max, we are taking into account the largest continuous substring cost.\n6. Update the max_cost with the maximum value between the current max_cost and the current cost.\n7. Return the max_cost after the loop ends.\n    ",
        "js": "\n    ```javascript\nfunction maxValueSubstring(s, chars, vals) {\n    let values = {};\n\n    for (let i = 0; i < chars.length; i++) {\n        values[chars[i]] = vals[i];\n    }\n\n    let max_cost = 0;\n    let cost = 0;\n\n    for (let c of s) {\n        let value = c in values ? values[c] : (c.charCodeAt(0) - 'a'.charCodeAt(0) + 1);\n\n        cost = Math.max(0, cost + value);\n        max_cost = Math.max(max_cost, cost);\n    }\n\n    return max_cost;\n}\n```\n\n    \n    1. Create a dictionary (hash_map/hash_table) to store the custom values of the characters provided in 'chars' and 'vals'.\n2. Initialize variables 'max_cost' and 'cost' to 0.\n3. Iterate through each character in the input string 's'.\n4. Inside the loop, calculate the value of the current character\n   - If it is in the custom values dictionary, use the custom value.\n   - If it is not in the custom values dictionary, use the position of the character in the alphabet (1-indexed).\n5. Update the cost by adding the value: `cost = max(0, cost + value)`. By setting it to max, we are taking into account the largest continuous substring cost.\n6. Update the max_cost with the maximum value between the current max_cost and the current cost.\n7. Return the max_cost after the loop ends.\n    "
    }
]
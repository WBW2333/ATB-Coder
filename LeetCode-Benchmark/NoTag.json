[
    {
        "id": 1,
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"42 \" ( \"42 \" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n            ^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n             ^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"42\"",
                "output": "42"
            },
            {
                "input": "\"-42\"",
                "output": "-42"
            },
            {
                "input": "\"4193withwords\"",
                "output": "4193"
            }
        ],
        "java": "\n    ```java\npublic int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "python": "\n    ```python\ndef myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "c++": "\n    ```cpp\nint myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "js": "\n    ```javascript\nfunction myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    "
    },
    {
        "id": 2,
        "title": "Pow(x, n)",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculates `x` raised to the power `n` (i.e., `xn`).",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 2.00000, n = 10\n**Output:** 1024.00000\n\n",
                "**Example 2:**\n\n**Input:** x = 2.10000, n = 3\n**Output:** 9.26100\n\n",
                "**Example 3:**\n\n**Input:** x = 2.00000, n = -2\n**Output:** 0.25000\n**Explanation:** 2\\-2 = 1/22 = 1/4 = 0.25"
            ],
            "constraints": "**Constraints:**\n\n*   `-100.0 < x < 100.0`\n*   `-231 <= n <= 231-1`\n*   `n` is an integer.\n*   `-104 <= xn <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2.00000,10",
                "output": "1024.00000"
            },
            {
                "input": "2.10000,3",
                "output": "9.26100"
            },
            {
                "input": "2.00000,-2",
                "output": "0.25000"
            }
        ],
        "java": "\n    ```java\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long i = n; i > 0; i /= 2) {\n        if ((i % 2) == 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "python": "\n    ```python\ndef myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "c++": "\n    ```cpp\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "js": "\n    ```javascript\nfunction myPow(x, n) {\n    if (n === 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    let result = 1;\n    let currentProduct = x;\n    for (let i = n; i > 0; i = Math.floor(i / 2)) {\n        if (i % 2 === 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    "
    },
    {
        "id": 3,
        "title": "Sqrt(x)",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.\n\nYou **must not use** any built-in exponent function or operator.\n\n*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 4\n**Output:** 2\n**Explanation:** The square root of 4 is 2, so we return 2.\n\n",
                "**Example 2:**\n\n**Input:** x = 8\n**Output:** 2\n**Explanation:** The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= x <= 231 - 1`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "8",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "python": "\n    ```python\ndef mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "c++": "\n    ```cpp\nint mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "js": "\n    ```javascript\nfunction mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    "
    },
    {
        "id": 4,
        "title": "Pascal's Triangle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:",
            "examples": [
                "**Example 1:**\n\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= numRows <= 30`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5",
                "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
            },
            {
                "input": "1",
                "output": "[[1]]"
            }
        ],
        "java": "\n    ```java\npublic List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> pascalsTriangle = new ArrayList<>();\n    for (int i = 0; i < numRows; i++) {\n        List<Integer> row = new ArrayList<>();\n        row.add(1);\n        for (int j = 1; j < i; j++) {\n            row.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));\n        }\n        if (i > 0) row.add(1);\n        pascalsTriangle.add(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "python": "\n    ```python\ndef generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "c++": "\n    ```cpp\nvector<vector<int>> generate(int numRows) {\n    vector<vector<int>> pascalsTriangle(numRows);\n    for (int i = 0; i < numRows; i++) {\n        pascalsTriangle[i].resize(i + 1);\n        pascalsTriangle[i][0] = pascalsTriangle[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            pascalsTriangle[i][j] = pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j];\n        }\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "js": "\n    ```javascript\nfunction generate(numRows) {\n    const pascalsTriangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        for (let j = 1; j < i; j++) {\n            row.push(pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j]);\n        }\n        if (i > 0) row.push(1);\n        pascalsTriangle.push(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    "
    },
    {
        "id": 5,
        "title": "Pascal's Triangle II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:",
            "examples": [
                "**Example 1:**\n\n**Input:** rowIndex = 3\n**Output:** \\[1,3,3,1\\]\n\n",
                "**Example 2:**\n\n**Input:** rowIndex = 0\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** rowIndex = 1\n**Output:** \\[1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= rowIndex <= 33`\n\n**",
            "follow_up": "Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?"
        },
        "tag": [],
        "example": [
            {
                "input": "3",
                "output": "[1,3,3,1]"
            },
            {
                "input": "0",
                "output": "[1]"
            },
            {
                "input": "1",
                "output": "[1,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "python": "\n    ```python\ndef get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex) {\n    vector<int> row(rowIndex + 1, 1);\n    for (int i = 1; i <= rowIndex; i++) {\n        for (int j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "js": "\n    ```javascript\nfunction getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(1);\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    "
    },
    {
        "id": 6,
        "title": "Binary Tree Upside Down",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, turn the tree upside down and return _the new root_.\n\nYou can turn a binary tree upside down with the following steps:\n\n1.  The original left child becomes the new root.\n2.  The original root becomes the new right child.\n3.  The original right child becomes the new left child.\n\nThe mentioned steps are done level by level. It is **guaranteed** that every right node has a sibling (a left node with the same parent) and has no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5\\]\n**Output:** \\[4,5,2,null,null,3,1\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree will be in the range `[0, 10]`.\n*   `1 <= Node.val <= 10`\n*   Every right node in the tree has a sibling (a left node that shares the same parent).\n*   Every right node in the tree has no children.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5]",
                "output": "[4,5,2,null,null,3,1]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode upsideDownBinaryTree(TreeNode root) {\n    if (root == null || root.left == null) {\n        return root;\n    }\n    TreeNode new_root = upsideDownBinaryTree(root.left);\n    root.left.right = root;\n    root.left.left = root.right;\n    root.left = null;\n    root.right = null;\n    return new_root;\n}\n```\n    \n    The algorithm uses a recursive depth-first search approach to solve the problem. It checks if the root or the left child of the root is `null`. If either of them is `null`, the function returns the current root as the new root.\n\nThen, the algorithm calls itself recursively, passing the left child of the current root as the new argument, until it reaches the last node in the leftmost branch. This last node becomes the new root.\n\nAt each level of recursion, the algorithm updates the left and right children of the current root's left child to be the current root and the current root's right child, respectively. Then, it sets the current root's left and right children to `null`.\n\nFinally, it returns the new root at the end of the algorithm.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef upside_down_binary_tree(root):\n    if not root or not root.left:\n        return root\n    new_root = upside_down_binary_tree(root.left)\n    root.left.right = root\n    root.left.left = root.right\n    root.left = None\n    root.right = None\n    return new_root\n```\n    \n    The algorithm uses a recursive depth-first search approach to solve the problem. It checks if the root or the left child of the root is `null`. If either of them is `null`, the function returns the current root as the new root.\n\nThen, the algorithm calls itself recursively, passing the left child of the current root as the new argument, until it reaches the last node in the leftmost branch. This last node becomes the new root.\n\nAt each level of recursion, the algorithm updates the left and right children of the current root's left child to be the current root and the current root's right child, respectively. Then, it sets the current root's left and right children to `null`.\n\nFinally, it returns the new root at the end of the algorithm.\n    ",
        "c++": "\n    ```cpp\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* upsideDownBinaryTree(TreeNode* root) {\n    if (root == nullptr || root->left == nullptr) {\n        return root;\n    }\n    TreeNode* new_root = upsideDownBinaryTree(root->left);\n    root->left->right = root;\n    root->left->left = root->right;\n    root->left = nullptr;\n    root->right = nullptr;\n    return new_root;\n}\n```\n    \n    The algorithm uses a recursive depth-first search approach to solve the problem. It checks if the root or the left child of the root is `null`. If either of them is `null`, the function returns the current root as the new root.\n\nThen, the algorithm calls itself recursively, passing the left child of the current root as the new argument, until it reaches the last node in the leftmost branch. This last node becomes the new root.\n\nAt each level of recursion, the algorithm updates the left and right children of the current root's left child to be the current root and the current root's right child, respectively. Then, it sets the current root's left and right children to `null`.\n\nFinally, it returns the new root at the end of the algorithm.\n    ",
        "js": "\n    ```javascript\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n}\n\nfunction upsideDownBinaryTree(root) {\n    if (!root || !root.left) {\n        return root;\n    }\n    let new_root = upsideDownBinaryTree(root.left);\n    root.left.right = root;\n    root.left.left = root.right;\n    root.left = null;\n    root.right = null;\n    return new_root;\n}\n```\n    \n    The algorithm uses a recursive depth-first search approach to solve the problem. It checks if the root or the left child of the root is `null`. If either of them is `null`, the function returns the current root as the new root.\n\nThen, the algorithm calls itself recursively, passing the left child of the current root as the new argument, until it reaches the last node in the leftmost branch. This last node becomes the new root.\n\nAt each level of recursion, the algorithm updates the left and right children of the current root's left child to be the current root and the current root's right child, respectively. Then, it sets the current root's left and right children to `null`.\n\nFinally, it returns the new root at the end of the algorithm.\n    "
    },
    {
        "id": 7,
        "title": "Read N Characters Given Read4",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method to read `n` characters.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The `read` function will only be called once for each test case.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** file =  \"abc \", n = 4\n**Output:** 3\n**Explanation:** After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nNote that  \"abc \" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.\n\n",
                "**Example 2:**\n\n**Input:** file =  \"abcde \", n = 5\n**Output:** 5\n**Explanation:** After calling your read method, buf should contain  \"abcde \". We read a total of 5 characters from the file, so return 5.\n\n",
                "**Example 3:**\n\n**Input:** file =  \"abcdABCD1234 \", n = 12\n**Output:** 12\n**Explanation:** After calling your read method, buf should contain  \"abcdABCD1234 \". We read a total of 12 characters from the file, so return 12."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abc\",4",
                "output": "3"
            },
            {
                "input": "\"abcde\",5",
                "output": "5"
            },
            {
                "input": "\"abcdABCD1234\",12",
                "output": "12"
            }
        ],
        "java": "\n    ```java\npublic int read4(char[] buf4);\n\npublic int read(char[] buf, int n) {\n    int totalRead = 0;\n    char[] buf4 = new char[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; i++) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "python": "\n    ```python\ndef read4(buf4: List[str]) -> int:\n    pass\n\ndef read(buf: List[str], n: int) -> int:\n    total_read = 0\n    buf4 = [''] * 4\n\n    while total_read < n:\n        read4_count = read4(buf4)\n        for i in range(read4_count):\n            if total_read < n:\n                buf[total_read] = buf4[i]\n                total_read += 1\n            else:\n                break\n        if read4_count < 4:\n            break\n\n    return total_read\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "c++": "\n    ```cpp\nint read4(char *buf4);\n\nint read(char *buf, int n) {\n    int totalRead = 0;\n    char buf4[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "js": "\n    ```javascript\nfunction read4(buf4) {\n    // Implemented elsewhere\n}\n\nfunction read(buf, n) {\n    let totalRead = 0;\n    const buf4 = new Array(4);\n\n    while (totalRead < n) {\n        const read4Count = read4(buf4);\n        for(let i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    "
    },
    {
        "id": 8,
        "title": "Read N Characters Given read4 II - Call Multiple Times",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method `read` to read `n` characters. Your method `read` may be **called multiple times**.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The read function may be **called multiple times**.\n*   Please remember to **RESET** your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see [here](https://leetcode.com/faq/) for more details.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.\n*   It is guaranteed that in a given test case the same buffer `buf` is called by `read`.",
            "examples": [
                "**Example 1:**\n\n**Input:** file =  \"abc \", queries = \\[1,2,1\\]\n**Output:** \\[1,2,0\\]\n**Explanation:** The test case represents the following scenario:\nFile file( \"abc \");\nSolution sol;\nsol.read(buf, 1); // After calling your read method, buf should contain  \"a \". We read a total of 1 character from the file, so return 1.\nsol.read(buf, 2); // Now buf should contain  \"bc \". We read a total of 2 characters from the file, so return 2.\nsol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.\nAssume buf is allocated and guaranteed to have enough space for storing all characters from the file.\n\n",
                "**Example 2:**\n\n**Input:** file =  \"abc \", queries = \\[4,1\\]\n**Output:** \\[3,0\\]\n**Explanation:** The test case represents the following scenario:\nFile file( \"abc \");\nSolution sol;\nsol.read(buf, 4); // After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nsol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= queries.length <= 10`\n*   `1 <= queries[i] <= 500`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abc\",[1,2,1]",
                "output": "[1,2,0]"
            },
            {
                "input": "\"abc\",[4,1]",
                "output": "[3,0]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    private int buffer_index = 0;\n    private int buffer_len = 0;\n    private char[] buf4 = new char[4];\n\n    public int read(char[] buf, int n) {\n        int cnt = 0;\n        while (cnt < n) {\n            if (buffer_index == buffer_len) {\n                buffer_len = read4(buf4);\n                buffer_index = 0;\n            }\n            if (buffer_len == 0) break;\n            while (cnt < n && buffer_index < buffer_len) {\n                buf[cnt++] = buf4[buffer_index++];\n            }\n        }\n        return cnt;\n    }\n\n    //dummy method\n    private int read4(char[] buf4) {\n        return 0;\n    }\n}\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def __init__(self):\n        self.buffer_index = 0\n        self.buffer_len = 0\n        self.buf4 = [None] * 4\n\n    def read(self, buf, n):\n        cnt = 0\n        while cnt < n:\n            if self.buffer_index == self.buffer_len:\n                self.buffer_len = self.read4(self.buf4)\n                self.buffer_index = 0\n            if self.buffer_len == 0:\n                break\n            while cnt < n and self.buffer_index < self.buffer_len:\n                buf[cnt] = self.buf4[self.buffer_index]\n                cnt += 1\n                self.buffer_index += 1\n        return cnt\n\n    def read4(self, buf4):\n        return 0\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\n    int buffer_index = 0;\n    int buffer_len = 0;\n    char buf4[4];\n\npublic:\n    int read(char* buf, int n) {\n        int cnt = 0;\n        while (cnt < n) {\n            if (buffer_index == buffer_len) {\n                buffer_len = read4(buf4);\n                buffer_index = 0;\n            }\n            if (buffer_len == 0) break;\n            while (cnt < n && buffer_index < buffer_len) {\n                buf[cnt++] = buf4[buffer_index++];\n            }\n        }\n        return cnt;\n    }\n};\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    constructor() {\n        this.buffer_index = 0;\n        this.buffer_len = 0;\n        this.buf4 = new Array(4);\n    }\n\n    read(buf, n) {\n        let cnt = 0;\n        while (cnt < n) {\n            if (this.buffer_index === this.buffer_len) {\n                this.buffer_len = this.read4(this.buf4);\n                this.buffer_index = 0;\n            }\n            if (this.buffer_len === 0) break;\n            while (cnt < n && this.buffer_index < this.buffer_len) {\n                buf[cnt++] = this.buf4[this.buffer_index++];\n            }\n        }\n        return cnt;\n    }\n\n    read4(buf4) {\n        return 0;\n    }\n}\n```\n    \n    The algorithm uses a buffer `buf4` to store characters read from the `read4` method. We initialize two variables, `buffer_index` to keep track of the current position in `buf4` and `buffer_len` to store the number of characters read from `read4`.\n\nIn the `read` method, the first step is to check if we need to read more characters from `read4`. This is done by checking if `buffer_index` is equal to `buffer_len`. If it is, then we call `read4` and reset the `buffer_index` to 0.\n\nIf the number of characters read from `read4` is 0, then we have reached the end of the file, so we break out of the loop.\n\nNext, we copy the characters from `buf4` to the destination buffer `buf` until either we have read enough characters (`cnt` equals `n`), or there are no more characters to copy from `buf4` (`buffer_index` equals `buffer_len`). After copying characters, we increment `cnt` and `buffer_index` accordingly.\n\nWhen the loop is finished, the result is the total number of characters read, which is stored in `cnt`.\n    "
    },
    {
        "id": 9,
        "title": "Longest Substring with At Most Two Distinct Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"eceba \"\n**Output:** 3\n**Explanation:** The substring is  \"ece \" which its length is 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ccaabbb \"\n**Output:** 5\n**Explanation:** The substring is  \"aabbb \" which its length is 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"eceba\"",
                "output": "3"
            },
            {
                "input": "\"ccaabbb\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "python": "\n    ```python\ndef lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLongestSubstringTwoDistinct(string s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        char_count[s[r]]++;\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count[s[l]]--;\n                if (char_count[s[l]] == 0) {\n                    char_count.erase(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLongestSubstringTwoDistinct(s) {\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < s.length) {\n        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(s[l], char_count.get(s[l]) - 1);\n                if (char_count.get(s[l]) === 0) {\n                    char_count.delete(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    "
    },
    {
        "id": 10,
        "title": "One Edit Distance",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`.\n\nA string `s` is said to be one distance apart from a string `t` if you can:\n\n*   Insert **exactly one** character into `s` to get `t`.\n*   Delete **exactly one** character from `s` to get `t`.\n*   Replace **exactly one** character of `s` with **a different character** to get `t`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ab \", t =  \"acb \"\n**Output:** true\n**Explanation:** We can insert 'c' into s to get t.\n\n",
                "**Example 2:**\n\n**Input:** s =  \" \", t =  \" \"\n**Output:** false\n**Explanation:** We cannot get t from s by only one step."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length, t.length <= 104`\n*   `s` and `t` consist of lowercase letters, uppercase letters, and digits.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"ab\",\"acb\"",
                "output": "true"
            },
            {
                "input": "\"\",\"\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}\n```\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "python": "\n    ```python\ndef isOneEditDistance(s: str, t: str) -> bool:\n    m, n = len(s), len(t)\n    if m > n:\n        return isOneEditDistance(t, s)\n    if n - m > 1:\n        return False\n    for i in range(m):\n        if s[i] != t[i]:\n            return s[i + (m < n):] == t[i + 1:]\n    return m + 1 == n\n```\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}\n```\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "js": "\n    ```javascript\nfunction isOneEditDistance(s, t) {\n    let m = s.length, n = t.length;\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (let i = 0; i < m; ++i) {\n        if (s[i] !== t[i]) {\n            if (m < n) {\n                return s.slice(i) === t.slice(i + 1);\n            } else {\n                return s.slice(i + 1) === t.slice(i + 1);\n            }\n        }\n    }\n    return m + 1 === n;\n}\n```\n\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    "
    },
    {
        "id": 11,
        "title": "Missing Ranges",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an inclusive range `[lower, upper]` and a **sorted unique** integer array `nums`, where all elements are in the inclusive range.\n\nA number `x` is considered **missing** if `x` is in the range `[lower, upper]` and `x` is not in `nums`.\n\nReturn _the **smallest sorted** list of ranges that **cover every missing number exactly**_. That is, no element of `nums` is in any of the ranges, and each missing number is in one of the ranges.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,3,50,75\\], lower = 0, upper = 99\n**Output:** \\[ \"2 \", \"4->49 \", \"51->74 \", \"76->99 \"\\]\n**Explanation:** The ranges are:\n\\[2,2\\] -->  \"2 \"\n\\[4,49\\] -->  \"4->49 \"\n\\[51,74\\] -->  \"51->74 \"\n\\[76,99\\] -->  \"76->99 \"\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1\\], lower = -1, upper = -1\n**Output:** \\[\\]\n**Explanation:** There are no missing ranges since there are no missing numbers."
            ],
            "constraints": "**Constraints:**\n\n*   `-109 <= lower <= upper <= 109`\n*   `0 <= nums.length <= 100`\n*   `lower <= nums[i] <= upper`\n*   All the values of `nums` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,3,50,75],0,99",
                "output": "[\"2\",\"4->49\",\"51->74\",\"76->99\"]"
            },
            {
                "input": "[-1],-1,-1",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findMissingRanges(int[] nums, int lower, int upper) {\n    List<String> result = new ArrayList<>();\n    long prev = (long) lower - 1;\n\n    for (int i = 0; i <= nums.length; ++i) {\n        long cur = (i == nums.length) ? (long) upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.add(Long.toString(prev + 1) + (cur - prev == 2 ? \"\" : \"->\") + Long.toString(cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:\n    result = []\n    prev = lower - 1\n\n    for i, num in enumerate(nums + [upper + 1]):\n        if num - prev >= 2:\n            result.append(f\"{prev + 1}\" + (\"\" if num - prev == 2 else \"->\") + f\"{num - 1}\")\n        prev = num\n\n    return result\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findMissingRanges(std::vector<int>& nums, int lower, int upper) {\n    std::vector<std::string> result;\n    long prev = (long)lower - 1;\n\n    for (int i = 0; i <= nums.size(); ++i) {\n        long cur = (i == nums.size()) ? (long)upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.push_back(std::to_string(prev + 1) + (cur - prev == 2 ? \"\" : \"->\") + std::to_string(cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    ",
        "js": "\n    ```javascript\nfunction findMissingRanges(nums, lower, upper) {\n    let result = [];\n    let prev = lower - 1;\n\n    for (let i = 0; i <= nums.length; ++i) {\n        let cur = (i === nums.length) ? upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.push((prev + 1) + (cur - prev === 2 ? \"\" : \"->\") + (cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates over the nums array and keeps track of the previous number (initialized to lower - 1) keeping in mind that nums is a sorted unique array of elements in the range [lower, upper]. For each number, it checks the difference between the current number and the previous number. If the difference is greater or equal to 2, it adds a range to the result vector. Also, it checks whether the range length is equal to 2, in which case it will only print the starting value of the range, without the \"->\". At the end of the loop, it returns the list of ranges covering the missing numbers in the input range.\n    "
    },
    {
        "id": 12,
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** numbers = \\[2,7,11,15\\], target = 9\n**Output:** \\[1,2\\]\n**Explanation:** The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return \\[1, 2\\].\n\n",
                "**Example 2:**\n\n**Input:** numbers = \\[2,3,4\\], target = 6\n**Output:** \\[1,3\\]\n**Explanation:** The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return \\[1, 3\\].\n\n",
                "**Example 3:**\n\n**Input:** numbers = \\[\\-1,0\\], target = -1\n**Output:** \\[1,2\\]\n**Explanation:** The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return \\[1, 2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= numbers.length <= 3 * 104`\n*   `-1000 <= numbers[i] <= 1000`\n*   `numbers` is sorted in **non-decreasing order**.\n*   `-1000 <= target <= 1000`\n*   The tests are generated such that there is **exactly one solution**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,7,11,15],9",
                "output": "[1,2]"
            },
            {
                "input": "[2,3,4],6",
                "output": "[1,3]"
            },
            {
                "input": "[-1,0],-1",
                "output": "[1,2]"
            }
        ],
        "java": "\n    ```java\npublic int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return new int[]{left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{};\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "python": "\n    ```python\ndef twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int left = 0, right = numbers.size() - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return {left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return {};\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "js": "\n    ```javascript\nfunction twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    while (left < right) {\n        let current_sum = numbers[left] + numbers[right];\n        if (current_sum === target) {\n            return [left + 1, right + 1];\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return [];\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    "
    },
    {
        "id": 13,
        "title": "Two Sum III - Data structure design",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.\n\nImplement the `TwoSum` class:\n\n*   `TwoSum()` Initializes the `TwoSum` object, with an empty array initially.\n*   `void add(int number)` Adds `number` to the data structure.\n*   `boolean find(int value)` Returns `true` if there exists any pair of numbers whose sum is equal to `value`, otherwise, it returns `false`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"TwoSum \",  \"add \",  \"add \",  \"add \",  \"find \",  \"find \"\\]\n\\[\\[\\], \\[1\\], \\[3\\], \\[5\\], \\[4\\], \\[7\\]\\]\n**Output**\n\\[null, null, null, null, true, false\\]\n\n**Explanation**\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // \\[\\] --> \\[1\\]\ntwoSum.add(3);   // \\[1\\] --> \\[1,3\\]\ntwoSum.add(5);   // \\[1,3\\] --> \\[1,3,5\\]\ntwoSum.find(4);  // 1 + 3 = 4, return true\ntwoSum.find(7);  // No two integers sum up to 7, return false"
            ],
            "constraints": "**Constraints:**\n\n*   `-105 <= number <= 105`\n*   `-231 <= value <= 231 - 1`\n*   At most `104` calls will be made to `add` and `find`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,null,true,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass TwoSum {\n    private HashMap<Integer, Integer> nums;\n\n    public TwoSum() {\n        nums = new HashMap<>();\n    }\n\n    public void add(int number) {\n        nums.put(number, nums.getOrDefault(number, 0) + 1);\n    }\n\n    public boolean find(int value) {\n        for (Integer i : nums.keySet()) {\n            int complement = value - i;\n            if (nums.containsKey(complement)) {\n                if (i != complement || nums.get(i) > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    ",
        "python": "\n    ```python\nclass TwoSum:\n\n    def __init__(self):\n        self.nums = {}\n\n    def add(self, number: int) -> None:\n        if number in self.nums:\n            self.nums[number] += 1\n        else:\n            self.nums[number] = 1\n\n    def find(self, value: int) -> bool:\n        for num in self.nums:\n            target = value - num\n            if target in self.nums:\n                if target != num or self.nums[num] > 1:\n                    return True\n        return False\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    ",
        "c++": "\n    ```cpp\nclass TwoSum {\npublic:\n    unordered_map<int, int> m;\n\n    TwoSum() {\n\n    }\n\n    void add(int number) {\n        m[number]++;\n    }\n\n    bool find(int value) {\n        for (auto &pair : m) {\n            int num1 = pair.first;\n            int num2 = value - num1;\n            if (num1 == num2 && pair.second > 1 || num1 != num2 && m.count(num2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    ",
        "js": "\n    ```javascript\nclass TwoSum {\n    constructor() {\n        this.nums = {};\n    }\n\n    add(number) {\n        if (this.nums.hasOwnProperty(number)) {\n            this.nums[number]++;\n        } else {\n            this.nums[number] = 1;\n        }\n    }\n\n    find(value) {\n        for (let num in this.nums) {\n            let target = value - num;\n            if (this.nums.hasOwnProperty(target)) {\n                if (target !== num || this.nums[num] > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n    \n    We create a class `TwoSum` to represent the data structure. We use a hashmap (`unordered_map` in C++, `HashMap` in Java, dictionary in Python, and object in JavaScript) to store the numbers as keys and their counts as values. \n\nIn the `add` method, we simply increment the count of the number in the hashmap. \n\nIn the `find` method, we iterate through the keys of the hashmap. For each number, we calculate its complement (`value - number`). If the complement is present in the hashmap, we check two cases:\n1. If `number` and `complement` are the same, we need at least two occurrences of the number in the hashmap to form a pair.\n2. If `number` and `complement` are different, we have our required pair and return `true`.\n\nIf we go through the entire hashmap and don't find any pair that satisfies one of the above conditions, we return `false`.\n    "
    },
    {
        "id": 14,
        "title": "Reverse Words in a String II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a character array `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by a single space.\n\nYour code must solve the problem **in-place,** i.e. without allocating extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \\[\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"\\]\n**Output:** \\[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \\[\"a\"\\]\n**Output:** \\[\"a\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is an English letter (uppercase or lowercase), digit, or space `' '`.\n*   There is **at least one** word in `s`.\n*   `s` does not contain leading or trailing spaces.\n*   All the words in `s` are guaranteed to be separated by a single space.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"t\",\"h\",\"e\",\"\",\"s\",\"k\",\"y\",\"\",\"i\",\"s\",\"\",\"b\",\"l\",\"u\",\"e\"]",
                "output": "[\"b\",\"l\",\"u\",\"e\",\"\",\"i\",\"s\",\"\",\"s\",\"k\",\"y\",\"\",\"t\",\"h\",\"e\"]"
            },
            {
                "input": "[\"a\"]",
                "output": "[\"a\"]"
            }
        ],
        "java": "\n    ```java\npublic void reverseWords(char[] s) {\n    reverse(s, 0, s.length - 1);\n    int start = 0;\n    for (int i = 0; i <= s.length; i++) {\n        if (i == s.length || s[i] == ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n\nprivate void reverse(char[] s, int start, int end) {\n    while (start < end) {\n        char temp = s[start];\n        s[start++] = s[end];\n        s[end--] = temp;\n    }\n}\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "python": "\n    ```python\ndef reverseWords(s: list) -> None:\n    def reverse(s, start, end):\n        while start < end:\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n\n    reverse(s, 0, len(s)-1)\n    start = 0\n    for i, char in enumerate(s + [' ']):\n        if char == ' ':\n            reverse(s, start, i - 1)\n            start = i + 1\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "c++": "\n    ```cpp\nvoid reverseWords(vector<char>& s) {\n    reverse(s.begin(), s.end());\n    int start = 0, end;\n    while ((end = find(s.begin() + start, s.end(), ' ') - s.begin()) < s.size()) {\n        reverse(s.begin() + start, s.begin() + end);\n        start = end + 1;\n    }\n    reverse(s.begin() + start, s.end());\n}\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "js": "\n    ```javascript\nfunction reverseWords(s) {\n    function reverse(s, start, end) {\n        while (start < end) {\n            [s[start], s[end]] = [s[end], s[start]];\n            start++;\n            end--;\n        }\n    }\n\n    reverse(s, 0, s.length - 1);\n    let start = 0;\n    for (let i = 0; i <= s.length; i++) {\n        if (i === s.length || s[i] === ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    "
    },
    {
        "id": 15,
        "title": "Implement Trie (Prefix Tree)",
        "difficulty": "Medium",
        "content": {
            "problem": "A [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as \"try \") or **prefix tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n*   `Trie()` Initializes the trie object.\n*   `void insert(String word)` Inserts the string `word` into the trie.\n*   `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n*   `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Trie \",  \"insert \",  \"search \",  \"search \",  \"startsWith \",  \"insert \",  \"search \"\\]\n\\[\\[\\], \\[ \"apple \"\\], \\[ \"apple \"\\], \\[ \"app \"\\], \\[ \"app \"\\], \\[ \"app \"\\], \\[ \"app \"\\]\\]\n**Output**\n\\[null, null, true, false, true, null, true\\]\n\n**Explanation**\nTrie trie = new Trie();\ntrie.insert( \"apple \");\ntrie.search( \"apple \");   // return True\ntrie.search( \"app \");     // return False\ntrie.startsWith( \"app \"); // return True\ntrie.insert( \"app \");\ntrie.search( \"app \");     // return True"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length, prefix.length <= 2000`\n*   `word` and `prefix` consist only of lowercase English letters.\n*   At most `3 * 104` calls **in total** will be made to `insert`, `search`, and `startsWith`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],]]",
                "output": "**Output**\n[null,null,true,false,true,null,true]"
            }
        ],
        "java": "\n    ```java\nclass Trie {\n    private class TrieNode {\n        Map<Character, TrieNode> children;\n        boolean isEndOfWord;\n\n        public TrieNode() {\n            children = new HashMap<>();\n            isEndOfWord = false;\n        }\n    }\n\n    private final TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n        current.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            TrieNode node = current.children.get(c);\n            if (node == null) {\n                return false;\n            }\n            current = node;\n        }\n        return current.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode current = root;\n        for (char c : prefix.toCharArray()) {\n            TrieNode node = current.children.get(c);\n            if (node == null) {\n                return false;\n            }\n            current = node;\n        }\n        return true;\n    }\n}\n```\n    \n    The Trie data structure is implemented as a tree, where each node has a mapping of characters to their corresponding child nodes. Every node also has an `isEndOfWord` flag to indicate if any word ends at this node. \n\nThe `insert` function iterates through each character in a given word, adding new nodes to the tree if they don't already exist, and finally setting the `isEndOfWord` flag to true at the final node.\n\nThe `search` function follows the characters from the root of the Trie to the final node, returning false if any character does not map to a child node, otherwise returning the value of the `isEndOfWord` flag at the final node.\n\nThe `startsWith` function is similar to `search`, but returns true if a sequence of characters exists in the Trie, regardless of whether a word terminates at the final node.\n    ",
        "python": "\n    ```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n```\n    \n    The Trie data structure is implemented as a tree, where each node has a mapping of characters to their corresponding child nodes. Every node also has an `isEndOfWord` flag to indicate if any word ends at this node. \n\nThe `insert` function iterates through each character in a given word, adding new nodes to the tree if they don't already exist, and finally setting the `isEndOfWord` flag to true at the final node.\n\nThe `search` function follows the characters from the root of the Trie to the final node, returning false if any character does not map to a child node, otherwise returning the value of the `isEndOfWord` flag at the final node.\n\nThe `startsWith` function is similar to `search`, but returns true if a sequence of characters exists in the Trie, regardless of whether a word terminates at the final node.\n    ",
        "c++": "\n    ```cpp\nclass Trie {\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        bool isEndOfWord;\n    };\n\n    TrieNode *root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n        root->isEndOfWord = false;\n    }\n\n    void insert(string word) {\n        TrieNode *curr = root;\n        for (char c : word) {\n            if (curr->children.find(c) == curr->children.end()) {\n                curr->children[c] = new TrieNode();\n            }\n            curr = curr->children[c];\n        }\n        curr->isEndOfWord = true;\n    }\n\n    bool search(string word) {\n        TrieNode *curr = root;\n        for (char c : word) {\n            if (curr->children.find(c) == curr->children.end()) {\n                return false;\n            }\n            curr = curr->children[c];\n        }\n        return curr->isEndOfWord;\n    }\n\n    bool startsWith(string prefix) {\n        TrieNode *curr = root;\n        for (char c : prefix) {\n            if (curr->children.find(c) == curr->children.end()) {\n                return false;\n            }\n            curr = curr->children[c];\n        }\n        return true;\n    }\n};\n```\n    \n    The Trie data structure is implemented as a tree, where each node has a mapping of characters to their corresponding child nodes. Every node also has an `isEndOfWord` flag to indicate if any word ends at this node. \n\nThe `insert` function iterates through each character in a given word, adding new nodes to the tree if they don't already exist, and finally setting the `isEndOfWord` flag to true at the final node.\n\nThe `search` function follows the characters from the root of the Trie to the final node, returning false if any character does not map to a child node, otherwise returning the value of the `isEndOfWord` flag at the final node.\n\nThe `startsWith` function is similar to `search`, but returns true if a sequence of characters exists in the Trie, regardless of whether a word terminates at the final node.\n    ",
        "js": "\n    ```javascript\nclass TrieNode {\n    constructor() {\n        this.children = {};\n        this.isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(word) {\n        let node = this.root;\n        for (let char of word) {\n            if (!node.children[char]) {\n                node.children[char] = new TrieNode();\n            }\n            node = node.children[char];\n        }\n        node.isEndOfWord = true;\n    }\n\n    search(word) {\n        let node = this.root;\n        for (let char of word) {\n            node = node.children[char];\n            if (!node) {\n                return false;\n            }\n        }\n        return node.isEndOfWord;\n    }\n\n    startsWith(prefix) {\n        let node = this.root;\n        for (let char of prefix) {\n            node = node.children[char];\n            if (!node) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n    \n    The Trie data structure is implemented as a tree, where each node has a mapping of characters to their corresponding child nodes. Every node also has an `isEndOfWord` flag to indicate if any word ends at this node. \n\nThe `insert` function iterates through each character in a given word, adding new nodes to the tree if they don't already exist, and finally setting the `isEndOfWord` flag to true at the final node.\n\nThe `search` function follows the characters from the root of the Trie to the final node, returning false if any character does not map to a child node, otherwise returning the value of the `isEndOfWord` flag at the final node.\n\nThe `startsWith` function is similar to `search`, but returns true if a sequence of characters exists in the Trie, regardless of whether a word terminates at the final node.\n    "
    },
    {
        "id": 16,
        "title": "Shortest Word Distance",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, return _the shortest distance between these two words in the list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** wordsDict = \\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\], word1 =  \"coding \", word2 =  \"practice \"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** wordsDict = \\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\], word1 =  \"makes \", word2 =  \"coding \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= wordsDict.length <= 3 * 104`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.\n*   `word1 != word2`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"coding\",\"practice\"",
                "output": "3"
            },
            {
                "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"makes\",\"coding\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "python": "\n    ```python\ndef shortestDistance(wordsDict, word1, word2):\n    idx1, idx2, minDistance = -1, -1, float('inf')\n    for i, word in enumerate(wordsDict):\n        if word == word1:\n            idx1 = i\n        if word == word2:\n            idx2 = i\n        if idx1 != -1 and idx2 != -1:\n            minDistance = min(minDistance, abs(idx1 - idx2))\n    return minDistance\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) {\n    int idx1 = -1, idx2 = -1, minDistance = INT_MAX;\n    for (int i = 0; i < wordsDict.size(); i++) {\n        if (wordsDict[i] == word1) idx1 = i;\n        if (wordsDict[i] == word2) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = std::min(minDistance, std::abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "js": "\n    ```javascript\nfunction shortestDistance(wordsDict, word1, word2) {\n    let idx1 = -1, idx2 = -1, minDistance = Number.MAX_VALUE;\n    for (let i = 0; i < wordsDict.length; i++) {\n        if (wordsDict[i] === word1) idx1 = i;\n        if (wordsDict[i] === word2) idx2 = i;\n        if (idx1 !== -1 && idx2 !== -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    "
    },
    {
        "id": 17,
        "title": "Shortest Word Distance II",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.\n\nImplement the `WordDistance` class:\n\n*   `WordDistance(String[] wordsDict)` initializes the object with the strings array `wordsDict`.\n*   `int shortest(String word1, String word2)` returns the shortest distance between `word1` and `word2` in the array `wordsDict`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"WordDistance \",  \"shortest \",  \"shortest \"\\]\n\\[\\[\\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\]\\], \\[ \"coding \",  \"practice \"\\], \\[ \"makes \",  \"coding \"\\]\\]\n**Output**\n\\[null, 3, 1\\]\n\n**Explanation**\nWordDistance wordDistance = new WordDistance(\\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\]);\nwordDistance.shortest( \"coding \",  \"practice \"); // return 3\nwordDistance.shortest( \"makes \",  \"coding \");    // return 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= wordsDict.length <= 3 * 104`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.\n*   `word1 != word2`\n*   At most `5000` calls will be made to `shortest`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]",
                "output": "**Output**\n[null,3,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.ArrayList;\n\nclass WordDistance {\n    HashMap<String, ArrayList<Integer>> wordIndexes;\n\n    public WordDistance(String[] wordsDict) {\n        wordIndexes = new HashMap<>();\n        for (int i = 0; i < wordsDict.length; ++i) {\n            if (!wordIndexes.containsKey(wordsDict[i])) {\n                wordIndexes.put(wordsDict[i], new ArrayList<>());\n            }\n            wordIndexes.get(wordsDict[i]).add(i);\n        }\n    }\n\n    public int shortest(String word1, String word2) {\n        ArrayList<Integer> indexes1 = wordIndexes.get(word1);\n        ArrayList<Integer> indexes2 = wordIndexes.get(word2);\n        int i = 0, j = 0, min_dist = Integer.MAX_VALUE;\n\n        while (i < indexes1.size() && j < indexes2.size()) {\n            min_dist = Math.min(min_dist, Math.abs(indexes1.get(i) - indexes2.get(j)));\n            if (indexes1.get(i) < indexes2.get(j)) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return min_dist;\n    }\n}\n```    \n    The algorithm first initializes a hashmap during instantiation, with each unique word, in the array wordsDict, as keys, and their corresponding indexes (in wordsDict) as values. \n\nThe shortest() function accepts word1 and word2 as input arguments. The function is responsible for calculating and returning the minimum distance between the two input words in the given array wordsDict. To achieve that, it performs the following:\n\n1. Store the index arrays for word1 and word2 in variables `indexes1` and `indexes2`.\n2. Initialize variables `i` and `j` to 0, to iterate through the index arrays and initialize `min_dist` to the maximum value possible for the programming language.\n3. Perform a while loop with the condition that `i` and `j` are lesser than the length of the arrays `indexes1` and `indexes2`, respectively.\n4. Calculate `abs(indexes1[i] - indexes2[j])` and compare it against the current `min_dist`. If smaller, set `min_dist` to the new minimum distance.\n5. If `indexes1[i]` is lesser than `indexes2[j]`, then increment `i`, otherwise increment `j`.\n6. When the loop terminates, return `min_dist` which holds the shortest distance between the two input words in the array.\n    ",
        "python": "\n    ```python\nclass WordDistance:\n\n    def __init__(self, wordsDict):\n        self.word_indexes = {}\n        for i, word in enumerate(wordsDict):\n            if word not in self.word_indexes:\n                self.word_indexes[word] = []\n            self.word_indexes[word].append(i)\n\n    def shortest(self, word1, word2):\n        indexes1 = self.word_indexes[word1]\n        indexes2 = self.word_indexes[word2]\n        i, j, min_dist = 0, 0, float('inf')\n\n        while i < len(indexes1) and j < len(indexes2):\n            min_dist = min(min_dist, abs(indexes1[i] - indexes2[j]))\n            if indexes1[i] < indexes2[j]:\n                i += 1\n            else:\n                j += 1\n\n        return min_dist\n```    \n    The algorithm first initializes a hashmap during instantiation, with each unique word, in the array wordsDict, as keys, and their corresponding indexes (in wordsDict) as values. \n\nThe shortest() function accepts word1 and word2 as input arguments. The function is responsible for calculating and returning the minimum distance between the two input words in the given array wordsDict. To achieve that, it performs the following:\n\n1. Store the index arrays for word1 and word2 in variables `indexes1` and `indexes2`.\n2. Initialize variables `i` and `j` to 0, to iterate through the index arrays and initialize `min_dist` to the maximum value possible for the programming language.\n3. Perform a while loop with the condition that `i` and `j` are lesser than the length of the arrays `indexes1` and `indexes2`, respectively.\n4. Calculate `abs(indexes1[i] - indexes2[j])` and compare it against the current `min_dist`. If smaller, set `min_dist` to the new minimum distance.\n5. If `indexes1[i]` is lesser than `indexes2[j]`, then increment `i`, otherwise increment `j`.\n6. When the loop terminates, return `min_dist` which holds the shortest distance between the two input words in the array.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <string>\n\nclass WordDistance {\npublic:\n    WordDistance(std::vector<std::string>& wordsDict) {\n        for(int i = 0; i < wordsDict.size(); ++i) {\n            wordIndexes[wordsDict[i]].push_back(i);\n        }\n    }\n\n    int shortest(std::string word1, std::string word2) {\n        std::vector<int> indexes1 = wordIndexes[word1];\n        std::vector<int> indexes2 = wordIndexes[word2];\n        int i = 0, j = 0, min_dist = INT_MAX;\n\n        while(i < indexes1.size() && j < indexes2.size()) {\n            min_dist = std::min(min_dist, abs(indexes1[i] - indexes2[j]));\n            if(indexes1[i] < indexes2[j]) {\n                ++i;\n            }\n            else {\n                ++j;\n            }\n        }\n        return min_dist;\n    }\n\nprivate:\n    std::unordered_map<std::string, std::vector<int>> wordIndexes;\n};\n```    \n    The algorithm first initializes a hashmap during instantiation, with each unique word, in the array wordsDict, as keys, and their corresponding indexes (in wordsDict) as values. \n\nThe shortest() function accepts word1 and word2 as input arguments. The function is responsible for calculating and returning the minimum distance between the two input words in the given array wordsDict. To achieve that, it performs the following:\n\n1. Store the index arrays for word1 and word2 in variables `indexes1` and `indexes2`.\n2. Initialize variables `i` and `j` to 0, to iterate through the index arrays and initialize `min_dist` to the maximum value possible for the programming language.\n3. Perform a while loop with the condition that `i` and `j` are lesser than the length of the arrays `indexes1` and `indexes2`, respectively.\n4. Calculate `abs(indexes1[i] - indexes2[j])` and compare it against the current `min_dist`. If smaller, set `min_dist` to the new minimum distance.\n5. If `indexes1[i]` is lesser than `indexes2[j]`, then increment `i`, otherwise increment `j`.\n6. When the loop terminates, return `min_dist` which holds the shortest distance between the two input words in the array.\n    ",
        "js": "\n    ```javascript\nclass WordDistance {\n    constructor(wordsDict) {\n        this.wordIndexes = new Map();\n        for (let i = 0; i < wordsDict.length; ++i) {\n            if (!this.wordIndexes.has(wordsDict[i])) {\n                this.wordIndexes.set(wordsDict[i], []);\n            }\n            this.wordIndexes.get(wordsDict[i]).push(i);\n        }\n    }\n\n    shortest(word1, word2) {\n        const indexes1 = this.wordIndexes.get(word1);\n        const indexes2 = this.wordIndexes.get(word2);\n        let i = 0, j = 0, min_dist = Number.MAX_VALUE;\n\n        while (i < indexes1.length && j < indexes2.length) {\n            min_dist = Math.min(min_dist, Math.abs(indexes1[i] - indexes2[j]));\n            if (indexes1[i] < indexes2[j]) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return min_dist;\n    }\n}\n```    \n    The algorithm first initializes a hashmap during instantiation, with each unique word, in the array wordsDict, as keys, and their corresponding indexes (in wordsDict) as values. \n\nThe shortest() function accepts word1 and word2 as input arguments. The function is responsible for calculating and returning the minimum distance between the two input words in the given array wordsDict. To achieve that, it performs the following:\n\n1. Store the index arrays for word1 and word2 in variables `indexes1` and `indexes2`.\n2. Initialize variables `i` and `j` to 0, to iterate through the index arrays and initialize `min_dist` to the maximum value possible for the programming language.\n3. Perform a while loop with the condition that `i` and `j` are lesser than the length of the arrays `indexes1` and `indexes2`, respectively.\n4. Calculate `abs(indexes1[i] - indexes2[j])` and compare it against the current `min_dist`. If smaller, set `min_dist` to the new minimum distance.\n5. If `indexes1[i]` is lesser than `indexes2[j]`, then increment `i`, otherwise increment `j`.\n6. When the loop terminates, return `min_dist` which holds the shortest distance between the two input words in the array.\n    "
    },
    {
        "id": 18,
        "title": "Shortest Word Distance III",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return _the shortest distance between the occurrence of these two words in the list_.\n\n**Note** that `word1` and `word2` may be the same. It is guaranteed that they represent **two individual words** in the list.",
            "examples": [
                "**Example 1:**\n\n**Input:** wordsDict = \\[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"\\], word1 = \"makes\", word2 = \"coding\"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** wordsDict = \\[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"\\], word1 = \"makes\", word2 = \"makes\"\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= wordsDict.length <= 105`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"makes\",\"coding\"",
                "output": "1"
            },
            {
                "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"makes\",\"makes\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int index1 = -1, index2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i].equals(word1)) { index1 = i; }\n        if (wordsDict[i].equals(word2)) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "python": "\n    ```python\ndef shortest_distance(words_dict, word1, word2):\n    index1, index2, min_distance = -1, -1, float('inf')\n    for i, word in enumerate(words_dict):\n        if word == word1:\n            index1 = i\n        if word == word2:\n            index2 = i\n        if index1 != -1 and(index2 != -1):\n            min_distance = min(min_distance, abs(index1 - index2))\n    return min_distance\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <limits>\n\nint shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) {\n    int index1 = -1, index2 = -1, minDistance = std::numeric_limits<int>::max();\n    for (int i = 0; i < wordsDict.size(); ++i) {\n        if (wordsDict[i] == word1) { index1 = i; }\n        if (wordsDict[i] == word2) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = std::min(minDistance, std::abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "js": "\n    ```javascript\nfunction shortestDistance(wordsDict, word1, word2) {\n    let index1 = -1, index2 = -1, minDistance = Infinity;\n    for (let i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i] === word1) { index1 = i; }\n        if (wordsDict[i] === word2) { index2 = i; }\n        if (index1 !== -1 && index2 !== -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    "
    },
    {
        "id": 19,
        "title": "Strobogrammatic Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `num` which represents an integer, return `true` _if_ `num` _is a **strobogrammatic number**_.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"69 \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** num =  \"88 \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** num =  \"962 \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 50`\n*   `num` consists of only digits.\n*   `num` does not contain any leading zeros except for zero itself.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"69\"",
                "output": "true"
            },
            {
                "input": "\"88\"",
                "output": "true"
            },
            {
                "input": "\"962\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "python": "\n    ```python\ndef isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "c++": "\n    ```cpp\nbool isStrobogrammatic(string num) {\n    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int left = 0, right = num.size() - 1;\n    while(left <= right) {\n        if(lookup[num[left]] != num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "js": "\n    ```javascript\nfunction isStrobogrammatic(num) {\n    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};\n    let left = 0, right = num.length - 1;\n    while(left <= right) {\n        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    "
    },
    {
        "id": 20,
        "title": "Strobogrammatic Number II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return all the **strobogrammatic numbers** that are of length `n`. You may return the answer in **any order**.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[\"11\",\"69\",\"88\",\"96\"\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"0\",\"1\",\"8\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 14`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2",
                "output": "[\"11\",\"69\",\"88\",\"96\"]"
            },
            {
                "input": "1",
                "output": "[\"0\",\"1\",\"8\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<String> findStrobogrammatic(int n) {\n    return helper(n, n);\n}\n\nprivate List<String> helper(int n, int m) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n    \n    List<String> list = helper(n - 2, m);\n    List<String> res = new ArrayList<>();\n\n    for (int i = 0; i < list.size(); i++) {\n        String s = list.get(i);\n        \n        if (n != m) res.add(\"0\" + s + \"0\");\n\n        res.add(\"1\" + s + \"1\");\n        res.add(\"6\" + s + \"9\");\n        res.add(\"8\" + s + \"8\");\n        res.add(\"9\" + s + \"6\");\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "python": "\n    ```python\ndef findStrobogrammatic(n):\n    def helper(n, m):\n        if n == 0:\n            return [\"\"]\n        if n == 1:\n            return [\"0\", \"1\", \"8\"]\n\n        list = helper(n - 2, m)\n        res = []\n\n        for s in list:\n            if n != m:\n                res.append(\"0\" + s + \"0\")\n\n            res.append(\"1\" + s + \"1\")\n            res.append(\"6\" + s + \"9\")\n            res.append(\"8\" + s + \"8\")\n            res.append(\"9\" + s + \"6\")\n\n        return res\n\n    return helper(n, n)\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findStrobogrammatic(int n) {\n    return helper(n, n);\n}\n\nstd::vector<std::string> helper(int n, int m) {\n    if (n == 0) return {\"\"};\n    if (n == 1) return {\"0\", \"1\", \"8\"};\n    \n    std::vector<std::string> list = helper(n - 2, m);\n    std::vector<std::string> res;\n\n    for (int i = 0; i < list.size(); i++) {\n        std::string s = list[i];\n        \n        if (n != m) res.push_back(\"0\" + s + \"0\");\n\n        res.push_back(\"1\" + s + \"1\");\n        res.push_back(\"6\" + s + \"9\");\n        res.push_back(\"8\" + s + \"8\");\n        res.push_back(\"9\" + s + \"6\");\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "js": "\n    ```javascript\nfunction findStrobogrammatic(n) {\n    return helper(n, n);\n}\n\nfunction helper(n, m) {\n    if (n === 0) return [\"\"];\n    if (n === 1) return [\"0\", \"1\", \"8\"];\n    \n    const list = helper(n - 2, m);\n    const res = [];\n\n    for (let i = 0; i < list.length; i++) {\n        const s = list[i];\n\n        if (n !== m) res.push(\"0\" + s + \"0\");\n\n        res.push(\"1\" + s + \"1\");\n        res.push(\"6\" + s + \"9\");\n        res.push(\"8\" + s + \"8\");\n        res.push(\"9\" + s + \"6\");\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    "
    },
    {
        "id": 21,
        "title": "Strobogrammatic Number III",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings low and high that represent two integers `low` and `high` where `low <= high`, return _the number of **strobogrammatic numbers** in the range_ `[low, high]`.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** low = \"50\", high = \"100\"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** low = \"0\", high = \"0\"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= low.length, high.length <= 15`\n*   `low` and `high` consist of only digits.\n*   `low <= high`\n*   `low` and `high` do not contain any leading zeros except for zero itself.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"50\",\"100\"",
                "output": "3"
            },
            {
                "input": "\"0\",\"0\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int strobogrammaticInRange(String low, String high) {\n    int count = 0;\n    for(int len = low.length(); len <= high.length(); ++len)\n        count += withinRange(helper(len, len), low, high) ? 1 : 0;\n    return count;\n}\n\nprivate String helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    String res = \"\";\n    for(String a : helper(m - 2, n).split(\" \")) {\n        if(m != n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n\nprivate boolean withinRange(String num, String low, String high) {\n    if(num.length() > low.length()) return num.compareTo(high) <= 0;\n    if(num.length() < low.length()) return num.compareTo(low) >= 0;\n    return num.compareTo(low) >= 0 && num.compareTo(high) <= 0;\n}\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "python": "\n    ```python\ndef strobogrammaticInRange(low, high):\n    count = 0\n    for len in range(len(low), len(high)+1):\n        count += 1 if low <= helper(len, len) <= high else 0\n    return count\n\ndef helper(m, n):\n    if m == 0:\n        return \"\"\n    if m == 1:\n        return \"0 1 8\"\n    if n == 0:\n        return \"11 69 88 96\"\n    res = \"\"\n    for a in helper(m-2, n).split():\n        if m != n:\n            res += a + \"0\" + a + \" \"\n        res += a + \"1\" + a + \" \"\n        res += a + \"6\" + a + \" \"\n        res += a + \"8\" + a + \" \"\n        res += a + \"9\" + a + \" \"\n    return res\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "c++": "\n    ```cpp\nint strobogrammaticInRange(string low, string high) {\n    int count = 0;\n    for(int len = low.size(); len <= high.size(); ++len)\n        count += helper(len, len) <= high ? helper(len, len) >= low ? 1 : 0 : 0;\n    return count;\n}\n\nstring helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    string res = \"\";\n    for(auto a : helper(m - 2, n)) {\n        if(m != n) res += a + \"0\" + a;\n        res += a + \"1\" + a;\n        res += a + \"6\" + a;\n        res += a + \"8\" + a;\n        res += a + \"9\" + a;\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "js": "\n    ```javascript\nfunction strobogrammaticInRange(low, high) {\n    let count = 0;\n    for (let len = low.length; len <= high.length; ++len) {\n        const num = helper(len, len);\n        count += (num >= low && num <= high) ? 1 : 0;\n    }\n    return count;\n}\n\nfunction helper(m, n) {\n    if (m === 0) return \"\";\n    if (m === 1) return \"0 1 8\";\n    if (n === 0) return \"11 69 88 96\";\n    let res = \"\";\n    for (const a of helper(m - 2, n).split(\" \")) {\n        if (m !== n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    "
    },
    {
        "id": 22,
        "title": "Group Shifted Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "We can shift a string by shifting each of its letters to its successive letter.\n\n*   For example, `\"abc \"` can be shifted to be `\"bcd \"`.\n\nWe can keep shifting the string to form a sequence.\n\n*   For example, we can keep shifting `\"abc \"` to form the sequence: `\"abc \" -> \"bcd \" -> ... -> \"xyz \"`.\n\nGiven an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** strings = \\[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"\\]\n**Output:** \\[\\[\"acef\"\\],\\[\"a\",\"z\"\\],\\[\"abc\",\"bcd\",\"xyz\"\\],\\[\"az\",\"ba\"\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** strings = \\[\"a\"\\]\n**Output:** \\[\\[\"a\"\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strings.length <= 200`\n*   `1 <= strings[i].length <= 50`\n*   `strings[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]",
                "output": "[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]"
            },
            {
                "input": "[\"a\"]",
                "output": "[[\"a\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> groupStrings(String[] strings) {\n    Map<String, List<String>> map = new HashMap<>();\n\n    for (String s : strings) {\n        StringBuilder key = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            key.append((c - s.charAt(0) + 26) % 26).append(\",\");\n        }\n        String keyStr = key.toString();\n        map.putIfAbsent(keyStr, new ArrayList<>());\n        map.get(keyStr).add(s);\n    }\n\n    return new ArrayList<>(map.values());\n}\n```\n    \n    The idea is to create a unique key for each group of strings, that depends on the relative distances between characters in a string. We iterate through the given strings and create the key for each string by taking the difference between the ASCII code of each character and that of the first character, modulo 26. We add these deltas as comma-separated elements and use them as the key in a map. Where a map is a hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript. For each string, we append it to the list of strings corresponding to its group (key) in the map.\n\nAfter iterating through all the strings, we return the list of groups from the map.\n\nNote that the modulo operation and `<code>26</code>` come from the number of lowercase English letters which is 26. So, any shift greater than 25 will simply wrap around to the initial letters.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef groupStrings(strings):\n    groups = defaultdict(list)\n\n    for s in strings:\n        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)\n        groups[key].append(s)\n\n    return list(groups.values())\n```\n    \n    The idea is to create a unique key for each group of strings, that depends on the relative distances between characters in a string. We iterate through the given strings and create the key for each string by taking the difference between the ASCII code of each character and that of the first character, modulo 26. We add these deltas as comma-separated elements and use them as the key in a map. Where a map is a hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript. For each string, we append it to the list of strings corresponding to its group (key) in the map.\n\nAfter iterating through all the strings, we return the list of groups from the map.\n\nNote that the modulo operation and `<code>26</code>` come from the number of lowercase English letters which is 26. So, any shift greater than 25 will simply wrap around to the initial letters.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) {\n    std::unordered_map<std::string, std::vector<std::string>> map;\n    \n    for (const auto& s : strings) {\n        std::string key;\n        for (char c : s) {\n            key += std::to_string((c - s[0] + 26) % 26) + \",\";\n        }\n        map[key].push_back(s);\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    for (auto& kv : map) {\n        result.push_back(kv.second);\n    }\n    \n    return result;\n}\n```\n    \n    The idea is to create a unique key for each group of strings, that depends on the relative distances between characters in a string. We iterate through the given strings and create the key for each string by taking the difference between the ASCII code of each character and that of the first character, modulo 26. We add these deltas as comma-separated elements and use them as the key in a map. Where a map is a hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript. For each string, we append it to the list of strings corresponding to its group (key) in the map.\n\nAfter iterating through all the strings, we return the list of groups from the map.\n\nNote that the modulo operation and `<code>26</code>` come from the number of lowercase English letters which is 26. So, any shift greater than 25 will simply wrap around to the initial letters.\n    ",
        "js": "\n    ```javascript\nfunction groupStrings(strings) {\n    const map = new Map();\n\n    for (const s of strings) {\n        let key = '';\n        for (const c of s) {\n            key += `${(c.charCodeAt(0) - s.charCodeAt(0) + 26) % 26},`;\n        }\n        if (!map.has(key)) {\n            map.set(key, []);\n        }\n        map.get(key).push(s);\n    }\n\n    return Array.from(map.values());\n}\n```\n    \n    The idea is to create a unique key for each group of strings, that depends on the relative distances between characters in a string. We iterate through the given strings and create the key for each string by taking the difference between the ASCII code of each character and that of the first character, modulo 26. We add these deltas as comma-separated elements and use them as the key in a map. Where a map is a hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript. For each string, we append it to the list of strings corresponding to its group (key) in the map.\n\nAfter iterating through all the strings, we return the list of groups from the map.\n\nNote that the modulo operation and `<code>26</code>` come from the number of lowercase English letters which is 26. So, any shift greater than 25 will simply wrap around to the initial letters.\n    "
    },
    {
        "id": 23,
        "title": "Count Univalue Subtrees",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the number of **uni-value**_ _subtrees_.\n\nA **uni-value subtree** means all nodes of the subtree have the same value.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,1,5,5,5,null,5\\]\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** root = \\[5,5,5,5,5,null,5\\]\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   The number of the node in the tree will be in the range `[0, 1000]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,1,5,5,5,null,5]",
                "output": "4"
            },
            {
                "input": "[]",
                "output": "0"
            },
            {
                "input": "[5,5,5,5,5,null,5]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public int countUnivalSubtrees(TreeNode root) {\n        return helper(root, new int[1]);\n    }\n    \n    private boolean helper(TreeNode node, int[] count) {\n        if (node == null) return true;\n        \n        boolean left = helper(node.left, count);\n        boolean right = helper(node.right, count);\n        \n        if (left && right) {\n            if (node.left != null && node.val != node.left.val) return false;\n            if (node.right != null && node.val != node.right.val) return false;\n            count[0]++;\n            return true;\n        }\n        \n        return false;\n    }\n}\n```\n    \n    The algorithm uses a recursive helper function `helper()`. This helper function takes a TreeNode and it returns a boolean value. This value indicates if the current subtree (rooted at the node) is a unival subtree or not. While doing this, it also updates the count of unival subtrees encountered.\n\n1. If the current node is `null`, it returns `true`. This means that an empty tree is considered  a unival tree.\n\n2. We recursively call the helper function for the left and right nodes of the current node.\n\n3. If both left and right subtrees return `true`, it means that they are both unival subtrees. Then, we check if the current node forms a unival subtree by comparing its value with the left and right child nodes when they are not `null`. If the values are the same, we increment the count and return `true` for the current node.\n\n4. If either of the left or right subtree is not unival, we return `false` for the current node.\n\nFinally, we return the count of unival subtrees found during the traversal of the entire tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def countUnivalSubtrees(self, root: TreeNode) -> int:\n        count = 0\n\n        def helper(node):\n            nonlocal count\n            if node is None:\n                return True\n\n            left = helper(node.left)\n            right = helper(node.right)\n\n            if left and right:\n                if node.left and node.val != node.left.val:\n                    return False\n                if node.right and node.val != node.right.val:\n                    return False\n                count += 1\n                return True\n\n            return False\n\n        helper(root)\n        return count\n```\n    \n    The algorithm uses a recursive helper function `helper()`. This helper function takes a TreeNode and it returns a boolean value. This value indicates if the current subtree (rooted at the node) is a unival subtree or not. While doing this, it also updates the count of unival subtrees encountered.\n\n1. If the current node is `null`, it returns `true`. This means that an empty tree is considered  a unival tree.\n\n2. We recursively call the helper function for the left and right nodes of the current node.\n\n3. If both left and right subtrees return `true`, it means that they are both unival subtrees. Then, we check if the current node forms a unival subtree by comparing its value with the left and right child nodes when they are not `null`. If the values are the same, we increment the count and return `true` for the current node.\n\n4. If either of the left or right subtree is not unival, we return `false` for the current node.\n\nFinally, we return the count of unival subtrees found during the traversal of the entire tree.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int countUnivalSubtrees(TreeNode* root) {\n        int count = 0;\n        helper(root, count);\n        return count;\n    }\n    \n    bool helper(TreeNode* node, int& count) {\n        if (!node) return true;\n        \n        bool left = helper(node->left, count);\n        bool right = helper(node->right, count);\n        \n        if (left && right) {\n            if (node->left && node->val != node->left->val) return false;\n            if (node->right && node->val != node->right->val) return false;\n            count++;\n            return true;\n        }\n        \n        return false;\n    }\n};\n```\n    \n    The algorithm uses a recursive helper function `helper()`. This helper function takes a TreeNode and it returns a boolean value. This value indicates if the current subtree (rooted at the node) is a unival subtree or not. While doing this, it also updates the count of unival subtrees encountered.\n\n1. If the current node is `null`, it returns `true`. This means that an empty tree is considered  a unival tree.\n\n2. We recursively call the helper function for the left and right nodes of the current node.\n\n3. If both left and right subtrees return `true`, it means that they are both unival subtrees. Then, we check if the current node forms a unival subtree by comparing its value with the left and right child nodes when they are not `null`. If the values are the same, we increment the count and return `true` for the current node.\n\n4. If either of the left or right subtree is not unival, we return `false` for the current node.\n\nFinally, we return the count of unival subtrees found during the traversal of the entire tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nconst countUnivalSubtrees = (root) => {\n    let count = 0;\n\n    const helper = (node) => {\n        if (node === null) return true;\n\n        const left = helper(node.left);\n        const right = helper(node.right);\n\n        if (left && right) {\n            if (node.left && node.val !== node.left.val) return false;\n            if (node.right && node.val !== node.right.val) return false;\n\n            count++;\n            return true;\n        }\n\n        return false;\n    };\n\n    helper(root);\n    return count;\n};\n```\n    \n    The algorithm uses a recursive helper function `helper()`. This helper function takes a TreeNode and it returns a boolean value. This value indicates if the current subtree (rooted at the node) is a unival subtree or not. While doing this, it also updates the count of unival subtrees encountered.\n\n1. If the current node is `null`, it returns `true`. This means that an empty tree is considered  a unival tree.\n\n2. We recursively call the helper function for the left and right nodes of the current node.\n\n3. If both left and right subtrees return `true`, it means that they are both unival subtrees. Then, we check if the current node forms a unival subtree by comparing its value with the left and right child nodes when they are not `null`. If the values are the same, we increment the count and return `true` for the current node.\n\n4. If either of the left or right subtree is not unival, we return `false` for the current node.\n\nFinally, we return the count of unival subtrees found during the traversal of the entire tree.\n    "
    },
    {
        "id": 24,
        "title": "Flatten 2D Vector",
        "difficulty": "Medium",
        "content": {
            "problem": "Design an iterator to flatten a 2D vector. It should support the `next` and `hasNext` operations.\n\nImplement the `Vector2D` class:\n\n*   `Vector2D(int[][] vec)` initializes the object with the 2D vector `vec`.\n*   `next()` returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to `next` are valid.\n*   `hasNext()` returns `true` if there are still some elements in the vector, and `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Vector2D \",  \"next \",  \"next \",  \"next \",  \"hasNext \",  \"hasNext \",  \"next \",  \"hasNext \"\\]\n\\[\\[\\[\\[1, 2\\], \\[3\\], \\[4\\]\\]\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, 1, 2, 3, true, true, 4, false\\]\n\n**Explanation**\nVector2D vector2D = new Vector2D(\\[\\[1, 2\\], \\[3\\], \\[4\\]\\]);\nvector2D.next();    // return 1\nvector2D.next();    // return 2\nvector2D.next();    // return 3\nvector2D.hasNext(); // return True\nvector2D.hasNext(); // return True\nvector2D.next();    // return 4\nvector2D.hasNext(); // return False"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= vec.length <= 200`\n*   `0 <= vec[i].length <= 500`\n*   `-500 <= vec[i][j] <= 500`\n*   At most `105` calls will be made to `next` and `hasNext`.\n\n**",
            "follow_up": "Follow up:** As an added challenge, try to code it using only [iterators in C++](http://www.cplusplus.com/reference/iterator/iterator/) or [iterators in Java](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)."
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],]]],[],[],[],[],[],[],[]]",
                "output": "**Output**\n[null,1,2,3,true,true,4,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Vector2D implements Iterator<Integer> {\n    private Iterator<List<Integer>> i;\n    private Iterator<Integer> j;\n\n    public Vector2D(List<List<Integer>> vec) {\n        i = vec.iterator();\n        if (i.hasNext()) {\n            j = i.next().iterator();\n        }\n    }\n\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            return null;\n        }\n        return j.next();\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (j == null) {\n            return false;\n        }\n\n        while (!j.hasNext() && i.hasNext()) {\n            j = i.next().iterator();\n        }\n\n        return j.hasNext();\n    }\n}\n```\n\n    \n    The algorithm is quite straightforward. We track the indices `row` and `col` for traversal. In C++ and Java implementations, iterators are used for the same purpose.\n\n1. In the constructor, we initialize the 2D vector and set the initial row and columns to zero.\n\n2. In the `next()` function, we return the value corresponding to the indices (or iterators) and increment the column (or iterator) by 1.\n\n3. In the `hasNext()` function, we check if we have a valid element and if not, we try to move forward to the next row (or iterator) and reset the column (or iterator) to 0. This process continues until we find a valid element, or we reach the end of the 2D vector. If a valid element is found, it returns true. Otherwise, it returns false.\n    ",
        "python": "\n    ```python\nclass Vector2D:\n    def __init__(self, vec):\n        self.vec = vec\n        self.row = 0\n        self.col = 0\n\n    def next(self):\n        val = self.vec[self.row][self.col]\n        self.col += 1\n        return val\n\n    def hasNext(self):\n        while self.row < len(self.vec):\n            if self.col < len(self.vec[self.row]):\n                return True\n            self.row += 1\n            self.col = 0\n        return False\n```\n\n    \n    The algorithm is quite straightforward. We track the indices `row` and `col` for traversal. In C++ and Java implementations, iterators are used for the same purpose.\n\n1. In the constructor, we initialize the 2D vector and set the initial row and columns to zero.\n\n2. In the `next()` function, we return the value corresponding to the indices (or iterators) and increment the column (or iterator) by 1.\n\n3. In the `hasNext()` function, we check if we have a valid element and if not, we try to move forward to the next row (or iterator) and reset the column (or iterator) to 0. This process continues until we find a valid element, or we reach the end of the 2D vector. If a valid element is found, it returns true. Otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nclass Vector2D {\npublic:\n    vector<vector<int>>::iterator i, i_end;\n    int j = 0;\n\n    Vector2D(vector<vector<int>>& vec) {\n        i = vec.begin();\n        i_end = vec.end();\n    }\n    \n    int next() {\n        hasNext();\n        return (*i)[j++];\n    }\n    \n    bool hasNext() {\n        while (i != i_end && j == (*i).size()) {\n            ++i;\n            j = 0;\n        }\n        return i != i_end;\n    }\n};\n```\n\n    \n    The algorithm is quite straightforward. We track the indices `row` and `col` for traversal. In C++ and Java implementations, iterators are used for the same purpose.\n\n1. In the constructor, we initialize the 2D vector and set the initial row and columns to zero.\n\n2. In the `next()` function, we return the value corresponding to the indices (or iterators) and increment the column (or iterator) by 1.\n\n3. In the `hasNext()` function, we check if we have a valid element and if not, we try to move forward to the next row (or iterator) and reset the column (or iterator) to 0. This process continues until we find a valid element, or we reach the end of the 2D vector. If a valid element is found, it returns true. Otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nclass Vector2D {\n    constructor(vec) {\n        this.vec = vec;\n        this.row = 0;\n        this.col = 0;\n    }\n\n    next() {\n        const val = this.vec[this.row][this.col];\n        this.col++;\n        return val;\n    }\n\n    hasNext() {\n        while (this.row < this.vec.length) {\n            if (this.col < this.vec[this.row].length) {\n                return true;\n            }\n            this.row++;\n            this.col = 0;\n        }\n        return false;\n    }\n}\n```\n\n    \n    The algorithm is quite straightforward. We track the indices `row` and `col` for traversal. In C++ and Java implementations, iterators are used for the same purpose.\n\n1. In the constructor, we initialize the 2D vector and set the initial row and columns to zero.\n\n2. In the `next()` function, we return the value corresponding to the indices (or iterators) and increment the column (or iterator) by 1.\n\n3. In the `hasNext()` function, we check if we have a valid element and if not, we try to move forward to the next row (or iterator) and reset the column (or iterator) to 0. This process continues until we find a valid element, or we reach the end of the 2D vector. If a valid element is found, it returns true. Otherwise, it returns false.\n    "
    },
    {
        "id": 25,
        "title": "Meeting Rooms",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,30],[5,10],[15,20]]",
                "output": "false"
            },
            {
                "input": "[[7,10],[2,4]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    for (int i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "python": "\n    ```python\ndef can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    \n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "js": "\n    ```javascript\nfunction canAttendMeetings(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    "
    },
    {
        "id": 26,
        "title": "Meeting Rooms II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of conference rooms required_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `0 <= starti < endi <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,30],[5,10],[15,20]]",
                "output": "2"
            },
            {
                "input": "[[7,10],[2,4]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(),\n              [](const std::vector<int>& a, const std::vector<int>& b) { return a[0] < b[0]; });\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    min_heap.push(intervals[0][1]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] >= min_heap.top()) {\n            min_heap.pop();\n        }\n        min_heap.push(intervals[i][1]);\n    }\n\n    return min_heap.size();\n}\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    ",
        "js": "\n    ```javascript\nfunction minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const minHeap = [intervals[0][1]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap[0]) {\n            minHeap.shift();\n        }\n        minHeap.push(intervals[i][1]);\n        minHeap.sort((a, b) => a - b);\n    }\n\n    return minHeap.length;\n}\n```\n    \n    1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required.\n    "
    },
    {
        "id": 27,
        "title": "Factor Combinations",
        "difficulty": "Medium",
        "content": {
            "problem": "Numbers can be regarded as the product of their factors.\n\n*   For example, `8 = 2 x 2 x 2 = 2 x 4`.\n\nGiven an integer `n`, return _all possible combinations of its factors_. You may return the answer in **any order**.\n\n**Note** that the factors should be in the range `[2, n - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** \\[\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 12\n**Output:** \\[\\[2,6\\],\\[3,4\\],\\[2,2,3\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 37\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 107`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1",
                "output": "[]"
            },
            {
                "input": "12",
                "output": "[[2,6],[3,4],[2,2,3]]"
            },
            {
                "input": "37",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "python": "\n    ```python\ndef getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "js": "\n    ```javascript\nfunction getFactors(n) {\n    const result = [];\n    const helper = (n, start, path) => {\n        if (n === 1) {\n            if (path.length > 1) {\n                result.push([...path]);\n            }\n            return;\n        }\n\n        for (let i = start; i <= n; i++) {\n            if (n % i === 0) {\n                path.push(i);\n                helper(n / i, i, path);\n                path.pop();\n            }\n        }\n    };\n\n    helper(n, 2, []);\n    return result;\n}\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    "
    },
    {
        "id": 28,
        "title": "Verify Preorder Sequence in Binary Search Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of **unique** integers `preorder`, return `true` _if it is the correct preorder traversal sequence of a binary search tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** preorder = \\[5,2,1,3,6\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** preorder = \\[5,2,6,1,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= preorder.length <= 104`\n*   `1 <= preorder[i] <= 104`\n*   All the elements of `preorder` are **unique**.\n\n**",
            "follow_up": "Follow up:** Could you do it using only constant space complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "[5,2,1,3,6]",
                "output": "true"
            },
            {
                "input": "[5,2,6,1,3]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isValidPreorder(int[] preorder) {\n    Stack<Integer> stack = new Stack<>();\n    int lowerBound = Integer.MIN_VALUE;\n    for (int num : preorder) {\n        if (num < lowerBound) return false;\n        while (!stack.isEmpty() && num > stack.peek()) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "python": "\n    ```python\ndef isValidPreorder(preorder: List[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "c++": "\n    ```cpp\nbool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "js": "\n    ```javascript\nvar isValidPreorder = function(preorder) {\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n};\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    "
    },
    {
        "id": 29,
        "title": "Paint House",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n\n",
                "**Example 2:**\n\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[17,2,17],[16,16,5],[14,3,19]]",
                "output": "10"
            },
            {
                "input": "[[7,6,2]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minCost(int[][] costs) {\n    if (costs.length == 0) return 0;\n    for (int i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], Math.min(costs[costs.length - 1][1], costs[costs.length - 1][2]));\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "python": "\n    ```python\ndef minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n    for (int i = 1; i < costs.size(); ++i) {\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return min(costs.back()[0], min(costs.back()[1], costs.back()[2]));\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "js": "\n    ```javascript\nfunction minCost(costs) {\n    if (costs.length === 0) return 0;\n    for (let i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1], costs[costs.length - 1][2]);\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    "
    },
    {
        "id": 30,
        "title": "3Sum Smaller",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,0,1,3\\], target = 2\n**Output:** 2\n**Explanation:** Because there are two triplets which sums are less than 2:\n\\[-2,0,1\\]\n\\[-2,0,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0\\], target = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `0 <= n <= 3500`\n*   `-100 <= nums[i] <= 100`\n*   `-100 <= target <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[-2,0,1,3],2",
                "output": "2"
            },
            {
                "input": "[],0",
                "output": "0"
            },
            {
                "input": "[0],0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int threeSumSmaller(int[] nums, int target) {\n    int count = 0;\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length; ++i) {\n        int j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "python": "\n    ```python\ndef threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "c++": "\n    ```cpp\nint threeSumSmaller(vector<int>& nums, int target) {\n    int count = 0;\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < nums.size(); ++i) {\n        int j = i + 1, k = nums.size() - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "js": "\n    ```javascript\nfunction threeSumSmaller(nums, target) {\n    let count = 0;\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; ++i) {\n        let j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    "
    },
    {
        "id": 31,
        "title": "Graph Valid Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer n and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.\n\nReturn `true` _if the edges of the given graph make up a valid tree, and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[1,4\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[1,3\\],\\[1,4\\]\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `0 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   There are no self-loops or repeated edges.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,1],[0,2],[0,3],[1,4]]",
                "output": "true"
            },
            {
                "input": "5,[[0,1],[1,2],[2,3],[1,3],[1,4]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic boolean isTree(int n, int[][] edges) {\n    List<List<Integer>> neighbors = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) neighbors.add(new ArrayList<>());\n    for (int[] edge : edges) {\n        neighbors.get(edge[0]).add(edge[1]);\n        neighbors.get(edge[1]).add(edge[0]);\n    }\n    boolean[] visited = new boolean[n];\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (boolean visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nprivate boolean hasCycle(List<List<Integer>> neighbors, boolean[] visited, int parent, int node) {\n    visited[node] = true;\n    for (int neighbor : neighbors.get(node))\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to traverse the given graph. During traversal, it checks if there is a cycle (a node visited more than once). A valid tree should not have any cycles, and all nodes must be reachable.\n\n1. Create a list of neighbors for each node.\n2. Initialize a visited array to keep track of visited nodes.\n3. Call the 'hasCycle' function to perform DFS and also check the existence of a cycle.\n4. If a cycle exists, return false.\n5. If all nodes have not been visited, return false.\n6. If there is no cycle and all nodes have been visited, return true.\n\nThe 'hasCycle' function checks for the cycle recursively. When visiting a node, mark it as visited. For each neighbor of the current node, if the neighbor is not the parent and has been visited, return true as a cycle is found. If the neighbor is not visited, call the 'hasCycle' function recursively. If the recursion returns true, a cycle has been found. Else, return false as no cycle is found in the current neighbors.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef isTree(n: int, edges: List[List[int]]) -> bool:\n    neighbors = [[] for _ in range(n)]\n    for edge in edges:\n        neighbors[edge[0]].append(edge[1])\n        neighbors[edge[1]].append(edge[0])\n    visited = [False] * n\n    if hasCycle(neighbors, visited, -1, 0): return False\n    return all(visited)\n\ndef hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:\n    visited[node] = True\n    for neighbor in neighbors[node]:\n        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True\n    return False\n```\n    \n    The algorithm uses depth-first search (DFS) to traverse the given graph. During traversal, it checks if there is a cycle (a node visited more than once). A valid tree should not have any cycles, and all nodes must be reachable.\n\n1. Create a list of neighbors for each node.\n2. Initialize a visited array to keep track of visited nodes.\n3. Call the 'hasCycle' function to perform DFS and also check the existence of a cycle.\n4. If a cycle exists, return false.\n5. If all nodes have not been visited, return false.\n6. If there is no cycle and all nodes have been visited, return true.\n\nThe 'hasCycle' function checks for the cycle recursively. When visiting a node, mark it as visited. For each neighbor of the current node, if the neighbor is not the parent and has been visited, return true as a cycle is found. If the neighbor is not visited, call the 'hasCycle' function recursively. If the recursion returns true, a cycle has been found. Else, return false as no cycle is found in the current neighbors.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool isTree(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> neighbors(n);\n    for (const auto& edge : edges) {\n        neighbors[edge[0]].push_back(edge[1]);\n        neighbors[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(n, false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const auto& visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nbool hasCycle(const std::vector<std::vector<int>>& neighbors, std::vector<bool>& visited, int parent, int node) {\n    visited[node] = true;\n    for (const auto& neighbor : neighbors[node])\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to traverse the given graph. During traversal, it checks if there is a cycle (a node visited more than once). A valid tree should not have any cycles, and all nodes must be reachable.\n\n1. Create a list of neighbors for each node.\n2. Initialize a visited array to keep track of visited nodes.\n3. Call the 'hasCycle' function to perform DFS and also check the existence of a cycle.\n4. If a cycle exists, return false.\n5. If all nodes have not been visited, return false.\n6. If there is no cycle and all nodes have been visited, return true.\n\nThe 'hasCycle' function checks for the cycle recursively. When visiting a node, mark it as visited. For each neighbor of the current node, if the neighbor is not the parent and has been visited, return true as a cycle is found. If the neighbor is not visited, call the 'hasCycle' function recursively. If the recursion returns true, a cycle has been found. Else, return false as no cycle is found in the current neighbors.\n    ",
        "js": "\n    ```javascript\nfunction isTree(n, edges) {\n    const neighbors = Array.from({length: n}, () => []);\n    for (const edge of edges) {\n        neighbors[edge[0]].push(edge[1]);\n        neighbors[edge[1]].push(edge[0]);\n    }\n    const visited = Array(n).fill(false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const visit of visited)\n        if (!visit) return false;\n    return true;\n}\n\nfunction hasCycle(neighbors, visited, parent, node) {\n    visited[node] = true;\n    for (const neighbour of neighbors[node])\n        if ((neighbour !== parent && visited[neighbour]) || (!visited[neighbour] && hasCycle(neighbors, visited, node, neighbour))) return true;\n    return false;\n}\n```\n    \n    The algorithm uses depth-first search (DFS) to traverse the given graph. During traversal, it checks if there is a cycle (a node visited more than once). A valid tree should not have any cycles, and all nodes must be reachable.\n\n1. Create a list of neighbors for each node.\n2. Initialize a visited array to keep track of visited nodes.\n3. Call the 'hasCycle' function to perform DFS and also check the existence of a cycle.\n4. If a cycle exists, return false.\n5. If all nodes have not been visited, return false.\n6. If there is no cycle and all nodes have been visited, return true.\n\nThe 'hasCycle' function checks for the cycle recursively. When visiting a node, mark it as visited. For each neighbor of the current node, if the neighbor is not the parent and has been visited, return true as a cycle is found. If the neighbor is not visited, call the 'hasCycle' function recursively. If the recursion returns true, a cycle has been found. Else, return false as no cycle is found in the current neighbors.\n    "
    },
    {
        "id": 32,
        "title": "Paint House II",
        "difficulty": "Hard",
        "content": {
            "problem": "There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...\n\nReturn _the minimum cost to paint all houses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** costs = \\[\\[1,5,3\\],\\[2,9,4\\]\\]\n**Output:** 5\n**Explanation:**\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n\n",
                "**Example 2:**\n\n**Input:** costs = \\[\\[1,3\\],\\[2,4\\]\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == k`\n*   `1 <= n <= 100`\n*   `2 <= k <= 20`\n*   `1 <= costs[i][j] <= 20`\n\n**",
            "follow_up": "Follow up:** Could you solve it in `O(nk)` runtime?"
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,5,3],[2,9,4]]",
                "output": "5"
            },
            {
                "input": "[[1,3],[2,4]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minCost(int[][] costs) {\n    if (costs == null || costs.length == 0) return 0;\n\n    int n = costs.length;\n    int k = costs[0].length;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            int minCost = Integer.MAX_VALUE;\n            for (int l = 0; l < k; l++) {\n                if (l == j) continue;\n                minCost = Math.min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return Arrays.stream(costs[n - 1]).min().getAsInt();\n}\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "python": "\n    ```python\ndef min_cost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n\n    n, k = len(costs), len(costs[0])\n\n    for i in range(1, n):\n        for j in range(k):\n            min_cost = float(\"inf\")\n            for l in range(k):\n                if l == j:\n                    continue\n                min_cost = min(min_cost, costs[i - 1][l])\n            costs[i][j] += min_cost\n\n    return min(costs[n - 1])\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n\n    int n = costs.size();\n    int k = costs[0].size();\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < k; ++j) {\n            int minCost = INT_MAX;\n            for (int l = 0; l < k; ++l) {\n                if (l == j) continue;\n                minCost = min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return *min_element(costs[n - 1].begin(), costs[n - 1].end());\n}\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "js": "\n    ```javascript\nfunction minCost(costs) {\n    if (!costs || costs.length === 0) return 0;\n\n    const n = costs.length;\n    const k = costs[0].length;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < k; j++) {\n            let minCost = Number.MAX_VALUE;\n            for (let l = 0; l < k; l++) {\n                if (l === j) continue;\n                minCost = Math.min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return Math.min(...costs[n - 1]);\n}\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    "
    },
    {
        "id": 33,
        "title": "Palindrome Permutation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return `true` _if a permutation of the string could form a_ _**palindrome**_ _and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"code \"\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aab \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"carerac \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5000`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"code\"",
                "output": "false"
            },
            {
                "input": "\"aab\"",
                "output": "true"
            },
            {
                "input": "\"carerac\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean canPermutePalindrome(String s) {\n    HashMap<Character, Integer> count = new HashMap<>();\n    for(char c : s.toCharArray()) {\n        count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n    int odd_count = 0;\n    for(int value : count.values()) {\n        if (value % 2 != 0) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef canPermutePalindrome(s: str) -> bool:\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    odd_count = 0\n    for value in count.values():\n        if value % 2:\n            odd_count += 1\n    return odd_count <= 1\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool canPermutePalindrome(string s) {\n    unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n    int odd_count = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        if (it->second % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction canPermutePalindrome(s) {\n    const count = {}\n    for (const c of s) {\n        if (c in count) {\n            count[c]++;\n        } else {\n            count[c] = 1;\n        }\n    }\n    let odd_count = 0;\n    for (const value of Object.values(count)) {\n        if (value % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    "
    },
    {
        "id": 34,
        "title": "Palindrome Permutation II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string s, return _all the palindromic permutations (without duplicates) of it_.\n\nYou may return the answer in **any order**. If `s` has no palindromic permutation, return an empty list.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"aabb\"\n**Output:** \\[\"abba\",\"baab\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \"abc\"\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 16`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aabb\"",
                "output": "[\"abba\",\"baab\"]"
            },
            {
                "input": "\"abc\"",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public List<String> generatePalindromes(String s) {\n        List<String> result = new ArrayList<>();\n        Map<Character, Integer> charCount = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        String midChar = \"\";\n        List<Character> halfChars = new ArrayList<>();\n        int numOdds = 0;\n        for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {\n            if (entry.getValue() % 2 == 1) {\n                numOdds++;\n                midChar = String.valueOf(entry.getKey());\n            }\n            for (int i = 0; i < entry.getValue() / 2; i++) {\n                halfChars.add(entry.getKey());\n            }\n\n            if (numOdds > 1) {\n                return result;\n            }\n        }\n\n        permute(0, halfChars, midChar, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void permute(int idx, List<Character> halfChars, String midChar, List<Character> current, List<String> result) {\n        if (idx == halfChars.size()) {\n            String firstHalf = \"\".valueOf(current.toArray(new Character[0]));\n            result.add(firstHalf + midChar + new StringBuilder(firstHalf).reverse());\n            return;\n        }\n\n        for (int i = 0; i < halfChars.size(); i++) {\n            if (i > 0 && halfChars.get(i) == halfChars.get(i - 1)) {\n                continue;\n            }\n            Character c = halfChars.remove(i);\n            current.add(c);\n            permute(idx + 1, halfChars, midChar, current, result);\n            current.remove(current.size() - 1);\n            halfChars.add(i, c);\n        }\n    }\n}\n```\n    \n    1. Count the occurrences of each character in the given string `s`.\n2. If there are more than one odd counts for any character, there can't be a palindrome, so return an empty list.\n3. Create two parts of the palindrome, `halfStr` and `midChar`. The `halfStr` will contain half of `s` divided by character counts, and `midChar` will contain the middle character if `s` has an odd length.\n4. Generate all unique permutations of `halfStr`.\n5. For each permutation of `halfStr`, concatenate it with `midChar` and its reverse to create a palindrome and add it to the result list.\n6. Return the result list.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\nfrom itertools import permutations\n\ndef generatePalindromes(s):\n    result = []\n    char_count = Counter(s)\n\n    mid_char = \"\"\n    half_str = []\n    num_ocurrences = 0\n\n    for char, count in char_count.items():\n        if count % 2 == 1:\n            num_ocurrences += 1\n            mid_char = char\n        half_str.extend([char] * (count // 2))\n\n        if num_ocurrences > 1:\n            return result\n\n    for perm in set(permutations(half_str)):\n        palindrome = \"\".join(perm) + mid_char + \"\".join(reversed(perm))\n        result.append(palindrome)\n\n    return result\n```\n    \n    1. Count the occurrences of each character in the given string `s`.\n2. If there are more than one odd counts for any character, there can't be a palindrome, so return an empty list.\n3. Create two parts of the palindrome, `halfStr` and `midChar`. The `halfStr` will contain half of `s` divided by character counts, and `midChar` will contain the middle character if `s` has an odd length.\n4. Generate all unique permutations of `halfStr`.\n5. For each permutation of `halfStr`, concatenate it with `midChar` and its reverse to create a palindrome and add it to the result list.\n6. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<string> generatePalindromes(string s) {\n    unordered_map<char, int> charCount;\n    for (const char &c : s) {\n        charCount[c]++;\n    }\n    \n    int numOdds = 0;\n    string halfStr = \"\", midChar = \"\";\n    for (const auto &entry : charCount) {\n        if (entry.second % 2 == 1) {\n            numOdds++;\n            midChar = entry.first;\n        }\n        halfStr += string(entry.second / 2, entry.first);\n        \n        if (numOdds > 1) {\n            return {};\n        }\n    }\n    \n    vector<string> result;\n    sort(halfStr.begin(), halfStr.end());\n    do {\n        string palindrome = halfStr + midChar + string(halfStr.rbegin(), halfStr.rend());\n        result.push_back(palindrome);\n    } while (next_permutation(halfStr.begin(), halfStr.end()));\n    \n    return result;\n}\n```\n    \n    1. Count the occurrences of each character in the given string `s`.\n2. If there are more than one odd counts for any character, there can't be a palindrome, so return an empty list.\n3. Create two parts of the palindrome, `halfStr` and `midChar`. The `halfStr` will contain half of `s` divided by character counts, and `midChar` will contain the middle character if `s` has an odd length.\n4. Generate all unique permutations of `halfStr`.\n5. For each permutation of `halfStr`, concatenate it with `midChar` and its reverse to create a palindrome and add it to the result list.\n6. Return the result list.\n    ",
        "js": "\n    ```javascript\nfunction generatePalindromes(s) {\n    let result = [];\n    let charCount = new Map();\n    for (const c of s) {\n        charCount.set(c, (charCount.get(c) || 0) + 1);\n    }\n\n    let midChar = \"\";\n    let halfChars = [];\n    let numOdds = 0;\n    charCount.forEach((count, char) => {\n        if (count % 2 === 1) {\n            numOdds++;\n            midChar = char;\n        }\n        for (let i = 0; i < Math.floor(count / 2); i++) {\n            halfChars.push(char);\n        }\n\n        if (numOdds > 1) {\n            return [];\n        }\n    });\n\n    function btPerm(idx, current) {\n        if (idx === halfChars.length) {\n            const firstHalf = current.join('');\n            result.push(firstHalf + midChar + firstHalf.split('').reverse().join(''));\n            return;\n        }\n\n        for (let i = 0; i < halfChars.length; i++) {\n            if (i > 0 && halfChars[i] === halfChars[i - 1]) {\n                continue;\n            }\n            const char = halfChars.splice(i, 1)[0];\n            current.push(char);\n            btPerm(idx + 1, current);\n            current.pop();\n            halfChars.splice(i, 0, char);\n        }\n    }\n\n    halfChars.sort();\n    btPerm(0, []);\n\n    return result;\n}\n```\n    \n    1. Count the occurrences of each character in the given string `s`.\n2. If there are more than one odd counts for any character, there can't be a palindrome, so return an empty list.\n3. Create two parts of the palindrome, `halfStr` and `midChar`. The `halfStr` will contain half of `s` divided by character counts, and `midChar` will contain the middle character if `s` has an odd length.\n4. Generate all unique permutations of `halfStr`.\n5. For each permutation of `halfStr`, concatenate it with `midChar` and its reverse to create a palindrome and add it to the result list.\n6. Return the result list.\n    "
    },
    {
        "id": 35,
        "title": "Closest Binary Search Tree Value",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree and a `target` value, return _the value in the BST that is closest to the_ `target`. If there are multiple answers, print the smallest.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\], target = 3.714286\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\], target = 4.428571\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 109`\n*   `-109 <= target <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,5,1,3],3.714286",
                "output": "4"
            },
            {
                "input": "[1],4.428571",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public int closestValue(TreeNode root, double target) {\n        int closest = root.val;\n        while (root != null) {\n            if (Math.abs(target - closest) > Math.abs(target - root.val)) {\n                closest = root.val;\n            }\n            root = target < root.val ? root.left : root.right;\n        }\n        return closest;\n    }\n}\n```\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def closestValue(self, root: TreeNode, target: float) -> int:\n        closest = root.val\n        while root:\n            if abs(target - closest) > abs(target - root.val):\n                closest = root.val\n            root = root.left if target < root.val else root.right\n        return closest\n```\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        int closest = root->val;\n        while (root != nullptr) {\n            if (abs(target - closest) > abs(target - root->val)) {\n                closest = root->val;\n            }\n            root = target < root->val ? root->left : root->right;\n        }\n        return closest;\n    }\n};\n```\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    ",
        "js": "\n    ```javascript\nvar closestValue = function(root, target) {\n    let closest = root.val;\n    while (root !== null) {\n        if (Math.abs(target - closest) > Math.abs(target - root.val)) {\n            closest = root.val;\n        }\n        root = target < root.val ? root.left : root.right;\n    }\n    return closest;\n};\n```\n\n    \n    The algorithm uses a while loop to traverse the binary search tree. During the iteration, we continuously update the closest variable with the current node's value if the current node's value is closer to the target than the previous closest value. The algorithm follows the binary search tree's property, taking the left branch if the target is less than the current node's value and the right branch if the target is greater than the current node's value. On reaching a null node, the algorithm terminates and returns the closest value found.\n    "
    },
    {
        "id": 36,
        "title": "Encode and Decode Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n\nstring encode(vector strs) {\n  // ... your code\n  return encoded\\_string;\n}\n\nMachine 2 (receiver) has the function:\n\nvector decode(string s) {\n  //... your code\n  return strs;\n}\n\nSo Machine 1 does:\n\nstring encoded\\_string = encode(strs);\n\nand Machine 2 does:\n\nvector strs2 = decode(encoded\\_string);\n\n`strs2` in Machine 2 should be the same as `strs` in Machine 1.\n\nImplement the `encode` and `decode` methods.\n\nYou are not allowed to solve the problem using any serialize methods (such as `eval`).",
            "examples": [
                "**Example 1:**\n\n**Input:** dummy\\_input = \\[ \"Hello \", \"World \"\\]\n**Output:** \\[ \"Hello \", \"World \"\\]\n**Explanation:**\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString\\[\\] strs = decoder.decode(msg);\n\n",
                "**Example 2:**\n\n**Input:** dummy\\_input = \\[ \" \"\\]\n**Output:** \\[ \" \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` contains any possible characters out of `256` valid ASCII characters.\n\n**",
            "follow_up": "Follow up:** Could you write a generalized algorithm to work on any possible set of characters?"
        },
        "tag": [],
        "example": [
            {
                "input": "[\"Hello\",\"World\"]",
                "output": "[\"Hello\",\"World\"]"
            },
            {
                "input": "[\"\"]",
                "output": "[\"\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String encode(List<String> strs) {\n    StringBuilder encodedString = new StringBuilder();\n    for (String s : strs) {\n        encodedString.append(s.length()).append('#').append(s);\n    }\n    return encodedString.toString();\n}\n\npublic List<String> decode(String s) {\n    List<String> strs = new ArrayList<>();\n    int i = 0;\n    while (i < s.length()) {\n        int delimiterPos = s.indexOf('#', i);\n        int length = Integer.parseInt(s.substring(i, delimiterPos));\n        strs.add(s.substring(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}\n```\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "python": "\n    ```python\ndef encode(strs):\n    encoded_string = \"\"\n    for s in strs:\n        encoded_string += str(len(s)) + \"#\" + s\n    return encoded_string\n\ndef decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        delimiter_pos = s.find('#', i)\n        length = int(s[i:delimiter_pos])\n        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])\n        i = delimiter_pos + 1 + length\n    return strs\n```\n\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string encode(const std::vector<std::string>& strs) {\n    std::string encoded_string;\n    for (const auto& s : strs) {\n        encoded_string += std::to_string(s.length()) + \"#\" + s;\n    }\n    return encoded_string;\n}\n\nstd::vector<std::string> decode(const std::string& s) {\n    std::vector<std::string> strs;\n    int i = 0;\n    while (i < s.length()) {\n        int delimiter_pos = s.find('#', i);\n        int length = std::stoi(s.substr(i, delimiter_pos - i));\n        strs.push_back(s.substr(delimiter_pos + 1, length));\n        i = delimiter_pos + length + 1;\n    }\n    return strs;\n}\n```\n\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "js": "\n    ```javascript\nfunction encode(strs) {\n    let encodedString = \"\";\n    for (const s of strs) {\n        encodedString += s.length + \"#\" + s;\n    }\n    return encodedString;\n}\n\nfunction decode(s) {\n    let strs = [];\n    let i = 0;\n    while (i < s.length) {\n        const delimiterPos = s.indexOf('#', i);\n        const length = parseInt(s.slice(i, delimiterPos));\n        strs.push(s.slice(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}\n```\n\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    "
    },
    {
        "id": 37,
        "title": "Closest Binary Search Tree Value II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the `root` of a binary search tree, a `target` value, and an integer `k`, return _the_ `k` _values in the BST that are closest to the_ `target`. You may return the answer in **any order**.\n\nYou are **guaranteed** to have only one unique set of `k` values in the BST that are closest to the `target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\], target = 3.714286, k = 2\n**Output:** \\[4,3\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\], target = 0.000000, k = 1\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`.\n*   `0 <= Node.val <= 109`\n*   `-109 <= target <= 109`\n\n**",
            "follow_up": "Follow up:** Assume that the BST is balanced. Could you solve it in less than `O(n)` runtime (where `n = total nodes`)?"
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,5,1,3],3.714286,2",
                "output": "[4,3]"
            },
            {
                "input": "[1],0.000000,1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> closestKValues(TreeNode root, double target, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));\n    List<Integer> values = new ArrayList<>();\n\n    inorderTraversal(root, target, k, maxHeap);\n\n    while (!maxHeap.isEmpty()) {\n        values.add(maxHeap.poll()[0]);\n    }\n    return values;\n}\n\nvoid inorderTraversal(TreeNode node, double target, int k, PriorityQueue<int[]> maxHeap) {\n    if (node == null) return;\n\n    inorderTraversal(node.left, target, k, maxHeap);\n    maxHeap.offer(new int[]{node.val, Math.abs(node.val - target)});\n    if (maxHeap.size() > k) maxHeap.poll();\n    inorderTraversal(node.right, target, k, maxHeap);\n}\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef closestKValues(root, target, k):\n    values = []\n    max_heap = []\n\n    def inorder_traverse(node):\n        if not node:\n            return\n        inorder_traverse(node.left)\n        heappush(max_heap, (-abs(node.val - target), node.val))\n        if len(max_heap) > k:\n            heappop(max_heap)\n        inorder_traverse(node.right)\n\n    inorder_traverse(root)\n    while max_heap:\n        _, val = heappop(max_heap)\n        values.append(val)\n    return values\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvector<int> closestKValues(TreeNode* root, double target, int k) {\n    vector<int> values;\n    priority_queue<pair<double, int>> maxHeap;\n\n    function<void(TreeNode*)> inorderTraverse = [&](TreeNode* node) {\n        if (!node) return;\n        inorderTraverse(node->left);\n        maxHeap.push(make_pair(fabs(node->val - target), node->val));\n        if (maxHeap.size() > k) maxHeap.pop();\n        inorderTraverse(node->right);\n    };\n\n    inorderTraverse(root);\n    while (!maxHeap.empty()) {\n        values.push_back(maxHeap.top().second);\n        maxHeap.pop();\n    }\n    return values;\n}\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction closestKValues(root, target, k) {\n    const values = [];\n    const maxHeap = [];\n\n    function inorderTraversal(node) {\n        if (!node) return;\n        inorderTraversal(node.left);\n        maxHeap.push({diff: Math.abs(node.val - target), val: node.val});\n        maxHeap.sort((a, b) => b.diff - a.diff);\n        if (maxHeap.length > k) maxHeap.pop();\n        inorderTraversal(node.right);\n    }\n\n    inorderTraversal(root);\n    for (let item of maxHeap) {\n        values.push(item.val);\n    }\n    return values;\n}\n```\n    \n    The proposed algorithm is an Inorder Traversal of a Binary Search Tree, which visits the nodes in ascending order. During the traversal, we calculate the absolute difference between each node's value and the target value, and maintain a max heap with the K smallest differences. In the end, we retrieve the values from the max heap and return them in the result.\n\nThe time complexity of this algorithm is O(n) due to the traversal of the whole tree. Although the follow-up question asks about a solution with less O(n) time, the provided algorithms have not considered that case.\n    "
    },
    {
        "id": 38,
        "title": "Paint Fence",
        "difficulty": "Medium",
        "content": {
            "problem": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 6\n**Explanation:** All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** n = 7, k = 2\n**Output:** 42"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= k <= 105`\n*   The testcases are generated such that the answer is in the range `[0, 231 - 1]` for the given `n` and `k`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,2",
                "output": "6"
            },
            {
                "input": "1,1",
                "output": "1"
            },
            {
                "input": "7,2",
                "output": "42"
            }
        ],
        "java": "\n    ```java\npublic int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "python": "\n    ```python\ndef numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "c++": "\n    ```cpp\nint numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "js": "\n    ```javascript\nfunction numWays(n, k) {\n    if (n === 0) return 0;\n    if (n === 1) return k;\n\n    let same = k;\n    let different = k * (k - 1);\n    for (let i = 2; i < n; ++i) {\n        const temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    "
    },
    {
        "id": 39,
        "title": "Find the Celebrity",
        "difficulty": "Medium",
        "content": {
            "problem": "Suppose you are at a party with `n` people labeled from `0` to `n - 1` and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know the celebrity, but the celebrity does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: \"Hi, A. Do you know B? \" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` that tells you whether `a` knows `b`. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if they are at the party.\n\nReturn _the celebrity's label if there is a celebrity at the party_. If there is no celebrity, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** 1\n**Explanation:** There are three persons labeled with 0, 1 and 2. graph\\[i\\]\\[j\\] = 1 means person i knows person j, otherwise graph\\[i\\]\\[j\\] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1,0,1\\],\\[1,1,0\\],\\[0,1,1\\]\\]\n**Output:** -1\n**Explanation:** There is no celebrity."
            ],
            "constraints": "**Constraints:**\n\n*   `n == graph.length == graph[i].length`\n*   `2 <= n <= 100`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][i] == 1`\n\n**",
            "follow_up": "Follow up:** If the maximum number of allowed calls to the API `knows` is `3 * n`, could you find a solution without exceeding the maximum number of calls?"
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,0],[0,1,0],[1,1,1]]",
                "output": "1"
            },
            {
                "input": "[[1,0,1],[1,1,0],[0,1,1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic boolean knows(int a, int b);\n\npublic int findCelebrity(int n) {\n    int candidate = 0;\n    for (int i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "python": "\n    ```python\ndef knows(a: int, b:int) -> bool:\n    pass\n\ndef findCelebrity(n: int) -> int:\n    candidate = 0\n    for i in range(1, n):\n        if knows(candidate, i):\n            candidate = i\n    \n    for i in range(n):\n        if i != candidate and (knows(candidate, i) or not knows(i, candidate)):\n            return -1\n    return candidate\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "c++": "\n    ```cpp\nbool knows(int a, int b);\n\nint findCelebrity(int n) {\n    int candidate = 0;\n    for (int i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "js": "\n    ```javascript\nfunction knows(a, b) {\n    // Implementation not shown\n}\n\nfunction findCelebrity(n) {\n    let candidate = 0;\n    for (let i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (i !== candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    "
    },
    {
        "id": 40,
        "title": "Wiggle Sort",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.\n\nYou may assume the input array always has a valid answer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,5,2,1,6,4\\]\n**Output:** \\[3,5,1,6,2,4\\]\n**Explanation:** \\[1,6,2,5,3,4\\] is also accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,6,5,6,3,8\\]\n**Output:** \\[6,6,5,6,3,8\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 104`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**",
            "follow_up": "Follow up:** Could you solve the problem in `O(n)` time complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,2,1,6,4]",
                "output": "[3,5,1,6,2,4]"
            },
            {
                "input": "[6,6,5,6,3,8]",
                "output": "[6,6,5,6,3,8]"
            }
        ],
        "java": "\n    ```java\npublic void wiggleSort(int[] nums) {\n    for (int i = 1; i < nums.length; i++) {\n        if (i % 2 == 0 && nums[i] > nums[i-1] || i % 2 == 1 && nums[i] < nums[i-1]) {\n            int temp = nums[i];\n            nums[i] = nums[i-1];\n            nums[i-1] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "python": "\n    ```python\ndef wiggleSort(nums):\n    for i in range(1, len(nums)):\n        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):\n            nums[i], nums[i-1] = nums[i-1], nums[i]\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "c++": "\n    ```cpp\nvoid wiggleSort(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {\n            swap(nums[i], nums[i-1]);\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "js": "\n    ```javascript\nfunction wiggleSort(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        if (i % 2 === 0 && nums[i] > nums[i-1] || i % 2 === 1 && nums[i] < nums[i-1]) {\n            [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    "
    },
    {
        "id": 41,
        "title": "Zigzag Iterator",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two vectors of integers `v1` and `v2`, implement an iterator to return their elements alternately.\n\nImplement the `ZigzagIterator` class:\n\n*   `ZigzagIterator(List v1, List v2)` initializes the object with the two vectors `v1` and `v2`.\n*   `boolean hasNext()` returns `true` if the iterator still has elements, and `false` otherwise.\n*   `int next()` returns the current element of the iterator and moves the iterator to the next element.",
            "examples": [
                "**Example 1:**\n\n**Input:** v1 = \\[1,2\\], v2 = \\[3,4,5,6\\]\n**Output:** \\[1,3,2,4,5,6\\]\n**Explanation:** By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: \\[1,3,2,4,5,6\\].\n\n",
                "**Example 2:**\n\n**Input:** v1 = \\[1\\], v2 = \\[\\]\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** v1 = \\[\\], v2 = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= v1.length, v2.length <= 1000`\n*   `1 <= v1.length + v2.length <= 2000`\n*   `-231 <= v1[i], v2[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** What if you are given `k` vectors? How well can your code be extended to such cases?\n\n**Clarification for the follow-up question:**\n\nThe \"Zigzag \" order is not clearly defined and is ambiguous for `k > 2` cases. If \"Zigzag \" does not look right to you, replace \"Zigzag \" with \"Cyclic \".\n\n**Follow-up Example:**\n\n**Input:** v1 = \\[1,2,3\\], v2 = \\[4,5,6,7\\], v3 = \\[8,9\\]\n**Output:** \\[1,4,8,2,5,9,3,6,7\\]"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2],[3,4,5,6]",
                "output": "[1,3,2,4,5,6]"
            },
            {
                "input": "[1],[]",
                "output": "[1]"
            },
            {
                "input": "[],[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class ZigzagIterator {\n    private List<Integer> list1;\n    private List<Integer> list2;\n    private boolean isList1;\n    private int index1, index2;\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        list1 = v1;\n        list2 = v2;\n        isList1 = list1.size() > 0;\n        index1 = 0;\n        index2 = 0;\n    }\n\n    public int next() {\n        if (isList1 && index1 < list1.size()) {\n            isList1 = !isList1;\n            return list1.get(index1++);\n        } else {\n            isList1 = !isList1;\n            return list2.get(index2++);\n        }\n    }\n\n    public boolean hasNext() {\n        return index1 < list1.size() || index2 < list2.size();\n    }\n}\n```\n    \n    The ZigzagIterator class is initialized with two vectors `v1` and `v2`. The `hasNext()` method checks whether there are any remaining elements in either vector. When the `next()` method is called, decide which vector to take the element from based on the current indices comparing to the lengths of the vectors. If there're more elements in the first vector or equal number of elements in both but the current index of the first vector is less than the current index of the second vector, we take the element from the first vector. Otherwise, we take the element from the second vector. And in every step, we move the index of the chosen vector forward. We can swap the vectors every time we decide which vector to take the element from so that the implementation can work for k > 2 vectors (cyclic order).\n    ",
        "python": "\n    ```python\nclass ZigzagIterator:\n\n    def __init__(self, v1: List[int], v2: List[int]):\n        self.v1, self.v2 = v1, v2\n        self.index1, self.index2 = 0, 0\n\n    def next(self) -> int:\n        if self.index1 < len(self.v1) and (self.index1 <= self.index2 or self.index2 == len(self.v2)):\n            result = self.v1[self.index1]\n            self.index1 += 1\n            return result\n        if self.index2 < len(self.v2) and (self.index2 < self.index1 or self.index1 == len(self.v1)):\n            result = self.v2[self.index2]\n            self.index2 += 1\n            return result\n\n    def hasNext(self) -> bool:\n        return self.index1 < len(self.v1) or self.index2 < len(self.v2)\n```\n    \n    The ZigzagIterator class is initialized with two vectors `v1` and `v2`. The `hasNext()` method checks whether there are any remaining elements in either vector. When the `next()` method is called, decide which vector to take the element from based on the current indices comparing to the lengths of the vectors. If there're more elements in the first vector or equal number of elements in both but the current index of the first vector is less than the current index of the second vector, we take the element from the first vector. Otherwise, we take the element from the second vector. And in every step, we move the index of the chosen vector forward. We can swap the vectors every time we decide which vector to take the element from so that the implementation can work for k > 2 vectors (cyclic order).\n    ",
        "c++": "\n    ```cpp\nclass ZigzagIterator {\npublic:\n    ZigzagIterator(vector<int>& v1, vector<int>& v2): curr_v(NULL), index1(0), index2(0) {\n        if (!v1.empty()) {\n            curr_v = &v1;\n            other_v = &v2;\n        } else if (!v2.empty()) {\n            curr_v = &v2;\n            other_v = &v1;\n        }\n    }\n\n    int next() {\n        int result = (*curr_v)[index1++];\n        if (index2 < other_v->size()) {\n            swap(curr_v, other_v);\n            swap(index1, index2);\n        }\n        return result;\n    }\n\n    bool hasNext() {\n        return curr_v && index1 < curr_v->size();\n    }\n\nprivate:\n    vector<int> *curr_v;\n    vector<int> *other_v;\n    int index1;\n    int index2;\n};\n```\n    \n    The ZigzagIterator class is initialized with two vectors `v1` and `v2`. The `hasNext()` method checks whether there are any remaining elements in either vector. When the `next()` method is called, decide which vector to take the element from based on the current indices comparing to the lengths of the vectors. If there're more elements in the first vector or equal number of elements in both but the current index of the first vector is less than the current index of the second vector, we take the element from the first vector. Otherwise, we take the element from the second vector. And in every step, we move the index of the chosen vector forward. We can swap the vectors every time we decide which vector to take the element from so that the implementation can work for k > 2 vectors (cyclic order).\n    ",
        "js": "\n    ```javascript\nclass ZigzagIterator {\n    constructor(v1, v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n        this.index1 = 0;\n        this.index2 = 0;\n    }\n    \n    next() {\n        if (this.index1 < this.v1.length && (this.index1 <= this.index2 || this.index2 == this.v2.length)) {\n            return this.v1[this.index1++];\n        }\n        if (this.index2 < this.v2.length && (this.index2 < this.index1 || this.index1 == this.v1.length)) {\n            return this.v2[this.index2++];\n        }\n    }\n\n    hasNext() {\n        return this.index1 < this.v1.length || this.index2 < this.v2.length;\n    }\n}\n```\n    \n    The ZigzagIterator class is initialized with two vectors `v1` and `v2`. The `hasNext()` method checks whether there are any remaining elements in either vector. When the `next()` method is called, decide which vector to take the element from based on the current indices comparing to the lengths of the vectors. If there're more elements in the first vector or equal number of elements in both but the current index of the first vector is less than the current index of the second vector, we take the element from the first vector. Otherwise, we take the element from the second vector. And in every step, we move the index of the chosen vector forward. We can swap the vectors every time we decide which vector to take the element from so that the implementation can work for k > 2 vectors (cyclic order).\n    "
    },
    {
        "id": 42,
        "title": "Inorder Successor in BST",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary search tree and a node `p` in it, return _the in-order successor of that node in the BST_. If the given node has no in-order successor in the tree, return `null`.\n\nThe successor of a node `p` is the node with the smallest key greater than `p.val`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[2,1,3\\], p = 1\n**Output:** 2\n**Explanation:** 1's in-order successor node is 2. Note that both p and the return value is of TreeNode type.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,3,6,2,4,null,null,1\\], p = 6\n**Output:** null\n**Explanation:** There is no in-order successor of the current node, so the answer is `null`."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\n*   All Nodes will have unique values.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,3],1",
                "output": "2"
            },
            {
                "input": "[5,3,6,2,4,null,null,1],6",
                "output": "null"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n    TreeNode successor = null;\n    while (root != null) {\n        if (root.val > p.val) {\n            successor = root;\n            root = root.left;\n        } else {\n            root = root.right;\n        }\n    }\n    return successor;\n}\n```    \n    In our function, `inorderSuccessor`, the goal is to find the node with the smallest key greater than the given node `p`. We start by initializing a variable `successor` as `null`. \n\nWe then run a while loop until the `root` is `null`. Within this loop, we have two conditions - one for when the root's value is greater than the value of the given node. In this case, we update the `successor` to the current root and then move to the left subtree by updating the root to its left child. If the root's value is not greater than the value of the given node, we move to the right subtree by updating the root to its right child.\n\nAt the end of the loop, when the `root` is `null`, the `successor` variable now holds our answer - the in-order successor of the given node `p` in the BST. If no in-order successor exists, it holds `null`. We return the `successor` variable.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode:\n    successor = None\n    while root:\n        if root.val > p.val:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    return successor\n```    \n    In our function, `inorderSuccessor`, the goal is to find the node with the smallest key greater than the given node `p`. We start by initializing a variable `successor` as `null`. \n\nWe then run a while loop until the `root` is `null`. Within this loop, we have two conditions - one for when the root's value is greater than the value of the given node. In this case, we update the `successor` to the current root and then move to the left subtree by updating the root to its left child. If the root's value is not greater than the value of the given node, we move to the right subtree by updating the root to its right child.\n\nAt the end of the loop, when the `root` is `null`, the `successor` variable now holds our answer - the in-order successor of the given node `p` in the BST. If no in-order successor exists, it holds `null`. We return the `successor` variable.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nTreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n    TreeNode* successor = nullptr;\n    while (root != nullptr) {\n        if (root->val > p->val) {\n            successor = root;\n            root = root->left;\n        } else {\n            root = root->right;\n        }\n    }\n    return successor;\n}\n```    \n    In our function, `inorderSuccessor`, the goal is to find the node with the smallest key greater than the given node `p`. We start by initializing a variable `successor` as `null`. \n\nWe then run a while loop until the `root` is `null`. Within this loop, we have two conditions - one for when the root's value is greater than the value of the given node. In this case, we update the `successor` to the current root and then move to the left subtree by updating the root to its left child. If the root's value is not greater than the value of the given node, we move to the right subtree by updating the root to its right child.\n\nAt the end of the loop, when the `root` is `null`, the `successor` variable now holds our answer - the in-order successor of the given node `p` in the BST. If no in-order successor exists, it holds `null`. We return the `successor` variable.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorderSuccessor(root, p) {\n    let successor = null;\n    while (root !== null) {\n        if (root.val > p.val) {\n            successor = root;\n            root = root.left;\n        } else {\n            root = root.right;\n        }\n    }\n    return successor;\n}\n```    \n    In our function, `inorderSuccessor`, the goal is to find the node with the smallest key greater than the given node `p`. We start by initializing a variable `successor` as `null`. \n\nWe then run a while loop until the `root` is `null`. Within this loop, we have two conditions - one for when the root's value is greater than the value of the given node. In this case, we update the `successor` to the current root and then move to the left subtree by updating the root to its left child. If the root's value is not greater than the value of the given node, we move to the right subtree by updating the root to its right child.\n\nAt the end of the loop, when the `root` is `null`, the `successor` variable now holds our answer - the in-order successor of the given node `p` in the BST. If no in-order successor exists, it holds `null`. We return the `successor` variable.\n    "
    },
    {
        "id": 43,
        "title": "Walls and Gates",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` grid `rooms` initialized with these three possible values.\n\n*   `-1` A wall or an obstacle.\n*   `0` A gate.\n*   `INF` Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.\n\nFill each empty room with the distance to _its nearest gate_. If it is impossible to reach a gate, it should be filled with `INF`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rooms = \\[\\[2147483647,-1,0,2147483647\\],\\[2147483647,2147483647,2147483647,-1\\],\\[2147483647,-1,2147483647,-1\\],\\[0,-1,2147483647,2147483647\\]\\]\n**Output:** \\[\\[3,-1,0,1\\],\\[2,2,1,-1\\],\\[1,-1,2,-1\\],\\[0,-1,3,4\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** rooms = \\[\\[-1\\]\\]\n**Output:** \\[\\[-1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == rooms.length`\n*   `n == rooms[i].length`\n*   `1 <= m, n <= 250`\n*   `rooms[i][j]` is `-1`, `0`, or `231 - 1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
                "output": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]"
            },
            {
                "input": "[[-1]]",
                "output": "[[-1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic void wallsAndGates(int[][] rooms) {\n    int m = rooms.length;\n    int n = rooms[0].length;\n    Queue<int[]> q = new LinkedList<>();\n    int INF = 2147483647;\n\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(rooms[i][j] == 0) {\n                q.offer(new int[]{i, j});\n            }\n        }\n    }\n    \n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!q.isEmpty()) {\n        int[] cur = q.poll();\n        int i = cur[0];\n        int j = cur[1];\n\n        for(int[] d : directions) {\n            int ni = i + d[0];\n            int nj = j + d[1];\n\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF) {\n                rooms[ni][nj] = rooms[i][j] + 1;\n                q.offer(new int[]{ni, nj});\n            }\n        }\n    }\n}\n```\n    \n    The algorithm uses BFS (Breadth-First Search) to find the shortest distances from empty rooms to gates. We first create a queue `q` and add all the gates' coordinates to it. Then, we create an array `directions` containing possible moves (up, down, left, right).\n\nWhile the queue is not empty, we loop through all the gates in the queue, and for each gate, we explore its neighbors (up, down, left, right) and check if they are empty rooms. If they are, we update their distance to be 1 more than the current gate's distance, and add these neighbors to the queue. Once a room's distance is updated, it will not be updated again because that's the shortest distance found. The process continues until all reachable empty rooms have their distances updated.\n\nThis algorithm operates in O(m*n) time complexity, where m and n are the dimensions of the grid rooms, since each cell is visited once.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef wallsAndGates(rooms):\n    m, n = len(rooms), len(rooms[0])\n    q = deque()\n    INF = 2147483647\n\n    for i in range(m):\n        for j in range(n):\n            if rooms[i][j] == 0:\n                q.append((i, j))\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while q:\n        i, j = q.popleft()\n\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n\n            if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF:\n                rooms[ni][nj] = rooms[i][j] + 1\n                q.append((ni, nj))\n\n```\n    \n    The algorithm uses BFS (Breadth-First Search) to find the shortest distances from empty rooms to gates. We first create a queue `q` and add all the gates' coordinates to it. Then, we create an array `directions` containing possible moves (up, down, left, right).\n\nWhile the queue is not empty, we loop through all the gates in the queue, and for each gate, we explore its neighbors (up, down, left, right) and check if they are empty rooms. If they are, we update their distance to be 1 more than the current gate's distance, and add these neighbors to the queue. Once a room's distance is updated, it will not be updated again because that's the shortest distance found. The process continues until all reachable empty rooms have their distances updated.\n\nThis algorithm operates in O(m*n) time complexity, where m and n are the dimensions of the grid rooms, since each cell is visited once.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid wallsAndGates(vector<vector<int>>& rooms) {\n    const int INF = 2147483647;\n    int m = rooms.size();\n    int n = rooms[0].size();\n    queue<pair<int, int>> q;\n\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(rooms[i][j] == 0) {\n                q.push(make_pair(i, j));\n            }\n        }\n    }\n\n    int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!q.empty()) {\n        int i = q.front().first;\n        int j = q.front().second;\n        q.pop();\n\n        for(auto d : directions) {\n            int ni = i + d[0];\n            int nj = j + d[1];\n\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF) {\n                rooms[ni][nj] = rooms[i][j] + 1;\n                q.push(make_pair(ni, nj));\n            }\n        }\n    }\n}\n```\n    \n    The algorithm uses BFS (Breadth-First Search) to find the shortest distances from empty rooms to gates. We first create a queue `q` and add all the gates' coordinates to it. Then, we create an array `directions` containing possible moves (up, down, left, right).\n\nWhile the queue is not empty, we loop through all the gates in the queue, and for each gate, we explore its neighbors (up, down, left, right) and check if they are empty rooms. If they are, we update their distance to be 1 more than the current gate's distance, and add these neighbors to the queue. Once a room's distance is updated, it will not be updated again because that's the shortest distance found. The process continues until all reachable empty rooms have their distances updated.\n\nThis algorithm operates in O(m*n) time complexity, where m and n are the dimensions of the grid rooms, since each cell is visited once.\n    ",
        "js": "\n    ```javascript\nfunction wallsAndGates(rooms) {\n    const m = rooms.length;\n    const n = rooms[0].length;\n    const q = [];\n    const INF = 2147483647;\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (rooms[i][j] === 0) {\n                q.push([i, j]);\n            }\n        }\n    }\n\n    const directions = [\n        [0, 1],\n        [0, -1],\n        [1, 0],\n        [-1, 0]\n    ];\n\n    while (q.length) {\n        const [i, j] = q.shift();\n\n        directions.forEach(([di, dj]) => {\n            const ni = i + di;\n            const nj = j + dj;\n\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] === INF) {\n                rooms[ni][nj] = rooms[i][j] + 1;\n                q.push([ni, nj]);\n            }\n        });\n    }\n}\n```\n    \n    The algorithm uses BFS (Breadth-First Search) to find the shortest distances from empty rooms to gates. We first create a queue `q` and add all the gates' coordinates to it. Then, we create an array `directions` containing possible moves (up, down, left, right).\n\nWhile the queue is not empty, we loop through all the gates in the queue, and for each gate, we explore its neighbors (up, down, left, right) and check if they are empty rooms. If they are, we update their distance to be 1 more than the current gate's distance, and add these neighbors to the queue. Once a room's distance is updated, it will not be updated again because that's the shortest distance found. The process continues until all reachable empty rooms have their distances updated.\n\nThis algorithm operates in O(m*n) time complexity, where m and n are the dimensions of the grid rooms, since each cell is visited once.\n    "
    },
    {
        "id": 44,
        "title": "Unique Word Abbreviation",
        "difficulty": "Medium",
        "content": {
            "problem": "The **abbreviation** of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an **abbreviation** of itself.\n\nFor example:\n\n*   `dog --> d1g` because there is one letter between the first letter `'d'` and the last letter `'g'`.\n*   `internationalization --> i18n` because there are 18 letters between the first letter `'i'` and the last letter `'n'`.\n*   `it --> it` because any word with only two characters is an **abbreviation** of itself.\n\nImplement the `ValidWordAbbr` class:\n\n*   `ValidWordAbbr(String[] dictionary)` Initializes the object with a `dictionary` of words.\n*   `boolean isUnique(string word)` Returns `true` if **either** of the following conditions are met (otherwise returns `false`):\n    *   There is no word in `dictionary` whose **abbreviation** is equal to `word`'s **abbreviation**.\n    *   For any word in `dictionary` whose **abbreviation** is equal to `word`'s **abbreviation**, that word and `word` are **the same**.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"ValidWordAbbr \",  \"isUnique \",  \"isUnique \",  \"isUnique \",  \"isUnique \",  \"isUnique \"\\]\n\\[\\[\\[ \"deer \",  \"door \",  \"cake \",  \"card \"\\]\\], \\[ \"dear \"\\], \\[ \"cart \"\\], \\[ \"cane \"\\], \\[ \"make \"\\], \\[ \"cake \"\\]\\]\n**Output**\n\\[null, false, true, false, true, true\\]\n\n**Explanation**\nValidWordAbbr validWordAbbr = new ValidWordAbbr(\\[ \"deer \",  \"door \",  \"cake \",  \"card \"\\]);\nvalidWordAbbr.isUnique( \"dear \"); // return false, dictionary word  \"deer \" and word  \"dear \" have the same abbreviation  \"d2r \" but are not the same.\nvalidWordAbbr.isUnique( \"cart \"); // return true, no words in the dictionary have the abbreviation  \"c2t \".\nvalidWordAbbr.isUnique( \"cane \"); // return false, dictionary word  \"cake \" and word  \"cane \" have the same abbreviation   \"c2e \" but are not the same.\nvalidWordAbbr.isUnique( \"make \"); // return true, no words in the dictionary have the abbreviation  \"m2e \".\nvalidWordAbbr.isUnique( \"cake \"); // return true, because  \"cake \" is already in the dictionary and no other word in the dictionary has  \"c2e \" abbreviation."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= dictionary.length <= 3 * 104`\n*   `1 <= dictionary[i].length <= 20`\n*   `dictionary[i]` consists of lowercase English letters.\n*   `1 <= word.length <= 20`\n*   `word` consists of lowercase English letters.\n*   At most `5000` calls will be made to `isUnique`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[\"dear\"],[\"cart\"],[\"cane\"],[\"make\"],[\"cake\"]]",
                "output": "**Output**\n[null,false,true,false,true,true]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass ValidWordAbbr {\n    private Map<String, Set<String>> wordMap;\n\n    public ValidWordAbbr(String[] dictionary) {\n        wordMap = new HashMap<>();\n        for (String word : dictionary) {\n            String abbr = getAbbreviation(word);\n            wordMap.putIfAbsent(abbr, new HashSet<>());\n            wordMap.get(abbr).add(word);\n        }\n    }\n\n    public boolean isUnique(String word) {\n        String abbr = getAbbreviation(word);\n        Set<String> abbrGroup = wordMap.get(abbr);\n        return abbrGroup == null || (abbrGroup.size() == 1 && abbrGroup.contains(word));\n    }\n\n    private String getAbbreviation(String word) {\n        int n = word.length();\n        return n <= 2 ? word : word.charAt(0) + Integer.toString(n - 2) + word.charAt(n - 1);\n    }\n}\n```\n    \n    The algorithm first initializes the class by storing the words into a hash map with their abbreviations as keys and a set containing the words with this abbreviation as the value. This allows for efficient lookups and eliminates duplicates in the `dictionary`.\n\nFor the `isUnique` function, the algorithm first gets the abbreviation of the `word`. Then, it checks whether the abbreviation is not present in the hash map or whether the abbreviation is present with only one word (the same as the input word) in the set. If either of these conditions is met, the function returns `true`. Otherwise, it returns `false`.\n\nThe `get_abbreviation` function returns the abbreviated version of a given `word`. If the length of the `word` is less than or equal to 2, the function returns the `word` itself; otherwise, it returns the first character, the number of characters between the first and last characters, and the last character of the `word` as a string.\n    ",
        "python": "\n    ```python\nclass ValidWordAbbr:\n\n    def __init__(self, dictionary):\n        self.word_map = {}\n        for word in dictionary:\n            abbr = self.get_abbreviation(word)\n            if abbr not in self.word_map:\n                self.word_map[abbr] = {word}\n            else:\n                self.word_map[abbr].add(word)\n\n    def isUnique(self, word):\n        abbr = self.get_abbreviation(word)\n        abbr_group = self.word_map.get(abbr, set())\n        return len(abbr_group) == 0 or (len(abbr_group) == 1 and word in abbr_group)\n\n    def get_abbreviation(self, word):\n        n = len(word)\n        return word if n <= 2 else word[0] + str(n - 2) + word[-1]\n```\n\n    \n    The algorithm first initializes the class by storing the words into a hash map with their abbreviations as keys and a set containing the words with this abbreviation as the value. This allows for efficient lookups and eliminates duplicates in the `dictionary`.\n\nFor the `isUnique` function, the algorithm first gets the abbreviation of the `word`. Then, it checks whether the abbreviation is not present in the hash map or whether the abbreviation is present with only one word (the same as the input word) in the set. If either of these conditions is met, the function returns `true`. Otherwise, it returns `false`.\n\nThe `get_abbreviation` function returns the abbreviated version of a given `word`. If the length of the `word` is less than or equal to 2, the function returns the `word` itself; otherwise, it returns the first character, the number of characters between the first and last characters, and the last character of the `word` as a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n\nclass ValidWordAbbr {\npublic:\n    ValidWordAbbr(vector<string>& dictionary) {\n        for (auto& word : dictionary) {\n            string abbr = get_abbreviation(word);\n            word_map[abbr].insert(word);\n        }\n    }\n    \n    bool isUnique(string word) {\n        string abbr = get_abbreviation(word);\n        auto abbr_group = word_map.find(abbr);\n        return abbr_group == word_map.end() || (abbr_group->second.size() == 1 && abbr_group->second.count(word));\n    }\n    \nprivate:\n    unordered_map<string, unordered_set<string>> word_map;\n\n    string get_abbreviation(const string& word) {\n        int n = word.size();\n        return n <= 2 ? word : word.front() + to_string(n - 2) + word.back();\n    }\n};\n```\n    \n    The algorithm first initializes the class by storing the words into a hash map with their abbreviations as keys and a set containing the words with this abbreviation as the value. This allows for efficient lookups and eliminates duplicates in the `dictionary`.\n\nFor the `isUnique` function, the algorithm first gets the abbreviation of the `word`. Then, it checks whether the abbreviation is not present in the hash map or whether the abbreviation is present with only one word (the same as the input word) in the set. If either of these conditions is met, the function returns `true`. Otherwise, it returns `false`.\n\nThe `get_abbreviation` function returns the abbreviated version of a given `word`. If the length of the `word` is less than or equal to 2, the function returns the `word` itself; otherwise, it returns the first character, the number of characters between the first and last characters, and the last character of the `word` as a string.\n    ",
        "js": "\n    ```javascript\nclass ValidWordAbbr {\n    constructor(dictionary) {\n        this.wordMap = new Map();\n        for (let word of dictionary) {\n            let abbr = this.getAbbreviation(word);\n            if (!this.wordMap.has(abbr)) {\n                this.wordMap.set(abbr, new Set([word]));\n            } else {\n                this.wordMap.get(abbr).add(word);\n            }\n        }\n    }\n\n    isUnique(word) {\n        let abbr = this.getAbbreviation(word);\n        let abbrGroup = this.wordMap.get(abbr) || new Set();\n        return abbrGroup.size === 0 || (abbrGroup.size === 1 && abbrGroup.has(word));\n    }\n\n    getAbbreviation(word) {\n        let n = word.length;\n        return n <= 2 ? word : word[0] + (n - 2) + word[n - 1];\n    }\n}\n```\n\n    \n    The algorithm first initializes the class by storing the words into a hash map with their abbreviations as keys and a set containing the words with this abbreviation as the value. This allows for efficient lookups and eliminates duplicates in the `dictionary`.\n\nFor the `isUnique` function, the algorithm first gets the abbreviation of the `word`. Then, it checks whether the abbreviation is not present in the hash map or whether the abbreviation is present with only one word (the same as the input word) in the set. If either of these conditions is met, the function returns `true`. Otherwise, it returns `false`.\n\nThe `get_abbreviation` function returns the abbreviated version of a given `word`. If the length of the `word` is less than or equal to 2, the function returns the `word` itself; otherwise, it returns the first character, the number of characters between the first and last characters, and the last character of the `word` as a string.\n    "
    },
    {
        "id": 45,
        "title": "Word Pattern II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `pattern` and a string `s`, return `true` _if_ `s` _**matches** the_ `pattern`_._\n\nA string `s` **matches** a `pattern` if there is some **bijective mapping** of single characters to strings such that if each character in `pattern` is replaced by the string it maps to, then the resulting string is `s`. A **bijective mapping** means that no two characters map to the same string, and no character maps to two different strings.",
            "examples": [
                "**Example 1:**\n\n**Input:** pattern =  \"abab \", s =  \"redblueredblue \"\n**Output:** true\n**Explanation:** One possible mapping is as follows:\n'a' ->  \"red \"\n'b' ->  \"blue \"\n\n",
                "**Example 2:**\n\n**Input:** pattern =  \"aaaa \", s =  \"asdasdasdasd \"\n**Output:** true\n**Explanation:** One possible mapping is as follows:\n'a' ->  \"asd \"\n\n",
                "**Example 3:**\n\n**Input:** pattern =  \"aabb \", s =  \"xyzabcxzyabc \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pattern.length, s.length <= 20`\n*   `pattern` and `s` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abab\",\"redblueredblue\"",
                "output": "true"
            },
            {
                "input": "\"aaaa\",\"asdasdasdasd\"",
                "output": "true"
            },
            {
                "input": "\"aabb\",\"xyzabcxzyabc\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean wordPatternMatch(String pattern, String s) {\n    Map<Character, String> patternMap = new HashMap<>();\n    Set<String> words = new HashSet<>();\n    return backtrack(pattern, 0, s, 0, patternMap, words);\n}\n\nprivate boolean backtrack(String pattern, int pIndex, String s, int sIndex, Map<Character, String> patternMap, Set<String> words) {\n    if (pIndex == pattern.length() && sIndex == s.length()) return true;\n    if (pIndex == pattern.length() || sIndex == s.length()) return false;\n\n    char p = pattern.charAt(pIndex);\n    if (patternMap.containsKey(p)) {\n        String word = patternMap.get(p);\n        if (!s.startsWith(word, sIndex)) return false;\n        return backtrack(pattern, pIndex + 1, s, sIndex + word.length(), patternMap, words);\n    } else {\n        for (int length = 1; length <= s.length() - sIndex; length++) {\n            String word = s.substring(sIndex, sIndex + length);\n            if (words.contains(word)) continue;\n            patternMap.put(p, word);\n            words.add(word);\n            if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;\n            patternMap.remove(p);\n            words.remove(word);\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "python": "\n    ```python\ndef wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(p_index, s_index, pattern_map, words):\n        if p_index == len(pattern) and s_index == len(s):\n            return True\n        if p_index == len(pattern) or s_index == len(s):\n            return False\n\n        p = pattern[p_index]\n        if p in pattern_map:\n            word = pattern_map[p]\n            if not s.startswith(word, s_index):\n                return False\n            return backtrack(p_index + 1, s_index + len(word), pattern_map, words)\n        else:\n            for length in range(1, len(s) - s_index + 1):\n                word = s[s_index : s_index + length]\n                if word in words:\n                    continue\n                pattern_map[p] = word\n                words.add(word)\n                if backtrack(p_index + 1, s_index + length, pattern_map, words):\n                    return True\n                pattern_map.pop(p)\n                words.remove(word)\n        return False\n\n    return backtrack(0, 0, {}, set())\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "c++": "\n    ```cpp\nbool wordPatternMatch(string pattern, string s) {\n    unordered_map<char, string> pattern_map;\n    unordered_set<string> words;\n    return backtrack(pattern, 0, s, 0, pattern_map, words);\n}\n\nbool backtrack(string& pattern, int p_index, string& s, int s_index, unordered_map<char, string>& pattern_map, unordered_set<string>& words) {\n    if (p_index == pattern.size() && s_index == s.size()) return true;\n    if (p_index == pattern.size() || s_index == s.size()) return false;\n\n    char p = pattern[p_index];\n    if (pattern_map.count(p)) {\n        string word = pattern_map[p];\n        if (s.substr(s_index, word.size()) != word) return false;\n        return backtrack(pattern, p_index + 1, s, s_index + word.size(), pattern_map, words);\n    } else {\n        for (int length = 1; length <= s.size() - s_index; length++) {\n            string word = s.substr(s_index, length);\n            if (words.count(word)) continue;\n            pattern_map[p] = word;\n            words.insert(word);\n            if (backtrack(pattern, p_index + 1, s, s_index + length, pattern_map, words)) return true;\n            pattern_map.erase(p);\n            words.erase(word);\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "js": "\n    ```javascript\nvar wordPatternMatch = function(pattern, s) {\n    const patternMap = new Map();\n    const words = new Set();\n    return backtrack(pattern, 0, s, 0, patternMap, words);\n    \n    function backtrack(pattern, pIndex, s, sIndex, patternMap, words) {\n        if (pIndex == pattern.length && sIndex == s.length) return true;\n        if (pIndex == pattern.length || sIndex == s.length) return false;\n\n        let p = pattern[pIndex];\n        if (patternMap.has(p)) {\n            let word = patternMap.get(p);\n            if (s.slice(sIndex, sIndex + word.length) !== word) return false;\n            return backtrack(pattern, pIndex + 1, s, sIndex + word.length, patternMap, words);\n        } else {\n            for (let length = 1; length <= s.length - sIndex; length++) {\n                let word = s.substr(sIndex, length);\n                if (words.has(word)) continue;\n                patternMap.set(p, word);\n                words.add(word);\n                if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;\n                patternMap.delete(p);\n                words.delete(word);\n            }\n        }\n        return false;\n    }\n};\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    "
    },
    {
        "id": 46,
        "title": "Flip Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn all possible states of the string `currentState` after **one valid move**. You may return the answer in **any order**. If there is no valid move, return an empty list `[]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** \\[ \"--++ \", \"+--+ \", \"++-- \"\\]\n\n",
                "**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= currentState.length <= 500`\n*   `currentState[i]` is either `'+'` or `'-'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"++++\"",
                "output": "[\"--++\",\"+--+\",\"++--\"]"
            },
            {
                "input": "\"+\"",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generatePossibleNextMoves(String currentState) {\n    List<String> result = new ArrayList<>();\n    for (int i = 1; i < currentState.length(); i++) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {\n            result.add(currentState.substring(0, i - 1) + \"--\" + currentState.substring(i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "python": "\n    ```python\ndef generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState) {\n    std::vector<std::string> result;\n    for (int i = 1; i < currentState.size(); ++i) {\n        if (currentState[i] == '+' && currentState[i - 1] == '+') {\n            currentState[i] = currentState[i - 1] = '-';\n            result.push_back(currentState);\n            currentState[i] = currentState[i - 1] = '+';\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "js": "\n    ```javascript\nfunction generatePossibleNextMoves(currentState) {\n    const result = [];\n    for (let i = 1; i < currentState.length; i++) {\n        if (currentState[i] === '+' && currentState[i - 1] === '+') {\n            result.push(currentState.slice(0, i - 1) + '--' + currentState.slice(i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    "
    },
    {
        "id": 47,
        "title": "Flip Game II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn `true` _if the starting player can **guarantee a win**_, and `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** true\n**Explanation:** The starting player can guarantee a win by flipping the middle  \"++ \" to become  \"+--+ \".\n\n",
                "**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= currentState.length <= 60`\n*   `currentState[i]` is either `'+'` or `'-'`.\n\n**",
            "follow_up": "Follow up:** Derive your algorithm's runtime complexity."
        },
        "tag": [],
        "example": [
            {
                "input": "\"++++\"",
                "output": "true"
            },
            {
                "input": "\"+\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean canWin(String currentState) {\n    for (int i = 0; i < currentState.length() - 1; ++i) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {\n            String temp = currentState.substring(0, i) + \"--\" + currentState.substring(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "python": "\n    ```python\ndef canWin(currentState: str) -> bool:\n    for i in range(len(currentState) - 1):\n        if currentState[i] == '+' and currentState[i + 1] == '+':\n            temp = currentState[:i] + \"--\" + currentState[i + 2:]\n            if not canWin(temp):\n                return True\n    return False\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "c++": "\n    ```cpp\nbool canWin(string currentState) {\n    for (int i = 0; i < currentState.size() - 1; ++i) {\n        if (currentState[i] == '+' && currentState[i + 1] == '+') {\n            currentState[i] = '-';\n            currentState[i + 1] = '-';\n            bool opponentWins = canWin(currentState);\n            currentState[i] = '+';\n            currentState[i + 1] = '+';\n            if (!opponentWins) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "js": "\n    ```javascript\nfunction canWin(currentState) {\n    for (let i = 0; i < currentState.length - 1; ++i) {\n        if (currentState[i] === '+' && currentState[i + 1] === '+') {\n            let temp = currentState.slice(0, i) + \"--\" + currentState.slice(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    "
    },
    {
        "id": 48,
        "title": "Best Meeting Point",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` binary grid `grid` where each `1` marks the home of one friend, return _the minimal **total travel distance**_.\n\nThe **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.\n\nThe distance is calculated using [Manhattan Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0,1\\],\\[0,0,0,0,0\\],\\[0,0,1,0,0\\]\\]\n**Output:** 6\n**Explanation:** Given three friends living at (0,0), (0,4), and (2,2).\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.\nSo return 6.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.\n*   There will be **at least two** friends in the `grid`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
                "output": "6"
            },
            {
                "input": "[[1,1]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minTotalDistance(int[][] grid) {\n    List<Integer> rows = new ArrayList<Integer>();\n    List<Integer> cols = new ArrayList<Integer>();\n    int m = grid.length, n = grid[0].length;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                rows.add(i);\n                cols.add(j);\n            }\n        }\n    }\n    Collections.sort(cols);\n    int row_median = rows.get(rows.size() / 2), col_median = cols.get(cols.size() / 2);\n    int distance = 0;\n    for (int i : rows) distance += Math.abs(i - row_median);\n    for (int j : cols) distance += Math.abs(j - col_median);\n    return distance;\n}\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "python": "\n    ```python\ndef minTotalDistance(grid):\n    m, n = len(grid), len(grid[0])\n    rows, cols = [], []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows.append(i)\n                cols.append(j)\n\n    cols.sort()\n    row_median, col_median = rows[len(rows) // 2], cols[len(cols) // 2]\n    distance = sum(abs(i - row_median) for i in rows) + sum(abs(j - col_median) for j in cols)\n    return distance\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "c++": "\n    ```cpp\nint minTotalDistance(vector<vector<int>>& grid) {\n    vector<int> rows, cols;\n    int m = grid.size(), n = grid[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                rows.push_back(i);\n                cols.push_back(j);\n            }\n        }\n    }\n    sort(cols.begin(), cols.end());\n    int row_median = rows[rows.size() / 2], col_median = cols[cols.size() / 2];\n    int distance = 0;\n    for (int i : rows) distance += abs(i - row_median);\n    for (int j : cols) distance += abs(j - col_median);\n    return distance;\n}\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "js": "\n    ```javascript\nvar minTotalDistance = function(grid) {\n    let m = grid.length, n = grid[0].length;\n    let rows = [], cols = [];\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] === 1) {\n                rows.push(i);\n                cols.push(j);\n            }\n        }\n    }\n    cols.sort((a, b) => a - b);\n    let row_median = rows[Math.floor(rows.length / 2)], col_median = cols[Math.floor(cols.length / 2)];\n    let distance = rows.reduce((acc, i) => acc + Math.abs(i - row_median), 0) + cols.reduce((acc, j) => acc + Math.abs(j - col_median), 0);\n    return distance;\n};\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    "
    },
    {
        "id": 49,
        "title": "Binary Tree Longest Consecutive Sequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the length of the longest **consecutive sequence path**_.\n\nA **consecutive sequence path** is a path where the values **increase by one** along the path.\n\nNote that the path can start **at any node** in the tree, and you cannot go from a node to its parent in the path.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,null,null,5\\]\n**Output:** 3\n**Explanation:** Longest consecutive sequence path is 3-4-5, so return 3.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,null,3,2,null,1\\]\n**Output:** 2\n**Explanation:** Longest consecutive sequence path is 2-3, not 3-2-1, so return 2."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-3 * 104 <= Node.val <= 3 * 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,3,2,4,null,null,null,5]",
                "output": "3"
            },
            {
                "input": "[2,null,3,2,null,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int longestConsecutiveSequence(TreeNode root, int[] longestPath) {\n    if (root == null) {\n        return 0;\n    }\n    int left = longestConsecutiveSequence(root.left, longestPath);\n    int right = longestConsecutiveSequence(root.right, longestPath);\n    int currPath = 1;\n    if (root.left != null && root.left.val == root.val + 1) {\n        currPath = Math.max(currPath, left + 1);\n    }\n    if (root.right != null && root.right.val == root.val + 1) {\n        currPath = Math.max(currPath, right + 1);\n    }\n    longestPath[0] = Math.max(longestPath[0], currPath);\n    return currPath;\n}\n\npublic int longestConsecutive(TreeNode root) {\n    int[] longestPath = new int[1];\n    longestConsecutiveSequence(root, longestPath);\n    return longestPath[0];\n}\n```\n\n    \n    The solution is using depth-first search on the binary tree with a recursive function `longestConsecutiveSequence`. This function takes a node as input and returns the longest path of consecutive values that starts at that node. It also updates an array `longestPath` that stores the longest path seen so far, allowing multiple levels of the recursive function calls to access and update it.\n\nFor each node, the function first calls itself recursively for left and right child nodes. Then, it checks if the left and right children are consecutive values to the current value, and if so, adds the corresponding paths to `currPath`. Finally, it compares `currPath` with the maximum path found so far and updates the `longestPath` array accordingly. The longest consecutive path is returned after the recursion is complete.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longest_consecutive_sequence(root, longest_path):\n    if root is None:\n        return 0\n    left = longest_consecutive_sequence(root.left, longest_path)\n    right = longest_consecutive_sequence(root.right, longest_path)\n    curr_path = 1\n    if root.left and root.left.val == root.val + 1:\n        curr_path = max(curr_path, left + 1)\n    if root.right and root.right.val == root.val + 1:\n        curr_path = max(curr_path, right + 1)\n    longest_path[0] = max(longest_path[0], curr_path)\n    return curr_path\n\ndef longest_consecutive(root):\n    longest_path = [0]\n    longest_consecutive_sequence(root, longest_path)\n    return longest_path[0]\n```\n\n    \n    The solution is using depth-first search on the binary tree with a recursive function `longestConsecutiveSequence`. This function takes a node as input and returns the longest path of consecutive values that starts at that node. It also updates an array `longestPath` that stores the longest path seen so far, allowing multiple levels of the recursive function calls to access and update it.\n\nFor each node, the function first calls itself recursively for left and right child nodes. Then, it checks if the left and right children are consecutive values to the current value, and if so, adds the corresponding paths to `currPath`. Finally, it compares `currPath` with the maximum path found so far and updates the `longestPath` array accordingly. The longest consecutive path is returned after the recursion is complete.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint longestConsecutiveSequence(TreeNode* root, int &longestPath) {\n    if (root == NULL) {\n        return 0;\n    }\n    int left = longestConsecutiveSequence(root->left, longestPath);\n    int right = longestConsecutiveSequence(root->right, longestPath);\n    int currPath = 1;\n    if (root->left != NULL && root->left->val == root->val + 1) {\n        currPath = max(currPath, left + 1);\n    }\n    if (root->right != NULL && root->right->val == root->val + 1) {\n        currPath = max(currPath, right + 1);\n    }\n    longestPath = max(longestPath, currPath);\n    return currPath;\n}\n\nint longestConsecutive(TreeNode* root) {\n    int longestPath = 0;\n    longestConsecutiveSequence(root, longestPath);\n    return longestPath;\n}\n```\n\n    \n    The solution is using depth-first search on the binary tree with a recursive function `longestConsecutiveSequence`. This function takes a node as input and returns the longest path of consecutive values that starts at that node. It also updates an array `longestPath` that stores the longest path seen so far, allowing multiple levels of the recursive function calls to access and update it.\n\nFor each node, the function first calls itself recursively for left and right child nodes. Then, it checks if the left and right children are consecutive values to the current value, and if so, adds the corresponding paths to `currPath`. Finally, it compares `currPath` with the maximum path found so far and updates the `longestPath` array accordingly. The longest consecutive path is returned after the recursion is complete.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction longestConsecutiveSequence(root, longestPath) {\n    if (!root) {\n        return 0;\n    }\n    const left = longestConsecutiveSequence(root.left, longestPath);\n    const right = longestConsecutiveSequence(root.right, longestPath);\n    let currPath = 1;\n    if (root.left && root.left.val === root.val + 1) {\n        currPath = Math.max(currPath, left + 1);\n    }\n    if (root.right && root.right.val === root.val + 1) {\n        currPath = Math.max(currPath, right + 1);\n    }\n    longestPath[0] = Math.max(longestPath[0], currPath);\n    return currPath;\n}\n\nfunction longestConsecutive(root) {\n    const longestPath = [0];\n    longestConsecutiveSequence(root, longestPath);\n    return longestPath[0];\n}\n```\n\n    \n    The solution is using depth-first search on the binary tree with a recursive function `longestConsecutiveSequence`. This function takes a node as input and returns the longest path of consecutive values that starts at that node. It also updates an array `longestPath` that stores the longest path seen so far, allowing multiple levels of the recursive function calls to access and update it.\n\nFor each node, the function first calls itself recursively for left and right child nodes. Then, it checks if the left and right children are consecutive values to the current value, and if so, adds the corresponding paths to `currPath`. Finally, it compares `currPath` with the maximum path found so far and updates the `longestPath` array accordingly. The longest consecutive path is returned after the recursion is complete.\n    "
    },
    {
        "id": 50,
        "title": "Smallest Rectangle Enclosing Black Pixels",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` binary matrix `image` where `0` represents a white pixel and `1` represents a black pixel.\n\nThe black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.\n\nGiven two integers `x` and `y` that represents the location of one of the black pixels, return _the area of the smallest (axis-aligned) rectangle that encloses all black pixels_.\n\nYou must write an algorithm with less than `O(mn)` runtime complexity",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[ \"0 \", \"0 \", \"1 \", \"0 \"\\],\\[ \"0 \", \"1 \", \"1 \", \"0 \"\\],\\[ \"0 \", \"1 \", \"0 \", \"0 \"\\]\\], x = 0, y = 2\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[ \"1 \"\\]\\], x = 0, y = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 100`\n*   `image[i][j]` is either `'0'` or `'1'`.\n*   `0 <= x < m`\n*   `0 <= y < n`\n*   `image[x][y] == '1'.`\n*   The black pixels in the `image` only form **one component**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"0\"]],0,2",
                "output": "6"
            },
            {
                "input": "[[\"1\"]],0,0",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minArea(char[][] image, int x, int y) {\n    int top = x, bottom = x, left = y, right = y;\n    for (int i = 0; i < image.length; ++i) {\n        for (int j = 0; j < image[i].length; ++j) {\n            if (image[i][j] == '1') {\n                top = Math.min(top, i);\n                bottom = Math.max(bottom, i);\n                left = Math.min(left, j);\n                right = Math.max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "python": "\n    ```python\ndef minArea(image, x, y):\n    top, bottom, left, right = x, x, y, y\n    for i, row in enumerate(image):\n        for j, cell in enumerate(row):\n            if cell == '1':\n                top, bottom = min(top, i), max(bottom, i)\n                left, right = min(left, j), max(right, j)\n    return (bottom - top + 1) * (right - left + 1)\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "c++": "\n    ```cpp\nint minArea(vector<vector<char>>& image, int x, int y) {\n    int top = x, bottom = x, left = y, right = y;\n    for (int i = 0; i < image.size(); ++i) {\n        for (int j = 0; j < image[i].size(); ++j) {\n            if (image[i][j] == '1') {\n                top = min(top, i);\n                bottom = max(bottom, i);\n                left = min(left, j);\n                right = max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "js": "\n    ```javascript\nfunction minArea(image, x, y) {\n    let top = x, bottom = x, left = y, right = y;\n    for (let i = 0; i < image.length; ++i) {\n        for (let j = 0; j < image[i].length; ++j) {\n            if (image[i][j] === '1') {\n                top = Math.min(top, i);\n                bottom = Math.max(bottom, i);\n                left = Math.min(left, j);\n                right = Math.max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    "
    },
    {
        "id": 51,
        "title": "Range Sum Query - Immutable",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, handle multiple queries of the following type:\n\n1.  Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n*   `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n*   `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"NumArray \",  \"sumRange \",  \"sumRange \",  \"sumRange \"\\]\n\\[\\[\\[-2, 0, 3, -5, 2, -1\\]\\], \\[0, 2\\], \\[2, 5\\], \\[0, 5\\]\\]\n**Output**\n\\[null, 1, -1, -3\\]\n\n**Explanation**\nNumArray numArray = new NumArray(\\[-2, 0, 3, -5, 2, -1\\]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n*   `0 <= left <= right < nums.length`\n*   At most `104` calls will be made to `sumRange`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[0,2],[2,5],[0,5]]",
                "output": "**Output**\n[null,1,-1,-3]"
            }
        ],
        "java": "\n    ```java\nclass NumArray {\n    int[] pSum;\n\n    public NumArray(int[] nums) {\n        pSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            pSum[i + 1] = pSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return pSum[right + 1] - pSum[left];\n    }\n}\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    ",
        "python": "\n    ```python\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.pSum = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            self.pSum[i + 1] = self.pSum[i] + num\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.pSum[right + 1] - self.pSum[left]\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nclass NumArray {\npublic:\n    std::vector<int> pSum;\n\n    NumArray(std::vector<int> &nums) {\n        pSum.resize(nums.size() + 1);\n        for (int i = 0; i < nums.size(); i++) {\n            pSum[i + 1] = pSum[i] + nums[i];\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return pSum[right + 1] - pSum[left];\n    }\n};\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    ",
        "js": "\n    ```javascript\nclass NumArray {\n    constructor(nums) {\n        this.pSum = new Array(nums.length + 1).fill(0);\n        for (let i = 0; i < nums.length; i++) {\n            this.pSum[i + 1] = this.pSum[i] + nums[i];\n        }\n    }\n\n    sumRange(left, right) {\n        return this.pSum[right + 1] - this.pSum[left];\n    }\n}\n```\n    \n    The algorithm uses the concept of prefix-sum to answer range-sum queries efficiently. In the constructor, we iterate through the input `nums` array and build an additional `pSum` array, which stores the prefix sum for each position i, i.e., sum of all elements from index 0 to index i (inclusive) of `nums`.\n\nThe `sumRange` method is simply a matter of taking the difference between two elements in the prefix-sum array. This difference will be the sum of elements between the given `left` and `right` indices (inclusive) in the input array.\n\nThe algorithm has a time complexity of O(1) for `sumRange` queries after the O(n) pre-processing of the input array during the constructor call. The space complexity is O(n) for the `pSum` array.\n    "
    },
    {
        "id": 52,
        "title": "Range Sum Query 2D - Immutable",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a 2D matrix `matrix`, handle multiple queries of the following type:\n\n*   Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nImplement the `NumMatrix` class:\n\n*   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.\n*   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nYou must design an algorithm where `sumRegion` works on `O(1)` time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"NumMatrix \",  \"sumRegion \",  \"sumRegion \",  \"sumRegion \"\\]\n\\[\\[\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]\\], \\[2, 1, 4, 3\\], \\[1, 1, 2, 2\\], \\[1, 2, 2, 4\\]\\]\n**Output**\n\\[null, 8, 11, 12\\]\n\n**Explanation**\nNumMatrix numMatrix = new NumMatrix(\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `-104 <= matrix[i][j] <= 104`\n*   `0 <= row1 <= row2 < m`\n*   `0 <= col1 <= col2 < n`\n*   At most `104` calls will be made to `sumRegion`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]",
                "output": "**Output**\n[null,8,11,12]"
            }
        ],
        "java": "\n    ```java\nclass NumMatrix {\n    private int[][] dp;\n\n    public NumMatrix(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        dp = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n    }\n}\n```\n    \n    We can preprocess the matrix by creating a 2D array `dp` to store the sum of all elements in the rectangle from `(0, 0)` to `(i, j)` for each position `(i, j)`. For each position, we can calculate the sum using the previously computed sums: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]`. This way, we only need to calculate the sum once for each rectangle.\n\nAfter preprocessing, we can answer the query `sumRegion(row1, col1, row2, col2)` in constant time. The sum of the elements in the query rectangle can be calculated as follows: `dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]`. This is done by taking the sum of all elements in the rectangle from `(0, 0)` to `(row2, col2)` and then subtracting the sums of the rectangles from `(0, 0)` to `(row1 - 1, col2)` and from `(0, 0)` to `(row2, col1 - 1)`, and finally adding the sum of the rectangle from `(0, 0)` to `(row1 - 1, col1 - 1)` to avoid double subtraction.\n    ",
        "python": "\n    ```python\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        self.dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]\n```\n    \n    We can preprocess the matrix by creating a 2D array `dp` to store the sum of all elements in the rectangle from `(0, 0)` to `(i, j)` for each position `(i, j)`. For each position, we can calculate the sum using the previously computed sums: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]`. This way, we only need to calculate the sum once for each rectangle.\n\nAfter preprocessing, we can answer the query `sumRegion(row1, col1, row2, col2)` in constant time. The sum of the elements in the query rectangle can be calculated as follows: `dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]`. This is done by taking the sum of all elements in the rectangle from `(0, 0)` to `(row2, col2)` and then subtracting the sums of the rectangles from `(0, 0)` to `(row1 - 1, col2)` and from `(0, 0)` to `(row2, col1 - 1)`, and finally adding the sum of the rectangle from `(0, 0)` to `(row1 - 1, col1 - 1)` to avoid double subtraction.\n    ",
        "c++": "\n    ```cpp\nclass NumMatrix {\npublic:\n    vector<vector<int>> dp;\n    \n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        dp = vector<vector<int>>(m + 1, vector<int>(n + 1));\n        \n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n    }\n};\n```\n    \n    We can preprocess the matrix by creating a 2D array `dp` to store the sum of all elements in the rectangle from `(0, 0)` to `(i, j)` for each position `(i, j)`. For each position, we can calculate the sum using the previously computed sums: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]`. This way, we only need to calculate the sum once for each rectangle.\n\nAfter preprocessing, we can answer the query `sumRegion(row1, col1, row2, col2)` in constant time. The sum of the elements in the query rectangle can be calculated as follows: `dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]`. This is done by taking the sum of all elements in the rectangle from `(0, 0)` to `(row2, col2)` and then subtracting the sums of the rectangles from `(0, 0)` to `(row1 - 1, col2)` and from `(0, 0)` to `(row2, col1 - 1)`, and finally adding the sum of the rectangle from `(0, 0)` to `(row1 - 1, col1 - 1)` to avoid double subtraction.\n    ",
        "js": "\n    ```javascript\nclass NumMatrix {\n    constructor(matrix) {\n        this.dp = [];\n        let m = matrix.length;\n        let n = matrix[0].length;\n        \n        for (let i = 0; i <= m; i++) {\n            this.dp[i] = new Array(n + 1).fill(0);\n        }\n        \n        for (let i = 1; i <= m; i++) {\n            for (let j = 1; j <= n; j++) {\n                this.dp[i][j] = this.dp[i - 1][j] + this.dp[i][j - 1] - this.dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n    \n    sumRegion(row1, col1, row2, col2) {\n        return this.dp[row2 + 1][col2 + 1] - this.dp[row1][col2 + 1] - this.dp[row2 + 1][col1] + this.dp[row1][col1];\n    }\n}\n```\n    \n    We can preprocess the matrix by creating a 2D array `dp` to store the sum of all elements in the rectangle from `(0, 0)` to `(i, j)` for each position `(i, j)`. For each position, we can calculate the sum using the previously computed sums: `dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]`. This way, we only need to calculate the sum once for each rectangle.\n\nAfter preprocessing, we can answer the query `sumRegion(row1, col1, row2, col2)` in constant time. The sum of the elements in the query rectangle can be calculated as follows: `dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]`. This is done by taking the sum of all elements in the rectangle from `(0, 0)` to `(row2, col2)` and then subtracting the sums of the rectangles from `(0, 0)` to `(row1 - 1, col2)` and from `(0, 0)` to `(row2, col1 - 1)`, and finally adding the sum of the rectangle from `(0, 0)` to `(row1 - 1, col1 - 1)` to avoid double subtraction.\n    "
    },
    {
        "id": 53,
        "title": "Number of Islands II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).\n\nWe may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [ri, ci]` is the position `(ri, ci)` at which we should operate the `ith` operation.\n\nReturn _an array of integers_ `answer` _where_ `answer[i]` _is the number of islands after turning the cell_ `(ri, ci)` _into a land_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, positions = \\[\\[0,0\\],\\[0,1\\],\\[1,2\\],\\[2,1\\]\\]\n**Output:** \\[1,1,2,3\\]\n**Explanation:**\nInitially, the 2d grid is filled with water.\n- Operation #1: addLand(0, 0) turns the water at grid\\[0\\]\\[0\\] into a land. We have 1 island.\n- Operation #2: addLand(0, 1) turns the water at grid\\[0\\]\\[1\\] into a land. We still have 1 island.\n- Operation #3: addLand(1, 2) turns the water at grid\\[1\\]\\[2\\] into a land. We have 2 islands.\n- Operation #4: addLand(2, 1) turns the water at grid\\[2\\]\\[1\\] into a land. We have 3 islands.\n\n",
                "**Example 2:**\n\n**Input:** m = 1, n = 1, positions = \\[\\[0,0\\]\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n, positions.length <= 104`\n*   `1 <= m * n <= 104`\n*   `positions[i].length == 2`\n*   `0 <= ri < m`\n*   `0 <= ci < n`\n\n**",
            "follow_up": "Follow up:** Could you solve it in time complexity `O(k log(mn))`, where `k == positions.length`?"
        },
        "tag": [],
        "example": [
            {
                "input": "3,3,[[0,0],[0,1],[1,2],[2,1]]",
                "output": "[1,1,2,3]"
            },
            {
                "input": "1,1,[[0,0]]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<Integer> numIslands2(int m, int n, int[][] positions) {\n    int[] roots = new int[m * n];\n    Arrays.fill(roots, -1);\n    int[][] dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int islandCount = 0;\n    List<Integer> result = new ArrayList<>();\n\n    for (int[] position : positions) {\n        int i = position[0], j = position[1], index = i * n + j;\n        if (roots[index] != -1) {\n            result.add(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[index] = index;\n        for (int[] dir : dirs) {\n            int ni = i + dir[0], nj = j + dir[1], neighbor = ni * n + nj;\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {\n                int rootNb = find(roots, neighbor);\n                if (index != rootNb) {\n                    roots[rootNb] = index;\n                    islandCount--;\n                }\n            }\n        }\n        result.add(islandCount);\n    }\n    return result;\n}\n\nprivate int find(int[] roots, int x) {\n    if (roots[x] != x) roots[x] = find(roots, roots[x]);\n    return roots[x];\n}\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "python": "\n    ```python\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:\n    def index(x: int, y: int) -> int:\n        return x * n + y\n    \n    def find(x: int) -> int:\n        if roots[x] != x:\n            roots[x] = find(roots[x])\n        return roots[x]\n\n    roots = [-1] * (m * n)\n    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    islandCount = 0\n    result = []\n\n    for i, j in positions:\n        idx = index(i, j)\n        if roots[idx] != -1:\n            result.append(islandCount)\n            continue\n        islandCount += 1\n        roots[idx] = idx\n        for dx, dy in dirs:\n            ni, nj = i + dx, j + dy\n            neighbor = index(ni, nj)\n            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:\n                root_neighbor = find(neighbor)\n                if idx != root_neighbor:\n                    roots[root_neighbor] = idx\n                    islandCount -= 1\n        result.append(islandCount)\n    return result\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nusing namespace std;\n\nvector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {\n    vector<int> roots(m * n, -1);\n    vector<vector<int>> dirs{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int islandCount = 0;\n    vector<int> result;\n    \n    auto getIndex = [&](int i, int j){\n        return i * n + j;\n    };        \n    \n    function<int(int)> findRoot = [&](int x) {\n        if (roots[x] != x) {\n            roots[x] = findRoot(roots[x]);\n        }\n        return roots[x];\n    };\n    \n    for(const auto& position : positions) {\n        int i = position[0], j = position[1], index = getIndex(i, j);\n        if (roots[index] != -1) {\n            result.push_back(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[index] = index;\n        for (const auto& dir : dirs) {\n            int ni = i + dir[0], nj = j + dir[1], neighbor = getIndex(ni, nj);\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {\n                int rootNb = findRoot(neighbor);\n                if (index != rootNb) {\n                    roots[rootNb] = index;\n                    islandCount--;\n                }\n            }\n        }\n        result.push_back(islandCount);\n    }\n    return result;\n}\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "js": "\n    ```javascript\nfunction numIslands2(m, n, positions) {\n    const roots = new Array(m * n).fill(-1);\n    const dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]];\n    let islandCount = 0;\n    const result = [];\n\n    const index = (x, y) => x * n + y;\n    \n    function find(x) {\n        if (roots[x] !== x) roots[x] = find(roots[x]);\n        return roots[x];\n    }\n\n    for (const [i, j] of positions) {\n        const idx = index(i, j);\n        if (roots[idx] !== -1) {\n            result.push(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[idx] = idx;\n        for (const [dx, dy] of dirs) {\n            const ni = i + dx, nj = j + dy;\n            const neighbor = index(ni, nj);\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] !== -1) {\n                const root_neighbor = find(neighbor);\n                if (idx !== root_neighbor) {\n                    roots[root_neighbor] = idx;\n                    islandCount--;\n                }\n            }\n        }\n        result.push(islandCount);\n    }\n    return result;\n}\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    "
    },
    {
        "id": 54,
        "title": "Range Sum Query - Mutable",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, handle multiple queries of the following types:\n\n1.  **Update** the value of an element in `nums`.\n2.  Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n*   `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n*   `void update(int index, int val)` **Updates** the value of `nums[index]` to be `val`.\n*   `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"NumArray \",  \"sumRange \",  \"update \",  \"sumRange \"\\]\n\\[\\[\\[1, 3, 5\\]\\], \\[0, 2\\], \\[1, 2\\], \\[0, 2\\]\\]\n**Output**\n\\[null, 9, null, 8\\]\n\n**Explanation**\nNumArray numArray = new NumArray(\\[1, 3, 5\\]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = \\[1, 2, 5\\]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-100 <= nums[i] <= 100`\n*   `0 <= index < nums.length`\n*   `-100 <= val <= 100`\n*   `0 <= left <= right < nums.length`\n*   At most `3 * 104` calls will be made to `update` and `sumRange`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[0,2],[1,2],[0,2]]",
                "output": "**Output**\n[null,9,null,8]"
            }
        ],
        "java": "\n    ```java\nclass NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}\n```\n\n    \n    The algorithm uses a prefix sum array to efficiently answer the range sum queries. The idea is to pre-process the input array by creating an auxiliary array prefixSum, where prefixSum[i] stores the sum of the first i elements. This allows us to compute the sum of elements in a range [left, right] in constant time, by simply returning the difference between prefixSum[right+1] and prefixSum[left]. To generate the prefixSum array, we iterate through the input array nums, and for each element, we add its value to the prefixSum array using the previous prefixSum value.\n\nThe time complexity of creating the prefixSum array is O(n) and each range sum query will take O(1) time since we just need to access and subtract two elements in the prefixSum array.\n    ",
        "python": "\n    ```python\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n```\n\n    \n    The algorithm uses a prefix sum array to efficiently answer the range sum queries. The idea is to pre-process the input array by creating an auxiliary array prefixSum, where prefixSum[i] stores the sum of the first i elements. This allows us to compute the sum of elements in a range [left, right] in constant time, by simply returning the difference between prefixSum[right+1] and prefixSum[left]. To generate the prefixSum array, we iterate through the input array nums, and for each element, we add its value to the prefixSum array using the previous prefixSum value.\n\nThe time complexity of creating the prefixSum array is O(n) and each range sum query will take O(1) time since we just need to access and subtract two elements in the prefixSum array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nclass NumArray {\npublic:\n    std::vector<int> prefix_sum;\n\n    NumArray(std::vector<int>& nums) {\n        prefix_sum.resize(nums.size() + 1);\n        for (int i = 0; i < nums.size(); ++i) {\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return prefix_sum[right + 1] - prefix_sum[left];\n    }\n};\n```\n\n    \n    The algorithm uses a prefix sum array to efficiently answer the range sum queries. The idea is to pre-process the input array by creating an auxiliary array prefixSum, where prefixSum[i] stores the sum of the first i elements. This allows us to compute the sum of elements in a range [left, right] in constant time, by simply returning the difference between prefixSum[right+1] and prefixSum[left]. To generate the prefixSum array, we iterate through the input array nums, and for each element, we add its value to the prefixSum array using the previous prefixSum value.\n\nThe time complexity of creating the prefixSum array is O(n) and each range sum query will take O(1) time since we just need to access and subtract two elements in the prefixSum array.\n    ",
        "js": "\n    ```javascript\nclass NumArray {\n    constructor(nums) {\n        this.prefixSum = [0];\n        for (let i = 0; i < nums.length; i++) {\n            this.prefixSum[i + 1] = this.prefixSum[i] + nums[i];\n        }\n    }\n\n    sumRange(left, right) {\n        return this.prefixSum[right + 1] - this.prefixSum[left];\n    }\n}\n```\n\n    \n    The algorithm uses a prefix sum array to efficiently answer the range sum queries. The idea is to pre-process the input array by creating an auxiliary array prefixSum, where prefixSum[i] stores the sum of the first i elements. This allows us to compute the sum of elements in a range [left, right] in constant time, by simply returning the difference between prefixSum[right+1] and prefixSum[left]. To generate the prefixSum array, we iterate through the input array nums, and for each element, we add its value to the prefixSum array using the previous prefixSum value.\n\nThe time complexity of creating the prefixSum array is O(n) and each range sum query will take O(1) time since we just need to access and subtract two elements in the prefixSum array.\n    "
    },
    {
        "id": 55,
        "title": "Range Sum Query 2D - Mutable",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a 2D matrix `matrix`, handle multiple queries of the following types:\n\n1.  **Update** the value of a cell in `matrix`.\n2.  Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nImplement the NumMatrix class:\n\n*   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.\n*   `void update(int row, int col, int val)` **Updates** the value of `matrix[row][col]` to be `val`.\n*   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"NumMatrix \",  \"sumRegion \",  \"update \",  \"sumRegion \"\\]\n\\[\\[\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]\\], \\[2, 1, 4, 3\\], \\[3, 2, 2\\], \\[2, 1, 4, 3\\]\\]\n**Output**\n\\[null, 8, null, 10\\]\n\n**Explanation**\nNumMatrix numMatrix = new NumMatrix(\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)\nnumMatrix.update(3, 2, 2);       // matrix changes from left image to right image\nnumMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= matrix[i][j] <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\n*   `-1000 <= val <= 1000`\n*   `0 <= row1 <= row2 < m`\n*   `0 <= col1 <= col2 < n`\n*   At most `5000` calls will be made to `sumRegion` and `update`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],]]],[2,1,4,3],[3,2,2],[2,1,4,3]]",
                "output": "**Output**\n[null,8,null,10]"
            }
        ],
        "java": "\n    ```java\nclass NumMatrix {\n    int[][] dp;\n    public NumMatrix(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        dp = new int[m + 1][n + 1];\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    public void update(int row, int col, int val) {\n        int oldValue = dp[row + 1][col + 1] - dp[row + 1][col] - dp[row][col + 1] + dp[row][col];\n        int delta = val - oldValue;\n        for(int i = row + 1; i < dp.length; i++)\n            for(int j = col + 1; j < dp[0].length; j++)\n                dp[i][j] += delta;\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];\n    }\n}\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    ",
        "python": "\n    ```python\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        self.dp = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                self.dp[i + 1][j + 1] = self.dp[i + 1][j] + self.dp[i][j + 1] - self.dp[i][j] + matrix[i][j]\n                \n    def update(self, row: int, col: int, val: int) -> None:\n        oldValue = self.dp[row + 1][col + 1] - self.dp[row + 1][col] - self.dp[row][col + 1] + self.dp[row][col]\n        delta = val - oldValue\n        for i in range(row + 1, len(self.dp)):\n            for j in range(col + 1, len(self.dp[0])):\n                self.dp[i][j] += delta\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    ",
        "c++": "\n    ```cpp\nclass NumMatrix {\npublic:\n    vector<vector<int>> dp;\n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        dp.resize(m + 1, vector<int>(n + 1, 0));\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    void update(int row, int col, int val) {\n        int oldValue = dp[row + 1][col + 1] - dp[row + 1][col] - dp[row][col + 1] + dp[row][col];\n        int delta = val - oldValue;\n        for(int i = row + 1; i < dp.size(); i++)\n            for(int j = col + 1; j < dp[0].size(); j++)\n                dp[i][j] += delta;\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];\n    }\n};\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    ",
        "js": "\n    ```javascript\nclass NumMatrix {\n    constructor(matrix) {\n        this.dp = new Array(matrix.length + 1).fill().map(() => new Array(matrix[0].length + 1).fill(0));\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                this.dp[i + 1][j + 1] = this.dp[i + 1][j] + this.dp[i][j + 1] - this.dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    update(row, col, val) {\n        let oldValue = this.dp[row + 1][col + 1] - this.dp[row + 1][col] - this.dp[row][col + 1] + this.dp[row][col];\n        let delta = val - oldValue;\n        for (let i = row + 1; i < this.dp.length; i++) {\n            for (let j = col + 1; j < this.dp[0].length; j++) {\n                this.dp[i][j] += delta;\n            }\n        }\n    }\n\n    sumRegion(row1, col1, row2, col2) {\n        return this.dp[row2 + 1][col2 + 1] - this.dp[row2 + 1][col1] - this.dp[row1][col2 + 1] + this.dp[row1][col1];\n    }\n}\n```\n\n    \n    1. When initializing the object, create a 2D table `dp` to store partial sums of the 2D array `matrix`. The dimensions of `dp` is one unit larger than the dimensions of `matrix`.\n2. For each element (i, j) in `matrix`, add its value to the partial sums `dp[i+1][j] + dp[i][j+1]`, subtract the overlapping sum `dp[i][j]`, and store the result at `dp[i+1][j+1]`.\n3. When updating the value of a cell, calculate the difference between the new and old values, and propagate it through the remaining cells in the corresponding row and column in the `dp` table.\n4. To calculate the sum within a given rectangle, use the values stored in the `dp` table as follows:\n  - Add the value of the lower-right corner: `dp[row2+1][col2+1]`\n  - Subtract the values of the upper-right and lower-left corners: `dp[row2+1][col1]` and `dp[row1][col2+1]`\n  - Add back the value of the upper-left corner: `dp[row1][col1]`\n    "
    },
    {
        "id": 56,
        "title": "Sparse Matrix Multiplication",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat1 = \\[\\[1,0,0\\],\\[-1,0,3\\]\\], mat2 = \\[\\[7,0,0\\],\\[0,0,0\\],\\[0,0,1\\]\\]\n**Output:** \\[\\[7,0,0\\],\\[-7,0,3\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat1 = \\[\\[0\\]\\], mat2 = \\[\\[0\\]\\]\n**Output:** \\[\\[0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat1.length`\n*   `k == mat1[i].length == mat2.length`\n*   `n == mat2[i].length`\n*   `1 <= m, n, k <= 100`\n*   `-100 <= mat1[i][j], mat2[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,0,0],[-1,0,3]],[[7,0,0],[0,0,0],[0,0,1]]",
                "output": "[[7,0,0],[-7,0,3]]"
            },
            {
                "input": "[[0]],[[0]]",
                "output": "[[0]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] multiply(int[][] mat1, int[][] mat2) {\n    int m = mat1.length;\n    int k = mat1[0].length;\n    int n = mat2[0].length;\n    int[][] result = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "python": "\n    ```python\ndef multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {\n    int m = mat1.size();\n    int k = mat1[0].size();\n    int n = mat2[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "js": "\n    ```javascript\nfunction multiply(mat1, mat2) {\n    const m = mat1.length;\n    const k = mat1[0].length;\n    const n = mat2[0].length;\n    const result = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < k; j++) {\n            if (mat1[i][j] !== 0) {\n                for (let l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    "
    },
    {
        "id": 57,
        "title": "Binary Tree Vertical Order Traversal",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _**the vertical order traversal** of its nodes' values_. (i.e., from top to bottom, column by column).\n\nIf two nodes are in the same row and column, the order should be from **left to right**.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[9\\],\\[3,15\\],\\[20\\],\\[7\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,9,8,4,0,1,7\\]\n**Output:** \\[\\[4\\],\\[9\\],\\[3,0,1\\],\\[8\\],\\[7\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[3,9,8,4,0,1,7,null,null,null,2,5\\]\n**Output:** \\[\\[4\\],\\[9,5\\],\\[3,0,1\\],\\[8,2\\],\\[7\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "[[9],[3,15],[20],[7]]"
            },
            {
                "input": "[3,9,8,4,0,1,7]",
                "output": "[[4],[9],[3,0,1],[8],[7]]"
            },
            {
                "input": "[3,9,8,4,0,1,7,null,null,null,2,5]",
                "output": "[[4],[9,5],[3,0,1],[8,2],[7]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        if (root == null) return new ArrayList<>();\n\n        HashMap<Integer, List<Integer>> columnTable = new HashMap<>();\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\n        q.offer(new Pair<>(root, 0));\n\n        while (!q.isEmpty()) {\n            TreeNode curNode = q.peek().getKey();\n            int column = q.peek().getValue();\n            q.poll();\n\n            if (curNode != null) {\n                columnTable.putIfAbsent(column, new ArrayList<>());\n                columnTable.get(column).add(curNode.val);\n                q.offer(new Pair<>(curNode.left, column - 1));\n                q.offer(new Pair<>(curNode.right, column + 1));\n            }\n        }\n\n        return new ArrayList<>(columnTable.values());\n    }\n}\n```\n    \n    The algorithm for vertical order traversal works as follows:\n1. Create a mapping of columns to their corresponding node values. Initialize a queue to store nodes and their columns, starting with the root at column 0.\n2. While the queue is not empty, dequeue the node and column. Add the node's value to the corresponding column in the mapping.\n3. Enqueue the node's left and right children with their respective column values (left child gets column -1, right child gets column +1).\n4. After the queue is empty, collect the node values for each column in order and put them into the result array.\n\nThe algorithm works for each language implementation.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verticalOrder(root: Optional[TreeNode]) -> List[List[int]]:\n    if not root: return []\n\n    column_table = defaultdict(list)\n    q = deque([(root, 0)])\n\n    while q:\n        cur_node, column = q.popleft()\n\n        if cur_node:\n            column_table[column].append(cur_node.val)\n            q.append((cur_node.left, column - 1))\n            q.append((cur_node.right, column + 1))\n\n    return [column_table[key] for key in sorted(column_table)]\n```\n    \n    The algorithm for vertical order traversal works as follows:\n1. Create a mapping of columns to their corresponding node values. Initialize a queue to store nodes and their columns, starting with the root at column 0.\n2. While the queue is not empty, dequeue the node and column. Add the node's value to the corresponding column in the mapping.\n3. Enqueue the node's left and right children with their respective column values (left child gets column -1, right child gets column +1).\n4. After the queue is empty, collect the node values for each column in order and put them into the result array.\n\nThe algorithm works for each language implementation.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n#include <queue>\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::vector<int>> verticalOrder(TreeNode* root) {\n    if (!root) return {};\n\n    std::map<int, std::vector<int>> columnTable;\n    std::queue<std::pair<TreeNode*, int>> q;\n    q.push({root, 0});\n\n    while (!q.empty()) {\n        TreeNode* curNode = q.front().first;\n        int column = q.front().second;\n        q.pop();\n\n        if (curNode) {\n            columnTable[column].push_back(curNode->val);\n            q.push({curNode->left, column - 1});\n            q.push({curNode->right, column + 1});\n        }\n    }\n\n    std::vector<std::vector<int>> result;\n    for (auto& [_, values] : columnTable) {\n        result.push_back(std::move(values));\n    }\n\n    return result;\n}\n```\n    \n    The algorithm for vertical order traversal works as follows:\n1. Create a mapping of columns to their corresponding node values. Initialize a queue to store nodes and their columns, starting with the root at column 0.\n2. While the queue is not empty, dequeue the node and column. Add the node's value to the corresponding column in the mapping.\n3. Enqueue the node's left and right children with their respective column values (left child gets column -1, right child gets column +1).\n4. After the queue is empty, collect the node values for each column in order and put them into the result array.\n\nThe algorithm works for each language implementation.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left, right) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\nvar verticalOrder = function(root) {\n    if (!root) return [];\n    \n    const columnTable = new Map();\n    const q = [[root, 0]];\n\n    while (q.length) {\n        const [curNode, column] = q.shift();\n\n        if (curNode) {\n            if (!columnTable.has(column)) columnTable.set(column, []);\n            columnTable.get(column).push(curNode.val);\n            q.push([curNode.left, column - 1]);\n            q.push([curNode.right, column + 1]);\n        }\n    }\n\n    return Array.from(columnTable.entries()).sort((a, b) => a[0] - b[0]).map(entry => entry[1]);\n};\n```\n    \n    The algorithm for vertical order traversal works as follows:\n1. Create a mapping of columns to their corresponding node values. Initialize a queue to store nodes and their columns, starting with the root at column 0.\n2. While the queue is not empty, dequeue the node and column. Add the node's value to the corresponding column in the mapping.\n3. Enqueue the node's left and right children with their respective column values (left child gets column -1, right child gets column +1).\n4. After the queue is empty, collect the node values for each column in order and put them into the result array.\n\nThe algorithm works for each language implementation.\n    "
    },
    {
        "id": 58,
        "title": "Shortest Distance from All Buildings",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` grid `grid` of values `0`, `1`, or `2`, where:\n\n*   each `0` marks **an empty land** that you can pass by freely,\n*   each `1` marks **a building** that you cannot pass through, and\n*   each `2` marks **an obstacle** that you cannot pass through.\n\nYou want to build a house on an empty land that reaches all buildings in the **shortest total travel** distance. You can only move up, down, left, and right.\n\nReturn _the **shortest travel distance** for such a house_. If it is not possible to build such a house according to the above rules, return `-1`.\n\nThe **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.\n\nThe distance is calculated using [Manhattan Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,2,0,1\\],\\[0,0,0,0,0\\],\\[0,0,1,0,0\\]\\]\n**Output:** 7\n**Explanation:** Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.\nSo return 7.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   There will be **at least one** building in the `grid`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
                "output": "7"
            },
            {
                "input": "[[1,0]]",
                "output": "1"
            },
            {
                "input": "[[1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int shortestDistance(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    \n    int[][] total_count = new int[m][n];\n    int[][] dist_sum = new int[m][n];\n    int house_count = 0;\n    \n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                house_count++;\n                Queue<int[]> q = new LinkedList<>();\n                q.offer(new int[]{i, j});\n                boolean[][] visited = new boolean[m][n];\n                int level = 1;\n                while (!q.isEmpty()) {\n                    int sz = q.size();\n                    for (int q_i = 0; q_i < sz; q_i++) {\n                        int[] cur = q.poll();\n                        int x = cur[0];\n                        int y = cur[1];\n                        for (int[] dir : dirs) {\n                            int x_new = x + dir[0];\n                            int y_new = y + dir[1];\n                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] == 0) {\n                                visited[x_new][y_new] = true;\n                                q.offer(new int[]{x_new, y_new});\n                                dist_sum[x_new][y_new] += level;\n                                total_count[x_new][y_new]++;\n                            }\n                        }\n                    }\n                    level++;\n                }\n            }\n        }\n    }\n                                         \n    int min_dist = Integer.MAX_VALUE;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (total_count[i][j] == house_count) {\n                min_dist = Math.min(min_dist, dist_sum[i][j]);\n            }\n        }\n    }\n    \n    return min_dist == Integer.MAX_VALUE ? -1 : min_dist;\n}\n```\n\n    \n    The problem can be solved using repeated Breadth-First Search (BFS) algorithm.\n\n1. Initialize two `m x n` matrices `total_count` and `dist_sum` initialized to all 0s, where `total_count` stores the total number of houses reached from each cell and `dist_sum` stores the sum of the distances from each cell to every house reachable from that cell.\n\n2. Count the total number of houses in `grid`.\n\n3. Iterate through the matrix and for each house, perform a BFS to fill the `total_count` matrix with +1 for each empty cell reachable from the current house and add the corresponding level (distance) to the `dist_sum` matrix for reachable empty cells.\n\n4. To find the minimum distance, iterate through the `total_count` matrix and find the cell with the same count as the total number of houses (i.e., cell reachable from all houses) and has the minimum corresponding value in the `dist_sum` matrix.\n\n5. If such cell does not exist, return -1.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef shortestDistance(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n\n    total_count = [[0] * n for _ in range(m)]\n    dist_sum = [[0] * n for _ in range(m)]\n    house_count = 0\n\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                house_count += 1\n                q = deque([(i, j)])\n                visited = [[False] * n for _ in range(m)]\n                level = 1\n                while q:\n                    for _ in range(len(q)):\n                        x, y = q.popleft()\n                        for dx, dy in dirs:\n                            x_new, y_new = x + dx, y + dy\n                            if 0 <= x_new < m and 0 <= y_new < n and not visited[x_new][y_new] and grid[x_new][y_new] == 0:\n                                visited[x_new][y_new] = True\n                                q.append((x_new, y_new))\n                                dist_sum[x_new][y_new] += level\n                                total_count[x_new][y_new] += 1\n                    level += 1\n\n    min_dist = float(\"inf\")\n    for i in range(m):\n        for j in range(n):\n            if total_count[i][j] == house_count:\n                min_dist = min(min_dist, dist_sum[i][j])\n\n    return -1 if min_dist == float(\"inf\") else min_dist\n```\n\n    \n    The problem can be solved using repeated Breadth-First Search (BFS) algorithm.\n\n1. Initialize two `m x n` matrices `total_count` and `dist_sum` initialized to all 0s, where `total_count` stores the total number of houses reached from each cell and `dist_sum` stores the sum of the distances from each cell to every house reachable from that cell.\n\n2. Count the total number of houses in `grid`.\n\n3. Iterate through the matrix and for each house, perform a BFS to fill the `total_count` matrix with +1 for each empty cell reachable from the current house and add the corresponding level (distance) to the `dist_sum` matrix for reachable empty cells.\n\n4. To find the minimum distance, iterate through the `total_count` matrix and find the cell with the same count as the total number of houses (i.e., cell reachable from all houses) and has the minimum corresponding value in the `dist_sum` matrix.\n\n5. If such cell does not exist, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint shortestDistance(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    \n    vector<vector<int>> total_count(m, vector<int>(n, 0));\n    vector<vector<int>> dist_sum(m, vector<int>(n, 0));\n    int house_count = 0;\n    \n    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                house_count++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                vector<vector<bool>> visited(m, vector<bool>(n, false));\n                int level = 1;\n                while (!q.empty()) {\n                    int sz = q.size();\n                    for (int q_i = 0; q_i < sz; q_i++) {\n                        int x = q.front().first;\n                        int y = q.front().second;\n                        q.pop();\n                        for (auto &dir : dirs) {\n                            int x_new = x + dir[0];\n                            int y_new = y + dir[1];\n                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] == 0) {\n                                visited[x_new][y_new] = true;\n                                q.push({x_new, y_new});\n                                dist_sum[x_new][y_new] += level;\n                                total_count[x_new][y_new]++;\n                            }\n                        }\n                    }\n                    level++;\n                }\n            }\n        }\n    }\n                                         \n    int min_dist = INT_MAX;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (total_count[i][j] == house_count) {\n                min_dist = min(min_dist, dist_sum[i][j]);\n            }\n        }\n    }\n    \n    return min_dist == INT_MAX ? -1 : min_dist;\n}\n```\n\n    \n    The problem can be solved using repeated Breadth-First Search (BFS) algorithm.\n\n1. Initialize two `m x n` matrices `total_count` and `dist_sum` initialized to all 0s, where `total_count` stores the total number of houses reached from each cell and `dist_sum` stores the sum of the distances from each cell to every house reachable from that cell.\n\n2. Count the total number of houses in `grid`.\n\n3. Iterate through the matrix and for each house, perform a BFS to fill the `total_count` matrix with +1 for each empty cell reachable from the current house and add the corresponding level (distance) to the `dist_sum` matrix for reachable empty cells.\n\n4. To find the minimum distance, iterate through the `total_count` matrix and find the cell with the same count as the total number of houses (i.e., cell reachable from all houses) and has the minimum corresponding value in the `dist_sum` matrix.\n\n5. If such cell does not exist, return -1.\n    ",
        "js": "\n    ```javascript\nfunction shortestDistance(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    \n    let total_count = Array.from({length: m}, () => Array(n).fill(0));\n    let dist_sum = Array.from({length: m}, () => Array(n).fill(0));\n    let house_count = 0;\n    \n    let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                house_count++;\n                let q = [{x: i, y: j}];\n                let visited = Array.from({length: m}, () => Array(n).fill(false));\n                let level = 1;\n                while (q.length) {\n                    let sz = q.length;\n                    for (let q_i = 0; q_i < sz; q_i++) {\n                        let { x, y } = q.shift();\n                        dirs.forEach(([dx, dy]) => {\n                            let x_new = x + dx;\n                            let y_new = y + dy;\n                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] === 0) {\n                                visited[x_new][y_new] = true;\n                                q.push({ x: x_new, y: y_new });\n                                dist_sum[x_new][y_new] += level;\n                                total_count[x_new][y_new]++;\n                            }\n                        });\n                    }\n                    level++;\n                }\n            }\n        }\n    }\n                                         \n    let min_dist = Infinity;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (total_count[i][j] === house_count) {\n                min_dist = Math.min(min_dist, dist_sum[i][j]);\n            }\n        }\n    }\n    \n    return min_dist === Infinity ? -1 : min_dist;\n}\n```\n\n    \n    The problem can be solved using repeated Breadth-First Search (BFS) algorithm.\n\n1. Initialize two `m x n` matrices `total_count` and `dist_sum` initialized to all 0s, where `total_count` stores the total number of houses reached from each cell and `dist_sum` stores the sum of the distances from each cell to every house reachable from that cell.\n\n2. Count the total number of houses in `grid`.\n\n3. Iterate through the matrix and for each house, perform a BFS to fill the `total_count` matrix with +1 for each empty cell reachable from the current house and add the corresponding level (distance) to the `dist_sum` matrix for reachable empty cells.\n\n4. To find the minimum distance, iterate through the `total_count` matrix and find the cell with the same count as the total number of houses (i.e., cell reachable from all houses) and has the minimum corresponding value in the `dist_sum` matrix.\n\n5. If such cell does not exist, return -1.\n    "
    },
    {
        "id": 59,
        "title": "Generalized Abbreviation",
        "difficulty": "Medium",
        "content": {
            "problem": "A word's **generalized abbreviation** can be constructed by taking any number of **non-overlapping** and **non-adjacent** substrings and replacing them with their respective lengths.\n\n*   For example, `\"abcde \"` can be abbreviated into:\n    *   `\"a3e \"` ( `\"bcd \"` turned into `\"3 \"`)\n    *   `\"1bcd1 \"` ( `\"a \"` and `\"e \"` both turned into `\"1 \"`)\n    *   `\"5 \"` ( `\"abcde \"` turned into `\"5 \"`)\n    *   `\"abcde \"` (no substrings replaced)\n*   However, these abbreviations are **invalid**:\n    *   `\"23 \"` ( `\"ab \"` turned into `\"2 \"` and `\"cde \"` turned into `\"3 \"`) is invalid as the substrings chosen are adjacent.\n    *   `\"22de \"` ( `\"ab \"` turned into `\"2 \"` and `\"bc \"` turned into `\"2 \"`) is invalid as the substring chosen overlap.\n\nGiven a string `word`, return _a list of all the possible **generalized abbreviations** of_ `word`. Return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** word = \"word\"\n**Output:** \\[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"\\]\n\n",
                "**Example 2:**\n\n**Input:** word = \"a\"\n**Output:** \\[\"1\",\"a\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 15`\n*   `word` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"word\"",
                "output": "[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"]"
            },
            {
                "input": "\"a\"",
                "output": "[\"1\",\"a\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateAbbreviations(String word) {\n    List<String> res = new ArrayList<>();\n    res.add(word.isEmpty() ? \"\" : Integer.toString(word.length()));\n    for (int i = 0; i < word.length(); ++i) {\n        String pre = word.substring(0, i);\n        for (String abbr : generateAbbreviations(word.substring(i + 1))) {\n            int num = abbr.chars().findFirst_NEG_INT().getAsInt();\n            if (abbr.isEmpty() || num > 0) {\n                res.add(pre + '1' + abbr);\n            }\n            if (i == 0 || abbr.isEmpty() || abbr.charAt(0) > '9') {\n                res.add(word.substring(0, i + 1) + abbr);\n            }\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "python": "\n    ```python\ndef generateAbbreviations(word):\n    if not word:\n        return [\"\"]\n    res = []\n    for i in range(len(word) + 1):\n        for item in generateAbbreviations(word[i+1:]):\n            if i == 0 or not item or not item[0].isdigit():\n                res.append(word[:i+1] + item)\n            if item and item[0].isdigit():\n                res.append(word[:i] + '1' + item)\n    return res\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> generateAbbreviations(std::string word) {\n    std::vector<std::string> res;\n    res.push_back(word.empty() ? \"\" : std::to_string(word.size()));\n    for (size_t i = 0; i < word.size(); ++i)\n        for (const std::string &abbr : generateAbbreviations(word.substr(i + 1))) {\n            size_t num;\n            if (abbr.empty() || (num = abbr.find_first_not_of('123456789')) > 0)\n                res.push_back(word.substr(0, i) + '1' + abbr);\n            if (i == 0 || abbr.empty() || abbr[0] > '9')\n                res.push_back(word.substr(0, i + 1) + abbr);\n        }\n    return res;\n}\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "js": "\n    ```javascript\nfunction generateAbbreviations(word) {\n    if (word === '') {\n        return ['']\n    }\n    const res = []\n    for (let i = 0; i < word.length + 1; i++) {\n        for (const item of generateAbbreviations(word.slice(i + 1))) {\n            if (i === 0 || !item || isNaN(item[0])) {\n                res.push(word.slice(0, i + 1) + item)\n            }\n            if (item && !isNaN(item[0])) {\n                res.push(word.slice(0, i) + '1' + item)\n            }\n        }\n    }\n    return res\n}\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    "
    },
    {
        "id": 60,
        "title": "Number of Connected Components in an Undirected Graph",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,1],[1,2],[3,4]]",
                "output": "2"
            },
            {
                "input": "5,[[0,1],[1,2],[2,3],[3,4]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int countComponents(int n, int[][] edges) {\n    List<List<Integer>> adjList = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, visited, adjList);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\n    visited[node] = true;\n    for (int neighbor : adjList.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adjList);\n        }\n    }\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "python": "\n    ```python\ndef countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint countComponents(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> adjList(n);\n    for (const auto& edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n    }\n    \n    std::vector<bool> visited(n, false);\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            std::function<void(int)> dfs = [&](int node) {\n                visited[node] = true;\n                for (int neighbor : adjList[node]) {\n                    if (!visited[neighbor]) {\n                        dfs(neighbor);\n                    }\n                }\n            };\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "js": "\n    ```javascript\nfunction countComponents(n, edges) {\n    const adjList = new Array(n).fill(0).map(() => []);\n    for (const edge of edges) {\n        adjList[edge[0]].push(edge[1]);\n        adjList[edge[1]].push(edge[0]);\n    }\n\n    const visited = new Array(n).fill(false);\n    let connectedComponents = 0;\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of adjList[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    "
    },
    {
        "id": 61,
        "title": "Maximum Size Subarray Sum Equals k",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the maximum length of a_ _subarray_ _that sums to_ `k`. If there is not one, return `0` instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,-1,5,-2,3\\], k = 3\n**Output:** 4\n**Explanation:** The subarray \\[1, -1, 5, -2\\] sums to 3 and is the longest.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-2,-1,2,1\\], k = 1\n**Output:** 2\n**Explanation:** The subarray \\[-1, 2\\] sums to 1 and is the longest."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 105`\n*   `-104 <= nums[i] <= 104`\n*   `-109 <= k <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,-1,5,-2,3],3",
                "output": "4"
            },
            {
                "input": "[-2,-1,2,1],1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int maxSubArrayLen(int[] nums, int k) {\n    Map<Integer, Integer> sumIndex = new HashMap<>();\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum == k) maxLength = i + 1;\n        if (sumIndex.containsKey(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.containsKey(sum)) sumIndex.put(sum, i);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "python": "\n    ```python\ndef maxSubArrayLen(nums: List[int], k: int) -> int:\n    sum_index = {}\n    maxLength = sum = 0\n    for i, num in enumerate(nums):\n        sum += num\n        if sum == k:\n            maxLength = i + 1\n        if sum - k in sum_index:\n            maxLength = max(maxLength, i - sum_index[sum - k])\n        if sum not in sum_index:\n            sum_index[sum] = i\n    return maxLength\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "c++": "\n    ```cpp\nint maxSubArrayLen(vector<int>& nums, int k) {\n    unordered_map<int, int> sumIndex;\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.size(); i++) {\n        sum += nums[i];\n        if(sum == k) maxLength = i + 1;\n        if(sumIndex.count(sum - k)) maxLength = max(maxLength, i - sumIndex[sum - k]);\n        if(!sumIndex.count(sum)) sumIndex[sum] = i;\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "js": "\n    ```javascript\nfunction maxSubArrayLen(nums, k) {\n    let sumIndex = new Map();\n    let maxLength = 0, sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum === k) maxLength = i + 1;\n        if (sumIndex.has(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.has(sum)) sumIndex.set(sum, i);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    "
    },
    {
        "id": 62,
        "title": "Largest BST Subtree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.\n\nA **Binary Search Tree (BST)** is a tree in which all the nodes follow the below-mentioned properties:\n\n*   The left subtree values are less than the value of their parent (root) node's value.\n*   The right subtree values are greater than the value of their parent (root) node's value.\n\n**Note:** A subtree must include all of its descendants.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[10,5,15,1,8,null,7\\]\n**Output:** 3\n**Explanation:** The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[4,2,7,2,3,5,null,2,null,null,null,null,null,1\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n\n**",
            "follow_up": "Follow up:** Can you figure out ways to solve it with `O(n)` time complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "[10,5,15,1,8,null,7]",
                "output": "3"
            },
            {
                "input": "[4,2,7,2,3,5,null,2,null,null,null,null,null,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\nclass TreeInfo {\n    boolean isBST;\n    int size;\n    int minValue;\n    int maxValue;\n\n    TreeInfo(boolean isBST, int size, int minValue, int maxValue) {\n        this.isBST = isBST;\n        this.size = size;\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n    }\n}\n\npublic int largestBSTSubtree(TreeNode root) {\n    return largestBSTUtil(root, new int[1]).size;\n}\n\nprivate TreeInfo largestBSTUtil(TreeNode root, int[] largestBST) {\n    if (root == null) return new TreeInfo(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);\n\n    TreeInfo left = largestBSTUtil(root.left, largestBST);\n    TreeInfo right = largestBSTUtil(root.right, largestBST);\n\n    if (left.isBST && root.val > left.maxValue && right.isBST && root.val <right.minValue) {\n        largestBST[0] = Math.max(largestBST[0], left.size + 1 + right.size);\n        return new TreeInfo(true, left.size + 1 + right.size, Math.min(root.val, left.minValue), Math.max(root.val, right.maxValue));\n    }\n\n    return new TreeInfo(false, -1, Integer.MAX_VALUE, Integer.MIN_VALUE);\n}\n```\n    \n    The algorithm leverages the postorder traversal of the binary tree. We create a `TreeInfo` structure to store the information related to BST. It has `isBST` as a boolean to check if the tree is BST or not, `size` to store the size of the largest BST subtree, `minValue`, and `maxValue` to represent the minimum and maximum values in the subtree.\n\nThe utility function `largestBSTUtil` recursively traverses the binary tree in post order. When there is no root node, it returns a `TreeInfo` structure with default values. The function then checks the left and right subtrees.\n\nThe function checks if both the left and right subtrees are BST, and if the current root node's value is greater than the maximum value of its left subtree and less than the minimum value of its right subtree. If this condition is true, it sets `largestBST` as the maximum of its previous value and the sum of the current node's left and right subtree sizes plus one (the current node).\n\nThe function then returns a new `TreeInfo` structure with an updated `size`, `minValue`, and `maxValue` that combines information from both subtrees.\n\nThe base function `largestBSTSubtree` initializes an array `largestBST` at zero and calls the `largestBSTUtil` function. After the traversal, the `largestBST` will contain the size of the largest BST subtree found in the input binary tree. We return this value.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largestBSTSubtree(root: TreeNode) -> int:\n    def largestBSTUtil(root):\n        if not root:\n            return True, 0, float('inf'), float('-inf')\n        \n        left = largestBSTUtil(root.left)\n        right = largestBSTUtil(root.right)\n        \n        if left[0] and root.val > left[3] and right[0] and root.val < right[2]:\n            largestBST[0] = max(largestBST[0], left[1] + 1 + right[1])\n            return True, left[1] + 1 + right[1], min(root.val, left[2]), max(root.val, right[3])\n        \n        return False, -1, float('inf'), float('-inf')\n    \n    largestBST = [0]\n    largestBSTUtil(root)\n    \n    return largestBST[0]\n```\n    \n    The algorithm leverages the postorder traversal of the binary tree. We create a `TreeInfo` structure to store the information related to BST. It has `isBST` as a boolean to check if the tree is BST or not, `size` to store the size of the largest BST subtree, `minValue`, and `maxValue` to represent the minimum and maximum values in the subtree.\n\nThe utility function `largestBSTUtil` recursively traverses the binary tree in post order. When there is no root node, it returns a `TreeInfo` structure with default values. The function then checks the left and right subtrees.\n\nThe function checks if both the left and right subtrees are BST, and if the current root node's value is greater than the maximum value of its left subtree and less than the minimum value of its right subtree. If this condition is true, it sets `largestBST` as the maximum of its previous value and the sum of the current node's left and right subtree sizes plus one (the current node).\n\nThe function then returns a new `TreeInfo` structure with an updated `size`, `minValue`, and `maxValue` that combines information from both subtrees.\n\nThe base function `largestBSTSubtree` initializes an array `largestBST` at zero and calls the `largestBSTUtil` function. After the traversal, the `largestBST` will contain the size of the largest BST subtree found in the input binary tree. We return this value.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nstruct TreeInfo {\n    bool isBST;\n    int size;\n    int minValue;\n    int maxValue;\n};\n\nTreeInfo largestBSTUtil(TreeNode* root, int &largestBST) {\n    if (!root) return {true, 0, INT_MAX, INT_MIN};\n\n    TreeInfo left = largestBSTUtil(root->left, largestBST);\n    TreeInfo right = largestBSTUtil(root->right, largestBST);\n\n    if (left.isBST && root->val > left.maxValue && right.isBST && root->val < right.minValue) {\n        largestBST = max(largestBST, left.size + 1 + right.size);\n        return {true, left.size + 1 + right.size, min(root->val, left.minValue), max(root->val, right.maxValue)};\n    }\n\n    return {false, -1, INT_MAX, INT_MIN};\n}\n\nint largestBSTSubtree(TreeNode* root) {\n    int largestBST = 0;\n    largestBSTUtil(root, largestBST);\n    return largestBST;\n}\n```\n    \n    The algorithm leverages the postorder traversal of the binary tree. We create a `TreeInfo` structure to store the information related to BST. It has `isBST` as a boolean to check if the tree is BST or not, `size` to store the size of the largest BST subtree, `minValue`, and `maxValue` to represent the minimum and maximum values in the subtree.\n\nThe utility function `largestBSTUtil` recursively traverses the binary tree in post order. When there is no root node, it returns a `TreeInfo` structure with default values. The function then checks the left and right subtrees.\n\nThe function checks if both the left and right subtrees are BST, and if the current root node's value is greater than the maximum value of its left subtree and less than the minimum value of its right subtree. If this condition is true, it sets `largestBST` as the maximum of its previous value and the sum of the current node's left and right subtree sizes plus one (the current node).\n\nThe function then returns a new `TreeInfo` structure with an updated `size`, `minValue`, and `maxValue` that combines information from both subtrees.\n\nThe base function `largestBSTSubtree` initializes an array `largestBST` at zero and calls the `largestBSTUtil` function. After the traversal, the `largestBST` will contain the size of the largest BST subtree found in the input binary tree. We return this value.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left, right) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nfunction largestBSTSubtree(root) {\n    function largestBSTUtil(root, largestBST) {\n        if (!root) return [true, 0, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];\n\n        let left = largestBSTUtil(root.left, largestBST);\n        let right = largestBSTUtil(root.right, largestBST);\n\n        if (left[0] && root.val > left[3] && right[0] && root.val < right[2]) {\n            largestBST[0] = Math.max(largestBST[0], left[1] + 1 + right[1]);\n            return [true, left[1] + 1 + right[1], Math.min(root.val, left[2]), Math.max(root.val, right[3])];\n        }\n\n        return [false, -1, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];\n    }\n\n    let largestBST = [0];\n    largestBSTUtil(root, largestBST);\n\n    return largestBST[0];\n}\n```\n    \n    The algorithm leverages the postorder traversal of the binary tree. We create a `TreeInfo` structure to store the information related to BST. It has `isBST` as a boolean to check if the tree is BST or not, `size` to store the size of the largest BST subtree, `minValue`, and `maxValue` to represent the minimum and maximum values in the subtree.\n\nThe utility function `largestBSTUtil` recursively traverses the binary tree in post order. When there is no root node, it returns a `TreeInfo` structure with default values. The function then checks the left and right subtrees.\n\nThe function checks if both the left and right subtrees are BST, and if the current root node's value is greater than the maximum value of its left subtree and less than the minimum value of its right subtree. If this condition is true, it sets `largestBST` as the maximum of its previous value and the sum of the current node's left and right subtree sizes plus one (the current node).\n\nThe function then returns a new `TreeInfo` structure with an updated `size`, `minValue`, and `maxValue` that combines information from both subtrees.\n\nThe base function `largestBSTSubtree` initializes an array `largestBST` at zero and calls the `largestBSTUtil` function. After the traversal, the `largestBST` will contain the size of the largest BST subtree found in the input binary tree. We return this value.\n    "
    },
    {
        "id": 63,
        "title": "Nested List Weight Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists.\n\nThe **depth** of an integer is the number of lists that it is inside of. For example, the nested list `[1,[2,2],[[3],2],1]` has each integer's value set to its **depth**.\n\nReturn _the sum of each integer in_ `nestedList` _multiplied by its **depth**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nestedList = \\[\\[1,1\\],2,\\[1,1\\]\\]\n**Output:** 10\n**Explanation:** Four 1's at depth 2, one 2 at depth 1. 1\\*2 + 1\\*2 + 2\\*1 + 1\\*2 + 1\\*2 = 10.\n\n",
                "**Example 2:**\n\n**Input:** nestedList = \\[1,\\[4,\\[6\\]\\]\\]\n**Output:** 27\n**Explanation:** One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1\\*1 + 4\\*2 + 6\\*3 = 27.\n\n",
                "**Example 3:**\n\n**Input:** nestedList = \\[0\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nestedList.length <= 50`\n*   The values of the integers in the nested list is in the range `[-100, 100]`.\n*   The maximum **depth** of any integer is less than or equal to `50`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1],2,[1,1]]",
                "output": "10"
            },
            {
                "input": "[1,[4,[6]]]",
                "output": "27"
            },
            {
                "input": "[0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int depthSum(List<?> nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nprivate int depthSumHelper(List<?> nestedList, int depth) {\n    int sum = 0;\n    for (Object element : nestedList) {\n        if (element instanceof Integer) {\n            sum += (int) element * depth;\n        } else {\n            sum += depthSumHelper((List<?>) element, depth + 1);\n        }\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm utilizes a helper function that takes the nested list and the current depth. It loops through each element in the nested list. If the element is an integer, it adds the product of the integer and the depth to the sum. If the element is a list, it recursively calls the helper function with the element and a higher depth. This continues until all elements are processed, and the sum is returned.\n    ",
        "python": "\n    ```python\nfrom typing import List, Union\n\ndef depth_sum(nested_list: List[Union[int, List]]) -> int:\n    def depth_sum_helper(nested_list: List[Union[int, List]], depth: int) -> int:\n        return sum(element * depth if isinstance(element, int) else depth_sum_helper(element, depth + 1) for element in nested_list)\n\n    return depth_sum_helper(nested_list, 1)\n```\n\n    \n    The algorithm utilizes a helper function that takes the nested list and the current depth. It loops through each element in the nested list. If the element is an integer, it adds the product of the integer and the depth to the sum. If the element is a list, it recursively calls the helper function with the element and a higher depth. This continues until all elements are processed, and the sum is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <variant>\n\nusing NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;\n\nint depthSumHelper(NestedList nestedList, int depth) {\n    int sum = 0;\n    for (auto& element : nestedList) {\n        if (std::holds_alternative<int>(element)) {\n            sum += std::get<int>(element) * depth;\n        } else {\n            sum += depthSumHelper(std::get<std::vector<std::variant<int, std::vector<int>>>>(element), depth + 1);\n        }\n    }\n    return sum;\n}\n\nint depthSum(NestedList nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n```\n\n    \n    The algorithm utilizes a helper function that takes the nested list and the current depth. It loops through each element in the nested list. If the element is an integer, it adds the product of the integer and the depth to the sum. If the element is a list, it recursively calls the helper function with the element and a higher depth. This continues until all elements are processed, and the sum is returned.\n    ",
        "js": "\n    ```javascript\nfunction depthSum(nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nfunction depthSumHelper(nestedList, depth) {\n    let sum = 0;\n    for (let element of nestedList) {\n        if (typeof element === \"number\") {\n            sum += element * depth;\n        } else {\n            sum += depthSumHelper(element, depth + 1);\n        }\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm utilizes a helper function that takes the nested list and the current depth. It loops through each element in the nested list. If the element is an integer, it adds the product of the integer and the depth to the sum. If the element is a list, it recursively calls the helper function with the element and a higher depth. This continues until all elements are processed, and the sum is returned.\n    "
    },
    {
        "id": 64,
        "title": "Longest Substring with At Most K Distinct Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"eceba \", k = 2\n**Output:** 3\n**Explanation:** The substring is  \"ece \" with length 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", k = 1\n**Output:** 2\n**Explanation:** The substring is  \"aa \" with length 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `0 <= k <= 50`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"eceba\",2",
                "output": "3"
            },
            {
                "input": "\"aa\",1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); ++right) {\n        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n\n        while (charCount.size() > k) {\n            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n            if (charCount.get(s.charAt(left)) == 0) {\n                charCount.remove(s.charAt(left));\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "python": "\n    ```python\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <algorithm>\n\nint lengthOfLongestSubstringKDistinct(std::string s, int k) {\n    std::unordered_map<char, int> charCount;\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.size(); ++right) {\n        charCount[s[right]]++;\n\n        while (charCount.size() > k) {\n            charCount[s[left]]--;\n            if (charCount[s[left]] == 0) {\n                charCount.erase(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = std::max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "js": "\n    ```javascript\nfunction lengthOfLongestSubstringKDistinct(s, k) {\n    const charCount = new Map();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; ++right) {\n        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n        while (charCount.size > k) {\n            charCount.set(s[left], charCount.get(s[left]) - 1);\n            if (charCount.get(s[left]) === 0) {\n                charCount.delete(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    "
    },
    {
        "id": 65,
        "title": "Moving Average from Data Stream",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\n\nImplement the `MovingAverage` class:\n\n*   `MovingAverage(int size)` Initializes the object with the size of the window `size`.\n*   `double next(int val)` Returns the moving average of the last `size` values of the stream.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MovingAverage \",  \"next \",  \"next \",  \"next \",  \"next \"\\]\n\\[\\[3\\], \\[1\\], \\[10\\], \\[3\\], \\[5\\]\\]\n**Output**\n\\[null, 1.0, 5.5, 4.66667, 6.0\\]\n\n**Explanation**\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // return 1.0 = 1 / 1\nmovingAverage.next(10); // return 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= size <= 1000`\n*   `-105 <= val <= 105`\n*   At most `104` calls will be made to `next`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],]]",
                "output": "**Output**\n[null,1.0,5.5,4.66667,6.0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass MovingAverage {\n    private Queue<Integer> queue;\n    private int maxSize;\n    private double sum;\n\n    public MovingAverage(int size) {\n        queue = new LinkedList<>();\n        maxSize = size;\n        sum = 0.0;\n    }\n\n    public double next(int val) {\n        if (queue.size() == maxSize) {\n            sum -= queue.remove();\n        }\n        queue.add(val);\n        sum += val;\n        return sum / queue.size();\n    }\n}\n```\n    \n    The algorithm uses a queue to maintain a sliding window of the last `size` values of the stream. When a new value is added, the algorithm checks the size of the queue. If it equals `size`, the oldest value is removed from the front of the queue by updating the sum and popping it. Then, the new value is added to the back of the queue, and the sum is updated. The average is returned by dividing the sum by the number of values currently in the queue. The time complexity of the `next` function is O(1).\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.queue = deque()\n        self.maxSize = size\n        self.sum = 0.0\n\n    def next(self, val: int) -> float:\n        if len(self.queue) == self.maxSize:\n            self.sum -= self.queue.popleft()\n        self.queue.append(val)\n        self.sum += val\n        return self.sum / len(self.queue)\n```\n    \n    The algorithm uses a queue to maintain a sliding window of the last `size` values of the stream. When a new value is added, the algorithm checks the size of the queue. If it equals `size`, the oldest value is removed from the front of the queue by updating the sum and popping it. Then, the new value is added to the back of the queue, and the sum is updated. The average is returned by dividing the sum by the number of values currently in the queue. The time complexity of the `next` function is O(1).\n    ",
        "c++": "\n    ```cpp\n#include <queue>\nusing namespace std;\n\nclass MovingAverage {\npublic:\n    queue<int> q;\n    int maxSize;\n    double sum;\n\n    MovingAverage(int size) {\n        maxSize = size;\n        sum = 0;\n    }\n\n    double next(int val) {\n        if (q.size() == maxSize) {\n            sum -= q.front();\n            q.pop();\n        }\n        q.push(val);\n        sum += val;\n        return sum / q.size();\n    }\n};\n```\n    \n    The algorithm uses a queue to maintain a sliding window of the last `size` values of the stream. When a new value is added, the algorithm checks the size of the queue. If it equals `size`, the oldest value is removed from the front of the queue by updating the sum and popping it. Then, the new value is added to the back of the queue, and the sum is updated. The average is returned by dividing the sum by the number of values currently in the queue. The time complexity of the `next` function is O(1).\n    ",
        "js": "\n    ```javascript\nclass MovingAverage {\n    constructor(size) {\n        this.queue = [];\n        this.maxSize = size;\n        this.sum = 0;\n    }\n\n    next(val) {\n        if (this.queue.length === this.maxSize) {\n            this.sum -= this.queue.shift();\n        }\n        this.queue.push(val);\n        this.sum += val;\n        return this.sum / this.queue.length;\n    }\n}\n```\n    \n    The algorithm uses a queue to maintain a sliding window of the last `size` values of the stream. When a new value is added, the algorithm checks the size of the queue. If it equals `size`, the oldest value is removed from the front of the queue by updating the sum and popping it. Then, the new value is added to the back of the queue, and the sum is updated. The average is returned by dividing the sum by the number of values currently in the queue. The time complexity of the `next` function is O(1).\n    "
    },
    {
        "id": 66,
        "title": "Design Tic-Tac-Toe",
        "difficulty": "Medium",
        "content": {
            "problem": "Assume the following rules are for the tic-tac-toe game on an `n x n` board between two players:\n\n1.  A move is guaranteed to be valid and is placed on an empty block.\n2.  Once a winning condition is reached, no more moves are allowed.\n3.  A player who succeeds in placing `n` of their marks in a horizontal, vertical, or diagonal row wins the game.\n\nImplement the `TicTacToe` class:\n\n*   `TicTacToe(int n)` Initializes the object the size of the board `n`.\n*   `int move(int row, int col, int player)` Indicates that the player with id `player` plays at the cell `(row, col)` of the board. The move is guaranteed to be a valid move, and the two players alternate in making moves. Return\n    *   `0` if there is **no winner** after the move,\n    *   `1` if **player 1** is the winner after the move, or\n    *   `2` if **player 2** is the winner after the move.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"TicTacToe \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \"\\]\n\\[\\[3\\], \\[0, 0, 1\\], \\[0, 2, 2\\], \\[2, 2, 1\\], \\[1, 1, 2\\], \\[2, 0, 1\\], \\[1, 0, 2\\], \\[2, 1, 1\\]\\]\n**Output**\n\\[null, 0, 0, 0, 0, 0, 0, 1\\]\n\n**Explanation**\nTicTacToe ticTacToe = new TicTacToe(3);\nAssume that player 1 is  \"X \" and player 2 is  \"O \" in the board.\nticTacToe.move(0, 0, 1); // return 0 (no one wins)\n|X| | |\n| | | |    // Player 1 makes a move at (0, 0).\n| | | |\n\nticTacToe.move(0, 2, 2); // return 0 (no one wins)\n|X| |O|\n| | | |    // Player 2 makes a move at (0, 2).\n| | | |\n\nticTacToe.move(2, 2, 1); // return 0 (no one wins)\n|X| |O|\n| | | |    // Player 1 makes a move at (2, 2).\n| | |X|\n\nticTacToe.move(1, 1, 2); // return 0 (no one wins)\n|X| |O|\n| |O| |    // Player 2 makes a move at (1, 1).\n| | |X|\n\nticTacToe.move(2, 0, 1); // return 0 (no one wins)\n|X| |O|\n| |O| |    // Player 1 makes a move at (2, 0).\n|X| |X|\n\nticTacToe.move(1, 0, 2); // return 0 (no one wins)\n|X| |O|\n|O|O| |    // Player 2 makes a move at (1, 0).\n|X| |X|\n\nticTacToe.move(2, 1, 1); // return 1 (player 1 wins)\n|X| |O|\n|O|O| |    // Player 1 makes a move at (2, 1).\n|X|X|X|"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 100`\n*   player is `1` or `2`.\n*   `0 <= row, col < n`\n*   `(row, col)` are **unique** for each different call to `move`.\n*   At most `n2` calls will be made to `move`.\n\n**",
            "follow_up": "Follow-up:** Could you do better than `O(n2)` per `move()` operation?"
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],]]",
                "output": "**Output**\n[null,0,0,0,0,0,0,1]"
            }
        ],
        "java": "\n    ```java\nclass TicTacToe {\n    int[] rows, cols;\n    int diagonal, anti_diagonal, n;\n\n    public TicTacToe(int n) {\n        this.n = n;\n        rows = new int[n];\n        cols = new int[n];\n        diagonal = 0;\n        anti_diagonal = 0;\n    }\n\n    public int move(int row, int col, int player) {\n        int toAdd = (player == 1) ? 1 : -1;\n\n        rows[row] += toAdd;\n        cols[col] += toAdd;\n\n        if (row == col) diagonal += toAdd;\n        if (row + col == n - 1) anti_diagonal += toAdd;\n\n        if (Math.abs(rows[row]) == n || \n            Math.abs(cols[col]) == n || \n            Math.abs(diagonal) == n || \n            Math.abs(anti_diagonal) == n)\n            return player;\n\n        return 0;\n    }\n}\n```\n\n    \n    We can use four extra arrays (rows, cols, diagonal, and anti_diagonal) to keep track of the sum of the marks for each player (1 for player 1 and -1 for player 2) in each row, column, diagonal, and anti-diagonal. When the absolute value of any entry in these arrays becomes equal to `n`, we know that a player has won.\n\nTo implement the `move` function, we first determine the value `toAdd` as 1 if the player is 1 or -1 if the player is 2. Then, we update the corresponding row, col, diagonal (if row == col), and anti_diagonal (if row + col == n - 1) by adding `toAdd` to their respective values. Finally, we check if the absolute values of the updated entries are equal to `n`, and return the player number if the winning condition is met; otherwise, return 0. This solution has a time complexity of O(1) per `move` operation.\n    ",
        "python": "\n    ```python\nclass TicTacToe:\n    def __init__(self, n: int):\n        self.rows, self.cols = [0] * n, [0] * n\n        self.diagonal = self.anti_diagonal = self.n = n\n\n    def move(self, row: int, col: int, player: int) -> int:\n        to_add = 1 if player == 1 else -1\n\n        self.rows[row] += to_add\n        self.cols[col] += to_add\n\n        if row == col:\n            self.diagonal += to_add\n        if row + col == self.n - 1:\n            self.anti_diagonal += to_add\n\n        if (abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n\n                or abs(self.diagonal) == self.n or abs(self.anti_diagonal) == self.n):\n            return player\n\n        return 0\n```\n\n    \n    We can use four extra arrays (rows, cols, diagonal, and anti_diagonal) to keep track of the sum of the marks for each player (1 for player 1 and -1 for player 2) in each row, column, diagonal, and anti-diagonal. When the absolute value of any entry in these arrays becomes equal to `n`, we know that a player has won.\n\nTo implement the `move` function, we first determine the value `toAdd` as 1 if the player is 1 or -1 if the player is 2. Then, we update the corresponding row, col, diagonal (if row == col), and anti_diagonal (if row + col == n - 1) by adding `toAdd` to their respective values. Finally, we check if the absolute values of the updated entries are equal to `n`, and return the player number if the winning condition is met; otherwise, return 0. This solution has a time complexity of O(1) per `move` operation.\n    ",
        "c++": "\n    ```cpp\nclass TicTacToe {\npublic:\n    vector<int> rows, cols;\n    int diagonal, anti_diagonal, n;\n    \n    TicTacToe(int n) {\n        this->n = n;\n        rows = vector<int>(n, 0);\n        cols = vector<int>(n, 0);\n        diagonal = 0;\n        anti_diagonal = 0;\n    }\n\n    int move(int row, int col, int player) {\n        int toAdd = (player == 1) ? 1 : -1;\n        \n        rows[row] += toAdd;\n        cols[col] += toAdd;\n        \n        if (row == col) diagonal += toAdd;\n        if (row + col == n - 1) anti_diagonal += toAdd;\n\n        if (abs(rows[row]) == n || \n            abs(cols[col]) == n || \n            abs(diagonal) == n || \n            abs(anti_diagonal) == n)\n            return player;\n\n        return 0;\n    }\n};\n```\n\n    \n    We can use four extra arrays (rows, cols, diagonal, and anti_diagonal) to keep track of the sum of the marks for each player (1 for player 1 and -1 for player 2) in each row, column, diagonal, and anti-diagonal. When the absolute value of any entry in these arrays becomes equal to `n`, we know that a player has won.\n\nTo implement the `move` function, we first determine the value `toAdd` as 1 if the player is 1 or -1 if the player is 2. Then, we update the corresponding row, col, diagonal (if row == col), and anti_diagonal (if row + col == n - 1) by adding `toAdd` to their respective values. Finally, we check if the absolute values of the updated entries are equal to `n`, and return the player number if the winning condition is met; otherwise, return 0. This solution has a time complexity of O(1) per `move` operation.\n    ",
        "js": "\n    ```javascript\nclass TicTacToe {\n    constructor(n) {\n        this.rows = new Array(n).fill(0);\n        this.cols = new Array(n).fill(0);\n        this.diagonal = 0;\n        this.anti_diagonal = 0;\n        this.n = n;\n    }\n\n    move(row, col, player) {\n        const toAdd = player === 1 ? 1 : -1;\n\n        this.rows[row] += toAdd;\n        this.cols[col] += toAdd;\n\n        if (row === col) this.diagonal += toAdd;\n        if (row + col === this.n - 1) this.anti_diagonal += toAdd;\n\n        if (Math.abs(this.rows[row]) === this.n || \n            Math.abs(this.cols[col]) === this.n || \n            Math.abs(this.diagonal) === this.n || \n            Math.abs(this.anti_diagonal) === this.n)\n            return player;\n\n        return 0;\n    }\n}\n```\n\n    \n    We can use four extra arrays (rows, cols, diagonal, and anti_diagonal) to keep track of the sum of the marks for each player (1 for player 1 and -1 for player 2) in each row, column, diagonal, and anti-diagonal. When the absolute value of any entry in these arrays becomes equal to `n`, we know that a player has won.\n\nTo implement the `move` function, we first determine the value `toAdd` as 1 if the player is 1 or -1 if the player is 2. Then, we update the corresponding row, col, diagonal (if row == col), and anti_diagonal (if row + col == n - 1) by adding `toAdd` to their respective values. Finally, we check if the absolute values of the updated entries are equal to `n`, and return the player number if the winning condition is met; otherwise, return 0. This solution has a time complexity of O(1) per `move` operation.\n    "
    },
    {
        "id": 67,
        "title": "Android Unlock Patterns",
        "difficulty": "Medium",
        "content": {
            "problem": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an \"unlock pattern \" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a **valid** unlock pattern if both of the following are true:\n\n*   All the dots in the sequence are **distinct**.\n*   If the line segment connecting two consecutive dots in the sequence passes through the **center** of any other dot, the other dot **must have previously appeared** in the sequence. No jumps through the center non-selected dots are allowed.\n    *   For example, connecting dots `2` and `9` without dots `5` or `6` appearing beforehand is valid because the line from dot `2` to dot `9` does not pass through the center of either dot `5` or `6`.\n    *   However, connecting dots `1` and `3` without dot `2` appearing beforehand is invalid because the line from dot `1` to dot `3` passes through the center of dot `2`.\n\nHere are some example valid and invalid unlock patterns:\n\n*   The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n*   The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n*   The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n*   The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return _the **number of unique and valid unlock patterns** of the Android grid lock screen that consist of **at least**_ `m` _keys and **at most**_ `n` _keys._\n\nTwo unlock patterns are considered **unique** if there is a dot in one sequence that is not in the other, or the order of the dots is different.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 9\n\n",
                "**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 65"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 9`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1,1",
                "output": "9"
            },
            {
                "input": "1,2",
                "output": "65"
            }
        ],
        "java": "\n    ```java\npublic int numberOfPatterns(int m, int n) {\n    int[][] jumps = new int[10][10];\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    boolean[] visited = new boolean[10];\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nprivate int dfs(int[][] jumps, boolean[] visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "python": "\n    ```python\ndef numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "c++": "\n    ```cpp\nint numberOfPatterns(int m, int n) {\n    const vector<vector<int>> jumps(10, vector<int>(10, 0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    vector<bool> visited(10, false);\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nint dfs(const vector<vector<int>>& jumps, vector<bool>& visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "js": "\n    ```javascript\nvar numberOfPatterns = function(m, n) {\n    const jumps = Array.from({length: 10}, () => Array(10).fill(0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    const visited = Array(10).fill(false);\n\n    let cnt = 0;\n    for (let i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n};\n\nfunction dfs(jumps, visited, curr, remaining) {\n    if (remaining < 0) return 0;\n    if (remaining === 0) return 1;\n\n    visited[curr] = true;\n    let cnt = 0;\n    for (let next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] === 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    "
    },
    {
        "id": 68,
        "title": "Design Snake Game",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a [Snake game](https://en.wikipedia.org/wiki/Snake_(video_game)) that is played on a device with screen size `height x width`. [Play the game online](http://patorjk.com/games/snake/) if you are not familiar with the game.\n\nThe snake is initially positioned at the top left corner `(0, 0)` with a length of `1` unit.\n\nYou are given an array `food` where `food[i] = (ri, ci)` is the row and column position of a piece of food that the snake can eat. When a snake eats a piece of food, its length and the game's score both increase by `1`.\n\nEach piece of food appears one by one on the screen, meaning the second piece of food will not appear until the snake eats the first piece of food.\n\nWhen a piece of food appears on the screen, it is **guaranteed** that it will not appear on a block occupied by the snake.\n\nThe game is over if the snake goes out of bounds (hits a wall) or if its head occupies a space that its body occupies **after** moving (i.e. a snake of length 4 cannot run into itself).\n\nImplement the `SnakeGame` class:\n\n*   `SnakeGame(int width, int height, int[][] food)` Initializes the object with a screen of size `height x width` and the positions of the `food`.\n*   `int move(String direction)` Returns the score of the game after applying one `direction` move by the snake. If the game is over, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"SnakeGame \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \"\\]\n\\[\\[3, 2, \\[\\[1, 2\\], \\[0, 1\\]\\]\\], \\[ \"R \"\\], \\[ \"D \"\\], \\[ \"R \"\\], \\[ \"U \"\\], \\[ \"L \"\\], \\[ \"U \"\\]\\]\n**Output**\n\\[null, 0, 0, 1, 1, 2, -1\\]\n\n**Explanation**\nSnakeGame snakeGame = new SnakeGame(3, 2, \\[\\[1, 2\\], \\[0, 1\\]\\]);\nsnakeGame.move( \"R \"); // return 0\nsnakeGame.move( \"D \"); // return 0\nsnakeGame.move( \"R \"); // return 1, snake eats the first piece of food. The second piece of food appears at (0, 1).\nsnakeGame.move( \"U \"); // return 1\nsnakeGame.move( \"L \"); // return 2, snake eats the second food. No more food appears.\nsnakeGame.move( \"U \"); // return -1, game over because snake collides with border"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= width, height <= 104`\n*   `1 <= food.length <= 50`\n*   `food[i].length == 2`\n*   `0 <= ri < height`\n*   `0 <= ci < width`\n*   `direction.length == 1`\n*   `direction` is `'U'`, `'D'`, `'L'`, or `'R'`.\n*   At most `104` calls will be made to `move`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],]]],[\"R\"],[\"D\"],[\"R\"],[\"U\"],[\"L\"],[\"U\"]]",
                "output": "**Output**\n[null,0,0,1,1,2,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass SnakeGame {\n    private int width, height, pos, score;\n    private int[][] food;\n    private LinkedList<int[]> snake;\n    private Set<String> occupied;\n\n    public SnakeGame(int width, int height, int[][] food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        pos = 0;\n        score = 0;\n        snake = new LinkedList<>();\n        occupied = new HashSet<>();\n        snake.add(new int[]{0, 0});\n        occupied.add(\"0_0\");\n    }\n\n    public int move(String direction) {\n        int newX = snake.peekLast()[0] + dx.get(direction);\n        int newY = snake.peekLast()[1] + dy.get(direction);\n\n        if (newX < 0 || newX >= height || newY < 0 || newY >= width) {\n            return -1;\n        }\n\n        int[] newHead = new int[]{newX, newY};\n        int[] tail = snake.poll();\n\n        if (pos < food.length && food[pos][0] == newX && food[pos][1] == newY) {\n            score++;\n            pos++;\n        } else {\n            occupied.remove(tail[0] + \"_\" + tail[1]);\n        }\n\n        if (occupied.contains(newX + \"_\" + newY)) {\n            return -1;\n        }\n\n        snake.add(newHead);\n        occupied.add(newX + \"_\" + newY);\n        return score;\n    }\n\n    private static final Map<String, Integer> dx = Map.of(\"U\", -1, \"D\", 1, \"L\", 0, \"R\", 0);\n    private static final Map<String, Integer> dy = Map.of(\"U\", 0, \"D\", 0, \"L\", -1, \"R\", 1);\n}\n```\n    \n    1. Initialize variables width, height, food, pos (food position), score, snake deque with initial position (0, 0), occupied set with initial position, dx and dy dictionary to update coordinate values based on given direction.\n2. In the move method, calculate the next possible coordinates new_x and new_y using dx and dy dictionary.\n3. Check if the new_x and new_y are out of the boundary, if yes then return -1 as it's a game over.\n4. Check if the new position matches with food, if yes then update the score and increment the pos otherwise remove the tail block from the snake and occupied set.\n5. If new_head is already in the occupied set, return -1, Because after moving the snake is colliding itself.\n6. Otherwise, add the new_head in the snake deque and occupied set then return the current score.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass SnakeGame:\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = food\n        self.pos = 0\n        self.score = 0\n        self.snake = deque([(0, 0)])\n        self.occupied = {(0, 0)}\n        self.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0}\n        self.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1}\n\n    def move(self, direction: str) -> int:\n        new_x = self.snake[-1][0] + self.dx[direction]\n        new_y = self.snake[-1][1] + self.dy[direction]\n\n        if new_x < 0 or new_x >= self.height or new_y < 0 or new_y >= self.width:\n            return -1\n\n        new_head = (new_x, new_y)\n        tail = self.snake.popleft()\n\n        if self.pos < len(self.food) and self.food[self.pos] == list(new_head):\n            self.score += 1\n            self.pos += 1\n        else:\n            self.occupied.remove(tail)\n\n        if new_head in self.occupied:\n            return -1\n\n        self.snake.append(new_head)\n        self.occupied.add(new_head)\n        return self.score\n```\n    \n    1. Initialize variables width, height, food, pos (food position), score, snake deque with initial position (0, 0), occupied set with initial position, dx and dy dictionary to update coordinate values based on given direction.\n2. In the move method, calculate the next possible coordinates new_x and new_y using dx and dy dictionary.\n3. Check if the new_x and new_y are out of the boundary, if yes then return -1 as it's a game over.\n4. Check if the new position matches with food, if yes then update the score and increment the pos otherwise remove the tail block from the snake and occupied set.\n5. If new_head is already in the occupied set, return -1, Because after moving the snake is colliding itself.\n6. Otherwise, add the new_head in the snake deque and occupied set then return the current score.\n    ",
        "c++": "\n    ```cpp\n#include <list>\n#include <unordered_set>\n#include <vector>\n\nclass SnakeGame {\npublic:\n    SnakeGame(int width, int height, std::vector<std::vector<int>>& food)\n        : width(width), height(height), food(food), pos(0), score(0) {\n        snake.push_back({0, 0});\n        occupied.insert(0);\n    }\n\n    int move(std::string direction) {\n        int new_x = snake.back().first + dx[direction];\n        int new_y = snake.back().second + dy[direction];\n\n        if (new_x < 0 || new_x >= height || new_y < 0 || new_y >= width) {\n            return -1;\n        }\n\n        std::pair<int, int> new_head = std::make_pair(new_x, new_y);\n        std::pair<int, int> tail = snake.front();\n\n        if (pos < food.size() && food[pos][0] == new_x && food[pos][1] == new_y) {\n            score++;\n            pos++;\n        } else {\n            snake.pop_front();\n            occupied.erase(tail.first * width + tail.second);\n        }\n\n        if (occupied.count(new_head.first * width + new_head.second)) {\n            return -1;\n        }\n\n        snake.push_back(new_head);\n        occupied.insert(new_head.first * width + new_head.second);\n        return score;\n    }\n\nprivate:\n    int width;\n    int height;\n    std::vector<std::vector<int>> food;\n    int pos;\n    int score;\n    std::list<std::pair<int, int>> snake;\n    std::unordered_set<int> occupied;\n    std::unordered_map<std::string, int> dx = {{\"U\", -1}, {\"D\", 1}, {\"L\", 0}, {\"R\", 0}};\n    std::unordered_map<std::string, int> dy = {{\"U\", 0}, {\"D\", 0}, {\"L\", -1}, {\"R\", 1}};\n};\n```\n    \n    1. Initialize variables width, height, food, pos (food position), score, snake deque with initial position (0, 0), occupied set with initial position, dx and dy dictionary to update coordinate values based on given direction.\n2. In the move method, calculate the next possible coordinates new_x and new_y using dx and dy dictionary.\n3. Check if the new_x and new_y are out of the boundary, if yes then return -1 as it's a game over.\n4. Check if the new position matches with food, if yes then update the score and increment the pos otherwise remove the tail block from the snake and occupied set.\n5. If new_head is already in the occupied set, return -1, Because after moving the snake is colliding itself.\n6. Otherwise, add the new_head in the snake deque and occupied set then return the current score.\n    ",
        "js": "\n    ```javascript\nclass SnakeGame {\n    constructor(width, height, food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        this.pos = 0;\n        this.score = 0;\n        this.snake = [[0, 0]];\n        this.occupied = new Set(['0_0']);\n        this.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0};\n        this.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1};\n    }\n\n    move(direction) {\n        let newX = this.snake[this.snake.length - 1][0] + this.dx[direction];\n        let newY = this.snake[this.snake.length - 1][1] + this.dy[direction];\n\n        if (newX < 0 || newX >= this.height || newY < 0 || newY >= this.width) {\n            return -1;\n        }\n\n        let newHead = [newX, newY];\n        let tail = this.snake.shift();\n\n        if (this.pos < this.food.length && this.food[this.pos][0] === newX && this.food[this.pos][1] === newY) {\n            this.score++;\n            this.pos++;\n        } else {\n            this.occupied.delete(tail[0] + '_' + tail[1]);\n        }\n\n        if (this.occupied.has(newX + '_' + newY)) {\n            return -1;\n        }\n\n        this.snake.push(newHead);\n        this.occupied.add(newX + '_' + newY);\n        return this.score;\n    }\n}\n```\n    \n    1. Initialize variables width, height, food, pos (food position), score, snake deque with initial position (0, 0), occupied set with initial position, dx and dy dictionary to update coordinate values based on given direction.\n2. In the move method, calculate the next possible coordinates new_x and new_y using dx and dy dictionary.\n3. Check if the new_x and new_y are out of the boundary, if yes then return -1 as it's a game over.\n4. Check if the new position matches with food, if yes then update the score and increment the pos otherwise remove the tail block from the snake and occupied set.\n5. If new_head is already in the occupied set, return -1, Because after moving the snake is colliding itself.\n6. Otherwise, add the new_head in the snake deque and occupied set then return the current score.\n    "
    },
    {
        "id": 69,
        "title": "Line Reflection",
        "difficulty": "Medium",
        "content": {
            "problem": "Given `n` points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.\n\nIn other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.\n\n**Note** that there can be repeated points.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[-1,1\\]\\]\n**Output:** true\n**Explanation:** We can choose the line x = 0.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[-1,-1\\]\\]\n**Output:** false\n**Explanation:** We can't choose a line."
            ],
            "constraints": "**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 104`\n*   `-108 <= points[i][j] <= 108`\n\n**",
            "follow_up": "Follow up:** Could you do better than `O(n2)`?"
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1],[-1,1]]",
                "output": "true"
            },
            {
                "input": "[[1,1],[-1,-1]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isReflected(int[][] points) {\n    int minX = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    Set<String> pointSet = new HashSet<>();\n\n    for (int[] point : points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    int sum = minX + maxX;\n    for (int[] point : points) {\n        if (!pointSet.contains((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "python": "\n    ```python\ndef isReflected(points):\n    min_x = min(point[0] for point in points)\n    max_x = max(point[0] for point in points)\n    point_set = {(point[0], point[1]) for point in points}\n    \n    sum_x = min_x + max_x\n    for point in points:\n        if (sum_x - point[0], point[1]) not in point_set:\n            return False\n\n    return True\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n\n    unordered_set<string> pointSet;\n    for(const auto& point : points) {\n        minX = min(minX, point[0]);\n        maxX = max(maxX, point[0]);\n        pointSet.insert(to_string(point[0]) + \",\" + to_string(point[1]));\n    }\n\n    int sum = minX + maxX;\n    for(const auto& point : points) {\n        if(!pointSet.count(to_string(sum - point[0]) + \",\" + to_string(point[1]))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "js": "\n    ```javascript\nfunction isReflected(points) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    const pointSet = new Set();\n\n    for (const point of points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    const sum = minX + maxX;\n    for (const point of points) {\n        if (!pointSet.has((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    "
    },
    {
        "id": 70,
        "title": "Rearrange String k Distance Apart",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` and an integer `k`, rearrange `s` such that the same characters are **at least** distance `k` from each other. If it is not possible to rearrange the string, return an empty string `\" \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aabbcc \", k = 3\n**Output:**  \"abcabc \"\n**Explanation:** The same letters are at least a distance of 3 from each other.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaabc \", k = 3\n**Output:**  \" \"\n**Explanation:** It is not possible to rearrange the string.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aaadbbcc \", k = 2\n**Output:**  \"abacabcd \"\n**Explanation:** The same letters are at least a distance of 2 from each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of only lowercase English letters.\n*   `0 <= k <= s.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aabbcc\",3",
                "output": "\"abcabc\""
            },
            {
                "input": "\"aaabc\",3",
                "output": "\"\""
            },
            {
                "input": "\"aaadbbcc\",2",
                "output": "\"abacabcd\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public String rearrangeString(String s, int k) {\n        if (k == 0) return s;\n\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap =\n                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n        maxHeap.addAll(freqMap.entrySet());\n\n        StringBuilder result = new StringBuilder();\n        while (!maxHeap.isEmpty()) {\n            List<Map.Entry<Character, Integer>> temp = new ArrayList<>();\n\n            for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {\n                Map.Entry<Character, Integer> curr = maxHeap.poll();\n\n                result.append(curr.getKey());\n                if (curr.getValue() - 1 > 0) {\n                    curr.setValue(curr.getValue() - 1);\n                    temp.add(curr);\n                }\n            }\n\n            maxHeap.addAll(temp);\n\n            if (maxHeap.isEmpty()) break;\n            if (result.length() < s.length()) {\n                int spaces = k - temp.size();\n                while (spaces-- > 0) result.append(\" \");\n            }\n        }\n\n        if (result.length() < s.length()) return \"\";\n        return result.toString();\n    }\n}\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    ",
        "python": "\n    ```python\nimport heapq\nfrom collections import Counter\n\ndef rearrange_string(s, k):\n    if k == 0:\n        return s\n\n    counter = Counter(s)\n    max_heap = [(-count, char) for char, count in counter.items()]\n    heapq.heapify(max_heap)\n\n    result = []\n    while max_heap:\n        temp = []\n\n        for _ in range(k):\n            if not max_heap:\n                break\n\n            count, char = heapq.heappop(max_heap)\n            result.append(char)\n\n            if count + 1 < 0:\n                temp.append((count + 1, char))\n\n        for item in temp:\n            heapq.heappush(max_heap, item)\n\n        if not max_heap:\n            break\n\n        if len(result) < len(s):\n            result.extend([' '] * (k - len(temp)))\n\n    if len(result) < len(s):\n        return \"\"\n    return \"\".join(result)\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nstring rearrangeString(string s, int k) {\n    if (k == 0) return s;\n    \n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    \n    priority_queue<pair<int, char>> max_heap;\n    for (const auto& kv : freq) {\n        max_heap.emplace(kv.second, kv.first);\n    }\n    \n    string result;\n    while (!max_heap.empty()) {\n        vector<pair<int, char>> temp;\n        \n        for (int i = 0; i < k && !max_heap.empty(); ++i) {\n            auto curr = max_heap.top();\n            max_heap.pop();\n            \n            result += curr.second;\n            if (--curr.first > 0) {\n                temp.push_back(curr);\n            }\n        }\n        \n        for (const auto& entry : temp) {\n            max_heap.push(entry);\n        }\n        \n        if (max_heap.empty()) break;\n        if (result.length() < s.length()) result.append(k - temp.size(), ' ');\n    }\n    \n    if (result.length() < s.length()) return \"\";\n    return result;\n}\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    ",
        "js": "\n    ```javascript\nfunction rearrangeString(s, k) {\n  if (k === 0) return s;\n\n  const freqMap = new Map();\n  for (const c of s) {\n    freqMap.set(c, (freqMap.get(c) || 0) + 1);\n  }\n\n  const maxHeap = Array.from(freqMap.entries()).sort((a, b) => b[1] - a[1]);\n\n  let result = '';\n  while (maxHeap.length) {\n    const temp = [];\n\n    for (let i = 0; i < k && maxHeap.length > 0; i++) {\n      const curr = maxHeap.shift();\n\n      result += curr[0];\n      if (curr[1] - 1 > 0) {\n        temp.push([curr[0], curr[1] - 1]);\n      }\n    }\n\n    maxHeap.unshift(...temp.sort((a, b) => b[1] - a[1]));\n\n    if (!maxHeap.length) break;\n    if (result.length < s.length) {\n      result += \" \".repeat(k - temp.length);\n    }\n  }\n\n  if (result.length < s.length) return \"\";\n  return result;\n}\n```\n\n    \n    The algorithm involves the following steps:\n1. Calculate the frequency of each character in the input string `s`. Store it in a hash table (dictionary/map) `freq`.\n2. Build a max heap (priority queue) from the frequency table. The heap will be sorted based on the frequency values.\n3. While the max heap is not empty, pop the first `k` elements from the heap, where `k` is the minimum distance required between the same characters, and append the characters to the result string.\n4. If the frequency of the popped elements is greater than one, decrement their frequency and store them in a temporary list `temp`.\n5. After popping `k` elements, add them back to the max heap.\n6. If the max heap is empty, break the loop.\n7. If the length of the result string is less than the input string, append `k - temp.length` spaces.\n8. If the final result string length is less than the input string, return an empty string. Otherwise, return the result string.\n\nThis algorithm ensures that characters with the highest frequency are placed first in the result string followed by other characters, maintaining a distance of at least `k` between the same characters. If it's not possible to place characters at that distance, an empty string will be returned.\n    "
    },
    {
        "id": 71,
        "title": "Logger Rate Limiter",
        "difficulty": "Easy",
        "content": {
            "problem": "Design a logger system that receives a stream of messages along with their timestamps. Each **unique** message should only be printed **at most every 10 seconds** (i.e. a message printed at timestamp `t` will prevent other identical messages from being printed until timestamp `t + 10`).\n\nAll messages will come in chronological order. Several messages may arrive at the same timestamp.\n\nImplement the `Logger` class:\n\n*   `Logger()` Initializes the `logger` object.\n*   `bool shouldPrintMessage(int timestamp, string message)` Returns `true` if the `message` should be printed in the given `timestamp`, otherwise returns `false`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Logger \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \"\\]\n\\[\\[\\], \\[1,  \"foo \"\\], \\[2,  \"bar \"\\], \\[3,  \"foo \"\\], \\[8,  \"bar \"\\], \\[10,  \"foo \"\\], \\[11,  \"foo \"\\]\\]\n**Output**\n\\[null, true, true, false, false, false, true\\]\n\n**Explanation**\nLogger logger = new Logger();\nlogger.shouldPrintMessage(1,  \"foo \");  // return true, next allowed timestamp for  \"foo \" is 1 + 10 = 11\nlogger.shouldPrintMessage(2,  \"bar \");  // return true, next allowed timestamp for  \"bar \" is 2 + 10 = 12\nlogger.shouldPrintMessage(3,  \"foo \");  // 3 < 11, return false\nlogger.shouldPrintMessage(8,  \"bar \");  // 8 < 12, return false\nlogger.shouldPrintMessage(10,  \"foo \"); // 10 < 11, return false\nlogger.shouldPrintMessage(11,  \"foo \"); // 11 >= 11, return true, next allowed timestamp for  \"foo \" is 11 + 10 = 21"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= timestamp <= 109`\n*   Every `timestamp` will be passed in non-decreasing order (chronological order).\n*   `1 <= message.length <= 30`\n*   At most `104` calls will be made to `shouldPrintMessage`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],]]",
                "output": "**Output**\n[null,true,true,false,false,false,true]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Logger {\n    private Map<String, Integer> messageTimestamps;\n\n    public Logger() {\n        messageTimestamps = new HashMap<>();\n    }\n\n    public boolean shouldPrintMessage(int timestamp, String message) {\n        if (!messageTimestamps.containsKey(message) || timestamp - messageTimestamps.get(message) >= 10) {\n            messageTimestamps.put(message, timestamp);\n            return true;\n        }\n        return false;\n    }\n}\n```\n    \n    The algorithm initializes an empty map to store message timestamps. The `shouldPrintMessage` function takes input parameters `timestamp` and `message`. It checks if the message is in the map or not. If the message is not in the map or the difference between the given timestamp and the message's timestamp is greater than or equal to 10, it updates the message's timestamp in the map with the given timestamp, and the function returns `true`. If the difference is less than 10, the function returns `false`. This ensures that messages will only be printed at most every 10 seconds.\n    ",
        "python": "\n    ```python\nclass Logger:\n    def __init__(self):\n        self.message_timestamps = {}\n\n    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n        if message not in self.message_timestamps or timestamp - self.message_timestamps[message] >= 10:\n            self.message_timestamps[message] = timestamp\n            return True\n        return False\n```\n    \n    The algorithm initializes an empty map to store message timestamps. The `shouldPrintMessage` function takes input parameters `timestamp` and `message`. It checks if the message is in the map or not. If the message is not in the map or the difference between the given timestamp and the message's timestamp is greater than or equal to 10, it updates the message's timestamp in the map with the given timestamp, and the function returns `true`. If the difference is less than 10, the function returns `false`. This ensures that messages will only be printed at most every 10 seconds.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass Logger {\npublic:\n    unordered_map<string, int> message_timestamps;\n\n    Logger() {\n    }\n    \n    bool shouldPrintMessage(int timestamp, string message) {\n        if (!message_timestamps.count(message) || timestamp - message_timestamps[message] >= 10) {\n            message_timestamps[message] = timestamp;\n            return true;\n        }\n        return false;\n    }\n};\n```\n    \n    The algorithm initializes an empty map to store message timestamps. The `shouldPrintMessage` function takes input parameters `timestamp` and `message`. It checks if the message is in the map or not. If the message is not in the map or the difference between the given timestamp and the message's timestamp is greater than or equal to 10, it updates the message's timestamp in the map with the given timestamp, and the function returns `true`. If the difference is less than 10, the function returns `false`. This ensures that messages will only be printed at most every 10 seconds.\n    ",
        "js": "\n    ```javascript\nclass Logger {\n    constructor() {\n        this.messageTimestamps = {};\n    }\n\n    shouldPrintMessage(timestamp, message) {\n        if (!this.messageTimestamps.hasOwnProperty(message) || timestamp - this.messageTimestamps[message] >= 10) {\n            this.messageTimestamps[message] = timestamp;\n            return true;\n        }\n        return false;\n    }\n}\n```\n    \n    The algorithm initializes an empty map to store message timestamps. The `shouldPrintMessage` function takes input parameters `timestamp` and `message`. It checks if the message is in the map or not. If the message is not in the map or the difference between the given timestamp and the message's timestamp is greater than or equal to 10, it updates the message's timestamp in the map with the given timestamp, and the function returns `true`. If the difference is less than 10, the function returns `false`. This ensures that messages will only be printed at most every 10 seconds.\n    "
    },
    {
        "id": 72,
        "title": "Sort Transformed Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a **sorted** integer array `nums` and three integers `a`, `b` and `c`, apply a quadratic function of the form `f(x) = ax2 + bx + c` to each element `nums[i]` in the array, and return _the array in a sorted order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-4,-2,2,4\\], a = 1, b = 3, c = 5\n**Output:** \\[3,9,15,33\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-4,-2,2,4\\], a = -1, b = 3, c = 5\n**Output:** \\[-23,-5,1,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `-100 <= nums[i], a, b, c <= 100`\n*   `nums` is sorted in **ascending** order.\n\n**",
            "follow_up": "Follow up:** Could you solve it in `O(n)` time?"
        },
        "tag": [],
        "example": [
            {
                "input": "[-4,-2,2,4],1,3,5",
                "output": "[3,9,15,33]"
            },
            {
                "input": "[-4,-2,2,4],-1,3,5",
                "output": "[-23,-5,1,7]"
            }
        ],
        "java": "\n    ```java\npublic int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n    int[] result = new int[nums.length];\n    int i = 0, j = nums.length - 1, index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "python": "\n    ```python\ndef sort_transformed_array(nums, a, b, c):\n    result = [0] * len(nums)\n    i, j = 0, len(nums) - 1\n    index = len(nums) - 1 if a >= 0 else 0\n    \n    while i <= j:\n        left = nums[i] * nums[i] * a + nums[i] * b + c\n        right = nums[j] * nums[j] * a + nums[j] * b + c\n        \n        if a >= 0:\n            if left >= right:\n                result[index] = left\n                index -= 1\n                i += 1\n            else:\n                result[index] = right\n                index -= 1\n                j -= 1\n        else:\n            if left <= right:\n                result[index] = left\n                index += 1\n                i += 1\n            else:\n                result[index] = right\n                index += 1\n                j -= 1\n    return result\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "c++": "\n    ```cpp\nvector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    vector<int> result(nums.size());\n    int i = 0, j = nums.size() - 1, index = (a >= 0) ? nums.size() - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "js": "\n    ```javascript\nfunction sortTransformedArray(nums, a, b, c) {\n    let result = new Array(nums.length);\n    let i = 0, j = nums.length - 1;\n    let index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        let left = nums[i] * nums[i] * a + nums[i] * b + c;\n        let right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    "
    },
    {
        "id": 73,
        "title": "Bomb Enemy",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[ \"0 \", \"E \", \"0 \", \"0 \"\\],\\[ \"E \", \"0 \", \"W \", \"E \"\\],\\[ \"0 \", \"E \", \"0 \", \"0 \"\\]\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[ \"W \", \"W \", \"W \"\\],\\[ \"0 \", \"0 \", \"0 \"\\],\\[ \"E \", \"E \", \"E \"\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `'W'`, `'E'`, or `'0'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"0\",\"E\",\"0\",\"0\"],[\"E\",\"0\",\"W\",\"E\"],[\"0\",\"E\",\"0\",\"0\"]]",
                "output": "3"
            },
            {
                "input": "[[\"W\",\"W\",\"W\"],[\"0\",\"0\",\"0\"],[\"E\",\"E\",\"E\"]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxKilledEnemies(char[][] grid) {\n    if (grid.length == 0) return 0;\n    int m = grid.length, n = grid[0].length, result = 0, rowhits;\n    int[] colhits = new int[n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j-1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E' ? 1 : 0;\n            }\n            if (i == 0 || grid[i-1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E' ? 1 : 0;\n            }\n            if (grid[i][j] == '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "python": "\n    ```python\ndef maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "c++": "\n    ```cpp\nint maxKilledEnemies(vector<vector<char>>& grid) {\n    if (grid.empty()) return 0;\n    int m = grid.size(), n = grid[0].size(), result = 0, rowhits = 0;\n    vector<int> colhits(n, 0);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j - 1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E';\n            }\n            if (i == 0 || grid[i - 1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E';\n            }\n            if (grid[i][j] == '0') result = max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "js": "\n    ```javascript\nfunction maxKilledEnemies(grid) {\n    if (!grid.length) return 0;\n    let m = grid.length, n = grid[0].length, result = 0, rowhits;\n    let colhits = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (j === 0 || grid[i][j - 1] === 'W') {\n                rowhits = 0;\n                for (let k = j; k < n && grid[i][k] !== 'W'; k++)\n                    rowhits += grid[i][k] === 'E' ? 1 : 0;\n            }\n            if (i === 0 || grid[i - 1][j] === 'W') {\n                colhits[j] = 0;\n                for (let k = i; k < m && grid[k][j] !== 'W'; k++)\n                    colhits[j] += grid[k][j] === 'E' ? 1 : 0;\n            }\n            if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    "
    },
    {
        "id": 74,
        "title": "Design Hit Counter",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a hit counter which counts the number of hits received in the past `5` minutes (i.e., the past `300` seconds).\n\nYour system should accept a `timestamp` parameter (**in seconds** granularity), and you may assume that calls are being made to the system in chronological order (i.e., `timestamp` is monotonically increasing). Several hits may arrive roughly at the same time.\n\nImplement the `HitCounter` class:\n\n*   `HitCounter()` Initializes the object of the hit counter system.\n*   `void hit(int timestamp)` Records a hit that happened at `timestamp` (**in seconds**). Several hits may happen at the same `timestamp`.\n*   `int getHits(int timestamp)` Returns the number of hits in the past 5 minutes from `timestamp` (i.e., the past `300` seconds).",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"HitCounter \",  \"hit \",  \"hit \",  \"hit \",  \"getHits \",  \"hit \",  \"getHits \",  \"getHits \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[3\\], \\[4\\], \\[300\\], \\[300\\], \\[301\\]\\]\n**Output**\n\\[null, null, null, null, 3, null, 4, 3\\]\n\n**Explanation**\nHitCounter hitCounter = new HitCounter();\nhitCounter.hit(1);       // hit at timestamp 1.\nhitCounter.hit(2);       // hit at timestamp 2.\nhitCounter.hit(3);       // hit at timestamp 3.\nhitCounter.getHits(4);   // get hits at timestamp 4, return 3.\nhitCounter.hit(300);     // hit at timestamp 300.\nhitCounter.getHits(300); // get hits at timestamp 300, return 4.\nhitCounter.getHits(301); // get hits at timestamp 301, return 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= timestamp <= 2 * 109`\n*   All the calls are being made to the system in chronological order (i.e., `timestamp` is monotonically increasing).\n*   At most `300` calls will be made to `hit` and `getHits`.\n\n**",
            "follow_up": "Follow up:** What if the number of hits per second could be huge? Does your design scale?"
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],]]",
                "output": "**Output**\n[null,null,null,null,3,null,4,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class HitCounter {\n    private Queue<Integer> queue;\n\n    public HitCounter() {\n        queue = new LinkedList<>();\n    }\n\n    public void hit(int timestamp) {\n        queue.offer(timestamp);\n    }\n\n    public int getHits(int timestamp) {\n        while (!queue.isEmpty() && queue.peek() <= (timestamp - 300)) {\n            queue.poll();\n        }\n        return queue.size();\n    }\n}\n```\n    \n    The key to solving this problem is maintaining a queue with hit timestamps. Since the timestamps are monotonically increasing, we can simply simulate the moving window by removing hits that are no longer within the last 300 seconds for a given timestamp.\n\n1. Implement the `HitCounter` class with a queue-like data structure (e.g., `deque`, `queue`, `list`, `linkedlist`)\n2. For `hit(timestamp)`, add the timestamp to the tail of the queue.\n3. For `getHits(timestamp)`, iterate through the timestamps from the head of the queue and remove any timestamp that is not within the last 300 seconds (i.e., <= current_timestamp - 300). Then return the number of timestamps left in the queue (i.e., the size of the queue).\n\nThere is no difference in terms of algorithm between the four languages. They all follow the same logic which is based on the explanation above. Some minor differences include the syntax and how certain operations are done, but the core logic remains the same.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass HitCounter:\n\n    def __init__(self):\n        self.queue = deque()\n\n    def hit(self, timestamp: int) -> None:\n        self.queue.append(timestamp)\n\n    def getHits(self, timestamp: int) -> int:\n        while self.queue and self.queue[0] <= timestamp - 300:\n            self.queue.popleft()\n        return len(self.queue)\n```\n    \n    The key to solving this problem is maintaining a queue with hit timestamps. Since the timestamps are monotonically increasing, we can simply simulate the moving window by removing hits that are no longer within the last 300 seconds for a given timestamp.\n\n1. Implement the `HitCounter` class with a queue-like data structure (e.g., `deque`, `queue`, `list`, `linkedlist`)\n2. For `hit(timestamp)`, add the timestamp to the tail of the queue.\n3. For `getHits(timestamp)`, iterate through the timestamps from the head of the queue and remove any timestamp that is not within the last 300 seconds (i.e., <= current_timestamp - 300). Then return the number of timestamps left in the queue (i.e., the size of the queue).\n\nThere is no difference in terms of algorithm between the four languages. They all follow the same logic which is based on the explanation above. Some minor differences include the syntax and how certain operations are done, but the core logic remains the same.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n\nclass HitCounter {\npublic:\n    HitCounter() {}\n\n    void hit(int timestamp) {\n        q.push(timestamp);\n    }\n\n    int getHits(int timestamp) {\n        while (!q.empty() && q.front() <= (timestamp - 300)) {\n            q.pop();\n        }\n        return q.size();\n    }\n\nprivate:\n    std::queue<int> q;\n};\n```\n    \n    The key to solving this problem is maintaining a queue with hit timestamps. Since the timestamps are monotonically increasing, we can simply simulate the moving window by removing hits that are no longer within the last 300 seconds for a given timestamp.\n\n1. Implement the `HitCounter` class with a queue-like data structure (e.g., `deque`, `queue`, `list`, `linkedlist`)\n2. For `hit(timestamp)`, add the timestamp to the tail of the queue.\n3. For `getHits(timestamp)`, iterate through the timestamps from the head of the queue and remove any timestamp that is not within the last 300 seconds (i.e., <= current_timestamp - 300). Then return the number of timestamps left in the queue (i.e., the size of the queue).\n\nThere is no difference in terms of algorithm between the four languages. They all follow the same logic which is based on the explanation above. Some minor differences include the syntax and how certain operations are done, but the core logic remains the same.\n    ",
        "js": "\n    ```javascript\nclass HitCounter {\n  constructor() {\n    this.queue = [];\n  }\n\n  hit(timestamp) {\n    this.queue.push(timestamp);\n  }\n\n  getHits(timestamp) {\n    while (this.queue.length > 0 && this.queue[0] <= timestamp - 300) {\n      this.queue.shift();\n    }\n    return this.queue.length;\n  }\n}\n```\n    \n    The key to solving this problem is maintaining a queue with hit timestamps. Since the timestamps are monotonically increasing, we can simply simulate the moving window by removing hits that are no longer within the last 300 seconds for a given timestamp.\n\n1. Implement the `HitCounter` class with a queue-like data structure (e.g., `deque`, `queue`, `list`, `linkedlist`)\n2. For `hit(timestamp)`, add the timestamp to the tail of the queue.\n3. For `getHits(timestamp)`, iterate through the timestamps from the head of the queue and remove any timestamp that is not within the last 300 seconds (i.e., <= current_timestamp - 300). Then return the number of timestamps left in the queue (i.e., the size of the queue).\n\nThere is no difference in terms of algorithm between the four languages. They all follow the same logic which is based on the explanation above. Some minor differences include the syntax and how certain operations are done, but the core logic remains the same.\n    "
    },
    {
        "id": 75,
        "title": "Nested List Weight Sum II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists.\n\nThe **depth** of an integer is the number of lists that it is inside of. For example, the nested list `[1,[2,2],[[3],2],1]` has each integer's value set to its **depth**. Let `maxDepth` be the **maximum depth** of any integer.\n\nThe **weight** of an integer is `maxDepth - (the depth of the integer) + 1`.\n\nReturn _the sum of each integer in_ `nestedList` _multiplied by its **weight**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nestedList = \\[\\[1,1\\],2,\\[1,1\\]\\]\n**Output:** 8\n**Explanation:** Four 1's with a weight of 1, one 2 with a weight of 2.\n1\\*1 + 1\\*1 + 2\\*2 + 1\\*1 + 1\\*1 = 8\n\n",
                "**Example 2:**\n\n**Input:** nestedList = \\[1,\\[4,\\[6\\]\\]\\]\n**Output:** 17\n**Explanation:** One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1.\n1\\*3 + 4\\*2 + 6\\*1 = 17"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nestedList.length <= 50`\n*   The values of the integers in the nested list is in the range `[-100, 100]`.\n*   The maximum **depth** of any integer is less than or equal to `50`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1],2,[1,1]]",
                "output": "8"
            },
            {
                "input": "[1,[4,[6]]]",
                "output": "17"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int depthSumInverse(List<NestedInteger> nestedList) {\n    int maxDepth = maxDepth(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}\n\nprivate int maxDepth(List<NestedInteger> nestedList) {\n    int depth = 1;\n    for (NestedInteger nested : nestedList) {\n        if (!nested.isInteger()) {\n            depth = Math.max(depth, 1 + maxDepth(nested.getList()));\n        }\n    }\n    return depth;\n}\n\nprivate int sumHelper(List<NestedInteger> nestedList, int depth) {\n    int sum = 0;\n    for (NestedInteger nested : nestedList) {\n        if (nested.isInteger()) {\n            sum += depth * nested.getInteger();\n        } else {\n            sum += sumHelper(nested.getList(), depth - 1);\n        }\n    }\n    return sum;\n}\n```\n    \n    1. First, we find the maximum depth of the integers in the input nestedList using a helper function maxDepthHelper by recursively going through all elements in nestedList. For every sublist encountered, we update the depth to the maximum depth found so far.\n2. Then, we compute the weighted sum of all integers in the nestedList by calling another helper function sumHelper. sumHelper goes through every element in nestedList and, for each integer, it calculates the weighted sum by multiplying the integer value with its corresponding weight (which is maxDepth - currentDepth + 1).\n3. Finally, the main function returns the total weighted sum obtained in the previous step.\n\nTime complexity: O(N) where N is the total number of elements (integers and nested lists) in the input nestedList. In each recursive call, we process a single element.\nSpace complexity: O(D) where D is the maximum depth of integers found in the nestedList. This is for the recursive call stack.\n    ",
        "python": "\n    ```python\nfrom typing import List, Union\n\nNestedInteger = Union[int, List[Union[int, \"NestedInteger\"]]]\n\ndef depthSumInverse(nestedList: List[NestedInteger]) -> int:\n    max_depth = max_depth_helper(nestedList)\n    return sum_helper(nestedList, max_depth)\n\ndef max_depth_helper(nested_list: List[NestedInteger]) -> int:\n    depth = 1\n    for nested in nested_list:\n        if isinstance(nested, list):\n            depth = max(depth, 1 + max_depth_helper(nested))\n    return depth\n\ndef sum_helper(nested_list: List[NestedInteger], depth: int) -> int:\n    sum = 0\n    for nested in nested_list:\n        if isinstance(nested, int):\n            sum += depth * nested\n        else:\n            sum += sum_helper(nested, depth - 1)\n    return sum\n```\n    \n    1. First, we find the maximum depth of the integers in the input nestedList using a helper function maxDepthHelper by recursively going through all elements in nestedList. For every sublist encountered, we update the depth to the maximum depth found so far.\n2. Then, we compute the weighted sum of all integers in the nestedList by calling another helper function sumHelper. sumHelper goes through every element in nestedList and, for each integer, it calculates the weighted sum by multiplying the integer value with its corresponding weight (which is maxDepth - currentDepth + 1).\n3. Finally, the main function returns the total weighted sum obtained in the previous step.\n\nTime complexity: O(N) where N is the total number of elements (integers and nested lists) in the input nestedList. In each recursive call, we process a single element.\nSpace complexity: O(D) where D is the maximum depth of integers found in the nestedList. This is for the recursive call stack.\n    ",
        "c++": "\n    ```cpp\n#include <variant>\n#include <vector>\n\nusing NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;\n\nint sumHelper(NestedInteger& nested, int depth) {\n    int sum = 0;\n    if (auto pInt = std::get_if<int>(&nested)) {\n        sum += depth * (*pInt);\n    } else {\n        auto& list = std::get<std::vector<NestedInteger>>(nested);\n        for (auto& element : list) {\n            sum += sumHelper(element, depth - 1);\n        }\n    }\n    return sum;\n}\n\nint maxDepth(NestedInteger& nested) {\n    if (std::holds_alternative<int>(nested)) return 0;\n    int depth = 1;\n    for (auto& element : std::get<std::vector<NestedInteger>>(nested)) {\n        depth = std::max(depth, 1 + maxDepth(element));\n    }\n    return depth;\n}\n\nint depthSumInverse(std::vector<NestedInteger>& nestedList) {\n    int max_depth = 1;\n    for (auto& nested : nestedList) {\n        max_depth = std::max(max_depth, 1 + maxDepth(nested));\n    }\n    int sum = 0;\n    for (auto& nested : nestedList) {\n        sum += sumHelper(nested, max_depth);\n    }\n    return sum;\n}\n```\n    \n    1. First, we find the maximum depth of the integers in the input nestedList using a helper function maxDepthHelper by recursively going through all elements in nestedList. For every sublist encountered, we update the depth to the maximum depth found so far.\n2. Then, we compute the weighted sum of all integers in the nestedList by calling another helper function sumHelper. sumHelper goes through every element in nestedList and, for each integer, it calculates the weighted sum by multiplying the integer value with its corresponding weight (which is maxDepth - currentDepth + 1).\n3. Finally, the main function returns the total weighted sum obtained in the previous step.\n\nTime complexity: O(N) where N is the total number of elements (integers and nested lists) in the input nestedList. In each recursive call, we process a single element.\nSpace complexity: O(D) where D is the maximum depth of integers found in the nestedList. This is for the recursive call stack.\n    ",
        "js": "\n    ```javascript\nfunction depthSumInverse(nestedList) {\n    function maxDepthHelper(nestedList) {\n        let depth = 1;\n        for (let nested of nestedList) {\n            if (Array.isArray(nested)) {\n                depth = Math.max(depth, 1 + maxDepthHelper(nested));\n            }\n        }\n        return depth;\n    }\n    function sumHelper(nestedList, depth) {\n        let sum = 0;\n        for (let nested of nestedList) {\n            if (typeof nested === \"number\") {\n                sum += depth * nested;\n            } else {\n                sum += sumHelper(nested, depth - 1);\n            }\n        }\n        return sum;\n    }\n    let maxDepth = maxDepthHelper(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}\n```\n    \n    1. First, we find the maximum depth of the integers in the input nestedList using a helper function maxDepthHelper by recursively going through all elements in nestedList. For every sublist encountered, we update the depth to the maximum depth found so far.\n2. Then, we compute the weighted sum of all integers in the nestedList by calling another helper function sumHelper. sumHelper goes through every element in nestedList and, for each integer, it calculates the weighted sum by multiplying the integer value with its corresponding weight (which is maxDepth - currentDepth + 1).\n3. Finally, the main function returns the total weighted sum obtained in the previous step.\n\nTime complexity: O(N) where N is the total number of elements (integers and nested lists) in the input nestedList. In each recursive call, we process a single element.\nSpace complexity: O(D) where D is the maximum depth of integers found in the nestedList. This is for the recursive call stack.\n    "
    },
    {
        "id": 76,
        "title": "Find Leaves of Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, collect a tree's nodes as if you were doing this:\n\n*   Collect all the leaf nodes.\n*   Remove all the leaf nodes.\n*   Repeat until the tree is empty.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5\\]\n**Output:** \\[\\[4,5,3\\],\\[2\\],\\[1\\]\\]\nExplanation:\n\\[\\[3,5,4\\],\\[2\\],\\[1\\]\\] and \\[\\[3,4,5\\],\\[2\\],\\[1\\]\\] are also considered correct answers since per each level it does not matter the order on which elements are returned.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[\\[1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5]",
                "output": "[[4,5,3],[2],[1]]\nExplanation:\n[[3,5,4],[2],[1]]and[[3,4,5],[2],[1]]arealsoconsideredcorrectanswerssincepereachlevelitdoesnotmattertheorderonwhichelementsarereturned."
            },
            {
                "input": "[1]",
                "output": "[[1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<List<Integer>> findLeaves(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    findLeaves(root, result, 0);\n    return result;\n}\n\nprivate int findLeaves(TreeNode node, List<List<Integer>> result, int level) {\n    if (node == null) return -1;\n    int leftLevel = findLeaves(node.left, result, level + 1);\n    int rightLevel = findLeaves(node.right, result, level + 1);\n    level = Math.max(leftLevel, rightLevel) + 1;\n    if (result.size() <= level) result.add(new ArrayList<>());\n    result.get(level).add(node.val);\n    return level;\n}\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to find the leaves at the same level. The algorithm uses a helper function `findLeaves` to recursively traverse the tree. \n\nIn each recursive call, the current node is checked for being a leaf node (both left and right children are `null`). If the current node is a leaf, its value is added to the corresponding level of the result vector. If not, the recursion continues for the left and right children. The level variable stores the current level of the leaf node.\n\nThe `findLeaves` function runs as long as there are nodes left in the tree. Once all the leaf nodes are collected and removed, the result vector contains the desired output.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_leaves(node, result, level):\n    if not node:\n        return -1\n    left_level = find_leaves(node.left, result, level + 1)\n    right_level = find_leaves(node.right, result, level + 1)\n    level = max(left_level, right_level) + 1\n    if len(result) <= level:\n        result.append([])\n    result[level].append(node.val)\n    return level\n\ndef findLeaves(root):\n    result = []\n    find_leaves(root, result, 0)\n    return result\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to find the leaves at the same level. The algorithm uses a helper function `findLeaves` to recursively traverse the tree. \n\nIn each recursive call, the current node is checked for being a leaf node (both left and right children are `null`). If the current node is a leaf, its value is added to the corresponding level of the result vector. If not, the recursion continues for the left and right children. The level variable stores the current level of the leaf node.\n\nThe `findLeaves` function runs as long as there are nodes left in the tree. Once all the leaf nodes are collected and removed, the result vector contains the desired output.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nvoid findLeaves(TreeNode* node, std::vector<std::vector<int>>& result, int& level) {\n    if (!node) return;\n    if (!node->left && !node->right) {\n        if (result.size() <= level) {\n            result.push_back(std::vector<int>());\n        }\n        result[level].push_back(node->val);\n        node = nullptr;\n        return;\n    }\n    level++;\n    findLeaves(node->left, result, level);\n    findLeaves(node->right, result, level);\n    level--;\n}\n\nstd::vector<std::vector<int>> findLeaves(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    int level = 0;\n    while (root) {\n        findLeaves(root, result, level);\n        if (!root->left && !root->right) root = nullptr;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to find the leaves at the same level. The algorithm uses a helper function `findLeaves` to recursively traverse the tree. \n\nIn each recursive call, the current node is checked for being a leaf node (both left and right children are `null`). If the current node is a leaf, its value is added to the corresponding level of the result vector. If not, the recursion continues for the left and right children. The level variable stores the current level of the leaf node.\n\nThe `findLeaves` function runs as long as there are nodes left in the tree. Once all the leaf nodes are collected and removed, the result vector contains the desired output.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val = 0, left = null, right = null){\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction findLeaves(root) {\n    const result = [];\n    findLeavesHelper(root, result, 0);\n    return result;\n}\n\nfunction findLeavesHelper(node, result, level) {\n    if (node === null) return -1;\n    const leftLevel = findLeavesHelper(node.left, result, level + 1);\n    const rightLevel = findLeavesHelper(node.right, result, level + 1);\n    level = Math.max(leftLevel, rightLevel) + 1;\n    if (result.length <= level) result.push([]);\n    result[level].push(node.val);\n    return level;\n}\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to find the leaves at the same level. The algorithm uses a helper function `findLeaves` to recursively traverse the tree. \n\nIn each recursive call, the current node is checked for being a leaf node (both left and right children are `null`). If the current node is a leaf, its value is added to the corresponding level of the result vector. If not, the recursion continues for the left and right children. The level variable stores the current level of the leaf node.\n\nThe `findLeaves` function runs as long as there are nodes left in the tree. Once all the leaf nodes are collected and removed, the result vector contains the desired output.\n    "
    },
    {
        "id": 77,
        "title": "Plus One Linked List",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a non-negative integer represented as a linked list of digits, _plus one to the integer_.\n\nThe digits are stored such that the most significant digit is at the `head` of the list.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3\\]\n**Output:** \\[1,2,4\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[0\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   The number represented by the linked list does not contain leading zeros except for the zero itself.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "[1,2,4]"
            },
            {
                "input": "[0]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode plusOne(ListNode head) {\n    if (head == null) return head;\n    int carry = plusOneDfs(head);\n    if (carry == 1) {\n        ListNode newHead = new ListNode(1);\n        newHead.next = head;\n        return newHead;\n    }\n    return head;\n}\n\nprivate int plusOneDfs(ListNode node) {\n    if (node == null) return 1;\n    int carry = plusOneDfs(node.next);\n    if (carry + node.val == 10) {\n        node.val = 0;\n        return 1;\n    } else {\n        node.val += carry;\n        return 0;\n    }\n}\n```\n\n    \n    We define our linked list nodes with a simple struct (in C++) or class (in other languages) with the `val` and `next` attributes. We then perform a postorder depth first search on the linked list to obtain the least significant digit first. When the traversal reaches the end of the list (i.e., current node is NULL or None), it returns an initial carry of 1 as we want to \"plus one\" to the number. As we return from the recursive call, we add the carry to the current node's value, and if it resulted in a 10, we reset the value to 0 and return carry 1 to the next higher digit. Otherwise, we update the node value and return 0 carry.\n\nIf a carry of 1 is left after the traversal of the entire list, we create a new head node with value 1 and link it to the original head as the new most significant digit. Finally, we return our new head node of the linked list.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef plusOne(head: ListNode) -> ListNode:\n    def plusOneDfs(node):\n        if not node:\n            return 1\n        carry = plusOneDfs(node.next)\n        if carry + node.val == 10:\n            node.val = 0\n            return 1\n        else:\n            node.val += carry\n            return 0\n\n    if not head:\n        return head\n    carry = plusOneDfs(head)\n    if carry == 1:\n        new_head = ListNode(1)\n        new_head.next = head\n        return new_head\n    return head\n```\n\n    \n    We define our linked list nodes with a simple struct (in C++) or class (in other languages) with the `val` and `next` attributes. We then perform a postorder depth first search on the linked list to obtain the least significant digit first. When the traversal reaches the end of the list (i.e., current node is NULL or None), it returns an initial carry of 1 as we want to \"plus one\" to the number. As we return from the recursive call, we add the carry to the current node's value, and if it resulted in a 10, we reset the value to 0 and return carry 1 to the next higher digit. Otherwise, we update the node value and return 0 carry.\n\nIf a carry of 1 is left after the traversal of the entire list, we create a new head node with value 1 and link it to the original head as the new most significant digit. Finally, we return our new head node of the linked list.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* plusOne(ListNode* head) {\n    if (head == NULL) return head;\n    if (plusOneDfs(head) == 1) {\n        ListNode* newHead = new ListNode(1);\n        newHead->next = head;\n        return newHead;\n    }\n    return head;\n}\n\nint plusOneDfs(ListNode* node) {\n    if (node == NULL) return 1;\n    int carry = plusOneDfs(node->next);\n    if (carry + node->val == 10) {\n        node->val = 0;\n        return 1;\n    } else {\n        node->val += carry;\n        return 0;\n    }\n}\n```\n\n    \n    We define our linked list nodes with a simple struct (in C++) or class (in other languages) with the `val` and `next` attributes. We then perform a postorder depth first search on the linked list to obtain the least significant digit first. When the traversal reaches the end of the list (i.e., current node is NULL or None), it returns an initial carry of 1 as we want to \"plus one\" to the number. As we return from the recursive call, we add the carry to the current node's value, and if it resulted in a 10, we reset the value to 0 and return carry 1 to the next higher digit. Otherwise, we update the node value and return 0 carry.\n\nIf a carry of 1 is left after the traversal of the entire list, we create a new head node with value 1 and link it to the original head as the new most significant digit. Finally, we return our new head node of the linked list.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction plusOne(head) {\n    function plusOneDfs(node) {\n        if (!node) return 1;\n        const carry = plusOneDfs(node.next);\n        if (carry + node.val === 10) {\n            node.val = 0;\n            return 1;\n        } else {\n            node.val += carry;\n            return 0;\n        }\n    }\n\n    if (!head) return head;\n    const carry = plusOneDfs(head);\n    if (carry === 1) {\n        const newHead = new ListNode(1);\n        newHead.next = head;\n        return newHead;\n    }\n    return head;\n}\n```\n\n    \n    We define our linked list nodes with a simple struct (in C++) or class (in other languages) with the `val` and `next` attributes. We then perform a postorder depth first search on the linked list to obtain the least significant digit first. When the traversal reaches the end of the list (i.e., current node is NULL or None), it returns an initial carry of 1 as we want to \"plus one\" to the number. As we return from the recursive call, we add the carry to the current node's value, and if it resulted in a 10, we reset the value to 0 and return carry 1 to the next higher digit. Otherwise, we update the node value and return 0 carry.\n\nIf a carry of 1 is left after the traversal of the entire list, we create a new head node with value 1 and link it to the original head as the new most significant digit. Finally, we return our new head node of the linked list.\n    "
    },
    {
        "id": 78,
        "title": "Range Addition",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.\n\nYou have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.\n\nReturn `arr` _after applying all the_ `updates`.",
            "examples": [
                "**Example 1:**\n\n**Input:** length = 5, updates = \\[\\[1,3,2\\],\\[2,4,3\\],\\[0,2,-2\\]\\]\n**Output:** \\[-2,0,3,5,3\\]\n\n",
                "**Example 2:**\n\n**Input:** length = 10, updates = \\[\\[2,4,6\\],\\[5,6,8\\],\\[1,9,-4\\]\\]\n**Output:** \\[0,-4,2,2,2,4,4,-4,-4,-4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= length <= 105`\n*   `0 <= updates.length <= 104`\n*   `0 <= startIdxi <= endIdxi < length`\n*   `-1000 <= inci <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[1,3,2],[2,4,3],[0,2,-2]]",
                "output": "[-2,0,3,5,3]"
            },
            {
                "input": "10,[[2,4,6],[5,6,8],[1,9,-4]]",
                "output": "[0,-4,2,2,2,4,4,-4,-4,-4]"
            }
        ],
        "java": "\n    ```java\npublic int[] getUpdatedArray(int length, int[][] updates) {\n    int[] arr = new int[length];\n\n    for (int[] update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "python": "\n    ```python\ndef get_updated_array(length, updates):\n    arr = [0] * length\n\n    for start, end, inc in updates:\n        arr[start] += inc\n        if end + 1 < length:\n            arr[end + 1] -= inc\n\n    for i in range(1, length):\n        arr[i] += arr[i - 1]\n\n    return arr\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getUpdatedArray(int length, vector<vector<int>>& updates) {\n    vector<int> arr(length, 0);\n\n    for (const auto& update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "js": "\n    ```javascript\nfunction getUpdatedArray(length, updates) {\n    const arr = new Array(length).fill(0);\n\n    for (const [start, end, inc] of updates) {\n        arr[start] += inc;\n        if (end + 1 < length) {\n            arr[end + 1] -= inc;\n        }\n    }\n\n    for (let i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n\n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    "
    },
    {
        "id": 79,
        "title": "Design Phone Directory",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a phone directory that initially has `maxNumbers` empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.\n\nImplement the `PhoneDirectory` class:\n\n*   `PhoneDirectory(int maxNumbers)` Initializes the phone directory with the number of available slots `maxNumbers`.\n*   `int get()` Provides a number that is not assigned to anyone. Returns `-1` if no number is available.\n*   `bool check(int number)` Returns `true` if the slot `number` is available and `false` otherwise.\n*   `void release(int number)` Recycles or releases the slot `number`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"PhoneDirectory \",  \"get \",  \"get \",  \"check \",  \"get \",  \"check \",  \"release \",  \"check \"\\]\n\\[\\[3\\], \\[\\], \\[\\], \\[2\\], \\[\\], \\[2\\], \\[2\\], \\[2\\]\\]\n**Output**\n\\[null, 0, 1, true, 2, false, null, true\\]\n\n**Explanation**\nPhoneDirectory phoneDirectory = new PhoneDirectory(3);\nphoneDirectory.get();      // It can return any available phone number. Here we assume it returns 0.\nphoneDirectory.get();      // Assume it returns 1.\nphoneDirectory.check(2);   // The number 2 is available, so return true.\nphoneDirectory.get();      // It returns 2, the only number that is left.\nphoneDirectory.check(2);   // The number 2 is no longer available, so return false.\nphoneDirectory.release(2); // Release number 2 back to the pool.\nphoneDirectory.check(2);   // Number 2 is available again, return true."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= maxNumbers <= 104`\n*   `0 <= number < maxNumbers`\n*   At most `2 * 104` calls will be made to `get`, `check`, and `release`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],]]",
                "output": "**Output**\n[null,0,1,true,2,false,null,true]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass PhoneDirectory {\n    boolean[] available;\n    Queue<Integer> released;\n\n    public PhoneDirectory(int maxNumbers) {\n        available = new boolean[maxNumbers];\n        Arrays.fill(available, true);\n        released = new LinkedList<>();\n    }\n    \n    public int get() {\n        if (!released.isEmpty()) {\n            int number = released.poll();\n            available[number] = false;\n            return number;\n        }\n        for (int i = 0; i < available.length; i++) {\n            if (available[i]) {\n                available[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    public boolean check(int number) {\n        return available[number];\n    }\n    \n    public void release(int number) {\n        if (!available[number]) {\n            available[number] = true;\n            released.offer(number);\n        }\n    }\n}\n```\n\n    \n    The algorithm uses an array of booleans called `available` with a size of `maxNumbers` to represent each slot's availability (true means available, and false means occupied). Additionally, it uses a queue called `released` to store numbers that have been released recently.\n\n- When the phone directory is initialized, all `available` slots are set to `true`, and the `released` queue is empty.\n- When `get()` is called, it returns the first available number. If there is a recently released number in the `released` queue, it assigns this number to the caller and removes it from the queue. If there are no recently released numbers, it simply finds the first available number in the `available` array, sets it to `false`, and returns it. If no number is available, it returns `-1`.\n- When `check()` is called, it returns the value of `available[number]` (true or false).\n- When `release()` is called, it sets the value of `available[number]` to `true` and enqueues this number to the `released` queue if the slot is not already available.\n\nThis solution ensures that each operation (get, check, and release) has an O(maxNumbers) complexity in the worst case, meeting the requirement given the constraints.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass PhoneDirectory:\n    def __init__(self, maxNumbers: int):\n        self.available = [True] * maxNumbers\n        self.released = deque()\n    \n    def get(self) -> int:\n        if self.released:\n            number = self.released.popleft()\n            self.available[number] = False\n            return number\n        for i in range(len(self.available)):\n            if self.available[i]:\n                self.available[i] = False\n                return i\n        return -1\n    \n    def check(self, number: int) -> bool:\n        return self.available[number]\n    \n    def release(self, number: int) -> None:\n        if not self.available[number]:\n            self.available[number] = True\n            self.released.append(number)\n```\n\n    \n    The algorithm uses an array of booleans called `available` with a size of `maxNumbers` to represent each slot's availability (true means available, and false means occupied). Additionally, it uses a queue called `released` to store numbers that have been released recently.\n\n- When the phone directory is initialized, all `available` slots are set to `true`, and the `released` queue is empty.\n- When `get()` is called, it returns the first available number. If there is a recently released number in the `released` queue, it assigns this number to the caller and removes it from the queue. If there are no recently released numbers, it simply finds the first available number in the `available` array, sets it to `false`, and returns it. If no number is available, it returns `-1`.\n- When `check()` is called, it returns the value of `available[number]` (true or false).\n- When `release()` is called, it sets the value of `available[number]` to `true` and enqueues this number to the `released` queue if the slot is not already available.\n\nThis solution ensures that each operation (get, check, and release) has an O(maxNumbers) complexity in the worst case, meeting the requirement given the constraints.\n    ",
        "c++": "\n    ```cpp\nclass PhoneDirectory {\n    vector<bool> available;\n    queue<int> released;\npublic:\n    PhoneDirectory(int maxNumbers): available(maxNumbers, true) {}\n    \n    int get() {\n        if(!released.empty()) {\n            int number = released.front();\n            released.pop();\n            available[number] = false;\n            return number;\n        }\n        for(int i = 0; i < available.size(); i++) {\n            if(available[i]) {\n                available[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    bool check(int number) {\n        return available[number];\n    }\n    \n    void release(int number) {\n        if(!available[number]) {\n            available[number] = true;\n            released.push(number);\n        }\n    }\n};\n```\n\n    \n    The algorithm uses an array of booleans called `available` with a size of `maxNumbers` to represent each slot's availability (true means available, and false means occupied). Additionally, it uses a queue called `released` to store numbers that have been released recently.\n\n- When the phone directory is initialized, all `available` slots are set to `true`, and the `released` queue is empty.\n- When `get()` is called, it returns the first available number. If there is a recently released number in the `released` queue, it assigns this number to the caller and removes it from the queue. If there are no recently released numbers, it simply finds the first available number in the `available` array, sets it to `false`, and returns it. If no number is available, it returns `-1`.\n- When `check()` is called, it returns the value of `available[number]` (true or false).\n- When `release()` is called, it sets the value of `available[number]` to `true` and enqueues this number to the `released` queue if the slot is not already available.\n\nThis solution ensures that each operation (get, check, and release) has an O(maxNumbers) complexity in the worst case, meeting the requirement given the constraints.\n    ",
        "js": "\n    ```javascript\nclass PhoneDirectory {\n    constructor(maxNumbers) {\n        this.available = new Array(maxNumbers).fill(true);\n        this.released = [];\n    }\n    \n    get() {\n        if (this.released.length > 0) {\n            let number = this.released.shift();\n            this.available[number] = false;\n            return number;\n        }\n        for (let i = 0; i < this.available.length; i++) {\n            if (this.available[i]) {\n                this.available[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    check(number) {\n        return this.available[number];\n    }\n    \n    release(number) {\n        if (!this.available[number]) {\n            this.available[number] = true;\n            this.released.push(number);\n        }\n    }\n}\n```\n\n    \n    The algorithm uses an array of booleans called `available` with a size of `maxNumbers` to represent each slot's availability (true means available, and false means occupied). Additionally, it uses a queue called `released` to store numbers that have been released recently.\n\n- When the phone directory is initialized, all `available` slots are set to `true`, and the `released` queue is empty.\n- When `get()` is called, it returns the first available number. If there is a recently released number in the `released` queue, it assigns this number to the caller and removes it from the queue. If there are no recently released numbers, it simply finds the first available number in the `available` array, sets it to `false`, and returns it. If no number is available, it returns `-1`.\n- When `check()` is called, it returns the value of `available[number]` (true or false).\n- When `release()` is called, it sets the value of `available[number]` to `true` and enqueues this number to the `released` queue if the slot is not already available.\n\nThis solution ensures that each operation (get, check, and release) has an O(maxNumbers) complexity in the worst case, meeting the requirement given the constraints.\n    "
    },
    {
        "id": 80,
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement the `RandomizedSet` class:\n\n*   `RandomizedSet()` Initializes the `RandomizedSet` object.\n*   `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.\n*   `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.\n*   `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.\n\nYou must implement the functions of the class such that each function works in **average** `O(1)` time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"RandomizedSet \",  \"insert \",  \"remove \",  \"insert \",  \"getRandom \",  \"remove \",  \"insert \",  \"getRandom \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[2\\], \\[\\], \\[1\\], \\[2\\], \\[\\]\\]\n**Output**\n\\[null, true, false, true, 2, true, false, 2\\]\n\n**Explanation**\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains \\[1,2\\].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains \\[2\\].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= val <= 231 - 1`\n*   At most `2 *` `105` calls will be made to `insert`, `remove`, and `getRandom`.\n*   There will be **at least one** element in the data structure when `getRandom` is called.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],]]",
                "output": "**Output**\n[null,true,false,true,2,true,false,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class RandomizedSet {\n    private Map<Integer, Integer> indexMap;\n    private List<Integer> nums;\n    private Random rand;\n\n    public RandomizedSet() {\n        indexMap = new HashMap<>();\n        nums = new ArrayList<>();\n        rand = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (indexMap.containsKey(val)) return false;\n\n        indexMap.put(val, nums.size());\n        nums.add(val);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!indexMap.containsKey(val)) return false;\n\n        int last = nums.get(nums.size() - 1);\n        indexMap.put(last, indexMap.get(val));\n        nums.set(indexMap.get(val), last);\n\n        nums.remove(nums.size() - 1);\n        indexMap.remove(val);\n        return true;\n    }\n\n    public int getRandom() {\n        return nums.get(rand.nextInt(nums.size()));\n    }\n}\n```\n    \n    The algorithm uses a combination of both data structures, HashMap and ArrayList (or unordered_map and vector in C++). The HashMap is used to store the values and their corresponding indices in the ArrayList.\n\n1. When inserting a value, we first check if the value is already present in the HashMap. If it's not present, we add the value to the HashMap with its index in the ArrayList, and also add the value to the ArrayList.\n\n2. When removing a value, we check if the value is present in the HashMap. If it's present, we swap the value to be removed with the last value in the ArrayList, update the HashMap with the new index of the last value, and remove the last value from the ArrayList. After that, we remove the value from the HashMap.\n\n3. To get a random value, we use the random function to generate a random index within the ArrayList's range and return the value at that index.\n\nBy using this combination of data structures, we are able to achieve average O(1) time complexity for each of the functions.\n    ",
        "python": "\n    ```python\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.index_map = {}\n        self.nums = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.index_map:\n            return False\n\n        self.index_map[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.index_map:\n            return False\n\n        last = self.nums[-1]\n        self.index_map[last] = self.index_map[val]\n        self.nums[self.index_map[val]] = last\n\n        self.nums.pop()\n        del self.index_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        return self.nums[random.randint(0, len(self.nums) - 1)]\n```\n    \n    The algorithm uses a combination of both data structures, HashMap and ArrayList (or unordered_map and vector in C++). The HashMap is used to store the values and their corresponding indices in the ArrayList.\n\n1. When inserting a value, we first check if the value is already present in the HashMap. If it's not present, we add the value to the HashMap with its index in the ArrayList, and also add the value to the ArrayList.\n\n2. When removing a value, we check if the value is present in the HashMap. If it's present, we swap the value to be removed with the last value in the ArrayList, update the HashMap with the new index of the last value, and remove the last value from the ArrayList. After that, we remove the value from the HashMap.\n\n3. To get a random value, we use the random function to generate a random index within the ArrayList's range and return the value at that index.\n\nBy using this combination of data structures, we are able to achieve average O(1) time complexity for each of the functions.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <random>\n\nclass RandomizedSet {\n    std::unordered_map<int, int> index_map;\n    std::vector<int> nums;\npublic:\n    bool insert(int val) {\n        if (index_map.count(val)) return false;\n\n        index_map[val] = nums.size();\n        nums.push_back(val);\n        return true;\n    }\n\n    bool remove(int val) {\n        if (!index_map.count(val)) return false;\n\n        int last = nums.back();\n        index_map[last] = index_map[val];\n        nums[index_map[val]] = last;\n\n        nums.pop_back();\n        index_map.erase(val);\n        return true;\n    }\n\n    int getRandom() {\n        return nums[rand() % nums.size()];\n    }\n};\n```\n    \n    The algorithm uses a combination of both data structures, HashMap and ArrayList (or unordered_map and vector in C++). The HashMap is used to store the values and their corresponding indices in the ArrayList.\n\n1. When inserting a value, we first check if the value is already present in the HashMap. If it's not present, we add the value to the HashMap with its index in the ArrayList, and also add the value to the ArrayList.\n\n2. When removing a value, we check if the value is present in the HashMap. If it's present, we swap the value to be removed with the last value in the ArrayList, update the HashMap with the new index of the last value, and remove the last value from the ArrayList. After that, we remove the value from the HashMap.\n\n3. To get a random value, we use the random function to generate a random index within the ArrayList's range and return the value at that index.\n\nBy using this combination of data structures, we are able to achieve average O(1) time complexity for each of the functions.\n    ",
        "js": "\n    ```javascript\nclass RandomizedSet {\n    constructor() {\n        this.indexMap = new Map();\n        this.nums = [];\n    }\n\n    insert(val) {\n        if (this.indexMap.has(val)) return false;\n\n        this.indexMap.set(val, this.nums.length);\n        this.nums.push(val);\n        return true;\n    }\n\n    remove(val) {\n        if (!this.indexMap.has(val)) return false;\n\n        const last = this.nums[this.nums.length - 1];\n        this.indexMap.set(last, this.indexMap.get(val));\n        this.nums[this.indexMap.get(val)] = last;\n\n        this.nums.pop();\n        this.indexMap.delete(val);\n        return true;\n    }\n\n    getRandom() {\n        return this.nums[Math.floor(Math.random() * this.nums.length)];\n    }\n}\n```\n    \n    The algorithm uses a combination of both data structures, HashMap and ArrayList (or unordered_map and vector in C++). The HashMap is used to store the values and their corresponding indices in the ArrayList.\n\n1. When inserting a value, we first check if the value is already present in the HashMap. If it's not present, we add the value to the HashMap with its index in the ArrayList, and also add the value to the ArrayList.\n\n2. When removing a value, we check if the value is present in the HashMap. If it's present, we swap the value to be removed with the last value in the ArrayList, update the HashMap with the new index of the last value, and remove the last value from the ArrayList. After that, we remove the value from the HashMap.\n\n3. To get a random value, we use the random function to generate a random index within the ArrayList's range and return the value at that index.\n\nBy using this combination of data structures, we are able to achieve average O(1) time complexity for each of the functions.\n    "
    },
    {
        "id": 81,
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": "Hard",
        "content": {
            "problem": "`RandomizedCollection` is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the `RandomizedCollection` class:\n\n*   `RandomizedCollection()` Initializes the empty `RandomizedCollection` object.\n*   `bool insert(int val)` Inserts an item `val` into the multiset, even if the item is already present. Returns `true` if the item is not present, `false` otherwise.\n*   `bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item is present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.\n*   `int getRandom()` Returns a random element from the current multiset of elements. The probability of each element being returned is **linearly related** to the number of the same values the multiset contains.\n\nYou must implement the functions of the class such that each function works on **average** `O(1)` time complexity.\n\n**Note:** The test cases are generated such that `getRandom` will only be called if there is **at least one** item in the `RandomizedCollection`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"RandomizedCollection \",  \"insert \",  \"insert \",  \"insert \",  \"getRandom \",  \"remove \",  \"getRandom \"\\]\n\\[\\[\\], \\[1\\], \\[1\\], \\[2\\], \\[\\], \\[1\\], \\[\\]\\]\n**Output**\n\\[null, true, false, true, 2, true, 1\\]\n\n**Explanation**\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains \\[1,1\\].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains \\[1,1,2\\].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains \\[1,2\\].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= val <= 231 - 1`\n*   At most `2 * 105` calls **in total** will be made to `insert`, `remove`, and `getRandom`.\n*   There will be **at least one** element in the data structure when `getRandom` is called.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],]]",
                "output": "**Output**\n[null,true,false,true,2,true,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass RandomizedCollection {\n    Map<Integer, Set<Integer>> indices;\n    List<Integer> nums;\n\n    public RandomizedCollection() {\n        indices = new HashMap<>();\n        nums = new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        nums.add(val);\n        indices.putIfAbsent(val, new HashSet<>());\n        indices.get(val).add(nums.size() - 1);\n        return indices.get(val).size() == 1;\n    }\n    \n    public boolean remove(int val) {\n        if (!indices.containsKey(val) || indices.get(val).isEmpty()) return false;\n        int idx = indices.get(val).iterator().next();\n        indices.get(val).remove(idx);\n\n        if (idx < nums.size() - 1) {\n            int last = nums.get(nums.size() - 1);\n            nums.set(idx, last);\n            indices.get(last).remove(nums.size() - 1);\n            indices.get(last).add(idx);\n        }\n        nums.remove(nums.size() - 1);\n        return true;\n    }\n    \n    public int getRandom() {\n        int index = (int) (Math.random() * nums.size());\n        return nums.get(index);\n    }\n}\n```\n\n    \n    The data structure uses a HashMap (or an unordered_map in C++, or a Map in JavaScript) called 'indices' to store the indices of each number in the collection. It also uses a List (or a vector in C++, or an Array in JavaScript) called 'nums' to store the numbers in the order they are inserted.\n\nThe 'insert' function adds the element to the nums list and updates the indices in the HashMap. If the size of the index set is equal to 1, then the value is new. The 'remove' function removes an element from the nums list and updates the indices in the HashMap accordingly. To keep the time complexity O(1), we swap the element to remove with the last element in the list, and then remove the last element from the list.\n\nFinally, the 'getRandom' function generates a random index in the range of the size of the nums list and returns the element at that index. Since each function takes constant time on average, the overall time complexity is O(1).\n    ",
        "python": "\n    ```python\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.indices = defaultdict(set)\n        self.nums = []\n\n    def insert(self, val):\n        self.nums.append(val)\n        self.indices[val].add(len(self.nums) - 1)\n        return len(self.indices[val]) == 1\n\n    def remove(self, val):\n        if not self.indices[val]:\n            return False\n\n        idx = self.indices[val].pop()\n        if idx < len(self.nums) - 1:\n            last = self.nums[-1]\n            self.nums[idx] = last\n            self.indices[last].remove(len(self.nums) - 1)\n            self.indices[last].add(idx)\n        self.nums.pop()\n        return True\n\n    def getRandom(self):\n        return self.nums[random.randint(0, len(self.nums) - 1)]\n```\n\n    \n    The data structure uses a HashMap (or an unordered_map in C++, or a Map in JavaScript) called 'indices' to store the indices of each number in the collection. It also uses a List (or a vector in C++, or an Array in JavaScript) called 'nums' to store the numbers in the order they are inserted.\n\nThe 'insert' function adds the element to the nums list and updates the indices in the HashMap. If the size of the index set is equal to 1, then the value is new. The 'remove' function removes an element from the nums list and updates the indices in the HashMap accordingly. To keep the time complexity O(1), we swap the element to remove with the last element in the list, and then remove the last element from the list.\n\nFinally, the 'getRandom' function generates a random index in the range of the size of the nums list and returns the element at that index. Since each function takes constant time on average, the overall time complexity is O(1).\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <random>\n\nclass RandomizedCollection {\npublic:\n    unordered_map<int, unordered_set<int>> indices;\n    vector<int> nums;\n    \n    bool insert(int val) {\n        nums.push_back(val);\n        indices[val].insert(nums.size() - 1);\n        return indices[val].size() == 1;\n    }\n    \n    bool remove(int val) {\n        if (!indices[val].size()) return false;\n        int idx = *indices[val].begin();\n        indices[val].erase(idx);\n        if (idx < nums.size() - 1) {\n            int last = nums.back();\n            nums[idx] = last;\n            indices[last].erase(nums.size() - 1);\n            indices[last].insert(idx);\n        }\n        nums.pop_back();\n        return true;\n    }\n    \n    int getRandom() {\n        return nums[rand() % nums.size()];\n    }\n};\n```\n\n    \n    The data structure uses a HashMap (or an unordered_map in C++, or a Map in JavaScript) called 'indices' to store the indices of each number in the collection. It also uses a List (or a vector in C++, or an Array in JavaScript) called 'nums' to store the numbers in the order they are inserted.\n\nThe 'insert' function adds the element to the nums list and updates the indices in the HashMap. If the size of the index set is equal to 1, then the value is new. The 'remove' function removes an element from the nums list and updates the indices in the HashMap accordingly. To keep the time complexity O(1), we swap the element to remove with the last element in the list, and then remove the last element from the list.\n\nFinally, the 'getRandom' function generates a random index in the range of the size of the nums list and returns the element at that index. Since each function takes constant time on average, the overall time complexity is O(1).\n    ",
        "js": "\n    ```javascript\nclass RandomizedCollection {\n    constructor() {\n        this.indices = new Map();\n        this.nums = [];\n    }\n\n    insert(val) {\n        this.nums.push(val);\n        if (!this.indices.has(val)) this.indices.set(val, new Set());\n        this.indices.get(val).add(this.nums.length - 1);\n        return this.indices.get(val).size === 1;\n    }\n\n    remove(val) {\n        if (!this.indices.has(val) || this.indices.get(val).size === 0) return false;\n        const idx = this.indices.get(val).values().next().value;\n        this.indices.get(val).delete(idx);\n\n        if (idx < this.nums.length - 1) {\n            const last = this.nums[this.nums.length - 1];\n            this.nums[idx] = last;\n            this.indices.get(last).delete(this.nums.length - 1);\n            this.indices.get(last).add(idx);\n        }\n        this.nums.pop();\n        return true;\n    }\n\n    getRandom() {\n        const index = Math.floor(Math.random() * this.nums.length);\n        return this.nums[index];\n    }\n}\n```\n\n    \n    The data structure uses a HashMap (or an unordered_map in C++, or a Map in JavaScript) called 'indices' to store the indices of each number in the collection. It also uses a List (or a vector in C++, or an Array in JavaScript) called 'nums' to store the numbers in the order they are inserted.\n\nThe 'insert' function adds the element to the nums list and updates the indices in the HashMap. If the size of the index set is equal to 1, then the value is new. The 'remove' function removes an element from the nums list and updates the indices in the HashMap accordingly. To keep the time complexity O(1), we swap the element to remove with the last element in the list, and then remove the last element from the list.\n\nFinally, the 'getRandom' function generates a random index in the range of the size of the nums list and returns the element at that index. Since each function takes constant time on average, the overall time complexity is O(1).\n    "
    },
    {
        "id": 82,
        "title": "Valid Word Abbreviation",
        "difficulty": "Easy",
        "content": {
            "problem": "A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.\n\nFor example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nThe following are **not valid** abbreviations:\n\n*   `\"s55n \"` ( `\"s ubsti tutio n \"`, the replaced substrings are adjacent)\n*   `\"s010n \"` (has leading zeros)\n*   `\"s0ubstitution \"` (replaces an empty substring)\n\nGiven a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.\n\nA **substring** is a contiguous **non-empty** sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"internationalization \", abbr =  \"i12iz4n \"\n**Output:** true\n**Explanation:** The word  \"internationalization \" can be abbreviated as  \"i12iz4n \" ( \"i nternational iz atio n \").\n\n",
                "**Example 2:**\n\n**Input:** word =  \"apple \", abbr =  \"a2e \"\n**Output:** false\n**Explanation:** The word  \"apple \" cannot be abbreviated as  \"a2e \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 20`\n*   `word` consists of only lowercase English letters.\n*   `1 <= abbr.length <= 10`\n*   `abbr` consists of lowercase English letters and digits.\n*   All the integers in `abbr` will fit in a 32-bit integer.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"internationalization\",\"i12iz4n\"",
                "output": "true"
            },
            {
                "input": "\"apple\",\"a2e\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean validWordAbbreviation(String word, String abbr) {\n    int i = 0, j = 0;\n    while (i < word.length() && j < abbr.length()) {\n        if (Character.isDigit(abbr.charAt(j))) {\n            if (abbr.charAt(j) == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))\n                num = num * 10 + (abbr.charAt(j++) - '0');\n            i += num;\n        } else {\n            if (word.charAt(i++) != abbr.charAt(j++)) return false;\n        }\n    }\n    return i == word.length() && j == abbr.length();\n}\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "python": "\n    ```python\ndef validWordAbbreviation(word, abbr):\n    i, j = 0, 0\n    while i < len(word) and j < len(abbr):\n        if abbr[j].isdigit():\n            if abbr[j] == '0': return False  # leading zero\n            num = 0\n            while j < len(abbr) and abbr[j].isdigit():\n                num = num * 10 + int(abbr[j])\n                j += 1\n            i += num\n        else:\n            if word[i] != abbr[j]: return False\n            i, j = i + 1, j + 1\n    return i == len(word) and j == len(abbr)\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "c++": "\n    ```cpp\nbool validWordAbbreviation(string word, string abbr) {\n    int i = 0, j = 0;\n    while (i < word.size() && j < abbr.size()) {\n        if (isdigit(abbr[j])) {\n            if (abbr[j] == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.size() && isdigit(abbr[j]))\n                num = num * 10 + (abbr[j++] - '0');\n            i += num;\n        } else {\n            if (word[i++] != abbr[j++]) return false;\n        }\n    }\n    return i == word.size() && j == abbr.size();\n}\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "js": "\n    ```javascript\nfunction validWordAbbreviation(word, abbr) {\n    let i = 0, j = 0;\n    while (i < word.length && j < abbr.length) {\n        if (!isNaN(abbr[j])) {\n            if (abbr[j] === '0') return false; // leading zero\n            let num = 0;\n            while (j < abbr.length && !isNaN(abbr[j])) {\n                num = num * 10 + parseInt(abbr[j]);\n                j++;\n            }\n            i += num;\n        } else {\n            if (word[i] !== abbr[j]) return false;\n            i++; j++;\n        }\n    }\n    return i === word.length && j === abbr.length;\n}\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    "
    },
    {
        "id": 83,
        "title": "Minimum Unique Word Abbreviation",
        "difficulty": "Hard",
        "content": {
            "problem": "A string can be **abbreviated** by replacing any number of **non-adjacent** substrings with their lengths. For example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nNote that `\"s55n \"` ( `\"s ubsti tutio n \"`) is not a valid abbreviation of `\"substitution \"` because the replaced substrings are adjacent.\n\nThe **length** of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation `\"s10n \"` has a length of `3` (`2` letters + `1` substring) and `\"su3i1u2on \"` has a length of `9` (`6` letters + `3` substrings).\n\nGiven a target string `target` and an array of strings `dictionary`, return _an **abbreviation** of_ `target` _with the **shortest possible length** such that it is **not an abbreviation** of **any** string in_ `dictionary`_. If there are multiple shortest abbreviations, return any of them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** target =  \"apple \", dictionary = \\[ \"blade \"\\]\n**Output:**  \"a4 \"\n**Explanation:** The shortest abbreviation of  \"apple \" is  \"5 \", but this is also an abbreviation of  \"blade \".\nThe next shortest abbreviations are  \"a4 \" and  \"4e \".  \"4e \" is an abbreviation of blade while  \"a4 \" is not.\nHence, return  \"a4 \".\n\n",
                "**Example 2:**\n\n**Input:** target =  \"apple \", dictionary = \\[ \"blade \", \"plain \", \"amber \"\\]\n**Output:**  \"1p3 \"\n**Explanation:**  \"5 \" is an abbreviation of both  \"apple \" but also every word in the dictionary.\n \"a4 \" is an abbreviation of  \"apple \" but also  \"amber \".\n \"4e \" is an abbreviation of  \"apple \" but also  \"blade \".\n \"1p3 \",  \"2p2 \", and  \"3l1 \" are the next shortest abbreviations of  \"apple \".\nSince none of them are abbreviations of words in the dictionary, returning any of them is correct."
            ],
            "constraints": "**Constraints:**\n\n*   `m == target.length`\n*   `n == dictionary.length`\n*   `1 <= m <= 21`\n*   `0 <= n <= 1000`\n*   `1 <= dictionary[i].length <= 100`\n*   `log2(n) + m <= 21` if `n > 0`\n*   `target` and `dictionary[i]` consist of lowercase English letters.\n*   `dictionary` does not contain `target`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"apple\",[\"blade\"]",
                "output": "\"a4\""
            },
            {
                "input": "\"apple\",[\"blade\",\"plain\",\"amber\"]",
                "output": "\"1p3\""
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic class Solution {\n    private static String abbreviate(String s, int k, int i) {\n        if (i == s.length()) {\n            return (k > 0) ? String.valueOf(k) : \"\";\n        }\n        if (k == 0) {\n            return s.substring(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n        }\n        return String.valueOf(k) + s.charAt(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n    }\n\n    private static boolean isAbbreviation(String target, String word) {\n        int i = 0, j = 0;\n        while (i < target.length() && j < word.length()) {\n            if (target.charAt(i) == word.charAt(j)) {\n                i++; j++;\n            } else if (Character.isDigit(target.charAt(i))) {\n                int k = 0;\n                while (i < target.length() && Character.isDigit(target.charAt(i))) {\n                    k = k * 10 + target.charAt(i++) - '0';\n                }\n                j += k;\n            } else {\n                return false;\n            }\n        }\n        return (i == target.length() && j == word.length());\n    }\n\n    public static String minAbbreviation(String target, List<String> dictionary) {\n        String ans = target;\n        for (int k = 0; k <= target.length(); k++) {\n            for (int i = 0; i <= target.length() - k; i++) {\n                String current = abbreviate(target, k, i);\n                if (current.length() < ans.length()) {\n                    boolean valid = true;\n                    for (String word : dictionary) {\n                        if (isAbbreviation(current, word)) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        ans = current;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "python": "\n    ```python\ndef abbreviate(s, k, i):\n    if i == len(s):\n        return str(k) if k > 0 else \"\"\n    if k == 0:\n        return s[i:] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n    return str(k) + s[i] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n\ndef is_abbreviation(target, word):\n    i, j = 0, 0\n    while i < len(target) and j < len(word):\n        if target[i] == word[j]:\n            i, j = i + 1, j + 1\n        elif target[i].isdigit():\n            k = 0\n            while i < len(target) and target[i].isdigit():\n                k = k * 10 + int(target[i])\n                i += 1\n            j += k\n        else:\n            return False\n    return i == len(target) and j == len(word)\n\ndef min_abbreviation(target, dictionary):\n    ans = target\n    for k in range(0, len(target) + 1):\n        for i in range(0, len(target) - k + 1):\n            current = abbreviate(target, k, i)\n            if len(current) < len(ans):\n                valid = True\n                for word in dictionary:\n                    if is_abbreviation(current, word):\n                        valid = False\n                        break\n                if valid:\n                    ans = current\n    return ans\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string abbreviate(const std::string& s, int k, int i) {\n    if (i == s.length()) {\n        return (k > 0) ? std::to_string(k) : \"\";\n    }\n    if (k == 0) {\n        return s.substr(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n    }\n    return std::to_string(k) + s[i] + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n}\n\nbool isAbbreviation(const std::string& target, const std::string& word) {\n    int i = 0, j = 0;\n    while (i < target.length() && j < word.length()) {\n        if (target[i] == word[j]) {\n            i++; j++;\n        } else if (isdigit(target[i])) {\n            int k = 0;\n            while (i < target.length() && isdigit(target[i])) {\n                k = k * 10 + target[i++] - '0';\n            }\n            j += k;\n        } else {\n            return false;\n        }\n    }\n    return (i == target.length() && j == word.length());\n}\n\nstd::string minAbbreviation(std::string target, std::vector<std::string>& dictionary) {\n    std::string ans = target;\n    for (int k = 0; k <= target.length(); k++) {\n        for (int i = 0; i <= target.length() - k; i++) {\n            std::string current = abbreviate(target, k, i);\n            if (current.length() < ans.length()) {\n                bool valid = true;\n                for (const std::string& word : dictionary) {\n                    if (isAbbreviation(current, word)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    ans = current;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "js": "\n    ```javascript\nfunction abbreviate(s, k, i) {\n    if (i === s.length) {\n        return (k > 0) ? String(k) : \"\";\n    }\n    if (k === 0) {\n        return s.slice(i) + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : \"\");\n    }\n    return String(k) + s[i] + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : \"\");\n}\n\nfunction isAbbreviation(target, word) {\n    let i = 0, j = 0;\n    while (i < target.length && j < word.length) {\n        if (target[i] === word[j]) {\n            i++; j++;\n        } else if (target[i] >= '0' && target[i] <= '9') {\n            let k = 0;\n            while (i < target.length && target[i] >= '0' && target[i] <= '9') {\n                k = k * 10 + parseInt(target[i++]);\n            }\n            j += k;\n        } else {\n            return false;\n        }\n    }\n    return (i === target.length && j === word.length);\n}\n\nfunction minAbbreviation(target, dictionary) {\n    let ans = target;\n    for (let k = 0; k <= target.length; k++) {\n        for (let i = 0; i <= target.length - k; i++) {\n            let current = abbreviate(target, k, i);\n            if (current.length < ans.length) {\n                let valid = true;\n                for (const word of dictionary) {\n                    if (isAbbreviation(current, word)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    ans = current;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    "
    },
    {
        "id": 84,
        "title": "Sentence Screen Fitting",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.\n\nThe order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence = \\[ \"hello \", \"world \"\\], rows = 2, cols = 8\n**Output:** 1\n**Explanation:**\nhello---\nworld---\nThe character '-' signifies an empty space on the screen.\n\n",
                "**Example 2:**\n\n**Input:** sentence = \\[ \"a \",  \"bcd \",  \"e \"\\], rows = 3, cols = 6\n**Output:** 2\n**Explanation:**\na-bcd- \ne-a---\nbcd-e-\nThe character '-' signifies an empty space on the screen.\n\n",
                "**Example 3:**\n\n**Input:** sentence = \\[ \"i \", \"had \", \"apple \", \"pie \"\\], rows = 4, cols = 5\n**Output:** 1\n**Explanation:**\ni-had\napple\npie-i\nhad--\nThe character '-' signifies an empty space on the screen."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 100`\n*   `1 <= sentence[i].length <= 10`\n*   `sentence[i]` consists of lowercase English letters.\n*   `1 <= rows, cols <= 2 * 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"hello\",\"world\"],2,8",
                "output": "1"
            },
            {
                "input": "[\"a\",\"bcd\",\"e\"],3,6",
                "output": "2"
            },
            {
                "input": "[\"i\",\"had\",\"apple\",\"pie\"],4,5",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int wordsTyping(String[] sentence, int rows, int cols) {\n    int totalChars = 0;\n    for (String word : sentence) {\n        totalChars += word.length() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remainingCols = cols;\n        while (true) {\n            int wordLen = sentence[index].length();\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "python": "\n    ```python\ndef words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "c++": "\n    ```cpp\nint wordsTyping(vector<string>& sentence, int rows, int cols) {\n    int total_chars = 0;\n    for (const auto& word : sentence) {\n        total_chars += word.size() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remaining_cols = cols;\n        while (true) {\n            int word_len = sentence[index].size();\n            if (remaining_cols >= word_len) {\n                remaining_cols -= word_len + 1;\n                index = (index + 1) % sentence.size();\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "js": "\n    ```javascript\nfunction wordsTyping(sentence, rows, cols) {\n    let totalChars = sentence.reduce((acc, word) => acc + word.length + 1, 0);\n\n    let result = 0;\n    let index = 0;\n    for (let r = 0; r < rows; ++r) {\n        let remainingCols = cols;\n        while (true) {\n            let wordLen = sentence[index].length;\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index === 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    "
    },
    {
        "id": 85,
        "title": "Valid Word Square",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `words`, return `true` _if it forms a valid **word square**_.\n\nA sequence of strings forms a valid **word square** if the `kth` row and column read the same string, where `0 <= k < max(numRows, numColumns)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abcd \", \"bnrt \", \"crmy \", \"dtye \"\\]\n**Output:** true\n**Explanation:**\nThe 1st row and 1st column both read  \"abcd \".\nThe 2nd row and 2nd column both read  \"bnrt \".\nThe 3rd row and 3rd column both read  \"crmy \".\nThe 4th row and 4th column both read  \"dtye \".\nTherefore, it is a valid word square.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"abcd \", \"bnrt \", \"crm \", \"dt \"\\]\n**Output:** true\n**Explanation:**\nThe 1st row and 1st column both read  \"abcd \".\nThe 2nd row and 2nd column both read  \"bnrt \".\nThe 3rd row and 3rd column both read  \"crm \".\nThe 4th row and 4th column both read  \"dt \".\nTherefore, it is a valid word square.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"ball \", \"area \", \"read \", \"lady \"\\]\n**Output:** false\n**Explanation:**\nThe 3rd row reads  \"read \" while the 3rd column reads  \"lead \".\nTherefore, it is NOT a valid word square."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 500`\n*   `1 <= words[i].length <= 500`\n*   `words[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"abcd\",\"bnrt\",\"crmy\",\"dtye\"]",
                "output": "true"
            },
            {
                "input": "[\"abcd\",\"bnrt\",\"crm\",\"dt\"]",
                "output": "true"
            },
            {
                "input": "[\"ball\",\"area\",\"read\",\"lady\"]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean validWordSquare(List<String> words) {\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < words.get(i).length(); j++) {\n            if (j >= words.size() || i >= words.get(j).length() || words.get(i).charAt(j) != words.get(j).charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "python": "\n    ```python\ndef valid_word_square(words):\n    for i in range(len(words)):\n        for j in range(len(words[i])):\n            if j >= len(words) or i >= len(words[j]) or words[i][j] != words[j][i]:\n                return False\n    return True\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "c++": "\n    ```cpp\nbool validWordSquare(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i) {\n        for (int j = 0; j < words[i].size(); ++j) {\n            if (j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "js": "\n    ```javascript\nfunction validWordSquare(words) {\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words[i].length; j++) {\n            if (j >= words.length || i >= words[j].length || words[i][j] !== words[j][i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    "
    },
    {
        "id": 86,
        "title": "Word Squares",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of **unique** strings `words`, return _all the_ **[word squares](https://en.wikipedia.org/wiki/Word_square)** _you can build from_ `words`. The same word from `words` can be used **multiple times**. You can return the answer in **any order**.\n\nA sequence of strings forms a valid **word square** if the `kth` row and column read the same string, where `0 <= k < max(numRows, numColumns)`.\n\n*   For example, the word sequence `[ \"ball \", \"area \", \"lead \", \"lady \"]` forms a word square because each word reads the same both horizontally and vertically.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"area \", \"lead \", \"wall \", \"lady \", \"ball \"\\]\n**Output:** \\[\\[ \"ball \", \"area \", \"lead \", \"lady \"\\],\\[ \"wall \", \"area \", \"lead \", \"lady \"\\]\\]\n**Explanation:**\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"abat \", \"baba \", \"atan \", \"atal \"\\]\n**Output:** \\[\\[ \"baba \", \"abat \", \"baba \", \"atal \"\\],\\[ \"baba \", \"abat \", \"baba \", \"atan \"\\]\\]\n**Explanation:**\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 4`\n*   All `words[i]` have the same length.\n*   `words[i]` consists of only lowercase English letters.\n*   All `words[i]` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]",
                "output": "[[\"ball\",\"area\",\"lead\",\"lady\"],[\"wall\",\"area\",\"lead\",\"lady\"]]"
            },
            {
                "input": "[\"abat\",\"baba\",\"atan\",\"atal\"]",
                "output": "[[\"baba\",\"abat\",\"baba\",\"atal\"],[\"baba\",\"abat\",\"baba\",\"atan\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> wordSquares(String[] words) {\n    Map<String, List<String>> prefixMap = buildPrefixMap(words);\n    List<List<String>> squares = new ArrayList<>();\n    for (String word : words) {\n        List<String> square = new ArrayList<>();\n        square.add(word);\n        searchSquares(1, words[0].length(), square, prefixMap, squares);\n    }\n    return squares;\n}\n\nprivate void searchSquares(int index, int length, List<String> square, Map<String, List<String>> prefixMap, List<List<String>> squares) {\n    if (index == length) {\n        squares.add(new ArrayList<>(square));\n        return;\n    }\n    String prefix = buildPrefix(square, index);\n    for (String word : prefixMap.getOrDefault(prefix, new ArrayList<>())) {\n        square.add(word);\n        searchSquares(index + 1, length, square, prefixMap, squares);\n        square.remove(square.size() - 1);\n    }\n}\n\nprivate String buildPrefix(List<String> square, int index) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < index; i++) {\n        sb.append(square.get(i).charAt(index));\n    }\n    return sb.toString();\n}\n\nprivate Map<String, List<String>> buildPrefixMap(String[] words) {\n    Map<String, List<String>> prefixMap = new HashMap<>();\n    for (String word : words) {\n        for (int i = 0; i <= word.length(); i++) {\n            String prefix = word.substring(0, i);\n            if (!prefixMap.containsKey(prefix)) {\n                prefixMap.put(prefix, new ArrayList<>());\n            }\n            prefixMap.get(prefix).add(word);\n        }\n    }\n    return prefixMap;\n}\n```\n    \n    The algorithm starts by building a prefix map where keys are prefixes of the words in 'words' and values are the words that have that prefix. This is done to easily find words sharing the same prefix in constant time during the search.\n\nNext, the main algorithm iterates through each word in 'words' and creates a word square using the prefix map. It starts from the first word and adds it to the square. Then, on each step, it finds all the words that share the same prefix with the current row and the previous columns. For example, if the first word is 'ball', then the second word should have the prefix 'a', because the second column must have 'area' or a word with the same prefix for the word square to be valid.\n\nFor each possible match found in the prefix map, the algorithm adds the word to the square and checks the next row. If it reaches the end, the algorithm adds the current square to the list of results. This process is repeated for each word in 'words', thus finding all valid word squares.\n\nFinally, the list of all valid word squares is returned.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef wordSquares(words):\n    def build(row, squares, word_lens):\n        if row == word_lens:\n            res.append(list(squares))\n            return\n        prefix = ''.join(squares[i][row] for i in range(row))\n        for w in prefixes[prefix]:\n            squares[row] = w\n            build(row+1, squares, word_lens)\n\n    if not words: return []\n    res = []\n    word_lens = len(words[0])\n    \n    prefixes = defaultdict(list)\n    for word in words:\n        for i in range(word_lens+1):\n            prefixes[word[:i]].append(word)\n            \n    for word in words:\n        build(1, [word] + [None]*(word_lens-1), word_lens)\n        \n    return res\n```\n    \n    The algorithm starts by building a prefix map where keys are prefixes of the words in 'words' and values are the words that have that prefix. This is done to easily find words sharing the same prefix in constant time during the search.\n\nNext, the main algorithm iterates through each word in 'words' and creates a word square using the prefix map. It starts from the first word and adds it to the square. Then, on each step, it finds all the words that share the same prefix with the current row and the previous columns. For example, if the first word is 'ball', then the second word should have the prefix 'a', because the second column must have 'area' or a word with the same prefix for the word square to be valid.\n\nFor each possible match found in the prefix map, the algorithm adds the word to the square and checks the next row. If it reaches the end, the algorithm adds the current square to the list of results. This process is repeated for each word in 'words', thus finding all valid word squares.\n\nFinally, the list of all valid word squares is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nvoid build(int r, const std::vector<std::string>& words, std::vector<std::string>& sq, std::unordered_map<std::string, std::vector<std::string>>& mapping, std::vector<std::vector<std::string>>& res){\n    if(r == sq.size()){\n        res.push_back(sq);\n        return;\n    }\n    std::string prefix;\n    for(int i=0; i<r; i++){\n        prefix.push_back(sq[i][r]);\n    }\n    for(auto& word: mapping[prefix]){\n        sq[r] = word;\n        build(r+1, words, sq, mapping, res);\n    }\n}\n\nstd::vector<std::vector<std::string>> wordSquares(std::vector<std::string>& words){\n    std::vector<std::vector<std::string>> res;\n    if(words.empty()) return res;\n    std::unordered_map<std::string, std::vector<std::string>> mapping;\n    for(const auto& w: words){\n        for(int i=0; i<=w.size(); i++){\n            mapping[w.substr(0, i)].push_back(w);\n        }\n    }\n    for(const auto& w: words){\n        std::vector<std::string> sq(words[0].size(), \"\");\n        sq[0] = w;\n        build(1, words, sq, mapping, res);\n    }\n    return res;\n}\n```\n    \n    The algorithm starts by building a prefix map where keys are prefixes of the words in 'words' and values are the words that have that prefix. This is done to easily find words sharing the same prefix in constant time during the search.\n\nNext, the main algorithm iterates through each word in 'words' and creates a word square using the prefix map. It starts from the first word and adds it to the square. Then, on each step, it finds all the words that share the same prefix with the current row and the previous columns. For example, if the first word is 'ball', then the second word should have the prefix 'a', because the second column must have 'area' or a word with the same prefix for the word square to be valid.\n\nFor each possible match found in the prefix map, the algorithm adds the word to the square and checks the next row. If it reaches the end, the algorithm adds the current square to the list of results. This process is repeated for each word in 'words', thus finding all valid word squares.\n\nFinally, the list of all valid word squares is returned.\n    ",
        "js": "\n    ```javascript\nfunction wordSquares(words) {\n    const buildPrefixMap = words => {\n        const prefixMap = new Map();\n        for (const word of words) {\n            for (let i = 0; i <= word.length; i++) {\n                const prefix = word.slice(0, i);\n                if (!prefixMap.has(prefix)) {\n                    prefixMap.set(prefix, []);\n                }\n                prefixMap.get(prefix).push(word);\n            }\n        }\n        return prefixMap;\n    };\n\n    const search = (row, square, prefixMap, res) => {\n        if (row === square.length) {\n            res.push(square.slice());\n            return;\n        }\n        const prefix = square.slice(0, row).map((word, i) => word[row]).join('');\n        for (const word of prefixMap.get(prefix) || []) {\n            square[row] = word;\n            search(row + 1, square, prefixMap, res);\n        }\n    };\n\n    const prefixMap = buildPrefixMap(words);\n    const res = [];\n    for (const word of words) {\n        search(1, [word], prefixMap, res);\n    }\n    return res;\n}\n```\n    \n    The algorithm starts by building a prefix map where keys are prefixes of the words in 'words' and values are the words that have that prefix. This is done to easily find words sharing the same prefix in constant time during the search.\n\nNext, the main algorithm iterates through each word in 'words' and creates a word square using the prefix map. It starts from the first word and adds it to the square. Then, on each step, it finds all the words that share the same prefix with the current row and the previous columns. For example, if the first word is 'ball', then the second word should have the prefix 'a', because the second column must have 'area' or a word with the same prefix for the word square to be valid.\n\nFor each possible match found in the prefix map, the algorithm adds the word to the square and checks the next row. If it reaches the end, the algorithm adds the current square to the list of results. This process is repeated for each word in 'words', thus finding all valid word squares.\n\nFinally, the list of all valid word squares is returned.\n    "
    },
    {
        "id": 87,
        "title": "Convert Binary Search Tree to Sorted Doubly Linked List",
        "difficulty": "Medium",
        "content": {
            "problem": "Convert a **Binary Search Tree** to a sorted **Circular Doubly-Linked List** in place.\n\nYou can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.\n\nWe want to do the transformation **in place**. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\]\n\n \n**Output:** \\[1,2,3,4,5\\]\n\n**Explanation:** The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.\n \n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[1,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-1000 <= Node.val <= 1000`\n*   All the values of the tree are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,5,1,3]",
                "output": "[1,2,3,4,5]"
            },
            {
                "input": "[2,1,3]",
                "output": "[1,2,3]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    private static class Node {\n        int val;\n        Node left;\n        Node right;\n\n        Node(int val, Node left, Node right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    private Node first = null;\n    private Node last = null;\n\n    public Node treeToDoublyList(Node root) {\n        if (root == null) {\n            return null;\n        }\n\n        inOrder(root);\n\n        last.right = first;\n        first.left = last;\n\n        return first;\n    }\n\n    private void inOrder(Node root) {\n        if (root == null) {\n            return;\n        }\n\n        inOrder(root.left);\n\n        if (last != null) {\n            last.right = root;\n            root.left = last;\n        } else {\n            first = root;\n        }\n\n        last = root;\n\n        inOrder(root.right);\n    }\n}\n```\n\n    \n    The idea is to perform an in-order traversal of the given binary search tree, and while traversing, change the left and right pointers of each node to form a doubly linked list.\n\nWe start with two pointers, first and last. Inside the in-order traversal function, we connect the nodes iteratively based on their in-order order. The first node encountered in the traversal will be the leftmost node, which will also be the smallest element, and the last node will be the rightmost node. After finishing the traversal, connect the first and last nodes to create a circular doubly linked list.\n\nIn each step, move the last pointer to the current node in the in-order traversal and update the previous node's right and the current node's left pointers. Continue this process until the whole tree is traversed. Finally, connect the first and last nodes to make it a circular list.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def treeToDoublyList(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n\n        first = None\n        last = None\n        \n        def inOrder(node):\n            nonlocal first, last\n            \n            if not node:\n                return\n\n            inOrder(node.left)\n\n            if last:\n                last.right = node\n                node.left = last\n            else:\n                first = node\n            \n            last = node\n\n            inOrder(node.right)\n\n        inOrder(root)\n\n        first.left = last\n        last.right = first\n\n        return first\n```\n\n    \n    The idea is to perform an in-order traversal of the given binary search tree, and while traversing, change the left and right pointers of each node to form a doubly linked list.\n\nWe start with two pointers, first and last. Inside the in-order traversal function, we connect the nodes iteratively based on their in-order order. The first node encountered in the traversal will be the leftmost node, which will also be the smallest element, and the last node will be the rightmost node. After finishing the traversal, connect the first and last nodes to create a circular doubly linked list.\n\nIn each step, move the last pointer to the current node in the in-order traversal and update the previous node's right and the current node's left pointers. Continue this process until the whole tree is traversed. Finally, connect the first and last nodes to make it a circular list.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n        left = NULL;\n        right = NULL;\n    }\n\n    Node(int _val, Node* _left, Node* _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n\nclass Solution {\npublic:\n    Node* treeToDoublyList(Node* root) {\n        if (!root) return nullptr;\n        Node *first = nullptr, *last = nullptr;\n        inorder(root, first, last);\n        first->left = last;\n        last->right = first;\n        return first;\n    }\n\n    void inorder(Node* root, Node*& first, Node*& last) {\n        if (!root) return;\n        inorder(root->left, first, last);\n\n        if (last) {\n            last->right = root;\n            root->left = last;\n        } else {\n            first = root;\n        }\n        last = root;\n\n        inorder(root->right, first, last);\n    }\n};\n```\n\n    \n    The idea is to perform an in-order traversal of the given binary search tree, and while traversing, change the left and right pointers of each node to form a doubly linked list.\n\nWe start with two pointers, first and last. Inside the in-order traversal function, we connect the nodes iteratively based on their in-order order. The first node encountered in the traversal will be the leftmost node, which will also be the smallest element, and the last node will be the rightmost node. After finishing the traversal, connect the first and last nodes to create a circular doubly linked list.\n\nIn each step, move the last pointer to the current node in the in-order traversal and update the previous node's right and the current node's left pointers. Continue this process until the whole tree is traversed. Finally, connect the first and last nodes to make it a circular list.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, left, right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nvar treeToDoublyList = function(root) {\n    if (!root) {\n        return null;\n    }\n\n    let first = null;\n    let last = null;\n\n    function inOrder(node) {\n        if (!node) {\n            return;\n        }\n\n        inOrder(node.left);\n\n        if (last) {\n            last.right = node;\n            node.left = last;\n        } else {\n            first = node;\n        }\n\n        last = node;\n\n        inOrder(node.right);\n    }\n\n    inOrder(root);\n\n    first.left = last;\n    last.right = first;\n\n    return first;\n};\n```\n\n    \n    The idea is to perform an in-order traversal of the given binary search tree, and while traversing, change the left and right pointers of each node to form a doubly linked list.\n\nWe start with two pointers, first and last. Inside the in-order traversal function, we connect the nodes iteratively based on their in-order order. The first node encountered in the traversal will be the leftmost node, which will also be the smallest element, and the last node will be the rightmost node. After finishing the traversal, connect the first and last nodes to create a circular doubly linked list.\n\nIn each step, move the last pointer to the current node in the in-order traversal and update the previous node's right and the current node's left pointers. Continue this process until the whole tree is traversed. Finally, connect the first and last nodes to make it a circular list.\n    "
    },
    {
        "id": 88,
        "title": "Serialize and Deserialize N-ary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\nFor example, you may serialize the following `3-ary` tree\n\nas `[1 [3[5 6] 2 4]]`. Note that this is just an example, you do not necessarily need to follow this format.\n\nOr you can follow LeetCode's level order traversal serialization format, where each group of children is separated by the null value.\n\nFor example, the above tree may be serialized as `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.\n\nYou do not necessarily need to follow the above-suggested formats, there are many more different formats that work so please be creative and come up with different approaches yourself.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** \\[1,null,3,2,4,null,5,6\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `0 <= Node.val <= 104`\n*   The height of the n-ary tree is less than or equal to `1000`\n*   Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]"
            },
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "[1,null,3,2,4,null,5,6]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n    \n    public Node() {\n        children = new ArrayList<>();\n    }\n    \n    public Node(int _val) {\n        val = _val;\n        children = new ArrayList<>();\n    }\n    \n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\npublic class Codec {\n\n    public String serialize(Node root) {\n        if (root == null)\n            return \"\";\n        StringBuilder sb = new StringBuilder();\n        sb.append(root.val).append(\" \");\n        for (Node child: root.children) {\n            sb.append(serialize(child));\n        }\n        sb.append(\"# \");\n        return sb.toString();\n    }\n\n    public Node deserialize(String data) {\n        return deserialize(new Scanner(data));\n    }\n\n    private Node deserialize(Scanner scanner) {\n        if (!scanner.hasNext()) {\n            return null;\n        }\n        String val = scanner.next();\n        if (val.equals(\"#\")) {\n            return null;\n        }\n        Node node = new Node(Integer.parseInt(val));\n        while (true) {\n            Node child = deserialize(scanner);\n            if (child == null) {\n                break;\n            }\n            node.children.add(child);\n        }\n        return node;\n    }\n}\n```\n    \n    1. To serialize, perform a pre-order traversal of the tree, and store the node value followed by a space, form the string step by step.\n2. Append '#' followed by a space for indicating end of each internal node.\n3. To deserialize, split the serialized string into tokens, and create an iterator.\n4. Call the recursive deserialize helper function with the iterator as the argument.\n5. In deserialize helper function, keep track of children and separate them from parent nodes by checking for the end-of-node indicator '#'.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\nclass Codec:\n    def serialize(self, root):\n        if root is None:\n            return \"\"\n        \n        data = str(root.val) + \" \"\n        for child in root.children:\n            data += self.serialize(child)\n        data += \"# \"\n        return data\n\n    def deserialize(self, data):\n        def dfs(iter_data):\n            val = next(iter_data)\n            if val == \"#\":\n                return None\n            \n            node = Node(int(val))\n            while True:\n                child = dfs(iter_data)\n                if child is None:\n                    break\n                node.children.append(child)\n            return node\n\n        return dfs(iter(data.split()))\n\n```\n    \n    1. To serialize, perform a pre-order traversal of the tree, and store the node value followed by a space, form the string step by step.\n2. Append '#' followed by a space for indicating end of each internal node.\n3. To deserialize, split the serialized string into tokens, and create an iterator.\n4. Call the recursive deserialize helper function with the iterator as the argument.\n5. In deserialize helper function, keep track of children and separate them from parent nodes by checking for the end-of-node indicator '#'.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Codec {\npublic:\n\n    string serialize(Node* root) {\n        if (!root) return \"\";\n        string data = to_string(root->val) + \" \";\n        for (Node* child : root->children) {\n            data += serialize(child);\n        }\n        data += \"# \";\n        return data;\n    }\n\n    Node* deserialize(string data) {\n        istringstream iss(data);\n        return deserialize(iss);\n    }\n\nprivate:\n    Node* deserialize(istringstream& iss) {\n        string val;\n        iss >> val;\n        if (val == \"#\") return nullptr;\n        Node* node = new Node(stoi(val));\n        while (true) {\n            Node* child = deserialize(iss);\n            if (!child) break;\n            node->children.push_back(child);\n        }\n        return node;\n    }\n};\n```\n    \n    1. To serialize, perform a pre-order traversal of the tree, and store the node value followed by a space, form the string step by step.\n2. Append '#' followed by a space for indicating end of each internal node.\n3. To deserialize, split the serialized string into tokens, and create an iterator.\n4. Call the recursive deserialize helper function with the iterator as the argument.\n5. In deserialize helper function, keep track of children and separate them from parent nodes by checking for the end-of-node indicator '#'.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, children = []) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\nclass Codec {\n    serialize(root) {\n        if (!root) return \"\";\n        let data = root.val + \" \";\n        for (const child of root.children) {\n            data += this.serialize(child);\n        }\n        data += \"# \";\n        return data;\n    }\n\n    deserialize(data) {\n        const tokens = data.split(\" \");\n        tokens.pop();\n        const iter = tokens[Symbol.iterator]();\n        return this.deserializeHelper(iter);\n    }\n\n    deserializeHelper(iter) {\n        const token = iter.next().value;\n        if (token === \"#\") return null;\n        const node = new Node(parseInt(token));\n        while (true) {\n            const child = this.deserializeHelper(iter);\n            if (child === null) break;\n            node.children.push(child);\n        }\n        return node;\n    }\n}\n\n```\n    \n    1. To serialize, perform a pre-order traversal of the tree, and store the node value followed by a space, form the string step by step.\n2. Append '#' followed by a space for indicating end of each internal node.\n3. To deserialize, split the serialized string into tokens, and create an iterator.\n4. Call the recursive deserialize helper function with the iterator as the argument.\n5. In deserialize helper function, keep track of children and separate them from parent nodes by checking for the end-of-node indicator '#'.\n    "
    },
    {
        "id": 89,
        "title": "Encode N-ary Tree to Binary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.\n\n_Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See following example)._\n\nFor example, you may encode the following `3-ary` tree to a binary tree in this way:\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n\nNote that the above is just an example which _might or might not_ work. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** \\[1,null,3,2,4,null,5,6\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `0 <= Node.val <= 104`\n*   The height of the n-ary tree is less than or equal to `1000`\n*   Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "[1,null,3,2,4,null,5,6]"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nclass NaryTreeNode {\n    int val;\n    List<NaryTreeNode> children;\n}\n\nclass BinaryTreeNode {\n    int val;\n    BinaryTreeNode left, right;\n}\n\npublic BinaryTreeNode encode(NaryTreeNode root) {\n    if (root == null) return null;\n    BinaryTreeNode binaryRoot = new BinaryTreeNode();\n    binaryRoot.val = root.val;\n    if (root.children.size() > 0)\n        binaryRoot.left = encode(root.children.get(0));\n    BinaryTreeNode sibling = binaryRoot.left;\n    for (int i = 1; i < root.children.size(); ++i) {\n        sibling.right = encode(root.children.get(i));\n        sibling = sibling.right;\n    }\n    return binaryRoot;\n}\n\npublic NaryTreeNode decode(BinaryTreeNode root) {\n    if (root == null) return null;\n    NaryTreeNode naryRoot = new NaryTreeNode();\n    naryRoot.val = root.val;\n    naryRoot.children = new ArrayList<>();\n    BinaryTreeNode sibling = root.left;\n    while (sibling != null) {\n        naryRoot.children.add(decode(sibling));\n        sibling = sibling.right;\n    }\n    return naryRoot;\n}\n```\n    \n    To encode the given N-ary tree into a binary tree recursively, we perform the following steps:\n\n1. For each node of the N-ary tree, create a corresponding binary tree node with the same value.\n2. Store the first child of the N-ary tree node as the left child of the binary tree node.\n3. Iterate through the remaining children in the N-ary tree node, placing each child to the right of the first child of the binary tree node. In other words, we represent the siblings of the N-ary tree as the right children in the binary tree.\n4. We repeat this process until every node in the given N-ary tree has been processed.\n\nFor decoding the binary tree back to N-ary tree, we reverse the process followed for encoding. While traversing the binary tree, we create a new N-ary tree node with the same value, retrieve its children from the left child and its subsequent right children of the binary tree node.\n\nNote, in both cases, we recursively perform the process for every node in the original tree.\n\nThe above algorithms are shown in C++, Java, Python, and JavaScript.\n    ",
        "python": "\n    ```python\nclass NaryTreeNode:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\nclass BinaryTreeNode:\n    def __init__(self, val=None, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef encode(root: NaryTreeNode) -> BinaryTreeNode:\n    if not root:\n        return None\n    binary_root = BinaryTreeNode(root.val)\n    if root.children:\n        binary_root.left = encode(root.children[0])\n    sibling = binary_root.left\n    for child in root.children[1:]:\n        sibling.right = encode(child)\n        sibling = sibling.right\n    return binary_root\n\ndef decode(root: BinaryTreeNode) -> NaryTreeNode:\n    if not root:\n        return None\n    nary_root = NaryTreeNode(root.val)\n    sibling = root.left\n    while sibling:\n        nary_root.children.append(decode(sibling))\n        sibling = sibling.right\n    return nary_root\n```\n    \n    To encode the given N-ary tree into a binary tree recursively, we perform the following steps:\n\n1. For each node of the N-ary tree, create a corresponding binary tree node with the same value.\n2. Store the first child of the N-ary tree node as the left child of the binary tree node.\n3. Iterate through the remaining children in the N-ary tree node, placing each child to the right of the first child of the binary tree node. In other words, we represent the siblings of the N-ary tree as the right children in the binary tree.\n4. We repeat this process until every node in the given N-ary tree has been processed.\n\nFor decoding the binary tree back to N-ary tree, we reverse the process followed for encoding. While traversing the binary tree, we create a new N-ary tree node with the same value, retrieve its children from the left child and its subsequent right children of the binary tree node.\n\nNote, in both cases, we recursively perform the process for every node in the original tree.\n\nThe above algorithms are shown in C++, Java, Python, and JavaScript.\n    ",
        "c++": "\n    ```cpp\nstruct NaryTreeNode {\n    int val;\n    vector<NaryTreeNode*> children;\n};\n\nstruct BinaryTreeNode {\n    int val;\n    BinaryTreeNode *left, *right;\n};\n\nBinaryTreeNode* encode(NaryTreeNode* root) {\n    if (!root) return nullptr;\n    BinaryTreeNode* binaryRoot = new BinaryTreeNode();\n    binaryRoot->val = root->val;\n    if (root->children.size() > 0)\n        binaryRoot->left = encode(root->children[0]);\n    BinaryTreeNode* sibling = binaryRoot->left;\n    for (int i = 1; i < root->children.size(); ++i) {\n        sibling->right = encode(root->children[i]);\n        sibling = sibling->right;\n    }\n    return binaryRoot;\n}\n\nNaryTreeNode* decode(BinaryTreeNode* root) {\n    if (!root) return nullptr;\n    NaryTreeNode* naryRoot = new NaryTreeNode();\n    naryRoot->val = root->val;\n    BinaryTreeNode* sibling = root->left;\n    while (sibling) {\n        naryRoot->children.push_back(decode(sibling));\n        sibling = sibling->right;\n    }\n    return naryRoot;\n}\n```\n    \n    To encode the given N-ary tree into a binary tree recursively, we perform the following steps:\n\n1. For each node of the N-ary tree, create a corresponding binary tree node with the same value.\n2. Store the first child of the N-ary tree node as the left child of the binary tree node.\n3. Iterate through the remaining children in the N-ary tree node, placing each child to the right of the first child of the binary tree node. In other words, we represent the siblings of the N-ary tree as the right children in the binary tree.\n4. We repeat this process until every node in the given N-ary tree has been processed.\n\nFor decoding the binary tree back to N-ary tree, we reverse the process followed for encoding. While traversing the binary tree, we create a new N-ary tree node with the same value, retrieve its children from the left child and its subsequent right children of the binary tree node.\n\nNote, in both cases, we recursively perform the process for every node in the original tree.\n\nThe above algorithms are shown in C++, Java, Python, and JavaScript.\n    ",
        "js": "\n    ```javascript\nclass NaryTreeNode {\n    constructor(val = 0, children = []) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\nclass BinaryTreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction encode(root) {\n    if (!root) return null;\n    const binaryRoot = new BinaryTreeNode(root.val);\n    if (root.children.length > 0) {\n        binaryRoot.left = encode(root.children[0]);\n    }\n    let sibling = binaryRoot.left;\n    for (let i = 1; i < root.children.length; ++i) {\n        sibling.right = encode(root.children[i]);\n        sibling = sibling.right;\n    }\n    return binaryRoot;\n}\n\nfunction decode(root) {\n    if (!root) return null;\n    const naryRoot = new NaryTreeNode(root.val);\n    let sibling = root.left;\n    while (sibling) {\n        naryRoot.children.push(decode(sibling));\n        sibling = sibling.right;\n    }\n    return naryRoot;\n}\n```\n    \n    To encode the given N-ary tree into a binary tree recursively, we perform the following steps:\n\n1. For each node of the N-ary tree, create a corresponding binary tree node with the same value.\n2. Store the first child of the N-ary tree node as the left child of the binary tree node.\n3. Iterate through the remaining children in the N-ary tree node, placing each child to the right of the first child of the binary tree node. In other words, we represent the siblings of the N-ary tree as the right children in the binary tree.\n4. We repeat this process until every node in the given N-ary tree has been processed.\n\nFor decoding the binary tree back to N-ary tree, we reverse the process followed for encoding. While traversing the binary tree, we create a new N-ary tree node with the same value, retrieve its children from the left child and its subsequent right children of the binary tree node.\n\nNote, in both cases, we recursively perform the process for every node in the original tree.\n\nThe above algorithms are shown in C++, Java, Python, and JavaScript.\n    "
    },
    {
        "id": 90,
        "title": "All O`one Data Structure",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.\n\nImplement the `AllOne` class:\n\n*   `AllOne()` Initializes the object of the data structure.\n*   `inc(String key)` Increments the count of the string `key` by `1`. If `key` does not exist in the data structure, insert it with count `1`.\n*   `dec(String key)` Decrements the count of the string `key` by `1`. If the count of `key` is `0` after the decrement, remove it from the data structure. It is guaranteed that `key` exists in the data structure before the decrement.\n*   `getMaxKey()` Returns one of the keys with the maximal count. If no element exists, return an empty string `\" \"`.\n*   `getMinKey()` Returns one of the keys with the minimum count. If no element exists, return an empty string `\" \"`.\n\n**Note** that each function must run in `O(1)` average time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"AllOne \",  \"inc \",  \"inc \",  \"getMaxKey \",  \"getMinKey \",  \"inc \",  \"getMaxKey \",  \"getMinKey \"\\]\n\\[\\[\\], \\[ \"hello \"\\], \\[ \"hello \"\\], \\[\\], \\[\\], \\[ \"leet \"\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null,  \"hello \",  \"hello \", null,  \"hello \",  \"leet \"\\]\n\n**Explanation**\nAllOne allOne = new AllOne();\nallOne.inc( \"hello \");\nallOne.inc( \"hello \");\nallOne.getMaxKey(); // return  \"hello \"\nallOne.getMinKey(); // return  \"hello \"\nallOne.inc( \"leet \");\nallOne.getMaxKey(); // return  \"hello \"\nallOne.getMinKey(); // return  \"leet \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= key.length <= 10`\n*   `key` consists of lowercase English letters.\n*   It is guaranteed that for each call to `dec`, `key` is existing in the data structure.\n*   At most `5 * 104` calls will be made to `inc`, `dec`, `getMaxKey`, and `getMinKey`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],]]",
                "output": "**Output**\n[null,null,null,\"hello\",\"hello\",null,\"hello\",\"leet\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class AllOne {\n    private HashMap<String, Integer> data;\n    \n    public AllOne() {\n        data = new HashMap<String, Integer>();\n    }\n    \n    public void inc(String key) {\n        data.put(key, data.getOrDefault(key, 0) + 1);\n    }\n    \n    public void dec(String key) {\n        data.put(key, data.getOrDefault(key, 0) - 1);\n        if (data.get(key) == 0) {\n            data.remove(key);\n        }\n    }\n    \n    public String getMaxKey() {\n        if (data.isEmpty()) return \"\";\n        return Collections.max(data.entrySet(), Map.Entry.comparingByValue()).getKey();\n    }\n    \n    public String getMinKey() {\n        if (data.isEmpty()) return \"\";\n        return Collections.min(data.entrySet(), Map.Entry.comparingByValue()).getKey();\n    }\n}\n```\n\n    \n    - The algorithm stores the count of strings in a hash map/dictionary, where the keys are the strings and the values are the counts.\n- For `inc` function, increment the corresponding count for the given string in the data structure using its key.\n- For `dec` function, decrement the corresponding count for the given string if it exists in the data structure, and if the count becomes 0, remove the key-value pair from the data structure.\n- For `getMaxKey` function, find the key with the highest count value in the key-value pairs.\n- For `getMinKey` function, find the key with the lowest count value in the key-value pairs.\n\nNote that each language has its specific ways to implement each of these operations, taking advantage of their specific features (e.g., lambdas in C++, or list comprehensions in Python).\n    ",
        "python": "\n    ```python\nclass AllOne:\n    def __init__(self):\n        self.data = dict()\n\n    def inc(self, key: str) -> None:\n        self.data[key] = self.data.get(key, 0) + 1\n\n    def dec(self, key: str) -> None:\n        self.data[key] = self.data.get(key, 0) - 1\n        if self.data[key] == 0:\n            del self.data[key]\n\n    def getMaxKey(self) -> str:\n        if not self.data:\n            return \"\"\n        return max(self.data, key=lambda x: self.data[x])\n\n    def getMinKey(self) -> str:\n        if not self.data:\n            return \"\"\n        return min(self.data, key=lambda x: self.data[x])\n```\n\n    \n    - The algorithm stores the count of strings in a hash map/dictionary, where the keys are the strings and the values are the counts.\n- For `inc` function, increment the corresponding count for the given string in the data structure using its key.\n- For `dec` function, decrement the corresponding count for the given string if it exists in the data structure, and if the count becomes 0, remove the key-value pair from the data structure.\n- For `getMaxKey` function, find the key with the highest count value in the key-value pairs.\n- For `getMinKey` function, find the key with the lowest count value in the key-value pairs.\n\nNote that each language has its specific ways to implement each of these operations, taking advantage of their specific features (e.g., lambdas in C++, or list comprehensions in Python).\n    ",
        "c++": "\n    ```cpp\nclass AllOne {\npublic:\n    unordered_map<string, int> data;\n    void inc(string key) {\n        data[key]++;\n    }\n    void dec(string key) {\n        if (data[key] > 0) data[key]--;\n        if (data[key] == 0) data.erase(key);\n    }\n    string getMaxKey() {\n        if (data.empty()) return \"\";\n        return max_element(data.begin(), data.end(),\n            [](const auto& a, const auto& b) { return a.second < b.second; })->first;\n    }\n    string getMinKey() {\n        if (data.empty()) return \"\";\n        return min_element(data.begin(), data.end(),\n            [](const auto& a, const auto& b) { return a.second < b.second; })->first;\n    }\n};\n```\n\n    \n    - The algorithm stores the count of strings in a hash map/dictionary, where the keys are the strings and the values are the counts.\n- For `inc` function, increment the corresponding count for the given string in the data structure using its key.\n- For `dec` function, decrement the corresponding count for the given string if it exists in the data structure, and if the count becomes 0, remove the key-value pair from the data structure.\n- For `getMaxKey` function, find the key with the highest count value in the key-value pairs.\n- For `getMinKey` function, find the key with the lowest count value in the key-value pairs.\n\nNote that each language has its specific ways to implement each of these operations, taking advantage of their specific features (e.g., lambdas in C++, or list comprehensions in Python).\n    ",
        "js": "\n    ```javascript\nclass AllOne {\n    constructor() {\n        this.data = new Map();\n    }\n\n    inc(key) {\n        this.data.set(key, (this.data.get(key) || 0) + 1);\n    }\n\n    dec(key) {\n        if (this.data.has(key)) {\n            if (this.data.get(key) === 1) {\n                this.data.delete(key);\n            } else {\n                this.data.set(key, this.data.get(key) - 1);\n            }\n        }\n    }\n\n    getMaxKey() {\n        if (this.data.size === 0) return \"\";\n        return [...this.data.entries()].reduce((a, b) => (a[1] > b[1] ? a : b))[0];\n    }\n\n    getMinKey() {\n        if (this.data.size === 0) return \"\";\n        return [...this.data.entries()].reduce((a, b) => (a[1] < b[1] ? a : b))[0];\n    }\n}\n```\n\n    \n    - The algorithm stores the count of strings in a hash map/dictionary, where the keys are the strings and the values are the counts.\n- For `inc` function, increment the corresponding count for the given string in the data structure using its key.\n- For `dec` function, decrement the corresponding count for the given string if it exists in the data structure, and if the count becomes 0, remove the key-value pair from the data structure.\n- For `getMaxKey` function, find the key with the highest count value in the key-value pairs.\n- For `getMinKey` function, find the key with the lowest count value in the key-value pairs.\n\nNote that each language has its specific ways to implement each of these operations, taking advantage of their specific features (e.g., lambdas in C++, or list comprehensions in Python).\n    "
    },
    {
        "id": 91,
        "title": "Ternary Expression Parser",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `expression` representing arbitrarily nested ternary expressions, evaluate the expression, and return _the result of it_.\n\nYou can always assume that the given expression is valid and only contains digits, `'?'`, `':'`, `'T'`, and `'F'` where `'T'` is true and `'F'` is false. All the numbers in the expression are **one-digit** numbers (i.e., in the range `[0, 9]`).\n\nThe conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, `'T'` or `'F'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"T?2:3 \"\n**Output:**  \"2 \"\n**Explanation:** If true, then result is 2; otherwise result is 3.\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"F?1:T?4:5 \"\n**Output:**  \"4 \"\n**Explanation:** The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n \"(F ? 1 : (T ? 4 : 5)) \" -->  \"(F ? 1 : 4) \" -->  \"4 \"\nor  \"(F ? 1 : (T ? 4 : 5)) \" -->  \"(T ? 4 : 5) \" -->  \"4 \"\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"T?T?F:5:3 \"\n**Output:**  \"F \"\n**Explanation:** The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n \"(T ? (T ? F : 5) : 3) \" -->  \"(T ? F : 3) \" -->  \"F \"\n \"(T ? (T ? F : 5) : 3) \" -->  \"(T ? F : 5) \" -->  \"F \""
            ],
            "constraints": "**Constraints:**\n\n*   `5 <= expression.length <= 104`\n*   `expression` consists of digits, `'T'`, `'F'`, `'?'`, and `':'`.\n*   It is **guaranteed** that `expression` is a valid ternary expression and that each number is a **one-digit number**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"T?2:3\"",
                "output": "\"2\""
            },
            {
                "input": "\"F?1:T?4:5\"",
                "output": "\"4\""
            },
            {
                "input": "\"T?T?F:5:3\"",
                "output": "\"F\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic String parseTernary(String expression) {\n    Stack<Character> stk = new Stack<>();\n    for (int i = expression.length() - 1; i >= 0; --i) {\n        char c = expression.charAt(i);\n        if (!stk.isEmpty() && stk.peek() == '?') {\n            stk.pop(); // Pop '?'\n            char first = stk.pop();\n            stk.pop(); // Pop ':'\n            char second = stk.pop();\n            stk.push(c == 'T' ? first : second);\n        } else {\n            stk.push(c);\n        }\n    }\n    return String.valueOf(stk.peek());\n}\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "python": "\n    ```python\ndef parseTernary(expression: str) -> str:\n    stack = []\n    for c in reversed(expression):\n        if stack and stack[-1] == '?':\n            stack.pop()  # Pop '?'\n            first = stack.pop()\n            stack.pop()  # Pop ':'\n            second = stack.pop()\n            stack.append(first if c == 'T' else second)\n        else:\n            stack.append(c)\n    return stack[-1]\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string parseTernary(std::string expression) {\n    std::stack<char> stk;\n    for (int i = expression.size() - 1; i >= 0; --i) {\n        char c = expression[i];\n        if (!stk.empty() && stk.top() == '?') {\n            stk.pop(); // Pop '?'\n            char first = stk.top();\n            stk.pop();\n            stk.pop(); // Pop ':'\n            char second = stk.top();\n            stk.pop();\n            stk.push(c == 'T' ? first : second);\n        } else {\n            stk.push(c);\n        }\n    }\n    return std::string(1, stk.top());\n}\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "js": "\n    ```javascript\nfunction parseTernary(expression) {\n    const stack = [];\n    for (let i = expression.length - 1; i >= 0; i--) {\n        const c = expression[i];\n        if (stack.length && stack[stack.length - 1] === '?') {\n            stack.pop(); // Pop '?'\n            const first = stack.pop();\n            stack.pop(); // Pop ':'\n            const second = stack.pop();\n            stack.push(c === 'T' ? first : second);\n        } else {\n            stack.push(c);\n        }\n    }\n    return stack[stack.length - 1];\n}\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    "
    },
    {
        "id": 92,
        "title": "Sequence Reconstruction",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` of length `n` where `nums` is a permutation of the integers in the range `[1, n]`. You are also given a 2D integer array `sequences` where `sequences[i]` is a subsequence of `nums`.\n\nCheck if `nums` is the shortest possible and the only **supersequence**. The shortest **supersequence** is a sequence **with the shortest length** and has all `sequences[i]` as subsequences. There could be multiple valid **supersequences** for the given array `sequences`.\n\n*   For example, for `sequences = [[1,2],[1,3]]`, there are two shortest **supersequences**, `[1,2,3]` and `[1,3,2]`.\n*   While for `sequences = [[1,2],[1,3],[1,2,3]]`, the only shortest **supersequence** possible is `[1,2,3]`. `[1,2,3,4]` is a possible supersequence but not the shortest.\n\nReturn `true` _if_ `nums` _is the only shortest **supersequence** for_ `sequences`_, or_ `false` _otherwise_.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], sequences = \\[\\[1,2\\],\\[1,3\\]\\]\n**Output:** false\n**Explanation:** There are two possible supersequences: \\[1,2,3\\] and \\[1,3,2\\].\nThe sequence \\[1,2\\] is a subsequence of both: \\[**1**,**2**,3\\] and \\[**1**,3,**2**\\].\nThe sequence \\[1,3\\] is a subsequence of both: \\[**1**,2,**3**\\] and \\[**1**,**3**,2\\].\nSince nums is not the only shortest supersequence, we return false.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\], sequences = \\[\\[1,2\\]\\]\n**Output:** false\n**Explanation:** The shortest possible supersequence is \\[1,2\\].\nThe sequence \\[1,2\\] is a subsequence of it: \\[**1**,**2**\\].\nSince nums is not the shortest supersequence, we return false.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\], sequences = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** true\n**Explanation:** The shortest possible supersequence is \\[1,2,3\\].\nThe sequence \\[1,2\\] is a subsequence of it: \\[**1**,**2**,3\\].\nThe sequence \\[1,3\\] is a subsequence of it: \\[**1**,2,**3**\\].\nThe sequence \\[2,3\\] is a subsequence of it: \\[1,**2**,**3**\\].\nSince nums is the only shortest supersequence, we return true."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `nums` is a permutation of all the integers in the range `[1, n]`.\n*   `1 <= sequences.length <= 104`\n*   `1 <= sequences[i].length <= 104`\n*   `1 <= sum(sequences[i].length) <= 105`\n*   `1 <= sequences[i][j] <= n`\n*   All the arrays of `sequences` are **unique**.\n*   `sequences[i]` is a subsequence of `nums`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3],[[1,2],[1,3]]",
                "output": "false"
            },
            {
                "input": "[1,2,3],[[1,2]]",
                "output": "false"
            },
            {
                "input": "[1,2,3],[[1,2],[1,3],[2,3]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) {\n    Map<Integer, Integer> pos = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        pos.put(nums[i], i);\n    }\n\n    for (int[] seq : sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "python": "\n    ```python\ndef is_shortest_and_unique_supersequence(nums, sequences):\n    pos = {val: idx for idx, val in enumerate(nums)}\n\n    for seq in sequences:\n        if pos[seq[0]] > pos[seq[-1]]:\n            return False\n    return True\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "c++": "\n    ```cpp\nbool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) {\n    unordered_map<int, int> pos;\n    for (int i = 0; i < nums.size(); ++i) {\n        pos[nums[i]] = i;\n    }\n\n    for (const auto& seq : sequences) {\n        if (pos[seq[0]] > pos[seq.back()]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "js": "\n    ```javascript\nfunction isShortestAndUniqueSupersequence(nums, sequences) {\n    const pos = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        pos.set(nums[i], i);\n    }\n\n    for (const seq of sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    "
    },
    {
        "id": 93,
        "title": "Arithmetic Slices II - Subsequence",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of all the **arithmetic subsequences** of_ `nums`.\n\nA sequence of numbers is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1, 3, 5, 7, 9]`, `[7, 7, 7, 7]`, and `[3, -1, -5, -9]` are arithmetic sequences.\n*   For example, `[1, 1, 2, 5, 7]` is not an arithmetic sequence.\n\nA **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n*   For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`.\n\nThe test cases are generated so that the answer fits in **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,6,8,10\\]\n**Output:** 7\n**Explanation:** All arithmetic subsequence slices are:\n\\[2,4,6\\]\n\\[4,6,8\\]\n\\[6,8,10\\]\n\\[2,4,6,8\\]\n\\[4,6,8,10\\]\n\\[2,4,6,8,10\\]\n\\[2,6,10\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,7,7,7,7\\]\n**Output:** 16\n**Explanation:** Any subsequence of this array is arithmetic."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,4,6,8,10]",
                "output": "7"
            },
            {
                "input": "[7,7,7,7,7]",
                "output": "16"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "python": "\n    ```python\ndef numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) {\n    int res = 0;\n    int n = nums.size();\n    std::vector<std::unordered_map<int, int>> dp(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= INT_MIN || diff > INT_MAX) continue;\n\n            int delta = (int)diff;\n            dp[i][delta] += 1;\n\n            if (dp[j].count(delta)) {\n                res += dp[j][delta];\n                dp[i][delta] += dp[j][delta];\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "js": "\n    ```javascript\nfunction numberOfArithmeticSlices(nums) {\n    let res = 0;\n    const n = nums.length;\n    const dp = new Array(n).fill(0).map(() => new Map());\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            const diff = nums[i] - nums[j];\n            if (diff <= Number.MIN_SAFE_INTEGER || diff > Number.MAX_SAFE_INTEGER) continue;\n\n            if (!dp[i].has(diff)) {\n                dp[i].set(diff, 0);\n            }\n\n            dp[i].set(diff, dp[i].get(diff) + 1);\n\n            if (dp[j].has(diff)) {\n                res += dp[j].get(diff);\n                dp[i].set(diff, dp[i].get(diff) + dp[j].get(diff));\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    "
    },
    {
        "id": 94,
        "title": "Optimal Account Balancing",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of transactions `transactions` where `transactions[i] = [fromi, toi, amounti]` indicates that the person with `ID = fromi` gave `amounti $` to the person with `ID = toi`.\n\nReturn _the minimum number of transactions required to settle the debt_.",
            "examples": [
                "**Example 1:**\n\n**Input:** transactions = \\[\\[0,1,10\\],\\[2,0,5\\]\\]\n**Output:** 2\n**Explanation:**\nPerson #0 gave person #1 $10.\nPerson #2 gave person #0 $5.\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\n\n",
                "**Example 2:**\n\n**Input:** transactions = \\[\\[0,1,10\\],\\[1,0,1\\],\\[1,2,5\\],\\[2,0,5\\]\\]\n**Output:** 1\n**Explanation:**\nPerson #0 gave person #1 $10.\nPerson #1 gave person #0 $1.\nPerson #1 gave person #2 $5.\nPerson #2 gave person #0 $5.\nTherefore, person #1 only need to give person #0 $4, and all debt is settled."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= transactions.length <= 8`\n*   `transactions[i].length == 3`\n*   `0 <= fromi, toi < 12`\n*   `fromi != toi`\n*   `1 <= amounti <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1,10],[2,0,5]]",
                "output": "2"
            },
            {
                "input": "[[0,1,10],[1,0,1],[1,2,5],[2,0,5]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int minTransfers(int[][] transactions) {\n    Map<Integer, Integer> balances = new HashMap<>();\n    for (int[] transaction : transactions) {\n        balances.put(transaction[0], balances.getOrDefault(transaction[0], 0) - transaction[2]);\n        balances.put(transaction[1], balances.getOrDefault(transaction[1], 0) + transaction[2]);\n    }\n\n    List<Integer> debts = new ArrayList<>();\n    for (int balance : balances.values()) {\n        if (balance != 0) {\n            debts.add(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nprivate int dfs(List<Integer> debts, int start) {\n    while (start < debts.size() && debts.get(start) == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = Integer.MAX_VALUE;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts.get(start) > 0) != (debts.get(i) > 0)) {\n            debts.set(i, debts.get(i) + debts.get(start));\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts.set(i, debts.get(i) - debts.get(start));\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works by first iterating through the transactions and calculating the debt balance for each person. The debt balance maintains how much each person owes or is owed. Then, it stores the non-zero balance values in a separate list called `debts`.\n\nNext, it performs a depth-first search (DFS) to minimize the transaction counts. The DFS function iterates over each pair of debts, and if one member owes money and the other is owed money, it simulates settling the debt by adjusting the balance and calling the DFS function recursively with the updated balance. After this step, it reverts the changes to the balance and compares the minimum transactions found.\n\nThe algorithm iterates over all possible subsets of debts and returns the minimum number of transactions required to settle the debts.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef minTransfers(transactions):\n    balances = defaultdict(int)\n    for transaction in transactions:\n        balances[transaction[0]] -= transaction[2]\n        balances[transaction[1]] += transaction[2]\n\n    debts = [balance for balance in balances.values() if balance != 0]\n    return dfs(debts, 0)\n\ndef dfs(debts, start):\n    while start < len(debts) and debts[start] == 0:\n        start += 1\n    if start == len(debts):\n        return 0\n    result = float('inf')\n    for i in range(start + 1, len(debts)):\n        if (debts[start] > 0) != (debts[i] > 0):\n            debts[i] += debts[start]\n            result = min(result, 1 + dfs(debts, start + 1))\n            debts[i] -= debts[start]\n    return result\n```\n\n    \n    The algorithm works by first iterating through the transactions and calculating the debt balance for each person. The debt balance maintains how much each person owes or is owed. Then, it stores the non-zero balance values in a separate list called `debts`.\n\nNext, it performs a depth-first search (DFS) to minimize the transaction counts. The DFS function iterates over each pair of debts, and if one member owes money and the other is owed money, it simulates settling the debt by adjusting the balance and calling the DFS function recursively with the updated balance. After this step, it reverts the changes to the balance and compares the minimum transactions found.\n\nThe algorithm iterates over all possible subsets of debts and returns the minimum number of transactions required to settle the debts.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint minTransfers(std::vector<std::vector<int>>& transactions) {\n    std::unordered_map<int, int> balances;\n    for (const auto& transaction : transactions) {\n        balances[transaction[0]] -= transaction[2];\n        balances[transaction[1]] += transaction[2];\n    }\n\n    std_msgs::vector<int> debts;\n    for (const auto& balance : balances) {\n        if (balance.second != 0) {\n            debts.push_back(balance.second);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nint dfs(std::vector<int>& debts, int start) {\n    while (start < debts.size() && debts[start] == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = INT_MAX;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts[start] > 0) != (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = std::min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works by first iterating through the transactions and calculating the debt balance for each person. The debt balance maintains how much each person owes or is owed. Then, it stores the non-zero balance values in a separate list called `debts`.\n\nNext, it performs a depth-first search (DFS) to minimize the transaction counts. The DFS function iterates over each pair of debts, and if one member owes money and the other is owed money, it simulates settling the debt by adjusting the balance and calling the DFS function recursively with the updated balance. After this step, it reverts the changes to the balance and compares the minimum transactions found.\n\nThe algorithm iterates over all possible subsets of debts and returns the minimum number of transactions required to settle the debts.\n    ",
        "js": "\n    ```javascript\nfunction minTransfers(transactions) {\n    const balances = new Map();\n    for (const transaction of transactions) {\n        balances.set(transaction[0], (balances.get(transaction[0]) || 0) - transaction[2]);\n        balances.set(transaction[1], (balances.get(transaction[1]) || 0) + transaction[2]);\n    }\n\n    const debts = [];\n    for (const balance of balances.values()) {\n        if (balance !== 0) {\n            debts.push(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nfunction dfs(debts, start) {\n    while (start < debts.length && debts[start] === 0) {\n        start++;\n    }\n    if (start === debts.length) {\n        return 0;\n    }\n    let result = Infinity;\n    for (let i = start + 1; i < debts.length; ++i) {\n        if ((debts[start] > 0) !== (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works by first iterating through the transactions and calculating the debt balance for each person. The debt balance maintains how much each person owes or is owed. Then, it stores the non-zero balance values in a separate list called `debts`.\n\nNext, it performs a depth-first search (DFS) to minimize the transaction counts. The DFS function iterates over each pair of debts, and if one member owes money and the other is owed money, it simulates settling the debt by adjusting the balance and calling the DFS function recursively with the updated balance. After this step, it reverts the changes to the balance and compares the minimum transactions found.\n\nThe algorithm iterates over all possible subsets of debts and returns the minimum number of transactions required to settle the debts.\n    "
    },
    {
        "id": 95,
        "title": "Convex Polygon",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`. The points form a polygon when joined sequentially.\n\nReturn `true` if this polygon is [convex](http://en.wikipedia.org/wiki/Convex_polygon) and `false` otherwise.\n\nYou may assume the polygon formed by given points is always a [simple polygon](http://en.wikipedia.org/wiki/Simple_polygon). In other words, we ensure that exactly two edges intersect at each vertex and that edges otherwise don't intersect each other.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,5\\],\\[5,5\\],\\[5,0\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,10\\],\\[10,10\\],\\[10,0\\],\\[5,5\\]\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= points.length <= 104`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the given points are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0],[0,5],[5,5],[5,0]]",
                "output": "true"
            },
            {
                "input": "[[0,0],[0,10],[10,10],[10,0],[5,5]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isConvex(int[][] points) {\n    int n = points.length;\n    int pre = 0, cur = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        int x1 = points[(i + 1) % n][0] - points[i][0];\n        int y1 = points[(i + 1) % n][1] - points[i][1];\n        int x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0];\n        int y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1];\n        cur = x1 * y2 - x2 * y1;\n        \n        if (cur == 0)\n            continue;\n        if (cur * pre < 0)\n            return false;\n        pre = cur;\n    }\n\n    return true;\n}\n```\n    \n    We can determine if a polygon is convex by checking the z-component of the cross product between any two consecutive edges in the polygon. If the sign of this cross product remains the same for all the edges, the polygon is convex; otherwise, it is not.\n\nFirst, initialize `n` as the number of points, and `pre` and `cur` as integers to hold the cross product value. Then, loop through the points with an index `i` from 0 to `n`. Inside the loop:\n- Calculate `x1` and `y1` as the difference between the coordinates of the next point and the current point.\n- Calculate `x2` and `y2` as the difference between the coordinates of the point after the next and the next point.\n- Calculate the cross product value `cur` as `x1 * y2 - x2 * y1`.\n- If `cur` is 0, continue to the next iteration.\n- If the product of `cur` and `pre` is negative, return `false`, as the polygon is not convex.\n- Set `pre` to `cur`.\n\nAfter the loop, return `true`, as the polygon is convex.\n    ",
        "python": "\n    ```python\ndef isConvex(points):\n    n = len(points)\n    pre = cur = 0\n\n    for i in range(n):\n        x1 = points[(i + 1) % n][0] - points[i][0]\n        y1 = points[(i + 1) % n][1] - points[i][1]\n        x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0]\n        y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1]\n        cur = x1 * y2 - x2 * y1\n\n        if cur == 0:\n            continue\n        if cur * pre < 0:\n            return False\n        pre = cur\n\n    return True\n```\n    \n    We can determine if a polygon is convex by checking the z-component of the cross product between any two consecutive edges in the polygon. If the sign of this cross product remains the same for all the edges, the polygon is convex; otherwise, it is not.\n\nFirst, initialize `n` as the number of points, and `pre` and `cur` as integers to hold the cross product value. Then, loop through the points with an index `i` from 0 to `n`. Inside the loop:\n- Calculate `x1` and `y1` as the difference between the coordinates of the next point and the current point.\n- Calculate `x2` and `y2` as the difference between the coordinates of the point after the next and the next point.\n- Calculate the cross product value `cur` as `x1 * y2 - x2 * y1`.\n- If `cur` is 0, continue to the next iteration.\n- If the product of `cur` and `pre` is negative, return `false`, as the polygon is not convex.\n- Set `pre` to `cur`.\n\nAfter the loop, return `true`, as the polygon is convex.\n    ",
        "c++": "\n    ```cpp\nbool isConvex(vector<vector<int>>& points) {\n    int n = points.size();\n    int pre = 0, cur = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        int x1 = points[(i + 1) % n][0] - points[i][0];\n        int y1 = points[(i + 1) % n][1] - points[i][1];\n        int x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0];\n        int y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1];\n        cur = x1 * y2 - x2 * y1;\n        \n        if (cur == 0)\n            continue;\n        if (cur * pre < 0)\n            return false;\n        pre = cur;\n    }\n\n    return true;\n}\n```\n    \n    We can determine if a polygon is convex by checking the z-component of the cross product between any two consecutive edges in the polygon. If the sign of this cross product remains the same for all the edges, the polygon is convex; otherwise, it is not.\n\nFirst, initialize `n` as the number of points, and `pre` and `cur` as integers to hold the cross product value. Then, loop through the points with an index `i` from 0 to `n`. Inside the loop:\n- Calculate `x1` and `y1` as the difference between the coordinates of the next point and the current point.\n- Calculate `x2` and `y2` as the difference between the coordinates of the point after the next and the next point.\n- Calculate the cross product value `cur` as `x1 * y2 - x2 * y1`.\n- If `cur` is 0, continue to the next iteration.\n- If the product of `cur` and `pre` is negative, return `false`, as the polygon is not convex.\n- Set `pre` to `cur`.\n\nAfter the loop, return `true`, as the polygon is convex.\n    ",
        "js": "\n    ```javascript\nfunction isConvex(points) {\n    const n = points.length;\n    let pre = 0, cur = 0;\n\n    for (let i = 0; i < n; ++i) {\n        const x1 = points[(i + 1) % n][0] - points[i][0];\n        const y1 = points[(i + 1) % n][1] - points[i][1];\n        const x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0];\n        const y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1];\n        cur = x1 * y2 - x2 * y1;\n\n        if (cur === 0)\n            continue;\n        if (cur * pre < 0)\n            return false;\n        pre = cur;\n    }\n\n    return true;\n}\n```\n    \n    We can determine if a polygon is convex by checking the z-component of the cross product between any two consecutive edges in the polygon. If the sign of this cross product remains the same for all the edges, the polygon is convex; otherwise, it is not.\n\nFirst, initialize `n` as the number of points, and `pre` and `cur` as integers to hold the cross product value. Then, loop through the points with an index `i` from 0 to `n`. Inside the loop:\n- Calculate `x1` and `y1` as the difference between the coordinates of the next point and the current point.\n- Calculate `x2` and `y2` as the difference between the coordinates of the point after the next and the next point.\n- Calculate the cross product value `cur` as `x1 * y2 - x2 * y1`.\n- If `cur` is 0, continue to the next iteration.\n- If the product of `cur` and `pre` is negative, return `false`, as the polygon is not convex.\n- Set `pre` to `cur`.\n\nAfter the loop, return `true`, as the polygon is convex.\n    "
    },
    {
        "id": 96,
        "title": "Implement Rand10() Using Rand7()",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the **API** `rand7()` that generates a uniform random integer in the range `[1, 7]`, write a function `rand10()` that generates a uniform random integer in the range `[1, 10]`. You can only call the API `rand7()`, and you shouldn't call any other API. Please **do not** use a language's built-in random API.\n\nEach test case will have one **internal** argument `n`, the number of times that your implemented function `rand10()` will be called while testing. Note that this is **not an argument** passed to `rand10()`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** \\[2\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** \\[2,8\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 3\n**Output:** \\[3,8,10\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n\n**",
            "follow_up": "Follow up:**\n\n*   What is the [expected value](https://en.wikipedia.org/wiki/Expected_value) for the number of calls to `rand7()` function?\n*   Could you minimize the number of calls to `rand7()`?"
        },
        "tag": [],
        "example": [
            {
                "input": "1",
                "output": "[2]"
            },
            {
                "input": "2",
                "output": "[2,8]"
            },
            {
                "input": "3",
                "output": "[3,8,10]"
            }
        ],
        "java": "\n    ```java\npublic int rand7() ; // Provided API\n\npublic int rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    Here's how the algorithm works:\n\n1. Call `rand7()` two times and treat the two values as (row, column) indices in a 7x7 grid (so each value is 1 to 7). This gives us 49 possible values, forming a uniform distribution.\n\n2. We actually convert the two values `a` and `b` (from 1 to 7) into a single value, `result = (a - 1) * 7 + b`. This will give us a value between 1 and 49 (inclusive).\n\n3. If the `result` is greater than 40, we reject this value (and try again) since this is larger than what we can map to the range 1 to 10. We will use the value `result` to represent the range [1, 10] by taking the modulus of 10 and adding 1 (i.e. `result % 10 + 1`).\n\n4. This way, we ensure a uniformly random value between 1 to 10. Since some values are rejected, the expected number of calls to rand7() is 2.4 (the probability of a value being accepted is 40/49, so expected calls are 2/(40/49)).\n\n5. The number of calls to rand7() is optimized in this approach, minimizing it to 2 calls on average.\n    ",
        "python": "\n    ```python\ndef rand7():\n    pass  # Provided API\n\ndef rand10():\n    result = None\n    while True:\n        result = (rand7() - 1) * 7 + rand7()\n        if result <= 40:\n            break\n    return result % 10 + 1\n```\n    \n    Here's how the algorithm works:\n\n1. Call `rand7()` two times and treat the two values as (row, column) indices in a 7x7 grid (so each value is 1 to 7). This gives us 49 possible values, forming a uniform distribution.\n\n2. We actually convert the two values `a` and `b` (from 1 to 7) into a single value, `result = (a - 1) * 7 + b`. This will give us a value between 1 and 49 (inclusive).\n\n3. If the `result` is greater than 40, we reject this value (and try again) since this is larger than what we can map to the range 1 to 10. We will use the value `result` to represent the range [1, 10] by taking the modulus of 10 and adding 1 (i.e. `result % 10 + 1`).\n\n4. This way, we ensure a uniformly random value between 1 to 10. Since some values are rejected, the expected number of calls to rand7() is 2.4 (the probability of a value being accepted is 40/49, so expected calls are 2/(40/49)).\n\n5. The number of calls to rand7() is optimized in this approach, minimizing it to 2 calls on average.\n    ",
        "c++": "\n    ```cpp\nint rand7(); // Provided API\n\nint rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    Here's how the algorithm works:\n\n1. Call `rand7()` two times and treat the two values as (row, column) indices in a 7x7 grid (so each value is 1 to 7). This gives us 49 possible values, forming a uniform distribution.\n\n2. We actually convert the two values `a` and `b` (from 1 to 7) into a single value, `result = (a - 1) * 7 + b`. This will give us a value between 1 and 49 (inclusive).\n\n3. If the `result` is greater than 40, we reject this value (and try again) since this is larger than what we can map to the range 1 to 10. We will use the value `result` to represent the range [1, 10] by taking the modulus of 10 and adding 1 (i.e. `result % 10 + 1`).\n\n4. This way, we ensure a uniformly random value between 1 to 10. Since some values are rejected, the expected number of calls to rand7() is 2.4 (the probability of a value being accepted is 40/49, so expected calls are 2/(40/49)).\n\n5. The number of calls to rand7() is optimized in this approach, minimizing it to 2 calls on average.\n    ",
        "js": "\n    ```javascript\nfunction rand7() ; // Provided API\n\nfunction rand10() {\n    let result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    Here's how the algorithm works:\n\n1. Call `rand7()` two times and treat the two values as (row, column) indices in a 7x7 grid (so each value is 1 to 7). This gives us 49 possible values, forming a uniform distribution.\n\n2. We actually convert the two values `a` and `b` (from 1 to 7) into a single value, `result = (a - 1) * 7 + b`. This will give us a value between 1 and 49 (inclusive).\n\n3. If the `result` is greater than 40, we reject this value (and try again) since this is larger than what we can map to the range 1 to 10. We will use the value `result` to represent the range [1, 10] by taking the modulus of 10 and adding 1 (i.e. `result % 10 + 1`).\n\n4. This way, we ensure a uniformly random value between 1 to 10. Since some values are rejected, the expected number of calls to rand7() is 2.4 (the probability of a value being accepted is 40/49, so expected calls are 2/(40/49)).\n\n5. The number of calls to rand7() is optimized in this approach, minimizing it to 2 calls on average.\n    "
    },
    {
        "id": 97,
        "title": "Encode String with Shortest Length",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, encode the string such that its encoded length is the shortest.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. `k` should be a positive integer.\n\nIf an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return **any of them**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaa \"\n**Output:**  \"aaa \"\n**Explanation:** There is no way to encode it such that it is shorter than the input string, so we do not encode it.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaaaa \"\n**Output:**  \"5\\[a\\] \"\n**Explanation:**  \"5\\[a\\] \" is shorter than  \"aaaaa \" by 1 character.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aaaaaaaaaa \"\n**Output:**  \"10\\[a\\] \"\n**Explanation:**  \"a9\\[a\\] \" or  \"9\\[a\\]a \" are also valid solutions, both of them have the same length = 5, which is the same as  \"10\\[a\\] \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 150`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aaa\"",
                "output": "\"aaa\""
            },
            {
                "input": "\"aaaaa\"",
                "output": "\"5[a]\""
            },
            {
                "input": "\"aaaaaaaaaa\"",
                "output": "\"10[a]\""
            }
        ],
        "java": "\n    ```java\nString encode(String s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            String sub = s.substring(0, i);\n            StringBuilder composed = new StringBuilder();\n            for (int j = 0; j < reps; j++) {\n                composed.append(sub);\n            }\n            if (s.equals(composed.toString())) {\n                return reps + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "python": "\n    ```python\ndef encode(s: str) -> str:\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            reps = n // i\n            sub = s[:i]\n            composed = sub * reps\n            if s == composed:\n                return f\"{reps}[{sub}]\"\n    return s\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "c++": "\n    ```cpp\nstd::string encode(std::string s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            std::string sub = s.substr(0, i);\n            std::string composed = \"\";\n            for (int j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s == composed) {\n                return std::to_string(reps) + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "js": "\n    ```javascript\nfunction encode(s) {\n    const n = s.length;\n    for (let i = Math.floor(n / 2); i > 0; i--) {\n        if (n % i === 0) {\n            const reps = n / i;\n            const sub = s.slice(0, i);\n            let composed = \"\";\n            for (let j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s === composed) {\n                return `${reps}[${sub}]`;\n            }\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    "
    },
    {
        "id": 98,
        "title": "Find Permutation",
        "difficulty": "Medium",
        "content": {
            "problem": "A permutation `perm` of `n` integers of all the integers in the range `[1, n]` can be represented as a string `s` of length `n - 1` where:\n\n*   `s[i] == 'I'` if `perm[i] < perm[i + 1]`, and\n*   `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s`, reconstruct the lexicographically smallest permutation `perm` and return it.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"I \"\n**Output:** \\[1,2\\]\n**Explanation:** \\[1,2\\] is the only legal permutation that can represented by s, where the number 1 and 2 construct an increasing relationship.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"DI \"\n**Output:** \\[2,1,3\\]\n**Explanation:** Both \\[2,1,3\\] and \\[3,1,2\\] can be represented as  \"DI \", but since we want to find the smallest lexicographical permutation, you should return \\[2,1,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'I'` or `'D'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"I\"",
                "output": "[1,2]"
            },
            {
                "input": "\"DI\"",
                "output": "[2,1,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] findPermutation(String s) {\n        int[] perm = new int[s.length() + 1];\n        int left = 1;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == 'I') {\n                perm[i] = left++;\n                while(i + 1 < s.length() && s.charAt(i + 1) == 'D')\n                    i++;\n            }\n        }\n        perm[s.length()] = left++;\n        for(int i = s.length() - 1; i >= 0; i--)\n            if(s.charAt(i) == 'D')\n                perm[i] = left++;\n        return perm;\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    ",
        "python": "\n    ```python\ndef findPermutation(s: str) -> list[int]:\n    perm = [0] * (len(s) + 1)\n    left = 1\n    i = 0\n    while i < len(s):\n        if s[i] == 'I':\n            perm[i] = left\n            left += 1\n            while i + 1 < len(s) and s[i + 1] == 'D':\n                i += 1\n        i += 1\n    perm[len(s)] = left\n    left += 1\n    for i in reversed(range(len(s))):\n        if s[i] == 'D':\n            perm[i] = left\n            left += 1\n    return perm\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> findPermutation(std::string s) {\n    std::vector<int> perm(s.length() + 1);\n    int left = 1;\n    for(int i = 0; i < s.length(); i++) {\n        if(s[i] == 'I') {\n            perm[i] = left++;\n            while(i + 1 < s.length() && s[i + 1] == 'D')\n                i++;\n        }\n    }\n    perm[s.length()] = left++;\n    for(int i = s.length() - 1; i >= 0; i--)\n        if(s[i] == 'D')\n            perm[i] = left++;\n    return perm;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    ",
        "js": "\n    ```javascript\nfunction findPermutation(s) {\n    let perm = new Array(s.length + 1).fill(0);\n    let left = 1;\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === 'I') {\n            perm[i] = left++;\n            while(i + 1 < s.length && s[i + 1] === 'D')\n                i++;\n        }\n    }\n    perm[s.length] = left++;\n    for(let i = s.length - 1; i >= 0; i--)\n        if(s[i] === 'D')\n            perm[i] = left++;\n    return perm;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize an empty permutation array `perm` of length `n+1` (where `n` is the length of string `s`).\n2. Initialize a variable `left` with the value 1. This variable will keep track of the next unused smallest number.\n3. Iterate through the given string `s`. If the character at index `i` is 'I', place the value of `left` at the same index in the `perm` array and increment `left`. If there is a sequence of 'D's following current 'I', jump directly to the end of this sequence.\n4. After iterating through the whole string, assign the value of `left` to the last position of the `perm` array and increment `left`.\n5. Iterate through the string `s` in reverse order. If the character at index `i` is 'D', place the value of `left` at the same index in the `perm` array and increment `left`.\n6. At the end of the process, the filled `perm` array represents the lexicographically smallest permutation.\n\nThe time complexity of this algorithm is O(n) as it iterates through the string `s` and fills the `perm` array in linear time.\n    "
    },
    {
        "id": 99,
        "title": "Max Consecutive Ones II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array if you can flip at most one_ `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,0,1,1,0\\]\n**Output:** 4\n**Explanation:** \n- If we flip the first zero, nums becomes \\[1,1,1,1,0\\] and we have 4 consecutive ones.\n- If we flip the second zero, nums becomes \\[1,0,1,1,1\\] and we have 3 consecutive ones.\nThe max number of consecutive ones is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1,0,1\\]\n**Output:** 4\n**Explanation:** \n- If we flip the first zero, nums becomes \\[1,1,1,1,0,1\\] and we have 4 consecutive ones.\n- If we flip the second zero, nums becomes \\[1,0,1,1,1,1\\] and we have 4 consecutive ones.\nThe max number of consecutive ones is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.\n\n**",
            "follow_up": "Follow up:** What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,0,1,1,0]",
                "output": "4"
            },
            {
                "input": "[1,0,1,1,0,1]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int findMaxConsecutiveOnes(int[] nums) {\n    int maxCount = 0, countZeros = 0, left = 0;\n    for (int right = 0; right < nums.length; ++right) {\n        if (nums[right] == 0) countZeros++;\n        while (countZeros > 1) {\n            if (nums[left++] == 0) countZeros--;\n        }\n        maxCount = Math.max(maxCount, right - left + 1);\n    }\n    return maxCount;\n}\n```\n    \n    We can use the sliding window technique to solve this problem. We maintain a window, and traverse through the array from the left side to the right side. When we find a 0, we increment the count of zeros in the window. If the count of zeros is greater than 1, we remove elements from the left side of the window until we have only 1 zero in the window. This way, we make sure we calculate the maximum number of consecutive ones when a single zero is flipped.\n\nFor each window, we update the maximum consecutive ones by comparing the current window size (right - left + 1) with max_count.\n\nIn the follow-up case where the input numbers come in one by one as an infinite stream, we can still use the same sliding window technique efficiently. We don't need to store all numbers, as we only need to store the current window of numbers which has at most size N (in the worst case where all numbers are 1). The time complexity is O(N) for the entire stream of numbers.\n    ",
        "python": "\n    ```python\ndef findMaxConsecutiveOnes(nums: List[int]) -> int:\n    max_count, count_zeros, left = 0, 0, 0\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            count_zeros += 1\n        while count_zeros > 1:\n            if nums[left] == 0:\n                count_zeros -= 1\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count\n```\n    \n    We can use the sliding window technique to solve this problem. We maintain a window, and traverse through the array from the left side to the right side. When we find a 0, we increment the count of zeros in the window. If the count of zeros is greater than 1, we remove elements from the left side of the window until we have only 1 zero in the window. This way, we make sure we calculate the maximum number of consecutive ones when a single zero is flipped.\n\nFor each window, we update the maximum consecutive ones by comparing the current window size (right - left + 1) with max_count.\n\nIn the follow-up case where the input numbers come in one by one as an infinite stream, we can still use the same sliding window technique efficiently. We don't need to store all numbers, as we only need to store the current window of numbers which has at most size N (in the worst case where all numbers are 1). The time complexity is O(N) for the entire stream of numbers.\n    ",
        "c++": "\n    ```cpp\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_count = 0, count_zeros = 0, left = 0;\n    for (int right = 0; right < nums.size(); ++right) {\n        if (nums[right] == 0) count_zeros++;\n        while (count_zeros > 1) {\n            if (nums[left++] == 0) count_zeros--;\n        }\n        max_count = max(max_count, right - left + 1);\n    }\n    return max_count;\n}\n```\n    \n    We can use the sliding window technique to solve this problem. We maintain a window, and traverse through the array from the left side to the right side. When we find a 0, we increment the count of zeros in the window. If the count of zeros is greater than 1, we remove elements from the left side of the window until we have only 1 zero in the window. This way, we make sure we calculate the maximum number of consecutive ones when a single zero is flipped.\n\nFor each window, we update the maximum consecutive ones by comparing the current window size (right - left + 1) with max_count.\n\nIn the follow-up case where the input numbers come in one by one as an infinite stream, we can still use the same sliding window technique efficiently. We don't need to store all numbers, as we only need to store the current window of numbers which has at most size N (in the worst case where all numbers are 1). The time complexity is O(N) for the entire stream of numbers.\n    ",
        "js": "\n    ```javascript\nfunction findMaxConsecutiveOnes(nums) {\n    let maxCount = 0, countZeros = 0, left = 0;\n    for (let right = 0; right < nums.length; ++right) {\n        if (nums[right] === 0) countZeros++;\n        while (countZeros > 1) {\n            if (nums[left++] === 0) countZeros--;\n        }\n        maxCount = Math.max(maxCount, right - left + 1);\n    }\n    return maxCount;\n}\n```\n    \n    We can use the sliding window technique to solve this problem. We maintain a window, and traverse through the array from the left side to the right side. When we find a 0, we increment the count of zeros in the window. If the count of zeros is greater than 1, we remove elements from the left side of the window until we have only 1 zero in the window. This way, we make sure we calculate the maximum number of consecutive ones when a single zero is flipped.\n\nFor each window, we update the maximum consecutive ones by comparing the current window size (right - left + 1) with max_count.\n\nIn the follow-up case where the input numbers come in one by one as an infinite stream, we can still use the same sliding window technique efficiently. We don't need to store all numbers, as we only need to store the current window of numbers which has at most size N (in the worst case where all numbers are 1). The time complexity is O(N) for the entire stream of numbers.\n    "
    },
    {
        "id": 100,
        "title": "Robot Room Cleaner",
        "difficulty": "Hard",
        "content": {
            "problem": "You are controlling a robot that is located somewhere in a room. The room is modeled as an `m x n` binary grid where `0` represents a wall and `1` represents an empty slot.\n\nThe robot starts at an unknown location in the room that is guaranteed to be empty, and you do not have access to the grid, but you can move the robot using the given API `Robot`.\n\nYou are tasked to use the robot to clean the entire room (i.e., clean every empty cell in the room). The robot with the four given APIs can move forward, turn left, or turn right. Each turn is `90` degrees.\n\nWhen the robot tries to move into a wall cell, its bumper sensor detects the obstacle, and it stays on the current cell.\n\nDesign an algorithm to clean the entire room using the following APIs:\n\ninterface Robot {\n  // returns true if next cell is open and robot moves into the cell.\n  // returns false if next cell is obstacle and robot stays on the current cell.\n  boolean move();\n\n  // Robot will stay on the same cell after calling turnLeft/turnRight.\n  // Each turn will be 90 degrees.\n  void turnLeft();\n  void turnRight();\n\n  // Clean the current cell.\n  void clean();\n}\n\n**Note** that the initial direction of the robot will be facing up. You can assume all four edges of the grid are all surrounded by a wall.\n\n**Custom testing:**\n\nThe input is only given to initialize the room and the robot's position internally. You must solve this problem \"blindfolded \". In other words, you must control the robot using only the four mentioned APIs without knowing the room layout and the initial robot's position.",
            "examples": [
                "**Example 1:**\n\n**Input:** room = \\[\\[1,1,1,1,1,0,1,1\\],\\[1,1,1,1,1,0,1,1\\],\\[1,0,1,1,1,1,1,1\\],\\[0,0,0,1,0,0,0,0\\],\\[1,1,1,1,1,1,1,1\\]\\], row = 1, col = 3\n**Output:** Robot cleaned all rooms.\n**Explanation:** All grids in the room are marked by either 0 or 1.\n0 means the cell is blocked, while 1 means the cell is accessible.\nThe robot initially starts at the position of row=1, col=3.\nFrom the top left corner, its position is one row below and three columns right.\n\n",
                "**Example 2:**\n\n**Input:** room = \\[\\[1\\]\\], row = 0, col = 0\n**Output:** Robot cleaned all rooms."
            ],
            "constraints": "**Constraints:**\n\n*   `m == room.length`\n*   `n == room[i].length`\n*   `1 <= m <= 100`\n*   `1 <= n <= 200`\n*   `room[i][j]` is either `0` or `1`.\n*   `0 <= row < m`\n*   `0 <= col < n`\n*   `room[row][col] == 1`\n*   All the empty cells can be visited from the starting position.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1],[1,0,1,1,1,1,1,1],[0,0,0,1,0,0,0,0],[1,1,1,1,1,1,1,1]],1,3",
                "output": "Robotcleanedallrooms."
            },
            {
                "input": "[[1]],0,0",
                "output": "Robotcleanedallrooms."
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    private int comb(int n, int r) {\n        if(r > n - r) r = n - r;\n        long res = 1;\n        for(int i = 1; i <= r; i++) {\n            res *= n - r + i;\n            res /= i;\n        }\n        return (int)res;\n    }\n\n    public String kthSmallestPath(int[] destination, int k) {\n        int row = destination[0];\n        int col = destination[1];\n        StringBuilder ans = new StringBuilder();\n\n        for(int i = 0; i < row + col; i++) {\n            if(row == 0) {\n                ans.append('H');\n                col--;\n            } else if(col == 0) {\n                ans.append('V');\n                row--;\n            } else if(k <= comb(row + col - 1, row - 1)) {\n                ans.append('H');\n                col--;\n            } else {\n                ans.append('V');\n                k -= comb(row + col - 1, row - 1);\n                row--;\n            }\n        }\n\n        return ans.toString();\n    }\n}\n```\n\n    \n    The algorithm starts at the given location and loops through all possible paths until it reaches the destination cell, by only taking a right or down step. At each step, it compares the current path with lexicographically smaller path, and proceeds in either of the directions based on check conditions. In order to get the kth lexicographically smallest instruction, we use mathematical combination method to check if taking the horizontal step satisfies the condition or not. If it does, we take the horizontal step; otherwise, we take the vertical step.\n\nThe time complexity of this algorithm is O(row + col), where row and col are the coordinates of the destination cell, because we need to go through entire cells in row and column.\n    ",
        "python": "\n    ```python\nfrom math import comb\n\ndef kthSmallestPath(destination, k):\n    row, col = destination\n    ans = \"\"\n\n    for i in range(row + col):\n        if row == 0:\n            ans += 'H'\n            col -= 1\n        elif col == 0:\n            ans += 'V'\n            row -= 1\n        elif k <= comb(row + col - 1, row - 1):\n            ans += 'H'\n            col -= 1\n        else:\n            ans += 'V'\n            k -= comb(row + col - 1, row - 1)\n            row -= 1\n\n    return ans\n```\n\n    \n    The algorithm starts at the given location and loops through all possible paths until it reaches the destination cell, by only taking a right or down step. At each step, it compares the current path with lexicographically smaller path, and proceeds in either of the directions based on check conditions. In order to get the kth lexicographically smallest instruction, we use mathematical combination method to check if taking the horizontal step satisfies the condition or not. If it does, we take the horizontal step; otherwise, we take the vertical step.\n\nThe time complexity of this algorithm is O(row + col), where row and col are the coordinates of the destination cell, because we need to go through entire cells in row and column.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint comb(int n, int r) {\n    if(r > n - r) r = n - r;\n    long res = 1;\n    for(int i = 1; i <= r; i++) {\n        res *= n - r + i;\n        res /= i;\n    }\n    return (int)res;\n}\n\nstd::string kthSmallestPath(std::vector<int>& destination, int k) {\n    int row = destination[0];\n    int col = destination[1];\n    std::string ans;\n\n    for(int i = 0; i < row + col; i++) {\n        if(row == 0) {\n            ans += 'H';\n            col--;\n        } else if(col == 0) {\n            ans += 'V';\n            row--;\n        } else if(k <= comb(row + col - 1, row - 1)) {\n            ans += 'H';\n            col--;\n        } else {\n            ans += 'V';\n            k -= comb(row + col - 1, row - 1);\n            row--;\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm starts at the given location and loops through all possible paths until it reaches the destination cell, by only taking a right or down step. At each step, it compares the current path with lexicographically smaller path, and proceeds in either of the directions based on check conditions. In order to get the kth lexicographically smallest instruction, we use mathematical combination method to check if taking the horizontal step satisfies the condition or not. If it does, we take the horizontal step; otherwise, we take the vertical step.\n\nThe time complexity of this algorithm is O(row + col), where row and col are the coordinates of the destination cell, because we need to go through entire cells in row and column.\n    ",
        "js": "\n    ```javascript\nfunction comb(n, r) {\n    if(r > n - r) r = n - r;\n    let res = 1;\n    for(let i = 1; i <= r; i++) {\n        res *= n - r + i;\n        res /= i;\n    }\n    return res;\n}\n\nfunction kthSmallestPath(destination, k) {\n    let row = destination[0];\n    let col = destination[1];\n    let ans = \"\";\n\n    for(let i = 0; i < row + col; i++) {\n        if(row === 0) {\n            ans += 'H';\n            col--;\n        } else if(col === 0) {\n            ans += 'V';\n            row--;\n        } else if(k <= comb(row + col - 1, row - 1)) {\n            ans += 'H';\n            col--;\n        } else {\n            ans += 'V';\n            k -= comb(row + col - 1, row - 1);\n            row--;\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm starts at the given location and loops through all possible paths until it reaches the destination cell, by only taking a right or down step. At each step, it compares the current path with lexicographically smaller path, and proceeds in either of the directions based on check conditions. In order to get the kth lexicographically smallest instruction, we use mathematical combination method to check if taking the horizontal step satisfies the condition or not. If it does, we take the horizontal step; otherwise, we take the vertical step.\n\nThe time complexity of this algorithm is O(row + col), where row and col are the coordinates of the destination cell, because we need to go through entire cells in row and column.\n    "
    },
    {
        "id": 101,
        "title": "The Maze",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the `m x n` `maze`, the ball's `start` position and the `destination`, where `start = [startrow, startcol]` and `destination = [destinationrow, destinationcol]`, return `true` if the ball can stop at the destination, otherwise return `false`.\n\nYou may assume that **the borders of the maze are all walls** (see examples).",
            "examples": [
                "**Example 1:**\n\n**Input:** maze = \\[\\[0,0,1,0,0\\],\\[0,0,0,0,0\\],\\[0,0,0,1,0\\],\\[1,1,0,1,1\\],\\[0,0,0,0,0\\]\\], start = \\[0,4\\], destination = \\[4,4\\]\n**Output:** true\n**Explanation:** One possible way is : left -> down -> left -> down -> right -> down -> right.\n\n",
                "**Example 2:**\n\n**Input:** maze = \\[\\[0,0,1,0,0\\],\\[0,0,0,0,0\\],\\[0,0,0,1,0\\],\\[1,1,0,1,1\\],\\[0,0,0,0,0\\]\\], start = \\[0,4\\], destination = \\[3,2\\]\n**Output:** false\n**Explanation:** There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.\n\n",
                "**Example 3:**\n\n**Input:** maze = \\[\\[0,0,0,0,0\\],\\[1,1,0,0,1\\],\\[0,0,0,0,0\\],\\[0,1,0,0,1\\],\\[0,1,0,0,0\\]\\], start = \\[4,3\\], destination = \\[0,1\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `m == maze.length`\n*   `n == maze[i].length`\n*   `1 <= m, n <= 100`\n*   `maze[i][j]` is `0` or `1`.\n*   `start.length == 2`\n*   `destination.length == 2`\n*   `0 <= startrow, destinationrow <= m`\n*   `0 <= startcol, destinationcol <= n`\n*   Both the ball and the destination exist in an empty space, and they will not be in the same position initially.\n*   The maze contains **at least 2 empty spaces**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]],[0,4],[4,4]",
                "output": "true"
            },
            {
                "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]],[0,4],[3,2]",
                "output": "false"
            },
            {
                "input": "[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]],[4,3],[0,1]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean hasPath(int[][] maze, int[] start, int[] destination) {\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    Queue<int[]> q = new LinkedList<>();\n    q.add(start);\n    while (!q.isEmpty()) {\n        int[] curr = q.poll();\n        int x = curr[0], y = curr[1];\n        if (x == destination[0] && y == destination[1]) return true;\n        for (int[] dir : dirs) {\n            int i = x, j = y;\n            while (i + dir[0] >= 0 && i + dir[0] < maze.length && j + dir[1] >= 0 && j + dir[1] < maze[0].length && maze[i + dir[0]][j + dir[1]] == 0) {\n                i += dir[0];\n                j += dir[1];\n            }\n            if (maze[i][j] == 0) {\n                maze[i][j] = 1;\n                q.add(new int[]{i, j});\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The given problem can be solved using Breadth First Search (BFS). We start from the starting point, and at each step, we keep rolling in all possible directions (up, down, left, and right) till we hit a wall. We then add the final point (before hitting the wall) of each direction to the queue if it has not been visited before. If the destination is encountered while rolling, we return True. If the queue becomes empty, that means we have exhausted all possible rollings, and thus return False. In each language (C++, Java, Python, and JavaScript), we implement this BFS algorithm using the same logic inside a while loop, keeping track of the visited positions in the maze matrix itself by marking them as 1.\n    ",
        "python": "\n    ```python\ndef hasPath(maze, start, destination):\n    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    q = [start]\n    while q:\n        x, y = q.pop(0)\n        if x == destination[0] and y == destination[1]:\n            return True\n        for dx, dy in dirs:\n            i, j = x, y\n            while 0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and maze[i + dx][j + dy] == 0:\n                i += dx\n                j += dy\n            if maze[i][j] == 0:\n                maze[i][j] = 1\n                q.append((i, j))\n    return False\n```\n    \n    The given problem can be solved using Breadth First Search (BFS). We start from the starting point, and at each step, we keep rolling in all possible directions (up, down, left, and right) till we hit a wall. We then add the final point (before hitting the wall) of each direction to the queue if it has not been visited before. If the destination is encountered while rolling, we return True. If the queue becomes empty, that means we have exhausted all possible rollings, and thus return False. In each language (C++, Java, Python, and JavaScript), we implement this BFS algorithm using the same logic inside a while loop, keeping track of the visited positions in the maze matrix itself by marking them as 1.\n    ",
        "c++": "\n    ```cpp\nbool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {\n    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    queue<pair<int, int>> q;\n    q.push({start[0], start[1]});\n    while (!q.empty()) {\n        auto [x, y] = q.front(); q.pop();\n        if (x == destination[0] && y == destination[1]) return true;\n        for (auto [dx, dy] : dirs) {\n            int i = x, j = y;\n            while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 && j + dy < maze[0].size() && maze[i + dx][j + dy] == 0) {\n                i += dx, j += dy;\n            }\n            if (maze[i][j] == 0) {\n                maze[i][j] = 1;\n                q.push({i, j});\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The given problem can be solved using Breadth First Search (BFS). We start from the starting point, and at each step, we keep rolling in all possible directions (up, down, left, and right) till we hit a wall. We then add the final point (before hitting the wall) of each direction to the queue if it has not been visited before. If the destination is encountered while rolling, we return True. If the queue becomes empty, that means we have exhausted all possible rollings, and thus return False. In each language (C++, Java, Python, and JavaScript), we implement this BFS algorithm using the same logic inside a while loop, keeping track of the visited positions in the maze matrix itself by marking them as 1.\n    ",
        "js": "\n    ```javascript\nfunction hasPath(maze, start, destination) {\n    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    const q = [start];\n    while (q.length > 0) {\n        const [x, y] = q.shift();\n        if (x === destination[0] && y === destination[1]) return true;\n        for (const [dx, dy] of dirs) {\n            let i = x, j = y;\n            while (i + dx >= 0 && i + dx < maze.length && j + dy >= 0 && j + dy < maze[0].length && maze[i + dx][j + dy] === 0) {\n                i += dx;\n                j += dy;\n            }\n            if (maze[i][j] === 0) {\n                maze[i][j] = 1;\n                q.push([i, j]);\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The given problem can be solved using Breadth First Search (BFS). We start from the starting point, and at each step, we keep rolling in all possible directions (up, down, left, and right) till we hit a wall. We then add the final point (before hitting the wall) of each direction to the queue if it has not been visited before. If the destination is encountered while rolling, we return True. If the queue becomes empty, that means we have exhausted all possible rollings, and thus return False. In each language (C++, Java, Python, and JavaScript), we implement this BFS algorithm using the same logic inside a while loop, keeping track of the visited positions in the maze matrix itself by marking them as 1.\n    "
    },
    {
        "id": 102,
        "title": "The Maze III",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.\n\nGiven the `m x n` `maze`, the ball's position `ball` and the hole's position `hole`, where `ball = [ballrow, ballcol]` and `hole = [holerow, holecol]`, return _a string_ `instructions` _of all the instructions that the ball should follow to drop in the hole with the **shortest distance** possible_. If there are multiple valid instructions, return the **lexicographically minimum** one. If the ball can't drop in the hole, return `\"impossible \"`.\n\nIf there is a way for the ball to drop in the hole, the answer `instructions` should contain the characters `'u'` (i.e., up), `'d'` (i.e., down), `'l'` (i.e., left), and `'r'` (i.e., right).\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\nYou may assume that **the borders of the maze are all walls** (see examples).",
            "examples": [
                "**Example 1:**\n\n**Input:** maze = \\[\\[0,0,0,0,0\\],\\[1,1,0,0,1\\],\\[0,0,0,0,0\\],\\[0,1,0,0,1\\],\\[0,1,0,0,0\\]\\], ball = \\[4,3\\], hole = \\[0,1\\]\n**Output:**  \"lul \"\n**Explanation:** There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by  \"lul \".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is  \"lul \".\n\n",
                "**Example 2:**\n\n**Input:** maze = \\[\\[0,0,0,0,0\\],\\[1,1,0,0,1\\],\\[0,0,0,0,0\\],\\[0,1,0,0,1\\],\\[0,1,0,0,0\\]\\], ball = \\[4,3\\], hole = \\[3,0\\]\n**Output:**  \"impossible \"\n**Explanation:** The ball cannot reach the hole.\n\n",
                "**Example 3:**\n\n**Input:** maze = \\[\\[0,0,0,0,0,0,0\\],\\[0,0,1,0,0,1,0\\],\\[0,0,0,0,1,0,0\\],\\[0,0,0,0,0,0,1\\]\\], ball = \\[0,4\\], hole = \\[3,5\\]\n**Output:**  \"dldr \""
            ],
            "constraints": "**Constraints:**\n\n*   `m == maze.length`\n*   `n == maze[i].length`\n*   `1 <= m, n <= 100`\n*   `maze[i][j]` is `0` or `1`.\n*   `ball.length == 2`\n*   `hole.length == 2`\n*   `0 <= ballrow, holerow <= m`\n*   `0 <= ballcol, holecol <= n`\n*   Both the ball and the hole exist in an empty space, and they will not be in the same position initially.\n*   The maze contains **at least 2 empty spaces**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]],[4,3],[0,1]",
                "output": "\"lul\""
            },
            {
                "input": "[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]],[4,3],[3,0]",
                "output": "\"impossible\""
            },
            {
                "input": "[[0,0,0,0,0,0,0],[0,0,1,0,0,1,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]],[0,4],[3,5]",
                "output": "\"dldr\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        int m = maze.length, n = maze[0].length;\n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; ++i) Arrays.fill(dist[i], Integer.MAX_VALUE);\n        String[] dirs = {\"d\", \"l\", \"r\", \"u\"};\n        int[][] dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        dist[ball[0]][ball[1]] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) -> p1[0] != p2[0] ? p1[0] - p2[0] : p1[1] - p2[1]);\n        pq.offer(new int[]{0, 0});\n        \n        while (!pq.isEmpty()) {\n            int cur_dist = pq.peek()[0], cur_d = pq.peek()[1];\n            String cur_path = pq.poll()[2];\n            int x = ball[0], y = ball[1];\n            for (char c : cur_path.toCharArray()) {\n                if (c == 'd') x += dirs_vector[0][0];\n                if (c == 'l') y += dirs_vector[1][1];\n                if (c == 'r') y += dirs_vector[2][1];\n                if (c == 'u') x += dirs_vector[3][0];\n            }\n            if (x == hole[0] && y == hole[1]) return cur_path;\n\n            for (int k = 0; k < 4; ++k) {\n                int dist_move = 0, r = x, c = y;\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {\n                    r += dirs_vector[k][0];\n                    c += dirs_vector[k][1];\n                    ++dist_move;\n                }\n                r -= dirs_vector[k][0];\n                c -= dirs_vector[k][1];\n                --dist_move;\n                \n                if (dist[x][y] + dist_move < dist[r][c]) {\n                    dist[r][c] = dist[x][y] + dist_move;\n                    pq.offer(new int[]{cur_dist + dist_move, cur_d * 4 + k, cur_path + dirs[k]});\n                }\n            }\n        }\n        \n        return \"impossible\";\n    }\n}\n```\n    \n    The algorithm used to solve this problem is Dijkstra's shortest path algorithm with a priority queue. For each location in the maze, we store the minimal distance to reach that location along with the lexicographically smallest instructions.\n\nWe start at the ball's position and then simulate rolling it in all four directions. While rolling, we make sure that we don't go past the walls of the maze or hit a random wall, and we stop when the ball hits the hole. We update the distance and path to the location where the ball stops, only if it's shorter than the current recorded path for that location.\n\nSince we're using a priority queue, we will always process the shortest distance location first (in case of a tie, we process the lexicographically smaller path first). This guarantees that if we reach the hole while processing a location, the resulting path will be the shortest and lexicographically smallest.\n\nIf we have visited all possible locations and don't find the hole, we return \"impossible\" as the answer.\n\nThe time complexity is O(m * n * log(m * n)) where m and n are the row and column size of the maze. The space complexity is O(m * n) since we are storing the distance and path for all the locations in the maze.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def findShortestWay(self, maze: List[List[int]], ball: List[int], hole: List[int]) -> str:\n        m, n = len(maze), len(maze[0])\n        dist = [[float(\"inf\")] * n for _ in range(m)]\n        dirs = [\"d\", \"l\", \"r\", \"u\"]\n        dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]]\n        dist[ball[0]][ball[1]] = 0\n        pq = [(0, \"\", ball[0], ball[1])]\n        \n        while pq:\n            cur_dist, cur_path, x, y = heappop(pq)\n            if [x, y] == hole:\n                return cur_path\n\n            for k, d in enumerate(dirs):\n                dist_move, r, c = 0, x + dirs_vector[k][0], y + dirs_vector[k][1]\n                while 0 <= r < m and 0 <= c < n and maze[r][c] == 0 and [r, c] != hole:\n                    r += dirs_vector[k][0]\n                    c += dirs_vector[k][1]\n                    dist_move += 1\n                r -= dirs_vector[k][0]\n                c -= dirs_vector[k][1]\n                dist_move -= 1\n                \n                if dist[x][y] + dist_move < dist[r][c]:\n                    dist[r][c] = dist[x][y] + dist_move\n                    heappush(pq, (cur_dist + dist_move, cur_path + d, r, c))\n        \n        return \"impossible\"\n```\n    \n    The algorithm used to solve this problem is Dijkstra's shortest path algorithm with a priority queue. For each location in the maze, we store the minimal distance to reach that location along with the lexicographically smallest instructions.\n\nWe start at the ball's position and then simulate rolling it in all four directions. While rolling, we make sure that we don't go past the walls of the maze or hit a random wall, and we stop when the ball hits the hole. We update the distance and path to the location where the ball stops, only if it's shorter than the current recorded path for that location.\n\nSince we're using a priority queue, we will always process the shortest distance location first (in case of a tie, we process the lexicographically smaller path first). This guarantees that if we reach the hole while processing a location, the resulting path will be the shortest and lexicographically smallest.\n\nIf we have visited all possible locations and don't find the hole, we return \"impossible\" as the answer.\n\nThe time complexity is O(m * n * log(m * n)) where m and n are the row and column size of the maze. The space complexity is O(m * n) since we are storing the distance and path for all the locations in the maze.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {\n        int m = maze.size(), n = maze[0].size();\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX)); \n        vector<string> dirs = {\"d\", \"l\", \"r\", \"u\"};\n        vector<vector<int>> dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        string res = \"\";\n        dist[ball[0]][ball[1]] = 0;\n        auto cmp = [&](const auto& p1, const auto& p2){\n            return p1.first > p2.first || (p1.first == p2.first && p1.second > p2.second);\n        };\n        priority_queue<pair<int, string>, vector<pair<int, string>>, decltype(cmp)> pq(cmp);\n        pq.push({0, \"\"});\n        \n        while (!pq.empty()) {\n            int cur_dist = pq.top().first;\n            string cur_path = pq.top().second;\n            int x = ball[0], y = ball[1];\n            for (char c : cur_path) {\n                if (c == 'd') x += dirs_vector[0][0]; \n                if (c == 'l') y += dirs_vector[1][1];\n                if (c == 'r') y += dirs_vector[2][1];\n                if (c == 'u') x += dirs_vector[3][0];\n            }\n            pq.pop();\n            if (x == hole[0] && y == hole[1]) return cur_path;\n\n            for (int k = 0; k < 4; ++k) {\n                int dist_move = 0, r = x, c = y;\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {\n                    r += dirs_vector[k][0];\n                    c += dirs_vector[k][1];\n                    ++dist_move;\n                }\n                r -= dirs_vector[k][0];\n                c -= dirs_vector[k][1];\n                --dist_move;\n                \n                if (dist[x][y] + dist_move < dist[r][c]) {\n                    dist[r][c] = dist[x][y] + dist_move;\n                    pq.push({cur_dist + dist_move, cur_path + dirs[k]});\n                }\n            }\n        }\n        \n        return \"impossible\";\n    }\n};\n```\n    \n    The algorithm used to solve this problem is Dijkstra's shortest path algorithm with a priority queue. For each location in the maze, we store the minimal distance to reach that location along with the lexicographically smallest instructions.\n\nWe start at the ball's position and then simulate rolling it in all four directions. While rolling, we make sure that we don't go past the walls of the maze or hit a random wall, and we stop when the ball hits the hole. We update the distance and path to the location where the ball stops, only if it's shorter than the current recorded path for that location.\n\nSince we're using a priority queue, we will always process the shortest distance location first (in case of a tie, we process the lexicographically smaller path first). This guarantees that if we reach the hole while processing a location, the resulting path will be the shortest and lexicographically smallest.\n\nIf we have visited all possible locations and don't find the hole, we return \"impossible\" as the answer.\n\nThe time complexity is O(m * n * log(m * n)) where m and n are the row and column size of the maze. The space complexity is O(m * n) since we are storing the distance and path for all the locations in the maze.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    findShortestWay(maze, ball, hole) {\n        const m = maze.length, n = maze[0].length;\n        const dist = Array.from({ length: m }, () => Array(n).fill(Infinity));\n        const dirs = [\"d\", \"l\", \"r\", \"u\"];\n        const dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]];\n        dist[ball[0]][ball[1]] = 0;\n        const pq = [[0, \"\", ball[0], ball[1]]];\n\n        while (pq.length > 0) {\n            pq.sort((a, b) => a[0] - b[0] || a[1].localeCompare(b[1]));\n            const [cur_dist, cur_path, x, y] = pq.shift();\n            if (x === hole[0] && y === hole[1]) return cur_path;\n\n            for (let k = 0; k < 4; ++k) {\n                let dist_move = 0, r = x, c = y;\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] === 0 && (r !== hole[0] || c !== hole[1])) {\n                    r += dirs_vector[k][0];\n                    c += dirs_vector[k][1];\n                    ++dist_move;\n                }\n                r -= dirs_vector[k][0];\n                c -= dirs_vector[k][1];\n                --dist_move;\n\n                if (dist[x][y] + dist_move < dist[r][c]) {\n                    dist[r][c] = dist[x][y] + dist_move;\n                    pq.push([cur_dist + dist_move, cur_path + dirs[k], r, c]);\n                }\n            }\n        }\n\n        return \"impossible\";\n    }\n}\n```\n    \n    The algorithm used to solve this problem is Dijkstra's shortest path algorithm with a priority queue. For each location in the maze, we store the minimal distance to reach that location along with the lexicographically smallest instructions.\n\nWe start at the ball's position and then simulate rolling it in all four directions. While rolling, we make sure that we don't go past the walls of the maze or hit a random wall, and we stop when the ball hits the hole. We update the distance and path to the location where the ball stops, only if it's shorter than the current recorded path for that location.\n\nSince we're using a priority queue, we will always process the shortest distance location first (in case of a tie, we process the lexicographically smaller path first). This guarantees that if we reach the hole while processing a location, the resulting path will be the shortest and lexicographically smallest.\n\nIf we have visited all possible locations and don't find the hole, we return \"impossible\" as the answer.\n\nThe time complexity is O(m * n * log(m * n)) where m and n are the row and column size of the maze. The space complexity is O(m * n) since we are storing the distance and path for all the locations in the maze.\n    "
    },
    {
        "id": 103,
        "title": "The Maze II",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a ball in a `maze` with empty spaces (represented as `0`) and walls (represented as `1`). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the `m x n` `maze`, the ball's `start` position and the `destination`, where `start = [startrow, startcol]` and `destination = [destinationrow, destinationcol]`, return _the shortest **distance** for the ball to stop at the destination_. If the ball cannot stop at `destination`, return `-1`.\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\nYou may assume that **the borders of the maze are all walls** (see examples).",
            "examples": [
                "**Example 1:**\n\n**Input:** maze = \\[\\[0,0,1,0,0\\],\\[0,0,0,0,0\\],\\[0,0,0,1,0\\],\\[1,1,0,1,1\\],\\[0,0,0,0,0\\]\\], start = \\[0,4\\], destination = \\[4,4\\]\n**Output:** 12\n**Explanation:** One possible way is : left -> down -> left -> down -> right -> down -> right.\nThe length of the path is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\n\n",
                "**Example 2:**\n\n**Input:** maze = \\[\\[0,0,1,0,0\\],\\[0,0,0,0,0\\],\\[0,0,0,1,0\\],\\[1,1,0,1,1\\],\\[0,0,0,0,0\\]\\], start = \\[0,4\\], destination = \\[3,2\\]\n**Output:** -1\n**Explanation:** There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.\n\n",
                "**Example 3:**\n\n**Input:** maze = \\[\\[0,0,0,0,0\\],\\[1,1,0,0,1\\],\\[0,0,0,0,0\\],\\[0,1,0,0,1\\],\\[0,1,0,0,0\\]\\], start = \\[4,3\\], destination = \\[0,1\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == maze.length`\n*   `n == maze[i].length`\n*   `1 <= m, n <= 100`\n*   `maze[i][j]` is `0` or `1`.\n*   `start.length == 2`\n*   `destination.length == 2`\n*   `0 <= startrow, destinationrow < m`\n*   `0 <= startcol, destinationcol < n`\n*   Both the ball and the destination exist in an empty space, and they will not be in the same position initially.\n*   The maze contains **at least 2 empty spaces**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]],[0,4],[4,4]",
                "output": "12"
            },
            {
                "input": "[[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]],[0,4],[3,2]",
                "output": "-1"
            },
            {
                "input": "[[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]],[4,3],[0,1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int shortestDistance(int[][] maze, int[] start, int[] destination) {\n    int m = maze.length, n = maze[0].length;\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int[][] dist = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = -1;\n        }\n    }\n\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n\n    dist[start[0]][start[1]] = 0;\n    q.offer(new int[]{start[0], start[1], 0});\n\n    while (!q.isEmpty()) {\n        int[] cur = q.poll();\n        int x = cur[0], y = cur[1];\n\n        for (int[] dir : directions) {\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            int step = 0;\n\n            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {\n                newX += dir[0];\n                newY += dir[1];\n                step++;\n            }\n\n            newX -= dir[0];\n            newY -= dir[1];\n\n            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.offer(new int[]{newX, newY, dist[newX][newY]});\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}\n```\n\n    \n    We can use a BFS (Breadth-First Search) algorithm to explore the maze, counting the distance travelled in each direction. When visiting an empty space, we can continue moving in each direction until hitting a wall. Once the wall is hit, we store the distance travelled and visit the new position.\n\nWe keep track of visited positions and their distances, updating them if a shorter path is found. Use a queue to hold positions to visit next, and continue the process until the queue is empty.\n\nFinally, return the distance stored at the destination. If the destination hasn't been reached, return -1.\n    ",
        "python": "\n    ```python\nfrom queue import PriorityQueue\n\ndef shortestDistance(maze, start, destination):\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n\n    q = PriorityQueue()\n\n    dist[start[0]][start[1]] = 0\n    q.put((0, start[0], start[1]))\n\n    while not q.empty():\n        cur = q.get()\n        x, y = cur[1], cur[2]\n\n        for dir in directions:\n            newX, newY = x + dir[0], y + dir[1]\n            step = 0\n\n            while 0 <= newX < m and 0 <= newY < n and maze[newX][newY] == 0:\n                newX += dir[0]\n                newY += dir[1]\n                step += 1\n\n            newX -= dir[0]\n            newY -= dir[1]\n\n            if dist[newX][newY] == -1 or dist[x][y] + step < dist[newX][newY]:\n                dist[newX][newY] = dist[x][y] + step\n                q.put((dist[newX][newY], newX, newY))\n\n    return dist[destination[0]][destination[1]]\n```\n\n    \n    We can use a BFS (Breadth-First Search) algorithm to explore the maze, counting the distance travelled in each direction. When visiting an empty space, we can continue moving in each direction until hitting a wall. Once the wall is hit, we store the distance travelled and visit the new position.\n\nWe keep track of visited positions and their distances, updating them if a shorter path is found. Use a queue to hold positions to visit next, and continue the process until the queue is empty.\n\nFinally, return the distance stored at the destination. If the destination hasn't been reached, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {\n    int m = maze.size(), n = maze[0].size();\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<vector<int>> dist(m, vector<int> (n, -1));\n\n    queue<pair<int, int>> q;\n\n    dist[start[0]][start[1]] = 0;\n    q.push({start[0], start[1]});\n\n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n\n        for (auto dir : directions) {\n            int newX = x + dir.first;\n            int newY = y + dir.second;\n            int step = 0;\n\n            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {\n                newX += dir.first;\n                newY += dir.second;\n                step++;\n            }\n\n            newX -= dir.first;\n            newY -= dir.second;\n\n            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.push({newX, newY});\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}\n```\n\n    \n    We can use a BFS (Breadth-First Search) algorithm to explore the maze, counting the distance travelled in each direction. When visiting an empty space, we can continue moving in each direction until hitting a wall. Once the wall is hit, we store the distance travelled and visit the new position.\n\nWe keep track of visited positions and their distances, updating them if a shorter path is found. Use a queue to hold positions to visit next, and continue the process until the queue is empty.\n\nFinally, return the distance stored at the destination. If the destination hasn't been reached, return -1.\n    ",
        "js": "\n    ```javascript\nfunction shortestDistance(maze, start, destination) {\n    const m = maze.length, n = maze[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    const dist = new Array(m).fill(null).map(() => new Array(n).fill(-1));\n\n    const q = [[start[0], start[1], 0]];\n    dist[start[0]][start[1]] = 0;\n\n    while (q.length) {\n        const [x, y, d] = q.shift();\n\n        for (const dir of directions) {\n            let newX = x + dir[0];\n            let newY = y + dir[1];\n            let step = 0;\n\n            while (0 <= newX && newX < m && 0 <= newY && newY < n && maze[newX][newY] === 0) {\n                newX += dir[0];\n                newY += dir[1];\n                step++;\n            }\n\n            newX -= dir[0];\n            newY -= dir[1];\n\n            if (dist[newX][newY] === -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.push([newX, newY, dist[newX][newY]]);\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}\n```\n\n    \n    We can use a BFS (Breadth-First Search) algorithm to explore the maze, counting the distance travelled in each direction. When visiting an empty space, we can continue moving in each direction until hitting a wall. Once the wall is hit, we store the distance travelled and visit the new position.\n\nWe keep track of visited positions and their distances, updating them if a shorter path is found. Use a queue to hold positions to visit next, and continue the process until the queue is empty.\n\nFinally, return the distance stored at the destination. If the destination hasn't been reached, return -1.\n    "
    },
    {
        "id": 104,
        "title": "Inorder Successor in BST II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `node` in a binary search tree, return _the in-order successor of that node in the BST_. If that node has no in-order successor, return `null`.\n\nThe successor of a `node` is the node with the smallest key greater than `node.val`.\n\nYou will have direct access to the node but not to the root of the tree. Each node will have a reference to its parent node. Below is the definition for `Node`:\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}",
            "examples": [
                "**Example 1:**\n\n**Input:** tree = \\[2,1,3\\], node = 1\n**Output:** 2\n**Explanation:** 1's in-order successor node is 2. Note that both the node and the return value is of Node type.\n\n",
                "**Example 2:**\n\n**Input:** tree = \\[5,3,6,2,4,null,null,1\\], node = 6\n**Output:** null\n**Explanation:** There is no in-order successor of the current node, so the answer is null."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\n*   All Nodes will have unique values.\n\n**",
            "follow_up": "Follow up:** Could you solve it without looking up any of the node's values?"
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,3],1",
                "output": "2"
            },
            {
                "input": "[5,3,6,2,4,null,null,1],6",
                "output": "null"
            }
        ],
        "java": "\n    ```java\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n\npublic Node inorderSuccessor(Node node) {\n    if (node.right != null) {\n        node = node.right;\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n    while (node.parent != null && node == node.parent.right) {\n        node = node.parent;\n    }\n    return node.parent;\n}\n```\n    \n    Algorithm:\n\n1. If the node has a right child, then the in-order successor of the node is the leftmost node in its right sub-tree.\n2. If the node doesn't have a right child, follow the parent pointers until we either find a node that is a left child or we reach the root:\n    - If we find a node that is a left child, then the in-order successor is its parent.\n    - If we reach the root, then the current node is the last node in in-order traversal, so its in-order successor is `null`.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\ndef inorder_successor(node: Node) -> Node:\n    if node.right:\n        node = node.right\n        while node.left:\n            node = node.left\n        return node\n\n    while node.parent and node == node.parent.right:\n        node = node.parent\n\n    return node.parent\n```\n    \n    Algorithm:\n\n1. If the node has a right child, then the in-order successor of the node is the leftmost node in its right sub-tree.\n2. If the node doesn't have a right child, follow the parent pointers until we either find a node that is a left child or we reach the root:\n    - If we find a node that is a left child, then the in-order successor is its parent.\n    - If we reach the root, then the current node is the last node in in-order traversal, so its in-order successor is `null`.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* parent;\n};\n\nNode* inorderSuccessor(Node* node) {\n    if (node->right) {\n        node = node->right;\n        while (node->left) {\n            node = node->left;\n        }\n        return node;\n    }\n    while (node->parent && node == node->parent->right) {\n        node = node->parent;\n    }\n    return node->parent;\n}\n```\n    \n    Algorithm:\n\n1. If the node has a right child, then the in-order successor of the node is the leftmost node in its right sub-tree.\n2. If the node doesn't have a right child, follow the parent pointers until we either find a node that is a left child or we reach the root:\n    - If we find a node that is a left child, then the in-order successor is its parent.\n    - If we reach the root, then the current node is the last node in in-order traversal, so its in-order successor is `null`.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, left = null, right = null, parent = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n        this.parent = parent;\n    }\n}\n\nfunction inorderSuccessor(node) {\n    if (node.right) {\n        node = node.right;\n        while (node.left) {\n            node = node.left;\n        }\n        return node;\n    }\n    while (node.parent && node === node.parent.right) {\n        node = node.parent;\n    }\n    return node.parent;\n}\n```\n    \n    Algorithm:\n\n1. If the node has a right child, then the in-order successor of the node is the leftmost node in its right sub-tree.\n2. If the node doesn't have a right child, follow the parent pointers until we either find a node that is a left child or we reach the root:\n    - If we find a node that is a left child, then the in-order successor is its parent.\n    - If we reach the root, then the current node is the last node in in-order traversal, so its in-order successor is `null`.\n    "
    },
    {
        "id": 105,
        "title": "Word Abbreviation",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of **distinct** strings `words`, return _the minimal possible **abbreviations** for every word_.\n\nThe following are the rules for a string abbreviation:\n\n1.  The **initial** abbreviation for each word is: the first character, then the number of characters in between, followed by the last character.\n2.  If more than one word shares the **same** abbreviation, then perform the following operation:\n    *   **Increase** the prefix (characters in the first part) of each of their abbreviations by `1`.\n        *   For example, say you start with the words `[ \"abcdef \", \"abndef \"]` both initially abbreviated as `\"a4f \"`. Then, a sequence of operations would be `[ \"a4f \", \"a4f \"]` -> `[ \"ab3f \", \"ab3f \"]` -> `[ \"abc2f \", \"abn2f \"]`.\n    *   This operation is repeated until every abbreviation is **unique**.\n3.  At the end, if an abbreviation did not make a word shorter, then keep it as the original word.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"\\]\n**Output:** \\[\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[\"aa\",\"aaa\"\\]\n**Output:** \\[\"aa\",\"aaa\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 400`\n*   `2 <= words[i].length <= 400`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"]",
                "output": "[\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"]"
            },
            {
                "input": "[\"aa\",\"aaa\"]",
                "output": "[\"aa\",\"aaa\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\npublic String[] wordsAbbreviation(String[] words) {\n    int n = words.length;\n    String[] abbr = new String[n];\n    int[] prefixLen = new int[n];\n\n    for (int i = 0; i < n; i++) {\n        abbr[i] = abbrev(words[i], 1);\n        prefixLen[i] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        while (true) {\n            Map<String, int[]> groups = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (abbr[i].equals(abbr[j])) {\n                    if (!groups.containsKey(abbr[j])) {\n                        groups.put(abbr[j], new int[]{0, 0});\n                    }\n                    groups.get(abbr[j])[0]++;\n                    groups.get(abbr[j])[1] = j;\n                }\n            }\n            if (groups.get(abbr[i])[0] == 1) {\n                break;\n            }\n            abbr[groups.get(abbr[i])[1]] = abbrev(words[groups.get(abbr[i])[1]], ++prefixLen[groups.get(abbr[i])[1]]);\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n\nprivate String abbrev(String s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substring(0, k + 1) + Integer.toString(n - k - 2) + s.charAt(n - 1);\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "python": "\n    ```python\ndef wordsAbbreviation(words):\n    def abbrev(word, k):\n        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word\n\n    n = len(words)\n    abbr = [abbrev(word, 1) for word in words]\n    prefix_len = [1] * n\n\n    for i in range(n):\n        while abbr.count(abbr[i]) > 1:\n            groups = {}\n            for j in range(i + 1, n):\n                if abbr[i] == abbr[j]:\n                    if abbr[j] not in groups:\n                        groups[abbr[j]] = []\n                    groups[abbr[j]].append(j)\n            for group_members in groups.values():\n                for j in group_members:\n                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)\n                    prefix_len[j] += 1\n            abbr[i] = abbrev(words[i], prefix_len[i] + 1)\n            prefix_len[i] += 1\n\n    return abbr\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::string abbrev(const std::string& s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substr(0, k + 1) + std::to_string(n - k - 2) + s.back();\n}\n\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<std::string> abbr;\n    std::vector<int> prefixLen(n, 1);\n\n    for (int i = 0; i < n; ++i) {\n        abbr.push_back(abbrev(words[i], 1));\n    }\n\n    for (int i = 0; i < n; ++i) {\n        while (true) {\n            std::unordered_map<std::string, std::vector<int>> groups;\n            for (int j = i + 1; j < n; ++j) {\n                if (abbr[i] == abbr[j]) {\n                    groups[abbr[j]].push_back(j);\n                }\n            }\n            if (groups.empty()) {\n                break;\n            }\n            for (const auto &group : groups) {\n                for (int id : group.second) {\n                    abbr[id] = abbrev(words[id], ++prefixLen[id]);\n                }\n            }\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "js": "\n    ```javascript\nfunction wordsAbbreviation(words) {\n    function abbrev(word, k) {\n        return k < word.length - 2 ? word.slice(0, k + 1) + (word.length - k - 2) + word.slice(-1) : word;\n    }\n\n    const n = words.length;\n    const abbr = words.map(word => abbrev(word, 1));\n    const prefixLen = new Array(n).fill(1);\n\n    for (let i = 0; i < n; i++) {\n        while (abbr.filter(a => a === abbr[i]).length > 1) {\n            const groups = {};\n            for (let j = i + 1; j < n; j++) {\n                if (abbr[i] === abbr[j]) {\n                    if (!groups[abbr[j]]) {\n                        groups[abbr[j]] = [];\n                    }\n                    groups[abbr[j]].push(j);\n                }\n            }\n            for (const groupMembers of Object.values(groups)) {\n                for (const j of groupMembers) {\n                    abbr[j] = abbrev(words[j], prefixLen[j] + 1);\n                    prefixLen[j]++;\n                }\n            }\n            abbr[i] = abbrev(words[i], prefixLen[i] + 1);\n            prefixLen[i]++;\n        }\n    }\n\n    return abbr;\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    "
    },
    {
        "id": 106,
        "title": "Lonely Pixel I",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position where the same row and same column don't have **any other** black pixels.",
            "examples": [
                "**Example 1:**\n\n**Input:** picture = \\[\\[ \"W \", \"W \", \"B \"\\],\\[ \"W \", \"B \", \"W \"\\],\\[ \"B \", \"W \", \"W \"\\]\\]\n**Output:** 3\n**Explanation:** All the three 'B's are black lonely pixels.\n\n",
                "**Example 2:**\n\n**Input:** picture = \\[\\[ \"B \", \"B \", \"B \"\\],\\[ \"B \", \"B \", \"W \"\\],\\[ \"B \", \"B \", \"B \"\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == picture.length`\n*   `n == picture[i].length`\n*   `1 <= m, n <= 500`\n*   `picture[i][j]` is `'W'` or `'B'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"W\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"W\"]]",
                "output": "3"
            },
            {
                "input": "[[\"B\",\"B\",\"B\"],[\"B\",\"B\",\"W\"],[\"B\",\"B\",\"B\"]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int findLonelyPixel(char[][] picture) {\n    int m = picture.length, n = picture[0].length;\n    int[] row = new int[m], col = new int[n];\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "python": "\n    ```python\ndef findLonelyPixel(picture):\n    m, n = len(picture), len(picture[0])\n    row, col = [0] * m, [0] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row[i] += 1\n                col[j] += 1\n                \n    lonely = 0\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:\n                lonely += 1\n                \n    return lonely\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "c++": "\n    ```cpp\nint findLonelyPixel(vector<vector<char>>& picture) {\n    int m = picture.size(), n = picture[0].size();\n    vector<int> row(m, 0), col(n, 0);\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    ",
        "js": "\n    ```javascript\nfunction findLonelyPixel(picture) {\n    let m = picture.length, n = picture[0].length;\n    let row = new Array(m).fill(0), col = new Array(n).fill(0);\n    \n    for(let i = 0; i < m; ++i) {\n        for(let j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    let lonely = 0;\n    for(let i = 0; i < m; ++i) {\n        for(let j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n```\n    \n    The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture.\n    "
    },
    {
        "id": 107,
        "title": "Lonely Pixel II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` `picture` consisting of black `'B'` and white `'W'` pixels and an integer target, return _the number of **black** lonely pixels_.\n\nA black lonely pixel is a character `'B'` that located at a specific position `(r, c)` where:\n\n*   Row `r` and column `c` both contain exactly `target` black pixels.\n*   For all rows that have a black pixel at column `c`, they should be exactly the same as row `r`.",
            "examples": [
                "**Example 1:**\n\n**Input:** picture = \\[\\[ \"W \", \"B \", \"W \", \"B \", \"B \", \"W \"\\],\\[ \"W \", \"B \", \"W \", \"B \", \"B \", \"W \"\\],\\[ \"W \", \"B \", \"W \", \"B \", \"B \", \"W \"\\],\\[ \"W \", \"W \", \"B \", \"W \", \"B \", \"W \"\\]\\], target = 3\n**Output:** 6\n**Explanation:** All the green 'B' are the black pixels we need (all 'B's at column 1 and 3).\nTake 'B' at row r = 0 and column c = 1 as an example:\n - Rule 1, row r = 0 and column c = 1 both have exactly target = 3 black pixels. \n - Rule 2, the rows have black pixel at column c = 1 are row 0, row 1 and row 2. They are exactly the same as row r = 0.\n\n",
                "**Example 2:**\n\n**Input:** picture = \\[\\[ \"W \", \"W \", \"B \"\\],\\[ \"W \", \"W \", \"B \"\\],\\[ \"W \", \"W \", \"B \"\\]\\], target = 1\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == picture.length`\n*   `n == picture[i].length`\n*   `1 <= m, n <= 200`\n*   `picture[i][j]` is `'W'` or `'B'`.\n*   `1 <= target <= min(m, n)`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"W\",\"B\",\"W\",\"B\",\"B\",\"W\"],[\"W\",\"B\",\"W\",\"B\",\"B\",\"W\"],[\"W\",\"B\",\"W\",\"B\",\"B\",\"W\"],[\"W\",\"W\",\"B\",\"W\",\"B\",\"W\"]],3",
                "output": "6"
            },
            {
                "input": "[[\"W\",\"W\",\"B\"],[\"W\",\"W\",\"B\"],[\"W\",\"W\",\"B\"]],1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int findBlackPixel(char[][] picture, int target) {\n    int m = picture.length;\n    int n = picture[0].length;\n    int[] rows = new int[m];\n    int[] cols = new int[n];\n    Map<String, Integer> rowCounts = new HashMap<>();\n    for (int i = 0; i < m; ++i) {\n        StringBuilder row = new StringBuilder();\n        for (int j = 0; j < n; ++j) {\n            if (picture[i][j] == 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row.append(picture[i][j]);\n        }\n        String rowStr = row.toString();\n        if (rows[i] == target)\n            rowCounts.put(rowStr, rowCounts.getOrDefault(rowStr, 0) + 1);\n    }\n    int ans = 0;\n    for (Map.Entry<String, Integer> entry : rowCounts.entrySet()) {\n        String row = entry.getKey();\n        int count = entry.getValue();\n        if (count == target) {\n            for (int j = 0; j < n; ++j) {\n                if (row.charAt(j) == 'B' && cols[j] == target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels).\n    ",
        "python": "\n    ```python\ndef findBlackPixel(picture, target):\n    m, n = len(picture), len(picture[0])\n    rows = [0] * m\n    cols = [0] * n\n    rowCounts = {}\n    for i in range(m):\n        row = \"\"\n        for j in range(n):\n            if picture[i][j] == 'B':\n                rows[i] += 1\n                cols[j] += 1\n            row += picture[i][j]\n        if rows[i] == target:\n            rowCounts[row] = rowCounts.get(row, 0) + 1\n    ans = 0\n    for row, count in rowCounts.items():\n        if count == target:\n            for j in range(n):\n                if row[j] == 'B' and cols[j] == target:\n                    ans += count\n    return ans\n```\n    \n    1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels).\n    ",
        "c++": "\n    ```cpp\nint findBlackPixel(vector<vector<char>>& picture, int target) {\n    int m = picture.size();\n    int n = picture[0].size();\n    vector<int> rows(m, 0), cols(n, 0);\n    unordered_map<string, int> rowCounts;\n    for (int i = 0; i < m; ++i) {\n        string row;\n        for (int j = 0; j < n; ++j) {\n            if (picture[i][j] == 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row.push_back(picture[i][j]);\n        }\n        if (rows[i] == target)\n            rowCounts[row]++;\n    }\n    int ans = 0;\n    for (auto &[row, count] : rowCounts) {\n        if (count == target) {\n            for (int j = 0; j < n; ++j) {\n                if (row[j] == 'B' && cols[j] == target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels).\n    ",
        "js": "\n    ```javascript\nfunction findBlackPixel(picture, target) {\n    const m = picture.length;\n    const n = picture[0].length;\n    const rows = new Array(m).fill(0);\n    const cols = new Array(n).fill(0);\n    const rowCounts = new Map();\n    for (let i = 0; i < m; ++i) {\n        let row = \"\";\n        for (let j = 0; j < n; ++j) {\n            if (picture[i][j] === 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row += picture[i][j];\n        }\n        if (rows[i] === target)\n            rowCounts.set(row, (rowCounts.get(row) || 0) + 1);\n    }\n    let ans = 0;\n    for (let [row, count] of rowCounts.entries()) {\n        if (count === target) {\n            for (let j = 0; j < n; ++j) {\n                if (row[j] === 'B' && cols[j] === target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels).\n    "
    },
    {
        "id": 108,
        "title": "Construct Binary Tree from String",
        "difficulty": "Medium",
        "content": {
            "problem": "You need to construct a binary tree from a string consisting of parenthesis and integers.\n\nThe whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure.\n\nYou always start to construct the **left** child node of the parent first if it exists.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"4(2(3)(1))(6(5)) \"\n**Output:** \\[4,2,6,3,1,5\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"4(2(3)(1))(6(5)(7)) \"\n**Output:** \\[4,2,6,3,1,5,7\\]\n\n",
                "**Example 3:**\n\n**Input:** s =  \"-4(2(3)(1))(6(5)(7)) \"\n**Output:** \\[-4,2,6,3,1,5,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s` consists of digits, `'('`, `')'`, and `'-'` only.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"4(2(3)(1))(6(5))\"",
                "output": "[4,2,6,3,1,5]"
            },
            {
                "input": "\"4(2(3)(1))(6(5)(7))\"",
                "output": "[4,2,6,3,1,5,7]"
            },
            {
                "input": "\"-4(2(3)(1))(6(5)(7))\"",
                "output": "[-4,2,6,3,1,5,7]"
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public TreeNode str2tree(String s) {\n        MyInteger idx = new MyInteger(0);\n        return str2treeHelper(s, idx);\n    }\n\n    private TreeNode str2treeHelper(String s, MyInteger idx) {\n        if (idx.get() >= s.length()) return null;\n\n        int sign = 1;\n        if (s.charAt(idx.get()) == '-') {\n            sign = -1;\n            idx.increment();\n        }\n\n        int num = 0;\n        while (idx.get() < s.length() && Character.isDigit(s.charAt(idx.get()))) {\n            num = num * 10 + (s.charAt(idx.get()) - '0');\n            idx.increment();\n        }\n\n        TreeNode node = new TreeNode(sign * num);\n\n        if (idx.get() < s.length() && s.charAt(idx.get()) == '(') {\n            idx.increment();\n            node.left = str2treeHelper(s, idx);\n            idx.increment();\n        }\n        if (idx.get() < s.length() && s.charAt(idx.get()) == '(') {\n            idx.increment();\n            node.right = str2treeHelper(s, idx);\n            idx.increment();\n        }\n\n        return node;\n    }\n}\n\nclass MyInteger {\n    private int value;\n\n    MyInteger(int value) {\n        this.value = value;\n    }\n\n    int get() {\n        return value;\n    }\n\n    void increment() {\n        value++;\n    }\n}\n```\n\n    \n    The algorithm uses a recursive helper function (`str2treeHelper`) that constructs the binary tree nodes by traversing the input string `s`. The helper function updates the index (`idx`) at each recursive call and creates a TreeNode for each parenthesis pair encountered.\n\n1. If `idx` is greater than or equal to the string length, return `null`.\n2. Check the sign of the current number (if a negative sign is found) and update the `sign` and `idx`.\n3. Extract the current number and update the `idx`.\n4. Create a new TreeNode with the current number's value.\n5. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the left child node. Increment `idx` after constructing the left subtree.\n6. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the right child node. Increment `idx` after constructing the right subtree.\n7. Return the newly created TreeNode.\n\nThe main function initializes the index variable `idx`, calls the helper function, and returns the root node of the constructed binary tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def str2tree(self, s: str) -> TreeNode:\n        def str2tree_helper(idx):\n            if idx[0] >= len(s):\n                return None\n\n            sign = 1\n            if s[idx[0]] == '-':\n                sign = -1\n                idx[0] += 1\n                \n            num = 0\n            while idx[0] < len(s) and s[idx[0]].isdigit():\n                num = num * 10 + int(s[idx[0]])\n                idx[0] += 1\n\n            node = TreeNode(sign * num)\n\n            if idx[0] < len(s) and s[idx[0]] == '(':\n                idx[0] += 1\n                node.left = str2tree_helper(idx)\n                idx[0] += 1\n            if idx[0] < len(s) and s[idx[0]] == '(':\n                idx[0] += 1\n                node.right = str2tree_helper(idx)\n                idx[0] += 1\n\n            return node\n\n        idx = [0]\n        return str2tree_helper(idx)\n```\n\n    \n    The algorithm uses a recursive helper function (`str2treeHelper`) that constructs the binary tree nodes by traversing the input string `s`. The helper function updates the index (`idx`) at each recursive call and creates a TreeNode for each parenthesis pair encountered.\n\n1. If `idx` is greater than or equal to the string length, return `null`.\n2. Check the sign of the current number (if a negative sign is found) and update the `sign` and `idx`.\n3. Extract the current number and update the `idx`.\n4. Create a new TreeNode with the current number's value.\n5. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the left child node. Increment `idx` after constructing the left subtree.\n6. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the right child node. Increment `idx` after constructing the right subtree.\n7. Return the newly created TreeNode.\n\nThe main function initializes the index variable `idx`, calls the helper function, and returns the root node of the constructed binary tree.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* str2tree(std::string s) {\n        int idx = 0;\n        return str2treeHelper(s, idx);\n    }\n\n    TreeNode* str2treeHelper(const std::string& s, int& idx) {\n        if (idx >= s.length()) return NULL;\n        \n        int sign = 1;\n        if (s[idx] == '-') {\n            sign = -1;\n            idx++;\n        }\n        \n        int num = 0;\n        while (idx < s.length() && isdigit(s[idx])) {\n            num = num * 10 + (s[idx] - '0');\n            idx++;\n        }\n\n        TreeNode* node = new TreeNode(sign * num);\n\n        if (idx < s.length() && s[idx] == '(') {\n            idx++;\n            node->left = str2treeHelper(s, idx);\n            idx++;\n        }\n        if (idx < s.length() && s[idx] == '(') {\n            idx++;\n            node->right = str2treeHelper(s, idx);\n            idx++;\n        }\n\n        return node;\n    }\n};\n```\n\n    \n    The algorithm uses a recursive helper function (`str2treeHelper`) that constructs the binary tree nodes by traversing the input string `s`. The helper function updates the index (`idx`) at each recursive call and creates a TreeNode for each parenthesis pair encountered.\n\n1. If `idx` is greater than or equal to the string length, return `null`.\n2. Check the sign of the current number (if a negative sign is found) and update the `sign` and `idx`.\n3. Extract the current number and update the `idx`.\n4. Create a new TreeNode with the current number's value.\n5. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the left child node. Increment `idx` after constructing the left subtree.\n6. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the right child node. Increment `idx` after constructing the right subtree.\n7. Return the newly created TreeNode.\n\nThe main function initializes the index variable `idx`, calls the helper function, and returns the root node of the constructed binary tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nvar str2tree = function(s) {\n    const str2treeHelper = (s, idx) => {\n        if (idx.value >= s.length) return null;\n\n        let sign = 1;\n        if (s[idx.value] === '-') {\n            sign = -1;\n            idx.value++;\n        }\n\n        let num = 0;\n        while (idx.value < s.length && !isNaN(parseInt(s[idx.value], 10))) {\n            num = num * 10 + parseInt(s[idx.value], 10);\n            idx.value++;\n        }\n\n        const node = new TreeNode(sign * num);\n\n        if (idx.value < s.length && s[idx.value] === '(') {\n            idx.value++;\n            node.left = str2treeHelper(s, idx);\n            idx.value++;\n        }\n        if (idx.value < s.length && s[idx.value] === '(') {\n            idx.value++;\n            node.right = str2treeHelper(s, idx);\n            idx.value++;\n        }\n\n        return node;\n    };\n\n    const idx = {value: 0};\n    return str2treeHelper(s, idx);\n};\n```\n\n    \n    The algorithm uses a recursive helper function (`str2treeHelper`) that constructs the binary tree nodes by traversing the input string `s`. The helper function updates the index (`idx`) at each recursive call and creates a TreeNode for each parenthesis pair encountered.\n\n1. If `idx` is greater than or equal to the string length, return `null`.\n2. Check the sign of the current number (if a negative sign is found) and update the `sign` and `idx`.\n3. Extract the current number and update the `idx`.\n4. Create a new TreeNode with the current number's value.\n5. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the left child node. Increment `idx` after constructing the left subtree.\n6. If the current character at `idx` is '(', move to the next character and call the `str2treeHelper` to construct the right child node. Increment `idx` after constructing the right subtree.\n7. Return the newly created TreeNode.\n\nThe main function initializes the index variable `idx`, calls the helper function, and returns the root node of the constructed binary tree.\n    "
    },
    {
        "id": 109,
        "title": "Output Contest Matches",
        "difficulty": "Medium",
        "content": {
            "problem": "During the NBA playoffs, we always set the rather strong team to play with the rather weak team, like make the rank `1` team play with the rank `nth` team, which is a good strategy to make the contest more interesting.\n\nGiven `n` teams, return _their final contest matches in the form of a string_.\n\nThe `n` teams are labeled from `1` to `n`, which represents their initial rank (i.e., Rank `1` is the strongest team and Rank `n` is the weakest team).\n\nWe will use parentheses `'('`, and `')'` and commas `','` to represent the contest team pairing. We use the parentheses for pairing and the commas for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:**  \"((1,4),(2,3)) \"\n**Explanation:**\nIn the first round, we pair the team 1 and 4, the teams 2 and 3 together, as we need to make the strong team and weak team together.\nAnd we got (1, 4),(2, 3).\nIn the second round, the winners of (1, 4) and (2, 3) need to play again to generate the final winner, so you need to add the paratheses outside them.\nAnd we got the final answer ((1,4),(2,3)).\n\n",
                "**Example 2:**\n\n**Input:** n = 8\n**Output:**  \"(((1,8),(4,5)),((2,7),(3,6))) \"\n**Explanation:**\nFirst round: (1, 8),(2, 7),(3, 6),(4, 5)\nSecond round: ((1, 8),(4, 5)),((2, 7),(3, 6))\nThird round: (((1, 8),(4, 5)),((2, 7),(3, 6)))\nSince the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6)))."
            ],
            "constraints": "**Constraints:**\n\n*   `n == 2x` where `x` in in the range `[1, 12]`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "4",
                "output": "\"((1,4),(2,3))\""
            },
            {
                "input": "8",
                "output": "\"(((1,8),(4,5)),((2,7),(3,6)))\""
            }
        ],
        "java": "\n    ```java\npublic String findContestMatch(int n) {\n    String[] matches = new String[n];\n    for (int i = 1; i <= n; i++) {\n        matches[i - 1] = Integer.toString(i);\n    }\n\n    while (n > 1) {\n        for (int i = 0; i < n / 2; i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n /= 2;\n    }\n\n    return matches[0];\n}\n```\n\n    \n    This algorithm initializes an array of matches with `n` elements, each representing a team. It then generates one half of the final contest matches using a while loop. During each iteration of the while loop, for every pair of teams `i` and `n - 1 - i`, we form a new match by creating a string with the format `(team1,team2)` and store it in the matches array. With each iteration, we divide the number of matches by 2, which eventually gives us the final contest match at the first index of the matches array.\n    ",
        "python": "\n    ```python\ndef findContestMatch(n):\n    matches = [str(i) for i in range(1, n + 1)]\n\n    while n > 1:\n        for i in range(n // 2):\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\"\n        n //= 2\n\n    return matches[0]\n```\n\n    \n    This algorithm initializes an array of matches with `n` elements, each representing a team. It then generates one half of the final contest matches using a while loop. During each iteration of the while loop, for every pair of teams `i` and `n - 1 - i`, we form a new match by creating a string with the format `(team1,team2)` and store it in the matches array. With each iteration, we divide the number of matches by 2, which eventually gives us the final contest match at the first index of the matches array.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring findContestMatch(int n) {\n    vector<string> matches(n);\n    for (int i = 1; i <= n; i++) {\n        matches[i - 1] = to_string(i);\n    }\n\n    while (n > 1) {\n        for (int i = 0; i < n / 2; i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n /= 2;\n    }\n\n    return matches[0];\n}\n```\n\n    \n    This algorithm initializes an array of matches with `n` elements, each representing a team. It then generates one half of the final contest matches using a while loop. During each iteration of the while loop, for every pair of teams `i` and `n - 1 - i`, we form a new match by creating a string with the format `(team1,team2)` and store it in the matches array. With each iteration, we divide the number of matches by 2, which eventually gives us the final contest match at the first index of the matches array.\n    ",
        "js": "\n    ```javascript\nfunction findContestMatch(n) {\n    let matches = Array.from({length: n}, (_, i) => String(i + 1));\n    \n    while (n > 1) {\n        for (let i = 0; i < (n / 2); i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n = Math.floor(n / 2);\n    }\n    \n    return matches[0];\n}\n```\n\n    \n    This algorithm initializes an array of matches with `n` elements, each representing a team. It then generates one half of the final contest matches using a while loop. During each iteration of the while loop, for every pair of teams `i` and `n - 1 - i`, we form a new match by creating a string with the format `(team1,team2)` and store it in the matches array. With each iteration, we divide the number of matches by 2, which eventually gives us the final contest match at the first index of the matches array.\n    "
    },
    {
        "id": 110,
        "title": "Boundary of Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "The **boundary** of a binary tree is the concatenation of the **root**, the **left boundary**, the **leaves** ordered from left-to-right, and the **reverse order** of the **right boundary**.\n\nThe **left boundary** is the set of nodes defined by the following:\n\n*   The root node's left child is in the left boundary. If the root does not have a left child, then the left boundary is **empty**.\n*   If a node in the left boundary and has a left child, then the left child is in the left boundary.\n*   If a node is in the left boundary, has **no** left child, but has a right child, then the right child is in the left boundary.\n*   The leftmost leaf is **not** in the left boundary.\n\nThe **right boundary** is similar to the **left boundary**, except it is the right side of the root's right subtree. Again, the leaf is **not** part of the **right boundary**, and the **right boundary** is empty if the root does not have a right child.\n\nThe **leaves** are nodes that do not have any children. For this problem, the root is **not** a leaf.\n\nGiven the `root` of a binary tree, return _the values of its **boundary**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3,4\\]\n**Output:** \\[1,3,4,2\\]\n**Explanation:**\n- The left boundary is empty because the root does not have a left child.\n- The right boundary follows the path starting from the root's right child 2 -> 4.\n  4 is a leaf, so the right boundary is \\[2\\].\n- The leaves from left to right are \\[3,4\\].\nConcatenating everything results in \\[1\\] + \\[\\] + \\[3,4\\] + \\[2\\] = \\[1,3,4,2\\].\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3,4,5,6,null,null,null,7,8,9,10\\]\n**Output:** \\[1,2,4,7,8,9,10,6,3\\]\n**Explanation:**\n- The left boundary follows the path starting from the root's left child 2 -> 4.\n  4 is a leaf, so the left boundary is \\[2\\].\n- The right boundary follows the path starting from the root's right child 3 -> 6 -> 10.\n  10 is a leaf, so the right boundary is \\[3,6\\], and in reverse order is \\[6,3\\].\n- The leaves from left to right are \\[4,7,8,9,10\\].\nConcatenating everything results in \\[1\\] + \\[2\\] + \\[4,7,8,9,10\\] + \\[6,3\\] = \\[1,2,4,7,8,9,10,6,3\\]."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,2,3,4]",
                "output": "[1,3,4,2]"
            },
            {
                "input": "[1,2,3,4,5,6,null,null,null,7,8,9,10]",
                "output": "[1,2,4,7,8,9,10,6,3]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public void leftBoundary(TreeNode node, List<Integer> boundary) {\n        if (node == null || (node.left == null && node.right == null)) return;\n        boundary.add(node.val);\n        if (node.left != null) leftBoundary(node.left, boundary);\n        else leftBoundary(node.right, boundary);\n    }\n\n    public void rightBoundary(TreeNode node, List<Integer> boundary) {\n        if (node == null || (node.left == null && node.right == null)) return;\n        if (node.right != null) rightBoundary(node.right, boundary);\n        else rightBoundary(node.left, boundary);\n        boundary.add(node.val);\n    }\n\n    public void leaves(TreeNode node, List<Integer> boundary) {\n        if (node == null) return;\n        if (node.left == null && node.right == null) {\n            boundary.add(node.val);\n        }\n        leaves(node.left, boundary);\n        leaves(node.right, boundary);\n    }\n\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) return res;\n        res.add(root.val);\n        leftBoundary(root.left, res);\n        leaves(root, res);\n        rightBoundary(root.right, res);\n        return res;\n    }\n}\n```\n\n    \n    The algorithm consists of two main parts: traversing the tree and appending the values to the boundary list. At a high level, the steps are as follows:\n\n1. If the tree is empty, return an empty list.\n2. Add the root value to the boundary list.\n3. Traverse the left boundary, appending nodes' values as visited. This is done recursively, prioritizing the left child over the right child.\n4. Traverse the tree and append the values of any leaves encountered.\n5. Traverse the right boundary, appending nodes' values as visited. This is done backwards to account for the reverse order requirement of the right boundary.\n\nThe leftBoundary and rightBoundary functions are mostly the same, except the rightBoundary function adds values in reverse. The leaves function traverses the entire tree, adding values of any leaves encountered.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def leftBoundary(self, node, boundary):\n        if not node or not (node.left or node.right):\n            return\n        boundary.append(node.val)\n        if node.left:\n            self.leftBoundary(node.left, boundary)\n        else:\n            self.leftBoundary(node.right, boundary)\n\n    def rightBoundary(self, node, boundary):\n        if not node or not (node.left or node.right):\n            return\n        if node.right:\n            self.rightBoundary(node.right, boundary)\n        else:\n            self.rightBoundary(node.left, boundary)\n        boundary.append(node.val)\n\n    def leaves(self, node, boundary):\n        if not node:\n            return\n        if not (node.left or node.right):\n            boundary.append(node.val)\n        self.leaves(node.left, boundary)\n        self.leaves(node.right, boundary)\n\n    def boundaryOfBinaryTree(self, root):\n        res = []\n        if not root:\n            return res\n        res.append(root.val)\n        self.leftBoundary(root.left, res)\n        self.leaves(root, res)\n        self.rightBoundary(root.right, res)\n        return res\n```\n\n    \n    The algorithm consists of two main parts: traversing the tree and appending the values to the boundary list. At a high level, the steps are as follows:\n\n1. If the tree is empty, return an empty list.\n2. Add the root value to the boundary list.\n3. Traverse the left boundary, appending nodes' values as visited. This is done recursively, prioritizing the left child over the right child.\n4. Traverse the tree and append the values of any leaves encountered.\n5. Traverse the right boundary, appending nodes' values as visited. This is done backwards to account for the reverse order requirement of the right boundary.\n\nThe leftBoundary and rightBoundary functions are mostly the same, except the rightBoundary function adds values in reverse. The leaves function traverses the entire tree, adding values of any leaves encountered.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\npublic:\n    void leftBoundary(TreeNode* node, vector<int>& boundary) {\n        if (!node || (!node->left && !node->right)) return;\n        boundary.push_back(node->val);\n        if (node->left) leftBoundary(node->left, boundary);\n        else leftBoundary(node->right, boundary);\n    }\n\n    void rightBoundary(TreeNode* node, vector<int>& boundary) {\n        if (!node || (!node->left && !node->right)) return;\n        if (node->right) rightBoundary(node->right, boundary);\n        else rightBoundary(node->left, boundary);\n        boundary.push_back(node->val);\n    }\n\n    void leaves(TreeNode* node, vector<int>& boundary) {\n        if (!node) return;\n        if (!node->left && !node->right) {\n            boundary.push_back(node->val);\n        }\n        leaves(node->left, boundary);\n        leaves(node->right, boundary);\n    }\n\n    vector<int> boundaryOfBinaryTree(TreeNode* root) {\n        vector<int> res;\n        if (!root) return res;\n        res.push_back(root->val);\n        leftBoundary(root->left, res);\n        leaves(root, res);\n        rightBoundary(root->right, res);\n        return res;\n    }\n};\n```\n\n    \n    The algorithm consists of two main parts: traversing the tree and appending the values to the boundary list. At a high level, the steps are as follows:\n\n1. If the tree is empty, return an empty list.\n2. Add the root value to the boundary list.\n3. Traverse the left boundary, appending nodes' values as visited. This is done recursively, prioritizing the left child over the right child.\n4. Traverse the tree and append the values of any leaves encountered.\n5. Traverse the right boundary, appending nodes' values as visited. This is done backwards to account for the reverse order requirement of the right boundary.\n\nThe leftBoundary and rightBoundary functions are mostly the same, except the rightBoundary function adds values in reverse. The leaves function traverses the entire tree, adding values of any leaves encountered.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    leftBoundary(node, boundary) {\n        if (!node || (!node.left && !node.right)) return;\n        boundary.push(node.val);\n        if (node.left) this.leftBoundary(node.left, boundary);\n        else this.leftBoundary(node.right, boundary);\n    }\n\n    rightBoundary(node, boundary) {\n        if (!node || (!node.left && !node.right)) return;\n        if (node.right) this.rightBoundary(node.right, boundary);\n        else this.rightBoundary(node.left, boundary);\n        boundary.push(node.val);\n    }\n\n    leaves(node, boundary) {\n        if (!node) return;\n        if (!node.left && !node.right) {\n            boundary.push(node.val);\n        }\n        this.leaves(node.left, boundary);\n        this.leaves(node.right, boundary);\n    }\n\n    boundaryOfBinaryTree(root) {\n        let res = [];\n        if (!root) return res;\n\n        res.push(root.val);\n        this.leftBoundary(root.left, res);\n        this.leaves(root, res);\n        this.rightBoundary(root.right, res);\n        return res;\n    }\n}\n```\n\n    \n    The algorithm consists of two main parts: traversing the tree and appending the values to the boundary list. At a high level, the steps are as follows:\n\n1. If the tree is empty, return an empty list.\n2. Add the root value to the boundary list.\n3. Traverse the left boundary, appending nodes' values as visited. This is done recursively, prioritizing the left child over the right child.\n4. Traverse the tree and append the values of any leaves encountered.\n5. Traverse the right boundary, appending nodes' values as visited. This is done backwards to account for the reverse order requirement of the right boundary.\n\nThe leftBoundary and rightBoundary functions are mostly the same, except the rightBoundary function adds values in reverse. The leaves function traverses the entire tree, adding values of any leaves encountered.\n    "
    },
    {
        "id": 111,
        "title": "Split Array with Equal Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` of length `n`, return `true` if there is a triplet `(i, j, k)` which satisfies the following conditions:\n\n*   `0 < i, i + 1 < j, j + 1 < k < n - 1`\n*   The sum of subarrays `(0, i - 1)`, `(i + 1, j - 1)`, `(j + 1, k - 1)` and `(k + 1, n - 1)` is equal.\n\nA subarray `(l, r)` represents a slice of the original array starting from the element indexed `l` to the element indexed `r`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1\\]\n**Output:** true\n**Explanation:**\ni = 1, j = 3, k = 5. \nsum(0, i - 1) = sum(0, 0) = 1\nsum(i + 1, j - 1) = sum(2, 2) = 1\nsum(j + 1, k - 1) = sum(4, 4) = 1\nsum(k + 1, n - 1) = sum(6, 6) = 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 2000`\n*   `-106 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,1,2,1,2,1]",
                "output": "true"
            },
            {
                "input": "[1,2,1,2,1,2,1,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean find_triplet_equal_sum(int[] nums) {\n    int n = nums.length;\n    int[] prefix_sum = new int[n + 1];\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "python": "\n    ```python\ndef find_triplet_equal_sum(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    for i in range(1, n - 2):\n        for j in range(i + 2, n - 1):\n            for k in range(j + 2, n):\n                s1 = prefix_sum[i]\n                s2 = prefix_sum[j] - prefix_sum[i + 1]\n                s3 = prefix_sum[k] - prefix_sum[j + 1]\n                s4 = prefix_sum[n] - prefix_sum[k + 1]\n                if s1 == s2 == s3 == s4:\n                    return True\n    return False\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "c++": "\n    ```cpp\nbool find_triplet_equal_sum(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefix_sum(n + 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "js": "\n    ```javascript\nfunction find_triplet_equal_sum(nums) {\n    const n = nums.length;\n    const prefix_sum = new Array(n + 1).fill(0);\n\n    for (let i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (let i = 1; i + 2 < n; ++i) {\n        for (let j = i + 2; j + 1 < n; ++j) {\n            for (let k = j + 2; k < n; ++k) {\n                const s1 = prefix_sum[i];\n                const s2 = prefix_sum[j] - prefix_sum[i + 1];\n                const s3 = prefix_sum[k] - prefix_sum[j + 1];\n                const s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 === s2 && s2 === s3 && s3 === s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    "
    },
    {
        "id": 112,
        "title": "Binary Tree Longest Consecutive Sequence II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the length of the longest consecutive path in the tree_.\n\nA consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.\n\n*   For example, `[1,2,3,4]` and `[4,3,2,1]` are both considered valid, but the path `[1,2,4,3]` is not valid.\n\nOn the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** The longest consecutive path is \\[1, 2\\] or \\[2, 1\\].\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** 3\n**Explanation:** The longest consecutive path is \\[1, 2, 3\\] or \\[3, 2, 1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-3 * 104 <= Node.val <= 3 * 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "2"
            },
            {
                "input": "[2,1,3]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic int longestConsecutivePathUtil(TreeNode root, int[] maxLength) {\n    if (root == null) return 0;\n    int left = longestConsecutivePathUtil(root.left, maxLength) + 1;\n    int right = longestConsecutivePathUtil(root.right, maxLength) + 1;\n    if (root.left != null && root.left.val != root.val + 1) left = 1;\n    if (root.right != null && root.right.val != root.val + 1) right = 1;\n    int length = Math.max(left, right);\n    maxLength[0] = Math.max(maxLength[0], left + right - 1);\n    return length;\n}\n\npublic int longestConsecutive(TreeNode root) {\n    int[] maxLength = new int[1];\n    longestConsecutivePathUtil(root, maxLength);\n    return maxLength[0];\n}\n```\n    \n    The algorithm starts traversing the tree in a depth first search (DFS) from the root till each of the leafs. For each consecutive increasing path, it increments the length by one. If a node value breaks the consecutive sequence, it resets the length of that subtree. It keeps track of the maximum length of the consecutive path found so far in any of the subtrees, and updates it when it finds a longer path. Finally, it returns that value.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longest_consecutive(root: TreeNode) -> int:\n    def longest_consecutive_path_util(node, max_length):\n        if not node:\n            return 0\n        left = longest_consecutive_path_util(node.left, max_length) + 1\n        right = longest_consecutive_path_util(node.right, max_length) + 1\n        if node.left and node.left.val != node.val + 1:\n            left = 1\n        if node.right and node.right.val != node.val + 1:\n            right = 1\n        length = max(left, right)\n        max_length[0] = max(max_length[0], left + right - 1)\n        return length\n\n    max_length = [0]\n    longest_consecutive_path_util(root, max_length)\n    return max_length[0]\n```\n    \n    The algorithm starts traversing the tree in a depth first search (DFS) from the root till each of the leafs. For each consecutive increasing path, it increments the length by one. If a node value breaks the consecutive sequence, it resets the length of that subtree. It keeps track of the maximum length of the consecutive path found so far in any of the subtrees, and updates it when it finds a longer path. Finally, it returns that value.\n    ",
        "c++": "\n    ```cpp\n#include<algorithm>\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nint longestConsecutivePathUtil(TreeNode* root, int& maxLength) {\n    if (root == nullptr) return 0;\n    int left = longestConsecutivePathUtil(root->left, maxLength) + 1;\n    int right = longestConsecutivePathUtil(root->right, maxLength) + 1;\n    if (root->left != nullptr && root->left->val != root->val + 1) left = 1;\n    if (root->right != nullptr && root->right->val != root->val + 1) right = 1;\n    int length = std::max(left, right);\n    maxLength = std::max(maxLength, left + right - 1);\n    return length;\n}\n\nint longestConsecutive(TreeNode* root) {\n    int maxLength = 0;\n    longestConsecutivePathUtil(root, maxLength);\n    return maxLength;\n}\n```\n    \n    The algorithm starts traversing the tree in a depth first search (DFS) from the root till each of the leafs. For each consecutive increasing path, it increments the length by one. If a node value breaks the consecutive sequence, it resets the length of that subtree. It keeps track of the maximum length of the consecutive path found so far in any of the subtrees, and updates it when it finds a longer path. Finally, it returns that value.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction longestConsecutivePath(root) {\n    function longestConsecutivePathUtil(node, maxLength) {\n        if (!node) {\n            return 0;\n        }\n        let left = longestConsecutivePathUtil(node.left, maxLength) + 1;\n        let right = longestConsecutivePathUtil(node.right, maxLength) + 1;\n        if (node.left && node.left.val !== node.val + 1) {\n            left = 1;\n        }\n        if (node.right && node.right.val !== node.val + 1) {\n            right = 1;\n        }\n        let length = Math.max(left, right);\n        maxLength[0] = Math.max(maxLength[0], left + right - 1);\n        return length;\n    }\n\n    let maxLength = [0];\n    longestConsecutivePathUtil(root, maxLength);\n    return maxLength[0];\n}\n```\n    \n    The algorithm starts traversing the tree in a depth first search (DFS) from the root till each of the leafs. For each consecutive increasing path, it increments the length by one. If a node value breaks the consecutive sequence, it resets the length of that subtree. It keeps track of the maximum length of the consecutive path found so far in any of the subtrees, and updates it when it finds a longer path. Finally, it returns that value.\n    "
    },
    {
        "id": 113,
        "title": "Split Concatenated Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of strings `strs`. You could concatenate these strings together into a loop, where for each string, you could choose to reverse it or not. Among all the possible loops\n\nReturn _the lexicographically largest string after cutting the loop, which will make the looped string into a regular one_.\n\nSpecifically, to find the lexicographically largest string, you need to experience two phases:\n\n1.  Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.\n2.  Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint.\n\nAnd your job is to find the lexicographically largest one among all the possible regular strings.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"abc \", \"xyz \"\\]\n**Output:**  \"zyxcba \"\n**Explanation:** You can get the looped string  \"-abcxyz- \",  \"-abczyx- \",  \"-cbaxyz- \",  \"-cbazyx- \", where '-' represents the looped status. \nThe answer string came from the fourth looped one, where you could cut from the middle character 'a' and get  \"zyxcba \".\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"abc \"\\]\n**Output:**  \"cba \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 1000`\n*   `1 <= strs[i].length <= 1000`\n*   `1 <= sum(strs[i].length) <= 1000`\n*   `strs[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"abc\",\"xyz\"]",
                "output": "\"zyxcba\""
            },
            {
                "input": "[\"abc\"]",
                "output": "\"cba\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String splitLoopedString(String[] strs) {\n    String ans = \"\", cur = \"\";\n    for (String s : strs) {\n        String rev = new StringBuilder(s).reverse().toString();\n        cur += (s.compareTo(rev) > 0) ? s : rev;\n    }\n\n    for (int i = 0, k = 0; i < strs.length; i++) {\n        String rev = new StringBuilder(strs[i]).reverse().toString();\n        for (String xstr : Arrays.asList(strs[i], rev)) {\n            for (int j = 0; j < xstr.length(); j++) {\n                String t = xstr.substring(j) + cur.substring(k + xstr.length()) + cur.substring(0, k) + xstr.substring(0, j);\n                ans = ans.compareTo(t) > 0 ? ans : t;\n            }\n        }\n        k += strs[i].length();\n    }\n    return ans;\n}\n```\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    ",
        "python": "\n    ```python\ndef splitLoopedString(strs):\n    ans = ''\n    cur = ''.join(max(s, s[::-1]) for s in strs)\n    \n    for i, s in enumerate(strs):\n        for xstr in (s, s[::-1]):\n            for j in range(len(xstr)):\n                t = xstr[j:] + cur[len(xstr):] + cur[:len(xstr)] + xstr[:j]\n                ans = max(ans, t)\n        cur = cur[len(s):] + cur[:len(s)]\n    \n    return ans\n```\n\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string splitLoopedString(std::vector<std::string>& strs) {\n    std::string ans;\n    std::string cur;\n    for (auto &s : strs) {\n        std::string rev(s.rbegin(), s.rend());\n        cur += std::max(s, rev);\n    }\n\n    for (size_t i = 0, k = 0; i < strs.size(); ++i) {\n        std::string rev(strs[i].rbegin(), strs[i].rend());\n        for (auto &xstr : {strs[i], rev}) {\n            for (size_t j = 0; j < xstr.size(); ++j) {\n                std::string t = xstr.substr(j) + cur.substr(k + xstr.size()) + cur.substr(0, k) + xstr.substr(0, j);\n                ans = std::max(ans, t);\n            }\n        }\n        k += strs[i].size();\n    }\n    return ans;\n}\n```\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    ",
        "js": "\n    ```javascript\nfunction splitLoopedString(strs) {\n    let ans = \"\", cur = \"\";\n    strs.forEach(s => {\n        const rev = s.split('').reverse().join('');\n        cur += s > rev ? s : rev;\n    });\n\n    for (let i = 0, k = 0; i < strs.length; i++) {\n        let rev = strs[i].split('').reverse().join('');\n        [strs[i], rev].forEach(xstr => {\n            for (let j = 0; j < xstr.length; j++) {\n                let t = xstr.slice(j) + cur.slice(k + xstr.length) + cur.slice(0, k) + xstr.slice(0, j);\n                ans = ans > t ? ans : t;\n            }\n        });\n        k += strs[i].length;\n    }\n    return ans;\n}\n```\n    \n    The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L).\n    "
    },
    {
        "id": 114,
        "title": "Longest Line of Consecutive One in Matrix",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` binary matrix `mat`, return _the length of the longest line of consecutive one in the matrix_.\n\nThe line could be horizontal, vertical, diagonal, or anti-diagonal.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\]\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,1,1,1\\],\\[0,1,1,0\\],\\[0,0,0,1\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1,1,0],[0,1,1,0],[0,0,0,1]]",
                "output": "3"
            },
            {
                "input": "[[1,1,1,1],[0,1,1,0],[0,0,0,1]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int longestLine(int[][] mat) {\n    int rows = mat.length;\n    int cols = mat[0].length;\n    int max_length = 0;\n    int[][][] dp = new int[rows][cols][4];\n\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            if (mat[r][c] == 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = Math.max(max_length, Math.max(dp[r][c][0], Math.max(dp[r][c][1], Math.max(dp[r][c][2], dp[r][c][3]))));\n            }\n        }\n    }\n    return max_length;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array.\n    ",
        "python": "\n    ```python\ndef longestLine(mat):\n    rows, cols = len(mat), len(mat[0])\n    max_length = 0\n    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if mat[r][c] == 1:\n                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1\n                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1\n                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1\n                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1\n                max_length = max(max_length, max(dp[r][c]))\n\n    return max_length\n```\n\n    \n    The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array.\n    ",
        "c++": "\n    ```cpp\nint longestLine(vector<vector<int>>& mat) {\n    int rows = mat.size();\n    int cols = mat[0].size();\n    int max_length = 0;\n    vector<vector<vector<int>>> dp(rows, vector<vector<int>>(cols, vector<int>(4, 0)));\n\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            if (mat[r][c] == 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = max(max_length, max(dp[r][c][0], max(dp[r][c][1], max(dp[r][c][2], dp[r][c][3]))));\n            }\n        }\n    }\n    return max_length;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array.\n    ",
        "js": "\n    ```javascript\nfunction longestLine(mat) {\n    const rows = mat.length;\n    const cols = mat[0].length;\n    let max_length = 0;\n    const dp = Array.from(Array(rows), () => Array.from(Array(cols), () => Array(4).fill(0)));\n\n    for (let r = 0; r < rows; ++r) {\n        for (let c = 0; c < cols; ++c) {\n            if (mat[r][c] === 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = Math.max(max_length, Math.max(...dp[r][c]));\n            }\n        }\n    }\n    return max_length;\n}\n```\n\n    \n    The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array.\n    "
    },
    {
        "id": 115,
        "title": "Maximum Vacation Days",
        "difficulty": "Hard",
        "content": {
            "problem": "LeetCode wants to give one of its best employees the option to travel among `n` cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\n\nRules and restrictions:\n\n1.  You can only travel among `n` cities, represented by indexes from `0` to `n - 1`. Initially, you are in the city indexed `0` on **Monday**.\n2.  The cities are connected by flights. The flights are represented as an `n x n` matrix (not necessarily symmetrical), called `flights` representing the airline status from the city `i` to the city `j`. If there is no flight from the city `i` to the city `j`, `flights[i][j] == 0`; Otherwise, `flights[i][j] == 1`. Also, `flights[i][i] == 0` for all `i`.\n3.  You totally have `k` weeks (each week has **seven days**) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we do not consider the impact of flight time.\n4.  For each city, you can only have restricted vacation days in different weeks, given an `n x k` matrix called `days` representing this relationship. For the value of `days[i][j]`, it represents the maximum days you could take a vacation in the city `i` in the week `j`.\n5.  You could stay in a city beyond the number of vacation days, but you should work on the extra days, which will not be counted as vacation days.\n6.  If you fly from city `A` to city `B` and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city `B` in that week.\n7.  We do not consider the impact of flight hours on the calculation of vacation days.\n\nGiven the two matrices `flights` and `days`, return _the maximum vacation days you could take during_ `k` _weeks_.",
            "examples": [
                "**Example 1:**\n\n**Input:** flights = \\[\\[0,1,1\\],\\[1,0,1\\],\\[1,1,0\\]\\], days = \\[\\[1,3,1\\],\\[6,0,3\\],\\[3,3,3\\]\\]\n**Output:** 12\n**Explanation:**\nOne of the best strategies is:\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.\n(Although you start at city 0, we could also fly to and start at other cities since it is Monday.)\n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\n3rd week : stay at city 2, and play 3 days and work 4 days.\nAns = 6 + 3 + 3 = 12.\n\n",
                "**Example 2:**\n\n**Input:** flights = \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\], days = \\[\\[1,1,1\\],\\[7,7,7\\],\\[7,7,7\\]\\]\n**Output:** 3\n**Explanation:**\nSince there are no flights that enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. \nFor each week, you only have one day to play and six days to work.\nSo the maximum number of vacation days is 3.\nAns = 1 + 1 + 1 = 3.\n\n",
                "**Example 3:**\n\n**Input:** flights = \\[\\[0,1,1\\],\\[1,0,1\\],\\[1,1,0\\]\\], days = \\[\\[7,0,0\\],\\[0,7,0\\],\\[0,0,7\\]\\]\n**Output:** 21\n**Explanation:**\nOne of the best strategies is:\n1st week : stay at city 0, and play 7 days.\n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\nAns = 7 + 7 + 7 = 21"
            ],
            "constraints": "**Constraints:**\n\n*   `n == flights.length`\n*   `n == flights[i].length`\n*   `n == days.length`\n*   `k == days[i].length`\n*   `1 <= n, k <= 100`\n*   `flights[i][j]` is either `0` or `1`.\n*   `0 <= days[i][j] <= 7`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1,1],[1,0,1],[1,1,0]],[[1,3,1],[6,0,3],[3,3,3]]",
                "output": "12"
            },
            {
                "input": "[[0,0,0],[0,0,0],[0,0,0]],[[1,1,1],[7,7,7],[7,7,7]]",
                "output": "3"
            },
            {
                "input": "[[0,1,1],[1,0,1],[1,1,0]],[[7,0,0],[0,7,0],[0,0,7]]",
                "output": "21"
            }
        ],
        "java": "\n    ```java\npublic int maxVacationDays(int[][] flights, int[][] days) {\n    int n = flights.length;\n    int k = days[0].length;\n    int[][] memo = new int[n][k];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(memo[i], -1);\n    }\n    return dfs(flights, days, 0, 0, memo);\n}\n\nprivate int dfs(int[][] flights, int[][] days, int week, int city, int[][] memo) {\n    int numCities = flights.length;\n    int numWeeks = days[0].length;\n\n    if (week == numWeeks) {\n        return 0;\n    }\n\n    if (memo[city][week] != -1) {\n        return memo[city][week];\n    }\n\n    int maxVacation = days[city][week] + dfs(flights, days, week + 1, city, memo);\n\n    for (int i = 0; i < numCities; i++) {\n        if (flights[city][i] == 1) {\n            maxVacation = Math.max(maxVacation, days[i][week] + dfs(flights, days, week + 1, i, memo));\n        }\n    }\n\n    memo[city][week] = maxVacation;\n    return maxVacation;\n}\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "python": "\n    ```python\ndef maxVacationDays(flights, days):\n    n = len(flights)\n    k = len(days[0])\n    memo = [[-1] * k for _ in range(n)]\n\n    def dfs(currentWeek, currentCity):\n        if currentWeek == k:\n            return 0\n        if memo[currentCity][currentWeek] != -1:\n            return memo[currentCity][currentWeek]\n\n        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)\n\n        for i in range(n):\n            if flights[currentCity][i] == 1:\n                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))\n\n        memo[currentCity][currentWeek] = maxVacation\n        return maxVacation\n\n    return dfs(0, 0)\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "c++": "\n    ```cpp\nint dfs(const vector<vector<int>>& flights, const vector<vector<int>>& days, int currentWeek, int currentCity, vector<vector<int>>& memo) {\n    if (currentWeek == days[currentCity].size()) {\n        return 0;\n    }\n    if (memo[currentCity][currentWeek] != -1) {\n        return memo[currentCity][currentWeek];\n    }\n\n    int maxVacation = days[currentCity][currentWeek] + dfs(flights, days, currentWeek + 1, currentCity, memo);\n\n    for (int i = 0; i < flights.size(); i++) {\n        if (flights[currentCity][i] == 1) {\n            maxVacation = max(maxVacation, days[i][currentWeek] + dfs(flights, days, currentWeek + 1, i, memo));\n        }\n    }\n\n    memo[currentCity][currentWeek] = maxVacation;\n    return maxVacation;\n}\n\nint maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\n    vector<vector<int>> memo(flights.size(), vector<int>(days[0].size(), -1));\n    return dfs(flights, days, 0, 0, memo);\n}\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "js": "\n    ```javascript\nfunction maxVacationDays(flights, days) {\n    let n = flights.length;\n    let k = days[0].length;\n    let memo = new Array(n).fill(null).map(() => new Array(k).fill(-1));\n\n    function dfs(week, city) {\n        if (week === k) {\n            return 0;\n        }\n        if (memo[city][week] !== -1) {\n            return memo[city][week];\n        }\n\n        let maxVacation = days[city][week] + dfs(week + 1, city);\n\n        for (let i = 0; i < n; i++) {\n            if (flights[city][i] === 1) {\n                maxVacation = Math.max(maxVacation, days[i][week] + dfs(week + 1, i));\n            }\n        }\n\n        memo[city][week] = maxVacation;\n        return maxVacation;\n    }\n\n    return dfs(0, 0);\n}\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    "
    },
    {
        "id": 116,
        "title": "Squirrel Simulation",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two integers `height` and `width` representing a garden of size `height x width`. You are also given:\n\n*   an array `tree` where `tree = [treer, treec]` is the position of the tree in the garden,\n*   an array `squirrel` where `squirrel = [squirrelr, squirrelc]` is the position of the squirrel in the garden,\n*   and an array `nuts` where `nuts[i] = [nutir, nutic]` is the position of the `ith` nut in the garden.\n\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn _the **minimal distance** for the squirrel to collect all the nuts and put them under the tree one by one_.\n\nThe **distance** is the number of moves.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = 5, width = 7, tree = \\[2,2\\], squirrel = \\[4,4\\], nuts = \\[\\[3,0\\], \\[2,5\\]\\]\n**Output:** 12\n**Explanation:** The squirrel should go to the nut at \\[2, 5\\] first to achieve a minimal distance.\n\n",
                "**Example 2:**\n\n**Input:** height = 1, width = 3, tree = \\[0,1\\], squirrel = \\[0,0\\], nuts = \\[\\[0,2\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= height, width <= 100`\n*   `tree.length == 2`\n*   `squirrel.length == 2`\n*   `1 <= nuts.length <= 5000`\n*   `nuts[i].length == 2`\n*   `0 <= treer, squirrelr, nutir <= height`\n*   `0 <= treec, squirrelc, nutic <= width`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,7,[2,2],[4,4],[[3,0],[2,5]]",
                "output": "12"
            },
            {
                "input": "1,3,[0,1],[0,0],[[0,2]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {\n    int totalDist = 0;\n    int minDiff = Integer.MAX_VALUE;\n    \n    for (int[] nut : nuts) {\n        int treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);\n        int squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = Math.min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}\n```\n\n    \n    Our main goal in this problem is to minimize the total distance. We will loop through all the nuts and calculate the distance between the squirrel and the nut, and the distance between the tree and the nut. We have to double the tree distance due to the squirrel having to come back to the tree. After calculating the distances, we subtract the tree distance from the squirrel distance and find the minimum difference. The total distance is the sum of all the doubled tree distances and the minimum difference.\n    ",
        "python": "\n    ```python\ndef minDistance(height, width, tree, squirrel, nuts):\n    totalDist = 0\n    minDiff = float(\"inf\")\n    \n    for nut in nuts:\n        treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1])\n        squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1])\n        \n        totalDist += 2 * treeDist\n        minDiff = min(minDiff, squirrelDist - treeDist)\n    \n    return totalDist + minDiff\n```\n\n    \n    Our main goal in this problem is to minimize the total distance. We will loop through all the nuts and calculate the distance between the squirrel and the nut, and the distance between the tree and the nut. We have to double the tree distance due to the squirrel having to come back to the tree. After calculating the distances, we subtract the tree distance from the squirrel distance and find the minimum difference. The total distance is the sum of all the doubled tree distances and the minimum difference.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint minDistance(int height, int width, vector<int>& tree, vector<int>& squirrel, vector<vector<int>>& nuts) {\n    int totalDist = 0;\n    int minDiff = INT_MAX;\n    \n    for (vector<int>& nut : nuts) {\n        int treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]);\n        int squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}\n```\n\n    \n    Our main goal in this problem is to minimize the total distance. We will loop through all the nuts and calculate the distance between the squirrel and the nut, and the distance between the tree and the nut. We have to double the tree distance due to the squirrel having to come back to the tree. After calculating the distances, we subtract the tree distance from the squirrel distance and find the minimum difference. The total distance is the sum of all the doubled tree distances and the minimum difference.\n    ",
        "js": "\n    ```javascript\nfunction minDistance(height, width, tree, squirrel, nuts) {\n    let totalDist = 0;\n    let minDiff = Infinity;\n    \n    for (let nut of nuts) {\n        let treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);\n        let squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = Math.min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}\n```\n\n    \n    Our main goal in this problem is to minimize the total distance. We will loop through all the nuts and calculate the distance between the squirrel and the nut, and the distance between the tree and the nut. We have to double the tree distance due to the squirrel having to come back to the tree. After calculating the distances, we subtract the tree distance from the squirrel distance and find the minimum difference. The total distance is the sum of all the doubled tree distances and the minimum difference.\n    "
    },
    {
        "id": 117,
        "title": "Kill Process",
        "difficulty": "Medium",
        "content": {
            "problem": "You have `n` processes forming a rooted tree structure. You are given two integer arrays `pid` and `ppid`, where `pid[i]` is the ID of the `ith` process and `ppid[i]` is the ID of the `ith` process's parent process.\n\nEach process has only **one parent process** but may have multiple children processes. Only one process has `ppid[i] = 0`, which means this process has **no parent process** (the root of the tree).\n\nWhen a process is **killed**, all of its children processes will also be killed.\n\nGiven an integer `kill` representing the ID of a process you want to kill, return _a list of the IDs of the processes that will be killed. You may return the answer in **any order**._",
            "examples": [
                "**Example 1:**\n\n**Input:** pid = \\[1,3,10,5\\], ppid = \\[3,0,5,3\\], kill = 5\n**Output:** \\[5,10\\]\n**Explanation:** The processes colored in red are the processes that should be killed.\n\n",
                "**Example 2:**\n\n**Input:** pid = \\[1\\], ppid = \\[0\\], kill = 1\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == pid.length`\n*   `n == ppid.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= pid[i] <= 5 * 104`\n*   `0 <= ppid[i] <= 5 * 104`\n*   Only one process has no parent.\n*   All the values of `pid` are **unique**.\n*   `kill` is **guaranteed** to be in `pid`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,3,10,5],[3,0,5,3],5",
                "output": "[5,10]"
            },
            {
                "input": "[1],[0],1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {\n    Map<Integer, List<Integer>> children = new HashMap<>();\n    for (int i = 0; i < pid.size(); i++) {\n        children.computeIfAbsent(ppid.get(i), k -> new ArrayList<>()).add(pid.get(i));\n    }\n\n    List<Integer> killed = new ArrayList<>();\n    dfs(kill, children, killed);\n    return killed;\n}\n\nprivate void dfs(int id, Map<Integer, List<Integer>> children, List<Integer> killed) {\n    killed.add(id);\n    for (int child : children.getOrDefault(id, new ArrayList<>())) {\n        dfs(child, children, killed);\n    }\n}\n```\n    \n    We use a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, Map in JavaScript) to store the children of each process. We iterate through the `pid` and `ppid` arrays to construct a tree-like data structure in the `children` map.\n\nWe then perform a depth-first search (DFS) starting from the `kill` process to traverse the tree and add all the processes to the `killed` list. The DFS function is implemented in a recursive manner, where we first add the current process id to the list `killed` and then iterate through its children.\n\nWe call the `dfs` function with the `kill` process id to construct the `killed` list and then return it.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef killProcess(pid, ppid, kill):\n    children = defaultdict(list)\n    for i in range(len(pid)):\n        children[ppid[i]].append(pid[i])\n\n    def dfs(id, killed):\n        killed.append(id)\n        for child in children[id]:\n            dfs(child, killed)\n\n    killed = []\n    dfs(kill, killed)\n    return killed\n```\n    \n    We use a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, Map in JavaScript) to store the children of each process. We iterate through the `pid` and `ppid` arrays to construct a tree-like data structure in the `children` map.\n\nWe then perform a depth-first search (DFS) starting from the `kill` process to traverse the tree and add all the processes to the `killed` list. The DFS function is implemented in a recursive manner, where we first add the current process id to the list `killed` and then iterate through its children.\n\nWe call the `dfs` function with the `kill` process id to construct the `killed` list and then return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {\n    unordered_map<int, vector<int>> children;\n    for (int i = 0; i < pid.size(); i++) {\n        children[ppid[i]].push_back(pid[i]);\n    }\n\n    vector<int> killed;\n    function<void(int)> dfs = [&](int id) {\n        killed.push_back(id);\n        for (int child : children[id]) {\n            dfs(child);\n        }\n    };\n    dfs(kill);\n\n    return killed;\n}\n```\n    \n    We use a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, Map in JavaScript) to store the children of each process. We iterate through the `pid` and `ppid` arrays to construct a tree-like data structure in the `children` map.\n\nWe then perform a depth-first search (DFS) starting from the `kill` process to traverse the tree and add all the processes to the `killed` list. The DFS function is implemented in a recursive manner, where we first add the current process id to the list `killed` and then iterate through its children.\n\nWe call the `dfs` function with the `kill` process id to construct the `killed` list and then return it.\n    ",
        "js": "\n    ```javascript\nfunction killProcess(pid, ppid, kill) {\n  const children = new Map();\n  for (let i = 0; i < pid.length; i++) {\n    if (!children.has(ppid[i])) children.set(ppid[i], []);\n    children.get(ppid[i]).push(pid[i]);\n  }\n\n  const killed = [];\n  function dfs(id) {\n    killed.push(id);\n    const childList = children.get(id) || [];\n    for (const child of childList) {\n      dfs(child);\n    }\n  }\n  dfs(kill);\n\n  return killed;\n}\n```\n    \n    We use a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, Map in JavaScript) to store the children of each process. We iterate through the `pid` and `ppid` arrays to construct a tree-like data structure in the `children` map.\n\nWe then perform a depth-first search (DFS) starting from the `kill` process to traverse the tree and add all the processes to the `killed` list. The DFS function is implemented in a recursive manner, where we first add the current process id to the list `killed` and then iterate through its children.\n\nWe call the `dfs` function with the `kill` process id to construct the `killed` list and then return it.\n    "
    },
    {
        "id": 118,
        "title": "Design In-Memory File System",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a data structure that simulates an in-memory file system.\n\nImplement the FileSystem class:\n\n*   `FileSystem()` Initializes the object of the system.\n*   `List ls(String path)`\n    \n    *   If `path` is a file path, returns a list that only contains this file's name.\n    *   If `path` is a directory path, returns the list of file and directory names **in this directory**.\n    \n    The answer should in **lexicographic order**.\n*   `void mkdir(String path)` Makes a new directory according to the given `path`. The given directory path does not exist. If the middle directories in the path do not exist, you should create them as well.\n*   `void addContentToFile(String filePath, String content)`\n    *   If `filePath` does not exist, creates that file containing given `content`.\n    *   If `filePath` already exists, appends the given `content` to original content.\n*   `String readContentFromFile(String filePath)` Returns the content in the file at `filePath`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"FileSystem \",  \"ls \",  \"mkdir \",  \"addContentToFile \",  \"ls \",  \"readContentFromFile \"\\]\n\\[\\[\\], \\[ \"/ \"\\], \\[ \"/a/b/c \"\\], \\[ \"/a/b/c/d \",  \"hello \"\\], \\[ \"/ \"\\], \\[ \"/a/b/c/d \"\\]\\]\n**Output**\n\\[null, \\[\\], null, null, \\[ \"a \"\\],  \"hello \"\\]\n\n**Explanation**\nFileSystem fileSystem = new FileSystem();\nfileSystem.ls( \"/ \");                         // return \\[\\]\nfileSystem.mkdir( \"/a/b/c \");\nfileSystem.addContentToFile( \"/a/b/c/d \",  \"hello \");\nfileSystem.ls( \"/ \");                         // return \\[ \"a \"\\]\nfileSystem.readContentFromFile( \"/a/b/c/d \"); // return  \"hello \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= path.length, filePath.length <= 100`\n*   `path` and `filePath` are absolute paths which begin with `'/'` and do not end with `'/'` except that the path is just `\"/ \"`.\n*   You can assume that all directory names and file names only contain lowercase letters, and the same names will not exist in the same directory.\n*   You can assume that all operations will be passed valid parameters, and users will not attempt to retrieve file content or list a directory or file that does not exist.\n*   `1 <= content.length <= 50`\n*   At most `300` calls will be made to `ls`, `mkdir`, `addContentToFile`, and `readContentFromFile`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,[],null,null,[\"a\"],\"hello\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass FileSystem {\n    class Node {\n        boolean isFile = false;\n        String content = \"\";\n        Map<String, Node> children = new TreeMap<>();\n    }\n\n    Node root;\n\n    public FileSystem() {\n        root = new Node();\n    }\n\n    public List<String> ls(String path) {\n        Node node = root;\n        List<String> path_parts = splitPath(path);\n\n        for (String part : path_parts) {\n            node = node.children.get(part);\n        }\n\n        if (node.isFile) {\n            return Collections.singletonList(path_parts.get(path_parts.size() - 1));\n        } else {\n            return new ArrayList<>(node.children.keySet());\n        }\n    }\n\n    public void mkdir(String path) {\n        Node node = root;\n        List<String> path_parts = splitPath(path);\n\n        for (String part : path_parts) {\n            node.children.putIfAbsent(part, new Node());\n            node = node.children.get(part);\n        }\n    }\n\n    public void addContentToFile(String filePath, String content) {\n        Node node = root;\n        List<String> path_parts = splitPath(filePath);\n\n        for (String part : path_parts) {\n            node.children.putIfAbsent(part, new Node());\n            node = node.children.get(part);\n        }\n\n        node.isFile = true;\n        node.content += content;\n    }\n\n    public String readContentFromFile(String filePath) {\n        Node node = root;\n        List<String> path_parts = splitPath(filePath);\n\n        for (String part : path_parts) {\n            node = node.children.get(part);\n        }\n\n        return node.content;\n    }\n\n    private List<String> splitPath(String path) {\n        List<String> parts = new ArrayList<>();\n        String[] tokens = path.split(\"/\");\n        for (String token : tokens) {\n            if (!token.isEmpty()) {\n                parts.add(token);\n            }\n        }\n        return parts;\n    }\n}\n```\n    \n    The algorithm uses a Trie-like data structure to represent the file system. Each node in the Trie can represent both a file and a folder. We use two hash maps to store folder and file content respectively. When performing CRUD operations (ls, mkdir, addContentToFile, readContentFromFile), we traverse the Trie based on the path and find the corresponding node, then perform the operation accordingly. When returning the string lists or file content, we sort folder names lexicographically.\n    ",
        "python": "\n    ```python\nclass FileSystem:\n    class Node:\n        def __init__(self):\n            self.is_file = False\n            self.content = \"\"\n            self.children = {}\n\n    def __init__(self):\n        self.root = self.Node()\n\n    def ls(self, path: str):\n        node = self.root\n        path_parts = self.split_path(path)\n\n        for part in path_parts:\n            node = node.children[part]\n\n        if node.is_file:\n            return path_parts[-1:]\n        else:\n            return sorted(node.children.keys())\n\n    def mkdir(self, path: str):\n        node = self.root\n        path_parts = self.split_path(path)\n\n        for part in path_parts:\n            if part not in node.children:\n                node.children[part] = self.Node()\n            node = node.children[part]\n\n    def addContentToFile(self, filePath: str, content: str):\n        node = self.root\n        path_parts = self.split_path(filePath)\n\n        for part in path_parts:\n            if part not in node.children:\n                node.children[part] = self.Node()\n            node = node.children[part]\n\n        node.is_file = True\n        node.content += content\n\n    def readContentFromFile(self, filePath: str) -> str:\n        node = self.root\n        path_parts = self.split_path(filePath)\n\n        for part in path_parts:\n            node = node.children[part]\n\n        return node.content\n\n    @staticmethod\n    def split_path(path: str):\n        return [part for part in path.split(\"/\") if part]\n\n```\n    \n    The algorithm uses a Trie-like data structure to represent the file system. Each node in the Trie can represent both a file and a folder. We use two hash maps to store folder and file content respectively. When performing CRUD operations (ls, mkdir, addContentToFile, readContentFromFile), we traverse the Trie based on the path and find the corresponding node, then perform the operation accordingly. When returning the string lists or file content, we sort folder names lexicographically.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nclass FileSystem {\n    struct Node {\n        bool is_file = false;\n        std::string content;\n        std::map<std::string, Node*> children;\n    };\n\n    Node* root;\n\npublic:\n    FileSystem() {\n        root = new Node();\n    }\n\n    std::vector<std::string> ls(std::string path) {\n        Node* node = root;\n        std::vector<std::string> path_parts = split_path(path);\n\n        for (const std::string& part : path_parts) {\n            node = node->children[part];\n        }\n\n        if (node->is_file) {\n            return {path_parts.back()};\n        } else {\n            std::vector<std::string> files;\n            for (const auto& child : node->children) {\n                files.push_back(child.first);\n            }\n            std::sort(files.begin(), files.end());\n            return files;\n        }\n    }\n\n    void mkdir(std::string path) {\n        Node* node = root;\n        std::vector<std::string> path_parts = split_path(path);\n\n        for (const std::string& part : path_parts) {\n            if (node->children.find(part) == node->children.end()) {\n                node->children[part] = new Node();\n            }\n            node = node->children[part];\n        }\n    }\n\n    void addContentToFile(std::string filePath, std::string content) {\n        Node* node = root;\n        std::vector<std::string> path_parts = split_path(filePath);\n\n        for (const std::string& part : path_parts) {\n            if (node->children.find(part) == node->children.end()) {\n                node->children[part] = new Node();\n            }\n            node = node->children[part];\n        }\n\n        node->is_file = true;\n        node->content += content;\n    }\n\n    std::string readContentFromFile(std::string filePath) {\n        Node* node = root;\n        std::vector<std::string> path_parts = split_path(filePath);\n\n        for (const std::string& part : path_parts) {\n            node = node->children[part];\n        }\n\n        return node->content;\n    }\n\nprivate:\n    std::vector<std::string> split_path(const std::string& path) {\n        std::vector<std::string> parts;\n        std::istringstream ss(path);\n        std::string part;\n\n        while (std::getline(ss, part, '/')) {\n            if (!part.empty()) {\n                parts.push_back(part);\n            }\n        }\n\n        return parts;\n    }\n};\n```\n    \n    The algorithm uses a Trie-like data structure to represent the file system. Each node in the Trie can represent both a file and a folder. We use two hash maps to store folder and file content respectively. When performing CRUD operations (ls, mkdir, addContentToFile, readContentFromFile), we traverse the Trie based on the path and find the corresponding node, then perform the operation accordingly. When returning the string lists or file content, we sort folder names lexicographically.\n    ",
        "js": "\n    ```javascript\nclass FileSystem {\n    constructor() {\n        this.root = new this.Node();\n    }\n\n    ls(path) {\n        let node = this.root;\n        const pathParts = this.splitPath(path);\n\n        for (const part of pathParts) {\n            node = node.children[part];\n        }\n\n        if (node.isFile) {\n            return [pathParts[pathParts.length - 1]];\n        } else {\n            return Object.keys(node.children).sort();\n        }\n    }\n\n    mkdir(path) {\n        let node = this.root;\n        const pathParts = this.splitPath(path);\n\n        for (const part of pathParts) {\n            if (!node.children[part]) {\n                node.children[part] = new this.Node();\n            }\n            node = node.children[part];\n        }\n    }\n\n    addContentToFile(filePath, content) {\n        let node = this.root;\n        const pathParts = this.splitPath(filePath);\n\n        for (const part of pathParts) {\n            if (!node.children[part]) {\n                node.children[part] = new this.Node();\n            }\n            node = node.children[part];\n        }\n\n        node.isFile = true;\n        node.content += content;\n    }\n\n    readContentFromFile(filePath) {\n        let node = this.root;\n        const pathParts = this.splitPath(filePath);\n\n        for (const part of pathParts) {\n            node = node.children[part];\n        }\n\n        return node.content;\n    }\n\n    splitPath(path) {\n        return path.split('/').filter(part => part);\n    }\n\n    Node() {\n        this.isFile = false;\n        this.content = '';\n        this.children = {};\n    }\n}\n```\n    \n    The algorithm uses a Trie-like data structure to represent the file system. Each node in the Trie can represent both a file and a folder. We use two hash maps to store folder and file content respectively. When performing CRUD operations (ls, mkdir, addContentToFile, readContentFromFile), we traverse the Trie based on the path and find the corresponding node, then perform the operation accordingly. When returning the string lists or file content, we sort folder names lexicographically.\n    "
    },
    {
        "id": 119,
        "title": "Design Compressed String Iterator",
        "difficulty": "Easy",
        "content": {
            "problem": "Design and implement a data structure for a compressed string iterator. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.\n\nImplement the StringIterator class:\n\n*   `next()` Returns **the next character** if the original string still has uncompressed characters, otherwise returns a **white space**.\n*   `hasNext()` Returns true if there is any letter needs to be uncompressed in the original string, otherwise returns `false`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"StringIterator \",  \"next \",  \"next \",  \"next \",  \"next \",  \"next \",  \"next \",  \"hasNext \",  \"next \",  \"hasNext \"\\]\n\\[\\[ \"L1e2t1C1o1d1e1 \"\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null,  \"L \",  \"e \",  \"e \",  \"t \",  \"C \",  \"o \", true,  \"d \", true\\]\n\n**Explanation**\nStringIterator stringIterator = new StringIterator( \"L1e2t1C1o1d1e1 \");\nstringIterator.next(); // return  \"L \"\nstringIterator.next(); // return  \"e \"\nstringIterator.next(); // return  \"e \"\nstringIterator.next(); // return  \"t \"\nstringIterator.next(); // return  \"C \"\nstringIterator.next(); // return  \"o \"\nstringIterator.hasNext(); // return True\nstringIterator.next(); // return  \"d \"\nstringIterator.hasNext(); // return True"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= compressedString.length <= 1000`\n*   `compressedString` consists of lower-case an upper-case English letters and digits.\n*   The number of a single character repetitions in `compressedString` is in the range `[1, 10^9]`\n*   At most `100` calls will be made to `next` and `hasNext`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],],],]]",
                "output": "**Output**\n[null,\"L\",\"e\",\"e\",\"t\",\"C\",\"o\",true,\"d\",true]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\nclass StringIterator {\n    String s;\n    int i;\n    int count;\n    char ch;\n    \n    public StringIterator(String compressedString) {\n        s = compressedString;\n        i = 0;\n        count = 0;\n        ch = ' ';\n    }\n    \n    public char next() {\n        if(!hasNext()) {\n            return ' ';\n        }\n        if(count == 0) {\n            ch = s.charAt(i++);\n            while(i < s.length() && Character.isDigit(s.charAt(i))) {\n                count = count * 10 + (s.charAt(i++) - '0');\n            }\n        }\n        count--;\n        return ch;\n    }\n    \n    public boolean hasNext() {\n        return i < s.length() || count != 0;\n    }\n}\n```\n\n    \n    The main idea of the algorithm is to iterate through the compressed string, extracting each character and its associated count of repetitions. Each extracted character is stored in 'ch' and its count of repetitions is stored in 'count'. The 'next()' function checks if there are still letters to uncompress - if there aren't, it returns a white space. The 'next()' function also checks if the current count of repetitions for the character 'ch' is 0 - if it is, it extracts the next character from the compressed string until it encounters a digit, then extracts the whole count value. The 'hasNext()' function checks if there are any more characters in the compressed string or if the count of repetitions is not 0, meaning there are still characters to be uncompressed.\n    ",
        "python": "\n    ```python\nclass StringIterator:\n    def __init__(self, compressedString: str):\n        self.s = compressedString\n        self.i = 0\n        self.count = 0\n        self.ch = \" \"\n    \n    def next(self) -> str:\n        if not self.hasNext():\n            return \" \"\n        if self.count == 0:\n            self.ch = self.s[self.i]\n            self.i += 1\n            while self.i < len(self.s) and self.s[self.i].isdigit():\n                self.count = self.count * 10 + int(self.s[self.i])\n                self.i += 1\n        self.count -= 1\n        return self.ch\n    \n    def hasNext(self) -> bool:\n        return self.i < len(self.s) or self.count != 0\n```\n\n    \n    The main idea of the algorithm is to iterate through the compressed string, extracting each character and its associated count of repetitions. Each extracted character is stored in 'ch' and its count of repetitions is stored in 'count'. The 'next()' function checks if there are still letters to uncompress - if there aren't, it returns a white space. The 'next()' function also checks if the current count of repetitions for the character 'ch' is 0 - if it is, it extracts the next character from the compressed string until it encounters a digit, then extracts the whole count value. The 'hasNext()' function checks if there are any more characters in the compressed string or if the count of repetitions is not 0, meaning there are still characters to be uncompressed.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nclass StringIterator {\npublic:\n    StringIterator(const std::string& compressedString) {\n        s = compressedString;\n        i = 0;\n        count = 0;\n        ch = ' ';\n    }\n    char next() {\n        if(!hasNext()) return ' ';\n        if(count == 0) {\n            ch = s[i++];\n            while(i < s.size() && isdigit(s[i])) {\n                count = count * 10 + (s[i++] - '0');\n            }\n        }\n        count--;\n        return ch;\n    }\n    bool hasNext() {\n        return i < s.size() || count != 0;\n    }\nprivate:\n    std::string s;\n    int i;\n    int count;\n    char ch;\n};\n```\n    \n    \n    The main idea of the algorithm is to iterate through the compressed string, extracting each character and its associated count of repetitions. Each extracted character is stored in 'ch' and its count of repetitions is stored in 'count'. The 'next()' function checks if there are still letters to uncompress - if there aren't, it returns a white space. The 'next()' function also checks if the current count of repetitions for the character 'ch' is 0 - if it is, it extracts the next character from the compressed string until it encounters a digit, then extracts the whole count value. The 'hasNext()' function checks if there are any more characters in the compressed string or if the count of repetitions is not 0, meaning there are still characters to be uncompressed.\n    ",
        "js": "\n    ```javascript\nclass StringIterator {\n    constructor(compressedString) {\n        this.s = compressedString;\n        this.i = 0;\n        this.count = 0;\n        this.ch = ' ';\n    }\n\n    next() {\n        if (!this.hasNext()) {\n            return ' ';\n        }\n        if (this.count === 0) {\n            this.ch = this.s[this.i++];\n            while (this.i < this.s.length && !isNaN(this.s[this.i])) {\n                this.count = this.count * 10 + parseInt(this.s[this.i++]);\n            }\n        }\n        this.count--;\n        return this.ch;\n    }\n\n    hasNext() {\n        return this.i < this.s.length || this.count !== 0;\n    }\n}\n```\n\n    \n    The main idea of the algorithm is to iterate through the compressed string, extracting each character and its associated count of repetitions. Each extracted character is stored in 'ch' and its count of repetitions is stored in 'count'. The 'next()' function checks if there are still letters to uncompress - if there aren't, it returns a white space. The 'next()' function also checks if the current count of repetitions for the character 'ch' is 0 - if it is, it extracts the next character from the compressed string until it encounters a digit, then extracts the whole count value. The 'hasNext()' function checks if there are any more characters in the compressed string or if the count of repetitions is not 0, meaning there are still characters to be uncompressed.\n    "
    },
    {
        "id": 120,
        "title": "Add Bold Tag in String",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s` and an array of strings `words`.\n\nYou should add a closed pair of bold tag **and** to wrap the substrings in `s` that exist in `words`.\n\n*   If two such substrings overlap, you should wrap them together with only one pair of closed bold-tag.\n*   If two substrings wrapped by bold tags are consecutive, you should combine them.\n\nReturn `s` _after adding the bold tags_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcxyz123 \", words = \\[ \"abc \", \"123 \"\\]\n**Output:**  \"**abc**xyz**123** \"\n**Explanation:** The two strings of words are substrings of s as following:  \"abcxyz123 \".\nWe add ** before each substring and ** after each substring.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaabbb \", words = \\[ \"aa \", \"b \"\\]\n**Output:**  \"**aaabbb** \"\n**Explanation:** \n \"aa \" appears as a substring two times:  \"aaabbb \" and  \"aaabbb \".\n \"b \" appears as a substring three times:  \"aaabbb \",  \"aaabbb \", and  \"aaabbb \".\nWe add ** before each substring and ** after each substring:  \"**a**a**a****b****b****b** \".\nSince the first two **'s overlap, we merge them:  \"**aaa****b****b****b** \".\nSince now the four **'s are consecuutive, we merge them:  \"**aaabbb** \".****\n\n****"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `0 <= words.length <= 100`\n*   `1 <= words[i].length <= 1000`\n*   `s` and `words[i]` consist of English letters and digits.\n*   All the values of `words` are **unique**.\n\n**Note:** This question is the same as 758: [https://leetcode.com/problems/bold-words-in-string/](https://leetcode.com/problems/bold-words-in-string/)\n\n****",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcxyz123\",[\"abc\",\"123\"]",
                "output": "\"**abc**xyz**123**\""
            },
            {
                "input": "\"aaabbb\",[\"aa\",\"b\"]",
                "output": "\"**aaabbb**\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic String addBoldTag(String s, String[] words) {\n    int n = s.length();\n    boolean[] marked = new boolean[n];\n    for (String word : words) {\n        int pos = s.indexOf(word, 0);\n        while (pos != -1) {\n            Arrays.fill(marked, pos, pos + word.length(), true);\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < n; i++) {\n        if (marked[i] && (i == 0 || !marked[i - 1])) {\n            result.append(\"<b>\");\n        }\n        result.append(s.charAt(i));\n        if (marked[i] && (i == n - 1 || !marked[i + 1])) {\n            result.append(\"</b>\");\n        }\n    }\n    return result.toString();\n}\n```\n    \n    1. Create an array `marked` of the same length as the string `s`, initialized with boolean value `false`.\n2. Iterate through the words and, for each word, find its position in string `s` and mark each character, from the position till the end of the word, as `true` in the `marked` array. Repeat this process for all occurrences of the word in the string.\n3. Initialize an empty result string.\n4. Iterate through the string `s`. If the current character is marked and it is the first character or the previous one is not marked, add the opening tag `<b>` to the result string. Always append the current character to the result string. If the current character is marked and it is the last character or the next one is not marked, add the closing tag `</b>` to the result string.\n5. Return the result string.\n    ",
        "python": "\n    ```python\ndef addBoldTag(s: str, words: list) -> str:\n    n = len(s)\n    marked = [False] * n\n    for word in words:\n        pos = s.find(word)\n        while pos != -1:\n            for i in range(pos, pos + len(word)):\n                marked[i] = True\n            pos = s.find(word, pos + 1)\n    result = []\n    i = 0\n    while i < n:\n        if marked[i]:\n            result.append(\"<b>\")\n            while i < n and marked[i]:\n                result.append(s[i])\n                i += 1\n            result.append(\"</b>\")\n        else:\n            result.append(s[i])\n            i += 1\n    return \"\".join(result)\n```\n    \n    1. Create an array `marked` of the same length as the string `s`, initialized with boolean value `false`.\n2. Iterate through the words and, for each word, find its position in string `s` and mark each character, from the position till the end of the word, as `true` in the `marked` array. Repeat this process for all occurrences of the word in the string.\n3. Initialize an empty result string.\n4. Iterate through the string `s`. If the current character is marked and it is the first character or the previous one is not marked, add the opening tag `<b>` to the result string. Always append the current character to the result string. If the current character is marked and it is the last character or the next one is not marked, add the closing tag `</b>` to the result string.\n5. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string addBoldTag(std::string s, std::vector<std::string>& words) {\n    int n = s.size();\n    std::vector<bool> marked(n, false);\n    for (const auto& word : words) {\n        int pos = s.find(word, 0);\n        while (pos != std::string::npos) {\n            std::fill(marked.begin() + pos, marked.begin() + pos + word.size(), true);\n            pos = s.find(word, pos + 1);\n        }\n    }\n    std::string result;\n    for (int i = 0; i < n; ++i) {\n        if (marked[i] && (i == 0 || !marked[i - 1])) {\n            result += \"<b>\";\n        }\n        result += s[i];\n        if (marked[i] && (i == n - 1 || !marked[i + 1])) {\n            result += \"</b>\";\n        }\n    }\n    return result;\n}\n```\n    \n    1. Create an array `marked` of the same length as the string `s`, initialized with boolean value `false`.\n2. Iterate through the words and, for each word, find its position in string `s` and mark each character, from the position till the end of the word, as `true` in the `marked` array. Repeat this process for all occurrences of the word in the string.\n3. Initialize an empty result string.\n4. Iterate through the string `s`. If the current character is marked and it is the first character or the previous one is not marked, add the opening tag `<b>` to the result string. Always append the current character to the result string. If the current character is marked and it is the last character or the next one is not marked, add the closing tag `</b>` to the result string.\n5. Return the result string.\n    ",
        "js": "\n    ```javascript\nfunction addBoldTag(s, words) {\n    const n = s.length;\n    const marked = new Array(n).fill(false);\n    for (const word of words) {\n        let pos = s.indexOf(word, 0);\n        while (pos !== -1) {\n            marked.fill(true, pos, pos + word.length);\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n    let result = \"\";\n    for (let i = 0; i < n; i++) {\n        if (marked[i] && (i === 0 || !marked[i - 1])) {\n            result += \"<b>\";\n        }\n        result += s[i];\n        if (marked[i] && (i === n - 1 || !marked[i + 1])) {\n            result += \"</b>\";\n        }\n    }\n    return result;\n}\n```\n    \n    1. Create an array `marked` of the same length as the string `s`, initialized with boolean value `false`.\n2. Iterate through the words and, for each word, find its position in string `s` and mark each character, from the position till the end of the word, as `true` in the `marked` array. Repeat this process for all occurrences of the word in the string.\n3. Initialize an empty result string.\n4. Iterate through the string `s`. If the current character is marked and it is the first character or the previous one is not marked, add the opening tag `<b>` to the result string. Always append the current character to the result string. If the current character is marked and it is the last character or the next one is not marked, add the closing tag `</b>` to the result string.\n5. Return the result string.\n    "
    },
    {
        "id": 121,
        "title": "Minimum Factorization",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a positive integer num, return _the smallest positive integer_ `x` _whose multiplication of each digit equals_ `num`. If there is no answer or the answer is not fit in **32-bit** signed integer, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 48\n**Output:** 68\n\n",
                "**Example 2:**\n\n**Input:** num = 15\n**Output:** 35"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 231 - 1`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "48",
                "output": "68"
            },
            {
                "input": "15",
                "output": "35"
            }
        ],
        "java": "\n    ```java\npublic int smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > Integer.MAX_VALUE) return 0;\n        }\n    }\n    return num == 1 ? (int) result : 0;\n}\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ",
        "python": "\n    ```python\ndef smallestFactorization(num: int) -> int:\n    if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ",
        "c++": "\n    ```cpp\nint smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > INT_MAX) return 0;\n        }\n    }\n    return num == 1 ? result : 0;\n}\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ",
        "js": "\n    ```javascript\nfunction smallestFactorization(num) {\n    if (num === 1) return 1;\n    let result = 0, factor = 1;\n    for (let i = 9; i > 1; --i) {\n        while (num % i === 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > (2**31 - 1)) return 0;\n        }\n    }\n    return num === 1 ? result : 0;\n}\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    "
    },
    {
        "id": 122,
        "title": "Design Excel Sum Formula",
        "difficulty": "Hard",
        "content": {
            "problem": "Design the basic function of **Excel** and implement the function of the sum formula.\n\nImplement the `Excel` class:\n\n*   `Excel(int height, char width)` Initializes the object with the `height` and the `width` of the sheet. The sheet is an integer matrix `mat` of size `height x width` with the row index in the range `[1, height]` and the column index in the range `['A', width]`. All the values should be **zero** initially.\n*   `void set(int row, char column, int val)` Changes the value at `mat[row][column]` to be `val`.\n*   `int get(int row, char column)` Returns the value at `mat[row][column]`.\n*   `int sum(int row, char column, List numbers)` Sets the value at `mat[row][column]` to be the sum of cells represented by `numbers` and returns the value at `mat[row][column]`. This sum formula **should exist** until this cell is overlapped by another value or another sum formula. `numbers[i]` could be on the format:\n    *   `\"ColRow \"` that represents a single cell.\n        *   For example, `\"F7 \"` represents the cell `mat[7]['F']`.\n    *   `\"ColRow1:ColRow2 \"` that represents a range of cells. The range will always be a rectangle where `\"ColRow1 \"` represent the position of the top-left cell, and `\"ColRow2 \"` represents the position of the bottom-right cell.\n        *   For example, `\"B3:F7 \"` represents the cells `mat[i][j]` for `3 <= i <= 7` and `'B' <= j <= 'F'`.\n\n**Note:** You could assume that there will not be any circular sum reference.\n\n*   For example, `mat[1]['A'] == sum(1, \"B \")` and `mat[1]['B'] == sum(1, \"A \")`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Excel \",  \"set \",  \"sum \",  \"set \",  \"get \"\\]\n\\[\\[3,  \"C \"\\], \\[1,  \"A \", 2\\], \\[3,  \"C \", \\[ \"A1 \",  \"A1:B2 \"\\]\\], \\[2,  \"B \", 2\\], \\[3,  \"C \"\\]\\]\n**Output**\n\\[null, null, 4, null, 6\\]\n\n**Explanation**\nExcel excel = new Excel(3,  \"C \");\n // construct a 3\\*3 2D array with all zero.\n //   A B C\n // 1 0 0 0\n // 2 0 0 0\n // 3 0 0 0\nexcel.set(1,  \"A \", 2);\n // set mat\\[1\\]\\[ \"A \"\\] to be 2.\n //   A B C\n // 1 2 0 0\n // 2 0 0 0\n // 3 0 0 0\nexcel.sum(3,  \"C \", \\[ \"A1 \",  \"A1:B2 \"\\]); // return 4\n // set mat\\[3\\]\\[ \"C \"\\] to be the sum of value at mat\\[1\\]\\[ \"A \"\\] and the values sum of the rectangle range whose top-left cell is mat\\[1\\]\\[ \"A \"\\] and bottom-right cell is mat\\[2\\]\\[ \"B \"\\].\n //   A B C\n // 1 2 0 0\n // 2 0 0 0\n // 3 0 0 4\nexcel.set(2,  \"B \", 2);\n // set mat\\[2\\]\\[ \"B \"\\] to be 2. Note mat\\[3\\]\\[ \"C \"\\] should also be changed.\n //   A B C\n // 1 2 0 0\n // 2 0 2 0\n // 3 0 0 6\nexcel.get(3,  \"C \"); // return 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= height <= 26`\n*   `'A' <= width <= 'Z'`\n*   `1 <= row <= height`\n*   `'A' <= column <= width`\n*   `-100 <= val <= 100`\n*   `1 <= numbers.length <= 5`\n*   `numbers[i]` has the format `\"ColRow \"` or `\"ColRow1:ColRow2 \"`.\n*   At most `100` calls will be made to `set`, `get`, and `sum`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],]],[2,\"B\",2],[3,\"C\"]]",
                "output": "**Output**\n[null,null,4,null,6]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Excel {\n\n    int[][] mat;\n    Map<String, List<String>> formulas;\n\n    public Excel(int height, char width) {\n        mat = new int[height][width - 'A' + 1];\n        formulas = new HashMap<>();\n    }\n\n    public void set(int row, char column, int val) {\n        String pos = String.format(\"%c%d\", column, row);\n        formulas.remove(pos);\n        mat[row - 1][column - 'A'] = val;\n    }\n\n    public int get(int row, char column) {\n        String pos = String.format(\"%c%d\", column, row);\n        if (formulas.containsKey(pos)) {\n            return sum(row, column, formulas.get(pos));\n        }\n        return mat[row - 1][column - 'A'];\n    }\n\n    public int sum(int row, char column, List<String> numbers) {\n        int total = 0;\n        for (String num : numbers) {\n            if (num.contains(\":\")) {\n                String[] parts = num.split(\":\");\n                int startRow = Integer.parseInt(parts[0].substring(1));\n                int endRow = Integer.parseInt(parts[1].substring(1));\n                char startCol = parts[0].charAt(0);\n                char endCol = parts[1].charAt(0);\n                for (int r = startRow; r <= endRow; r++) {\n                    for (char c = startCol; c <= endCol; c++) {\n                        total += get(r, c);\n                    }\n                }\n            } else {\n                total += get(Integer.parseInt(num.substring(1)), num.charAt(0));\n            }\n        }\n        set(row, column, total);\n        formulas.put(String.format(\"%c%d\", column, row), numbers);\n        return total;\n    }\n}\n```\n\n    \n    The algorithm for this problem involves using a 2D array (matrix) to represent the values in the Excel sheet and a hashmap (formulas) to store sum formulas for cells in the Excel sheet. When using the 'set' method, the cell value in the matrix is set to the input value and any existing sum formula for the cell is removed. When using the 'get' method, the method first checks if a sum formula exists for the cell in focus. If it does, it returns the result of the sum formula without updating the matrix; otherwise, it returns the value in the matrix for the cell. When using the 'sum' method, the algorithm iterates through the input 'numbers', summing up the corresponding cell values based on the range given by either a single cell reference or a range of cells. The sum total is then set as the cell value in the matrix and the formula is stored in the 'formulas' hashmap. The sum total is returned as the result.\n    ",
        "python": "\n    ```python\nclass Excel:\n\n    def __init__(self, height: int, width: str):\n        self.mat = [[0] * (ord(width) - ord('A') + 1) for _ in range(height)]\n        self.formulas = {}\n\n    def set(self, row: int, column: str, val: int) -> None:\n        pos = column + str(row)\n        if pos in self.formulas:\n            del self.formulas[pos]\n        self.mat[row - 1][ord(column) - ord('A')] = val\n\n    def get(self, row: int, column: str) -> int:\n        pos = column + str(row)\n        if pos in self.formulas:\n            return self.sum(row, column, self.formulas[pos])\n        return self.mat[row - 1][ord(column) - ord('A')]\n\n    def sum(self, row: int, column: str, numbers) -> int:\n        total = 0\n        for num in numbers:\n            if ':' in num:\n                start, end = num.split(':')\n                start_row, end_row = int(start[1:]), int(end[1:])\n                start_col, end_col = start[0], end[0]\n                for r in range(start_row, end_row + 1):\n                    for c in range(ord(start_col), ord(end_col) + 1):\n                        total += self.get(r, chr(c))\n            else:\n                total += self.get(int(num[1:]), num[0])\n        self.set(row, column, total)\n        self.formulas[column + str(row)] = numbers\n        return total\n```\n\n    \n    The algorithm for this problem involves using a 2D array (matrix) to represent the values in the Excel sheet and a hashmap (formulas) to store sum formulas for cells in the Excel sheet. When using the 'set' method, the cell value in the matrix is set to the input value and any existing sum formula for the cell is removed. When using the 'get' method, the method first checks if a sum formula exists for the cell in focus. If it does, it returns the result of the sum formula without updating the matrix; otherwise, it returns the value in the matrix for the cell. When using the 'sum' method, the algorithm iterates through the input 'numbers', summing up the corresponding cell values based on the range given by either a single cell reference or a range of cells. The sum total is then set as the cell value in the matrix and the formula is stored in the 'formulas' hashmap. The sum total is returned as the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Excel {\npublic:\n    vector<vector<int>> mat;\n    unordered_map<string, pair<string, vector<string>>> formulas;\n\n    Excel(int height, char width) {\n        mat.resize(height, vector<int>(width - 'A' + 1));\n    }\n\n    void set(int row, char column, int val) {\n        row--; column -= 'A';\n        string pos = string(1, column + 'A') + to_string(row + 1);\n        formulas.erase(pos);\n        mat[row][column] = val;\n    }\n\n    int get(int row, char column) {\n        row--; column -= 'A';\n        string pos = string(1, column + 'A') + to_string(row + 1);\n        if (formulas.count(pos)) {\n            int sum = 0;\n            for (string &r : formulas[pos].second) {\n                auto x = r.find(':');\n                if (x == string::npos) {\n                    int rRow = stoi(r.substr(1)) - 1;\n                    int rCol = r[0] - 'A';\n                    sum += get(rRow + 1, rCol + 'A');\n                } else {\n                    int r1Row = stoi(r.substr(1, x - 1)) - 1;\n                    int r1Col = r[0] - 'A';\n                    int r2Row = stoi(r.substr(x + 2)) - 1;\n                    int r2Col = r[x + 1] - 'A';\n                    for (int i = r1Row; i <= r2Row; ++i)\n                        for (int j = r1Col; j <= r2Col; ++j)\n                            sum += get(i + 1, j + 'A');\n                }\n            }\n            return sum;\n        }\n        return mat[row][column];\n    }\n\n    int sum(int row, char column, vector<string> numbers) {\n        int total = 0;\n        string pos = string(1, column) + to_string(row);\n        for (auto &num : numbers) total += get(stoi(num.substr(1)), num[0]);\n        formulas[pos] = make_pair(pos, numbers);\n        set(row, column, total);\n        return total;\n    }\n};\n```\n\n    \n    The algorithm for this problem involves using a 2D array (matrix) to represent the values in the Excel sheet and a hashmap (formulas) to store sum formulas for cells in the Excel sheet. When using the 'set' method, the cell value in the matrix is set to the input value and any existing sum formula for the cell is removed. When using the 'get' method, the method first checks if a sum formula exists for the cell in focus. If it does, it returns the result of the sum formula without updating the matrix; otherwise, it returns the value in the matrix for the cell. When using the 'sum' method, the algorithm iterates through the input 'numbers', summing up the corresponding cell values based on the range given by either a single cell reference or a range of cells. The sum total is then set as the cell value in the matrix and the formula is stored in the 'formulas' hashmap. The sum total is returned as the result.\n    ",
        "js": "\n    ```javascript\nclass Excel {\n    constructor(height, width) {\n        this.mat = new Array(height).fill(null).map(() => new Array(width.charCodeAt(0)-'A'.charCodeAt(0)+1).fill(0));\n        this.formulas = {};\n    }\n\n    set(row, column, val) {\n        let pos = column + row.toString();\n        delete this.formulas[pos];\n        this.mat[row - 1][column.charCodeAt(0) - 'A'.charCodeAt(0)] = val;\n    }\n\n    get(row, column) {\n        let pos = column + row.toString();\n        if (pos in this.formulas) {\n            return this.sum(row, column, this.formulas[pos]);\n        }\n        return this.mat[row - 1][column.charCodeAt(0) - 'A'.charCodeAt(0)];\n    }\n\n    sum(row, column, numbers) {\n        let total = 0;\n        for (let num of numbers) {\n            if (num.includes(':')) {\n                let parts = num.split(':');\n                let startRow = parseInt(parts[0].substring(1));\n                let endRow = parseInt(parts[1].substring(1));\n                let startCol = parts[0].charAt(0);\n                let endCol = parts[1].charAt(0);\n                for (let r = startRow; r <= endRow; r++) {\n                    for (let c = startCol.charCodeAt(0); c <= endCol.charCodeAt(0); c++) {\n                        total += this.get(r, String.fromCharCode(c));\n                    }\n                }\n            } else {\n                total += this.get(parseInt(num.substring(1)), num.charAt(0));\n            }\n        }\n        this.set(row, column, total);\n        this.formulas[column + row.toString()] = numbers;\n        return total;\n    }\n}\n```\n\n    \n    The algorithm for this problem involves using a 2D array (matrix) to represent the values in the Excel sheet and a hashmap (formulas) to store sum formulas for cells in the Excel sheet. When using the 'set' method, the cell value in the matrix is set to the input value and any existing sum formula for the cell is removed. When using the 'get' method, the method first checks if a sum formula exists for the cell in focus. If it does, it returns the result of the sum formula without updating the matrix; otherwise, it returns the value in the matrix for the cell. When using the 'sum' method, the algorithm iterates through the input 'numbers', summing up the corresponding cell values based on the range given by either a single cell reference or a range of cells. The sum total is then set as the cell value in the matrix and the formula is stored in the 'formulas' hashmap. The sum total is returned as the result.\n    "
    },
    {
        "id": 123,
        "title": "Find the Derangement of An Array",
        "difficulty": "Medium",
        "content": {
            "problem": "In combinatorial mathematics, a **derangement** is a permutation of the elements of a set, such that no element appears in its original position.\n\nYou are given an integer `n`. There is originally an array consisting of `n` integers from `1` to `n` in ascending order, return _the number of **derangements** it can generate_. Since the answer may be huge, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** The original array is \\[1,2,3\\]. The two derangements are \\[2,3,1\\] and \\[3,1,2\\].\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3",
                "output": "2"
            },
            {
                "input": "2",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findDerangement(int n) {\n    final int MOD = 1000000007;\n    long[] dp = new long[n + 1];\n    dp[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    return (int)dp[n];\n}\n```\n    \n    To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n.\n    ",
        "python": "\n    ```python\ndef findDerangement(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n```\n    \n    To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n.\n    ",
        "c++": "\n    ```cpp\nint findDerangement(int n) {\n    long MOD = 1e9 + 7;\n    vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    return (int)dp[n];\n}\n```\n    \n    To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n.\n    ",
        "js": "\n    ```javascript\nfunction findDerangement(n) {\n    const MOD = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[2] = 1;\n    for (let i = 3; i <= n; ++i) {\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    return dp[n];\n}\n```\n    \n    To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n.\n    "
    },
    {
        "id": 124,
        "title": "Design Log Storage System",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given several logs, where each log contains a unique ID and timestamp. Timestamp is a string that has the following format: `Year:Month:Day:Hour:Minute:Second`, for example, `2017:01:01:23:59:59`. All domains are zero-padded decimal numbers.\n\nImplement the `LogSystem` class:\n\n*   `LogSystem()` Initializes the `LogSystem` object.\n*   `void put(int id, string timestamp)` Stores the given log `(id, timestamp)` in your storage system.\n*   `int[] retrieve(string start, string end, string granularity)` Returns the IDs of the logs whose timestamps are within the range from `start` to `end` inclusive. `start` and `end` all have the same format as `timestamp`, and `granularity` means how precise the range should be (i.e. to the exact `Day`, `Minute`, etc.). For example, `start = \"2017:01:01:23:59:59 \"`, `end = \"2017:01:02:23:59:59 \"`, and `granularity = \"Day \"` means that we need to find the logs within the inclusive range from **Jan. 1st 2017** to **Jan. 2nd 2017**, and the `Hour`, `Minute`, and `Second` for each log entry can be ignored.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"LogSystem \",  \"put \",  \"put \",  \"put \",  \"retrieve \",  \"retrieve \"\\]\n\\[\\[\\], \\[1,  \"2017:01:01:23:59:59 \"\\], \\[2,  \"2017:01:01:22:59:59 \"\\], \\[3,  \"2016:01:01:00:00:00 \"\\], \\[ \"2016:01:01:01:01:01 \",  \"2017:01:01:23:00:00 \",  \"Year \"\\], \\[ \"2016:01:01:01:01:01 \",  \"2017:01:01:23:00:00 \",  \"Hour \"\\]\\]\n**Output**\n\\[null, null, null, null, \\[3, 2, 1\\], \\[2, 1\\]\\]\n\n**Explanation**\nLogSystem logSystem = new LogSystem();\nlogSystem.put(1,  \"2017:01:01:23:59:59 \");\nlogSystem.put(2,  \"2017:01:01:22:59:59 \");\nlogSystem.put(3,  \"2016:01:01:00:00:00 \");\n\n// return \\[3,2,1\\], because you need to return all logs between 2016 and 2017.\nlogSystem.retrieve( \"2016:01:01:01:01:01 \",  \"2017:01:01:23:00:00 \",  \"Year \");\n\n// return \\[2,1\\], because you need to return all logs between Jan. 1, 2016 01:XX:XX and Jan. 1, 2017 23:XX:XX.\n// Log 3 is not returned because Jan. 1, 2016 00:00:00 comes before the start of the range.\nlogSystem.retrieve( \"2016:01:01:01:01:01 \",  \"2017:01:01:23:00:00 \",  \"Hour \");"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= id <= 500`\n*   `2000 <= Year <= 2017`\n*   `1 <= Month <= 12`\n*   `1 <= Day <= 31`\n*   `0 <= Hour <= 23`\n*   `0 <= Minute, Second <= 59`\n*   `granularity` is one of the values `[ \"Year \", \"Month \", \"Day \", \"Hour \", \"Minute \", \"Second \"]`.\n*   At most `500` calls will be made to `put` and `retrieve`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,null,[3,2,1],[2,1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass LogSystem {\n    Map<String, Integer> logs;\n    Map<String, Integer> timeGranularity;\n\n    public LogSystem() {\n        logs = new HashMap<>();\n        timeGranularity = new HashMap<>();\n        String[] granularities = {\"Year\", \"Month\", \"Day\", \"Hour\", \"Minute\", \"Second\"};\n        for (int i = 0; i < granularities.length; i++) {\n            timeGranularity.put(granularities[i], i);\n        }\n    }\n\n    public void put(int id, String timestamp) {\n        logs.put(timestamp, id);\n    }\n\n    public List<Integer> retrieve(String start, String end, String granularity) {\n        List<Integer> res = new ArrayList<>();\n        int sizeSubstring = new int[]{4, 7, 10, 13, 16, 19}[timeGranularity.get(granularity)];\n\n        for (Map.Entry<String, Integer> entry : logs.entrySet()) {\n            String key = entry.getKey();\n            if (start.substring(0, sizeSubstring).compareTo(key.substring(0, sizeSubstring)) <= 0\n                    && end.substring(0, sizeSubstring).compareTo(key.substring(0, sizeSubstring)) >= 0) {\n                res.add(entry.getValue());\n            }\n        }\n        return res;\n    }\n}\n```\n\n    \n    The algorithm creates a data structure `logs` to store logs, and two helper data structures for handling the logic of granularities: `time_granularity` maps granularity names to indexes and `size_map` maps the indexes to the length of the timestamps according to the given granularity. These two data structures are used to compute the substring size needed in the `retrieve` function.\n\nThe `put` function simply adds a log entry to the `logs` structure.\n\nThe `retrieve` function iterates through the `logs` structure and checks if the portion of the timestamp that corresponds to the given granularity falls within the specified range. If yes, it adds the corresponding ID to the result list.\n    ",
        "python": "\n    ```python\nclass LogSystem:\n\n    def __init__(self):\n        self.logs = {}\n        self.time_granularity = {\n            \"Year\": 0, \"Month\": 1, \"Day\": 2, \"Hour\": 3, \"Minute\": 4, \"Second\": 5\n        }\n        self.size_map = [4, 7, 10, 13, 16, 19]\n\n    def put(self, id: int, timestamp: str) -> None:\n        self.logs[timestamp] = id\n\n    def retrieve(self, start: str, end: str, granularity: str) -> list[int]:\n        size_substring = self.size_map[self.time_granularity[granularity]]\n        res = []\n\n        for k, v in self.logs.items():\n            if start[:size_substring] <= k[:size_substring] <= end[:size_substring]:\n                res.append(v)\n\n        return res\n```\n\n    \n    The algorithm creates a data structure `logs` to store logs, and two helper data structures for handling the logic of granularities: `time_granularity` maps granularity names to indexes and `size_map` maps the indexes to the length of the timestamps according to the given granularity. These two data structures are used to compute the substring size needed in the `retrieve` function.\n\nThe `put` function simply adds a log entry to the `logs` structure.\n\nThe `retrieve` function iterates through the `logs` structure and checks if the portion of the timestamp that corresponds to the given granularity falls within the specified range. If yes, it adds the corresponding ID to the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <map>\n\nclass LogSystem {\npublic:\n    LogSystem() {\n    }\n    \n    void put(int id, std::string timestamp) {\n        logs[timestamp] = id;\n    }\n\n    std::vector<int> retrieve(std::string start, std::string end, std::string granularity) {\n        std::vector<int> res;\n        std::string min_timestamp, max_timestamp;\n        int size_map[] = {4, 7, 10, 13, 16, 19};\n        std::map<std::string, int> time_granularity = {{\"Year\", 0}, {\"Month\", 1}, {\"Day\", 2}, {\"Hour\", 3}, {\"Minute\", 4}, {\"Second\", 5}};\n        int size_substring = size_map[time_granularity[granularity]];\n\n        min_timestamp = start.substr(0, size_substring);\n        max_timestamp = end.substr(0, size_substring);\n \n        for (const auto &x : logs) {\n            if (min_timestamp <= x.first.substr(0, size_substring) && max_timestamp >= x.first.substr(0, size_substring)) {\n                res.push_back(x.second);\n            }\n        }\n        return res;\n    }\n\nprivate:\n    std::map<std::string, int> logs;\n};\n```\n\n    \n    The algorithm creates a data structure `logs` to store logs, and two helper data structures for handling the logic of granularities: `time_granularity` maps granularity names to indexes and `size_map` maps the indexes to the length of the timestamps according to the given granularity. These two data structures are used to compute the substring size needed in the `retrieve` function.\n\nThe `put` function simply adds a log entry to the `logs` structure.\n\nThe `retrieve` function iterates through the `logs` structure and checks if the portion of the timestamp that corresponds to the given granularity falls within the specified range. If yes, it adds the corresponding ID to the result list.\n    ",
        "js": "\n    ```javascript\nclass LogSystem {\n    constructor() {\n        this.logs = new Map();\n        this.timeGranularity = new Map([['Year', 0], ['Month', 1], ['Day', 2], ['Hour', 3], ['Minute', 4], ['Second', 5]]);\n        this.sizeMap = [4, 7, 10, 13, 16, 19];\n    }\n\n    put(id, timestamp) {\n        this.logs.set(timestamp, id);\n    }\n\n    retrieve(start, end, granularity) {\n        const sizeSubstring = this.sizeMap[this.timeGranularity.get(granularity)];\n        let res = [];\n\n        for (const [k, v] of this.logs.entries()) {\n            if (k.substring(0, sizeSubstring) >= start.substring(0, sizeSubstring) && k.substring(0, sizeSubstring) <= end.substring(0, sizeSubstring)) {\n                res.push(v);\n            }\n        }\n        return res;\n    }\n}\n```\n\n    \n    The algorithm creates a data structure `logs` to store logs, and two helper data structures for handling the logic of granularities: `time_granularity` maps granularity names to indexes and `size_map` maps the indexes to the length of the timestamps according to the given granularity. These two data structures are used to compute the substring size needed in the `retrieve` function.\n\nThe `put` function simply adds a log entry to the `logs` structure.\n\nThe `retrieve` function iterates through the `logs` structure and checks if the portion of the timestamp that corresponds to the given granularity falls within the specified range. If yes, it adds the corresponding ID to the result list.\n    "
    },
    {
        "id": 125,
        "title": "Design Search Autocomplete System",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character `'#'`).\n\nYou are given a string array `sentences` and an integer array `times` both of length `n` where `sentences[i]` is a previously typed sentence and `times[i]` is the corresponding number of times the sentence was typed. For each input character except `'#'`, return the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed.\n\nHere are the specific rules:\n\n*   The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.\n*   The returned top `3` hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).\n*   If less than `3` hot sentences exist, return as many as you can.\n*   When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\n\nImplement the `AutocompleteSystem` class:\n\n*   `AutocompleteSystem(String[] sentences, int[] times)` Initializes the object with the `sentences` and `times` arrays.\n*   `List input(char c)` This indicates that the user typed the character `c`.\n    *   Returns an empty array `[]` if `c == '#'` and stores the inputted sentence in the system.\n    *   Returns the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than `3` matches, return them all.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"AutocompleteSystem \",  \"input \",  \"input \",  \"input \",  \"input \"\\]\n\\[\\[\\[ \"i love you \",  \"island \",  \"iroman \",  \"i love leetcode \"\\], \\[5, 3, 2, 2\\]\\], \\[ \"i \"\\], \\[ \"  \"\\], \\[ \"a \"\\], \\[ \"# \"\\]\\]\n**Output**\n\\[null, \\[ \"i love you \",  \"island \",  \"i love leetcode \"\\], \\[ \"i love you \",  \"i love leetcode \"\\], \\[\\], \\[\\]\\]\n\n**Explanation**\nAutocompleteSystem obj = new AutocompleteSystem(\\[ \"i love you \",  \"island \",  \"iroman \",  \"i love leetcode \"\\], \\[5, 3, 2, 2\\]);\nobj.input( \"i \"); // return \\[ \"i love you \",  \"island \",  \"i love leetcode \"\\]. There are four sentences that have prefix  \"i \". Among them,  \"ironman \" and  \"i love leetcode \" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114,  \"i love leetcode \" should be in front of  \"ironman \". Also we only need to output top 3 hot sentences, so  \"ironman \" will be ignored.\nobj.input( \"  \"); // return \\[ \"i love you \",  \"i love leetcode \"\\]. There are only two sentences that have prefix  \"i  \".\nobj.input( \"a \"); // return \\[\\]. There are no sentences that have prefix  \"i a \".\nobj.input( \"# \"); // return \\[\\]. The user finished the input, the sentence  \"i a \" should be saved as a historical sentence in system. And the following input will be counted as a new search."
            ],
            "constraints": "**Constraints:**\n\n*   `n == sentences.length`\n*   `n == times.length`\n*   `1 <= n <= 100`\n*   `1 <= sentences[i].length <= 100`\n*   `1 <= times[i] <= 50`\n*   `c` is a lowercase English letter, a hash `'#'`, or space `' '`.\n*   Each tested sentence will be a sequence of characters `c` that end with the character `'#'`.\n*   Each tested sentence will have a length in the range `[1, 200]`.\n*   The words in each input sentence are separated by single spaces.\n*   At most `5000` calls will be made to `input`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],]],[\"i\"],[\"\"],[\"a\"],[\"#\"]]",
                "output": "**Output**\n[null,[\"iloveyou\",\"island\",\"iloveleetcode\"],[\"iloveyou\",\"iloveleetcode\"],[],[]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass AutocompleteSystem {\n    class TrieNode {\n        HashMap<Character, TrieNode> children = new HashMap<>();\n        String sentence;\n        int times;\n\n        TrieNode() {\n            sentence = null;\n            times = 0;\n        }\n    }\n\n    private void insert(String sentence, int times) {\n        TrieNode curr = root;\n        for (char c : sentence.toCharArray()) {\n            curr.children.putIfAbsent(c, new TrieNode());\n            curr = curr.children.get(c);\n        }\n        curr.sentence = sentence;\n        curr.times += times;\n    }\n\n    private class NodeComparator implements Comparator<TrieNode> {\n        public int compare(TrieNode a, TrieNode b) {\n            if (a.times == b.times) {\n                return a.sentence.compareTo(b.sentence);\n            }\n            return b.times - a.times;\n        }\n    }\n\n    TrieNode root, curr;\n    String search;\n\n    public AutocompleteSystem(String[] sentences, int[] times) {\n        root = new TrieNode();\n        curr = root;\n        search = \"\";\n        for (int i = 0; i < sentences.length; ++i) {\n            insert(sentences[i], times[i]);\n        }\n    }\n    \n    public List<String> input(char c) {\n        List<String> res = new ArrayList<>();\n        if (c == '#') {\n            insert(search, 1);\n            search = \"\";\n            curr = root;\n            return res;\n        }\n        search += c;\n        if (!curr.children.containsKey(c)) {\n            curr = null;\n            return res;\n        }\n        curr = curr.children.get(c);\n        PriorityQueue<TrieNode> pq = new PriorityQueue<>(new NodeComparator());\n        for (TrieNode node : curr.children.values()) {\n            if (node.times > 0) {\n                pq.add(node);\n            }\n        }\n        while (!pq.isEmpty() && res.size() < 3) {\n            res.add(pq.poll().sentence);\n        }\n        return res;\n    }\n}\n```\n\n    \n    The algorithm implemented is a trie-based solution. The `AutocompleteSystem` class has a TrieNode structure and methods to insert sentences into the trie, as well as to find and return the top 3 historical hot sentences.\n\nThe TrieNode structure has a `children` dictionary that stores the characters and their child TrieNode references, a sentence attribute to store the sentence corresponding to the node (if it is the end of a sentence), and a times attribute to store the hot degree of the sentence.\n\nThe `insert` method takes a sentence and times as input and inserts the sentence into the trie structure by following the appropriate path based on each character.\n\nThe `input` method processes each character in the user input to search for matching historical hot sentences. If the user input is a special character '#' it stores the inputted sentence in the system and returns an empty list. When the user input is not a special character, the `input` method finds matching historical hot sentences by traversing the trie based on the characters of the user input. A priority queue (or sorting for JavaScript) is used to prioritize and return the top 3 hot historical sentences according to their hot degree and ASCII-code order.\n    ",
        "python": "\n    ```python\nfrom typing import List\nimport heapq\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sentence = \"\"\n        self.times = 0\n\nclass AutocompleteSystem:\n\n    def __init__(self, sentences: List[str], times: List[int]):\n        self.root = TrieNode()\n        self.current = self.root\n        self.search = \"\"\n        \n        for i in range(len(sentences)):\n            self.insert(sentences[i], times[i])\n\n    def insert(self, sentence: str, times: int):\n        curr = self.root\n        for c in sentence:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.sentence = sentence\n        curr.times += times\n\n    def input(self, c: str) -> List[str]:\n        if c == '#':\n            self.insert(self.search, 1)\n            self.search = \"\"\n            self.current = self.root\n            return []\n        \n        self.search += c\n        if not self.current:\n            return []\n        \n        if c not in self.current.children:\n            self.current = None\n            return []\n        \n        self.current = self.current.children[c]\n        heap = []\n        for child in self.current.children.values():\n            if child.times:\n                heapq.heappush(heap, (-child.times, child.sentence))\n        \n        res = []\n        for _ in range(3):\n            if not heap:\n                break\n            res.append(heapq.heappop(heap)[1])\n        return res\n```\n\n    \n    The algorithm implemented is a trie-based solution. The `AutocompleteSystem` class has a TrieNode structure and methods to insert sentences into the trie, as well as to find and return the top 3 historical hot sentences.\n\nThe TrieNode structure has a `children` dictionary that stores the characters and their child TrieNode references, a sentence attribute to store the sentence corresponding to the node (if it is the end of a sentence), and a times attribute to store the hot degree of the sentence.\n\nThe `insert` method takes a sentence and times as input and inserts the sentence into the trie structure by following the appropriate path based on each character.\n\nThe `input` method processes each character in the user input to search for matching historical hot sentences. If the user input is a special character '#' it stores the inputted sentence in the system and returns an empty list. When the user input is not a special character, the `input` method finds matching historical hot sentences by traversing the trie based on the characters of the user input. A priority queue (or sorting for JavaScript) is used to prioritize and return the top 3 hot historical sentences according to their hot degree and ASCII-code order.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <queue>\n\nclass AutocompleteSystem {\n    struct TrieNode {\n        std::unordered_map<char, TrieNode*> children;\n        std::string sentence;\n        int times;\n        TrieNode() : times(0) {}\n    };\n\n    void insert(const std::string &sentence, int times) {\n        TrieNode *curr = root;\n        for (char c : sentence) {\n            if (!curr->children[c]) {\n                curr->children[c] = new TrieNode();\n            }\n            curr = curr->children[c];\n        }\n        curr->times += times;\n        curr->sentence = sentence;\n    }\n\n    struct cmp {\n        bool operator()(const TrieNode* a, const TrieNode* b) const {\n            if (a->times == b->times) {\n                return a->sentence > b->sentence;\n            }\n            return a->times < b->times;\n        }\n    };\n\n    TrieNode *root;\n    TrieNode *current;\n    std::string search;\n\npublic:\n    AutocompleteSystem(std::vector<std::string>& sentences, std::vector<int>& times) {\n        root = new TrieNode();\n        for (int i = 0; i < sentences.size(); ++i) {\n            insert(sentences[i], times[i]);\n        }\n        current = root;\n    }\n    \n    std::vector<std::string> input(char c) {\n        if (c == '#') {\n            insert(search, 1);\n            search = \"\";\n            current = root;\n            return {};\n        }\n        search += c;\n        if (!current) {\n            return {};\n        }\n        current = current->children[c];\n        if (!current) {\n            return {};\n        }\n        std::priority_queue<TrieNode*, std::vector<TrieNode*>, cmp> pq;\n        for (auto &[char_, node] : current->children) {\n            if (node->times) {\n                pq.push(node);\n            }\n        }\n        \n        std::vector<std::string> res;\n        while (!pq.empty() && res.size() < 3) {\n            res.push_back(pq.top()->sentence);\n            pq.pop();\n        }\n        return res;\n    }\n};\n```\n\n    \n    The algorithm implemented is a trie-based solution. The `AutocompleteSystem` class has a TrieNode structure and methods to insert sentences into the trie, as well as to find and return the top 3 historical hot sentences.\n\nThe TrieNode structure has a `children` dictionary that stores the characters and their child TrieNode references, a sentence attribute to store the sentence corresponding to the node (if it is the end of a sentence), and a times attribute to store the hot degree of the sentence.\n\nThe `insert` method takes a sentence and times as input and inserts the sentence into the trie structure by following the appropriate path based on each character.\n\nThe `input` method processes each character in the user input to search for matching historical hot sentences. If the user input is a special character '#' it stores the inputted sentence in the system and returns an empty list. When the user input is not a special character, the `input` method finds matching historical hot sentences by traversing the trie based on the characters of the user input. A priority queue (or sorting for JavaScript) is used to prioritize and return the top 3 hot historical sentences according to their hot degree and ASCII-code order.\n    ",
        "js": "\n    ```javascript\nclass TrieNode {\n    constructor() {\n        this.children = {};\n        this.sentence = \"\";\n        this.times = 0;\n    }\n}\n\nclass AutocompleteSystem {\n    constructor(sentences, times) {\n        this.root = new TrieNode();\n        this.current = this.root;\n        this.search = \"\";\n        \n        for (let i = 0; i < sentences.length; ++i) {\n            this.insert(sentences[i], times[i]);\n        }\n    }\n    \n    insert(sentence, times) {\n        let curr = this.root;\n        for (let c of sentence) {\n            if (!curr.children[c]) {\n                curr.children[c] = new TrieNode();\n            }\n            curr = curr.children[c];\n        }\n        curr.sentence = sentence;\n        curr.times += times;\n    }\n    \n    input(c) {\n        if (c === '#') {\n            this.insert(this.search, 1);\n            this.search = \"\";\n            this.current = this.root;\n            return [];\n        }\n        \n        this.search += c;\n        if (!this.current) {\n            return [];\n        }\n        \n        if (!this.current.children[c]) {\n            this.current = null;\n            return [];\n        }\n        \n        this.current = this.current.children[c];\n        const heap = [];\n        for (let node of Object.values(this.current.children)) {\n            if (node.times) {\n                heap.push([node]);\n            }\n        }\n        \n        heap.sort((a, b) => {\n            if (a.times === b.times) {\n                return a.sentence.localeCompare(b.sentence);\n            }\n            return b.times - a.times;\n        });\n        \n        const res = [];\n        for (let i = 0; i < 3 && i < heap.length; ++i) {\n            res.push(heap[i].sentence);\n        }\n        return res;\n    }\n}\n```\n\n    \n    The algorithm implemented is a trie-based solution. The `AutocompleteSystem` class has a TrieNode structure and methods to insert sentences into the trie, as well as to find and return the top 3 historical hot sentences.\n\nThe TrieNode structure has a `children` dictionary that stores the characters and their child TrieNode references, a sentence attribute to store the sentence corresponding to the node (if it is the end of a sentence), and a times attribute to store the hot degree of the sentence.\n\nThe `insert` method takes a sentence and times as input and inserts the sentence into the trie structure by following the appropriate path based on each character.\n\nThe `input` method processes each character in the user input to search for matching historical hot sentences. If the user input is a special character '#' it stores the inputted sentence in the system and returns an empty list. When the user input is not a special character, the `input` method finds matching historical hot sentences by traversing the trie based on the characters of the user input. A priority queue (or sorting for JavaScript) is used to prioritize and return the top 3 hot historical sentences according to their hot degree and ASCII-code order.\n    "
    },
    {
        "id": 126,
        "title": "Maximum Average Subarray II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is greater than or equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,12,-5,-6,50,3\\], k = 4\n**Output:** 12.75000\n**Explanation:**\n\\- When the length is 4, averages are \\[0.5, 12.75, 10.5\\] and the maximum average is 12.75\n- When the length is 5, averages are \\[10.4, 10.8\\] and the maximum average is 10.8\n- When the length is 6, averages are \\[9.16667\\] and the maximum average is 9.16667\nThe maximum average is when we choose a subarray of length 4 (i.e., the sub array \\[12, -5, -6, 50\\]) which has the max average 12.75, so we return 12.75\nNote that we do not consider the subarrays of length < 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5\\], k = 1\n**Output:** 5.00000"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= k <= n <= 104`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,12,-5,-6,50,3],4",
                "output": "12.75000"
            },
            {
                "input": "[5],1",
                "output": "5.00000"
            }
        ],
        "java": "\n    ```java\npublic double findMaxAverage(int[] nums, int k) {\n    long sum = 0;\n    for(int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    double max_avg = (double) sum / k;\n    \n    for(int i = k; i < nums.length; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = Math.max(max_avg, (double) sum / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "python": "\n    ```python\ndef findMaxAverage(nums, k):\n    total = sum(nums[:k])\n    max_avg = total / k\n    for i in range(k, len(nums)):\n        total += nums[i] - nums[i - k]\n        max_avg = max(max_avg, total / k)\n    return max_avg\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "c++": "\n    ```cpp\ndouble findMaxAverage(vector<int>& nums, int k) {\n    long sum = 0;\n    int n = nums.size();\n    for(int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    double max_avg = static_cast<double>(sum) / k;\n    \n    for(int i = k; i < n; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = max(max_avg, static_cast<double>(sum) / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "js": "\n    ```javascript\nfunction findMaxAverage(nums, k) {\n    let sum = 0;\n    for(let i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    let max_avg = sum / k;\n    \n    for(let i = k; i < nums.length; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    "
    },
    {
        "id": 127,
        "title": "4 Keys Keyboard",
        "difficulty": "Medium",
        "content": {
            "problem": "Imagine you have a special keyboard with the following keys:\n\n*   A: Print one `'A'` on the screen.\n*   Ctrl-A: Select the whole screen.\n*   Ctrl-C: Copy selection to buffer.\n*   Ctrl-V: Print buffer on screen appending it after what has already been printed.\n\nGiven an integer n, return _the maximum number of_ `'A'` _you can print on the screen with **at most**_ `n` _presses on the keys_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** We can at most get 3 A's on screen by pressing the following key sequence:\nA, A, A\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** 9\n**Explanation:** We can at most get 9 A's on screen by pressing following key sequence:\nA, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 50`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3",
                "output": "3"
            },
            {
                "input": "7",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int maxA(int n) {\n    int[] dp = new int[n + 1];\n    for(int i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(int j = 1; j <= i - 3; ++j)\n            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can create a dp array of size `n + 1` to store the maximum number of 'A's that can be printed with a maximum of `i` presses.\n\nFor each position `i` in the dp array, we initialize it with the value of `i`, as the minimum number of 'A's that can be printed is pressing the 'A' key `i` times. Next, we iterate through the previous positions, from `j = 1` to `i - 3`, and calculate the maximum number of 'A's we can obtain by copying the string of 'A's with `(i - j - 1)` Ctrl-V presses right after a Ctrl A and Ctrl C.\n\nTo calculate the maximum, we take the maximum between the current value of `dp[i]` and `dp[j] * (i - j - 1)`. Finally, return the value of `dp[n]`, as it represents the maximum number of 'A's that can be printed with a maximum of `n` presses.\n    ",
        "python": "\n    ```python\ndef maxA(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i - 2):\n            dp[i] = max(dp[i], dp[j] * (i - j - 1))\n    return dp[n]\n```\n    \n    The problem can be solved using dynamic programming. We can create a dp array of size `n + 1` to store the maximum number of 'A's that can be printed with a maximum of `i` presses.\n\nFor each position `i` in the dp array, we initialize it with the value of `i`, as the minimum number of 'A's that can be printed is pressing the 'A' key `i` times. Next, we iterate through the previous positions, from `j = 1` to `i - 3`, and calculate the maximum number of 'A's we can obtain by copying the string of 'A's with `(i - j - 1)` Ctrl-V presses right after a Ctrl A and Ctrl C.\n\nTo calculate the maximum, we take the maximum between the current value of `dp[i]` and `dp[j] * (i - j - 1)`. Finally, return the value of `dp[n]`, as it represents the maximum number of 'A's that can be printed with a maximum of `n` presses.\n    ",
        "c++": "\n    ```cpp\nint maxA(int n) {\n    vector<int> dp(n + 1);\n    for(int i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(int j = 1; j <= i - 3; ++j)\n            dp[i] = max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can create a dp array of size `n + 1` to store the maximum number of 'A's that can be printed with a maximum of `i` presses.\n\nFor each position `i` in the dp array, we initialize it with the value of `i`, as the minimum number of 'A's that can be printed is pressing the 'A' key `i` times. Next, we iterate through the previous positions, from `j = 1` to `i - 3`, and calculate the maximum number of 'A's we can obtain by copying the string of 'A's with `(i - j - 1)` Ctrl-V presses right after a Ctrl A and Ctrl C.\n\nTo calculate the maximum, we take the maximum between the current value of `dp[i]` and `dp[j] * (i - j - 1)`. Finally, return the value of `dp[n]`, as it represents the maximum number of 'A's that can be printed with a maximum of `n` presses.\n    ",
        "js": "\n    ```javascript\nfunction maxA(n) {\n    let dp = new Array(n + 1);\n    for(let i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(let j = 1; j <= i - 3; ++j)\n            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can create a dp array of size `n + 1` to store the maximum number of 'A's that can be printed with a maximum of `i` presses.\n\nFor each position `i` in the dp array, we initialize it with the value of `i`, as the minimum number of 'A's that can be printed is pressing the 'A' key `i` times. Next, we iterate through the previous positions, from `j = 1` to `i - 3`, and calculate the maximum number of 'A's we can obtain by copying the string of 'A's with `(i - j - 1)` Ctrl-V presses right after a Ctrl A and Ctrl C.\n\nTo calculate the maximum, we take the maximum between the current value of `dp[i]` and `dp[j] * (i - j - 1)`. Finally, return the value of `dp[n]`, as it represents the maximum number of 'A's that can be printed with a maximum of `n` presses.\n    "
    },
    {
        "id": 128,
        "title": "Two Sum IV - Input is a BST",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree and an integer `k`, return `true` _if there exist two elements in the BST such that their sum is equal to_ `k`, _or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,3,6,2,4,null,7\\], k = 9\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,3,6,2,4,null,7\\], k = 28\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-104 <= Node.val <= 104`\n*   `root` is guaranteed to be a **valid** binary search tree.\n*   `-105 <= k <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,3,6,2,4,null,7],9",
                "output": "true"
            },
            {
                "input": "[5,3,6,2,4,null,7],28",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean findTarget(TreeNode root, int k) {\n    Set<Integer> nodes = new HashSet<>();\n    return findNode(root, k, nodes);\n}\n\npublic boolean findNode(TreeNode root, int k, Set<Integer> nodes) {\n    if (root == null) return false;\n    if (nodes.contains(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "python": "\n    ```python\ndef findTarget(root, k):\n    nodes = set()\n    return findNode(root, k, nodes)\n\ndef findNode(root, k, nodes):\n    if not root:\n        return False\n    if k - root.val in nodes:\n        return True\n    nodes.add(root.val)\n    return findNode(root.left, k, nodes) or findNode(root.right, k, nodes)\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "c++": "\n    ```cpp\nbool findTarget(TreeNode* root, int k) {\n    unordered_set<int> nodes;\n    return findNode(root, k, nodes);\n}\n\nbool findNode(TreeNode* root, int k, unordered_set<int>& nodes) {\n    if (!root) return false;\n    if (nodes.count(k - root->val)) return true;\n    nodes.insert(root->val);\n    return findNode(root->left, k, nodes) || findNode(root->right, k, nodes);\n}\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "js": "\n    ```javascript\nfunction findTarget(root, k) {\n    const nodes = new Set();\n    return findNode(root, k, nodes);\n}\n\nfunction findNode(root, k, nodes) {\n    if (!root) return false;\n    if (nodes.has(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    "
    },
    {
        "id": 129,
        "title": "Coin Path",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `coins` (**1-indexed**) of length `n` and an integer `maxJump`. You can jump to any index `i` of the array `coins` if `coins[i] != -1` and you have to pay `coins[i]` when you visit index `i`. In addition to that, if you are currently at index `i`, you can only jump to any index `i + k` where `i + k <= n` and `k` is a value in the range `[1, maxJump]`.\n\nYou are initially positioned at index `1` (`coins[1]` is not `-1`). You want to find the path that reaches index n with the minimum cost.\n\nReturn an integer array of the indices that you will visit in order so that you can reach index n with the minimum cost. If there are multiple paths with the same cost, return the **lexicographically smallest** such path. If it is not possible to reach index n, return an empty array.\n\nA path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j` exists, then `x < y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** coins = \\[1,2,4,-1,2\\], maxJump = 2\n**Output:** \\[1,3,5\\]\n\n",
                "**Example 2:**\n\n**Input:** coins = \\[1,2,4,-1,2\\], maxJump = 1\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= coins.length <= 1000`\n*   `-1 <= coins[i] <= 100`\n*   `coins[1] != -1`\n*   `1 <= maxJump <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,4,-1,2],2",
                "output": "[1,3,5]"
            },
            {
                "input": "[1,2,4,-1,2],1",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\nclass Solution {\n    public int[] cheapestJump(int[] coins, int maxJump) {\n        int n = coins.length;\n        int[] dp = new int[n];\n        int[] parent = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        Arrays.fill(parent, -1);\n        dp[0] = coins[0];\n        for (int i = 0; i < n; ++i) {\n            if (coins[i] == -1) continue;\n            for (int j = 1; j <= maxJump && i + j < n; ++j) {\n                int next = i + j;\n                int cost = coins[next] + dp[i];\n                if (cost < dp[next]) {\n                    dp[next] = cost;\n                    parent[next] = i;\n                }\n            }\n        }\n        List<Integer> ansList = new ArrayList<>();\n        if (dp[n - 1] == Integer.MAX_VALUE) return new int[0];\n        int cur = n - 1;\n        while (cur != -1) {\n            ansList.add(cur + 1);\n            cur = parent[cur];\n        }\n        Collections.reverse(ansList);\n        int[] ans = new int[ansList.size()];\n        for (int i = 0; i < ansLIST.size(); i++) {\n            ans[i] = ansList.get(i);\n        }\n        return ans;\n    }\n}\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "python": "\n    ```python\ndef cheapestJump(coins, maxJump):\n    n = len(coins)\n    dp = [float('inf')] * n\n    parent = [-1] * n\n    dp[0] = coins[0]\n    for i in range(n):\n        if coins[i] == -1:\n            continue\n        for j in range(1, maxJump + 1):\n            if i + j >= n:\n                break\n            next = i + j\n            cost = coins[next] + dp[i]\n            if cost < dp[next]:\n                dp[next] = cost\n                parent[next] = i\n    ans = []\n    if dp[n - 1] == float('inf'):\n        return ans\n    cur = n - 1\n    while cur != -1:\n        ans.append(cur + 1)\n        cur = parent[cur]\n    ans.reverse()\n    return ans\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nvector<int> cheapestJump(vector<int>& coins, int maxJump) {\n    int n = coins.size();\n    vector<int> dp(n, 1e9), parent(n, -1);\n    dp[0] = coins[0];\n    for (int i = 0; i < n; ++i) {\n        if (coins[i] == -1) continue;\n        for (int j = 1; j <= maxJump && i + j < n; ++j) {\n            int next = i + j;\n            int cost = coins[next] + dp[i];\n            if (cost < dp[next]) {\n                dp[next] = cost;\n                parent[next] = i;\n            }\n        }\n    }\n    vector<int> ans;\n    if (dp[n - 1] == 1e9) return ans;\n    int cur = n - 1;\n    while (cur != -1) {\n        ans.push_back(cur + 1);\n        cur = parent[cur];\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "js": "\n    ```javascript\nfunction cheapestJump(coins, maxJump) {\n    const n = coins.length;\n    const dp = new Array(n).fill(Infinity);\n    const parent = new Array(n).fill(-1);\n    dp[0] = coins[0];\n    for (let i = 0; i < n; ++i) {\n        if (coins[i] === -1) continue;\n        for (let j = 1; j <= maxJump && i + j < n; ++j) {\n            const next = i + j;\n            const cost = coins[next] + dp[i];\n            if (cost < dp[next]) {\n                dp[next] = cost;\n                parent[next] = i;\n            }\n        }\n    }\n    const ans = [];\n    if (dp[n - 1] === Infinity) return ans;\n    let cur = n - 1;\n    while (cur !== -1) {\n        ans.push(cur + 1);\n        cur = parent[cur];\n    }\n    ans.reverse();\n    return ans;\n}\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    "
    },
    {
        "id": 130,
        "title": "Remove 9",
        "difficulty": "Hard",
        "content": {
            "problem": "Start from integer `1`, remove any integer that contains `9` such as `9`, `19`, `29`...\n\nNow, you will have a new integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...]`.\n\nGiven an integer `n`, return _the_ `nth` (**1-indexed**) integer in the new sequence.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 9\n**Output:** 10\n\n",
                "**Example 2:**\n\n**Input:** n = 10\n**Output:** 11"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 8 * 108`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "9",
                "output": "10"
            },
            {
                "input": "10",
                "output": "11"
            }
        ],
        "java": "\n    ```java\npublic int newInteger(int n) {\n    int result = 0, base = 1;\n    while (n>0) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "python": "\n    ```python\ndef newInteger(n):\n    result = 0\n    base = 1\n    while n:\n        result += n % 9 * base\n        n //= 9\n        base *= 10\n    return result\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "c++": "\n    ```cpp\nint newInteger(int n) {\n    int result = 0, base = 1;\n    while (n) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "js": "\n    ```javascript\nfunction newInteger(n) {\n    let result = 0, base = 1;\n    while (n > 0) {\n        result += (n % 9) * base;\n        n = Math.floor(n / 9);\n        base *= 10;\n    }\n    return result;\n}\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    "
    },
    {
        "id": 131,
        "title": "Equal Tree Partition",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return `true` _if you can partition the tree into two trees with equal sums of values after removing exactly one edge on the original tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,10,10,null,null,2,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,10,null,null,2,20\\]\n**Output:** false\n**Explanation:** You cannot split the tree into two trees with equal sums after removing exactly one edge on the tree."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,10,10,null,null,2,3]",
                "output": "true"
            },
            {
                "input": "[1,2,10,null,null,2,20]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public boolean checkEqualTree(TreeNode root) {\n        Set<Integer> seen = new HashSet<>();\n        int total = sum(root, seen);\n        if (total % 2 == 0) {\n            seen.remove(total);\n            return seen.contains(total / 2);\n        }\n        return false;\n    }\n    \n    private int sum(TreeNode node, Set<Integer> seen) {\n        if (node == null) return 0;\n        int s = node.val + sum(node.left, seen) + sum(node.right, seen);\n        seen.add(s);\n        return s;\n    }\n}\n```\n\n    \n    The algorithm does a post-order traversal of the tree and calculates the sums of the subtrees as it traverses. It stores these sums in a set (or unordered_set in C++). Then, it checks if the set contains a value equal to half the total sum of the tree. If it does, that means there is a subtree with equal sum to the other half of the tree after removing one edge (which connects the subtree to the main tree). If the total sum is odd, it is not possible to divide the tree into two equal parts and it returns false.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def checkEqualTree(self, root: TreeNode) -> bool:\n        def _sum(node, seen):\n            if not node:\n                return 0\n            s = node.val + _sum(node.left, seen) + _sum(node.right, seen)\n            seen.add(s)\n            return s\n\n        seen = set()\n        total = _sum(root, seen)\n        return total % 2 == 0 and (total // 2) in seen\n```\n\n    \n    The algorithm does a post-order traversal of the tree and calculates the sums of the subtrees as it traverses. It stores these sums in a set (or unordered_set in C++). Then, it checks if the set contains a value equal to half the total sum of the tree. If it does, that means there is a subtree with equal sum to the other half of the tree after removing one edge (which connects the subtree to the main tree). If the total sum is odd, it is not possible to divide the tree into two equal parts and it returns false.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_set>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    bool checkEqualTree(TreeNode* root) {\n        unordered_set<int> seen;\n        int total = sum(root, seen);\n        if(total % 2 == 0) {\n            seen.erase(total);\n            return seen.count(total / 2);\n        }\n        return false;\n    }\n    int sum(TreeNode* node, unordered_set<int>& seen) {\n        if (!node) return 0;\n        int s = node->val + sum(node->left, seen) + sum(node->right, seen);\n        seen.insert(s);\n        return s;\n    }\n};\n```\n\n    \n    The algorithm does a post-order traversal of the tree and calculates the sums of the subtrees as it traverses. It stores these sums in a set (or unordered_set in C++). Then, it checks if the set contains a value equal to half the total sum of the tree. If it does, that means there is a subtree with equal sum to the other half of the tree after removing one edge (which connects the subtree to the main tree). If the total sum is odd, it is not possible to divide the tree into two equal parts and it returns false.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nvar checkEqualTree = function(root) {\n    let seen = new Set();\n    let total = sum(root, seen);\n    if (total % 2 === 0) {\n        seen.delete(total);\n        return seen.has(total / 2)\n    }\n    return false;\n\n    function sum(node, seen) {\n        if (!node) return 0;\n        let s = node.val + sum(node.left, seen) + sum(node.right, seen)\n        seen.add(s);\n        return s;\n    }\n};\n```\n\n    \n    The algorithm does a post-order traversal of the tree and calculates the sums of the subtrees as it traverses. It stores these sums in a set (or unordered_set in C++). Then, it checks if the set contains a value equal to half the total sum of the tree. If it does, that means there is a subtree with equal sum to the other half of the tree after removing one edge (which connects the subtree to the main tree). If the total sum is odd, it is not possible to divide the tree into two equal parts and it returns false.\n    "
    },
    {
        "id": 132,
        "title": "Path Sum IV",
        "difficulty": "Medium",
        "content": {
            "problem": "If the depth of a tree is smaller than `5`, then this tree can be represented by an array of three-digit integers. For each integer in this array:\n\n*   The hundreds digit represents the depth `d` of this node where `1 <= d <= 4`.\n*   The tens digit represents the position `p` of this node in the level it belongs to where `1 <= p <= 8`. The position is the same as that in a full binary tree.\n*   The units digit represents the value `v` of this node where `0 <= v <= 9`.\n\nGiven an array of **ascending** three-digit integers `nums` representing a binary tree with a depth smaller than `5`, return _the sum of all paths from the root towards the leaves_.\n\nIt is **guaranteed** that the given array represents a valid connected binary tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[113,215,221\\]\n**Output:** 12\n**Explanation:** The tree that the list represents is shown.\nThe path sum is (3 + 5) + (3 + 1) = 12.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[113,221\\]\n**Output:** 4\n**Explanation:** The tree that the list represents is shown. \nThe path sum is (3 + 1) = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 15`\n*   `110 <= nums[i] <= 489`\n*   `nums` represents a valid binary tree with depth less than `5`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[113,215,221]",
                "output": "12"
            },
            {
                "input": "[113,221]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int sum(TreeNode root, int val) {\n    if (root == null) return 0;\n    val = val * 10 + root.val;\n    if (root.left == null && root.right == null) return val;\n    return sum(root.left, val) + sum(root.right, val);\n}\n\npublic int pathSum(int[] nums) {\n    TreeNode root = new TreeNode(nums[0] % 10);\n    for (int num : nums) {\n        int depth = num / 100;\n        int pos = num % 100 / 10;\n        int val = num % 10;\n        TreeNode cur = root;\n        for (int d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (cur.right == null) cur.right = new TreeNode(val);\n                cur = cur.right;\n            } else {\n                if (cur.left == null) cur.left = new TreeNode(val);\n                cur = cur.left;\n            }\n        }\n    }\n    return sum(root, 0);\n}\n```\n    \n    The algorithm builds the binary tree from the input array `nums`, constructs a TreeNode for each element in `nums`:\n1. The TreeNode constructor takes the value of the node, which is the units digit.\n2. The element is then divided by 100 to get the depth, and modulo 100 is taken and then divided by 10 to get the position.\n3. Traversing level by level, the nodes are inserted, updating the left or right child pointer accordingly.\n\nAfter building the tree, the `sum` function is called to calculate the path sum of the tree, passing the root node and the current sum value as parameters. It recursively calculates the path sum for each child, updating the sum and returning it when the leaf node is reached.\n\nAt the end, the total path sum is returned.\n    ",
        "python": "\n    ```python\ndef sumPaths(root, val):\n    if not root: return 0\n    val = val * 10 + root.val\n    if not root.left and not root.right: return val\n    return sumPaths(root.left, val) + sumPaths(root.right, val)\n\ndef pathSum(nums):\n    root = TreeNode(nums[0] % 10)\n    for num in nums:\n        depth, pos, val = num // 100, num % 100 // 10, num % 10\n        cur = root\n        for d in reversed(range(depth - 1)):\n            if (pos >> d) & 1:\n                if not cur.right: cur.right = TreeNode(val)\n                cur = cur.right\n            else:\n                if not cur.left: cur.left = TreeNode(val)\n                cur = cur.left\n    return sumPaths(root, 0)\n```\n    \n    The algorithm builds the binary tree from the input array `nums`, constructs a TreeNode for each element in `nums`:\n1. The TreeNode constructor takes the value of the node, which is the units digit.\n2. The element is then divided by 100 to get the depth, and modulo 100 is taken and then divided by 10 to get the position.\n3. Traversing level by level, the nodes are inserted, updating the left or right child pointer accordingly.\n\nAfter building the tree, the `sum` function is called to calculate the path sum of the tree, passing the root node and the current sum value as parameters. It recursively calculates the path sum for each child, updating the sum and returning it when the leaf node is reached.\n\nAt the end, the total path sum is returned.\n    ",
        "c++": "\n    ```cpp\nint sum(TreeNode* root, int val) {\n    if (!root) return 0;\n    val = val * 10 + root->val;\n    if (!root->left && !root->right) return val;\n    return sum(root->left, val) + sum(root->right, val);\n}\n\nint pathSum(vector<int>& nums) {\n    TreeNode* root = new TreeNode(nums[0] % 10);\n    for (int num : nums) {\n        int depth = num / 100, pos = num % 100 / 10, val = num % 10;\n        TreeNode* cur = root;\n        for (int d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (!cur->right) cur->right = new TreeNode(val);\n                cur = cur->right;\n            } else {\n                if (!cur->left) cur->left = new TreeNode(val);\n                cur = cur->left;\n            }\n        }\n    }\n    return sum(root, 0);\n}\n```\n    \n    The algorithm builds the binary tree from the input array `nums`, constructs a TreeNode for each element in `nums`:\n1. The TreeNode constructor takes the value of the node, which is the units digit.\n2. The element is then divided by 100 to get the depth, and modulo 100 is taken and then divided by 10 to get the position.\n3. Traversing level by level, the nodes are inserted, updating the left or right child pointer accordingly.\n\nAfter building the tree, the `sum` function is called to calculate the path sum of the tree, passing the root node and the current sum value as parameters. It recursively calculates the path sum for each child, updating the sum and returning it when the leaf node is reached.\n\nAt the end, the total path sum is returned.\n    ",
        "js": "\n    ```javascript\nfunction sum(root, val) {\n    if (!root) return 0;\n    val = val * 10 + root.val;\n    if (!root.left && !root.right) return val;\n    return sum(root.left, val) + sum(root.right, val);\n}\n\nfunction pathSum(nums) {\n    const root = new TreeNode(nums[0] % 10);\n    for (const num of nums) {\n        const depth = Math.floor(num / 100);\n        const pos = Math.floor(num % 100 / 10);\n        const val = num % 10;\n        let cur = root;\n        for (let d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (!cur.right) cur.right = new TreeNode(val);\n                cur = cur.right;\n            } else {\n                if (!cur.left) cur.left = new TreeNode(val);\n                cur = cur.left;\n            }\n        }\n    }\n    return sum(root, 0);\n}\n```\n    \n    The algorithm builds the binary tree from the input array `nums`, constructs a TreeNode for each element in `nums`:\n1. The TreeNode constructor takes the value of the node, which is the units digit.\n2. The element is then divided by 100 to get the depth, and modulo 100 is taken and then divided by 10 to get the position.\n3. Traversing level by level, the nodes are inserted, updating the left or right child pointer accordingly.\n\nAfter building the tree, the `sum` function is called to calculate the path sum of the tree, passing the root node and the current sum value as parameters. It recursively calculates the path sum for each child, updating the sum and returning it when the leaf node is reached.\n\nAt the end, the total path sum is returned.\n    "
    },
    {
        "id": 133,
        "title": "Next Closest Time",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `time` represented in the format `\"HH:MM \"`, form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.\n\nYou may assume the given input string is always valid. For example, `\"01:34 \"`, `\"12:09 \"` are all valid. `\"1:34 \"`, `\"12:9 \"` are all invalid.",
            "examples": [
                "**Example 1:**\n\n**Input:** time =  \"19:34 \"\n**Output:**  \"19:39 \"\n**Explanation:** The next closest time choosing from digits **1**, **9**, **3**, **4**, is **19:39**, which occurs 5 minutes later.\nIt is not **19:33**, because this occurs 23 hours and 59 minutes later.\n\n",
                "**Example 2:**\n\n**Input:** time =  \"23:59 \"\n**Output:**  \"22:22 \"\n**Explanation:** The next closest time choosing from digits **2**, **3**, **5**, **9**, is **22:22**.\nIt may be assumed that the returned time is next day's time since it is smaller than the input time numerically."
            ],
            "constraints": "**Constraints:**\n\n*   `time.length == 5`\n*   `time` is a valid time in the form `\"HH:MM \"`.\n*   `0 <= HH < 24`\n*   `0 <= MM < 60`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"19:34\"",
                "output": "\"19:39\""
            },
            {
                "input": "\"23:59\"",
                "output": "\"22:22\""
            }
        ],
        "java": "\n    ```java\npublic String nextClosestTime(String time) {\n    String digits = time.substring(0, 2) + time.substring(3);\n    String next_time = time;\n    int elapsed = Integer.MAX_VALUE;\n\n    for (char a : digits.toCharArray()) {\n    for (char b : digits.toCharArray()) {\n    for (char c : digits.toCharArray()) {\n    for (char d : digits.toCharArray()) {\n        String candidate_time = new StringBuilder().append(a).append(b).append(':').append(c).append(d).toString();\n        int cand_elapsed = (Integer.parseInt(candidate_time.substring(0, 2)) * 60 + Integer.parseInt(candidate_time.substring(3)) -\n                            Integer.parseInt(time.substring(0, 2)) * 60 - Integer.parseInt(time.substring(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}\n```\n    \n    The given algorithm tries all possible combinations of the given digits to create valid \"HH:MM\" times. We calculate the time difference between the given time and each candidate time in minutes (taking into account the daily wraparound, hence the `% 1440`). If the computed elapsed time is less than the previous one while being positive, we update the next closest time.\n\n- Initialize `digits`, `next_time`, and `elapsed` variables.\n- Use multiple nested loops to iterate through all possible combinations of the digits for creating a time.\n- For each digit combination, form a candidate time.\n- Calculate the elapsed time from the given input time to this candidate time, taking into account the daily wraparound.\n- If the elapsed time is smaller than the current minimum time difference and greater than 0, update the next closest time and the elapsed time.\n- After all combinations have been exhausted, return the next closest time.\n    ",
        "python": "\n    ```python\ndef nextClosestTime(time: str) -> str:\n    digits = time[:2] + time[3:]\n    next_time = time\n    elapsed = float('inf')\n\n    for a in digits:\n        for b in digits:\n            for c in digits:\n                for d in digits:\n                    candidate_time = f\"{a}{b}:{c}{d}\"\n                    cand_elapsed = (int(candidate_time[:2]) * 60 + int(candidate_time[3:]) -\n                                    int(time[:2]) * 60 - int(time[3:]) + 1440) % 1440\n                    if 0 < cand_elapsed < elapsed:\n                        elapsed = cand_elapsed\n                        next_time = candidate_time\n\n    return next_time\n```\n    \n    The given algorithm tries all possible combinations of the given digits to create valid \"HH:MM\" times. We calculate the time difference between the given time and each candidate time in minutes (taking into account the daily wraparound, hence the `% 1440`). If the computed elapsed time is less than the previous one while being positive, we update the next closest time.\n\n- Initialize `digits`, `next_time`, and `elapsed` variables.\n- Use multiple nested loops to iterate through all possible combinations of the digits for creating a time.\n- For each digit combination, form a candidate time.\n- Calculate the elapsed time from the given input time to this candidate time, taking into account the daily wraparound.\n- If the elapsed time is smaller than the current minimum time difference and greater than 0, update the next closest time and the elapsed time.\n- After all combinations have been exhausted, return the next closest time.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring nextClosestTime(string time) {\n    string digits = time.substr(0, 2) + time.substr(3);\n    string next_time = time;\n    int elapsed = INT_MAX;\n\n    for (char a : digits) {\n    for (char b : digits) {\n    for (char c : digits) {\n    for (char d : digits) {\n        string candidate_time = string({a, b, ':', c, d});\n        int cand_elapsed = (stoi(candidate_time.substr(0, 2)) * 60 + stoi(candidate_time.substr(3)) -\n                            stoi(time.substr(0, 2)) * 60 - stoi(time.substr(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}\n```\n    \n    The given algorithm tries all possible combinations of the given digits to create valid \"HH:MM\" times. We calculate the time difference between the given time and each candidate time in minutes (taking into account the daily wraparound, hence the `% 1440`). If the computed elapsed time is less than the previous one while being positive, we update the next closest time.\n\n- Initialize `digits`, `next_time`, and `elapsed` variables.\n- Use multiple nested loops to iterate through all possible combinations of the digits for creating a time.\n- For each digit combination, form a candidate time.\n- Calculate the elapsed time from the given input time to this candidate time, taking into account the daily wraparound.\n- If the elapsed time is smaller than the current minimum time difference and greater than 0, update the next closest time and the elapsed time.\n- After all combinations have been exhausted, return the next closest time.\n    ",
        "js": "\n    ```javascript\nfunction nextClosestTime(time) {\n    let digits = time.substring(0, 2) + time.substring(3);\n    let next_time = time;\n    let elapsed = Infinity;\n\n    for (const a of digits) {\n    for (const b of digits) {\n    for (const c of digits) {\n    for (const d of digits) {\n        const candidate_time = `${a}${b}:${c}${d}`;\n        const cand_elapsed = (parseInt(candidate_time.substring(0, 2)) * 60 + parseInt(candidate_time.substring(3)) -\n                              parseInt(time.substring(0, 2)) * 60 - parseInt(time.substring(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}\n```\n    \n    The given algorithm tries all possible combinations of the given digits to create valid \"HH:MM\" times. We calculate the time difference between the given time and each candidate time in minutes (taking into account the daily wraparound, hence the `% 1440`). If the computed elapsed time is less than the previous one while being positive, we update the next closest time.\n\n- Initialize `digits`, `next_time`, and `elapsed` variables.\n- Use multiple nested loops to iterate through all possible combinations of the digits for creating a time.\n- For each digit combination, form a candidate time.\n- Calculate the elapsed time from the given input time to this candidate time, taking into account the daily wraparound.\n- If the elapsed time is smaller than the current minimum time difference and greater than 0, update the next closest time and the elapsed time.\n- After all combinations have been exhausted, return the next closest time.\n    "
    },
    {
        "id": 134,
        "title": "K Empty Slots",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` bulbs in a row numbered from `1` to `n`. Initially, all the bulbs are turned off. We turn on **exactly one** bulb every day until all bulbs are on after `n` days.\n\nYou are given an array `bulbs` of length `n` where `bulbs[i] = x` means that on the `(i+1)th` day, we will turn on the bulb at position `x` where `i` is **0-indexed** and `x` is **1-indexed.**\n\nGiven an integer `k`, return _the **minimum day number** such that there exists two **turned on** bulbs that have **exactly** `k` bulbs between them that are **all turned off**. If there isn't such day, return `-1`._",
            "examples": [
                "**Example 1:**\n\n**Input:** bulbs = \\[1,3,2\\], k = 1\n**Output:** 2\n**Explanation:**\nOn the first day: bulbs\\[0\\] = 1, first bulb is turned on: \\[1,0,0\\]\nOn the second day: bulbs\\[1\\] = 3, third bulb is turned on: \\[1,0,1\\]\nOn the third day: bulbs\\[2\\] = 2, second bulb is turned on: \\[1,1,1\\]\nWe return 2 because on the second day, there were two on bulbs with one off bulb between them.\n\n",
                "**Example 2:**\n\n**Input:** bulbs = \\[1,2,3\\], k = 1\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == bulbs.length`\n*   `1 <= n <= 2 * 104`\n*   `1 <= bulbs[i] <= n`\n*   `bulbs` is a permutation of numbers from `1` to `n`.\n*   `0 <= k <= 2 * 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,3,2],1",
                "output": "2"
            },
            {
                "input": "[1,2,3],1",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int kEmptySlots(int[] bulbs, int k) {\n    int[] days = new int[bulbs.length];\n    for(int i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n    \n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.length) {\n        int i = left + 1;\n        for (; i < right; i++) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n    \n    return ans == Integer.MAX_VALUE ? -1 : ans + 1;\n}\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "python": "\n    ```python\ndef kEmptySlots(bulbs, k):\n    days = [0] * len(bulbs)\n    for i, bulb in enumerate(bulbs):\n        days[bulb - 1] = i\n\n    ans = float('inf')\n    left = 0\n    right = k + 1\n    while right < len(days):\n        i = left + 1\n        for i in range(left + 1, right):\n            if days[i] < days[left] or days[i] < days[right]:\n                left = i\n                break\n        else:\n            ans = min(ans, max(days[left], days[right]))\n            left += 1\n            right += 1\n\n    return -1 if ans == float('inf') else ans + 1\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "c++": "\n    ```cpp\nint kEmptySlots(vector<int>& bulbs, int k) {\n    vector<int> days(bulbs.size());\n    for(int i = 0; i < bulbs.size(); ++i) {\n        days[bulbs[i] - 1] = i;\n    }\n    \n    int ans = INT_MAX;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.size()) {\n        int i = left + 1;\n        for (; i < right; ++i) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = min(ans, max(days[left], days[right]));\n            left ++;\n            right ++;\n        }\n    }\n    \n    return ans == INT_MAX ? -1 : ans + 1;\n}\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "js": "\n    ```javascript\nfunction kEmptySlots(bulbs, k) {\n    const days = new Array(bulbs.length);\n    for (let i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n\n    let ans = Number.MAX_SAFE_INTEGER;\n    let left = 0;\n    let right = k + 1;\n    while (right < days.length) {\n        let i = left + 1;\n        while (i < right) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n            i++;\n        }\n        if (i === right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans + 1;\n}\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    "
    },
    {
        "id": 135,
        "title": "Number of Distinct Islands",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nAn island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.\n\nReturn _the number of **distinct** islands_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,0,0,0\\],\\[1,1,0,0,0\\],\\[0,0,0,1,1\\],\\[0,0,0,1,1\\]\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,0,1,1\\],\\[1,0,0,0,0\\],\\[0,0,0,0,1\\],\\[1,1,0,1,1\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]",
                "output": "1"
            },
            {
                "input": "[[1,1,0,1,1],[1,0,0,0,0],[0,0,0,0,1],[1,1,0,1,1]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic int numDistinctIslands(int[][] grid) {\n    HashSet<ArrayList<ArrayList<Integer>>> uniqueIslands = new HashSet<>();\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1) {\n                ArrayList<ArrayList<Integer>> islandShape = new ArrayList<>();\n                dfs(grid, i, j, i, j, islandShape);\n                Collections.sort(islandShape, (shape1, shape2) -> {\n                    int cmp = shape1.get(0).compareTo(shape2.get(0));\n                    if (cmp != 0) return cmp;\n                    return shape1.get(1).compareTo(shape2.get(1));\n                });\n                uniqueIslands.add(islandShape);\n            }\n        }\n    }\n    return uniqueIslands.size();\n}\n\nprivate void dfs(int[][] grid, int i, int j, int i0, int j0, ArrayList<ArrayList<Integer>> shape) {\n    if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 1) {\n        grid[i][j] = 2;\n        ArrayList<Integer> current = new ArrayList<>();\n        current.add(i - i0);\n        current.add(j - j0);\n        shape.add(current);\n        dfs(grid, i - 1, j, i0, j0, shape);\n        dfs(grid, i + 1, j, i0, j0, shape);\n        dfs(grid, i, j - 1, i0, j0, shape);\n        dfs(grid, i, j + 1, i0, j0, shape);\n    }\n}\n```\n    \n    The algorithm behind this code is as follows:\n\n1. Initialize the set called `unique_islands` to store the shapes of different islands that are found.\n2. Iterate through the rows and columns of the grid.\n3. When a land cell (grid[i][j] == 1) is found, we've discovered a new island. To find the shape of this island:\n    - Call the `dfs` function (Depth First Search) starting from the current cell.\n    - `dfs` pushes visited cells' relative position to the island_shape list.\n    - Visited cells will have their value changed from 1 to 2 to avoid revisiting.\n4. After exploring the island, the list of relative positions representing the island_shape needs to be sorted to ensure uniqueness.\n5. Add the sorted island_shape to the set of unique_islands.\n6. After traversing the grid, return the number of islands in the unique_islands set.\n\nThe algorithm is similar across all languages, with small syntax differences. Note that JavaScript serializes the island_shape list to a JSON string before adding to the Set, as native Sets don't have deep equality comparison.\n    ",
        "python": "\n    ```python\ndef numDistinctIslands(grid):\n    unique_islands = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                island_shape = []\n                dfs(grid, i, j, i, j, island_shape)\n                island_shape.sort()\n                unique_islands.add(tuple(island_shape))\n    return len(unique_islands)\n\ndef dfs(grid, i, j, i0, j0, shape):\n    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:\n        grid[i][j] = 2\n        shape.append((i - i0, j - j0))\n        dfs(grid, i - 1, j, i0, j0, shape)\n        dfs(grid, i + 1, j, i0, j0, shape)\n        dfs(grid, i, j - 1, i0, j0, shape)\n        dfs(grid, i, j + 1, i0, j0, shape)\n```\n    \n    The algorithm behind this code is as follows:\n\n1. Initialize the set called `unique_islands` to store the shapes of different islands that are found.\n2. Iterate through the rows and columns of the grid.\n3. When a land cell (grid[i][j] == 1) is found, we've discovered a new island. To find the shape of this island:\n    - Call the `dfs` function (Depth First Search) starting from the current cell.\n    - `dfs` pushes visited cells' relative position to the island_shape list.\n    - Visited cells will have their value changed from 1 to 2 to avoid revisiting.\n4. After exploring the island, the list of relative positions representing the island_shape needs to be sorted to ensure uniqueness.\n5. Add the sorted island_shape to the set of unique_islands.\n6. After traversing the grid, return the number of islands in the unique_islands set.\n\nThe algorithm is similar across all languages, with small syntax differences. Note that JavaScript serializes the island_shape list to a JSON string before adding to the Set, as native Sets don't have deep equality comparison.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<set>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& grid, int i, int j, int i0, int j0, vector<pair<int, int>>& shape) {\n    if (i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {\n        grid[i][j] = 2;\n        shape.push_back({i - i0, j - j0});\n        dfs(grid, i - 1, j, i0, j0, shape);\n        dfs(grid, i + 1, j, i0, j0, shape);\n        dfs(grid, i, j - 1, i0, j0, shape);\n        dfs(grid, i, j + 1, i0, j0, shape);\n    }\n}\n\nint numDistinctIslands(vector<vector<int>>& grid) {\n    set<vector<pair<int, int>>> unique_islands;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                vector<pair<int,int>> island_shape;\n                dfs(grid, i, j, i, j, island_shape);\n                sort(island_shape.begin(), island_shape.end());\n                unique_islands.insert(island_shape);\n            }\n        }\n    }\n    return unique_islands.size();\n}\n```\n    \n    The algorithm behind this code is as follows:\n\n1. Initialize the set called `unique_islands` to store the shapes of different islands that are found.\n2. Iterate through the rows and columns of the grid.\n3. When a land cell (grid[i][j] == 1) is found, we've discovered a new island. To find the shape of this island:\n    - Call the `dfs` function (Depth First Search) starting from the current cell.\n    - `dfs` pushes visited cells' relative position to the island_shape list.\n    - Visited cells will have their value changed from 1 to 2 to avoid revisiting.\n4. After exploring the island, the list of relative positions representing the island_shape needs to be sorted to ensure uniqueness.\n5. Add the sorted island_shape to the set of unique_islands.\n6. After traversing the grid, return the number of islands in the unique_islands set.\n\nThe algorithm is similar across all languages, with small syntax differences. Note that JavaScript serializes the island_shape list to a JSON string before adding to the Set, as native Sets don't have deep equality comparison.\n    ",
        "js": "\n    ```javascript\nfunction numDistinctIslands(grid) {\n    const uniqueIslands = new Set();\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === 1) {\n                const islandShape = [];\n                dfs(grid, i, j, i, j, islandShape);\n                islandShape.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n                uniqueIslands.add(JSON.stringify(islandShape));\n            }\n        }\n    }\n    return uniqueIslands.size;\n}\n\nfunction dfs(grid, i, j, i0, j0, shape) {\n    if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 1) {\n        grid[i][j] = 2;\n        shape.push([i - i0, j - j0]);\n        dfs(grid, i - 1, j, i0, j0, shape);\n        dfs(grid, i + 1, j, i0, j0, shape);\n        dfs(grid, i, j - 1, i0, j0, shape);\n        dfs(grid, i, j + 1, i0, j0, shape);\n    }\n}\n```\n    \n    The algorithm behind this code is as follows:\n\n1. Initialize the set called `unique_islands` to store the shapes of different islands that are found.\n2. Iterate through the rows and columns of the grid.\n3. When a land cell (grid[i][j] == 1) is found, we've discovered a new island. To find the shape of this island:\n    - Call the `dfs` function (Depth First Search) starting from the current cell.\n    - `dfs` pushes visited cells' relative position to the island_shape list.\n    - Visited cells will have their value changed from 1 to 2 to avoid revisiting.\n4. After exploring the island, the list of relative positions representing the island_shape needs to be sorted to ensure uniqueness.\n5. Add the sorted island_shape to the set of unique_islands.\n6. After traversing the grid, return the number of islands in the unique_islands set.\n\nThe algorithm is similar across all languages, with small syntax differences. Note that JavaScript serializes the island_shape list to a JSON string before adding to the Set, as native Sets don't have deep equality comparison.\n    "
    },
    {
        "id": 136,
        "title": "Search in a Sorted Array of Unknown Size",
        "difficulty": "Medium",
        "content": {
            "problem": "This is an **_interactive problem_**.\n\nYou have a sorted array of **unique** elements and an **unknown size**. You do not have an access to the array but you can use the `ArrayReader` interface to access it. You can call `ArrayReader.get(i)` that:\n\n*   returns the value at the `ith` index (**0-indexed**) of the secret array (i.e., `secret[i]`), or\n*   returns `231 - 1` if the `i` is out of the boundary of the array.\n\nYou are also given an integer `target`.\n\nReturn the index `k` of the hidden array where `secret[k] == target` or return `-1` otherwise.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** secret = \\[-1,0,3,5,9,12\\], target = 9\n**Output:** 4\n**Explanation:** 9 exists in secret and its index is 4.\n\n",
                "**Example 2:**\n\n**Input:** secret = \\[-1,0,3,5,9,12\\], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in secret so return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= secret.length <= 104`\n*   `-104 <= secret[i], target <= 104`\n*   `secret` is sorted in a strictly increasing order.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[-1,0,3,5,9,12],9",
                "output": "4"
            },
            {
                "input": "[-1,0,3,5,9,12],2",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int search(ArrayReader reader, int target) {\n    int left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        int val = reader.get(mid);\n        if (val == target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}\n```\n    \n    We are using a binary search like algorithm to find the index. Initially, we set `left` to 0 and `right` to 1. Then we keep doubling the value of `right` (i.e., shifting it left by 1) until the value at `right` is greater than or equal to the target. This way, we can determine the range of the target value in the array, which is `[left, right]`. \n\nNow we apply a binary search algorithm. We calculate the middle index and check the value at that index. If the value at the middle index is equal to the target, we return the middle index. If the value is greater than the target, we update `right` to `mid - 1`; if the value is smaller than the target, we update `left` to `mid + 1`. We do this until `left` becomes greater than `right`. If we cannot find the target value, we return -1.\n\nThe time complexity of this algorithm is O(log n) as we are reducing the search space by half each iteration.\n    ",
        "python": "\n    ```python\ndef search(reader, target):\n    left, right = 0, 1\n    while reader.get(right) < target:\n        left = right\n        right <<= 1\n\n    while left <= right:\n        mid = left + ((right - left) >> 1)\n        val = reader.get(mid)\n        if val == target:\n            return mid\n        if val > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n```\n    \n    We are using a binary search like algorithm to find the index. Initially, we set `left` to 0 and `right` to 1. Then we keep doubling the value of `right` (i.e., shifting it left by 1) until the value at `right` is greater than or equal to the target. This way, we can determine the range of the target value in the array, which is `[left, right]`. \n\nNow we apply a binary search algorithm. We calculate the middle index and check the value at that index. If the value at the middle index is equal to the target, we return the middle index. If the value is greater than the target, we update `right` to `mid - 1`; if the value is smaller than the target, we update `left` to `mid + 1`. We do this until `left` becomes greater than `right`. If we cannot find the target value, we return -1.\n\nThe time complexity of this algorithm is O(log n) as we are reducing the search space by half each iteration.\n    ",
        "c++": "\n    ```cpp\nint search(const ArrayReader& reader, int target) {\n    int left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        int val = reader.get(mid);\n        if (val == target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}\n```\n    \n    We are using a binary search like algorithm to find the index. Initially, we set `left` to 0 and `right` to 1. Then we keep doubling the value of `right` (i.e., shifting it left by 1) until the value at `right` is greater than or equal to the target. This way, we can determine the range of the target value in the array, which is `[left, right]`. \n\nNow we apply a binary search algorithm. We calculate the middle index and check the value at that index. If the value at the middle index is equal to the target, we return the middle index. If the value is greater than the target, we update `right` to `mid - 1`; if the value is smaller than the target, we update `left` to `mid + 1`. We do this until `left` becomes greater than `right`. If we cannot find the target value, we return -1.\n\nThe time complexity of this algorithm is O(log n) as we are reducing the search space by half each iteration.\n    ",
        "js": "\n    ```javascript\nfunction search(reader, target) {\n    let left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        let mid = left + ((right - left) >> 1);\n        let val = reader.get(mid);\n        if (val === target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}\n```\n    \n    We are using a binary search like algorithm to find the index. Initially, we set `left` to 0 and `right` to 1. Then we keep doubling the value of `right` (i.e., shifting it left by 1) until the value at `right` is greater than or equal to the target. This way, we can determine the range of the target value in the array, which is `[left, right]`. \n\nNow we apply a binary search algorithm. We calculate the middle index and check the value at that index. If the value at the middle index is equal to the target, we return the middle index. If the value is greater than the target, we update `right` to `mid - 1`; if the value is smaller than the target, we update `left` to `mid + 1`. We do this until `left` becomes greater than `right`. If we cannot find the target value, we return -1.\n\nThe time complexity of this algorithm is O(log n) as we are reducing the search space by half each iteration.\n    "
    },
    {
        "id": 137,
        "title": "Insert into a Sorted Circular Linked List",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a Circular Linked List node, which is sorted in non-descending order, write a function to insert a value `insertVal` into the list such that it remains a sorted circular list. The given node can be a reference to any single node in the list and may not necessarily be the smallest value in the circular list.\n\nIf there are multiple suitable places for insertion, you may choose any place to insert the new value. After the insertion, the circular list should remain sorted.\n\nIf the list is empty (i.e., the given node is `null`), you should create a new single circular list and return the reference to that single node. Otherwise, you should return the originally given node.",
            "examples": [
                "**Example 1:**\n\n  \n\n**Input:** head = \\[3,4,1\\], insertVal = 2\n**Output:** \\[3,4,1,2\\]\n**Explanation:** In the figure above, there is a sorted circular list of three elements. You are given a reference to the node with value 3, and we need to insert 2 into the list. The new node should be inserted between node 1 and node 3. After the insertion, the list should look like this, and we should still return node 3.\n\n \n\n",
                "**Example 2:**\n\n**Input:** head = \\[\\], insertVal = 1\n**Output:** \\[1\\]\n**Explanation:** The list is empty (given head is `null`). We create a new single circular list and return the reference to that single node.\n\n",
                "**Example 3:**\n\n**Input:** head = \\[1\\], insertVal = 0\n**Output:** \\[1,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 5 * 104]`.\n*   `-106 <= Node.val, insertVal <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,4,1],2",
                "output": "[3,4,1,2]"
            },
            {
                "input": "[],1",
                "output": "[1]"
            },
            {
                "input": "[1],0",
                "output": "[1,0]"
            }
        ],
        "java": "\n    ```java\nclass Node {\n    int val;\n    Node next;\n    Node() { val = 0; next = null; }\n    Node(int _val) { val = _val; next = null; }\n    Node(int _val, Node _next) { val = _val; next = _next; }\n}\n\npublic Node insert(Node head, int insertVal) {\n    if (head == null) {\n        Node newNode = new Node(insertVal, null);\n        newNode.next = newNode;\n        return newNode;\n    }\n\n    Node prev = head;\n    Node curr = head.next;\n    boolean inserted = false;\n\n    do {\n        if (prev.val <= insertVal && insertVal <= curr.val) {\n            prev.next = new Node(insertVal, curr);\n            inserted = true;\n        } else if (prev.val > curr.val) {\n            if (insertVal >= prev.val || insertVal <= curr.val) {\n                prev.next = new Node(insertVal, curr);\n                inserted = true;\n            }\n        }\n        prev = curr;\n        curr = curr.next;\n    } while (prev != head && !inserted);\n\n    if (!inserted) {\n        prev.next = new Node(insertVal, curr);\n    }\n\n    return head;\n}\n```\n\n    \n    1. If the given `head` is `null`, we create a new node with the value `insertVal`, make it circular by pointing its `next` to itself, and return it.\n\n2. If `head` is not `null`, we start iterating the list from head to the next node.\n\n3. If `insertVal` fits between the values of the previous and current nodes considering the sorted list, add a new node with the value `insertVal` between previous and current nodes.\n\n4. If the value of the previous node is greater than the value of the current node (it means we reached the end of the list and looped back to the start) AND `insertVal` fits in that range, add a new node with the value `insertVal` between those nodes.\n\n5. If we complete the iteration without inserting the node, insert a new node with the value `insertVal` between the last previous node and its next.\n\n6. Return the original given `head`.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef insert(head, insertVal):\n    if head is None:\n        newNode = Node(insertVal)\n        newNode.next = newNode\n        return newNode\n\n    prev, curr = head, head.next\n    inserted = False\n\n    while True:\n        if prev.val <= insertVal <= curr.val:\n            prev.next = Node(insertVal, curr)\n            inserted = True\n        elif prev.val > curr.val:\n            if insertVal >= prev.val or insertVal <= curr.val:\n                prev.next = Node(insertVal, curr)\n                inserted = True\n        prev, curr = curr, curr.next\n\n        if prev == head or inserted:\n            break\n\n    if not inserted:\n        prev.next = Node(insertVal, curr)\n\n    return head\n```\n\n    \n    1. If the given `head` is `null`, we create a new node with the value `insertVal`, make it circular by pointing its `next` to itself, and return it.\n\n2. If `head` is not `null`, we start iterating the list from head to the next node.\n\n3. If `insertVal` fits between the values of the previous and current nodes considering the sorted list, add a new node with the value `insertVal` between previous and current nodes.\n\n4. If the value of the previous node is greater than the value of the current node (it means we reached the end of the list and looped back to the start) AND `insertVal` fits in that range, add a new node with the value `insertVal` between those nodes.\n\n5. If we complete the iteration without inserting the node, insert a new node with the value `insertVal` between the last previous node and its next.\n\n6. Return the original given `head`.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node() : val(0), next(nullptr) {}\n    Node(int _val) : val(_val), next(nullptr) {}\n    Node(int _val, Node* _next) : val(_val), next(_next) {}\n};\n\nNode* insert(Node* head, int insertVal) {\n    if (head == nullptr) {\n        Node* newNode = new Node(insertVal);\n        newNode->next = newNode;\n        return newNode;\n    }\n\n    Node* prev = head;\n    Node* curr = head->next;\n    bool inserted = false;\n\n    do {\n        if (prev->val <= insertVal && insertVal <= curr->val) {\n            prev->next = new Node(insertVal, curr);\n            inserted = true;\n        } else if (prev->val > curr->val) {\n            if (insertVal >= prev->val || insertVal <= curr->val) {\n                prev->next = new Node(insertVal, curr);\n                inserted = true;\n            }\n        }\n        prev = curr;\n        curr = curr->next;\n    } while (prev != head && !inserted);\n\n    if (!inserted) {\n        prev->next = new Node(insertVal, curr);\n    }\n\n    return head;\n}\n```\n\n    \n    1. If the given `head` is `null`, we create a new node with the value `insertVal`, make it circular by pointing its `next` to itself, and return it.\n\n2. If `head` is not `null`, we start iterating the list from head to the next node.\n\n3. If `insertVal` fits between the values of the previous and current nodes considering the sorted list, add a new node with the value `insertVal` between previous and current nodes.\n\n4. If the value of the previous node is greater than the value of the current node (it means we reached the end of the list and looped back to the start) AND `insertVal` fits in that range, add a new node with the value `insertVal` between those nodes.\n\n5. If we complete the iteration without inserting the node, insert a new node with the value `insertVal` between the last previous node and its next.\n\n6. Return the original given `head`.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction insert(head, insertVal) {\n    if (head === null) {\n        const newNode = new Node(insertVal);\n        newNode.next = newNode;\n        return newNode;\n    }\n\n    let prev = head;\n    let curr = head.next;\n    let inserted = false;\n\n    do {\n        if (prev.val <= insertVal && insertVal <= curr.val) {\n            prev.next = new Node(insertVal, curr);\n            inserted = true;\n        } else if (prev.val > curr.val) {\n            if (insertVal >= prev.val || insertVal <= curr.val) {\n                prev.next = new Node(insertVal, curr);\n                inserted = true;\n            }\n        }\n        prev = curr;\n        curr = curr.next;\n    } while (prev !== head && !inserted);\n\n    if (!inserted) {\n        prev.next = new Node(insertVal, curr);\n    }\n\n    return head;\n}\n```\n\n    \n    1. If the given `head` is `null`, we create a new node with the value `insertVal`, make it circular by pointing its `next` to itself, and return it.\n\n2. If `head` is not `null`, we start iterating the list from head to the next node.\n\n3. If `insertVal` fits between the values of the previous and current nodes considering the sorted list, add a new node with the value `insertVal` between previous and current nodes.\n\n4. If the value of the previous node is greater than the value of the current node (it means we reached the end of the list and looped back to the start) AND `insertVal` fits in that range, add a new node with the value `insertVal` between those nodes.\n\n5. If we complete the iteration without inserting the node, insert a new node with the value `insertVal` between the last previous node and its next.\n\n6. Return the original given `head`.\n    "
    },
    {
        "id": 138,
        "title": "Number of Distinct Islands II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nAn island is considered to be the same as another if they have the same shape, or have the same shape after **rotation** (90, 180, or 270 degrees only) or **reflection** (left/right direction or up/down direction).\n\nReturn _the number of **distinct** islands_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,0,0,0\\],\\[1,0,0,0,0\\],\\[0,0,0,0,1\\],\\[0,0,0,1,1\\]\\]\n**Output:** 1\n**Explanation:** The two islands are considered the same because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,0,0,0\\],\\[1,1,0,0,0\\],\\[0,0,0,1,1\\],\\[0,0,0,1,1\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]]",
                "output": "1"
            },
            {
                "input": "[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    private void dfs(int r, int c, int r0, int c0, int[][] grid, ArrayList<int[]> island){\n        if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1) {\n            grid[r][c] = 0;\n            island.add(new int[]{r - r0, c - c0});\n            dfs(r + 1, c, r0, c0, grid, island);\n            dfs(r - 1, c, r0, c0, grid, island);\n            dfs(r, c + 1, r0, c0, grid, island);\n            dfs(r, c - 1, r0, c0, grid, island);\n        }\n    }\n    \n    private String normalize(ArrayList<int[]> island) {\n        ArrayList<String> ret = new ArrayList<>();\n        for (int[] p : island) {\n            int x = p[0];\n            int y = p[1];\n            ret.add(x + \",\" + y);\n            ret.add(x + \",\" + -y);\n            ret.add(-x + \",\" + y);\n            ret.add(-x + \",\" + -y);\n            ret.add(y + \",\" + x);\n            ret.add(y + \",\" + -x);\n            ret.add(-y + \",\" + x);\n            ret.add(-y + \",\" + -x);\n        }\n        ret.sort(String::compareTo);\n        return String.join(\" \", ret);\n    }\n    \n    public int numDistinctIslands(int[][] grid) {\n        Set<String> distinctIslands = new HashSet<>();\n        for (int r = 0; r < grid.length; ++r) {\n            for (int c = 0; c < grid[r].length; ++c) {\n                if (grid[r][c] == 1) {\n                    ArrayList<int[]> island = new ArrayList<>();\n                    dfs(r, c, r, c, grid, island);\n                    distinctIslands.add(normalize(island));\n                }\n            }\n        }\n        return distinctIslands.size();\n    }\n}\n```\n\n    \n    The algorithm uses DFS to traverse each island in the grid. For each island, it calculates its normalized form by considering all possible rotations and reflections. This normalized form is the \"key\" for this island. Then, the algorithm uses a set to count the number of distinct islands.\n\n1. For each cell in the grid, if it's 1, run DFS and find the positions of the island.\n2. Normalize the positions by comparing them to all possible rotations and reflections, and choosing the lexicographically SMALLEST of these forms. By this way, all the forms considered the same will have the same \"key\". This \"key\" is a sorted list of the positions.\n3. Add the normalized positions to the set. Since sets only store unique items, we can count the number of distinct islands by counting the size of the set after iterating through the whole grid.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def numDistinctIslands(self, grid: List[List[int]]) -> int:\n        def dfs(r, c, r0, c0):\n            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]:\n                grid[r][c] = 0\n                island.append((r - r0, c - c0))\n                dfs(r + 1, c, r0, c0)\n                dfs(r - 1, c, r0, c0)\n                dfs(r, c + 1, r0, c0)\n                dfs(r, c - 1, r0, c0)\n\n        def normalize(island):\n            ret = []\n            for p in island:\n                x, y = p\n                ret += [(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)]\n            ret.sort()\n            return tuple(ret)\n\n        distinctIslands = set()\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c]:\n                    island = []\n                    dfs(r, c, r, c)\n                    distinctIslands.add(normalize(island))\n        return len(distinctIslands)\n```\n\n    \n    The algorithm uses DFS to traverse each island in the grid. For each island, it calculates its normalized form by considering all possible rotations and reflections. This normalized form is the \"key\" for this island. Then, the algorithm uses a set to count the number of distinct islands.\n\n1. For each cell in the grid, if it's 1, run DFS and find the positions of the island.\n2. Normalize the positions by comparing them to all possible rotations and reflections, and choosing the lexicographically SMALLEST of these forms. By this way, all the forms considered the same will have the same \"key\". This \"key\" is a sorted list of the positions.\n3. Add the normalized positions to the set. Since sets only store unique items, we can count the number of distinct islands by counting the size of the set after iterating through the whole grid.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_set>\n#include <vector>\n\nclass Solution {\nprivate:\n    void dfs(int r, int c, int r0, int c0, std::vector<std::vector<int>>& grid, std::vector<std::pair<int, int>>& island){\n        if (r >= 0 && c >= 0 && r < grid.size() && c < grid[r].size() && grid[r][c] == 1) {\n            grid[r][c] = 0;\n            island.push_back({r - r0, c - c0});\n            dfs(r + 1, c, r0, c0, grid, island);\n            dfs(r - 1, c, r0, c0, grid, island);\n            dfs(r, c + 1, r0, c0, grid, island);\n            dfs(r, c - 1, r0, c0, grid, island);\n        }\n    }\n    \n    std::vector<std::pair<int, int>> normalize(std::vector<std::pair<int, int>>& island) {\n        std::vector<std::vector<std::pair<int, int>>> ret(8);\n        for (const auto& p : island) {\n            int x = p.first;\n            int y = p.second;\n            ret[0].push_back({x, y});\n            ret[1].push_back({x, -y});\n            ret[2].push_back({-x, y});\n            ret[3].push_back({-x, -y});\n            ret[4].push_back({y, x});\n            ret[5].push_back({y, -x});\n            ret[6].push_back({-y, x});\n            ret[7].push_back({-y, -x});\n        }\n        for (auto& list : ret) {\n            std::sort(list.begin(), list.end());\n        }\n        std::sort(ret.begin(), ret.end());\n        return ret[0];\n    }\n    \npublic:\n    int numDistinctIslands(std::vector<std::vector<int>>& grid) {\n        std::unordered_set<std::string> distinctIslands;\n        for (int r = 0; r < grid.size(); ++r) {\n            for (int c = 0; c < grid[r].size(); ++c) {\n                if (grid[r][c] == 1) {\n                    std::vector<std::pair<int, int>> island;\n                    dfs(r, c, r, c, grid, island);\n                    distinctIslands.insert(normalize(island));\n                }\n            }\n        }\n        return distinctIslands.size();\n    }\n};\n```\n\n    \n    The algorithm uses DFS to traverse each island in the grid. For each island, it calculates its normalized form by considering all possible rotations and reflections. This normalized form is the \"key\" for this island. Then, the algorithm uses a set to count the number of distinct islands.\n\n1. For each cell in the grid, if it's 1, run DFS and find the positions of the island.\n2. Normalize the positions by comparing them to all possible rotations and reflections, and choosing the lexicographically SMALLEST of these forms. By this way, all the forms considered the same will have the same \"key\". This \"key\" is a sorted list of the positions.\n3. Add the normalized positions to the set. Since sets only store unique items, we can count the number of distinct islands by counting the size of the set after iterating through the whole grid.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    numDistinctIslands(grid) {\n        let distinctIslands = new Set();\n        \n        const dfs = (r, c, r0, c0) => {\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] === 1) {\n                grid[r][c] = 0;\n                island.push([r - r0, c - c0]);\n                dfs(r + 1, c, r0, c0);\n                dfs(r - 1, c, r0, c0);\n                dfs(r, c + 1, r0, c0);\n                dfs(r, c - 1, r0, c0);\n            }\n        };\n        \n        const normalize = (island) => {\n            let ret = [];\n            island.forEach(p => {\n                let [x, y] = p;\n                ret.push(...[[x, y], [x, -y], [-x, y], [-x, -y], [y, x], [y, -x], [-y, x], [-y, -x]]);\n            });\n            ret.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n            return JSON.stringify(ret);\n        };\n        \n        for (let r = 0; r < grid.length; ++r) {\n            for (let c = 0; c < grid[r].length; ++c) {\n                if (grid[r][c] === 1) {\n                    let island = [];\n                    dfs(r, c, r, c);\n                    distinctIslands.add(normalize(island));\n                }\n            }\n        }\n        return distinctIslands.size;\n    }\n}\n```\n\n    \n    The algorithm uses DFS to traverse each island in the grid. For each island, it calculates its normalized form by considering all possible rotations and reflections. This normalized form is the \"key\" for this island. Then, the algorithm uses a set to count the number of distinct islands.\n\n1. For each cell in the grid, if it's 1, run DFS and find the positions of the island.\n2. Normalize the positions by comparing them to all possible rotations and reflections, and choosing the lexicographically SMALLEST of these forms. By this way, all the forms considered the same will have the same \"key\". This \"key\" is a sorted list of the positions.\n3. Add the normalized positions to the set. Since sets only store unique items, we can count the number of distinct islands by counting the size of the set after iterating through the whole grid.\n    "
    },
    {
        "id": 139,
        "title": "Max Stack",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a max stack data structure that supports the stack operations and supports finding the stack's maximum element.\n\nImplement the `MaxStack` class:\n\n*   `MaxStack()` Initializes the stack object.\n*   `void push(int x)` Pushes element `x` onto the stack.\n*   `int pop()` Removes the element on top of the stack and returns it.\n*   `int top()` Gets the element on the top of the stack without removing it.\n*   `int peekMax()` Retrieves the maximum element in the stack without removing it.\n*   `int popMax()` Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the **top-most** one.\n\nYou must come up with a solution that supports `O(1)` for each `top` call and `O(logn)` for each other call.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MaxStack \",  \"push \",  \"push \",  \"push \",  \"top \",  \"popMax \",  \"top \",  \"peekMax \",  \"pop \",  \"top \"\\]\n\\[\\[\\], \\[5\\], \\[1\\], \\[5\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, null, 5, 5, 1, 5, 1, 5\\]\n\n**Explanation**\nMaxStack stk = new MaxStack();\nstk.push(5);   // \\[**5**\\] the top of the stack and the maximum number is 5.\nstk.push(1);   // \\[5, **1**\\] the top of the stack is 1, but the maximum is 5.\nstk.push(5);   // \\[5, 1, **5**\\] the top of the stack is 5, which is also the maximum, because it is the top most one.\nstk.top();     // return 5, \\[5, 1, **5**\\] the stack did not change.\nstk.popMax();  // return 5, \\[5, **1**\\] the stack is changed now, and the top is different from the max.\nstk.top();     // return 1, \\[5, **1**\\] the stack did not change.\nstk.peekMax(); // return 5, \\[5, **1**\\] the stack did not change.\nstk.pop();     // return 1, \\[**5**\\] the top of the stack and the max element is now 5.\nstk.top();     // return 5, \\[**5**\\] the stack did not change."
            ],
            "constraints": "**Constraints:**\n\n*   `-107 <= x <= 107`\n*   At most `105` calls will be made to `push`, `pop`, `top`, `peekMax`, and `popMax`.\n*   There will be **at least one element** in the stack when `pop`, `top`, `peekMax`, or `popMax` is called.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,null,5,5,1,5,1,5]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\nimport java.util.TreeSet;\n\nclass MaxStack {\n    Stack<Integer> mainStack;\n    TreeSet<Integer> maxSet;\n\n    public MaxStack() {\n        mainStack = new Stack<>();\n        maxSet = new TreeSet<>();\n    }\n\n    public void push(int x) {\n        mainStack.push(x);\n        maxSet.add(x);\n    }\n\n    public int pop() {\n        int top = mainStack.pop();\n        maxSet.remove(top);\n        return top;\n    }\n\n    public int top() {\n        return mainStack.peek();\n    }\n\n    public int peekMax() {\n        return maxSet.last();\n    }\n\n    public int popMax() {\n        int max = maxSet.last();\n        maxSet.remove(max);\n\n        Stack<Integer> tempStack = new Stack<>();\n        while (mainStack.peek() != max) {\n            tempStack.push(mainStack.pop());\n        }\n        mainStack.pop();\n        while (!tempStack.isEmpty()) {\n            mainStack.push(tempStack.pop());\n        }\n\n        return max;\n    }\n}\n```\n    \n    The algorithm uses two data structures, a main stack and a max set. The main stack is used to store the elements, and the max set is used to store the maximum elements in a sorted order. When an element is pushed onto the stack, it is added to the main stack and the max set. When the top element of the stack is removed, it is also removed from the max set. To find the maximum element, the last element of the max set is returned. To pop the maximum element, the algorithm first finds the maximum element in the list, removes it from the max set, and then removes it from the stack. If there are multiple maximum elements in the list, only the top-most one is removed. The time complexity for each `top` call is O(1) and for each `push`, `pop`, `peekMax`, and `popMax` call is O(logn).\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\nclass MaxStack:\n    def __init__(self):\n        self.mainStack = []\n        self.maxSet = SortedList()\n\n    def push(self, x: int) -> None:\n        self.mainStack.append(x)\n        self.maxSet.add(x)\n\n    def pop(self) -> int:\n        top = self.mainStack.pop()\n        self.maxSet.remove(top)\n        return top\n\n    def top(self) -> int:\n        return self.mainStack[-1]\n\n    def peekMax(self) -> int:\n        return self.maxSet[-1]\n\n    def popMax(self) -> int:\n        max_val = self.maxSet.pop()\n        tempStack = []\n        while self.mainStack[-1] != max_val:\n            tempStack.append(self.mainStack.pop())\n        self.mainStack.pop()\n        while tempStack:\n            self.mainStack.append(tempStack.pop())\n        return max_val\n```\n    \n    The algorithm uses two data structures, a main stack and a max set. The main stack is used to store the elements, and the max set is used to store the maximum elements in a sorted order. When an element is pushed onto the stack, it is added to the main stack and the max set. When the top element of the stack is removed, it is also removed from the max set. To find the maximum element, the last element of the max set is returned. To pop the maximum element, the algorithm first finds the maximum element in the list, removes it from the max set, and then removes it from the stack. If there are multiple maximum elements in the list, only the top-most one is removed. The time complexity for each `top` call is O(1) and for each `push`, `pop`, `peekMax`, and `popMax` call is O(logn).\n    ",
        "c++": "\n    ```cpp\n#include <set>\n#include <stack>\n\nclass MaxStack {\n    std::stack<int> mainStack;\n    std::multiset<int> maxSet;\n\npublic:\n    MaxStack() {}\n    \n    void push(int x) {\n        mainStack.push(x);\n        maxSet.insert(x);\n    }\n    \n    int pop() {\n        int top = mainStack.top();\n        mainStack.pop();\n        maxSet.erase(maxSet.find(top));\n        return top;\n    }\n    \n    int top() {\n        return mainStack.top();\n    }\n    \n    int peekMax() {\n        return *maxSet.rbegin();\n    }\n    \n    int popMax() {\n        int max = *maxSet.rbegin();\n        maxSet.erase(maxSet.find(max));\n        \n        std::stack<int> tempStack;\n        while (mainStack.top() != max) {\n            tempStack.push(mainStack.top());\n            mainStack.pop();\n        }\n        mainStack.pop();\n        while (!tempStack.empty()) {\n            mainStack.push(tempStack.top());\n            tempStack.pop();\n        }\n        \n        return max;\n    }\n};\n```\n    \n    The algorithm uses two data structures, a main stack and a max set. The main stack is used to store the elements, and the max set is used to store the maximum elements in a sorted order. When an element is pushed onto the stack, it is added to the main stack and the max set. When the top element of the stack is removed, it is also removed from the max set. To find the maximum element, the last element of the max set is returned. To pop the maximum element, the algorithm first finds the maximum element in the list, removes it from the max set, and then removes it from the stack. If there are multiple maximum elements in the list, only the top-most one is removed. The time complexity for each `top` call is O(1) and for each `push`, `pop`, `peekMax`, and `popMax` call is O(logn).\n    ",
        "js": "\n    ```javascript\nclass MaxStack {\n    constructor() {\n        this.mainStack = [];\n        this.maxSet = new Set();\n    }\n\n    push(x) {\n        this.mainStack.push(x);\n        this.maxSet.add(x);\n    }\n\n    pop() {\n        const top = this.mainStack.pop();\n        this.maxSet.delete(top);\n        return top;\n    }\n\n    top() {\n        return this.mainStack[this.mainStack.length - 1];\n    }\n\n    peekMax() {\n        return Math.max(...this.maxSet);\n    }\n\n    popMax() {\n        const max = Math.max(...this.maxSet);\n        this.maxSet.delete(max);\n\n        const tempStack = [];\n        while (this.mainStack[this.mainStack.length - 1] !== max) {\n            tempStack.push(this.mainStack.pop());\n        }\n        this.mainStack.pop();\n        while (tempStack.length) {\n            this.mainStack.push(tempStack.pop());\n        }\n\n        return max;\n    }\n}\n```\n    \n    The algorithm uses two data structures, a main stack and a max set. The main stack is used to store the elements, and the max set is used to store the maximum elements in a sorted order. When an element is pushed onto the stack, it is added to the main stack and the max set. When the top element of the stack is removed, it is also removed from the max set. To find the maximum element, the last element of the max set is returned. To pop the maximum element, the algorithm first finds the maximum element in the list, removes it from the max set, and then removes it from the stack. If there are multiple maximum elements in the list, only the top-most one is removed. The time complexity for each `top` call is O(1) and for each `push`, `pop`, `peekMax`, and `popMax` call is O(logn).\n    "
    },
    {
        "id": 140,
        "title": "Candy Crush",
        "difficulty": "Medium",
        "content": {
            "problem": "This question is about implementing a basic elimination algorithm for Candy Crush.\n\nGiven an `m x n` integer array `board` representing the grid of candy where `board[i][j]` represents the type of candy. A value of `board[i][j] == 0` represents that the cell is empty.\n\nThe given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:\n\n*   If three or more candies of the same type are adjacent vertically or horizontally, crush them all at the same time - these positions become empty.\n*   After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. No new candies will drop outside the top boundary.\n*   After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.\n*   If there does not exist more candies that can be crushed (i.e., the board is stable), then return the current board.\n\nYou need to perform the above rules until the board becomes stable, then return _the stable board_.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[110,5,112,113,114\\],\\[210,211,5,213,214\\],\\[310,311,3,313,314\\],\\[410,411,412,5,414\\],\\[5,1,512,3,3\\],\\[610,4,1,613,614\\],\\[710,1,2,713,714\\],\\[810,1,2,1,1\\],\\[1,1,2,2,2\\],\\[4,1,4,4,1014\\]\\]\n**Output:** \\[\\[0,0,0,0,0\\],\\[0,0,0,0,0\\],\\[0,0,0,0,0\\],\\[110,0,0,0,114\\],\\[210,0,0,0,214\\],\\[310,0,0,113,314\\],\\[410,0,0,213,414\\],\\[610,211,112,313,614\\],\\[710,311,412,613,714\\],\\[810,411,512,713,1014\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[1,3,5,5,2\\],\\[3,4,3,3,1\\],\\[3,2,4,5,2\\],\\[2,4,4,5,5\\],\\[1,4,4,1,1\\]\\]\n**Output:** \\[\\[1,3,0,0,0\\],\\[3,4,0,5,2\\],\\[3,2,0,3,1\\],\\[2,4,0,5,2\\],\\[1,4,3,1,1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `3 <= m, n <= 50`\n*   `1 <= board[i][j] <= 2000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]",
                "output": "[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]"
            },
            {
                "input": "[[1,3,5,5,2],[3,4,3,3,1],[3,2,4,5,2],[2,4,4,5,5],[1,4,4,1,1]]",
                "output": "[[1,3,0,0,0],[3,4,0,5,2],[3,2,0,3,1],[2,4,0,5,2],[1,4,3,1,1]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] candyCrush(int[][] board) {\n    int rows = board.length, cols = board[0].length;\n    boolean toDo = false;\n    \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols - 2; c++) {\n            int val = Math.abs(board[r][c]);\n            if (val != 0 && val == Math.abs(board[r][c + 1]) && val == Math.abs(board[r][c + 2])) {\n                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val;\n                toDo = true;\n            }\n        }\n    }\n    \n    for (int r = 0; r < rows - 2; r++) {\n        for (int c = 0; c < cols; c++) {\n            int val = Math.abs(board[r][c]);\n            if (val != 0 && val == Math.abs(board[r + 1][c]) && val == Math.abs(board[r + 2][c])) {\n                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val;\n                toDo = true;\n            }\n        }\n    }\n    \n    for (int c = 0; c < cols; c++) {\n        int wr = rows - 1;\n        for (int r = rows - 1; r >= 0; r--)\n            if (board[r][c] > 0)\n                board[wr--][c] = board[r][c];\n        while (wr >= 0)\n            board[wr--][c] = 0;\n    }\n    \n    return toDo ? candyCrush(board) : board;\n}\n```\n    \n    The algorithm iterates over `board`, checking for matching candies both horizontally and vertically. If matching candies are found, their signs are inverted to mark them as crushed. After marking all matching candies, the empty cells are filled by dropping candies from above in the same column. Finally, the function is called recursively until no more matching candies are found.\n    ",
        "python": "\n    ```python\ndef candyCrush(board):\n    rows = len(board)\n    cols = len(board[0])\n    toDo = False\n    \n    for r in range(rows):\n        for c in range(cols - 2):\n            val = abs(board[r][c])\n            if val and val == abs(board[r][c + 1]) and val == abs(board[r][c + 2]):\n                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val\n                toDo = True\n                \n    for r in range(rows - 2):\n        for c in range(cols):\n            val = abs(board[r][c])\n            if val and val == abs(board[r + 1][c]) and val == abs(board[r + 2][c]):\n                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val\n                toDo = True\n                \n    for c in range(cols):\n        wr = rows - 1\n        for r in range(rows - 1, -1, -1):\n            if board[r][c] > 0:\n                board[wr][c] = board[r][c]\n                wr -= 1\n                \n        for r in range(wr, -1, -1):\n            board[r][c] = 0\n                \n    return candyCrush(board) if toDo else board\n```\n    \n    The algorithm iterates over `board`, checking for matching candies both horizontally and vertically. If matching candies are found, their signs are inverted to mark them as crushed. After marking all matching candies, the empty cells are filled by dropping candies from above in the same column. Finally, the function is called recursively until no more matching candies are found.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\nvector<vector<int>> candyCrush(vector<vector<int>>& board) {\n    int rows = board.size(), cols = board[0].size();\n    bool toDo = false;\n    \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols - 2; c++) {\n            int val = abs(board[r][c]);\n            if (val && val == abs(board[r][c + 1]) && val == abs(board[r][c + 2])) {\n                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val;\n                toDo = true;\n            }\n        }\n    }\n    \n    for (int r = 0; r < rows - 2; r++) {\n        for (int c = 0; c < cols; c++) {\n            int val = abs(board[r][c]);\n            if (val && val == abs(board[r + 1][c]) && val == abs(board[r + 2][c])) {\n                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val;\n                toDo = true;\n            }\n        }\n    }\n    \n    for (int c = 0; c < cols; c++) {\n        int wr = rows - 1;\n        for (int r = rows - 1; r >= 0; r--)\n            if (board[r][c] > 0)\n                board[wr--][c] = board[r][c];\n        while (wr >= 0)\n            board[wr--][c] = 0;\n    }\n    \n    return toDo ? candyCrush(board) : board;\n}\n```\n    \n    The algorithm iterates over `board`, checking for matching candies both horizontally and vertically. If matching candies are found, their signs are inverted to mark them as crushed. After marking all matching candies, the empty cells are filled by dropping candies from above in the same column. Finally, the function is called recursively until no more matching candies are found.\n    ",
        "js": "\n    ```javascript\nfunction candyCrush(board) {\n    let rows = board.length;\n    let cols = board[0].length;\n    let toDo = false;\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols - 2; c++) {\n            let val = Math.abs(board[r][c]);\n            if (val && val === Math.abs(board[r][c + 1]) && val === Math.abs(board[r][c + 2])) {\n                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val;\n                toDo = true;\n            }\n        }\n    }\n    for (let r = 0; r < rows - 2; r++) {\n        for (let c = 0; c < cols; c++) {\n            let val = Math.abs(board[r][c]);\n            if (val && val === Math.abs(board[r + 1][c]) && val === Math.abs(board[r + 2][c])) {\n                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val;\n                toDo = true;\n            }\n        }\n    }\n\n    for (let c = 0; c < cols; c++) {\n        let wr = rows - 1;\n        for (let r = rows - 1; r >= 0; r--) {\n            if (board[r][c] > 0) {\n                board[wr][c] = board[r][c];\n                wr--;\n            }\n        }\n        for (let r = wr; r >= 0; r--) {\n            board[r][c] = 0;\n        }\n    }\n\n    return toDo ? candyCrush(board) : board;\n}\n```\n\n    \n    The algorithm iterates over `board`, checking for matching candies both horizontally and vertically. If matching candies are found, their signs are inverted to mark them as crushed. After marking all matching candies, the empty cells are filled by dropping candies from above in the same column. Finally, the function is called recursively until no more matching candies are found.\n    "
    },
    {
        "id": 141,
        "title": "Minimum Window Subsequence",
        "difficulty": "Hard",
        "content": {
            "problem": "Given strings `s1` and `s2`, return _the minimum contiguous substring part of_ `s1`_, so that_ `s2` _is a subsequence of the part_.\n\nIf there is no such window in `s1` that covers all characters in `s2`, return the empty string `\" \"`. If there are multiple such minimum-length windows, return the one with the **left-most starting index**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"abcdebdde \", s2 =  \"bde \"\n**Output:**  \"bcde \"\n**Explanation:** \n \"bcde \" is the answer because it occurs before  \"bdde \" which has the same length.\n \"deb \" is not a smaller window because the elements of s2 in the window must occur in order.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl \", s2 =  \"u \"\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length <= 2 * 104`\n*   `1 <= s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcdebdde\",\"bde\"",
                "output": "\"bcde\""
            },
            {
                "input": "\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\",\"u\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String minWindowSubSequence(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[n + 1][m + 1];\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1.charAt(j - 1) == s2.charAt(i - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substring(start, start + length);\n}\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "python": "\n    ```python\ndef min_window_sub_sequence(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for j in range(0, m + 1):\n        dp[0][j] = j\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[j - 1] == s2[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    start, length = 0, m + 1\n    for j in range(1, m + 1):\n        if dp[n][j] != 0 and j - dp[n][j] < length:\n            start = dp[n][j]\n            length = j - start\n\n    return \"\" if length == m + 1 else s1[start:start + length]\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string min_window_sub_sequence(std::string s1, std::string s2) {\n    int m = s1.length(), n = s2.length();\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, -1));\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1[j - 1] == s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != -1 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substr(start, length);\n}\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "js": "\n    ```javascript\nfunction minWindowSubSequence(s1, s2) {\n    const m = s1.length, n = s2.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));\n\n    for (let j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= m; ++j) {\n            if (s1[j - 1] === s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    let start = 0, length = m + 1;\n    for (let j = 1; j <= m; ++j) {\n        if (dp[n][j] !== 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length === m + 1 ? \"\" : s1.slice(start, start + length);\n}\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    "
    },
    {
        "id": 142,
        "title": "Sentence Similarity",
        "difficulty": "Easy",
        "content": {
            "problem": "We can represent a sentence as an array of words, for example, the sentence `\"I am happy with leetcode \"` can be represented as `arr = [ \"I \", \"am \",happy \", \"with \", \"leetcode \"]`.\n\nGiven two sentences `sentence1` and `sentence2` each represented as a string array and given an array of string pairs `similarPairs` where `similarPairs[i] = [xi, yi]` indicates that the two words `xi` and `yi` are similar.\n\nReturn _`true` if `sentence1` and `sentence2` are similar, or `false` if they are not similar_.\n\nTwo sentences are similar if:\n\n*   They have **the same length** (i.e., the same number of words)\n*   `sentence1[i]` and `sentence2[i]` are similar.\n\nNotice that a word is always similar to itself, also notice that the similarity relation is not transitive. For example, if the words `a` and `b` are similar, and the words `b` and `c` are similar, `a` and `c` are **not necessarily similar**.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence1 = \\[ \"great \", \"acting \", \"skills \"\\], sentence2 = \\[ \"fine \", \"drama \", \"talent \"\\], similarPairs = \\[\\[ \"great \", \"fine \"\\],\\[ \"drama \", \"acting \"\\],\\[ \"skills \", \"talent \"\\]\\]\n**Output:** true\n**Explanation:** The two sentences have the same length and each word i of sentence1 is also similar to the corresponding word in sentence2.\n\n",
                "**Example 2:**\n\n**Input:** sentence1 = \\[ \"great \"\\], sentence2 = \\[ \"great \"\\], similarPairs = \\[\\]\n**Output:** true\n**Explanation:** A word is similar to itself.\n\n",
                "**Example 3:**\n\n**Input:** sentence1 = \\[ \"great \"\\], sentence2 = \\[ \"doubleplus \", \"good \"\\], similarPairs = \\[\\[ \"great \", \"doubleplus \"\\]\\]\n**Output:** false\n**Explanation:** As they don't have the same length, we return false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence1.length, sentence2.length <= 1000`\n*   `1 <= sentence1[i].length, sentence2[i].length <= 20`\n*   `sentence1[i]` and `sentence2[i]` consist of English letters.\n*   `0 <= similarPairs.length <= 1000`\n*   `similarPairs[i].length == 2`\n*   `1 <= xi.length, yi.length <= 20`\n*   `xi` and `yi` consist of lower-case and upper-case English letters.\n*   All the pairs `(xi, yi)` are **distinct**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"great\",\"acting\",\"skills\"],[\"fine\",\"drama\",\"talent\"],[[\"great\",\"fine\"],[\"drama\",\"acting\"],[\"skills\",\"talent\"]]",
                "output": "true"
            },
            {
                "input": "[\"great\"],[\"great\"],[]",
                "output": "true"
            },
            {
                "input": "[\"great\"],[\"doubleplus\",\"good\"],[[\"great\",\"doubleplus\"]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) {\n    if (sentence1.length != sentence2.length) return false;\n    Map<String, Set<String>> similarityMap = new HashMap<>();\n    for (List<String> pair : similarPairs) {\n        similarityMap.putIfAbsent(pair.get(0), new HashSet<>());\n        similarityMap.putIfAbsent(pair.get(1), new HashSet<>());\n        similarityMap.get(pair.get(0)).add(pair.get(1));\n        similarityMap.get(pair.get(1)).add(pair.get(0));\n    }\n    for (int i = 0; i < sentence1.length; ++i) {\n        if (!sentence1[i].equals(sentence2[i]) && !similarityMap.getOrDefault(sentence1[i], Collections.emptySet()).contains(sentence2[i]))\n            return false;\n    }\n    return true;\n}\n```\n\n    \n    1. If the lengths of the given sentences are unequal, the sentences cannot be similar, hence return false.\n2. Create a mapping from each word in similarPairs to its set of similar words.\n3. Iterate over each word in both sentences and check whether they are similar. If not, return false.\n4. If all words in sentence1 are similar to words at same indices in sentence2, return true.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef areSentencesSimilar(sentence1, sentence2, similarPairs):\n    if len(sentence1) != len(sentence2): return False\n    similarityMap = defaultdict(set)\n    for pair in similarPairs:\n        similarityMap[pair[0]].add(pair[1])\n        similarityMap[pair[1]].add(pair[0])\n    for i in range(len(sentence1)):\n        if sentence1[i] != sentence2[i] and sentence2[i] not in similarityMap[sentence1[i]]:\n            return False\n    return True\n```\n\n    \n    1. If the lengths of the given sentences are unequal, the sentences cannot be similar, hence return false.\n2. Create a mapping from each word in similarPairs to its set of similar words.\n3. Iterate over each word in both sentences and check whether they are similar. If not, return false.\n4. If all words in sentence1 are similar to words at same indices in sentence2, return true.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nbool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {\n    if (sentence1.size() != sentence2.size()) return false;\n    unordered_map<string, unordered_set<string>> similarityMap;\n    for (const auto& pair : similarPairs) {\n        similarityMap[pair[0]].insert(pair[1]);\n        similarityMap[pair[1]].insert(pair[0]);\n    }\n    for (int i = 0; i < sentence1.size(); ++i) {\n        if (sentence1[i] != sentence2[i] && !similarityMap[sentence1[i]].count(sentence2[i]))\n            return false;\n    }\n    return true;\n}\n```\n\n    \n    1. If the lengths of the given sentences are unequal, the sentences cannot be similar, hence return false.\n2. Create a mapping from each word in similarPairs to its set of similar words.\n3. Iterate over each word in both sentences and check whether they are similar. If not, return false.\n4. If all words in sentence1 are similar to words at same indices in sentence2, return true.\n    ",
        "js": "\n    ```javascript\nfunction areSentencesSimilar(sentence1, sentence2, similarPairs) {\n    if (sentence1.length !== sentence2.length) return false;\n    const similarityMap = new Map();\n    for (const pair of similarPairs) {\n        if (!similarityMap.has(pair[0])) similarityMap.set(pair[0], new Set());\n        if (!similarityMap.has(pair[1])) similarityMap.set(pair[1], new Set());\n        similarityMap.get(pair[0]).add(pair[1]);\n        similarityMap.get(pair[1]).add(pair[0]);\n    }\n    for (let i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i] !== sentence2[i] && !similarityMap.get(sentence1[i])?.has(sentence2[i]))\n            return false;\n    }\n    return true;\n}\n```\n\n    \n    1. If the lengths of the given sentences are unequal, the sentences cannot be similar, hence return false.\n2. Create a mapping from each word in similarPairs to its set of similar words.\n3. Iterate over each word in both sentences and check whether they are similar. If not, return false.\n4. If all words in sentence1 are similar to words at same indices in sentence2, return true.\n    "
    },
    {
        "id": 143,
        "title": "Sentence Similarity II",
        "difficulty": "Medium",
        "content": {
            "problem": "We can represent a sentence as an array of words, for example, the sentence `\"I am happy with leetcode \"` can be represented as `arr = [ \"I \", \"am \",happy \", \"with \", \"leetcode \"]`.\n\nGiven two sentences `sentence1` and `sentence2` each represented as a string array and given an array of string pairs `similarPairs` where `similarPairs[i] = [xi, yi]` indicates that the two words `xi` and `yi` are similar.\n\nReturn `true` _if `sentence1` and `sentence2` are similar, or_ `false` _if they are not similar_.\n\nTwo sentences are similar if:\n\n*   They have **the same length** (i.e., the same number of words)\n*   `sentence1[i]` and `sentence2[i]` are similar.\n\nNotice that a word is always similar to itself, also notice that the similarity relation is transitive. For example, if the words `a` and `b` are similar, and the words `b` and `c` are similar, then `a` and `c` are **similar**.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence1 = \\[ \"great \", \"acting \", \"skills \"\\], sentence2 = \\[ \"fine \", \"drama \", \"talent \"\\], similarPairs = \\[\\[ \"great \", \"good \"\\],\\[ \"fine \", \"good \"\\],\\[ \"drama \", \"acting \"\\],\\[ \"skills \", \"talent \"\\]\\]\n**Output:** true\n**Explanation:** The two sentences have the same length and each word i of sentence1 is also similar to the corresponding word in sentence2.\n\n",
                "**Example 2:**\n\n**Input:** sentence1 = \\[ \"I \", \"love \", \"leetcode \"\\], sentence2 = \\[ \"I \", \"love \", \"onepiece \"\\], similarPairs = \\[\\[ \"manga \", \"onepiece \"\\],\\[ \"platform \", \"anime \"\\],\\[ \"leetcode \", \"platform \"\\],\\[ \"anime \", \"manga \"\\]\\]\n**Output:** true\n**Explanation:**  \"leetcode \" -->  \"platform \" -->  \"anime \" -->  \"manga \" -->  \"onepiece \".\nSince  \"leetcode is similar to  \"onepiece \" and the first two words are the same, the two sentences are similar.\n\n",
                "**Example 3:**\n\n**Input:** sentence1 = \\[ \"I \", \"love \", \"leetcode \"\\], sentence2 = \\[ \"I \", \"love \", \"onepiece \"\\], similarPairs = \\[\\[ \"manga \", \"hunterXhunter \"\\],\\[ \"platform \", \"anime \"\\],\\[ \"leetcode \", \"platform \"\\],\\[ \"anime \", \"manga \"\\]\\]\n**Output:** false\n**Explanation:**  \"leetcode \" is not similar to  \"onepiece \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence1.length, sentence2.length <= 1000`\n*   `1 <= sentence1[i].length, sentence2[i].length <= 20`\n*   `sentence1[i]` and `sentence2[i]` consist of lower-case and upper-case English letters.\n*   `0 <= similarPairs.length <= 2000`\n*   `similarPairs[i].length == 2`\n*   `1 <= xi.length, yi.length <= 20`\n*   `xi` and `yi` consist of English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"great\",\"acting\",\"skills\"],[\"fine\",\"drama\",\"talent\"],[[\"great\",\"good\"],[\"fine\",\"good\"],[\"drama\",\"acting\"],[\"skills\",\"talent\"]]",
                "output": "true"
            },
            {
                "input": "[\"I\",\"love\",\"leetcode\"],[\"I\",\"love\",\"onepiece\"],[[\"manga\",\"onepiece\"],[\"platform\",\"anime\"],[\"leetcode\",\"platform\"],[\"anime\",\"manga\"]]",
                "output": "true"
            },
            {
                "input": "[\"I\",\"love\",\"leetcode\"],[\"I\",\"love\",\"onepiece\"],[[\"manga\",\"hunterXhunter\"],[\"platform\",\"anime\"],[\"leetcode\",\"platform\"],[\"anime\",\"manga\"]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> pairs) {\n    if (sentence1.length != sentence2.length) return false;\n    \n    Map<String, Set<String>> graph = new HashMap<>();\n    for (List<String> p : pairs) {\n        graph.putIfAbsent(p.get(0), new HashSet<>());\n        graph.putIfAbsent(p.get(1), new HashSet<>());\n        graph.get(p.get(0)).add(p.get(1));\n        graph.get(p.get(1)).add(p.get(0));\n    }\n    \n    for (int i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i].equals(sentence2[i])) continue;\n        if (!graph.getOrDefault(sentence1[i], new HashSet<>()).contains(sentence2[i])) return false;\n    }\n    return true;\n}\n```\n    \n    We start by checking if sentence1 and sentence2 have the same length, otherwise, they cannot be similar. Then, create a graph using an adjacency list to represent the similarity pairs. Iterate through sentence1 and sentence2 in parallel, compare each pair of words exactly in the same position in both sentences. If a pair of words is equal, they are already similar, so we continue with the next pair. If not, we look for the word from sentence2 in the adjacency list for the word from sentence1. If we find it, they are similar; if not, the sentences are not similar. If all pairs are marked as similar, we return `True`, otherwise `False`.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef areSentencesSimilar(sentence1, sentence2, pairs):\n    if len(sentence1) != len(sentence2):\n        return False\n    \n    graph = defaultdict(set)\n    for a, b in pairs:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    for a, b in zip(sentence1, sentence2):\n        if a == b:\n            continue\n        if b not in graph[a]:\n            return False\n\n    return True\n```\n    \n    We start by checking if sentence1 and sentence2 have the same length, otherwise, they cannot be similar. Then, create a graph using an adjacency list to represent the similarity pairs. Iterate through sentence1 and sentence2 in parallel, compare each pair of words exactly in the same position in both sentences. If a pair of words is equal, they are already similar, so we continue with the next pair. If not, we look for the word from sentence2 in the adjacency list for the word from sentence1. If we find it, they are similar; if not, the sentences are not similar. If all pairs are marked as similar, we return `True`, otherwise `False`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <string>\n\nbool areSentencesSimilar(std::vector<std::string>& sentence1, std::vector<std::string>& sentence2, std::vector<std::vector<std::string>>& pairs) {\n    if (sentence1.size() != sentence2.size()) return false;\n\n    std::unordered_map<std::string, std::unordered_set<std::string>> graph;\n    for (const auto& p : pairs) {\n        graph[p[0]].insert(p[1]);\n        graph[p[1]].insert(p[0]);\n    }\n    \n    for (int i = 0; i < sentence1.size(); ++i) {\n        if (sentence1[i] == sentence2[i]) continue;\n        if (graph[sentence1[i]].find(sentence2[i]) == graph[sentence1[i]].end()) return false;\n    }\n    return true;\n}\n```\n    \n    We start by checking if sentence1 and sentence2 have the same length, otherwise, they cannot be similar. Then, create a graph using an adjacency list to represent the similarity pairs. Iterate through sentence1 and sentence2 in parallel, compare each pair of words exactly in the same position in both sentences. If a pair of words is equal, they are already similar, so we continue with the next pair. If not, we look for the word from sentence2 in the adjacency list for the word from sentence1. If we find it, they are similar; if not, the sentences are not similar. If all pairs are marked as similar, we return `True`, otherwise `False`.\n    ",
        "js": "\n    ```javascript\nfunction areSentencesSimilar(sentence1, sentence2, pairs) {\n    if (sentence1.length !== sentence2.length) return false;\n    \n    const graph = new Map();\n    for (const [a, b] of pairs) {\n        if (!graph.has(a)) graph.set(a, new Set());\n        if (!graph.has(b)) graph.set(b, new Set());\n        \n        graph.get(a).add(b);\n        graph.get(b).add(a);\n    }\n    \n    for (let i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i] === sentence2[i]) continue;\n\n        const neighbors = graph.get(sentence1[i]);\n        if (!neighbors || !neighbors.has(sentence2[i])) return false;\n    }\n    \n    return true;\n}\n```\n    \n    We start by checking if sentence1 and sentence2 have the same length, otherwise, they cannot be similar. Then, create a graph using an adjacency list to represent the similarity pairs. Iterate through sentence1 and sentence2 in parallel, compare each pair of words exactly in the same position in both sentences. If a pair of words is equal, they are already similar, so we continue with the next pair. If not, we look for the word from sentence2 in the adjacency list for the word from sentence1. If we find it, they are similar; if not, the sentences are not similar. If all pairs are marked as similar, we return `True`, otherwise `False`.\n    "
    },
    {
        "id": 144,
        "title": "Closest Leaf in a Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree where every node has **a unique value** and a target integer `k`, return _the value of the **nearest leaf node** to the target_ `k` _in the tree_.\n\n**Nearest to a leaf** means the least number of edges traveled on the binary tree to reach any leaf of the tree. Also, a node is called a leaf if it has no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,3,2\\], k = 1\n**Output:** 2\n**Explanation:** Either 2 or 3 is the nearest leaf node to the target of 1.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\], k = 1\n**Output:** 1\n**Explanation:** The nearest leaf node is the root node itself.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,2,3,4,null,null,null,5,null,6\\], k = 2\n**Output:** 3\n**Explanation:** The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `1 <= Node.val <= 1000`\n*   All the values of the tree are **unique**.\n*   There exist some node in the tree where `Node.val == k`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,3,2],1",
                "output": "2"
            },
            {
                "input": "[1],1",
                "output": "1"
            },
            {
                "input": "[1,2,3,4,null,null,null,5,null,6],2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic String toLowerCase(String s) {\n    return s.toLowerCase();\n}\n```\n    \n    The implemented algorithm converts each letter of the given string to its lowercase version. For C++, the transform function is used to apply the `tolower` function to each character to convert it to lowercase. In Java, Python, and JavaScript, the built-in `toLowerCase`, `lower`, and `toLowerCase` functions, respectively, are used to transform the input string into its lowercase variant.\n    ",
        "python": "\n    ```python\ndef to_lower_case(s: str) -> str:\n    return s.lower()\n```\n    \n    The implemented algorithm converts each letter of the given string to its lowercase version. For C++, the transform function is used to apply the `tolower` function to each character to convert it to lowercase. In Java, Python, and JavaScript, the built-in `toLowerCase`, `lower`, and `toLowerCase` functions, respectively, are used to transform the input string into its lowercase variant.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <cctype>\n\nstd::string toLowerCase(std::string s) {\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    return s;\n}\n```\n    \n    The implemented algorithm converts each letter of the given string to its lowercase version. For C++, the transform function is used to apply the `tolower` function to each character to convert it to lowercase. In Java, Python, and JavaScript, the built-in `toLowerCase`, `lower`, and `toLowerCase` functions, respectively, are used to transform the input string into its lowercase variant.\n    ",
        "js": "\n    ```javascript\nfunction toLowerCase(s) {\n    return s.toLowerCase();\n}\n```\n    \n    The implemented algorithm converts each letter of the given string to its lowercase version. For C++, the transform function is used to apply the `tolower` function to each character to convert it to lowercase. In Java, Python, and JavaScript, the built-in `toLowerCase`, `lower`, and `toLowerCase` functions, respectively, are used to transform the input string into its lowercase variant.\n    "
    },
    {
        "id": 145,
        "title": "Number Of Corner Rectangles",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` integer matrix `grid` where each entry is only `0` or `1`, return _the number of **corner rectangles**_.\n\nA **corner rectangle** is four distinct `1`'s on the grid that forms an axis-aligned rectangle. Note that only the corners need to have the value `1`. Also, all four `1`'s used must be distinct.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,1,0\\],\\[0,0,1,0,1\\],\\[0,0,0,1,0\\],\\[1,0,1,0,1\\]\\]\n**Output:** 1\n**Explanation:** There is only one corner rectangle, with corners grid\\[1\\]\\[2\\], grid\\[1\\]\\[4\\], grid\\[3\\]\\[2\\], grid\\[3\\]\\[4\\].\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 9\n**Explanation:** There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1\\]\\]\n**Output:** 0\n**Explanation:** Rectangles must have four distinct corners."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.\n*   The number of `1`'s in the grid is in the range `[1, 6000]`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,0,0,1,0],[0,0,1,0,1],[0,0,0,1,0],[1,0,1,0,1]]",
                "output": "1"
            },
            {
                "input": "[[1,1,1],[1,1,1],[1,1,1]]",
                "output": "9"
            },
            {
                "input": "[[1,1,1,1]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countCornerRectangles(int[][] grid) {\n    int count = 0;\n    int m = grid.length;\n    int n = grid[0].length;\n    \n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            if (grid[i][j] == 1) {\n                for (int k = i + 1; k < m; k++) {\n                    for (int l = j + 1; l < n; l++) {\n                        if (grid[k][l] == 1 && grid[i][l] == 1 && grid[k][j] == 1) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ",
        "python": "\n    ```python\ndef countCornerRectangles(grid):\n    count = 0\n    m = len(grid)\n    n = len(grid[0])\n    \n    for i in range(m - 1):\n        for j in range(n - 1):\n            if grid[i][j] == 1:\n                for k in range(i + 1, m):\n                    for l in range(j + 1, n):\n                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:\n                            count += 1\n    return count\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ",
        "c++": "\n    ```cpp\nint countCornerRectangles(vector<vector<int>>& grid) {\n    int count = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n    \n    for (int i = 0; i < m - 1; i++) {\n        for (int j = 0; j < n - 1; j++) {\n            if (grid[i][j] == 1) {\n                for (int k = i + 1; k < m; k++) {\n                    for (int l = j + 1; l < n; l++) {\n                        if (grid[k][l] == 1 && grid[i][l] == 1 && grid[k][j] == 1) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    ",
        "js": "\n    ```javascript\nfunction countCornerRectangles(grid) {\n    let count = 0;\n    let m = grid.length;\n    let n = grid[0].length;\n    \n    for (let i = 0; i < m - 1; i++) {\n        for (let j = 0; j < n - 1; j++) {\n            if (grid[i][j] === 1) {\n                for (let k = i + 1; k < m; k++) {\n                    for (let l = j + 1; l < n; l++) {\n                        if (grid[k][l] === 1 && grid[i][l] === 1 && grid[k][j] === 1) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through each element of the grid, starting from the top-left corner to the bottom-right corner. For each element with value 1, it checks for another 1 in the same row but at a later column (forming a top corner of the rectangle) and another 1 in the same column but at a later row (forming a left corner of the rectangle). Then, it checks if the intersection point of these two corners (the bottom-right corner of the rectangle) is also 1. If all these conditions are met, it means a corner rectangle is formed, and the count is incremented. The final result is returned after iterating through all possible combinations.\n\nTime complexity: O(m^2 * n^2), where m and n are the dimensions of the grid\nSpace complexity: O(1)\n    "
    },
    {
        "id": 146,
        "title": "IP to CIDR",
        "difficulty": "Medium",
        "content": {
            "problem": "An **IP address** is a formatted 32-bit unsigned integer where each group of 8 bits is printed as a decimal number and the dot character `'.'` splits the groups.\n\n*   For example, the binary number `00001111 10001000 11111111 01101011` (spaces added for clarity) formatted as an IP address would be `\"15.136.255.107 \"`.\n\nA **CIDR block** is a format used to denote a specific set of IP addresses. It is a string consisting of a base IP address, followed by a slash, followed by a prefix length `k`. The addresses it covers are all the IPs whose **first `k` bits** are the same as the base IP address.\n\n*   For example, `\"123.45.67.89/20 \"` is a CIDR block with a prefix length of `20`. Any IP address whose binary representation matches `01111011 00101101 0100xxxx xxxxxxxx`, where `x` can be either `0` or `1`, is in the set covered by the CIDR block.\n\nYou are given a start IP address `ip` and the number of IP addresses we need to cover `n`. Your goal is to use **as few CIDR blocks as possible** to cover all the IP addresses in the **inclusive** range `[ip, ip + n - 1]` **exactly**. No other IP addresses outside of the range should be covered.\n\nReturn _the **shortest** list of **CIDR blocks** that covers the range of IP addresses. If there are multiple answers, return **any** of them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** ip =  \"255.0.0.7 \", n = 10\n**Output:** \\[ \"255.0.0.7/32 \", \"255.0.0.8/29 \", \"255.0.0.16/32 \"\\]\n**Explanation:**\nThe IP addresses that need to be covered are:\n- 255.0.0.7  -> 11111111 00000000 00000000 00000111\n- 255.0.0.8  -> 11111111 00000000 00000000 00001000\n- 255.0.0.9  -> 11111111 00000000 00000000 00001001\n- 255.0.0.10 -> 11111111 00000000 00000000 00001010\n- 255.0.0.11 -> 11111111 00000000 00000000 00001011\n- 255.0.0.12 -> 11111111 00000000 00000000 00001100\n- 255.0.0.13 -> 11111111 00000000 00000000 00001101\n- 255.0.0.14 -> 11111111 00000000 00000000 00001110\n- 255.0.0.15 -> 11111111 00000000 00000000 00001111\n- 255.0.0.16 -> 11111111 00000000 00000000 00010000\nThe CIDR block  \"255.0.0.7/32 \" covers the first address.\nThe CIDR block  \"255.0.0.8/29 \" covers the middle 8 addresses (binary format of 11111111 00000000 00000000 00001xxx).\nThe CIDR block  \"255.0.0.16/32 \" covers the last address.\nNote that while the CIDR block  \"255.0.0.0/28 \" does cover all the addresses, it also includes addresses outside of the range, so we cannot use it.\n\n",
                "**Example 2:**\n\n**Input:** ip =  \"117.145.102.62 \", n = 8\n**Output:** \\[ \"117.145.102.62/31 \", \"117.145.102.64/30 \", \"117.145.102.68/31 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `7 <= ip.length <= 15`\n*   `ip` is a valid **IPv4** on the form `\"a.b.c.d \"` where `a`, `b`, `c`, and `d` are integers in the range `[0, 255]`.\n*   `1 <= n <= 1000`\n*   Every implied address `ip + x` (for `x < n`) will be a valid IPv4 address.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"255.0.0.7\",10",
                "output": "[\"255.0.0.7/32\",\"255.0.0.8/29\",\"255.0.0.16/32\"]"
            },
            {
                "input": "\"117.145.102.62\",8",
                "output": "[\"117.145.102.62/31\",\"117.145.102.64/30\",\"117.145.102.68/31\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> ipToCIDR(String ip, int n) {\n    String[] parts = ip.split(\"\\\\.\");\n    int start = (Integer.parseInt(parts[0]) << 24) + (Integer.parseInt(parts[1]) << 16) + (Integer.parseInt(parts[2]) << 8) + Integer.parseInt(parts[3]);\n    int end = start + n - 1;\n    \n    List<String> ans = new ArrayList<>();\n    while (start <= end) {\n        int samePrefixBits = Integer.numberOfTrailingZeros(~(start & -start));\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        int range = 1 << samePrefixBits;\n        ans.add((start >> 24) + \".\" + ((start >> 16) & 255) + \".\" + ((start >> 8) & 255) + \".\" + (start & 255) + \"/\" + (32 - samePrefixBits));\n        start += range;\n    }\n    \n    return ans;\n}\n```\n\n    \n    The algorithm first converts the given IP to an integer. Then iteratively, it finds the first CIDR block that covers the starting IP and all the subsequent IPs that have the same prefix bits as the starting IP address, without covering any address outside the range. Once the range of the CIDR block is found, the CIDR block is added to the result and the starting IP is updated to be the next address after the found range. This process is repeated until the whole range is covered.\n\nFor each step, we start by finding the number of bits with a one in the lowest bits of the current starting IP's binary representation. This tells us how many bits are different from the preceding IP(s). Then, we keep decreasing the number of bits (effectively increasing the range) until we find a range that covers at least the remaining IPs in the range. To avoid overstepping the range, we decrease the prefix bits if the maximum number of IPs covered by the current CIDR block is more than what's left. Finally, we add the CIDR block and update the starting IP. The algorithm terminates when the starting IP becomes greater than the end IP.\n    ",
        "python": "\n    ```python\ndef ipToCIDR(ip: str, n: int) -> List[str]:\n    a, b, c, d = map(int, ip.split('.'))\n    start = (a << 24) + (b << 16) + (c << 8) + d\n    end = start + n - 1\n    \n    ans = []\n    while start <= end:\n        samePrefixBits = (~start & start).bit_length() - 1\n        while ((end - start) >> samePrefixBits) < 1:\n            samePrefixBits -= 1\n        range = 1 << samePrefixBits\n        ans.append(f\"{start >> 24}.{(start >> 16) & 255}.{(start >> 8) & 255}.{start & 255}/{32 - samePrefixBits}\")\n        start += range\n    \n    return ans\n```\n\n    \n    The algorithm first converts the given IP to an integer. Then iteratively, it finds the first CIDR block that covers the starting IP and all the subsequent IPs that have the same prefix bits as the starting IP address, without covering any address outside the range. Once the range of the CIDR block is found, the CIDR block is added to the result and the starting IP is updated to be the next address after the found range. This process is repeated until the whole range is covered.\n\nFor each step, we start by finding the number of bits with a one in the lowest bits of the current starting IP's binary representation. This tells us how many bits are different from the preceding IP(s). Then, we keep decreasing the number of bits (effectively increasing the range) until we find a range that covers at least the remaining IPs in the range. To avoid overstepping the range, we decrease the prefix bits if the maximum number of IPs covered by the current CIDR block is more than what's left. Finally, we add the CIDR block and update the starting IP. The algorithm terminates when the starting IP becomes greater than the end IP.\n    ",
        "c++": "\n    ```cpp\n#include <bitset>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> ipToCIDR(string ip, int n) {\n    stringstream ss(ip);\n    int a, b, c, d;\n    char ch;\n    ss >> a >> ch >> b >> ch >> c >> ch >> d;\n    unsigned mask = 0xFFFFFFFF;\n    unsigned start = (a << 24) + (b << 16) + (c << 8) + d;\n    unsigned end = start + n - 1;\n    \n    vector<string> ans;\n    while (start <= end) {\n        int samePrefixBits = __builtin_ctz(~(start & -start));\n        while ((mask >> samePrefixBits) & 1)\n            ++samePrefixBits;\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        unsigned range = 1 << samePrefixBits;\n        stringstream res;\n        res << (start >> 24) << \".\" << ((start >> 16) & 255) << \".\" << ((start >> 8) & 255) << \".\" << (start & 255) << \"/\" << (32 - samePrefixBits);\n        ans.push_back(res.str());\n        start += range;\n    }\n    \n    return ans;\n}\n```\n\n    \n    The algorithm first converts the given IP to an integer. Then iteratively, it finds the first CIDR block that covers the starting IP and all the subsequent IPs that have the same prefix bits as the starting IP address, without covering any address outside the range. Once the range of the CIDR block is found, the CIDR block is added to the result and the starting IP is updated to be the next address after the found range. This process is repeated until the whole range is covered.\n\nFor each step, we start by finding the number of bits with a one in the lowest bits of the current starting IP's binary representation. This tells us how many bits are different from the preceding IP(s). Then, we keep decreasing the number of bits (effectively increasing the range) until we find a range that covers at least the remaining IPs in the range. To avoid overstepping the range, we decrease the prefix bits if the maximum number of IPs covered by the current CIDR block is more than what's left. Finally, we add the CIDR block and update the starting IP. The algorithm terminates when the starting IP becomes greater than the end IP.\n    ",
        "js": "\n    ```javascript\nfunction ipToCIDR(ip, n) {\n    const [a, b, c, d] = ip.split('.').map(Number);\n    let start = (a << 24) + (b << 16) + (c << 8) + d;\n    const end = start + n - 1;\n    \n    const ans = [];\n    while (start <= end) {\n        let samePrefixBits = Math.clz32(~(start & -start));\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        const range = 1 << samePrefixBits;\n        ans.push(`${(start >> 24)}.${((start >> 16) & 255)}.${((start >> 8) & 255)}.${(start & 255)}/${32 - samePrefixBits}`);\n        start += range;\n    }\n    \n    return ans;\n}\n```\n\n    \n    The algorithm first converts the given IP to an integer. Then iteratively, it finds the first CIDR block that covers the starting IP and all the subsequent IPs that have the same prefix bits as the starting IP address, without covering any address outside the range. Once the range of the CIDR block is found, the CIDR block is added to the result and the starting IP is updated to be the next address after the found range. This process is repeated until the whole range is covered.\n\nFor each step, we start by finding the number of bits with a one in the lowest bits of the current starting IP's binary representation. This tells us how many bits are different from the preceding IP(s). Then, we keep decreasing the number of bits (effectively increasing the range) until we find a range that covers at least the remaining IPs in the range. To avoid overstepping the range, we decrease the prefix bits if the maximum number of IPs covered by the current CIDR block is more than what's left. Finally, we add the CIDR block and update the starting IP. The algorithm terminates when the starting IP becomes greater than the end IP.\n    "
    },
    {
        "id": 147,
        "title": "Pour Water",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an elevation map represents as an integer array `heights` where `heights[i]` representing the height of the terrain at index `i`. The width at each index is `1`. You are also given two integers `volume` and `k`. `volume` units of water will fall at index `k`.\n\nWater first drops at the index `k` and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules:\n\n*   If the droplet would eventually fall by moving left, then move left.\n*   Otherwise, if the droplet would eventually fall by moving right, then move right.\n*   Otherwise, rise to its current position.\n\nHere, **\"eventually fall \"** means that the droplet will eventually be at a lower level if it moves in that direction. Also, level means the height of the terrain plus any water in that column.\n\nWe can assume there is infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than one grid block, and each unit of water has to be in exactly one block.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[2,1,1,2,1,2,2\\], volume = 4, k = 3\n**Output:** \\[2,2,2,3,2,2,2\\]\n**Explanation:**\nThe first drop of water lands at index k = 3. When moving left or right, the water can only move to the same level or a lower level. (By level, we mean the total height of the terrain plus any water in that column.)\nSince moving left will eventually make it fall, it moves left. (A droplet  \"made to fall \" means go to a lower height than it was at previously.) Since moving left will not make it fall, it stays in place.\n \nThe next droplet falls at index k = 3. Since the new droplet moving left will eventually make it fall, it moves left. Notice that the droplet still preferred to move left, even though it could move right (and moving right makes it fall quicker.)\n \nThe third droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would eventually make it fall, it moves right.\n \nFinally, the fourth droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would not eventually make it fall, it stays in place.\n \n\n",
                "**Example 2:**\n\n**Input:** heights = \\[1,2,3,4\\], volume = 2, k = 2\n**Output:** \\[2,3,3,4\\]\n**Explanation:** The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.\n\n",
                "**Example 3:**\n\n**Input:** heights = \\[3,1,3\\], volume = 5, k = 1\n**Output:** \\[4,4,4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 100`\n*   `0 <= heights[i] <= 99`\n*   `0 <= volume <= 2000`\n*   `0 <= k < heights.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,1,2,1,2,2],4,3",
                "output": "[2,2,2,3,2,2,2]"
            },
            {
                "input": "[1,2,3,4],2,2",
                "output": "[2,3,3,4]"
            },
            {
                "input": "[3,1,3],5,1",
                "output": "[4,4,4]"
            }
        ],
        "java": "\n    ```java\npublic int minMoves(int target) {\n    target = Math.abs(target);\n    int step = 0;\n    int sum = 0;\n    while (sum < target || (sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Make sure the target is a positive integer by taking its absolute value.\n2. Initialize the `step` and `sum` variables to 0.\n3. Keep incrementing the `step` value by 1 and add it to the `sum` until the following condition is satisfied: `(sum >= target) && ((sum - target) % 2 == 0)`\n4. Return the minimum number of steps required to reach the destination, which will be the value of `step` at the end of the loop.\n    ",
        "python": "\n    ```python\ndef min_moves(target: int) -> int:\n    target = abs(target)\n    step = 0\n    total = 0\n    while total < target or (total - target) % 2 != 0:\n        step += 1\n        total += step\n    return step\n```\n\n    \n    The algorithm works as follows:\n1. Make sure the target is a positive integer by taking its absolute value.\n2. Initialize the `step` and `sum` variables to 0.\n3. Keep incrementing the `step` value by 1 and add it to the `sum` until the following condition is satisfied: `(sum >= target) && ((sum - target) % 2 == 0)`\n4. Return the minimum number of steps required to reach the destination, which will be the value of `step` at the end of the loop.\n    ",
        "c++": "\n    ```cpp\nint min_moves(int target) {\n    target = abs(target);\n    int step = 0;\n    int sum = 0;\n    while (sum < target || (sum - target) % 2 == 1) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Make sure the target is a positive integer by taking its absolute value.\n2. Initialize the `step` and `sum` variables to 0.\n3. Keep incrementing the `step` value by 1 and add it to the `sum` until the following condition is satisfied: `(sum >= target) && ((sum - target) % 2 == 0)`\n4. Return the minimum number of steps required to reach the destination, which will be the value of `step` at the end of the loop.\n    ",
        "js": "\n    ```javascript\nfunction minMoves(target) {\n    target = Math.abs(target);\n    let step = 0;\n    let sum = 0;\n    while (sum < target || (sum - target) % 2 !== 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Make sure the target is a positive integer by taking its absolute value.\n2. Initialize the `step` and `sum` variables to 0.\n3. Keep incrementing the `step` value by 1 and add it to the `sum` until the following condition is satisfied: `(sum >= target) && ((sum - target) % 2 == 0)`\n4. Return the minimum number of steps required to reach the destination, which will be the value of `step` at the end of the loop.\n    "
    },
    {
        "id": 148,
        "title": "Bold Words in String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of keywords `words` and a string `s`, make all appearances of all keywords `words[i]` in `s` bold. Any letters between **and** tags become bold.\n\nReturn `s` _after adding the bold tags_. The returned string should use the least number of tags possible, and the tags should form a valid combination.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"ab \", \"bc \"\\], s =  \"aabcd \"\n**Output:**  \"a**abc**d \"\n**Explanation:** Note that returning ` \"a**a**b**c**d \"` would use more tags, so it is incorrect.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"ab \", \"cb \"\\], s =  \"aabcd \"\n**Output:**  \"a**ab**cd \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `0 <= words.length <= 50`\n*   `1 <= words[i].length <= 10`\n*   `s` and `words[i]` consist of lowercase English letters.\n\n**Note:** This question is the same as 616: [https://leetcode.com/problems/add-bold-tag-in-string/](https://leetcode.com/problems/add-bold-tag-in-string/)",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"ab\",\"bc\"],\"aabcd\"",
                "output": "\"a**abc**d\""
            },
            {
                "input": "[\"ab\",\"cb\"],\"aabcd\"",
                "output": "\"a**ab**cd\""
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic String addBoldTag(List<String> words, String s) {\n    boolean[] bold = new boolean[s.length()];\n    for (String word : words) {\n        int pos = s.indexOf(word);\n        while (pos != -1) {\n            for (int i = pos; i < pos + word.length(); i++) {\n                bold[i] = true;\n            }\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n        if (bold[i] && (i == 0 || !bold[i - 1])) result.append(\"<b>\");\n        result.append(s.charAt(i));\n        if (bold[i] && (i == s.length() - 1 || !bold[i + 1])) result.append(\"</b>\");\n    }\n\n    return result.toString();\n}\n```\n    \n    1. Create an array `bold` of boolean values, same length as `s`, initially set to `false`.\n2. For each `word` in `words`, find its indices in `s`. For each index found, set the corresponding elements in `bold` to `true`.\n3. Create an empty result string. Iterate through `s` and concatenate each character to the result string. If the character is marked as bold and the previous character is not marked as bold, prepend a `<b>` tag. If the character is marked as bold and the next character is not marked as bold, append a `</b>` tag.\n4. Return the result string with bold tags inserted.\n    ",
        "python": "\n    ```python\ndef addBoldTag(words, s):\n    bold = [False] * len(s)\n    for word in words:\n        pos = s.find(word)\n        while pos != -1:\n            for i in range(pos, pos + len(word)):\n                bold[i] = True\n            pos = s.find(word, pos + 1)\n\n    result = []\n    for i in range(len(s)):\n        if bold[i] and (i == 0 or not bold[i - 1]):\n            result.append(\"<b>\")\n        result.append(s[i])\n        if bold[i] and (i == len(s) - 1 or not bold[i + 1]):\n            result.append(\"</b>\")\n\n    return \"\".join(result)\n```\n    \n    1. Create an array `bold` of boolean values, same length as `s`, initially set to `false`.\n2. For each `word` in `words`, find its indices in `s`. For each index found, set the corresponding elements in `bold` to `true`.\n3. Create an empty result string. Iterate through `s` and concatenate each character to the result string. If the character is marked as bold and the previous character is not marked as bold, prepend a `<b>` tag. If the character is marked as bold and the next character is not marked as bold, append a `</b>` tag.\n4. Return the result string with bold tags inserted.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string addBoldTag(std::vector<std::string>& words, std::string s) {\n    std::vector<bool> bold(s.size(), false);\n    for (std::string word : words) {\n        int pos = s.find(word);\n        while (pos != std::string::npos) {\n            for (int i = pos; i < pos + word.size(); i++) {\n                bold[i] = true;\n            }\n            pos = s.find(word, pos + 1);\n        }\n    }\n\n    std::string result = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (bold[i] && (i == 0 || !bold[i - 1])) result += \"<b>\";\n        result += s[i];\n        if (bold[i] && (i == s.size() - 1 || !bold[i + 1])) result += \"</b>\";\n    }\n\n    return result;\n}\n```\n    \n    1. Create an array `bold` of boolean values, same length as `s`, initially set to `false`.\n2. For each `word` in `words`, find its indices in `s`. For each index found, set the corresponding elements in `bold` to `true`.\n3. Create an empty result string. Iterate through `s` and concatenate each character to the result string. If the character is marked as bold and the previous character is not marked as bold, prepend a `<b>` tag. If the character is marked as bold and the next character is not marked as bold, append a `</b>` tag.\n4. Return the result string with bold tags inserted.\n    ",
        "js": "\n    ```javascript\nfunction addBoldTag(words, s) {\n    const bold = new Array(s.length).fill(false);\n    for (const word of words) {\n        let pos = s.indexOf(word);\n        while (pos !== -1) {\n            for (let i = pos; i < pos + word.length; i++) {\n                bold[i] = true;\n            }\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n\n    let result = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (bold[i] && (i === 0 || !bold[i - 1])) result += \"<b>\";\n        result += s[i];\n        if (bold[i] && (i === s.length - 1 || !bold[i + 1])) result += \"</b>\";\n    }\n\n    return result;\n}\n```\n    \n    1. Create an array `bold` of boolean values, same length as `s`, initially set to `false`.\n2. For each `word` in `words`, find its indices in `s`. For each index found, set the corresponding elements in `bold` to `true`.\n3. Create an empty result string. Iterate through `s` and concatenate each character to the result string. If the character is marked as bold and the previous character is not marked as bold, prepend a `<b>` tag. If the character is marked as bold and the next character is not marked as bold, append a `</b>` tag.\n4. Return the result string with bold tags inserted.\n    "
    },
    {
        "id": 149,
        "title": "Employee Free Time",
        "difficulty": "Hard",
        "content": {
            "problem": "We are given a list `schedule` of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing **common, positive-length free time** for _all_ employees, also in sorted order.\n\n(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined). Also, we wouldn't include intervals like \\[5, 5\\] in our answer, as they have zero length.",
            "examples": [
                "**Example 1:**\n\n**Input:** schedule = \\[\\[\\[1,2\\],\\[5,6\\]\\],\\[\\[1,3\\]\\],\\[\\[4,10\\]\\]\\]\n**Output:** \\[\\[3,4\\]\\]\n**Explanation:** There are a total of three employees, and all common\nfree time intervals would be \\[-inf, 1\\], \\[3, 4\\], \\[10, inf\\].\nWe discard any intervals that contain inf as they aren't finite.\n\n",
                "**Example 2:**\n\n**Input:** schedule = \\[\\[\\[1,3\\],\\[6,7\\]\\],\\[\\[2,4\\]\\],\\[\\[2,5\\],\\[9,12\\]\\]\\]\n**Output:** \\[\\[5,6\\],\\[7,9\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= schedule.length , schedule[i].length <= 50`\n*   `0 <= schedule[i].start < schedule[i].end <= 10^8`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[[1,2],[5,6]],[[1,3]],[[4,10]]]",
                "output": "[[3,4]]"
            },
            {
                "input": "[[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]",
                "output": "[[5,6],[7,9]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int minSetSize(int[][] intervals) {\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n    int n = intervals.length;\n    int end = intervals[0][1];\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "python": "\n    ```python\ndef min_set_size(intervals):\n    intervals.sort()\n    n = len(intervals)\n    end = intervals[0][1]\n    count = 1\n\n    for i in range(1, n):\n        if end < intervals[i][0]:\n            end = intervals[i][1]\n            count += 1\n        else:\n            end = min(end, intervals[i][1])\n    return count * 2\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minSetSize(std::vector<std::pair<int, int>> intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    int n = intervals.size();\n    int end = intervals[0].second;\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i].first) {\n            end = intervals[i].second;\n            count++;\n        } else {\n            end = std::min(end, intervals[i].second);\n        }\n    }\n    return count * 2;\n}\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "js": "\n    ```javascript\nfunction minSetSize(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    const n = intervals.length;\n    let end = intervals[0][1];\n    let count = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    "
    },
    {
        "id": 150,
        "title": "Find Anagram Mappings",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2` where `nums2` is **an anagram** of `nums1`. Both arrays may contain duplicates.\n\nReturn _an index mapping array_ `mapping` _from_ `nums1` _to_ `nums2` _where_ `mapping[i] = j` _means the_ `ith` _element in_ `nums1` _appears in_ `nums2` _at index_ `j`. If there are multiple answers, return **any of them**.\n\nAn array `a` is **an anagram** of an array `b` means `b` is made by randomizing the order of the elements in `a`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[12,28,46,32,50\\], nums2 = \\[50,12,32,46,28\\]\n**Output:** \\[1,4,3,2,0\\]\n**Explanation:** As mapping\\[0\\] = 1 because the 0th element of nums1 appears at nums2\\[1\\], and mapping\\[1\\] = 4 because the 1st element of nums1 appears at nums2\\[4\\], and so on.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[84,46\\], nums2 = \\[84,46\\]\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length <= 100`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 105`\n*   `nums2` is an anagram of `nums1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[12,28,46,32,50],[50,12,32,46,28]",
                "output": "[1,4,3,2,0]"
            },
            {
                "input": "[84,46],[84,46]",
                "output": "[0,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] anagramMappings(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> num_map = new HashMap<>();\n    for (int i = 0; i < nums2.length; i++) {\n        num_map.put(nums2[i], i);\n    }\n    int[] mapping = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "python": "\n    ```python\ndef anagramMappings(nums1, nums2):\n    num_map = {num: i for i, num in enumerate(nums2)}\n    mapping = [num_map[num] for num in nums1]\n    return mapping\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int, int> num_map;\n    for (int i = 0; i < nums2.size(); i++) {\n        num_map[nums2[i]] = i;\n    }\n    vector<int> mapping(nums1.size());\n    for (int i = 0; i < nums1.size(); i++) {\n        mapping[i] = num_map[nums1[i]];\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "js": "\n    ```javascript\nfunction anagramMappings(nums1, nums2) {\n    let num_map = new Map();\n    for (let i = 0; i < nums2.length; i++) {\n        num_map.set(nums2[i], i);\n    }\n    let mapping = new Array(nums1.length);\n    for (let i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    "
    },
    {
        "id": 151,
        "title": "Basic Calculator III",
        "difficulty": "Hard",
        "content": {
            "problem": "Implement a basic calculator to evaluate a simple expression string.\n\nThe expression string contains only non-negative integers, `'+'`, `'-'`, `'*'`, `'/'` operators, and open `'('` and closing parentheses `')'`. The integer division should **truncate toward zero**.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.\n\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1+1 \"\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** s =  \"6-4/2 \"\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** s =  \"2\\*(5+5\\*2)/3+(6/2+8) \"\n**Output:** 21"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s <= 104`\n*   `s` consists of digits, `'+'`, `'-'`, `'*'`, `'/'`, `'('`, and `')'`.\n*   `s` is a **valid** expression.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"1+1\"",
                "output": "2"
            },
            {
                "input": "\"6-4/2\"",
                "output": "4"
            },
            {
                "input": "\"2*(5+5*2)/3+(6/2+8)\"",
                "output": "21"
            }
        ],
        "java": "\n    ```java\nclass Node {\n    boolean val;\n    boolean isLeaf;\n    Node topLeft;\n    Node topRight;\n    Node bottomLeft;\n    Node bottomRight;\n\n    public Node() {\n        this(false, false, null, null, null, null);\n    }\n\n    public Node(boolean val, boolean isLeaf) {\n        this(val, isLeaf, null, null, null, null);\n    }\n\n    public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {\n        this.val = val;\n        this.isLeaf = isLeaf;\n        this.topLeft = topLeft;\n        this.topRight = topRight;\n        this.bottomLeft = bottomLeft;\n        this.bottomRight = bottomRight;\n    }\n}\n\npublic Node construct(int[][] grid) {\n    return helper(grid, 0, 0, grid.length);\n}\n\nprivate Node helper(int[][] grid, int x, int y, int length) {\n    if (length == 1) {\n        return new Node(grid[x][y] == 1, true);\n    }\n\n    Node tl = helper(grid, x, y, length / 2);\n    Node tr = helper(grid, x, y + length / 2, length / 2);\n    Node bl = helper(grid, x + length / 2, y, length / 2);\n    Node br = helper(grid, x + length / 2, y + length / 2, length / 2);\n\n    if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf &&\n        tl.val == tr.val && tr.val == bl.val && bl.val == br.val) {\n        return new Node(tl.val, true);\n    } else {\n        return new Node(false, false, tl, tr, bl, br);\n    }\n}\n```\n    \n    We start by defining a Node class for each language implementation, which represents a node in the Quad-Tree. The construct function initiates the construction of the Quad-Tree by calling the helper function with the initial indices (0, 0) and the length of the input grid.\n\nThe helper function works recursively to build the Quad-Tree. The base case for the recursion is when the length is 1, and we create a leaf node with the value of the cell in the grid.\n\nIn order to create the internal nodes, the helper function checks the topLeft, topRight, bottomLeft, and bottomRight subgrids by recursively calling itself with the updated indices and a halved length. If all the children nodes are leaf nodes and they have the same value, we return a new leaf node with the same value, discarding the created children nodes. If this condition doesn't hold, an internal node with the current children nodes is created.\n\nOnce the recursion successfully checks and constructs the entire grid, the root node of the Quad-Tree is returned, representing the constructed tree for the input grid.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val: bool, isLeaf: bool, topLeft: 'Node', topRight: 'Node', bottomLeft: 'Node', bottomRight: 'Node'):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef construct(grid):\n    def helper(x, y, length):\n        if length == 1:\n            return Node(grid[x][y] == 1, True, None, None, None, None)\n\n        tl = helper(x, y, length // 2)\n        tr = helper(x, y + length // 2, length // 2)\n        bl = helper(x + length // 2, y, length // 2)\n        br = helper(x + length // 2, y + length // 2, length // 2)\n\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val and tr.val == bl.val and bl.val == br.val:\n            return Node(tl.val, True, None, None, None, None)\n        else:\n            return Node(False, False, tl, tr, bl, br)\n\n    return helper(0, 0, len(grid))\n```\n    \n    We start by defining a Node class for each language implementation, which represents a node in the Quad-Tree. The construct function initiates the construction of the Quad-Tree by calling the helper function with the initial indices (0, 0) and the length of the input grid.\n\nThe helper function works recursively to build the Quad-Tree. The base case for the recursion is when the length is 1, and we create a leaf node with the value of the cell in the grid.\n\nIn order to create the internal nodes, the helper function checks the topLeft, topRight, bottomLeft, and bottomRight subgrids by recursively calling itself with the updated indices and a halved length. If all the children nodes are leaf nodes and they have the same value, we return a new leaf node with the same value, discarding the created children nodes. If this condition doesn't hold, an internal node with the current children nodes is created.\n\nOnce the recursion successfully checks and constructs the entire grid, the root node of the Quad-Tree is returned, representing the constructed tree for the input grid.\n    ",
        "c++": "\n    ```cpp\nstruct Node {\n    bool val;\n    bool isLeaf;\n    Node* topLeft;\n    Node* topRight;\n    Node* bottomLeft;\n    Node* bottomRight;\n};\n\nNode* construct(vector<vector<int>>& grid) {\n    return helper(grid, 0, 0, grid.size());\n}\n\nNode* helper(vector<vector<int>>& grid, int x, int y, int length) {\n    if (length == 1) {\n        return new Node{grid[x][y] == 1, true, nullptr, nullptr, nullptr, nullptr};\n    }\n    \n    Node* tl = helper(grid, x, y, length / 2);\n    Node* tr = helper(grid, x, y + length / 2, length / 2);\n    Node* bl = helper(grid, x + length / 2, y, length / 2);\n    Node* br = helper(grid, x + length / 2, y + length / 2, length / 2);\n    \n    if (tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf &&\n        tl->val == tr->val && tr->val == bl->val && bl->val == br->val) {\n        bool value = tl->val;\n        delete tl;\n        delete tr;\n        delete bl;\n        delete br;\n        return new Node{value, true, nullptr, nullptr, nullptr, nullptr};\n    } else {\n        return new Node{false, false, tl, tr, bl, br};\n    }\n}\n```\n    \n    We start by defining a Node class for each language implementation, which represents a node in the Quad-Tree. The construct function initiates the construction of the Quad-Tree by calling the helper function with the initial indices (0, 0) and the length of the input grid.\n\nThe helper function works recursively to build the Quad-Tree. The base case for the recursion is when the length is 1, and we create a leaf node with the value of the cell in the grid.\n\nIn order to create the internal nodes, the helper function checks the topLeft, topRight, bottomLeft, and bottomRight subgrids by recursively calling itself with the updated indices and a halved length. If all the children nodes are leaf nodes and they have the same value, we return a new leaf node with the same value, discarding the created children nodes. If this condition doesn't hold, an internal node with the current children nodes is created.\n\nOnce the recursion successfully checks and constructs the entire grid, the root node of the Quad-Tree is returned, representing the constructed tree for the input grid.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight) {\n        this.val = val;\n        this.isLeaf = isLeaf;\n        this.topLeft = topLeft;\n        this.topRight = topRight;\n        this.bottomLeft = bottomLeft;\n        this.bottomRight = bottomRight;\n    }\n}\n\nfunction construct(grid) {\n    function helper(x, y, length) {\n        if (length === 1) {\n            return new Node(grid[x][y] === 1, true, null, null, null, null);\n        }\n\n        const tl = helper(x, y, length >> 1);\n        const tr = helper(x, y + (length >> 1), length >> 1);\n        const bl = helper(x + (length >> 1), y, length >> 1);\n        const br = helper(x + (length >> 1), y + (length >> 1), length >> 1);\n\n        if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && tl.val === tr.val && tr.val === bl.val && bl.val === br.val) {\n            return new Node(tl.val, true, null, null, null, null);\n        } else {\n            return new Node(false, false, tl, tr, bl, br);\n        }\n    }\n\n    return helper(0, 0, grid.length);\n}\n```\n    \n    We start by defining a Node class for each language implementation, which represents a node in the Quad-Tree. The construct function initiates the construction of the Quad-Tree by calling the helper function with the initial indices (0, 0) and the length of the input grid.\n\nThe helper function works recursively to build the Quad-Tree. The base case for the recursion is when the length is 1, and we create a leaf node with the value of the cell in the grid.\n\nIn order to create the internal nodes, the helper function checks the topLeft, topRight, bottomLeft, and bottomRight subgrids by recursively calling itself with the updated indices and a halved length. If all the children nodes are leaf nodes and they have the same value, we return a new leaf node with the same value, discarding the created children nodes. If this condition doesn't hold, an internal node with the current children nodes is created.\n\nOnce the recursion successfully checks and constructs the entire grid, the root node of the Quad-Tree is returned, representing the constructed tree for the input grid.\n    "
    },
    {
        "id": 152,
        "title": "Minimize Max Distance to Gas Station",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `stations` that represents the positions of the gas stations on the **x-axis**. You are also given an integer `k`.\n\nYou should add `k` new gas stations. You can add the stations anywhere on the **x-axis**, and not necessarily on an integer position.\n\nLet `penalty()` be the maximum distance between **adjacent** gas stations after adding the `k` new stations.\n\nReturn _the smallest possible value of_ `penalty()`. Answers within `10-6` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** stations = \\[1,2,3,4,5,6,7,8,9,10\\], k = 9\n**Output:** 0.50000\n\n",
                "**Example 2:**\n\n**Input:** stations = \\[23,24,36,39,46,56,57,65,84,98\\], k = 1\n**Output:** 14.00000"
            ],
            "constraints": "**Constraints:**\n\n*   `10 <= stations.length <= 2000`\n*   `0 <= stations[i] <= 108`\n*   `stations` is sorted in a **strictly increasing** order.\n*   `1 <= k <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5,6,7,8,9,10],9",
                "output": "0.50000"
            },
            {
                "input": "[23,24,36,39,46,56,57,65,84,98],1",
                "output": "14.00000"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n}\n \npublic int maxDepth(Node root) {\n    if (root == null) {\n        return 0;\n    }\n    int depth = 0;\n    for (Node child : root.children) {\n        depth = Math.max(depth, maxDepth(child));\n    }\n    return 1 + depth;\n}\n```\n    \n    The algorithm works by recursively traversing the n-ary tree. It visits each node in the tree and calculates the maximum depth for each of its children. To find the maximum depth for the entire tree, it takes the maximum depth of all children and adds 1, representing the current root node. If the root is `null` or `None`, the maximum depth is 0.\n\nEach language implementation utilizes a `Node` class with a constructor to store the node value and children. It also has a `maxDepth` function that carries out the algorithm mentioned above. The difference among the languages lies only in the syntax for the class definitions and function calls.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n \ndef max_depth(root):\n    if root is None:\n        return 0\n    depth = 0\n    for child in root.children:\n        depth = max(depth, max_depth(child))\n    return 1 + depth\n```\n    \n    The algorithm works by recursively traversing the n-ary tree. It visits each node in the tree and calculates the maximum depth for each of its children. To find the maximum depth for the entire tree, it takes the maximum depth of all children and adds 1, representing the current root node. If the root is `null` or `None`, the maximum depth is 0.\n\nEach language implementation utilizes a `Node` class with a constructor to store the node value and children. It also has a `maxDepth` function that carries out the algorithm mentioned above. The difference among the languages lies only in the syntax for the class definitions and function calls.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nclass Node {\npublic:\n    int val;\n    std::vector<Node*> children;\n \n    Node() {}\n \n    Node(int _val) {\n        val = _val;\n    }\n};\n \nint maxDepth(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    int depth = 0;\n    for (Node* child : root->children) {\n        depth = std::max(depth, maxDepth(child));\n    }\n    return 1 + depth;\n}\n```\n    \n    The algorithm works by recursively traversing the n-ary tree. It visits each node in the tree and calculates the maximum depth for each of its children. To find the maximum depth for the entire tree, it takes the maximum depth of all children and adds 1, representing the current root node. If the root is `null` or `None`, the maximum depth is 0.\n\nEach language implementation utilizes a `Node` class with a constructor to store the node value and children. It also has a `maxDepth` function that carries out the algorithm mentioned above. The difference among the languages lies only in the syntax for the class definitions and function calls.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, children = []) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\nfunction maxDepth(root) {\n    if (root === null) {\n        return 0;\n    }\n    let depth = 0;\n    for (const child of root.children) {\n        depth = Math.max(depth, maxDepth(child));\n    }\n    return 1 + depth;\n}\n```\n    \n    The algorithm works by recursively traversing the n-ary tree. It visits each node in the tree and calculates the maximum depth for each of its children. To find the maximum depth for the entire tree, it takes the maximum depth of all children and adds 1, representing the current root node. If the root is `null` or `None`, the maximum depth is 0.\n\nEach language implementation utilizes a `Node` class with a constructor to store the node value and children. It also has a `maxDepth` function that carries out the algorithm mentioned above. The difference among the languages lies only in the syntax for the class definitions and function calls.\n    "
    },
    {
        "id": 153,
        "title": "Split BST",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary search tree (BST) and an integer `target`, split the tree into two subtrees where one subtree has nodes that are all smaller or equal to the target value, while the other subtree has all nodes that are greater than the target value. It Is not necessarily the case that the tree contains a node with the value `target`.\n\nAdditionally, most of the structure of the original tree should remain. Formally, for any child `c` with parent `p` in the original tree, if they are both in the same subtree after the split, then node `c` should still have the parent `p`.\n\nReturn _an array of the two roots of the two subtrees_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[4,2,6,1,3,5,7\\], target = 2\n**Output:** \\[\\[2,1\\],\\[4,3,6,null,null,5,7\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1\\], target = 1\n**Output:** \\[\\[1\\],\\[\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 50]`.\n*   `0 <= Node.val, target <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,6,1,3,5,7],2",
                "output": "[[2,1],[4,3,6,null,null,5,7]]"
            },
            {
                "input": "[1],1",
                "output": "[[1],[]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Stack;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n    public Node(int _val) {val = _val;}\n    public Node(int _val, List<Node> _children) {val = _val; children = _children;}\n}\n\npublic List<Integer> postorder(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if(root == null) return result;\n\n    Stack<Node> stack = new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()) {\n        Node current = stack.pop();\n\n        result.add(current.val);\n        for(Node child : current.children) {\n            stack.push(child);\n        }\n    }\n    Collections.reverse(result);\n    return result;\n}\n```\n    \n    The algorithm uses an iterative approach with a stack to perform the postorder traversal of the n-ary tree. Instead of appending the values of the nodes during the traversal, the values are pushed to the result list. As we go deeper into the tree, the children of each node encountered are pushed onto a stack to keep track of the nodes to visit next. \n\nAfter traversing the tree, the result list is reversed, which gives the desired postorder traversal. \n\nThis algorithm works for all the languages mentioned: C++, Java, Python, and JavaScript, with minor syntax differences for handling the stack and the children of the nodes.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef postorder(root: 'Node'):\n    if root is None:\n        return []\n    \n    result = []\n    stack = [root]\n\n    while stack:\n        curr = stack.pop()\n        result.append(curr.val)\n        stack.extend(curr.children)\n\n    return result[::-1]\n```\n    \n    The algorithm uses an iterative approach with a stack to perform the postorder traversal of the n-ary tree. Instead of appending the values of the nodes during the traversal, the values are pushed to the result list. As we go deeper into the tree, the children of each node encountered are pushed onto a stack to keep track of the nodes to visit next. \n\nAfter traversing the tree, the result list is reversed, which gives the desired postorder traversal. \n\nThis algorithm works for all the languages mentioned: C++, Java, Python, and JavaScript, with minor syntax differences for handling the stack and the children of the nodes.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n\nclass Node {\npublic:\n    int val;\n    std::vector<Node*> children;\n\n    Node() {}\n    Node(int _val) {val = _val;}\n    Node(int _val, std::vector<Node*> _children) {val = _val; children = _children;}\n};\n\nstd::vector<int> postorder(Node* root) {\n    std::vector<int> result;\n    if(root == nullptr) return result;\n\n    std::stack<Node*> s;\n    s.push(root);\n    while(!s.empty()) {\n        Node* curr = s.top();\n        s.pop();\n        \n        result.push_back(curr->val);\n        for(Node* child : curr->children) {\n            s.push(child);\n        }\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n    \n    The algorithm uses an iterative approach with a stack to perform the postorder traversal of the n-ary tree. Instead of appending the values of the nodes during the traversal, the values are pushed to the result list. As we go deeper into the tree, the children of each node encountered are pushed onto a stack to keep track of the nodes to visit next. \n\nAfter traversing the tree, the result list is reversed, which gives the desired postorder traversal. \n\nThis algorithm works for all the languages mentioned: C++, Java, Python, and JavaScript, with minor syntax differences for handling the stack and the children of the nodes.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val, children) {\n        this.val = val;\n        this.children = children ? children : [];\n    }\n}\n\nfunction postorder(root) {\n    if (!root) return [];\n    \n    let result = [];\n    let stack = [root];\n    \n    while (stack.length) {\n        let current = stack.pop();\n        result.push(current.val);\n        stack.push(...current.children);\n    }\n    \n    return result.reverse();\n}\n```\n    \n    The algorithm uses an iterative approach with a stack to perform the postorder traversal of the n-ary tree. Instead of appending the values of the nodes during the traversal, the values are pushed to the result list. As we go deeper into the tree, the children of each node encountered are pushed onto a stack to keep track of the nodes to visit next. \n\nAfter traversing the tree, the result list is reversed, which gives the desired postorder traversal. \n\nThis algorithm works for all the languages mentioned: C++, Java, Python, and JavaScript, with minor syntax differences for handling the stack and the children of the nodes.\n    "
    },
    {
        "id": 154,
        "title": "Is Graph Bipartite?",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an **undirected** graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:\n\n*   There are no self-edges (`graph[u]` does not contain `u`).\n*   There are no parallel edges (`graph[u]` does not contain duplicate values).\n*   If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).\n*   The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.\n\nA graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.\n\nReturn `true` _if and only if it is **bipartite**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[1,2,3\\],\\[0,2\\],\\[0,1,3\\],\\[0,2\\]\\]\n**Output:** false\n**Explanation:** There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0,2\\],\\[1,3\\],\\[0,2\\]\\]\n**Output:** true\n**Explanation:** We can partition the nodes into two sets: {0, 2} and {1, 3}."
            ],
            "constraints": "**Constraints:**\n\n*   `graph.length == n`\n*   `1 <= n <= 100`\n*   `0 <= graph[u].length < n`\n*   `0 <= graph[u][i] <= n - 1`\n*   `graph[u]` does not contain `u`.\n*   All the values of `graph[u]` are **unique**.\n*   If `graph[u]` contains `v`, then `graph[v]` contains `u`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,2,3],[0,2],[0,1,3],[0,2]]",
                "output": "false"
            },
            {
                "input": "[[1,3],[0,2],[1,3],[0,2]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] colors = new int[n];\n        Arrays.fill(colors, 0);\n\n        for (int i = 0; i < n; ++i) {\n            if (colors[i] == 0 && !dfs(i, 1, colors, graph)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private boolean dfs(int node, int color, int[] colors, int[][] graph) {\n        if (colors[node] != 0) {\n            return colors[node] == color;\n        }\n\n        colors[node] = color;\n        for (int neighbor : graph[node]) {\n            if (!dfs(neighbor, 3 - color, colors, graph)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n    \n    The algorithm is based on a Depth First Search (DFS). We iterate over all nodes, performing a DFS on the nodes that have not been assigned a color yet.\n\nIn the DFS, we first check if the node has a color assigned. If it has, we return true if the assigned color matches the expected color. If the node does not have a color assigned, we assign the expected color to it, and perform the DFS on all its neighbors with the alternate color (3 - color). If any of these DFS return false, we return false. Otherwise, we return true.\n\nAfter iterating all nodes, if none of them returned false, then the graph is bipartite.\n\nThis algorithm does not depend on the specific programming language, but the syntax for the DFS and color assignments will vary according to the language used.\n    ",
        "python": "\n    ```python\ndef isBipartite(graph: List[List[int]]) -> bool:\n    def dfs(node: int, color: int) -> bool:\n        if colors[node]:\n            return colors[node] == color\n\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not dfs(neighbor, 3 - color):\n                return False\n\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n\n    for i in range(n):\n        if not colors[i] and not dfs(i, 1):\n            return False\n\n    return True\n```\n    \n    The algorithm is based on a Depth First Search (DFS). We iterate over all nodes, performing a DFS on the nodes that have not been assigned a color yet.\n\nIn the DFS, we first check if the node has a color assigned. If it has, we return true if the assigned color matches the expected color. If the node does not have a color assigned, we assign the expected color to it, and perform the DFS on all its neighbors with the alternate color (3 - color). If any of these DFS return false, we return false. Otherwise, we return true.\n\nAfter iterating all nodes, if none of them returned false, then the graph is bipartite.\n\nThis algorithm does not depend on the specific programming language, but the syntax for the DFS and color assignments will vary according to the language used.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool dfs(int node, int color, vector<int>& colors, vector<vector<int>>& graph) {\n    if (colors[node] != 0) {\n        return colors[node] == color;\n    }\n\n    colors[node] = color;\n    for (int neighbor : graph[node]) {\n        if (!dfs(neighbor, 3 - color, colors, graph)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool isBipartite(vector<vector<int>>& graph) {\n    int n = graph.size();\n    vector<int> colors(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        if (colors[i] == 0 && !dfs(i, 1, colors, graph)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    The algorithm is based on a Depth First Search (DFS). We iterate over all nodes, performing a DFS on the nodes that have not been assigned a color yet.\n\nIn the DFS, we first check if the node has a color assigned. If it has, we return true if the assigned color matches the expected color. If the node does not have a color assigned, we assign the expected color to it, and perform the DFS on all its neighbors with the alternate color (3 - color). If any of these DFS return false, we return false. Otherwise, we return true.\n\nAfter iterating all nodes, if none of them returned false, then the graph is bipartite.\n\nThis algorithm does not depend on the specific programming language, but the syntax for the DFS and color assignments will vary according to the language used.\n    ",
        "js": "\n    ```javascript\nvar isBipartite = function(graph) {\n    function dfs(node, color) {\n        if (colors[node] !== 0) {\n            return colors[node] === color;\n        }\n\n        colors[node] = color;\n        for (const neighbor of graph[node]) {\n            if (!dfs(neighbor, 3 - color)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    let n = graph.length;\n    let colors = new Array(n).fill(0);\n\n    for (let i = 0; i < n; ++i) {\n        if (colors[i] === 0 && !dfs(i, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n```\n    \n    The algorithm is based on a Depth First Search (DFS). We iterate over all nodes, performing a DFS on the nodes that have not been assigned a color yet.\n\nIn the DFS, we first check if the node has a color assigned. If it has, we return true if the assigned color matches the expected color. If the node does not have a color assigned, we assign the expected color to it, and perform the DFS on all its neighbors with the alternate color (3 - color). If any of these DFS return false, we return false. Otherwise, we return true.\n\nAfter iterating all nodes, if none of them returned false, then the graph is bipartite.\n\nThis algorithm does not depend on the specific programming language, but the syntax for the DFS and color assignments will vary according to the language used.\n    "
    },
    {
        "id": 155,
        "title": "Similar RGB Color",
        "difficulty": "Easy",
        "content": {
            "problem": "The red-green-blue color `\"#AABBCC \"` can be written as `\"#ABC \"` in shorthand.\n\n*   For example, `\"#15c \"` is shorthand for the color `\"#1155cc \"`.\n\nThe similarity between the two colors `\"#ABCDEF \"` and `\"#UVWXYZ \"` is `-(AB - UV)2 - (CD - WX)2 - (EF - YZ)2`.\n\nGiven a string `color` that follows the format `\"#ABCDEF \"`, return a string represents the color that is most similar to the given color and has a shorthand (i.e., it can be represented as some `\"#XYZ \"`).\n\n**Any answer** which has the same highest similarity as the best answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** color =  \"#09f166 \"\n**Output:**  \"#11ee66 \"\n**Explanation:** \nThe similarity is -(0x09 - 0x11)2 -(0xf1 - 0xee)2 - (0x66 - 0x66)2 = -64 -9 -0 = -73.\nThis is the highest among any shorthand color.\n\n",
                "**Example 2:**\n\n**Input:** color =  \"#4e3fe1 \"\n**Output:**  \"#5544dd \""
            ],
            "constraints": "**Constraints:**\n\n*   `color.length == 7`\n*   `color[0] == '#'`\n*   `color[i]` is either digit or character in the range `['a', 'f']` for `i > 0`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"#09f166\"",
                "output": "\"#11ee66\""
            },
            {
                "input": "\"#4e3fe1\"",
                "output": "\"#5544dd\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> letterCasePermutation(String s) {\n    List<String> result = new ArrayList<>();\n    backtrack(s.toCharArray(), 0, result);\n    return result;\n}\n\nprivate void backtrack(char[] s, int index, List<String> result) {\n    if (index == s.length) {\n        result.add(new String(s));\n        return;\n    }\n    backtrack(s, index + 1, result);\n    if (Character.isLetter(s[index])) {\n        s[index] ^= (1 << 5);\n        backtrack(s, index + 1, result);\n        s[index] ^= (1 << 5);\n    }\n}\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "python": "\n    ```python\ndef letterCasePermutation(s):\n    def backtrack(index):\n        if index == len(s):\n            result.append(\"\".join(s))\n            return\n        backtrack(index + 1)\n        if s[index].isalpha():\n            s[index] = s[index].swapcase()\n            backtrack(index + 1)\n            s[index] = s[index].swapcase()\n\n    result = []\n    s = list(s)\n    backtrack(0)\n    return result\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid backtrack(std::string s, int index, std::vector<std::string>& result) {\n    if (index == s.length()) {\n        result.push_back(s);\n        return;\n    }\n    backtrack(s, index + 1, result);\n    if (isalpha(s[index])) {\n        s[index] ^= (1 << 5);\n        backtrack(s, index + 1, result);\n    }\n}\n\nstd::vector<std::string> letterCasePermutation(std::string s) {\n    std::vector<std::string> result;\n    backtrack(s, 0, result);\n    return result;\n}\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "js": "\n    ```javascript\nfunction letterCasePermutation(s) {\n    const result = [];\n    function backtrack(index) {\n        if (index === s.length) {\n            result.push(s.join(''));\n            return;\n        }\n        backtrack(index + 1);\n        if (s[index] !== s[index].toUpperCase() || s[index] !== s[index].toLowerCase()) {\n            s[index] = flipCase(s[index]);\n            backtrack(index + 1);\n            s[index] = flipCase(s[index]);\n        }\n    }\n    s = s.split('');\n    backtrack(0);\n    return result;\n}\n\nfunction flipCase(c) {\n    return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();\n}\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    "
    },
    {
        "id": 156,
        "title": "Convert to Base -2",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _a binary string representing its representation in base_ `-2`.\n\n**Note** that the returned string should not have leading zeros unless the string is `\"0 \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:**  \"110 \"\n**Explantion:** (-2)2 + (-2)1 = 2\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:**  \"111 \"\n**Explantion:** (-2)2 + (-2)1 + (-2)0 = 3\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:**  \"100 \"\n**Explantion:** (-2)2 = 4"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2",
                "output": "\"110\"\n**Explantion:**(-2)2+(-2)1=2"
            },
            {
                "input": "3",
                "output": "\"111\"\n**Explantion:**(-2)2+(-2)1+(-2)0=3"
            },
            {
                "input": "4",
                "output": "\"100\"\n**Explantion:**(-2)2=4"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeMap;\n\npublic int oddEvenJumps(int[] arr) {\n    int n = arr.length;\n    boolean[] canReachOdd = new boolean[n], canReachEven = new boolean[n];\n    canReachOdd[n - 1] = canReachEven[n - 1] = true;\n    TreeMap<Integer, Integer> indexMap = new TreeMap<>();\n    indexMap.put(arr[n - 1], n - 1);\n\n    int goodIndices = 1;\n    for (int i = n - 2; i >= 0; --i) {\n        Integer oddJump = indexMap.ceilingKey(arr[i]);\n        Integer evenJump = indexMap.floorKey(arr[i]);\n\n        if (oddJump != null) canReachOdd[i] = canReachEven[indexMap.get(oddJump)];\n        if (evenJump != null) canReachEven[i] = canReachOdd[indexMap.get(evenJump)];\n\n        if (canReachOdd[i]) ++goodIndices;\n\n        indexMap.put(arr[i], i);\n    }\n\n    return goodIndices;\n}\n```\n    \n    The algorithm uses dynamic programming and creates two arrays: `canReachOdd` and `canReachEven`. The last element of both arrays is set to true, indicating the end of the array can be reached on both odd and even jumps. You also need to create a map to store indices, with the corresponding key as the element at that index.\n\nIterating through the array in reverse, we find the smallest elements in the map that are greater than or equal to the current element for odd-numbered jumps (`oddJump`), and the largest elements in the map that are less than or equal to the current element for even-numbered jumps (`evenJump`). If the values are found, we update the `canReachOdd` and `canReachEven` arrays with the values from the map.\n\nIf the current index can be reached from an odd-numbered jump, we increase the number of good indices.\n\nFinally, return the value of good indices.\n    ",
        "python": "\n    ```python\ndef odd_even_jumps(arr):\n    n = len(arr)\n    can_reach_odd = [False] * n\n    can_reach_even = [False] * n\n    can_reach_odd[-1] = can_reach_even[-1] = True\n\n    index_map = {}\n    index_map[arr[-1]] = n - 1\n\n    good_indices = 1\n    for i in range(n - 2, -1, -1):\n        odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None)\n        even_jump = next(iter([value for value in index_map if value <= arr[i]]), None)\n\n        if odd_jump is not None:\n            can_reach_odd[i] = can_reach_even[index_map[odd_jump]]\n        if even_jump is not None:\n            can_reach_even[i] = can_reach_odd[index_map[even_jump]]\n\n        if can_reach_odd[i]:\n            good_indices += 1\n\n        index_map[arr[i]] = i\n\n    return good_indices\n```\n    \n    The algorithm uses dynamic programming and creates two arrays: `canReachOdd` and `canReachEven`. The last element of both arrays is set to true, indicating the end of the array can be reached on both odd and even jumps. You also need to create a map to store indices, with the corresponding key as the element at that index.\n\nIterating through the array in reverse, we find the smallest elements in the map that are greater than or equal to the current element for odd-numbered jumps (`oddJump`), and the largest elements in the map that are less than or equal to the current element for even-numbered jumps (`evenJump`). If the values are found, we update the `canReachOdd` and `canReachEven` arrays with the values from the map.\n\nIf the current index can be reached from an odd-numbered jump, we increase the number of good indices.\n\nFinally, return the value of good indices.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n\nint oddEvenJumps(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<bool> canReachOdd(n, false), canReachEven(n, false);\n    canReachOdd[n - 1] = canReachEven[n - 1] = true;\n    std::map<int, int> indexMap;\n    indexMap[arr[n - 1]] = n - 1;\n\n    int goodIndices = 1;\n    for (int i = n - 2; i >= 0; --i) {\n        auto oddJump = indexMap.lower_bound(arr[i]);\n        auto evenJump = indexMap.upper_bound(arr[i]);\n\n        if (oddJump != indexMap.end())\n            canReachOdd[i] = canReachEven[oddJump->second];\n        if (evenJump != indexMap.begin())\n            canReachEven[i] = canReachOdd[(--evenJump)->second];\n\n        if (canReachOdd[i]) ++goodIndices;\n\n        indexMap[arr[i]] = i;\n    }\n\n    return goodIndices;\n}\n```\n    \n    The algorithm uses dynamic programming and creates two arrays: `canReachOdd` and `canReachEven`. The last element of both arrays is set to true, indicating the end of the array can be reached on both odd and even jumps. You also need to create a map to store indices, with the corresponding key as the element at that index.\n\nIterating through the array in reverse, we find the smallest elements in the map that are greater than or equal to the current element for odd-numbered jumps (`oddJump`), and the largest elements in the map that are less than or equal to the current element for even-numbered jumps (`evenJump`). If the values are found, we update the `canReachOdd` and `canReachEven` arrays with the values from the map.\n\nIf the current index can be reached from an odd-numbered jump, we increase the number of good indices.\n\nFinally, return the value of good indices.\n    ",
        "js": "\n    ```javascript\nfunction oddEvenJumps(arr) {\n    const n = arr.length;\n    const canReachOdd = new Array(n).fill(false);\n    const canReachEven = new Array(n).fill(false);\n    canReachOdd[n - 1] = canReachEven[n - 1] = true;\n\n    const indexMap = new Map();\n    indexMap.set(arr[n - 1], n - 1);\n\n    let goodIndices = 1;\n    for (let i = n - 2; i >= 0; --i) {\n        const oddJump = [...indexMap.keys()].find((value) => value >= arr[i]);\n        const evenJump = [...indexMap.keys()].find((value) => value <= arr[i]);\n\n        if (oddJump !== undefined)\n            canReachOdd[i] = canReachEven[indexMap.get(oddJump)];\n        if (evenJump !== undefined)\n            canReachEven[i] = canReachOdd[indexMap.get(evenJump)];\n\n        if (canReachOdd[i]) ++goodIndices;\n\n        indexMap.set(arr[i], i);\n    }\n\n    return goodIndices;\n}\n```\n    \n    The algorithm uses dynamic programming and creates two arrays: `canReachOdd` and `canReachEven`. The last element of both arrays is set to true, indicating the end of the array can be reached on both odd and even jumps. You also need to create a map to store indices, with the corresponding key as the element at that index.\n\nIterating through the array in reverse, we find the smallest elements in the map that are greater than or equal to the current element for odd-numbered jumps (`oddJump`), and the largest elements in the map that are less than or equal to the current element for even-numbered jumps (`evenJump`). If the values are found, we update the `canReachOdd` and `canReachEven` arrays with the values from the map.\n\nIf the current index can be reached from an odd-numbered jump, we increase the number of good indices.\n\nFinally, return the value of good indices.\n    "
    },
    {
        "id": 157,
        "title": "Shortest Way to Form String",
        "difficulty": "Medium",
        "content": {
            "problem": "A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).\n\nGiven two strings `source` and `target`, return _the minimum number of **subsequences** of_ `source` _such that their concatenation equals_ `target`. If the task is impossible, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** source =  \"abc \", target =  \"abcbc \"\n**Output:** 2\n**Explanation:** The target  \"abcbc \" can be formed by  \"abc \" and  \"bc \", which are subsequences of source  \"abc \".\n\n",
                "**Example 2:**\n\n**Input:** source =  \"abc \", target =  \"acdbc \"\n**Output:** -1\n**Explanation:** The target string cannot be constructed from the subsequences of source string due to the character  \"d \" in target string.\n\n",
                "**Example 3:**\n\n**Input:** source =  \"xyz \", target =  \"xzyxz \"\n**Output:** 3\n**Explanation:** The target string can be constructed as follows  \"xz \" +  \"y \" +  \"xz \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= source.length, target.length <= 1000`\n*   `source` and `target` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abc\",\"abcbc\"",
                "output": "2"
            },
            {
                "input": "\"abc\",\"acdbc\"",
                "output": "-1"
            },
            {
                "input": "\"xyz\",\"xzyxz\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int numPairsDivisibleBy60(int[] time) {\n    int[] count = new int[60];\n    int pairs = 0;\n\n    for (int t : time) {\n        int mod = t % 60;\n        pairs += count[(60 - mod) % 60];\n        count[mod]++;\n    }\n\n    return pairs;\n}\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    ",
        "python": "\n    ```python\ndef num_pairs_divisible_by60(time):\n    count = [0] * 60\n    pairs = 0\n\n    for t in time:\n        mod = t % 60\n        pairs += count[(60 - mod) % 60]\n        count[mod] += 1\n\n    return pairs\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint numPairsDivisibleBy60(vector<int>& time) {\n    int count[60] = {0};\n    int pairs = 0;\n\n    for (int t : time) {\n        int mod = t % 60;\n        pairs += count[(60 - mod) % 60];\n        count[mod]++;\n    }\n\n    return pairs;\n}\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    ",
        "js": "\n    ```javascript\nfunction numPairsDivisibleBy60(time) {\n    let count = new Array(60).fill(0);\n    let pairs = 0;\n\n    for (let t of time) {\n        let mod = t % 60;\n        pairs += count[(60 - mod) % 60];\n        count[mod]++;\n    }\n\n    return pairs;\n}\n```\n    \n    The algorithm calculates the modulus (`t % 60`) for each song duration and stores the frequency in the `count` array. When iterating through the song durations, if the durations have moduluses that sum to 60, they meet the pair condition. Therefore, for each song duration, it adds the frequency of the required modulus (`(60 - mod) % 60`) to the count of pairs. This way, the algorithm counts all valid pairs for each song duration.\n\nThe algorithm only requires one pass through the input list; thus, its time complexity is O(n), where n is the number of songs in the input list. The extra space needed is the `count` array, which has a constant size of 60; hence, the space complexity is O(1).\n    "
    },
    {
        "id": 158,
        "title": "Confusing Number",
        "difficulty": "Easy",
        "content": {
            "problem": "A **confusing number** is a number that when rotated `180` degrees becomes a different number with **each digit valid**.\n\nWe can rotate digits of a number by `180` degrees to form new digits.\n\n*   When `0`, `1`, `6`, `8`, and `9` are rotated `180` degrees, they become `0`, `1`, `9`, `8`, and `6` respectively.\n*   When `2`, `3`, `4`, `5`, and `7` are rotated `180` degrees, they become **invalid**.\n\nNote that after rotating a number, we can ignore leading zeros.\n\n*   For example, after rotating `8000`, we have `0008` which is considered as just `8`.\n\nGiven an integer `n`, return `true` _if it is a **confusing number**, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6\n**Output:** true\n**Explanation:** We get 9 after rotating 6, 9 is a valid number, and 9 != 6.\n\n",
                "**Example 2:**\n\n**Input:** n = 89\n**Output:** true\n**Explanation:** We get 68 after rotating 89, 68 is a valid number and 68 != 89.\n\n",
                "**Example 3:**\n\n**Input:** n = 11\n**Output:** false\n**Explanation:** We get 11 after rotating 11, 11 is a valid number but the value remains the same, thus 11 is not a confusing number"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "6",
                "output": "true"
            },
            {
                "input": "89",
                "output": "true"
            },
            {
                "input": "11",
                "output": "false"
            }
        ],
        "java": "\n    \n```java\nimport java.util.Arrays;\n\npublic int shipWithinDays(int[] weights, int days) {\n    int left = Arrays.stream(weights).max().getAsInt();\n    int right = Arrays.stream(weights).sum();\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int day_count = 1, curr_capacity = 0;\n        for (int w : weights) {\n            curr_capacity += w;\n            if (curr_capacity > mid) {\n                day_count++;\n                curr_capacity = w;\n            }\n        }\n        if (day_count > days) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    \nThe algorithm employs binary search to find the least weight capacity. It starts by setting the initial search range to the maximum weight among packages (left) and the total weight of all packages (right). Then, the algorithm does the following steps until left is not less than right:\n1. Compute the middle value (mid) of the search range.\n2. Go through the packages' weights and count the days needed to ship them with the current mid value as the capacity. If the accumulated weight of packages exceeds the current capacity (mid), increment the day count and reset the accumulated weight.\n3. If the calculated days needed is greater than the given days, we need a bigger capacity, so we update left to mid + 1. Otherwise, update right to mid.\n\nAfter the loop, left is the least weight capacity that will ship all packages within days days.\n    ",
        "js": "\n    \n```javascript\nfunction shipWithinDays(weights, days) {\n    let left = Math.max(...weights), right = weights.reduce((a, b) => a + b, 0);\n    while (left < right) {\n        let mid = left + ((right - left) / 2) | 0;\n        let day_count = 1, curr_capacity = 0;\n        for (const w of weights) {\n            curr_capacity += w;\n            if (curr_capacity > mid) {\n                day_count++;\n                curr_capacity = w;\n            }\n        }\n        if (day_count > days) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    \nThe algorithm employs binary search to find the least weight capacity. It starts by setting the initial search range to the maximum weight among packages (left) and the total weight of all packages (right). Then, the algorithm does the following steps until left is not less than right:\n1. Compute the middle value (mid) of the search range.\n2. Go through the packages' weights and count the days needed to ship them with the current mid value as the capacity. If the accumulated weight of packages exceeds the current capacity (mid), increment the day count and reset the accumulated weight.\n3. If the calculated days needed is greater than the given days, we need a bigger capacity, so we update left to mid + 1. Otherwise, update right to mid.\n\nAfter the loop, left is the least weight capacity that will ship all packages within days days.\n    ",
        "c++": "\n    \n```cpp\n#include <vector>\n#include <algorithm>\n\nint shipWithinDays(std::vector<int>& weights, int days) {\n    int left = *max_element(weights.begin(), weights.end());\n    int right = accumulate(weights.begin(), weights.end(), 0);\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int day_count = 1, curr_capacity = 0;\n        for (int w : weights) {\n            curr_capacity += w;\n            if (curr_capacity > mid) {\n                day_count++;\n                curr_capacity = w;\n            }\n        }\n        if (day_count > days) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    \nThe algorithm employs binary search to find the least weight capacity. It starts by setting the initial search range to the maximum weight among packages (left) and the total weight of all packages (right). Then, the algorithm does the following steps until left is not less than right:\n1. Compute the middle value (mid) of the search range.\n2. Go through the packages' weights and count the days needed to ship them with the current mid value as the capacity. If the accumulated weight of packages exceeds the current capacity (mid), increment the day count and reset the accumulated weight.\n3. If the calculated days needed is greater than the given days, we need a bigger capacity, so we update left to mid + 1. Otherwise, update right to mid.\n\nAfter the loop, left is the least weight capacity that will ship all packages within days days.\n    ",
        "python": "\n    \n```python\ndef ship_within_days(weights, days):\n    left, right = max(weights), sum(weights)\n    while left < right:\n        mid = left + (right - left) // 2\n        day_count, curr_capacity = 1, 0\n        for w in weights:\n            curr_capacity += w\n            if curr_capacity > mid:\n                day_count += 1\n                curr_capacity = w\n        if day_count > days:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n```\n    \n    \nThe algorithm employs binary search to find the least weight capacity. It starts by setting the initial search range to the maximum weight among packages (left) and the total weight of all packages (right). Then, the algorithm does the following steps until left is not less than right:\n1. Compute the middle value (mid) of the search range.\n2. Go through the packages' weights and count the days needed to ship them with the current mid value as the capacity. If the accumulated weight of packages exceeds the current capacity (mid), increment the day count and reset the accumulated weight.\n3. If the calculated days needed is greater than the given days, we need a bigger capacity, so we update left to mid + 1. Otherwise, update right to mid.\n\nAfter the loop, left is the least weight capacity that will ship all packages within days days.\n    "
    },
    {
        "id": 159,
        "title": "Campus Bikes",
        "difficulty": "Medium",
        "content": {
            "problem": "On a campus represented on the X-Y plane, there are `n` workers and `m` bikes, with `n <= m`.\n\nYou are given an array `workers` of length `n` where `workers[i] = [xi, yi]` is the position of the `ith` worker. You are also given an array `bikes` of length `m` where `bikes[j] = [xj, yj]` is the position of the `jth` bike. All the given positions are **unique**.\n\nAssign a bike to each worker. Among the available bikes and workers, we choose the `(workeri, bikej)` pair with the shortest **Manhattan distance** between each other and assign the bike to that worker.\n\nIf there are multiple `(workeri, bikej)` pairs with the same shortest **Manhattan distance**, we choose the pair with **the smallest worker index**. If there are multiple ways to do that, we choose the pair with **the smallest bike index**. Repeat this process until there are no available workers.\n\nReturn _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the index (**0-indexed**) of the bike that the_ `ith` _worker is assigned to_.\n\nThe **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** workers = \\[\\[0,0\\],\\[2,1\\]\\], bikes = \\[\\[1,2\\],\\[3,3\\]\\]\n**Output:** \\[1,0\\]\n**Explanation:** Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is \\[1, 0\\].\n\n",
                "**Example 2:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\]\\], bikes = \\[\\[1,0\\],\\[2,2\\],\\[2,1\\]\\]\n**Output:** \\[0,2,1\\]\n**Explanation:** Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is \\[0,2,1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == workers.length`\n*   `m == bikes.length`\n*   `1 <= n <= m <= 1000`\n*   `workers[i].length == bikes[j].length == 2`\n*   `0 <= xi, yi < 1000`\n*   `0 <= xj, yj < 1000`\n*   All worker and bike locations are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0],[2,1]],[[1,2],[3,3]]",
                "output": "[1,0]"
            },
            {
                "input": "[[0,0],[1,1],[2,0]],[[1,0],[2,2],[2,1]]",
                "output": "[0,2,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\n\npublic int numDupDigitsAtMostN(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        HashSet<Integer> digits = new HashSet<>();\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digits.contains(digit)) {\n                count++;\n                break;\n            } else {\n                digits.add(digit);\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    ",
        "python": "\n    ```python\ndef num_dup_digits_at_most_n(n):\n    count = 0\n    for i in range(1, n + 1):\n        digits = set()\n        num = i\n        while num != 0:\n            digit = num % 10\n            if digit in digits:\n                count += 1\n                break\n            else:\n                digits.add(digit)\n            num //= 10\n    return count\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    ",
        "c++": "\n    ```cpp\n#include <set>\nusing namespace std;\n\nint numDupDigitsAtMostN(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        set<int> digits;\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digits.count(digit)) {\n                count++;\n                break;\n            } else {\n                digits.insert(digit);\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    ",
        "js": "\n    ```javascript\nfunction numDupDigitsAtMostN(n) {\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        let digits = new Set();\n        let num = i;\n        while (num !== 0) {\n            let digit = num % 10;\n            if (digits.has(digit)) {\n                count++;\n                break;\n            } else {\n                digits.add(digit);\n            }\n            num = Math.floor(num / 10);\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over the range of numbers from 1 to n inclusive. For each number, it extracts the digits by taking the remainder when dividing by 10 (`num % 10`) and adds it to a set (or hash set in Java) of digits. If a digit is already present in the set, it means that the digit is repeated, so we increment the count and break this iteration. At the end, we return the count of numbers with at least one repeated digit.\n    "
    },
    {
        "id": 160,
        "title": "Minimize Rounding Error to Meet Target",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of `prices` `[p1,p2...,pn]` and a `target`, round each price `pi` to `Roundi(pi)` so that the rounded array `[Round1(p1),Round2(p2)...,Roundn(pn)]` sums to the given `target`. Each operation `Roundi(pi)` could be either `Floor(pi)` or `Ceil(pi)`.\n\nReturn the string `\"-1 \"` if the rounded array is impossible to sum to `target`. Otherwise, return the smallest rounding error, which is defined as ` |Roundi(pi) - (pi)|` for `i` from `1` to `n`, as a string with three places after the decimal.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[ \"0.700 \", \"2.800 \", \"4.900 \"\\], target = 8\n**Output:**  \"1.000 \"\n**Explanation:**\nUse Floor, Ceil and Ceil operations to get (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[ \"1.500 \", \"2.500 \", \"3.500 \"\\], target = 10\n**Output:**  \"-1 \"\n**Explanation:** It is impossible to meet the target.\n\n",
                "**Example 3:**\n\n**Input:** prices = \\[ \"1.500 \", \"2.500 \", \"3.500 \"\\], target = 9\n**Output:**  \"1.500 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 500`\n*   Each string `prices[i]` represents a real number in the range `[0.0, 1000.0]` and has exactly 3 decimal places.\n*   `0 <= target <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"0.700\",\"2.800\",\"4.900\"],8",
                "output": "\"1.000\""
            },
            {
                "input": "[\"1.500\",\"2.500\",\"3.500\"],10",
                "output": "\"-1\""
            },
            {
                "input": "[\"1.500\",\"2.500\",\"3.500\"],9",
                "output": "\"1.500\""
            }
        ],
        "java": "\n    ```java\nimport java.text.DecimalFormat;\nimport java.math.BigDecimal;\n\npublic String findRoundingError(String[] prices, int target) {\n    int n = prices.length;\n    BigDecimal[] decimals = new BigDecimal[n];\n    int roundedSum = 0;\n    BigDecimal errorSum = BigDecimal.ZERO;\n\n    for (int i = 0; i < n; i++) {\n        BigDecimal price = new BigDecimal(prices[i]);\n        decimals[i] = price.subtract(price.setScale(0, BigDecimal.ROUND_DOWN));\n        roundedSum += price.setScale(0, BigDecimal.ROUND_DOWN).intValue();\n        errorSum = errorSum.add(decimals[i]);\n    }\n\n    if (target < roundedSum || target > roundedSum + n) {\n        return \"-1 \";\n    }\n\n    int ceilCount = target - roundedSum;\n    BigDecimal roundingError = BigDecimal.ZERO;\n\n    for (int i = 0; i < n; i++) {\n        if (ceilCount > 0) {\n            roundingError = roundingError.add(BigDecimal.ONE.subtract(decimals[i]));\n            ceilCount--;\n        } else {\n            roundingError = roundingError.add(decimals[i]);\n        }\n    }\n\n    DecimalFormat df = new DecimalFormat(\"#.000\");\n    return df.format(roundingError) + \" \";\n}\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    ",
        "python": "\n    ```python\nfrom math import floor, ceil\n\ndef find_rounding_error(prices, target):\n    n = len(prices)\n    decimals = [float(price) - floor(float(price)) for price in prices]\n    rounded_sum = sum(floor(float(price)) for price in prices)\n\n    if target < rounded_sum or target > rounded_sum + n:\n        return \"-1 \"\n\n    ceil_count = target - rounded_sum\n    rounding_error = 0.0\n\n    for d in decimals:\n        if ceil_count > 0:\n            rounding_error += 1 - d\n            ceil_count -= 1\n        else:\n            rounding_error += d\n\n    return f\"{rounding_error:.3f} \"\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nstring findRoundingError(vector<string>& prices, int target) {\n    int n = prices.size();\n    vector<double> decimals(n);\n    int rounded_sum = 0;\n    double error_sum = 0.0;\n\n    for (int i = 0; i < n; ++i) {\n        double price = stod(prices[i]);\n        decimals[i] = price - floor(price);\n        rounded_sum += floor(price);\n        error_sum += decimals[i];\n    }\n\n    if (target < rounded_sum || target > rounded_sum + n) {\n        return \"-1 \";\n    }\n\n    int ceil_count = target - rounded_sum;\n    double rounding_error = 0.0;\n\n    for (int i = 0; i < n; ++i) {\n        if (ceil_count > 0) {\n            rounding_error += 1 - decimals[i];\n            --ceil_count;\n        } else {\n            rounding_error += decimals[i];\n        }\n    }\n\n    return to_string(rounding_error).substr(0, 5) + \" \";\n}\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    ",
        "js": "\n    ```javascript\nfunction findRoundingError(prices, target) {\n    const n = prices.length;\n    const decimals = prices.map(price => {\n        let num = parseFloat(price);\n        return num - Math.floor(num);\n    });\n\n    const roundedSum = prices.reduce((sum, price) => {\n        return sum + Math.floor(parseFloat(price));\n    }, 0);\n\n    if (target < roundedSum || target > roundedSum + n) {\n        return '-1 ';\n    }\n\n    let ceilCount = target - roundedSum;\n    let roundingError = 0;\n\n    for (let d of decimals) {\n        if (ceilCount > 0) {\n            roundingError += 1 - d;\n            ceilCount--;\n        } else {\n            roundingError += d;\n        }\n    }\n    roundingError = roundingError.toFixed(3);\n    return roundingError.toString() + \" \";\n}\n```\n\n    \n    1. Convert the input `prices` to decimal numbers, and calculate the decimal parts (decimal array) using flooring or subtraction from the integer value.\n2. Compute the sum of the floors (rounded sum) of the `prices`.\n3. Check if the target is reachable (i.e., in the range of the rounded sum and the rounded sum + number of prices). If not, return \"-1 \".\n4. Calculate the number of ceiling operations needed (ceil_count).\n5. Compute the smallest rounding error by iterating over the decimal array, subtracting the decimal value (using ceil operation) or adding it to the rounding error. The condition should depend on whether ceil_count is positive or not.\n6. Return the result as a string with three decimal places.\n    "
    },
    {
        "id": 161,
        "title": "All Paths from Source Lead to Destination",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `edges` of a directed graph where `edges[i] = [ai, bi]` indicates there is an edge between nodes `ai` and `bi`, and two nodes `source` and `destination` of this graph, determine whether or not all paths starting from `source` eventually, end at `destination`, that is:\n\n*   At least one path exists from the `source` node to the `destination` node\n*   If a path exists from the `source` node to a node with no outgoing edges, then that node is equal to `destination`.\n*   The number of possible paths from `source` to `destination` is a finite number.\n\nReturn `true` if and only if all roads from `source` lead to `destination`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[0,2\\]\\], source = 0, destination = 2\n**Output:** false\n**Explanation:** It is possible to reach and get stuck on both node 1 and node 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[0,3\\],\\[1,2\\],\\[2,1\\]\\], source = 0, destination = 3\n**Output:** false\n**Explanation:** We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely.\n\n",
                "**Example 3:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[2,3\\]\\], source = 0, destination = 3\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`\n*   `0 <= edges.length <= 104`\n*   `edges.length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `0 <= source <= n - 1`\n*   `0 <= destination <= n - 1`\n*   The given graph may have self-loops and parallel edges.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,[[0,1],[0,2]],0,2",
                "output": "false"
            },
            {
                "input": "4,[[0,1],[0,3],[1,2],[2,1]],0,3",
                "output": "false"
            },
            {
                "input": "4,[[0,1],[0,2],[1,3],[2,3]],0,3",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean leadsToDestination(int n, int[][] edges, int source, int destination) {\n    Map<Integer, List<Integer>> graph = new HashMap<>();\n    for (int[] edge : edges) {\n        graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\n    }\n\n    int[] visited = new int[n];\n    return dfs(source, graph, visited, destination);\n}\n\nprivate boolean dfs(int node, Map<Integer, List<Integer>> graph, int[] visited, int destination) {\n    if (!graph.containsKey(node)) return node == destination;\n    if (visited[node] != 0) return visited[node] == 2;\n\n    visited[node] = 1;\n    for (int neighbor : graph.get(node)) {\n        if (!dfs(neighbor, graph, visited, destination)) return false;\n    }\n\n    visited[node] = 2;\n    return true;\n}\n```\n    \n    The approach is to use Depth-First Search (DFS) to traverse the graph starting from the source node. While doing DFS, if a node is found that has no outgoing edges, we check if it is the destination node. Also, if we visit a node that we have visited before and it has finished processing, it means the destination node can be reached from the current node, so we return true.\n\n1. Start by creating a graph from the edge list, and initializing a visited list of length n with all values set to 0.\n\n2. Use a helper function, `dfs`, which receives the current node, the graph, the visited list, and the destination node as parameters.\n\n3. In the dfs function, check the following:\n  a. If the node has no outgoing edges (i.e., it's not in the graph), return whether the node is the destination node.\n  b. If the visited[node] is not 0, return whether it is equal to 2.\n  c. If neither of the above conditions are met, set visited[node] to 1 and iterate through the neighbors of the node in the graph. For each neighbor, recursively call the dfs function with the neighbor as the new node. If any of the recursive calls return false, return false.\n  d. After the loop is done, set visited[node] to 2 and return true.\n\n4. In the main function, call `dfs` with the source node and return the result.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef leadsToDestination(n, edges, source, destination):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n\n    visited = [0] * n\n    return dfs(source, graph, visited, destination)\n\ndef dfs(node, graph, visited, destination):\n    if node not in graph:\n        return node == destination\n    if visited[node] != 0:\n        return visited[node] == 2\n\n    visited[node] = 1\n    for neighbor in graph[node]:\n        if not dfs(neighbor, graph, visited, destination):\n            return False\n\n    visited[node] = 2\n    return True\n```\n    \n    The approach is to use Depth-First Search (DFS) to traverse the graph starting from the source node. While doing DFS, if a node is found that has no outgoing edges, we check if it is the destination node. Also, if we visit a node that we have visited before and it has finished processing, it means the destination node can be reached from the current node, so we return true.\n\n1. Start by creating a graph from the edge list, and initializing a visited list of length n with all values set to 0.\n\n2. Use a helper function, `dfs`, which receives the current node, the graph, the visited list, and the destination node as parameters.\n\n3. In the dfs function, check the following:\n  a. If the node has no outgoing edges (i.e., it's not in the graph), return whether the node is the destination node.\n  b. If the visited[node] is not 0, return whether it is equal to 2.\n  c. If neither of the above conditions are met, set visited[node] to 1 and iterate through the neighbors of the node in the graph. For each neighbor, recursively call the dfs function with the neighbor as the new node. If any of the recursive calls return false, return false.\n  d. After the loop is done, set visited[node] to 2 and return true.\n\n4. In the main function, call `dfs` with the source node and return the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nbool dfs(int node, const std::unordered_map<int, std::vector<int>>& graph, std::vector<int>& visited, int destination) {\n    if (graph.find(node) == graph.end()) return node == destination;\n    if (visited[node] != 0) return visited[node] == 2;\n\n    visited[node] = 1;\n    for (int neighbor : graph.at(node)) {\n        if (!dfs(neighbor, graph, visited, destination)) return false;\n    }\n\n    visited[node] = 2;\n    return true;\n}\n\nbool leadsToDestination(int n, const std::vector<std::vector<int>>& edges, int source, int destination) {\n    std::unordered_map<int, std::vector<int>> graph;\n    for (const auto& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n    }\n\n    std::vector<int> visited(n, 0);\n    return dfs(source, graph, visited, destination);\n}\n```\n    \n    The approach is to use Depth-First Search (DFS) to traverse the graph starting from the source node. While doing DFS, if a node is found that has no outgoing edges, we check if it is the destination node. Also, if we visit a node that we have visited before and it has finished processing, it means the destination node can be reached from the current node, so we return true.\n\n1. Start by creating a graph from the edge list, and initializing a visited list of length n with all values set to 0.\n\n2. Use a helper function, `dfs`, which receives the current node, the graph, the visited list, and the destination node as parameters.\n\n3. In the dfs function, check the following:\n  a. If the node has no outgoing edges (i.e., it's not in the graph), return whether the node is the destination node.\n  b. If the visited[node] is not 0, return whether it is equal to 2.\n  c. If neither of the above conditions are met, set visited[node] to 1 and iterate through the neighbors of the node in the graph. For each neighbor, recursively call the dfs function with the neighbor as the new node. If any of the recursive calls return false, return false.\n  d. After the loop is done, set visited[node] to 2 and return true.\n\n4. In the main function, call `dfs` with the source node and return the result.\n    ",
        "js": "\n    ```javascript\nfunction leadsToDestination(n, edges, source, destination) {\n    const graph = new Map();\n    for (const [u, v] of edges) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push(v);\n    }\n\n    const visited = new Array(n).fill(0);\n    return dfs(source, graph, visited, destination);\n}\n\nfunction dfs(node, graph, visited, destination) {\n    if (!graph.has(node)) return node === destination;\n    if (visited[node] !== 0) return visited[node] === 2;\n\n    visited[node] = 1;\n    for (const neighbor of graph.get(node)) {\n        if (!dfs(neighbor, graph, visited, destination)) return false;\n    }\n\n    visited[node] = 2;\n    return true;\n}\n```\n    \n    The approach is to use Depth-First Search (DFS) to traverse the graph starting from the source node. While doing DFS, if a node is found that has no outgoing edges, we check if it is the destination node. Also, if we visit a node that we have visited before and it has finished processing, it means the destination node can be reached from the current node, so we return true.\n\n1. Start by creating a graph from the edge list, and initializing a visited list of length n with all values set to 0.\n\n2. Use a helper function, `dfs`, which receives the current node, the graph, the visited list, and the destination node as parameters.\n\n3. In the dfs function, check the following:\n  a. If the node has no outgoing edges (i.e., it's not in the graph), return whether the node is the destination node.\n  b. If the visited[node] is not 0, return whether it is equal to 2.\n  c. If neither of the above conditions are met, set visited[node] to 1 and iterate through the neighbors of the node in the graph. For each neighbor, recursively call the dfs function with the neighbor as the new node. If any of the recursive calls return false, return false.\n  d. After the loop is done, set visited[node] to 2 and return true.\n\n4. In the main function, call `dfs` with the source node and return the result.\n    "
    },
    {
        "id": 162,
        "title": "Missing Element in Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` which is sorted in **ascending order** and all of its elements are **unique** and given also an integer `k`, return the `kth` missing number starting from the leftmost number of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,7,9,10\\], k = 1\n**Output:** 5\n**Explanation:** The first missing number is 5.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,7,9,10\\], k = 3\n**Output:** 8\n**Explanation:** The missing numbers are \\[5,6,8,...\\], hence the third missing number is 8.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,4\\], k = 3\n**Output:** 6\n**Explanation:** The missing numbers are \\[3,5,6,7,...\\], hence the third missing number is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `1 <= nums[i] <= 107`\n*   `nums` is sorted in **ascending order,** and all the elements are **unique**.\n*   `1 <= k <= 108`\n\n**",
            "follow_up": "Follow up:** Can you find a logarithmic time complexity (i.e., `O(log(n))`) solution?"
        },
        "tag": [],
        "example": [
            {
                "input": "[4,7,9,10],1",
                "output": "5"
            },
            {
                "input": "[4,7,9,10],3",
                "output": "8"
            },
            {
                "input": "[1,2,4],3",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int findKthPositive(int[] nums, int k) {\n    int left = 0, right = nums.length;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] - mid - 1 < k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left + k;\n}\n```\n    \n    The algorithm starts by defining two pointers, `left` and `right`, initially set to 0 and the length of the `nums` array, respectively. It then enters a while loop where it continues iterating until the `left` pointer is no longer less than `right`. Inside the loop, we calculate the midpoint index between the two pointers.\n\nBased on the difference between the value stored at the midpoint index and the current midpoint index (subtracted by 1), we update our pointers. If the difference is less than `k`, then we set `left` to midpoint + 1, otherwise, we set `right` to midpoint. This is because we know the missing number should be either to the right or to the left of midpoint.\n\nThe loop terminates when we narrow down the search to one element. Finally, it returns the value of `left + k`, which gives us the kth missing number. This solution has a logarithmic time complexity, i.e., O(log n).\n    ",
        "python": "\n    ```python\ndef findKthPositive(nums, k):\n    left, right = 0, len(nums)\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] - mid - 1 < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left + k\n```\n    \n    The algorithm starts by defining two pointers, `left` and `right`, initially set to 0 and the length of the `nums` array, respectively. It then enters a while loop where it continues iterating until the `left` pointer is no longer less than `right`. Inside the loop, we calculate the midpoint index between the two pointers.\n\nBased on the difference between the value stored at the midpoint index and the current midpoint index (subtracted by 1), we update our pointers. If the difference is less than `k`, then we set `left` to midpoint + 1, otherwise, we set `right` to midpoint. This is because we know the missing number should be either to the right or to the left of midpoint.\n\nThe loop terminates when we narrow down the search to one element. Finally, it returns the value of `left + k`, which gives us the kth missing number. This solution has a logarithmic time complexity, i.e., O(log n).\n    ",
        "c++": "\n    ```cpp\nint findKthPositive(vector<int>& nums, int k) {\n    int left = 0, right = nums.size();\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] - mid - 1 < k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left + k;\n}\n```\n    \n    The algorithm starts by defining two pointers, `left` and `right`, initially set to 0 and the length of the `nums` array, respectively. It then enters a while loop where it continues iterating until the `left` pointer is no longer less than `right`. Inside the loop, we calculate the midpoint index between the two pointers.\n\nBased on the difference between the value stored at the midpoint index and the current midpoint index (subtracted by 1), we update our pointers. If the difference is less than `k`, then we set `left` to midpoint + 1, otherwise, we set `right` to midpoint. This is because we know the missing number should be either to the right or to the left of midpoint.\n\nThe loop terminates when we narrow down the search to one element. Finally, it returns the value of `left + k`, which gives us the kth missing number. This solution has a logarithmic time complexity, i.e., O(log n).\n    ",
        "js": "\n    ```javascript\nfunction findKthPositive(nums, k) {\n    let left = 0, right = nums.length;\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] - mid - 1 < k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left + k;\n}\n```\n\n    \n    The algorithm starts by defining two pointers, `left` and `right`, initially set to 0 and the length of the `nums` array, respectively. It then enters a while loop where it continues iterating until the `left` pointer is no longer less than `right`. Inside the loop, we calculate the midpoint index between the two pointers.\n\nBased on the difference between the value stored at the midpoint index and the current midpoint index (subtracted by 1), we update our pointers. If the difference is less than `k`, then we set `left` to midpoint + 1, otherwise, we set `right` to midpoint. This is because we know the missing number should be either to the right or to the left of midpoint.\n\nThe loop terminates when we narrow down the search to one element. Finally, it returns the value of `left + k`, which gives us the kth missing number. This solution has a logarithmic time complexity, i.e., O(log n).\n    "
    },
    {
        "id": 163,
        "title": "Longest Repeating Substring",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest repeating substrings_. If no repeating substring exists, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcd \"\n**Output:** 0\n**Explanation:** There is no repeating substring.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abbaba \"\n**Output:** 2\n**Explanation:** The longest repeating substrings are  \"ab \" and  \"ba \", each of which occurs twice.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aabcaabdaab \"\n**Output:** 3\n**Explanation:** The longest repeating substring is  \"aab \", which occurs `3` times."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcd\"",
                "output": "0"
            },
            {
                "input": "\"abbaba\"",
                "output": "2"
            },
            {
                "input": "\"aabcaabdaab\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findLongestRepeatingSubstring(String s) {\n    int n = s.length();\n    int maxSubstrLength = 0;\n    for (int len = 1; len <= n / 2; ++len) {\n        int maxRepeatCount = 0, repeatCount = 0;\n        for (int i = 0; i < n - len; ++i) {\n            if (s.substring(i, i + len).equals(s.substring(i + len, i + 2 * len))) {\n                repeatCount++;\n            } else {\n                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);\n                repeatCount = 0;\n            }\n        }\n        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);\n    }\n    return maxSubstrLength;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ",
        "python": "\n    ```python\ndef find_longest_repeating_substring(s: str) -> int:\n    n = len(s)\n    max_substr_length = 0\n    for length in range(1, n // 2 + 1):\n        max_repeat_count = repeat_count = 0\n        for i in range(n - length):\n            if s[i:i + length] == s[i + length:i + 2 * length]:\n                repeat_count += 1\n            else:\n                max_repeat_count = max(max_repeat_count, repeat_count)\n                repeat_count = 0\n        max_substr_length = max(max_substr_length, max_repeat_count * length)\n    return max_substr_length\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ",
        "c++": "\n    ```cpp\nint findLongestRepeatingSubstring(const std::string &s) {\n    int n = s.length();\n    int max_substr_length = 0;\n    for (int len = 1; len <= n/2; ++len) {\n        int max_repeat_count = 0, repeat_count = 0;\n        for (int i = 0; i < n - len; ++i) {\n            if (s.substr(i, len) == s.substr(i + len, len)) {\n                repeat_count++;\n            } else {\n                max_repeat_count = std::max(max_repeat_count, repeat_count);\n                repeat_count = 0;\n            }\n        }\n        max_substr_length = std::max(max_substr_length, max_repeat_count * len);\n    }\n    return max_substr_length;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    ",
        "js": "\n    ```javascript\nfunction findLongestRepeatingSubstring(s) {\n    let n = s.length;\n    let maxSubstrLength = 0;\n    for (let len = 1; len <= n / 2; ++len) {\n        let maxRepeatCount = 0, repeatCount = 0;\n        for (let i = 0; i < n - len; ++i) {\n            if (s.substring(i, i + len) === s.substring(i + len, i + 2 * len)) {\n                repeatCount++;\n            } else {\n                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);\n                repeatCount = 0;\n            }\n        }\n        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);\n    }\n    return maxSubstrLength;\n}\n```\n    \n    The algorithm iterates through each possible length of a substring (`len`). For each `len`, it checks if the current substring `s[i:i+len]` is equal to the next substring `s[i+len:i+2*len]`. If the substrings are equal, it increments `repeat_count` and updates `max_repeat_count` if needed. After iterating through all possible substring lengths, it returns the longest length of the repeated substrings as `max_substr_length`.\n    "
    },
    {
        "id": 164,
        "title": "Number of Valid Subarrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of non-empty **subarrays** with the leftmost element of the subarray not larger than other elements in the subarray_.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,4,2,5,3\\]\n**Output:** 11\n**Explanation:** There are 11 valid subarrays: \\[1\\],\\[4\\],\\[2\\],\\[5\\],\\[3\\],\\[1,4\\],\\[2,5\\],\\[1,4,2\\],\\[2,5,3\\],\\[1,4,2,5\\],\\[1,4,2,5,3\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 3\n**Explanation:** The 3 valid subarrays are: \\[3\\],\\[2\\],\\[1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,2,2\\]\n**Output:** 6\n**Explanation:** There are 6 valid subarrays: \\[2\\],\\[2\\],\\[2\\],\\[2,2\\],\\[2,2\\],\\[2,2,2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,4,2,5,3]",
                "output": "11"
            },
            {
                "input": "[3,2,1]",
                "output": "3"
            },
            {
                "input": "[2,2,2]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int maxScoreSightseeingPair(int[] values) {\n    int max_score = 0, max_score_left = values[0] + 0;\n    for (int j = 1; j < values.length; ++j) {\n        max_score = Math.max(max_score, max_score_left + values[j] - j);\n        max_score_left = Math.max(max_score_left, values[j] + j);\n    }\n    return max_score;\n}\n```\n    \n    We want to find the maximum score given by `values[i] + values[j] + i - j` for some `i < j`.\nWe can rewrite the formula as `values[i] + i + (values[j] - j)` for `i < j`.\nNow we can loop through the `values` array with an index `j`.\n\nFor each `j` we calculate the \"left\" score which is `values[i] + i` where `i` is in a range `[0, j-1]`.\n\nWe keep track of the maximum score before `j` (i.e. for `[0, j-1]`) in `max_score_left`.\nAlso, we keep track of the maximum score so far in `max_score`.\n\nFor each `j`, we can calculate the score for the current pair `(i, j)` with the formula `max_score_left + (values[j] - j)`. If this score is greater than our current `max_score`, then we update `max_score`.\n\nFinally, we return the `max_score` after iterating through the whole `values` array.\n    ",
        "python": "\n    ```python\ndef maxScoreSightseeingPair(values):\n    max_score = 0\n    max_score_left = values[0] + 0\n    for j in range(1, len(values)):\n        max_score = max(max_score, max_score_left + values[j] - j)\n        max_score_left = max(max_score_left, values[j] + j)\n    return max_score\n```\n    \n    We want to find the maximum score given by `values[i] + values[j] + i - j` for some `i < j`.\nWe can rewrite the formula as `values[i] + i + (values[j] - j)` for `i < j`.\nNow we can loop through the `values` array with an index `j`.\n\nFor each `j` we calculate the \"left\" score which is `values[i] + i` where `i` is in a range `[0, j-1]`.\n\nWe keep track of the maximum score before `j` (i.e. for `[0, j-1]`) in `max_score_left`.\nAlso, we keep track of the maximum score so far in `max_score`.\n\nFor each `j`, we can calculate the score for the current pair `(i, j)` with the formula `max_score_left + (values[j] - j)`. If this score is greater than our current `max_score`, then we update `max_score`.\n\nFinally, we return the `max_score` after iterating through the whole `values` array.\n    ",
        "c++": "\n    ```cpp\nint maxScoreSightseeingPair(vector<int>& values) {\n    int max_score = 0, max_score_left = values[0] + 0;\n    for (int j = 1; j < values.size(); ++j) {\n        max_score = max(max_score, max_score_left + values[j] - j);\n        max_score_left = max(max_score_left, values[j] + j);\n    }\n    return max_score;\n}\n```\n    \n    We want to find the maximum score given by `values[i] + values[j] + i - j` for some `i < j`.\nWe can rewrite the formula as `values[i] + i + (values[j] - j)` for `i < j`.\nNow we can loop through the `values` array with an index `j`.\n\nFor each `j` we calculate the \"left\" score which is `values[i] + i` where `i` is in a range `[0, j-1]`.\n\nWe keep track of the maximum score before `j` (i.e. for `[0, j-1]`) in `max_score_left`.\nAlso, we keep track of the maximum score so far in `max_score`.\n\nFor each `j`, we can calculate the score for the current pair `(i, j)` with the formula `max_score_left + (values[j] - j)`. If this score is greater than our current `max_score`, then we update `max_score`.\n\nFinally, we return the `max_score` after iterating through the whole `values` array.\n    ",
        "js": "\n    ```javascript\nfunction maxScoreSightseeingPair(values) {\n    let max_score = 0, max_score_left = values[0] + 0;\n    for (let j = 1; j < values.length; ++j) {\n        max_score = Math.max(max_score, max_score_left + values[j] - j);\n        max_score_left = Math.max(max_score_left, values[j] + j);\n    }\n    return max_score;\n}\n```\n    \n    We want to find the maximum score given by `values[i] + values[j] + i - j` for some `i < j`.\nWe can rewrite the formula as `values[i] + i + (values[j] - j)` for `i < j`.\nNow we can loop through the `values` array with an index `j`.\n\nFor each `j` we calculate the \"left\" score which is `values[i] + i` where `i` is in a range `[0, j-1]`.\n\nWe keep track of the maximum score before `j` (i.e. for `[0, j-1]`) in `max_score_left`.\nAlso, we keep track of the maximum score so far in `max_score`.\n\nFor each `j`, we can calculate the score for the current pair `(i, j)` with the formula `max_score_left + (values[j] - j)`. If this score is greater than our current `max_score`, then we update `max_score`.\n\nFinally, we return the `max_score` after iterating through the whole `values` array.\n    "
    },
    {
        "id": 165,
        "title": "Fixed Point",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of distinct integers `arr`, where `arr` is sorted in **ascending order**, return the smallest index `i` that satisfies `arr[i] == i`. If there is no such index, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[-10,-5,0,3,7\\]\n**Output:** 3\n**Explanation:** For the given array, `arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3`, thus the output is 3.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[0,2,5,8,17\\]\n**Output:** 0\n**Explanation:** `arr[0] = 0`, thus the output is 0.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[-10,-5,3,4,7,9\\]\n**Output:** -1\n**Explanation:** There is no such `i` that `arr[i] == i`, thus the output is -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length < 104`\n*   `-109 <= arr[i] <= 109`\n\n**",
            "follow_up": "Follow up:** The `O(n)` solution is very straightforward. Can we do better?"
        },
        "tag": [],
        "example": [
            {
                "input": "[-10,-5,0,3,7]",
                "output": "3"
            },
            {
                "input": "[0,2,5,8,17]",
                "output": "0"
            },
            {
                "input": "[-10,-5,3,4,7,9]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int fixedPoint(int[] arr) {\n    int left = 0, right = arr.length - 1;\n    while (left < right) {\n        int middle = left + (right - left) / 2;\n        if (arr[middle] < middle) {\n            left = middle + 1;\n        } else {\n            right = middle;\n        }\n    }\n    return arr[left] == left ? left : -1;\n}\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "python": "\n    ```python\ndef fixedPoint(arr: List[int]) -> int:\n    left, right = 0, len(arr) - 1\n    while left < right:\n        middle = left + (right - left) // 2\n        if arr[middle] < middle:\n            left = middle + 1\n        else:\n            right = middle\n    return left if arr[left] == left else -1\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "c++": "\n    ```cpp\nint fixedPoint(vector<int>& arr) {\n    int left = 0, right = arr.size() - 1;\n    while (left < right) {\n        int middle = left + (right - left) / 2;\n        if (arr[middle] < middle) {\n            left = middle + 1;\n        } else {\n            right = middle;\n        }\n    }\n    return arr[left] == left ? left : -1;\n}\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "js": "\n    ```javascript\nfunction fixedPoint(arr) {\n    let left = 0, right = arr.length - 1;\n    while (left < right) {\n        let middle = left + Math.floor((right - left) / 2);\n        if (arr[middle] < middle) {\n            left = middle + 1;\n        } else {\n            right = middle;\n        }\n    }\n    return arr[left] === left ? left : -1;\n}\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    "
    },
    {
        "id": 166,
        "title": "Index Pairs of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `text` and an array of strings `words`, return _an array of all index pairs_ `[i, j]` _so that the substring_ `text[i...j]` _is in `words`_.\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"thestoryofleetcodeandme \", words = \\[ \"story \", \"fleet \", \"leetcode \"\\]\n**Output:** \\[\\[3,7\\],\\[9,13\\],\\[10,17\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** text =  \"ababa \", words = \\[ \"aba \", \"ab \"\\]\n**Output:** \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Explanation:** Notice that matches can overlap, see  \"aba \" is found in \\[0,2\\] and \\[2,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 100`\n*   `1 <= words.length <= 20`\n*   `1 <= words[i].length <= 50`\n*   `text` and `words[i]` consist of lowercase English letters.\n*   All the strings of `words` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"thestoryofleetcodeandme\",[\"story\",\"fleet\",\"leetcode\"]",
                "output": "[[3,7],[9,13],[10,17]]"
            },
            {
                "input": "\"ababa\",[\"aba\",\"ab\"]",
                "output": "[[0,1],[0,2],[2,3],[2,4]]"
            }
        ],
        "java": "\n    ```java\npublic boolean hasAllCodesInRange(String s, int n) {\n    Set<String> substrings = new HashSet<>();\n    int length = Integer.toBinaryString(n).length();\n    for (int i = 0; i < s.length() - length + 1; ++i) {\n        substrings.add(s.substring(i, i + length));\n    }\n    return substrings.size() == n;\n}\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "python": "\n    ```python\ndef has_all_codes_in_range(s: str, n: int) -> bool:\n    substrings = set()\n    length = len(bin(n)) - 2\n    for i in range(len(s) - length + 1):\n        substrings.add(s[i:i + length])\n    return len(substrings) == n\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "c++": "\n    ```cpp\nbool hasAllCodesInRange(const std::string& s, int n) {\n    std::unordered_set<std::string> substrings;\n    int length = std::to_string(n).length();\n    for (int i = 0; i < s.length() - length + 1; ++i) {\n        substrings.insert(s.substr(i, length));\n    }\n    return substrings.size() == n;\n}\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "js": "\n    ```javascript\nfunction hasAllCodesInRange(s, n) {\n    let substrings = new Set();\n    let length = n.toString(2).length;\n    for (let i = 0; i < s.length - length + 1; ++i) {\n        substrings.add(s.substr(i, length));\n    }\n    return substrings.size == n;\n}\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    "
    },
    {
        "id": 167,
        "title": "Campus Bikes II",
        "difficulty": "Medium",
        "content": {
            "problem": "On a campus represented as a 2D grid, there are `n` workers and `m` bikes, with `n <= m`. Each worker and bike is a 2D coordinate on this grid.\n\nWe assign one unique bike to each worker so that the sum of the **Manhattan distances** between each worker and their assigned bike is minimized.\n\nReturn `the minimum possible sum of Manhattan distances between each worker and their assigned bike`.\n\nThe **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** workers = \\[\\[0,0\\],\\[2,1\\]\\], bikes = \\[\\[1,2\\],\\[3,3\\]\\]\n**Output:** 6\n**Explanation:** \nWe assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.\n\n",
                "**Example 2:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\]\\], bikes = \\[\\[1,0\\],\\[2,2\\],\\[2,1\\]\\]\n**Output:** 4\n**Explanation:** \nWe first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.\n\n",
                "**Example 3:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\],\\[3,0\\],\\[4,0\\]\\], bikes = \\[\\[0,999\\],\\[1,999\\],\\[2,999\\],\\[3,999\\],\\[4,999\\]\\]\n**Output:** 4995"
            ],
            "constraints": "**Constraints:**\n\n*   `n == workers.length`\n*   `m == bikes.length`\n*   `1 <= n <= m <= 10`\n*   `workers[i].length == 2`\n*   `bikes[i].length == 2`\n*   `0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000`\n*   All the workers and the bikes locations are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0],[2,1]],[[1,2],[3,3]]",
                "output": "6"
            },
            {
                "input": "[[0,0],[1,1],[2,0]],[[1,0],[2,2],[2,1]]",
                "output": "4"
            },
            {
                "input": "[[0,0],[1,0],[2,0],[3,0],[4,0]],[[0,999],[1,999],[2,999],[3,999],[4,999]]",
                "output": "4995"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int manhattanDistance(int[] worker, int[] bike) {\n        return Math.abs(worker[0] - bike[0]) + Math.abs(worker[1] - bike[1]);\n    }\n\n    private void dfs(int[][] workers, int[][] bikes, boolean[] used, int index, int dist, int[] minDist) {\n        if (index == workers.length) {\n            minDist[0] = Math.min(minDist[0], dist);\n            return;\n        }\n\n        if (dist >= minDist[0]) {\n            return;\n        }\n\n        for (int i = 0; i < bikes.length; i++) {\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            int curDist = manhattanDistance(workers[index], bikes[i]);\n            dfs(workers, bikes, used, index+1, dist + curDist, minDist);\n            used[i] = false;\n        }\n    }\n\n    public int assignBikes(int[][] workers, int[][] bikes) {\n        int[] minDist = new int[]{Integer.MAX_VALUE};\n        boolean[] used = new boolean[bikes.length];\n        dfs(workers, bikes, used, 0, 0, minDist);\n        return minDist[0];\n    }\n}\n```\n    \n    In order to solve the problem, we use a Depth First Search (DFS) algorithm to find all possible assignments of bikes to workers. We take the following steps:\n\n1. Create the helper function `manhattanDistance` to calculate the Manhattan distance between a worker and a bike.\n2. Implement the DFS function that takes the current worker index, the distance accumulated so far, and the minimum distance by reference. The DFS function will do the following:\n   a. Terminate if the current worker index is equal to the number of workers, indicating we have assigned bikes to all workers.\n   b. Terminate if the accumulated distance is greater than or equal to the current minimum distance.\n   c. Otherwise, iterate through all bikes and assign them to the current worker (if not already assigned to another worker).\n3. Call the DFS function starting from the first worker with accumulated distance equal to 0 and a reference to the minimum distance.\n4. Return the final minimum distance.\n\nThe time complexity of this solution is O(m^n), where m is the number of bikes, and n is the number of workers. Since the constraint is n <= 10, the solution will be efficient enough for our problem.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef manhattan_distance(worker: List[int], bike: List[int]) -> int:\n    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1])\n\ndef dfs(workers: List[List[int]], bikes: List[List[int]], used: List[bool], index: int, dist: int, min_dist: List[int]) -> None:\n    if index == len(workers):\n        min_dist[0] = min(min_dist[0], dist)\n        return\n\n    if dist >= min_dist[0]:\n        return\n\n    for i in range(len(bikes)):\n        if used[i]:\n            continue\n        used[i] = True\n        cur_dist = manhattan_distance(workers[index], bikes[i])\n        dfs(workers, bikes, used, index + 1, dist + cur_dist, min_dist)\n        used[i] = False\n\ndef assign_bikes(workers: List[List[int]], bikes: List[List[int]]) -> int:\n    min_dist = [float('inf')]\n    used = [False] * len(bikes)\n    dfs(workers, bikes, used, 0, 0, min_dist)\n    return min_dist[0]\n```\n    \n    In order to solve the problem, we use a Depth First Search (DFS) algorithm to find all possible assignments of bikes to workers. We take the following steps:\n\n1. Create the helper function `manhattanDistance` to calculate the Manhattan distance between a worker and a bike.\n2. Implement the DFS function that takes the current worker index, the distance accumulated so far, and the minimum distance by reference. The DFS function will do the following:\n   a. Terminate if the current worker index is equal to the number of workers, indicating we have assigned bikes to all workers.\n   b. Terminate if the accumulated distance is greater than or equal to the current minimum distance.\n   c. Otherwise, iterate through all bikes and assign them to the current worker (if not already assigned to another worker).\n3. Call the DFS function starting from the first worker with accumulated distance equal to 0 and a reference to the minimum distance.\n4. Return the final minimum distance.\n\nThe time complexity of this solution is O(m^n), where m is the number of bikes, and n is the number of workers. Since the constraint is n <= 10, the solution will be efficient enough for our problem.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<climits>\nusing namespace std;\n\nint manhattanDistance(vector<int>& worker, vector<int>& bike) {\n    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1]);\n}\n\nvoid dfs(vector<vector<int>>& workers, vector<vector<int>>& bikes, vector<bool>& used, int index, int dist, int& minDist) {\n    if (index == workers.size()) {\n        minDist = min(minDist, dist);\n        return;\n    }\n    \n    if (dist >= minDist) {\n        return;\n    }\n    \n    for (int i = 0; i < bikes.size(); i++) {\n        if (used[i]) {\n            continue;\n        }\n        used[i] = true;\n        int curDist = manhattanDistance(workers[index], bikes[i]);\n        dfs(workers, bikes, used, index+1, dist + curDist, minDist);\n        used[i] = false;\n    }\n}\n\nint assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {\n    int minDist = INT_MAX;\n    vector<bool> used(bikes.size(), false);\n    dfs(workers, bikes, used, 0, 0, minDist);\n    return minDist;\n}\n```\n    \n    In order to solve the problem, we use a Depth First Search (DFS) algorithm to find all possible assignments of bikes to workers. We take the following steps:\n\n1. Create the helper function `manhattanDistance` to calculate the Manhattan distance between a worker and a bike.\n2. Implement the DFS function that takes the current worker index, the distance accumulated so far, and the minimum distance by reference. The DFS function will do the following:\n   a. Terminate if the current worker index is equal to the number of workers, indicating we have assigned bikes to all workers.\n   b. Terminate if the accumulated distance is greater than or equal to the current minimum distance.\n   c. Otherwise, iterate through all bikes and assign them to the current worker (if not already assigned to another worker).\n3. Call the DFS function starting from the first worker with accumulated distance equal to 0 and a reference to the minimum distance.\n4. Return the final minimum distance.\n\nThe time complexity of this solution is O(m^n), where m is the number of bikes, and n is the number of workers. Since the constraint is n <= 10, the solution will be efficient enough for our problem.\n    ",
        "js": "\n    ```javascript\nfunction manhattanDistance(worker, bike) {\n    return Math.abs(worker[0] - bike[0]) + Math.abs(worker[1] - bike[1]);\n}\n\nfunction dfs(workers, bikes, used, index, dist, minDist) {\n    if (index === workers.length) {\n        minDist[0] = Math.min(minDist[0], dist);\n        return;\n    }\n\n    if (dist >= minDist[0]) {\n        return;\n    }\n\n    for (let i = 0; i < bikes.length; i++) {\n        if (used[i]) {\n            continue;\n        }\n        used[i] = true;\n        let curDist = manhattanDistance(workers[index], bikes[i]);\n        dfs(workers, bikes, used, index + 1, dist + curDist, minDist);\n        used[i] = false;\n    }\n}\n\nfunction assignBikes(workers, bikes) {\n    let minDist = [Infinity];\n    let used = new Array(bikes.length).fill(false);\n    dfs(workers, bikes, used, 0, 0, minDist);\n    return minDist[0];\n}\n```\n    \n    In order to solve the problem, we use a Depth First Search (DFS) algorithm to find all possible assignments of bikes to workers. We take the following steps:\n\n1. Create the helper function `manhattanDistance` to calculate the Manhattan distance between a worker and a bike.\n2. Implement the DFS function that takes the current worker index, the distance accumulated so far, and the minimum distance by reference. The DFS function will do the following:\n   a. Terminate if the current worker index is equal to the number of workers, indicating we have assigned bikes to all workers.\n   b. Terminate if the accumulated distance is greater than or equal to the current minimum distance.\n   c. Otherwise, iterate through all bikes and assign them to the current worker (if not already assigned to another worker).\n3. Call the DFS function starting from the first worker with accumulated distance equal to 0 and a reference to the minimum distance.\n4. Return the final minimum distance.\n\nThe time complexity of this solution is O(m^n), where m is the number of bikes, and n is the number of workers. Since the constraint is n <= 10, the solution will be efficient enough for our problem.\n    "
    },
    {
        "id": 168,
        "title": "Digit Count in Range",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a single-digit integer `d` and two integers `low` and `high`, return _the number of times that_ `d` _occurs as a digit in all integers in the inclusive range_ `[low, high]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** d = 1, low = 1, high = 13\n**Output:** 6\n**Explanation:** The digit d = 1 occurs 6 times in 1, 10, 11, 12, 13.\nNote that the digit d = 1 occurs twice in the number 11.\n\n",
                "**Example 2:**\n\n**Input:** d = 3, low = 100, high = 250\n**Output:** 35\n**Explanation:** The digit d = 3 occurs 35 times in 103,113,123,130,131,...,238,239,243."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= d <= 9`\n*   `1 <= low <= high <= 2 * 108`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1,1,13",
                "output": "6"
            },
            {
                "input": "3,100,250",
                "output": "35"
            }
        ],
        "java": "\n    ```java\npublic int countDigit(int d, int low, int high) {\n    int count = 0;\n    for (int i = low; i <= high; i++) {\n        int num = i;\n        while (num > 0) {\n            if (num % 10 == d) {\n                count++;\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    ",
        "python": "\n    ```python\ndef count_digit(d, low, high):\n    count = 0\n    for i in range(low, high + 1):\n        num = i\n        while num > 0:\n            if num % 10 == d:\n                count += 1\n            num //= 10\n    return count\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    ",
        "c++": "\n    ```cpp\nint countDigit(int d, int low, int high) {\n    int count = 0;\n    for (int i = low; i <= high; ++i) {\n        int num = i;\n        while (num) {\n            if (num % 10 == d) {\n                count++;\n            }\n            num /= 10;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    ",
        "js": "\n    ```javascript\nfunction countDigit(d, low, high) {\n    let count = 0;\n    for (let i = low; i <= high; i++) {\n        let num = i;\n        while (num > 0) {\n            if (num % 10 === d) {\n                count++;\n            }\n            num = Math.floor(num / 10);\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all integers between `low` and `high` (inclusive). For each integer, it iterates through each digit by dividing it by 10 each time and taking the remainder (mod 10) to check if it matches the given digit `d`. If a match is found, it increments the `count` variable. Finally, it returns the total count.\n    "
    },
    {
        "id": 169,
        "title": "Sum of Digits in the Minimum Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `0` _if the sum of the digits of the minimum integer in_ `nums` _is odd, or_ `1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\]\n**Output:** 0\n**Explanation:** The minimal element is 1, and the sum of those digits is 1 which is odd, so the answer is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[99,77,33,66,55\\]\n**Output:** 1\n**Explanation:** The minimal element is 33, and the sum of those digits is 3 + 3 = 6 which is even, so the answer is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[34,23,1,24,75,33,54,8]",
                "output": "0"
            },
            {
                "input": "[99,77,33,66,55]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int sumOfDigits(int[] nums) {\n    int minVal = Arrays.stream(nums).min().getAsInt();\n    int digitSum = 0;\n    while (minVal > 0) {\n        digitSum += minVal % 10;\n        minVal /= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "python": "\n    ```python\ndef sum_of_digits(nums):\n    min_val = min(nums)\n    digit_sum = sum(int(digit) for digit in str(min_val))\n    return 1 if digit_sum % 2 == 0 else 0\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "c++": "\n    ```cpp\nint sumOfDigits(vector<int>& nums) {\n    int minVal = *min_element(nums.begin(), nums.end());\n    int digitSum = 0;\n    while (minVal > 0) {\n        digitSum += minVal % 10;\n        minVal /= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "js": "\n    ```javascript\nfunction sumOfDigits(nums) {\n    const minVal = Math.min(...nums);\n    let digitSum = 0;\n    let temp = minVal;\n    while (temp > 0) {\n        digitSum += temp % 10;\n        temp = Math.floor(temp / 10);\n    }\n    return digitSum % 2 === 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    "
    },
    {
        "id": 170,
        "title": "High Five",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a list of the scores of different students, `items`, where `items[i] = [IDi, scorei]` represents one score from a student with `IDi`, calculate each student's **top five average**.\n\nReturn _the answer as an array of pairs_ `result`_, where_ `result[j] = [IDj, topFiveAveragej]` _represents the student with_ `IDj` _and their **top five average**. Sort_ `result` _by_ `IDj` _in **increasing order**._\n\nA student's **top five average** is calculated by taking the sum of their top five scores and dividing it by `5` using **integer division**.",
            "examples": [
                "**Example 1:**\n\n**Input:** items = \\[\\[1,91\\],\\[1,92\\],\\[2,93\\],\\[2,97\\],\\[1,60\\],\\[2,77\\],\\[1,65\\],\\[1,87\\],\\[1,100\\],\\[2,100\\],\\[2,76\\]\\]\n**Output:** \\[\\[1,87\\],\\[2,88\\]\\]\n**Explanation:** \nThe student with ID = 1 got scores 91, 92, 60, 65, 87, and 100. Their top five average is (100 + 92 + 91 + 87 + 65) / 5 = 87.\nThe student with ID = 2 got scores 93, 97, 77, 100, and 76. Their top five average is (100 + 97 + 93 + 77 + 76) / 5 = 88.6, but with integer division their average converts to 88.\n\n",
                "**Example 2:**\n\n**Input:** items = \\[\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\]\\]\n**Output:** \\[\\[1,100\\],\\[7,100\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= items.length <= 1000`\n*   `items[i].length == 2`\n*   `1 <= IDi <= 1000`\n*   `0 <= scorei <= 100`\n*   For each `IDi`, there will be **at least** five scores.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]",
                "output": "[[1,87],[2,88]]"
            },
            {
                "input": "[[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100]]",
                "output": "[[1,100],[7,100]]"
            }
        ],
        "java": "\n    ```java\nboolean aliceWin(int n) {\n    return n % 2 == 0;\n}\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "python": "\n    ```python\ndef alice_win(n):\n    return n % 2 == 0\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "c++": "\n    ```cpp\nbool aliceWin(int n) {\n    return n % 2 == 0;\n}\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "js": "\n    ```javascript\nfunction aliceWin(n) {\n    return n % 2 === 0;\n}\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    "
    },
    {
        "id": 171,
        "title": "Brace Expansion",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s` representing a list of words. Each letter in the word has one or more options.\n\n*   If there is one option, the letter is represented as is.\n*   If there is more than one option, then curly braces delimit the options. For example, `\"{a,b,c} \"` represents options `[ \"a \", \"b \", \"c \"]`.\n\nFor example, if `s = \"a{b,c} \"`, the first character is always `'a'`, but the second character can be `'b'` or `'c'`. The original list is `[ \"ab \", \"ac \"]`.\n\nReturn all words that can be formed in this manner, **sorted** in lexicographical order.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"{a,b}c{d,e}f\"\n**Output:** \\[\"acdf\",\"acef\",\"bcdf\",\"bcef\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\"\n**Output:** \\[\"abcd\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 50`\n*   `s` consists of curly brackets `'{}'`, commas `','`, and lowercase English letters.\n*   `s` is guaranteed to be a valid input.\n*   There are no nested curly brackets.\n*   All characters inside a pair of consecutive opening and ending curly brackets are different.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"{a,",
                "output": "[\"acdf\",\"acef\",\"bcdf\",\"bcef\"]"
            },
            {
                "input": "\"abcd\"",
                "output": "[\"abcd\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int longestArithSeqLength(int[] nums) {\n    int n = nums.length;\n    int longest = 0;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n    \n    for (int i = 0; i < n; i++) {\n        dp[i] = new HashMap<Integer, Integer>();\n        for (int j = 0; j < i; j++) {\n            int diff = nums[i] - nums[j];\n            dp[i].put(diff, dp[j].containsKey(diff) ? dp[j].get(diff) + 1 : 2);\n            longest = Math.max(longest, dp[i].get(diff));\n        }\n    }\n    \n    return longest;\n}\n```\n    \n    The function uses dynamic programming to solve the problem. A `dp` array of hashmaps/dictionaries is created to store intermediate lengths of arithmetic subsequences at each index. For each pair of elements in the array, calculate their difference, and use that difference as a key in each corresponding `dp` hashmap/dictionary. This allows us to keep track of the length of the longest arithmetic subsequence ending at index `i` with that difference.\n\nIf we find a difference that already exists in the hashmap/dictionary at the previous index, it means that there is an arithmetic subsequence with that difference that has been seen before. In this case, the length of the arithmetic subsequence is incremented by 1. If not, a new arithmetic subsequence has been found with just two elements.\n\nFinally, we keep updating the `longest` variable to store the maximum length seen so far, so that it holds the length of the longest arithmetic subsequence at the end of the loop.\n    ",
        "python": "\n    ```python\ndef longestArithSeqLength(nums):\n    n = len(nums)\n    longest = 0\n    dp = [{} for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            longest = max(longest, dp[i][diff])\n    \n    return longest\n```\n    \n    The function uses dynamic programming to solve the problem. A `dp` array of hashmaps/dictionaries is created to store intermediate lengths of arithmetic subsequences at each index. For each pair of elements in the array, calculate their difference, and use that difference as a key in each corresponding `dp` hashmap/dictionary. This allows us to keep track of the length of the longest arithmetic subsequence ending at index `i` with that difference.\n\nIf we find a difference that already exists in the hashmap/dictionary at the previous index, it means that there is an arithmetic subsequence with that difference that has been seen before. In this case, the length of the arithmetic subsequence is incremented by 1. If not, a new arithmetic subsequence has been found with just two elements.\n\nFinally, we keep updating the `longest` variable to store the maximum length seen so far, so that it holds the length of the longest arithmetic subsequence at the end of the loop.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint longestArithSeqLength(vector<int>& nums) {\n    int n = nums.size();\n    int longest = 0;\n    vector<unordered_map<int, int>> dp(n);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            int diff = nums[i] - nums[j];\n            dp[i][diff] = dp[j].count(diff) ? dp[j][diff] + 1 : 2;\n            longest = max(longest, dp[i][diff]);\n        }\n    }\n    \n    return longest;\n}\n```\n    \n    The function uses dynamic programming to solve the problem. A `dp` array of hashmaps/dictionaries is created to store intermediate lengths of arithmetic subsequences at each index. For each pair of elements in the array, calculate their difference, and use that difference as a key in each corresponding `dp` hashmap/dictionary. This allows us to keep track of the length of the longest arithmetic subsequence ending at index `i` with that difference.\n\nIf we find a difference that already exists in the hashmap/dictionary at the previous index, it means that there is an arithmetic subsequence with that difference that has been seen before. In this case, the length of the arithmetic subsequence is incremented by 1. If not, a new arithmetic subsequence has been found with just two elements.\n\nFinally, we keep updating the `longest` variable to store the maximum length seen so far, so that it holds the length of the longest arithmetic subsequence at the end of the loop.\n    ",
        "js": "\n    ```javascript\nfunction longestArithSeqLength(nums) {\n    const n = nums.length;\n    let longest = 0;\n    const dp = Array.from({ length: n }, () => ({}));\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            const diff = nums[i] - nums[j];\n            dp[i][diff] = (dp[j][diff] || 1) + 1;\n            longest = Math.max(longest, dp[i][diff]);\n        }\n    }\n    \n    return longest;\n}\n```\n    \n    The function uses dynamic programming to solve the problem. A `dp` array of hashmaps/dictionaries is created to store intermediate lengths of arithmetic subsequences at each index. For each pair of elements in the array, calculate their difference, and use that difference as a key in each corresponding `dp` hashmap/dictionary. This allows us to keep track of the length of the longest arithmetic subsequence ending at index `i` with that difference.\n\nIf we find a difference that already exists in the hashmap/dictionary at the previous index, it means that there is an arithmetic subsequence with that difference that has been seen before. In this case, the length of the arithmetic subsequence is incremented by 1. If not, a new arithmetic subsequence has been found with just two elements.\n\nFinally, we keep updating the `longest` variable to store the maximum length seen so far, so that it holds the length of the longest arithmetic subsequence at the end of the loop.\n    "
    },
    {
        "id": 172,
        "title": "Confusing Number II",
        "difficulty": "Hard",
        "content": {
            "problem": "A **confusing number** is a number that when rotated `180` degrees becomes a different number with **each digit valid**.\n\nWe can rotate digits of a number by `180` degrees to form new digits.\n\n*   When `0`, `1`, `6`, `8`, and `9` are rotated `180` degrees, they become `0`, `1`, `9`, `8`, and `6` respectively.\n*   When `2`, `3`, `4`, `5`, and `7` are rotated `180` degrees, they become **invalid**.\n\nNote that after rotating a number, we can ignore leading zeros.\n\n*   For example, after rotating `8000`, we have `0008` which is considered as just `8`.\n\nGiven an integer `n`, return _the number of **confusing numbers** in the inclusive range_ `[1, n]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 20\n**Output:** 6\n**Explanation:** The confusing numbers are \\[6,9,10,16,18,19\\].\n6 converts to 9.\n9 converts to 6.\n10 converts to 01 which is just 1.\n16 converts to 91.\n18 converts to 81.\n19 converts to 61.\n\n",
                "**Example 2:**\n\n**Input:** n = 100\n**Output:** 19\n**Explanation:** The confusing numbers are \\[6,9,10,16,18,19,60,61,66,68,80,81,86,89,90,91,98,99,100\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "20",
                "output": "6"
            },
            {
                "input": "100",
                "output": "19"
            }
        ],
        "java": "\n    ```java\npublic int confusingNumberII(int n) {\n    return helper(n, 0, new int[]{0, 1, 6, 8, 9});\n}\n\nprivate int helper(int n, int current, int[] validNums) {\n    int count = 0;\n    for (int num : validNums) {\n        long next = current * 10 + num;\n        if (next > n) break;\n        if (current == 0 && next == 0) continue;\n        if (next != rotate(next)) count++;\n        count += helper(n, (int) next, validNums);\n    }\n    return count;\n}\n\nprivate int rotate(int num) {\n    int rotated = 0;\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit == 2 || digit == 3 || digit == 4 || digit == 5 || digit == 7)\n            return -1;\n        if (digit == 6) digit = 9;\n        else if (digit == 9) digit = 6;\n        rotated = rotated * 10 + digit;\n        num /= 10;\n    }\n    return rotated;\n}\n```\n    \n    This problem can be solve using a recursive approach. We generate confusing numbers one digit at a time and validate if it's a valid and different number when rotated. In the helper function, we loop through the valid rotations, generate the next number by appending a valid rotation digit, and track count if the generated number is valid and not equal to its rotated version. For better efficiency, we input a memo that tracks the valid digits and their corresponding rotations.\nThe algorithm works as follows:\n\n1. Initialize count to 0.\n2. Generate the number one digit at a time using depth-first search (DFS).\n3. Check if the next number (current * 10 + num) is within the boundaries.\n4. If the next number is valid and different than its rotated version, increase count.\n5. Recursively call the helper function on the next number.\n6. Return the count.\n\nTo rotate a given number, we loop through its digits from right to left, and append their rotations. If the digit cannot be rotated, we return the original number to avoid increasing the count of confusing numbers.\n    ",
        "python": "\n    ```python\ndef confusingNumberII(n):\n    def helper(current):\n        nonlocal count, validNums\n        for num in validNums:\n            next_num = current * 10 + num\n            if next_num > n:\n                break\n            if current != 0 or next_num != 0:\n                if next_num != rotate(next_num):\n                    count += 1\n                count = helper(next_num)\n        return count\n\n    def rotate(num):\n        rotated = 0\n        original = num\n        while num > 0:\n            digit = num % 10\n            if digit in (2, 3, 4, 5, 7):\n                return original\n            revd = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}\n            rotated = rotated * 10 + revd[digit]\n            num //= 10\n        return rotated\n\n    count = 0\n    validNums = [0, 1, 6, 8, 9]\n    return helper(0)\n```\n    \n    This problem can be solve using a recursive approach. We generate confusing numbers one digit at a time and validate if it's a valid and different number when rotated. In the helper function, we loop through the valid rotations, generate the next number by appending a valid rotation digit, and track count if the generated number is valid and not equal to its rotated version. For better efficiency, we input a memo that tracks the valid digits and their corresponding rotations.\nThe algorithm works as follows:\n\n1. Initialize count to 0.\n2. Generate the number one digit at a time using depth-first search (DFS).\n3. Check if the next number (current * 10 + num) is within the boundaries.\n4. If the next number is valid and different than its rotated version, increase count.\n5. Recursively call the helper function on the next number.\n6. Return the count.\n\nTo rotate a given number, we loop through its digits from right to left, and append their rotations. If the digit cannot be rotated, we return the original number to avoid increasing the count of confusing numbers.\n    ",
        "c++": "\n    ```cpp\nint findConfusingNumbers(int num, int& n, unordered_map<int, int>& mp) {\n    if (num > n) return 0;\n    int rotated = 0, src = num, newNum;\n    while (src > 0) {\n        rotated = rotated * 10 + mp[src % 10];\n        src /= 10;\n    }\n    return (num != rotated) + findConfusingNumbers(num * 10 + 6, n, mp)\n           + findConfusingNumbers(num * 10 + 9, n, mp)\n           + findConfusingNumbers(num * 10 + 0, n, mp)\n           + findConfusingNumbers(num * 10 + 1, n, mp)\n           + findConfusingNumbers(num * 10 + 8, n, mp);\n}\n\nint confusingNumberII(int n) {\n    unordered_map<int, int> mp = {{0,0},{1,1},{6,9},{8,8},{9,6}};\n    return findConfusingNumbers(6, n, mp) + findConfusingNumbers(9, n, mp) +\n           findConfusingNumbers(1, n, mp) + findConfusingNumbers(8, n, mp) + findConfusingNumbers(0, n, mp);\n}\n```\n    \n    This problem can be solve using a recursive approach. We generate confusing numbers one digit at a time and validate if it's a valid and different number when rotated. In the helper function, we loop through the valid rotations, generate the next number by appending a valid rotation digit, and track count if the generated number is valid and not equal to its rotated version. For better efficiency, we input a memo that tracks the valid digits and their corresponding rotations.\nThe algorithm works as follows:\n\n1. Initialize count to 0.\n2. Generate the number one digit at a time using depth-first search (DFS).\n3. Check if the next number (current * 10 + num) is within the boundaries.\n4. If the next number is valid and different than its rotated version, increase count.\n5. Recursively call the helper function on the next number.\n6. Return the count.\n\nTo rotate a given number, we loop through its digits from right to left, and append their rotations. If the digit cannot be rotated, we return the original number to avoid increasing the count of confusing numbers.\n    ",
        "js": "\n    ```javascript\nvar confusingNumberII = function(n) {\n    const validNums = [0, 1, 6, 8, 9];\n\n    function helper(current) {\n        let count = 0;\n        for (const num of validNums) {\n            const nextNum = current * 10 + num;\n            if (nextNum > n) break;\n            if (current !== 0 || nextNum !== 0) {\n                if (nextNum !== rotate(nextNum)) count += 1;\n                count += helper(nextNum);\n            }\n        }\n        return count;\n    }\n\n    function rotate(num) {\n        let rotated = 0;\n        while (num > 0) {\n            const digit = num % 10;\n            if ([2, 3, 4, 5, 7].includes(digit)) return -1;\n            rotated = rotated * 10 + (digit === 6 ? 9 : (digit === 9 ? 6 : digit));\n            num = Math.floor(num / 10);\n        }\n        return rotated;\n    }\n\n    return helper(0);\n};\n```\n    \n    This problem can be solve using a recursive approach. We generate confusing numbers one digit at a time and validate if it's a valid and different number when rotated. In the helper function, we loop through the valid rotations, generate the next number by appending a valid rotation digit, and track count if the generated number is valid and not equal to its rotated version. For better efficiency, we input a memo that tracks the valid digits and their corresponding rotations.\nThe algorithm works as follows:\n\n1. Initialize count to 0.\n2. Generate the number one digit at a time using depth-first search (DFS).\n3. Check if the next number (current * 10 + num) is within the boundaries.\n4. If the next number is valid and different than its rotated version, increase count.\n5. Recursively call the helper function on the next number.\n6. Return the count.\n\nTo rotate a given number, we loop through its digits from right to left, and append their rotations. If the digit cannot be rotated, we return the original number to avoid increasing the count of confusing numbers.\n    "
    },
    {
        "id": 173,
        "title": "Shortest Common Supersequence ",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `str1` and `str2`, return _the shortest string that has both_ `str1` _and_ `str2` _as **subsequences**_. If there are multiple valid strings, return **any** of them.\n\nA string `s` is a **subsequence** of string `t` if deleting some number of characters from `t` (possibly `0`) results in the string `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** str1 =  \"abac \", str2 =  \"cab \"\n**Output:**  \"cabac \"\n**Explanation:** \nstr1 =  \"abac \" is a subsequence of  \"cabac \" because we can delete the first  \"c \".\nstr2 =  \"cab \" is a subsequence of  \"cabac \" because we can delete the last  \"ac \".\nThe answer provided is the shortest such string that satisfies these properties.\n\n",
                "**Example 2:**\n\n**Input:** str1 =  \"aaaaaaaa \", str2 =  \"aaaaaaaa \"\n**Output:**  \"aaaaaaaa \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= str1.length, str2.length <= 1000`\n*   `str1` and `str2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abac\",\"cab\"",
                "output": "\"cabac\""
            },
            {
                "input": "\"aaaaaaaa\",\"aaaaaaaa\"",
                "output": "\"aaaaaaaa\""
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass Result {\n    int min;\n    int max;\n}\n\nint dfs(TreeNode node, Result result) {\n    if (node == null) return 0;\n    Result leftResult = new Result();\n    Result rightResult = new Result();\n    int leftDiff = dfs(node.left, leftResult);\n    int rightDiff = dfs(node.right, rightResult);\n    result.min = Math.min(node.val, Math.min(leftResult.min, rightResult.min));\n    result.max = Math.max(node.val, Math.max(leftResult.max, rightResult.max));\n    return Math.max(Math.max(leftDiff, rightDiff), Math.max(Math.abs(node.val - leftResult.min), Math.abs(node.val - rightResult.max)));\n}\n\nint maxAncestorDiff(TreeNode root) {\n    Result result = new Result();\n    return dfs(root, result);\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef dfs(node):\n    if not node:\n        return 0, float('inf'), float('-inf')\n    left_diff, left_min, left_max = dfs(node.left)\n    right_diff, right_min, right_max = dfs(node.right)\n    mn = min(node.val, left_min, right_min)\n    mx = max(node.val, left_max, right_max)\n    return max(max(left_diff, right_diff), max(abs(node.val - left_min), abs(node.val - right_max))), mn, mx\n\ndef maxAncestorDiff(root):\n    diff, _, _ = dfs(root)\n    return diff\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int _val) : val(_val), left(nullptr), right(nullptr) {}\n};\n\nint dfs(TreeNode* node, int& mn, int& mx) {\n    if (!node) return 0;\n    int left_min = node->val, right_min = node->val;\n    int left_max = node->val, right_max = node->val;\n    int left_diff = dfs(node->left, left_min, left_max);\n    int right_diff = dfs(node->right, right_min, right_max);\n    mn = min(node->val, min(left_min, right_min));\n    mx = max(node->val, max(left_max, right_max));\n    return max(max(left_diff, right_diff), max(abs(node->val - left_min), abs(node->val - right_max)));\n}\nint maxAncestorDiff(TreeNode* root) {\n    int mn = root->val, mx = root->val;\n    return dfs(root, mn, mx);\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction dfs(node) {\n    if (!node) return [0, Infinity, -Infinity];\n    const [leftDiff, leftMin, leftMax] = dfs(node.left);\n    const [rightDiff, rightMin, rightMax] = dfs(node.right);\n    const mn = Math.min(node.val, leftMin, rightMin);\n    const mx = Math.max(node.val, leftMax, rightMax);\n    return [Math.max(Math.max(leftDiff, rightDiff), Math.max(Math.abs(node.val - leftMin), Math.abs(node.val - rightMax))), mn, mx];\n}\n\nfunction maxAncestorDiff(root) {\n    const [diff, _, _] = dfs(root);\n    return diff;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to traverse the input binary tree. The base case is reached when the root node is `null`, in which case the maximum value and minimum value are set to positive and negative infinity, respectively. While traversing the nodes, the algorithm maintains the maximum and minimum values of each subtree, as well as the maximum absolute difference.\n\nAt each node of the tree, the algorithm compares the difference in the node's value to the minimum and maximum values of both the left and right subtrees. This way, the potential new maximum difference is computed by comparing the current maximum difference to the absolute differences $(node.val - leftMin)$ and $(node.val - rightMax)$. The final maximum absolute difference is returned after the entire tree has been traversed. \n    "
    },
    {
        "id": 174,
        "title": "Two Sum Less Than K",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\], k = 60\n**Output:** 58\n**Explanation:** We can use 34 and 24 to sum 58 which is less than 60.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,20,30\\], k = 15\n**Output:** -1\n**Explanation:** In this case it is not possible to get a pair sum less that 15."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 1000`\n*   `1 <= k <= 2000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[34,23,1,24,75,33,54,8],60",
                "output": "58"
            },
            {
                "input": "[10,20,30],15",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int maxSumUnderK(int[] nums, int k) {\n    int maxSum = -1;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            int sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "python": "\n    ```python\ndef max_sum_under_k(nums, k):\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "c++": "\n    ```cpp\nint maxSumUnderK(vector<int>& nums, int k) {\n    int maxSum = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            int sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "js": "\n    ```javascript\nfunction maxSumUnderK(nums, k) {\n    let maxSum = -1;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            let sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    "
    },
    {
        "id": 175,
        "title": "Find K-Length Substrings With No Repeated Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return _the number of substrings in_ `s` _of length_ `k` _with no repeated characters_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"havefunonleetcode \", k = 5\n**Output:** 6\n**Explanation:** There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"home \", k = 5\n**Output:** 0\n**Explanation:** Notice k can be larger than the length of s. In this case, it is not possible to find any substring."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n*   `1 <= k <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"havefunonleetcode\",5",
                "output": "6"
            },
            {
                "input": "\"home\",5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numKLenSubstrNoRepeats(String s, int k) {\n    int n = s.length();\n    if (k > n) return 0;\n    \n    int result = 0;\n    HashSet<Character> window = new HashSet<>();\n    \n    for (int i = 0, j = 0; j < n; ++j) {\n        while (window.contains(s.charAt(j))) {\n            window.remove(s.charAt(i++));\n        }\n        window.add(s.charAt(j));\n        if (j - i + 1 == k) {\n            ++result;\n            window.remove(s.charAt(i++));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "python": "\n    ```python\ndef num_k_len_substr_no_repeats(s: str, k: int) -> int:\n    n = len(s)\n    if k > n:\n        return 0\n\n    result = 0\n    window = set()\n\n    i = 0\n    for j in range(n):\n        while s[j] in window:\n            window.remove(s[i])\n            i += 1\n        window.add(s[j])\n        if j - i + 1 == k:\n            result += 1\n            window.remove(s[i])\n            i += 1\n\n    return result\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "c++": "\n    ```cpp\nint numKLenSubstrNoRepeats(string s, int k) {\n    int n = s.length();\n    if (k > n) return 0;\n    \n    int result = 0;\n    unordered_set<char> window;\n    \n    for (int i = 0, j = 0; j < n; ++j) {\n        while (window.find(s[j]) != window.end()) {\n            window.erase(s[i++]);\n        }\n        window.insert(s[j]);\n        if (j - i + 1 == k) {\n            ++result;\n            window.erase(s[i++]);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    ",
        "js": "\n    ```javascript\nfunction numKLenSubstrNoRepeats(s, k) {\n    const n = s.length;\n    if (k > n) return 0;\n    \n    let result = 0;\n    const window = new Set();\n    \n    for (let i = 0, j = 0; j < n; ++j) {\n        while (window.has(s[j])) {\n            window.delete(s[i++]);\n        }\n        window.add(s[j]);\n        if (j - i + 1 === k) {\n            ++result;\n            window.delete(s[i++]);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm uses a sliding window approach. Initialize an empty set `window` to store unique characters in a substring. We use two pointers `i` and `j` for each end of the window. The outer loop iterates `j` through the string. If the current character `s[j]` is in `window`, remove the first element of the window by deleting `s[i++]`. Then, insert `s[j]` into the `window`.\nIf the current window size is equal to k (i.e., `j - i + 1 == k`), increment the count of unique substrings `result` by 1, and remove the first element of the window by deleting `s[i++]`.\n\nOnce the outer loop finishes, return the result variable, which contains the count of unique length-k substrings.\n    "
    },
    {
        "id": 176,
        "title": "The Earliest Moment When Everyone Become Friends",
        "difficulty": "Medium",
        "content": {
            "problem": "There are n people in a social group labeled from `0` to `n - 1`. You are given an array `logs` where `logs[i] = [timestampi, xi, yi]` indicates that `xi` and `yi` will be friends at the time `timestampi`.\n\nFriendship is **symmetric**. That means if `a` is friends with `b`, then `b` is friends with `a`. Also, person `a` is acquainted with a person `b` if `a` is friends with `b`, or `a` is a friend of someone acquainted with `b`.\n\nReturn _the earliest time for which every person became acquainted with every other person_. If there is no such earliest time, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** logs = \\[\\[20190101,0,1\\],\\[20190104,3,4\\],\\[20190107,2,3\\],\\[20190211,1,5\\],\\[20190224,2,4\\],\\[20190301,0,3\\],\\[20190312,1,2\\],\\[20190322,4,5\\]\\], n = 6\n**Output:** 20190301\n**Explanation:** \nThe first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups \\[0,1\\], \\[2\\], \\[3\\], \\[4\\], \\[5\\].\nThe second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups \\[0,1\\], \\[2\\], \\[3,4\\], \\[5\\].\nThe third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups \\[0,1\\], \\[2,3,4\\], \\[5\\].\nThe fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups \\[0,1,5\\], \\[2,3,4\\].\nThe fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens.\nThe sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends.\n\n",
                "**Example 2:**\n\n**Input:** logs = \\[\\[0,2,0\\],\\[1,0,1\\],\\[3,0,3\\],\\[4,1,2\\],\\[7,3,1\\]\\], n = 4\n**Output:** 3\n**Explanation:** At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= logs.length <= 104`\n*   `logs[i].length == 3`\n*   `0 <= timestampi <= 109`\n*   `0 <= xi, yi <= n - 1`\n*   `xi != yi`\n*   All the values `timestampi` are **unique**.\n*   All the pairs `(xi, yi)` occur at most one time in the input.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]],6",
                "output": "20190301"
            },
            {
                "input": "[[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]],4",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int earliestAcq(int[][] logs, int n) {\n    int[] parents = new int[n];\n    for (int i = 0; i < n; i++) {\n        parents[i] = i;\n    }\n\n    Arrays.sort(logs, (log1, log2) -> log1[0] - log2[0]);\n\n    int groupCount = n;\n    for (int[] log : logs) {\n        int rootX = find(log[1], parents);\n        int rootY = find(log[2], parents);\n        if (rootX != rootY) {\n            parents[rootX] = rootY;\n            groupCount--;\n        }\n        if (groupCount == 1) {\n            return log[0];\n        }\n    }\n    return -1;\n}\n\nprivate int find(int x, int[] parents) {\n    return x == parents[x] ? x : (parents[x] = find(parents[x], parents));\n}\n```\n    \n    All the implemented algorithms are based on the Union-Find data structure.\n\nWe initialize a parents array to keep track of the parent of each node. We sort the logs based on timestamps. We iterate through each log and for each pair of friends, x and y, we find their root using the `find` function. If the roots are not equal, we merge their roots and decrement the group count. This means they are now part of the same group, and there is one less separate group. We return the current timestamp when we reach to only one group left.\n    ",
        "python": "\n    ```python\ndef earliestAcq(logs, n):\n    def find(x):\n        if x != parents[x]:\n            parents[x] = find(parents[x])\n        return parents[x]\n\n    parents = list(range(n))\n    logs.sort()\n\n    group_count = n\n    for timestamp, x, y in logs:\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parents[root_x] = root_y\n            group_count -= 1\n        if group_count == 1:\n            return timestamp\n    return -1\n```\n    \n    All the implemented algorithms are based on the Union-Find data structure.\n\nWe initialize a parents array to keep track of the parent of each node. We sort the logs based on timestamps. We iterate through each log and for each pair of friends, x and y, we find their root using the `find` function. If the roots are not equal, we merge their roots and decrement the group count. This means they are now part of the same group, and there is one less separate group. We return the current timestamp when we reach to only one group left.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint parent(int x, std::vector<int>& parents) {\n    return x == parents[x] ? x : parents[x] = parent(parents[x], parents);\n}\n\nint earliestAcq(std::vector<std::vector<int>>& logs, int n) {\n    std::vector<int> parents(n);\n    for (int i = 0; i < n; ++i) parents[i] = i;\n    \n    std::sort(logs.begin(), logs.end());\n    \n    int groupCount = n;\n    for (const auto& log : logs) {\n        int rootX = parent(log[1], parents);\n        int rootY = parent(log[2], parents);\n        if (rootX != rootY) {\n            parents[rootX] = rootY;\n            groupCount--;\n        }\n        if (groupCount == 1) {\n            return log[0];\n        }\n    }\n    return -1;\n}\n```\n    \n    All the implemented algorithms are based on the Union-Find data structure.\n\nWe initialize a parents array to keep track of the parent of each node. We sort the logs based on timestamps. We iterate through each log and for each pair of friends, x and y, we find their root using the `find` function. If the roots are not equal, we merge their roots and decrement the group count. This means they are now part of the same group, and there is one less separate group. We return the current timestamp when we reach to only one group left.\n    ",
        "js": "\n    ```javascript\nfunction earliestAcq(logs, n) {\n    const parents = new Array(n).fill(0).map((_, idx) => idx);\n\n    logs.sort((a, b) => a[0] - b[0]);\n\n    const find = (x) => {\n        if (x !== parents[x]) {\n            parents[x] = find(parents[x]);\n        }\n        return parents[x];\n    }\n\n    let group_count = n;\n    for (const [timestamp, x, y] of logs) {\n        const root_x = find(x);\n        const root_y = find(y);\n        if (root_x !== root_y) {\n            parents[root_x] = root_y;\n            group_count--;\n        }\n        if (group_count === 1) {\n            return timestamp;\n        }\n    }\n\n    return -1;\n}\n```\n    \n    All the implemented algorithms are based on the Union-Find data structure.\n\nWe initialize a parents array to keep track of the parent of each node. We sort the logs based on timestamps. We iterate through each log and for each pair of friends, x and y, we find their root using the `find` function. If the roots are not equal, we merge their roots and decrement the group count. This means they are now part of the same group, and there is one less separate group. We return the current timestamp when we reach to only one group left.\n    "
    },
    {
        "id": 177,
        "title": "Path With Maximum Minimum Value",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` integer matrix `grid`, return _the maximum **score** of a path starting at_ `(0, 0)` _and ending at_ `(m - 1, n - 1)` moving in the 4 cardinal directions.\n\nThe **score** of a path is the minimum value in that path.\n\n*   For example, the score of the path `8 -> 4 -> 5 -> 9` is `4`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[5,4,5\\],\\[1,2,6\\],\\[7,4,6\\]\\]\n**Output:** 4\n**Explanation:** The path with the maximum score is highlighted in yellow. \n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[2,2,1,2,2,2\\],\\[1,2,2,2,1,2\\]\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[3,4,6,3,4\\],\\[0,2,1,1,7\\],\\[8,8,3,2,7\\],\\[3,2,4,9,8\\],\\[4,1,2,0,0\\],\\[4,6,5,4,3\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `0 <= grid[i][j] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[5,4,5],[1,2,6],[7,4,6]]",
                "output": "4"
            },
            {
                "input": "[[2,2,1,2,2,2],[1,2,2,2,1,2]]",
                "output": "2"
            },
            {
                "input": "[[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n\n    for (int i = 1; i < n; ++i) {\n        grid[0][i] = Math.min(grid[0][i], grid[0][i - 1]);\n    }\n\n    for (int i = 1; i < m; ++i) {\n        grid[i][0] = Math.min(grid[i][0], grid[i - 1][0]);\n\n        for (int j = 1; j < n; ++j) {\n            grid[i][j] = Math.max(Math.min(grid[i - 1][j], grid[i][j]), \n                                  Math.min(grid[i][j - 1], grid[i][j]));\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}\n```\n\n\n    \n    The basic idea is to maintain the maximum score at each cell in the grid. In this case, we start with the first row, and then for every next cell, we store the minimum of that cell and its previous cell in it.\n\nThen, starting from the second row, we perform the same operation for the first column, storing the minimum across rows.\n\nAt this point, for each interior cell in the grid, we have two options: either move from the top cell, or move from the left cell. We apply the same minimum operation between the current cell, and the top cell, and the left cell. We choose the maximum between these two results.\n\nFinally, we return the value at the last cell of the grid, which holds the maximum score.\n    ",
        "python": "\n    ```python\ndef maxScore(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, n):\n        grid[0][i] = min(grid[0][i], grid[0][i - 1])\n\n    for i in range(1, m):\n        grid[i][0] = min(grid[i][0], grid[i - 1][0])\n\n        for j in range(1, n):\n            grid[i][j] = max(min(grid[i - 1][j], grid[i][j]), min(grid[i][j - 1], grid[i][j]))\n\n    return grid[m - 1][n - 1]\n```\n\n\n    \n    The basic idea is to maintain the maximum score at each cell in the grid. In this case, we start with the first row, and then for every next cell, we store the minimum of that cell and its previous cell in it.\n\nThen, starting from the second row, we perform the same operation for the first column, storing the minimum across rows.\n\nAt this point, for each interior cell in the grid, we have two options: either move from the top cell, or move from the left cell. We apply the same minimum operation between the current cell, and the top cell, and the left cell. We choose the maximum between these two results.\n\nFinally, we return the value at the last cell of the grid, which holds the maximum score.\n    ",
        "c++": "\n    ```cpp\nint maxScore(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    \n    for (int i = 1; i < n; i++) {\n        grid[0][i] = min(grid[0][i], grid[0][i - 1]);\n    }\n    \n    for (int i = 1; i < m; i++) {\n        grid[i][0] = min(grid[i][0], grid[i - 1][0]);\n        \n        for (int j = 1; j < n; j++) {\n            grid[i][j] = max(min(grid[i - 1][j], grid[i][j]), min(grid[i][j - 1], grid[i][j]));\n        }\n    }\n    \n    return grid[m - 1][n - 1];\n}\n```\n\n\n    \n    The basic idea is to maintain the maximum score at each cell in the grid. In this case, we start with the first row, and then for every next cell, we store the minimum of that cell and its previous cell in it.\n\nThen, starting from the second row, we perform the same operation for the first column, storing the minimum across rows.\n\nAt this point, for each interior cell in the grid, we have two options: either move from the top cell, or move from the left cell. We apply the same minimum operation between the current cell, and the top cell, and the left cell. We choose the maximum between these two results.\n\nFinally, we return the value at the last cell of the grid, which holds the maximum score.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(grid) {\n    const m = grid.length, n = grid[0].length;\n    \n    for (let i = 1; i < n; ++i) {\n        grid[0][i] = Math.min(grid[0][i], grid[0][i - 1]);\n    }\n    \n    for (let i = 1; i < m; ++i) {\n        grid[i][0] = Math.min(grid[i][0], grid[i - 1][0]);\n        \n        for (let j = 1; j < n; ++j) {\n            grid[i][j] = Math.max(Math.min(grid[i - 1][j], grid[i][j]), \n                                  Math.min(grid[i][j - 1], grid[i][j]));\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}\n```\n\n\n    \n    The basic idea is to maintain the maximum score at each cell in the grid. In this case, we start with the first row, and then for every next cell, we store the minimum of that cell and its previous cell in it.\n\nThen, starting from the second row, we perform the same operation for the first column, storing the minimum across rows.\n\nAt this point, for each interior cell in the grid, we have two options: either move from the top cell, or move from the left cell. We apply the same minimum operation between the current cell, and the top cell, and the left cell. We choose the maximum between these two results.\n\nFinally, we return the value at the last cell of the grid, which holds the maximum score.\n    "
    },
    {
        "id": 178,
        "title": "Number of Days in a Month",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a year `year` and a month `month`, return _the number of days of that month_.",
            "examples": [
                "**Example 1:**\n\n**Input:** year = 1992, month = 7\n**Output:** 31\n\n",
                "**Example 2:**\n\n**Input:** year = 2000, month = 2\n**Output:** 29\n\n",
                "**Example 3:**\n\n**Input:** year = 1900, month = 2\n**Output:** 28"
            ],
            "constraints": "**Constraints:**\n\n*   `1583 <= year <= 2100`\n*   `1 <= month <= 12`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1992,7",
                "output": "31"
            },
            {
                "input": "2000,2",
                "output": "29"
            },
            {
                "input": "1900,2",
                "output": "28"
            }
        ],
        "java": "\n    ```java\nint numberOfDays(int year, int month) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "python": "\n    ```python\ndef number_of_days(year, month):\n    if month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            return 29\n        return 28\n    if month in [4, 6, 9, 11]:\n        return 30\n    return 31\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "c++": "\n    ```cpp\nint numberOfDays(int year, int month) {\n    if(month == 2) {\n        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if(month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "js": "\n    ```javascript\nfunction numberOfDays(year, month) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    "
    },
    {
        "id": 179,
        "title": "Remove Vowels from a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, remove the vowels `'a'`, `'e'`, `'i'`, `'o'`, and `'u'` from it, and return the new string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leetcodeisacommunityforcoders \"\n**Output:**  \"ltcdscmmntyfrcdrs \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aeiou \"\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"leetcodeisacommunityforcoders\"",
                "output": "\"ltcdscmmntyfrcdrs\""
            },
            {
                "input": "\"aeiou\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic boolean isRobotBounded(String instructions) {\n    int x = 0, y = 0, dir = 0;\n    int[][] moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (char c : instructions.toCharArray()) {\n        if (c == 'G') {\n            x += moves[dir][0];\n            y += moves[dir][1];\n        } else if (c == 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n\n    return (x == 0 && y == 0) || dir != 0;\n}\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "python": "\n    ```python\ndef is_robot_bounded(instructions: str) -> bool:\n    x, y, dir = 0, 0, 0\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for c in instructions:\n        if c == 'G':\n            x += moves[dir][0]\n            y += moves[dir][1]\n        elif c == 'L':\n            dir = (dir + 3) % 4\n        else:\n            dir = (dir + 1) % 4\n\n    return (x == 0 and y == 0) or dir != 0\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "c++": "\n    ```cpp\nbool isRobotBounded(string instructions) {\n    int x = 0, y = 0, dir = 0;\n    vector<vector<int>> moves {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (char c : instructions) {\n        if (c == 'G') {\n            x += moves[dir][0];\n            y += moves[dir][1];\n        } else if (c == 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n\n    return (x == 0 && y == 0) || dir != 0;\n}\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "js": "\n    ```javascript\nfunction isRobotBounded(instructions) {\n    let x = 0, y = 0, dir = 0;\n    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    for (const c of instructions) {\n        if (c === 'G') {\n            x += moves[dir][0];\n            y += moves[dir][1];\n        } else if (c === 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n\n    return (x === 0 && y === 0) || dir !== 0;\n}\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    "
    },
    {
        "id": 180,
        "title": "Maximum Average Subtree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the maximum **average** value of a **subtree** of that tree_. Answers within `10-5` of the actual answer will be accepted.\n\nA **subtree** of a tree is any node of that tree plus all its descendants.\n\nThe **average** value of a tree is the sum of its values, divided by the number of nodes.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,6,1\\]\n**Output:** 6.00000\n**Explanation:** \nFor the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.\nFor the node with value = 6 we have an average of 6 / 1 = 6.\nFor the node with value = 1 we have an average of 1 / 1 = 1.\nSo the answer is 6 which is the maximum.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0,null,1\\]\n**Output:** 1.00000"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,6,1]",
                "output": "6.00000"
            },
            {
                "input": "[0,null,1]",
                "output": "1.00000"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] gardenNoAdj(int n, int[][] paths) {\n    List<Set<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        graph.add(new HashSet<>());\n    }\n    for (int[] path : paths) {\n        graph.get(path[0] - 1).add(path[1] - 1);\n        graph.get(path[1] - 1).add(path[0] - 1);\n    }\n    int[] result = new int[n];\n    for (int i = 0; i < n; i++) {\n        Set<Integer> usedFlowers = new HashSet<>();\n        for (int neighbor : graph.get(i)) {\n            usedFlowers.add(result[neighbor]);\n        }\n        for (int flower = 1; flower <= 4; flower++) {\n            if (!usedFlowers.contains(flower)) {\n                result[i] = flower;\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm first represents the bidirectional paths with an adjacent graph structure. Then, for each garden (node), it iterates through its neighbors to keep track of the flowers already represented at adjacent gardens. Finally, it checks the remaining possible flowers (from the 4 types) which haven't been used in neighboring gardens, and assigns that flower type to the current garden. This process is repeated until a flower type is assigned to all gardens, ensuring that no two connected gardens have the same type of flower.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef gardenNoAdj(n, paths):\n    graph = defaultdict(set)\n    for x, y in paths:\n        graph[x - 1].add(y - 1)\n        graph[y - 1].add(x - 1)\n    \n    result = [0] * n\n    for i in range(n):\n        used_flowers = {result[neighbor] for neighbor in graph[i]}\n        for flower in range(1, 5):\n            if flower not in used_flowers:\n                result[i] = flower\n                break\n    return result\n```\n\n    \n    The algorithm first represents the bidirectional paths with an adjacent graph structure. Then, for each garden (node), it iterates through its neighbors to keep track of the flowers already represented at adjacent gardens. Finally, it checks the remaining possible flowers (from the 4 types) which haven't been used in neighboring gardens, and assigns that flower type to the current garden. This process is repeated until a flower type is assigned to all gardens, ensuring that no two connected gardens have the same type of flower.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nstd::vector<int> gardenNoAdj(int n, std::vector<std::vector<int>>& paths) {\n    std::vector<std::unordered_set<int>> graph(n);\n    for (const auto& path : paths) {\n        graph[path[0] - 1].insert(path[1] - 1);\n        graph[path[1] - 1].insert(path[0] - 1);\n    }\n    \n    std::vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        std::unordered_set<int> used_flowers;\n        for (int neighbor : graph[i]) {\n            used_flowers.insert(result[neighbor]);\n        }\n        for (int flower = 1; flower <= 4; ++flower) {\n            if (used_flowers.count(flower) == 0) {\n                result[i] = flower;\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm first represents the bidirectional paths with an adjacent graph structure. Then, for each garden (node), it iterates through its neighbors to keep track of the flowers already represented at adjacent gardens. Finally, it checks the remaining possible flowers (from the 4 types) which haven't been used in neighboring gardens, and assigns that flower type to the current garden. This process is repeated until a flower type is assigned to all gardens, ensuring that no two connected gardens have the same type of flower.\n    ",
        "js": "\n    ```javascript\nfunction gardenNoAdj(n, paths) {\n    const graph = Array.from({ length: n }, () => new Set());\n    \n    for (const [x, y] of paths) {\n        graph[x - 1].add(y - 1);\n        graph[y - 1].add(x - 1);\n    }\n    \n    const result = Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        const usedFlowers = new Set(graph[i].map(neighbor => result[neighbor]));\n        \n        for (let flower = 1; flower <= 4; flower++) {\n            if (!usedFlowers.has(flower)) {\n                result[i] = flower;\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm first represents the bidirectional paths with an adjacent graph structure. Then, for each garden (node), it iterates through its neighbors to keep track of the flowers already represented at adjacent gardens. Finally, it checks the remaining possible flowers (from the 4 types) which haven't been used in neighboring gardens, and assigns that flower type to the current garden. This process is repeated until a flower type is assigned to all gardens, ensuring that no two connected gardens have the same type of flower.\n    "
    },
    {
        "id": 181,
        "title": "Divide Array Into Increasing Sequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` sorted in non-decreasing order and an integer `k`, return `true` _if this array can be divided into one or more disjoint increasing subsequences of length at least_ `k`_, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,3,3,4,4\\], k = 3\n**Output:** true\n**Explanation:** The array can be divided into two subsequences \\[1,2,3,4\\] and \\[2,3,4\\] with lengths at least 3 each.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,6,6,7,8\\], k = 3\n**Output:** false\n**Explanation:** There is no way to divide the array using the conditions required."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\n*   `nums` is sorted in non-decreasing order.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,2,3,3,4,4],3",
                "output": "true"
            },
            {
                "input": "[5,6,6,7,8],3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int maxSumAfterPartitioning(int[] arr, int k) {\n    int n = arr.length;\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        int current_max = 0;\n        for (int j = 1; j <= k && i - j >= 0; ++j) {\n            current_max = Math.max(current_max, arr[i - j]);\n            dp[i] = Math.max(dp[i], dp[i - j] + current_max * j);\n        }\n    }\n    return dp[n];\n}\n```\n    \n    1. Initialize a dp array of size n+1, where n is the length of arr, with every element set to 0. dp[i] represents the maximum sum up to the index i.\n2. Iterate over array indices from 1 to n.\n   a. For each index i, initialize a variable `current_max` to store the maximum element found in the subarray.\n   b. Iterate over subarray lengths from 1 to k:\n      i. If the index i minus the subarray length is not negative, then find the maximum of `current_max` and the value located at arr[i - subarray length].\n      ii. Update the value of dp[i] with the maximum between the current value at dp[i] and the value found in dp[i - subarray length] + the product of current_max * subarray length.\n3. At the end, return the value stored in the last index of dp, which represents the maximum partitioned sum of the entire array.\n    ",
        "python": "\n    ```python\ndef maxSumAfterPartitioning(arr: list, k: int) -> int:\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_max = 0\n        for j in range(1, k + 1):\n            if i - j < 0:\n                break\n            current_max = max(current_max, arr[i - j])\n            dp[i] = max(dp[i], dp[i - j] + current_max * j)\n    return dp[n]\n```\n    \n    1. Initialize a dp array of size n+1, where n is the length of arr, with every element set to 0. dp[i] represents the maximum sum up to the index i.\n2. Iterate over array indices from 1 to n.\n   a. For each index i, initialize a variable `current_max` to store the maximum element found in the subarray.\n   b. Iterate over subarray lengths from 1 to k:\n      i. If the index i minus the subarray length is not negative, then find the maximum of `current_max` and the value located at arr[i - subarray length].\n      ii. Update the value of dp[i] with the maximum between the current value at dp[i] and the value found in dp[i - subarray length] + the product of current_max * subarray length.\n3. At the end, return the value stored in the last index of dp, which represents the maximum partitioned sum of the entire array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxSumAfterPartitioning(vector<int>& arr, int k) {\n    int n = arr.size();\n    vector<int> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        int current_max = 0;\n        for (int j = 1; j <= k && i - j >= 0; ++j) {\n            current_max = max(current_max, arr[i - j]);\n            dp[i] = max(dp[i], dp[i - j] + current_max * j);\n        }\n    }\n    return dp[n];\n}\n```\n    \n    1. Initialize a dp array of size n+1, where n is the length of arr, with every element set to 0. dp[i] represents the maximum sum up to the index i.\n2. Iterate over array indices from 1 to n.\n   a. For each index i, initialize a variable `current_max` to store the maximum element found in the subarray.\n   b. Iterate over subarray lengths from 1 to k:\n      i. If the index i minus the subarray length is not negative, then find the maximum of `current_max` and the value located at arr[i - subarray length].\n      ii. Update the value of dp[i] with the maximum between the current value at dp[i] and the value found in dp[i - subarray length] + the product of current_max * subarray length.\n3. At the end, return the value stored in the last index of dp, which represents the maximum partitioned sum of the entire array.\n    ",
        "js": "\n    ```javascript\nfunction maxSumAfterPartitioning(arr, k) {\n    const n = arr.length;\n    const dp = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        let current_max = 0;\n        for (let j = 1; j <= k && i - j >= 0; ++j) {\n            current_max = Math.max(current_max, arr[i - j]);\n            dp[i] = Math.max(dp[i], dp[i - j] + current_max * j);\n        }\n    }\n    return dp[n];\n}\n```\n    \n    1. Initialize a dp array of size n+1, where n is the length of arr, with every element set to 0. dp[i] represents the maximum sum up to the index i.\n2. Iterate over array indices from 1 to n.\n   a. For each index i, initialize a variable `current_max` to store the maximum element found in the subarray.\n   b. Iterate over subarray lengths from 1 to k:\n      i. If the index i minus the subarray length is not negative, then find the maximum of `current_max` and the value located at arr[i - subarray length].\n      ii. Update the value of dp[i] with the maximum between the current value at dp[i] and the value found in dp[i - subarray length] + the product of current_max * subarray length.\n3. At the end, return the value stored in the last index of dp, which represents the maximum partitioned sum of the entire array.\n    "
    },
    {
        "id": 182,
        "title": "Largest Unique Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the largest integer that only occurs once_. If no integer occurs once, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,7,3,9,4,9,8,3,1\\]\n**Output:** 8\n**Explanation:** The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it is the answer.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9,9,8,8\\]\n**Output:** -1\n**Explanation:** There is no number that occurs only once."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `0 <= nums[i] <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,7,3,9,4,9,8,3,1]",
                "output": "8"
            },
            {
                "input": "[9,9,8,8]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nString lastSubstring(String s) {\n    int i = 0, j = 1, k = 0, n = s.length();\n    while (j + k < n) {\n        if (s.charAt(i + k) == s.charAt(j + k)) {\n            k++;\n        } else if (s.charAt(i + k) < s.charAt(j + k)) {\n            i = j;\n            j++;\n            k = 0;\n        } else {\n            j++;\n            k = 0;\n        }\n    }\n    return s.substring(i);\n}\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "python": "\n    ```python\ndef last_substring(s: str) -> str:\n    i, j, k, n = 0, 1, 0, len(s)\n    while j + k < n:\n        if s[i + k] == s[j + k]:\n            k += 1\n        elif s[i + k] < s[j + k]:\n            i = j\n            j += 1\n            k = 0\n        else:\n            j += 1\n            k = 0\n    return s[i:]\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "c++": "\n    ```cpp\nstd::string lastSubstring(std::string s) {\n    int i = 0, j = 1, k = 0, n = s.length();\n    while (j + k < n) {\n        if (s[i + k] == s[j + k]) {\n            k++;\n        } else if (s[i + k] < s[j + k]) {\n            i = j;\n            j++;\n            k = 0;\n        } else {\n            j++;\n            k = 0;\n        }\n    }\n    return s.substr(i);\n}\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "js": "\n    ```javascript\nfunction lastSubstring(s) {\n    let i = 0, j = 1, k = 0, n = s.length;\n    while (j + k < n) {\n        if (s.charAt(i + k) === s.charAt(j + k)) {\n            k++;\n        } else if (s.charAt(i + k) < s.charAt(j + k)) {\n            i = j;\n            j++;\n            k = 0;\n        } else {\n            j++;\n            k = 0;\n        }\n    }\n    return s.substring(i);\n}\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    "
    },
    {
        "id": 183,
        "title": "Armstrong Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return `true` _if and only if it is an **Armstrong number**_.\n\nThe `k`\\-digit number `n` is an Armstrong number if and only if the `kth` power of each digit sums to `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 153\n**Output:** true\n**Explanation:** 153 is a 3-digit number, and 153 = 13 + 53 + 33.\n\n",
                "**Example 2:**\n\n**Input:** n = 123\n**Output:** false\n**Explanation:** 123 is a 3-digit number, and 123 != 13 + 23 + 33 = 36."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 108`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "153",
                "output": "true"
            },
            {
                "input": "123",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isArmstrong(int n) {\n    int power_sum = 0;\n    int original = n;\n    int k = String.valueOf(n).length();\n    while (n > 0) {\n        int digit = n % 10;\n        power_sum += Math.pow(digit, k);\n        n /= 10;\n    }\n    return power_sum == original;\n}\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "python": "\n    ```python\ndef is_armstrong(n: int) -> bool:\n    power_sum = 0\n    original = n\n    k = len(str(n))\n    while n > 0:\n        digit = n % 10\n        power_sum += digit ** k\n        n //= 10\n    return power_sum == original\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "c++": "\n    ```cpp\nbool isArmstrong(int n) {\n    int power_sum = 0, original = n;\n    int k = to_string(n).length();\n    while (n > 0) {\n        int digit = n % 10;\n        power_sum += pow(digit, k);\n        n /= 10;\n    }\n    return power_sum == original;\n}\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "js": "\n    ```javascript\nfunction isArmstrong(n) {\n    let power_sum = 0;\n    let original = n;\n    let k = n.toString().length;\n    while (n > 0) {\n        let digit = n % 10;\n        power_sum += Math.pow(digit, k);\n        n = Math.floor(n / 10);\n    }\n    return power_sum === original;\n}\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    "
    },
    {
        "id": 184,
        "title": "Connecting Cities With Minimum Cost",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` cities labeled from `1` to `n`. You are given the integer `n` and an array `connections` where `connections[i] = [xi, yi, costi]` indicates that the cost of connecting city `xi` and city `yi` (bidirectional connection) is `costi`.\n\nReturn _the minimum **cost** to connect all the_ `n` _cities such that there is at least one path between each pair of cities_. If it is impossible to connect all the `n` cities, return `-1`,\n\nThe **cost** is the sum of the connections' costs used.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, connections = \\[\\[1,2,5\\],\\[1,3,6\\],\\[2,3,1\\]\\]\n**Output:** 6\n**Explanation:** Choosing any 2 edges will connect all cities so we choose the minimum 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, connections = \\[\\[1,2,3\\],\\[3,4,4\\]\\]\n**Output:** -1\n**Explanation:** There is no way to connect all cities even if all edges are used."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`\n*   `1 <= connections.length <= 104`\n*   `connections[i].length == 3`\n*   `1 <= xi, yi <= n`\n*   `xi != yi`\n*   `0 <= costi <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,[[1,2,5],[1,3,6],[2,3,1]]",
                "output": "6"
            },
            {
                "input": "4,[[1,2,3],[3,4,4]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int find(int[] parent, int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n\npublic int minimumCost(int n, int[][] connections) {\n    Arrays.sort(connections, Comparator.comparingInt(a -> a[2]));\n\n    int[] parent = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int cost = 0;\n    int edges = 0;\n    for (int[] connection : connections) {\n        int root_x = find(parent, connection[0]);\n        int root_y = find(parent, connection[1]);\n\n        if (root_x != root_y) {\n            parent[root_y] = root_x;\n            cost += connection[2];\n            edges += 1;\n        }\n\n        if (edges == n - 1) {\n            break;\n        }\n    }\n\n    return edges == n - 1 ? cost : -1;\n}\n```\n    \n    The algorithm is based on Kruskal's algorithm for finding the minimum spanning tree (MST) of a connected, undirected graph. The problem can be modeled as a graph where cities are nodes and connections are edges with associated costs. The minimum cost to connect all cities such that there is at least one path between each pair of cities is equivalent to finding the MST of the graph. \n\nThe basic idea behind the algorithm is to sort the connections by increasing cost, and then iterate through the sorted connections, connecting cities if they have different root nodes. We will keep track of how many edges have been added to the MST. If we have added n - 1 edges(equal to the number of nodes minus one), we have a spanning tree, and we can return the total cost of the MST. If we do not have n - 1 edges at the end of the iteration, it means that it is not possible to connect all cities, and we should return -1.\n\n- Sort the connections array by increasing cost.\n- Initialize the parent array with each node as its own parent.\n- Initialize variables edges and cost to zero.\n- Loop through each connection in the sorted connections array.\n  - Find the root node of the two cities in the connection using the find function with path compression.\n  - If the root nodes are different, connect them by making one root node the parent of the other, increment the edges variable, and add the cost of the current connection to the total cost.\n  - If the number of edges is n - 1, break the loop.\n- If the number of edges is n - 1 at the end of the iteration, return the total cost, otherwise, return -1.\n    ",
        "python": "\n    ```python\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef minimumCost(n, connections):\n    connections.sort(key=lambda x: x[2])\n\n    parent = list(range(n + 1))\n\n    cost = 0\n    edges = 0\n    for c in connections:\n        root_x = find(parent, c[0])\n        root_y = find(parent, c[1])\n\n        if root_x != root_y:\n            parent[root_y] = root_x\n            cost += c[2]\n            edges += 1\n\n        if edges == n - 1:\n            break\n\n    return cost if edges == n - 1 else -1\n```\n    \n    The algorithm is based on Kruskal's algorithm for finding the minimum spanning tree (MST) of a connected, undirected graph. The problem can be modeled as a graph where cities are nodes and connections are edges with associated costs. The minimum cost to connect all cities such that there is at least one path between each pair of cities is equivalent to finding the MST of the graph. \n\nThe basic idea behind the algorithm is to sort the connections by increasing cost, and then iterate through the sorted connections, connecting cities if they have different root nodes. We will keep track of how many edges have been added to the MST. If we have added n - 1 edges(equal to the number of nodes minus one), we have a spanning tree, and we can return the total cost of the MST. If we do not have n - 1 edges at the end of the iteration, it means that it is not possible to connect all cities, and we should return -1.\n\n- Sort the connections array by increasing cost.\n- Initialize the parent array with each node as its own parent.\n- Initialize variables edges and cost to zero.\n- Loop through each connection in the sorted connections array.\n  - Find the root node of the two cities in the connection using the find function with path compression.\n  - If the root nodes are different, connect them by making one root node the parent of the other, increment the edges variable, and add the cost of the current connection to the total cost.\n  - If the number of edges is n - 1, break the loop.\n- If the number of edges is n - 1 at the end of the iteration, return the total cost, otherwise, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint find(std::vector<int>& parent, int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n\nint minimumCost(int n, std::vector<std::vector<int>>& connections) {\n    std::sort(connections.begin(), connections.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[2] < b[2];\n    });\n\n    std::vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int cost = 0;\n    int edges = 0;\n    for (const auto& connection : connections) {\n        int root_x = find(parent, connection[0]);\n        int root_y = find(parent, connection[1]);\n\n        if (root_x != root_y) {\n            parent[root_y] = root_x;\n            cost += connection[2];\n            edges += 1;\n        }\n\n        if (edges == n - 1) {\n            break;\n        }\n    }\n\n    return edges == n - 1 ? cost : -1;\n}\n```\n    \n    The algorithm is based on Kruskal's algorithm for finding the minimum spanning tree (MST) of a connected, undirected graph. The problem can be modeled as a graph where cities are nodes and connections are edges with associated costs. The minimum cost to connect all cities such that there is at least one path between each pair of cities is equivalent to finding the MST of the graph. \n\nThe basic idea behind the algorithm is to sort the connections by increasing cost, and then iterate through the sorted connections, connecting cities if they have different root nodes. We will keep track of how many edges have been added to the MST. If we have added n - 1 edges(equal to the number of nodes minus one), we have a spanning tree, and we can return the total cost of the MST. If we do not have n - 1 edges at the end of the iteration, it means that it is not possible to connect all cities, and we should return -1.\n\n- Sort the connections array by increasing cost.\n- Initialize the parent array with each node as its own parent.\n- Initialize variables edges and cost to zero.\n- Loop through each connection in the sorted connections array.\n  - Find the root node of the two cities in the connection using the find function with path compression.\n  - If the root nodes are different, connect them by making one root node the parent of the other, increment the edges variable, and add the cost of the current connection to the total cost.\n  - If the number of edges is n - 1, break the loop.\n- If the number of edges is n - 1 at the end of the iteration, return the total cost, otherwise, return -1.\n    ",
        "js": "\n    ```javascript\nfunction find(parent, x) {\n    if (parent[x] !== x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n\nfunction minimumCost(n, connections) {\n    connections.sort((a, b) => a[2] - b[2]);\n\n    const parent = Array.from({ length: n + 1 }, (_, i) => i);\n\n    let cost = 0;\n    let edges = 0;\n    for (const connection of connections) {\n        const root_x = find(parent, connection[0]);\n        const root_y = find(parent, connection[1]);\n\n        if (root_x !== root_y) {\n            parent[root_y] = root_x;\n            cost += connection[2];\n            edges += 1;\n        }\n\n        if (edges === n - 1) {\n            break;\n        }\n    }\n\n    return edges === n - 1 ? cost : -1;\n}\n```\n    \n    The algorithm is based on Kruskal's algorithm for finding the minimum spanning tree (MST) of a connected, undirected graph. The problem can be modeled as a graph where cities are nodes and connections are edges with associated costs. The minimum cost to connect all cities such that there is at least one path between each pair of cities is equivalent to finding the MST of the graph. \n\nThe basic idea behind the algorithm is to sort the connections by increasing cost, and then iterate through the sorted connections, connecting cities if they have different root nodes. We will keep track of how many edges have been added to the MST. If we have added n - 1 edges(equal to the number of nodes minus one), we have a spanning tree, and we can return the total cost of the MST. If we do not have n - 1 edges at the end of the iteration, it means that it is not possible to connect all cities, and we should return -1.\n\n- Sort the connections array by increasing cost.\n- Initialize the parent array with each node as its own parent.\n- Initialize variables edges and cost to zero.\n- Loop through each connection in the sorted connections array.\n  - Find the root node of the two cities in the connection using the find function with path compression.\n  - If the root nodes are different, connect them by making one root node the parent of the other, increment the edges variable, and add the cost of the current connection to the total cost.\n  - If the number of edges is n - 1, break the loop.\n- If the number of edges is n - 1 at the end of the iteration, return the total cost, otherwise, return -1.\n    "
    },
    {
        "id": 185,
        "title": "Parallel Courses",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`.\n\nIn one semester, you can take **any number** of courses as long as you have taken all the prerequisites in the **previous** semester for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. If there is no way to take all the courses, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\]\n**Output:** 2\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 1 and 2.\nIn the second semester, you can take course 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, relations = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1\n**Explanation:** No course can be studied because they are prerequisites of each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `1 <= relations.length <= 5000`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,[[1,3],[2,3]]",
                "output": "2"
            },
            {
                "input": "3,[[1,2],[2,3],[3,1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minimumSemesters(int n, int[][] relations) {\n    int[] in_degree = new int[n + 1];\n    List<List<Integer>> graph = new ArrayList<>();\n\n    for (int i = 0; i <= n; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] relation : relations) {\n        graph.get(relation[0]).add(relation[1]);\n        in_degree[relation[1]]++;\n    }\n\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.offer(i);\n        }\n    }\n\n    int semesters = 0;\n    while (!q.isEmpty()) {\n        int size = q.size();\n        semesters++;\n        for (int i = 0; i < size; i++) {\n            int course = q.poll();\n            n--;\n\n            for (int next : graph.get(course)) {\n                if (--in_degree[next] == 0) {\n                    q.offer(next);\n                }\n            }\n        }\n    }\n\n    return n == 0 ? semesters : -1;\n}\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "python": "\n    ```python\ndef minimum_semesters(n: int, relations: List[List[int]]) -> int:\n    in_degree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev, next in relations:\n        graph[prev].append(next)\n        in_degree[next] += 1\n\n    q = [i for i in range(1, n + 1) if in_degree[i] == 0]\n    semesters = 0\n\n    while q:\n        next_q = []\n        semesters += 1\n        for course in q:\n            n -= 1\n            for next_course in graph[course]:\n                in_degree[next_course] -= 1\n                if in_degree[next_course] == 0:\n                    next_q.append(next_course)\n        q = next_q\n\n    return semesters if n == 0 else -1\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "c++": "\n    ```cpp\nint minimumSemesters(int n, vector<vector<int>>& relations) {\n    vector<int> in_degree(n + 1, 0);\n    vector<vector<int>> graph(n + 1);\n\n    for (auto& relation : relations) {\n        graph[relation[0]].push_back(relation[1]);\n        in_degree[relation[1]]++;\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    int semesters = 0;\n    while (!q.empty()) {\n        int size = q.size();\n        semesters++;\n        while (size--) {\n            int course = q.front();\n            q.pop();\n            n--;\n\n            for (int next : graph[course]) {\n                if (--in_degree[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    return n == 0 ? semesters : -1;\n}\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    ",
        "js": "\n    ```javascript\nfunction minimumSemesters(n, relations) {\n    const in_degree = new Array(n + 1).fill(0);\n    const graph = new Array(n + 1).fill(null).map(() => []);\n\n    for (let [prev, next] of relations) {\n        graph[prev].push(next);\n        in_degree[next]++;\n    }\n\n    const q = [];\n    for (let i = 1; i <= n; i++) {\n        if (in_degree[i] === 0) {\n            q.push(i);\n        }\n    }\n\n    let semesters = 0;\n    while (q.length) {\n        const size = q.length;\n        semesters++;\n        for (let i = 0; i < size; i++) {\n            const course = q.shift();\n            n--;\n\n            for (let next of graph[course]) {\n                in_degree[next]--;\n                if (in_degree[next] === 0) {\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    return n === 0 ? semesters : -1;\n}\n```\n    \n    The algorithm uses topological sort to solve the problem. It starts by initializing the in-degree array, which stores the number of prerequisites for each course, and a graph represented by an adjacency list, where each index is a course and its value is an array of the courses that have it as a prerequisite.\n\nThe for-loop calculates the in-degrees of all courses and populates the adjacency list, then initializes a queue of courses with no prerequisites. The semesters variable is initialized to 0 as well.\n\nThe main loop processes each layer of courses (the ones that can be taken together), incrementing semesters in each iteration. For each course with no prerequisites or with prerequisites that have already been taken (in_degree[course] === 0), we decrement the counter n (initially equal to the number of total courses) and decrease the in-degrees of the courses that have the current course as a prerequisite.\n\nFinally, we return the number of semesters if all courses have been taken (n === 0), or -1 if there is a cycle between courses (not all courses have been taken).\n    "
    },
    {
        "id": 186,
        "title": "Check If a Number Is Majority Element in a Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in non-decreasing order and an integer `target`, return `true` _if_ `target` _is a **majority** element, or_ `false` _otherwise_.\n\nA **majority** element in an array `nums` is an element that appears more than `nums.length / 2` times in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,5,5,5,5,5,6,6\\], target = 5\n**Output:** true\n**Explanation:** The value 5 appears 5 times and the length of the array is 9.\nThus, 5 is a majority element because 5 > 9/2 is true.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,100,101,101\\], target = 101\n**Output:** false\n**Explanation:** The value 101 appears 2 times and the length of the array is 4.\nThus, 101 is not a majority element because 2 > 4/2 is false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i], target <= 109`\n*   `nums` is sorted in non-decreasing order.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,4,5,5,5,5,5,6,6],5",
                "output": "true"
            },
            {
                "input": "[10,100,101,101],101",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean isMajorityElement(int[] nums, int target) {\n    int count = 0;\n    for (int num : nums) {\n        if (num == target) count++;\n        if (count > nums.length / 2) return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "python": "\n    ```python\ndef is_majority_element(nums, target):\n    count = 0\n    for num in nums:\n        if num == target: count += 1\n        if count > len(nums) / 2: return True\n    return False\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "c++": "\n    ```cpp\nbool isMajorityElement(vector<int>& nums, int target) {\n    int count = 0;\n    for (int num : nums) {\n        if (num == target) count++;\n        if (count > nums.size() / 2) return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "js": "\n    ```javascript\nfunction isMajorityElement(nums, target) {\n    let count = 0;\n    for (const num of nums) {\n        if (num === target) count++;\n        if (count > nums.length / 2) return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    "
    },
    {
        "id": 187,
        "title": "Minimum Swaps to Group All 1's Together",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a binary array `data`, return the minimum number of swaps required to group all `1`'s present in the array together in **any place** in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** data = \\[1,0,1,0,1\\]\n**Output:** 1\n**Explanation:** There are 3 ways to group all 1's together:\n\\[1,1,1,0,0\\] using 1 swap.\n\\[0,1,1,1,0\\] using 2 swaps.\n\\[0,0,1,1,1\\] using 1 swap.\nThe minimum is 1.\n\n",
                "**Example 2:**\n\n**Input:** data = \\[0,0,0,1,0\\]\n**Output:** 0\n**Explanation:** Since there is only one 1 in the array, no swaps are needed.\n\n",
                "**Example 3:**\n\n**Input:** data = \\[1,0,1,0,1,0,0,1,1,0,1\\]\n**Output:** 3\n**Explanation:** One possible solution that uses 3 swaps is \\[0,0,0,0,0,1,1,1,1,1,1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= data.length <= 105`\n*   `data[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,0,1,0,1]",
                "output": "1"
            },
            {
                "input": "[0,0,0,1,0]",
                "output": "0"
            },
            {
                "input": "[1,0,1,0,1,0,0,1,1,0,1]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minSwaps(int[] data) {\n    int ones = 0;\n    for (int d : data) {\n        ones += d;\n    }\n    int cur_ones = 0, max_ones = 0;\n    for (int i = 0; i < data.length; i++) {\n        cur_ones += data[i];\n        if (i >= ones) {\n            cur_ones -= data[i - ones];\n        }\n        max_ones = Math.max(max_ones, cur_ones);\n    }\n    return ones - max_ones;\n}\n```\n\n    \n    First, count the number of ones in the data array. Then, use a sliding window of length equal to the count of ones to keep a running sum of ones in the window. Keep track of the maximum number of ones found in any window. The minimum number of swaps required to group all ones together equals the total number of ones minus the maximum number of ones found in any window.\n    ",
        "python": "\n    ```python\ndef minSwaps(data):\n    ones = sum(data)\n    cur_ones, max_ones = 0, 0\n    for i, d in enumerate(data):\n        cur_ones += d\n        if i >= ones:\n            cur_ones -= data[i - ones]\n        max_ones = max(max_ones, cur_ones)\n    return ones - max_ones\n```\n\n    \n    First, count the number of ones in the data array. Then, use a sliding window of length equal to the count of ones to keep a running sum of ones in the window. Keep track of the maximum number of ones found in any window. The minimum number of swaps required to group all ones together equals the total number of ones minus the maximum number of ones found in any window.\n    ",
        "c++": "\n    ```cpp\nint minSwaps(vector<int>& data) {\n    int ones = 0;\n    for (int d : data) {\n        ones += d;\n    }\n    int cur_ones = 0, max_ones = 0;\n    for (int i = 0; i < data.size(); i++) {\n        cur_ones += data[i];\n        if (i >= ones) {\n            cur_ones -= data[i - ones];\n        }\n        max_ones = max(max_ones, cur_ones);\n    }\n    return ones - max_ones;\n}\n```\n\n    \n    First, count the number of ones in the data array. Then, use a sliding window of length equal to the count of ones to keep a running sum of ones in the window. Keep track of the maximum number of ones found in any window. The minimum number of swaps required to group all ones together equals the total number of ones minus the maximum number of ones found in any window.\n    ",
        "js": "\n    ```javascript\nfunction minSwaps(data) {\n    let ones = data.reduce((a, b) => a + b);\n    let cur_ones = 0, max_ones = 0;\n    for (let i = 0; i < data.length; i++) {\n        cur_ones += data[i];\n        if (i >= ones) {\n            cur_ones -= data[i - ones];\n        }\n        max_ones = Math.max(max_ones, cur_ones);\n    }\n    return ones - max_ones;\n}\n```\n\n    \n    First, count the number of ones in the data array. Then, use a sliding window of length equal to the count of ones to keep a running sum of ones in the window. Keep track of the maximum number of ones found in any window. The minimum number of swaps required to group all ones together equals the total number of ones minus the maximum number of ones found in any window.\n    "
    },
    {
        "id": 188,
        "title": "Analyze User Website Visit Pattern",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two string arrays `username` and `website` and an integer array `timestamp`. All the given arrays are of the same length and the tuple `[username[i], website[i], timestamp[i]]` indicates that the user `username[i]` visited the website `website[i]` at time `timestamp[i]`.\n\nA **pattern** is a list of three websites (not necessarily distinct).\n\n*   For example, `[ \"home \", \"away \", \"love \"]`, `[ \"leetcode \", \"love \", \"leetcode \"]`, and `[ \"luffy \", \"luffy \", \"luffy \"]` are all patterns.\n\nThe **score** of a **pattern** is the number of users that visited all the websites in the pattern in the same order they appeared in the pattern.\n\n*   For example, if the pattern is `[ \"home \", \"away \", \"love \"]`, the score is the number of users `x` such that `x` visited `\"home \"` then visited `\"away \"` and visited `\"love \"` after that.\n*   Similarly, if the pattern is `[ \"leetcode \", \"love \", \"leetcode \"]`, the score is the number of users `x` such that `x` visited `\"leetcode \"` then visited `\"love \"` and visited `\"leetcode \"` **one more time** after that.\n*   Also, if the pattern is `[ \"luffy \", \"luffy \", \"luffy \"]`, the score is the number of users `x` such that `x` visited `\"luffy \"` three different times at different timestamps.\n\nReturn _the **pattern** with the largest **score**_. If there is more than one pattern with the same largest score, return the lexicographically smallest such pattern.",
            "examples": [
                "**Example 1:**\n\n**Input:** username = \\[ \"joe \", \"joe \", \"joe \", \"james \", \"james \", \"james \", \"james \", \"mary \", \"mary \", \"mary \"\\], timestamp = \\[1,2,3,4,5,6,7,8,9,10\\], website = \\[ \"home \", \"about \", \"career \", \"home \", \"cart \", \"maps \", \"home \", \"home \", \"about \", \"career \"\\]\n**Output:** \\[ \"home \", \"about \", \"career \"\\]\n**Explanation:** The tuples in this example are:\n\\[ \"joe \", \"home \",1\\],\\[ \"joe \", \"about \",2\\],\\[ \"joe \", \"career \",3\\],\\[ \"james \", \"home \",4\\],\\[ \"james \", \"cart \",5\\],\\[ \"james \", \"maps \",6\\],\\[ \"james \", \"home \",7\\],\\[ \"mary \", \"home \",8\\],\\[ \"mary \", \"about \",9\\], and \\[ \"mary \", \"career \",10\\].\nThe pattern ( \"home \",  \"about \",  \"career \") has score 2 (joe and mary).\nThe pattern ( \"home \",  \"cart \",  \"maps \") has score 1 (james).\nThe pattern ( \"home \",  \"cart \",  \"home \") has score 1 (james).\nThe pattern ( \"home \",  \"maps \",  \"home \") has score 1 (james).\nThe pattern ( \"cart \",  \"maps \",  \"home \") has score 1 (james).\nThe pattern ( \"home \",  \"home \",  \"home \") has score 0 (no user visited home 3 times).\n\n",
                "**Example 2:**\n\n**Input:** username = \\[ \"ua \", \"ua \", \"ua \", \"ub \", \"ub \", \"ub \"\\], timestamp = \\[1,2,3,4,5,6\\], website = \\[ \"a \", \"b \", \"a \", \"a \", \"b \", \"c \"\\]\n**Output:** \\[ \"a \", \"b \", \"a \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= username.length <= 50`\n*   `1 <= username[i].length <= 10`\n*   `timestamp.length == username.length`\n*   `1 <= timestamp[i] <= 109`\n*   `website.length == username.length`\n*   `1 <= website[i].length <= 10`\n*   `username[i]` and `website[i]` consist of lowercase English letters.\n*   It is guaranteed that there is at least one user who visited at least three websites.\n*   All the tuples `[username[i], timestamp[i], website[i]]` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"joe\",\"joe\",\"joe\",\"james\",\"james\",\"james\",\"james\",\"mary\",\"mary\",\"mary\"],[1,2,3,4,5,6,7,8,9,10],[\"home\",\"about\",\"career\",\"home\",\"cart\",\"maps\",\"home\",\"home\",\"about\",\"career\"]",
                "output": "[\"home\",\"about\",\"career\"]"
            },
            {
                "input": "[\"ua\",\"ua\",\"ua\",\"ub\",\"ub\",\"ub\"],[1,2,3,4,5,6],[\"a\",\"b\",\"a\",\"a\",\"b\",\"c\"]",
                "output": "[\"a\",\"b\",\"a\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<String> mostVisitedPattern(String[] username, int[] timestamp, String[] website) {\n        int n = username.length;\n        List<String[]> visitingOrder = new ArrayList<>();\n        HashMap<String, List<Tuple<Integer, Integer>>> userVisits = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            userVisits.putIfAbsent(username[i], new ArrayList<>());\n            userVisits.get(username[i]).add(new Tuple<>(timestamp[i], i));\n        }\n        \n        for (Map.Entry<String, List<Tuple<Integer, Integer>>> entry : userVisits.entrySet()) {\n            Collections.sort(entry.getValue(), (a, b) -> a.x - b.x);\n            int m = entry.getValue().size();\n            for (int i = 0; i < m; i++) {\n                for (int j = i + 1; j < m; j++) {\n                    for (int k = j + 1; k < m; k++) {\n                        visitingOrder.add(new String[] {website[entry.getValue().get(i).y], website[entry.getValue().get(j).y], website[entry.getValue().get(k).y]});\n                    }\n                }\n            }\n        }\n        \n        Collections.sort(visitingOrder, (a, b) -> {\n           for (int i = 0; i < 3; i++) {\n               int cmp = a[i].compareTo(b[i]);\n               if (cmp != 0) {\n                   return cmp;\n               }\n           }\n           return 0;\n        });\n        \n        List<String> ans = Arrays.asList(visitingOrder.get(0));\n        int maxScore = 0, score = 1;\n\n        for (int i = 1; i < visitingOrder.size(); i++) {\n            if (Arrays.equals(visitingOrder.get(i), visitingOrder.get(i - 1))) {\n                score++;\n            } else {\n                score = 1;\n            }\n            \n            if (score > maxScore) {\n                maxScore = score;\n                ans = Arrays.asList(visitingOrder.get(i));\n            }\n        }\n        \n        return ans;\n    }\n\n    private static class Tuple<X, Y> {\n        X x;\n        Y y;\n\n        Tuple(X x, Y y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}\n```\n\n    \n    The algorithm first processes and groups the input data within the user_visits hashmap, mapping each username with a sorted list of their visited websites according to timestamps. Then, the visiting_order list is created by generating all possible triplets of visited websites by each user. After sorting the visiting_order list, we iterate over it to find the pattern with the highest count (score) and return this pattern as the output. Each implementation is done using the semantics and data structures available in their respective programming languages. In general, the overall flow of the algorithm is the same in all languages.\n    ",
        "python": "\n    ```python\nfrom typing import List\nfrom collections import defaultdict\nfrom itertools import combinations\n\nclass Solution:\n    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:\n        n = len(username)\n        visits = defaultdict(list)\n        \n        # user_visits: {user: [(timestamp, website),...]}\n        for i in range(n):\n            visits[username[i]].append((timestamp[i], website[i]))\n\n\n        for user in visits:\n            visits[user].sort()\n        \n        patterns = defaultdict(int)\n        \n        for user in visits:\n            websites = [web for _, web in visits[user]]\n            patterns_set = set(combinations(websites, 3))\n\n            for pattern in patterns_set:\n                patterns[pattern] += 1\n                \n        patterns = sorted(patterns.items(), key=lambda x: (-x[1], x[0]))\n        \n        return list(patterns[0][0])\n```\n\n    \n    The algorithm first processes and groups the input data within the user_visits hashmap, mapping each username with a sorted list of their visited websites according to timestamps. Then, the visiting_order list is created by generating all possible triplets of visited websites by each user. After sorting the visiting_order list, we iterate over it to find the pattern with the highest count (score) and return this pattern as the output. Each implementation is done using the semantics and data structures available in their respective programming languages. In general, the overall flow of the algorithm is the same in all languages.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> mostVisitedPattern(vector<string>& username, vector<int>& timestamp, vector<string>& website) {\n        int n = username.size();\n        vector<vector<string>> visiting_order(n, vector<string>(3));\n        unordered_map<string, vector<pair<int, int>>> user_visits;\n\n        for (int i = 0; i < n; i++) {\n            user_visits[username[i]].push_back({timestamp[i], i});\n        }\n        \n        for (auto& p : user_visits) {\n            sort(p.second.begin(), p.second.end());\n            int m = p.second.size();\n            for (int i = 0; i < m; i++) {\n                for (int j = i + 1; j < m; j++) {\n                    for (int k = j + 1; k < m; k++) {\n                        visiting_order.push_back({website[p.second[i].second], website[p.second[j].second], website[p.second[k].second]});\n                    }\n                }\n            }\n        }\n        \n        sort(visiting_order.begin(), visiting_order.end());\n        \n        vector<string> ans = visiting_order[0];\n        int max_score = 0, score = 1;\n\n        for (int i = 1; i < visiting_order.size(); i++) {\n            if (visiting_order[i] == visiting_order[i-1]) {\n                score++;\n            } else {\n                score = 1;\n            }\n            \n            if (score > max_score) {\n                max_score = score;\n                ans = visiting_order[i];\n            }\n        }\n        \n        return ans;\n    }\n};\n```\n\n    \n    The algorithm first processes and groups the input data within the user_visits hashmap, mapping each username with a sorted list of their visited websites according to timestamps. Then, the visiting_order list is created by generating all possible triplets of visited websites by each user. After sorting the visiting_order list, we iterate over it to find the pattern with the highest count (score) and return this pattern as the output. Each implementation is done using the semantics and data structures available in their respective programming languages. In general, the overall flow of the algorithm is the same in all languages.\n    ",
        "js": "\n    ```javascript\nvar mostVisitedPattern = function(username, timestamp, website) {\n    let n = username.length;\n    let visitingOrder = [];\n    let userVisits = new Map();\n\n    for (let i = 0; i < n; i++) {\n        if (!userVisits.has(username[i])) {\n            userVisits.set(username[i], []);\n        }\n        userVisits.get(username[i]).push({time: timestamp[i], index: i});\n    }\n    \n    for (let visits of userVisits.values()) {\n        visits.sort((a, b) => a.time - b.time);\n        let m = visits.length;\n        for (let i = 0; i < m; i++) {\n            for (let j = i + 1; j < m; j++) {\n                for (let k = j + 1; k < m; k++) {\n                    visitingOrder.push([website[visits[i].index], website[visits[j].index], website[visits[k].index]]);\n                }\n            }\n        }\n    }\n    \n    visitingOrder.sort();\n    \n    let ans = visitingOrder[0];\n    let maxScore = 0, score = 1;\n\n    for (let i = 1; i < visitingOrder.length; i++) {\n        if (visitingOrder[i].toString() === visitingOrder[i-1].toString()) {\n            score++;\n        } else {\n            score = 1;\n        }\n        \n        if (score > maxScore) {\n            maxScore = score;\n            ans = visitingOrder[i];\n        }\n    }\n    \n    return ans;\n};\n```\n\n    \n    The algorithm first processes and groups the input data within the user_visits hashmap, mapping each username with a sorted list of their visited websites according to timestamps. Then, the visiting_order list is created by generating all possible triplets of visited websites by each user. After sorting the visiting_order list, we iterate over it to find the pattern with the highest count (score) and return this pattern as the output. Each implementation is done using the semantics and data structures available in their respective programming languages. In general, the overall flow of the algorithm is the same in all languages.\n    "
    },
    {
        "id": 189,
        "title": "String Transforms Into Another String",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `str1` and `str2` of the same length, determine whether you can transform `str1` into `str2` by doing **zero or more** _conversions_.\n\nIn one conversion you can convert **all** occurrences of one character in `str1` to **any** other lowercase English character.\n\nReturn `true` if and only if you can transform `str1` into `str2`.",
            "examples": [
                "**Example 1:**\n\n**Input:** str1 =  \"aabcc \", str2 =  \"ccdee \"\n**Output:** true\n**Explanation:** Convert 'c' to 'e' then 'b' to 'd' then 'a' to 'c'. Note that the order of conversions matter.\n\n",
                "**Example 2:**\n\n**Input:** str1 =  \"leetcode \", str2 =  \"codeleet \"\n**Output:** false\n**Explanation:** There is no way to transform str1 to str2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= str1.length == str2.length <= 104`\n*   `str1` and `str2` contain only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aabcc\",\"ccdee\"",
                "output": "true"
            },
            {
                "input": "\"leetcode\",\"codeleet\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nboolean canConvert(String str1, String str2) {\n    if (str1.equals(str2)) return true;\n    HashMap<Character, Character> conversion = new HashMap<>();\n    for (int i = 0; i < str1.length(); ++i) {\n        if (conversion.containsKey(str1.charAt(i)) && conversion.get(str1.charAt(i)) != str2.charAt(i)) {\n            return false;\n        }\n        conversion.put(str1.charAt(i), str2.charAt(i));\n    }\n    return new HashSet<Character>(Arrays.asList(str2.toCharArray())).size() < 26;\n}\n```\n\n    \n    The algorithm first checks if the given strings `str1` and `str2` are already equal or not. If yes, then it returns true, else it checks for the conversion map. \n\nInitially, create a hash map to store the character conversions from `str1` to `str2`. Iterate through both the strings character by character.\n\nWhenever a new character in `str1` is found, add it to the hash map with its corresponding character in `str2`. If the character from `str1` already exists as a key in the hash map, and its value does not match the corresponding character in `str2`, return false.\n\nFinally, find the number of unique characters in `str2`. If it is less than 26, then return true. Else, return false. The reason for this check is that we cannot perform any more conversions on `str1` if all 26 English lowercase characters are already used in `str2`.\n    ",
        "python": "\n    ```python\ndef canConvert(str1, str2):\n    if str1 == str2: return True;\n    conversion = {}\n    for c1, c2 in zip(str1, str2):\n        if c1 in conversion and conversion[c1] != c2: return False\n        conversion[c1] = c2\n    return len(set(str2)) < 26\n```\n\n    \n    The algorithm first checks if the given strings `str1` and `str2` are already equal or not. If yes, then it returns true, else it checks for the conversion map. \n\nInitially, create a hash map to store the character conversions from `str1` to `str2`. Iterate through both the strings character by character.\n\nWhenever a new character in `str1` is found, add it to the hash map with its corresponding character in `str2`. If the character from `str1` already exists as a key in the hash map, and its value does not match the corresponding character in `str2`, return false.\n\nFinally, find the number of unique characters in `str2`. If it is less than 26, then return true. Else, return false. The reason for this check is that we cannot perform any more conversions on `str1` if all 26 English lowercase characters are already used in `str2`.\n    ",
        "c++": "\n    ```cpp\nbool canConvert(std::string str1, std::string str2) {\n    if (str1 == str2) return true;\n    std::unordered_map<char, char> conversion;\n    for (int i = 0; i < str1.length(); ++i) {\n        if (conversion.count(str1[i]) && conversion[str1[i]] != str2[i]) return false;\n        conversion[str1[i]] = str2[i];\n    }\n    return std::unordered_set<char>(str2.begin(), str2.end()).size() < 26;\n}\n```\n\n    \n    The algorithm first checks if the given strings `str1` and `str2` are already equal or not. If yes, then it returns true, else it checks for the conversion map. \n\nInitially, create a hash map to store the character conversions from `str1` to `str2`. Iterate through both the strings character by character.\n\nWhenever a new character in `str1` is found, add it to the hash map with its corresponding character in `str2`. If the character from `str1` already exists as a key in the hash map, and its value does not match the corresponding character in `str2`, return false.\n\nFinally, find the number of unique characters in `str2`. If it is less than 26, then return true. Else, return false. The reason for this check is that we cannot perform any more conversions on `str1` if all 26 English lowercase characters are already used in `str2`.\n    ",
        "js": "\n    ```javascript\nfunction canConvert(str1, str2) {\n    if (str1 === str2) return true;\n    const conversion = new Map();\n    for (let i = 0; i < str1.length; ++i) {\n        if (conversion.has(str1[i]) && conversion.get(str1[i]) !== str2[i]) return false;\n        conversion.set(str1[i], str2[i]);\n    }\n    return new Set(str2).size < 26;\n}\n```\n\n    \n    The algorithm first checks if the given strings `str1` and `str2` are already equal or not. If yes, then it returns true, else it checks for the conversion map. \n\nInitially, create a hash map to store the character conversions from `str1` to `str2`. Iterate through both the strings character by character.\n\nWhenever a new character in `str1` is found, add it to the hash map with its corresponding character in `str2`. If the character from `str1` already exists as a key in the hash map, and its value does not match the corresponding character in `str2`, return false.\n\nFinally, find the number of unique characters in `str2`. If it is less than 26, then return true. Else, return false. The reason for this check is that we cannot perform any more conversions on `str1` if all 26 English lowercase characters are already used in `str2`.\n    "
    },
    {
        "id": 190,
        "title": "Single-Row Keyboard",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a special keyboard with **all keys in a single row**.\n\nGiven a string `keyboard` of length `26` indicating the layout of the keyboard (indexed from `0` to `25`). Initially, your finger is at index `0`. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index `i` to index `j` is `|i - j|`.\n\nYou want to type a string `word`. Write a function to calculate how much time it takes to type it with one finger.",
            "examples": [
                "**Example 1:**\n\n**Input:** keyboard =  \"abcdefghijklmnopqrstuvwxyz \", word =  \"cba \"\n**Output:** 4\n**Explanation:** The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.\nTotal time = 2 + 1 + 1 = 4. \n\n",
                "**Example 2:**\n\n**Input:** keyboard =  \"pqrstuvwxyzabcdefghijklmno \", word =  \"leetcode \"\n**Output:** 73"
            ],
            "constraints": "**Constraints:**\n\n*   `keyboard.length == 26`\n*   `keyboard` contains each English lowercase letter exactly once in some order.\n*   `1 <= word.length <= 104`\n*   `word[i]` is an English lowercase letter.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcdefghijklmnopqrstuvwxyz\",\"cba\"",
                "output": "4"
            },
            {
                "input": "\"pqrstuvwxyzabcdefghijklmno\",\"leetcode\"",
                "output": "73"
            }
        ],
        "java": "\n    ```java\npublic int calculateTime(String keyboard, String word) {\n    int time = 0;\n    int prevIndex = 0;\n    Map<Character, Integer> charToIndex = new HashMap<>();\n\n    for (int i = 0; i < keyboard.length(); i++) {\n        charToIndex.put(keyboard.charAt(i), i);\n    }\n\n    for (char c : word.toCharArray()) {\n        time += Math.abs(charToIndex.get(c) - prevIndex);\n        prevIndex = charToIndex.get(c);\n    }\n\n    return time;\n}\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "python": "\n    ```python\ndef calculate_time(keyboard: str, word: str) -> int:\n    time = 0\n    prev_index = 0\n    char_to_index = {char: i for i, char in enumerate(keyboard)}\n\n    for c in word:\n        time += abs(char_to_index[c] - prev_index)\n        prev_index = char_to_index[c]\n\n    return time\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "c++": "\n    ```cpp\nint calculateTime(std::string keyboard, std::string word) {\n    int time = 0;\n    int prev_index = 0;\n    std::unordered_map<char, int> char_to_index;\n\n    for (int i = 0; i < keyboard.length(); i++) {\n        char_to_index[keyboard[i]] = i;\n    }\n\n    for (char c : word) {\n        time += std::abs(char_to_index[c] - prev_index);\n        prev_index = char_to_index[c];\n    }\n\n    return time;\n}\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "js": "\n    ```javascript\nfunction calculateTime(keyboard, word) {\n    let time = 0;\n    let prevIndex = 0;\n    let charToIndex = {};\n\n    for (let i = 0; i < keyboard.length; i++) {\n        charToIndex[keyboard[i]] = i;\n    }\n\n    for (let c of word) {\n        time += Math.abs(charToIndex[c] - prevIndex);\n        prevIndex = charToIndex[c];\n    }\n\n    return time;\n}\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    "
    },
    {
        "id": 191,
        "title": "Design File System",
        "difficulty": "Medium",
        "content": {
            "problem": "You are asked to design a file system that allows you to create new paths and associate them with different values.\n\nThe format of a path is one or more concatenated strings of the form: `/` followed by one or more lowercase English letters. For example, \"`/leetcode \"` and \"`/leetcode/problems \"` are valid paths while an empty string `\" \"` and `\"/ \"` are not.\n\nImplement the `FileSystem` class:\n\n*   `bool createPath(string path, int value)` Creates a new `path` and associates a `value` to it if possible and returns `true`. Returns `false` if the path **already exists** or its parent path **doesn't exist**.\n*   `int get(string path)` Returns the value associated with `path` or returns `-1` if the path doesn't exist.",
            "examples": [
                "**Example 1:**\n\n**Input:** \n\\[ \"FileSystem \", \"createPath \", \"get \"\\]\n\\[\\[\\],\\[ \"/a \",1\\],\\[ \"/a \"\\]\\]\n**Output:** \n\\[null,true,1\\]\n**Explanation:** \nFileSystem fileSystem = new FileSystem();\n\nfileSystem.createPath( \"/a \", 1); // return true\nfileSystem.get( \"/a \"); // return 1\n\n",
                "**Example 2:**\n\n**Input:** \n\\[ \"FileSystem \", \"createPath \", \"createPath \", \"get \", \"createPath \", \"get \"\\]\n\\[\\[\\],\\[ \"/leet \",1\\],\\[ \"/leet/code \",2\\],\\[ \"/leet/code \"\\],\\[ \"/c/d \",1\\],\\[ \"/c \"\\]\\]\n**Output:** \n\\[null,true,true,2,false,-1\\]\n**Explanation:** \nFileSystem fileSystem = new FileSystem();\n\nfileSystem.createPath( \"/leet \", 1); // return true\nfileSystem.createPath( \"/leet/code \", 2); // return true\nfileSystem.get( \"/leet/code \"); // return 2\nfileSystem.createPath( \"/c/d \", 1); // return false because the parent path  \"/c \" doesn't exist.\nfileSystem.get( \"/c \"); // return -1 because this path doesn't exist."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= path.length <= 100`\n*   `1 <= value <= 109`\n*   Each `path` is **valid** and consists of lowercase English letters and `'/'`.\n*   At most `104` calls **in total** will be made to `createPath` and `get`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],]]",
                "output": "\n[null,true,1]"
            },
            {
                "input": "]\n],],],],],]]",
                "output": "\n[null,true,true,2,false,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass FileSystem {\n    private final HashMap<String, Integer> pathMap;\n\n    public FileSystem() {\n        pathMap = new HashMap<>();\n    }\n\n    public boolean createPath(String path, int value) {\n        if (pathMap.containsKey(path)) return false;\n        String parentPath = path.substring(0, path.lastIndexOf('/'));\n        if (!parentPath.isEmpty() && !pathMap.containsKey(parentPath)) return false;\n        pathMap.put(path, value);\n        return true;\n    }\n\n    public int get(String path) {\n        return pathMap.getOrDefault(path, -1);\n    }\n}\n```\n    \n    The algorithm for implementing the FileSystem class is relatively straightforward. It involves implementing a map (i.e., a HashMap, unordered_map, or a dictionary) to store the paths and their associated values. For the `createPath` method, we first check if the given path already exists in the map. If it does, then we return `false`. If it does not exist, we then extract the parent path of the input path and check if it exists in the map. If the parent path does not exist, we return `false`; otherwise, we insert the path and its associated value into the map and return `true`. \n\nThe `get` method is straightforward; we simply return the value associated with the given path from the map, or return `-1` if the path does not exist.\n\nBoth methods have time complexity O(1) because map operations (i.e., insert, find, get) take constant time on average.\n    ",
        "python": "\n    ```python\nclass FileSystem:\n    def __init__(self):\n        self.path_map = {}\n\n    def create_path(self, path: str, value: int) -> bool:\n        if path in self.path_map:\n            return False\n        parent_path = path[:path.rfind('/')]\n        if parent_path and parent_path not in self.path_map:\n            return False\n        self.path_map[path] = value\n        return True\n\n    def get(self, path: str) -> int:\n        return self.path_map.get(path, -1)\n```\n    \n    The algorithm for implementing the FileSystem class is relatively straightforward. It involves implementing a map (i.e., a HashMap, unordered_map, or a dictionary) to store the paths and their associated values. For the `createPath` method, we first check if the given path already exists in the map. If it does, then we return `false`. If it does not exist, we then extract the parent path of the input path and check if it exists in the map. If the parent path does not exist, we return `false`; otherwise, we insert the path and its associated value into the map and return `true`. \n\nThe `get` method is straightforward; we simply return the value associated with the given path from the map, or return `-1` if the path does not exist.\n\nBoth methods have time complexity O(1) because map operations (i.e., insert, find, get) take constant time on average.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass FileSystem {\npublic:\n    unordered_map<string, int> pathMap;\n\n    bool createPath(string path, int value) {\n        if (pathMap.count(path) != 0) return false;\n        string parentPath = path.substr(0, path.find_last_of('/'));\n        if (!parentPath.empty() && pathMap.count(parentPath) == 0) return false;\n        pathMap[path] = value;\n        return true;\n    }\n\n    int get(string path) {\n        if (pathMap.count(path) == 0) return -1;\n        return pathMap[path];\n    }\n};\n```\n    \n    The algorithm for implementing the FileSystem class is relatively straightforward. It involves implementing a map (i.e., a HashMap, unordered_map, or a dictionary) to store the paths and their associated values. For the `createPath` method, we first check if the given path already exists in the map. If it does, then we return `false`. If it does not exist, we then extract the parent path of the input path and check if it exists in the map. If the parent path does not exist, we return `false`; otherwise, we insert the path and its associated value into the map and return `true`. \n\nThe `get` method is straightforward; we simply return the value associated with the given path from the map, or return `-1` if the path does not exist.\n\nBoth methods have time complexity O(1) because map operations (i.e., insert, find, get) take constant time on average.\n    ",
        "js": "\n    ```javascript\nclass FileSystem {\n    constructor() {\n        this.pathMap = new Map();\n    }\n\n    createPath(path, value) {\n        if (this.pathMap.has(path)) return false;\n        const parentPath = path.substring(0, path.lastIndexOf('/'));\n        if (parentPath !== \"\" && !this.pathMap.has(parentPath)) return false;\n        this.pathMap.set(path, value);\n        return true;\n    }\n\n    get(path) {\n        return this.pathMap.get(path) || -1;\n    }\n}\n```\n    \n    The algorithm for implementing the FileSystem class is relatively straightforward. It involves implementing a map (i.e., a HashMap, unordered_map, or a dictionary) to store the paths and their associated values. For the `createPath` method, we first check if the given path already exists in the map. If it does, then we return `false`. If it does not exist, we then extract the parent path of the input path and check if it exists in the map. If the parent path does not exist, we return `false`; otherwise, we insert the path and its associated value into the map and return `true`. \n\nThe `get` method is straightforward; we simply return the value associated with the given path from the map, or return `-1` if the path does not exist.\n\nBoth methods have time complexity O(1) because map operations (i.e., insert, find, get) take constant time on average.\n    "
    },
    {
        "id": 192,
        "title": "Minimum Cost to Connect Sticks",
        "difficulty": "Medium",
        "content": {
            "problem": "You have some number of sticks with positive integer lengths. These lengths are given as an array `sticks`, where `sticks[i]` is the length of the `ith` stick.\n\nYou can connect any two sticks of lengths `x` and `y` into one stick by paying a cost of `x + y`. You must connect all the sticks until there is only one stick remaining.\n\nReturn _the minimum cost of connecting all the given sticks into one stick in this way_.",
            "examples": [
                "**Example 1:**\n\n**Input:** sticks = \\[2,4,3\\]\n**Output:** 14\n**Explanation:** You start with sticks = \\[2,4,3\\].\n1. Combine sticks 2 and 3 for a cost of 2 + 3 = 5. Now you have sticks = \\[5,4\\].\n2. Combine sticks 5 and 4 for a cost of 5 + 4 = 9. Now you have sticks = \\[9\\].\nThere is only one stick left, so you are done. The total cost is 5 + 9 = 14.\n\n",
                "**Example 2:**\n\n**Input:** sticks = \\[1,8,3,5\\]\n**Output:** 30\n**Explanation:** You start with sticks = \\[1,8,3,5\\].\n1. Combine sticks 1 and 3 for a cost of 1 + 3 = 4. Now you have sticks = \\[4,8,5\\].\n2. Combine sticks 4 and 5 for a cost of 4 + 5 = 9. Now you have sticks = \\[9,8\\].\n3. Combine sticks 9 and 8 for a cost of 9 + 8 = 17. Now you have sticks = \\[17\\].\nThere is only one stick left, so you are done. The total cost is 4 + 9 + 17 = 30.\n\n",
                "**Example 3:**\n\n**Input:** sticks = \\[5\\]\n**Output:** 0\n**Explanation:** There is only one stick, so you don't need to do anything. The total cost is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sticks.length <= 104`\n*   `1 <= sticks[i] <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,4,3]",
                "output": "14"
            },
            {
                "input": "[1,8,3,5]",
                "output": "30"
            },
            {
                "input": "[5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int connectSticks(int[] sticks) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    for (int stick : sticks) {\n        minHeap.offer(stick);\n    }\n    \n    int cost = 0;\n    while (minHeap.size() > 1) {\n        int first = minHeap.poll();\n        int second = minHeap.poll();\n        cost += first + second;\n        minHeap.offer(first + second);\n    }\n    return cost;\n}\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef connectSticks(sticks):\n    heapq.heapify(sticks)\n    cost = 0\n    while len(sticks) > 1:\n        first = heapq.heappop(sticks)\n        second = heapq.heappop(sticks)\n        cost += first + second\n        heapq.heappush(sticks, first + second)\n    return cost\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint connectSticks(std::vector<int>& sticks) {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n\n    for (int stick : sticks) {\n        min_heap.push(stick);\n    }\n\n    int cost = 0;\n    while (min_heap.size() > 1) {\n        int first = min_heap.top();\n        min_heap.pop();\n        int second = min_heap.top();\n        min_heap.pop();\n        cost += first + second;\n        min_heap.push(first + second);\n    }\n    return cost;\n}\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    ",
        "js": "\n    ```javascript\nfunction connectSticks(sticks) {\n    const minHeap = new MinHeap(sticks);\n    \n    let cost = 0;\n    while (minHeap.size() > 1) {\n        const first = minHeap.poll();\n        const second = minHeap.poll();\n        cost += first + second;\n        minHeap.offer(first + second);\n    }\n    return cost;\n}\n\nclass MinHeap {\n    constructor(items) {\n        this.heap = [];\n        for (const item of items) {\n            this.offer(item);\n        }\n    }\n    \n    offer(value) {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    \n    poll() {\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return min;\n    }\n    \n    size() {\n        return this.heap.length;\n    }\n    \n    bubbleUp(index) {\n        if (index === 0) return;\n        const parentIndex = Math.floor((index - 1) / 2);\n        if (this.heap[parentIndex] > this.heap[index]) {\n            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];\n            this.bubbleUp(parentIndex);\n        }\n    }\n    \n    bubbleDown(index) {\n        const leftChildIndex = 2 * index + 1;\n        const rightChildIndex = 2 * index + 2;\n        \n        let minIndex = index;\n        if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[minIndex]) {\n            minIndex = leftChildIndex;\n        }\n        \n        if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[minIndex]) {\n            minIndex = rightChildIndex;\n        }\n        \n        if (minIndex !== index) {\n            [this.heap[minIndex], this.heap[index]] = [this.heap[index], this.heap[minIndex]];\n            this.bubbleDown(minIndex);\n        }\n    }\n}\n```\n    \n    The algorithm works by turning the input array `sticks` into a min heap, a data structure that allows for efficient retrieval of the smallest element in the heap. The algorithm then iterates until there is only one stick left, removing the two smallest sticks from the heap, combining them and adding their sum back into the heap. The cost of combining the two sticks is added to the total cost. After all the sticks have been combined, the function returns the total cost. The algorithm has a time complexity of O(n log n) where n is the number of elements in the input array, as each operation in the heap takes O(log n) time, and we perform about n operations.\n    "
    },
    {
        "id": 193,
        "title": "Optimize Water Distribution in a Village",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` houses in a village. We want to supply water for all the houses by building wells and laying pipes.\n\nFor each house `i`, we can either build a well inside it directly with cost `wells[i - 1]` (note the `-1` due to **0-indexing**), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array `pipes` where each `pipes[j] = [house1j, house2j, costj]` represents the cost to connect `house1j` and `house2j` together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.\n\nReturn _the minimum total cost to supply water to all houses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, wells = \\[1,2,2\\], pipes = \\[\\[1,2,1\\],\\[2,3,1\\]\\]\n**Output:** 3\n**Explanation:** The image shows the costs of connecting houses using pipes.\nThe best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, wells = \\[1,1\\], pipes = \\[\\[1,2,1\\],\\[1,2,2\\]\\]\n**Output:** 2\n**Explanation:** We can supply water with cost two using one of the three options:\nOption 1:\n  - Build a well inside house 1 with cost 1.\n  - Build a well inside house 2 with cost 1.\nThe total cost will be 2.\nOption 2:\n  - Build a well inside house 1 with cost 1.\n  - Connect house 2 with house 1 with cost 1.\nThe total cost will be 2.\nOption 3:\n  - Build a well inside house 2 with cost 1.\n  - Connect house 1 with house 2 with cost 1.\nThe total cost will be 2.\nNote that we can connect houses 1 and 2 with cost 1 or with cost 2 but we will always choose **the cheapest option**."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`\n*   `wells.length == n`\n*   `0 <= wells[i] <= 105`\n*   `1 <= pipes.length <= 104`\n*   `pipes[j].length == 3`\n*   `1 <= house1j, house2j <= n`\n*   `0 <= costj <= 105`\n*   `house1j != house2j`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,[1,2,2],[[1,2,1],[2,3,1]]",
                "output": "3"
            },
            {
                "input": "2,[1,1],[[1,2,1],[1,2,2]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic void duplicateZeros(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] == 0) {\n            for (int j = n - 2; j > i; j--) {\n                arr[j + 1] = arr[j];\n            }\n            arr[i + 1] = 0;\n            i++;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array from left to right. Whenever a zero is found, it shifts all the elements after that zero one position to the right, starting from the second-to-last element, up to the element that is right after the zero. Then, it sets the next array index (i+1) to zero, effectively duplicating the zero, and increments i by one to skip the duplicated zero. This process repeats for each zero found in the array, until the end is reached.\n    ",
        "python": "\n    ```python\ndef duplicateZeros(arr):\n    n = len(arr)\n    i = 0\n    while i < n - 1:\n        if arr[i] == 0:\n            for j in range(n - 2, i, -1):\n                arr[j + 1] = arr[j]\n            arr[i + 1] = 0\n            i += 2\n        else:\n            i += 1\n```\n    \n    The algorithm iterates through the input array from left to right. Whenever a zero is found, it shifts all the elements after that zero one position to the right, starting from the second-to-last element, up to the element that is right after the zero. Then, it sets the next array index (i+1) to zero, effectively duplicating the zero, and increments i by one to skip the duplicated zero. This process repeats for each zero found in the array, until the end is reached.\n    ",
        "c++": "\n    ```cpp\nvoid duplicateZeros(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] == 0) {\n            for (int j = n - 2; j > i; j--) {\n                arr[j + 1] = arr[j];\n            }\n            arr[i + 1] = 0;\n            i++;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array from left to right. Whenever a zero is found, it shifts all the elements after that zero one position to the right, starting from the second-to-last element, up to the element that is right after the zero. Then, it sets the next array index (i+1) to zero, effectively duplicating the zero, and increments i by one to skip the duplicated zero. This process repeats for each zero found in the array, until the end is reached.\n    ",
        "js": "\n    ```javascript\nfunction duplicateZeros(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        if (arr[i] === 0) {\n            for (let j = n - 2; j > i; j--) {\n                arr[j + 1] = arr[j];\n            }\n            arr[i + 1] = 0;\n            i++;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array from left to right. Whenever a zero is found, it shifts all the elements after that zero one position to the right, starting from the second-to-last element, up to the element that is right after the zero. Then, it sets the next array index (i+1) to zero, effectively duplicating the zero, and increments i by one to skip the duplicated zero. This process repeats for each zero found in the array, until the end is reached.\n    "
    },
    {
        "id": 194,
        "title": "Diet Plan Performance",
        "difficulty": "Easy",
        "content": {
            "problem": "A dieter consumes `calories[i]` calories on the `i`\\-th day.\n\nGiven an integer `k`, for **every** consecutive sequence of `k` days (`calories[i], calories[i+1], ..., calories[i+k-1]` for all `0 <= i <= n-k`), they look at _T_, the total calories consumed during that sequence of `k` days (`calories[i] + calories[i+1] + ... + calories[i+k-1]`):\n\n*   If `T < lower`, they performed poorly on their diet and lose 1 point;\n*   If `T > upper`, they performed well on their diet and gain 1 point;\n*   Otherwise, they performed normally and there is no change in points.\n\nInitially, the dieter has zero points. Return the total number of points the dieter has after dieting for `calories.length` days.\n\nNote that the total points can be negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** calories = \\[1,2,3,4,5\\], k = 1, lower = 3, upper = 3\n**Output:** 0\n**Explanation**: Since k = 1, we consider each element of the array separately and compare it to lower and upper.\ncalories\\[0\\] and calories\\[1\\] are less than lower so 2 points are lost.\ncalories\\[3\\] and calories\\[4\\] are greater than upper so 2 points are gained.\n\n",
                "**Example 2:**\n\n**Input:** calories = \\[3,2\\], k = 2, lower = 0, upper = 1\n**Output:** 1\n**Explanation**: Since k = 2, we consider subarrays of length 2.\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\n\n",
                "**Example 3:**\n\n**Input:** calories = \\[6,5,0,0\\], k = 2, lower = 1, upper = 5\n**Output:** 0\n**Explanation**:\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\nlower <= calories\\[1\\] + calories\\[2\\] <= upper so no change in points.\ncalories\\[2\\] + calories\\[3\\] < lower so 1 point is lost."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= calories.length <= 10^5`\n*   `0 <= calories[i] <= 20000`\n*   `0 <= lower <= upper`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5],1,3,3",
                "output": "0"
            },
            {
                "input": "[3,2],2,0,1",
                "output": "1"
            },
            {
                "input": "[6,5,0,0],2,1,5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int dietPlanPerformance(int[] calories, int k, int lower, int upper) {\n    int points = 0;\n    int T = 0;\n\n    for(int i = 0; i < calories.length; i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "python": "\n    ```python\ndef dietPlanPerformance(calories, k, lower, upper):\n    points = 0\n    T = 0\n\n    for i in range(len(calories)):\n        T += calories[i]\n        if i >= k:\n            T -= calories[i-k]\n        if i >= k-1:\n            if T < lower: points -= 1\n            if T > upper: points += 1\n\n    return points\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "c++": "\n    ```cpp\nint dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) {\n    int points = 0;\n    int T = 0;\n\n    for(int i = 0; i < calories.size(); i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "js": "\n    ```javascript\nfunction dietPlanPerformance(calories, k, lower, upper) {\n    let points = 0;\n    let T = 0;\n\n    for(let i = 0; i < calories.length; i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    "
    },
    {
        "id": 195,
        "title": "Count Substrings with Only One Distinct Letter",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the number of substrings that have only **one distinct** letter_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaaba \"\n**Output:** 8\n**Explanation:** The substrings with one distinct letter are  \"aaa \",  \"aa \",  \"a \",  \"b \".\n \"aaa \" occurs 1 time.\n \"aa \" occurs 2 times.\n \"a \" occurs 4 times.\n \"b \" occurs 1 time.\nSo the answer is 1 + 2 + 4 + 1 = 8.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaaaaaaaaa \"\n**Output:** 55"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aaaba\"",
                "output": "8"
            },
            {
                "input": "\"aaaaaaaaaa\"",
                "output": "55"
            }
        ],
        "java": "\n    ```java\npublic int countLetters(String s) {\n    int count = 0, current = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "python": "\n    ```python\ndef count_letters(s: str) -> int:\n    count = 0\n    current = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current += 1\n        else:\n            count += (current * (current + 1)) // 2\n            current = 1\n\n    count += (current * (current + 1)) // 2\n    return count\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "c++": "\n    ```cpp\nint countLetters(string s) {\n    int count = 0, current = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "js": "\n    ```javascript\nfunction countLetters(s) {\n    let count = 0;\n    let current = 1;\n\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    "
    },
    {
        "id": 196,
        "title": "Before and After Puzzle",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a list of `phrases`, generate a list of Before and After puzzles.\n\nA _phrase_ is a string that consists of lowercase English letters and spaces only. No space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase.\n\n_Before and After puzzles_ are phrases that are formed by merging two phrases where the **last word of the first phrase** is the same as the **first word of the second phrase**.\n\nReturn the Before and After puzzles that can be formed by every two phrases `phrases[i]` and `phrases[j]` where `i != j`. Note that the order of matching two phrases matters, we want to consider both orders.\n\nYou should return a list of **distinct** strings **sorted lexicographically**.",
            "examples": [
                "**Example 1:**\n\n**Input:** phrases = \\[ \"writing code \", \"code rocks \"\\]\n**Output:** \\[ \"writing code rocks \"\\]\n\n",
                "**Example 2:**\n\n**Input:** phrases = \\[ \"mission statement \",\n                   \"a quick bite to eat \",\n                   \"a chip off the old block \",\n                   \"chocolate bar \",\n                   \"mission impossible \",\n                   \"a man on a mission \",\n                   \"block party \",\n                   \"eat my words \",\n                   \"bar of soap \"\\]\n**Output:** \\[ \"a chip off the old block party \",\n          \"a man on a mission impossible \",\n          \"a man on a mission statement \",\n          \"a quick bite to eat my words \",\n          \"chocolate bar of soap \"\\]\n\n",
                "**Example 3:**\n\n**Input:** phrases = \\[ \"a \", \"b \", \"a \"\\]\n**Output:** \\[ \"a \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= phrases.length <= 100`\n*   `1 <= phrases[i].length <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"writingcode\",\"coderocks\"]",
                "output": "[\"writingcoderocks\"]"
            },
            {
                "input": "[\"missionstatement\",\n\"aquickbitetoeat\",\n\"achipofftheoldblock\",\n\"chocolatebar\",\n\"missionimpossible\",\n\"amanonamission\",\n\"blockparty\",\n\"eatmywords\",\n\"barofsoap\"]",
                "output": "[\"achipofftheoldblockparty\",\n\"amanonamissionimpossible\",\n\"amanonamissionstatement\",\n\"aquickbitetoeatmywords\",\n\"chocolatebarofsoap\"]"
            },
            {
                "input": "[\"a\",\"b\",\"a\"]",
                "output": "[\"a\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> beforeAndAfterPuzzles(String[] phrases) {\n    Map<String, Set<String>> firstWordMap = new HashMap<>();\n    Set<String> result = new TreeSet<>();\n\n    for (String phrase : phrases) {\n        String firstWord = phrase.substring(0, phrase.indexOf(' '));\n        firstWordMap.putIfAbsent(firstWord, new HashSet<>());\n        firstWordMap.get(firstWord).add(phrase);\n    }\n\n    for (String phrase : phrases) {\n        String lastWord = phrase.substring(phrase.lastIndexOf(' ') + 1);\n        if (firstWordMap.containsKey(lastWord)) {\n            for (String curPhrase : firstWordMap.get(lastWord)) {\n                if (!phrase.equals(curPhrase)) {\n                    result.add(phrase + curPhrase.substring(curPhrase.indexOf(' ')));\n                }\n            }\n        }\n    }\n\n    return new ArrayList<>(result);\n}\n```\n    \n    1. Create a mapping of first words to their corresponding phrases.\n2. For each phrase, check if the last word is a key in the mapping, then iterate through the phrases that have the last word as their first word.\n3. If the current phrase and the original phrase are not the same, merge the phrases to create a puzzle and add it to the result set.\n4. Convert the result set to a list/array, sort it and return it.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef beforeAndAfterPuzzles(phrases):\n    first_word_map = defaultdict(set)\n    result = set()\n\n    for phrase in phrases:\n        first_word = phrase.split(' ')[0]\n        first_word_map[first_word].add(phrase)\n\n    for phrase in phrases:\n        last_word = phrase.split(' ')[-1]\n        if last_word in first_word_map:\n            for cur_phrase in first_word_map[last_word]:\n                if phrase != cur_phrase:\n                    result.add(phrase + cur_phrase[cur_phrase.index(' '):])\n\n    return sorted(list(result))\n```\n    \n    1. Create a mapping of first words to their corresponding phrases.\n2. For each phrase, check if the last word is a key in the mapping, then iterate through the phrases that have the last word as their first word.\n3. If the current phrase and the original phrase are not the same, merge the phrases to create a puzzle and add it to the result set.\n4. Convert the result set to a list/array, sort it and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <set>\n\nstd::vector<std::string> beforeAndAfterPuzzles(std::vector<std::string>& phrases) {\n    std::unordered_map<std::string, std::set<std::string>> firstWordMap;\n    std::set<std::string> result;\n\n    for (const std::string& phrase : phrases) {\n        std::string firstWord = phrase.substr(0, phrase.find(' '));\n        if (firstWordMap.find(firstWord) != firstWordMap.end()) {\n            firstWordMap[firstWord].insert(phrase);\n        } else {\n            firstWordMap[firstWord] = {phrase};\n        }\n    }\n\n    for (const std::string& phrase : phrases) {\n        std::string lastWord = phrase.substr(phrase.rfind(' ') + 1);\n        if (firstWordMap.find(lastWord) != firstWordMap.end()) {\n            for (const std::string& curPhrase : firstWordMap[lastWord]) {\n                if (phrase != curPhrase) {\n                    result.insert(phrase + curPhrase.substr(curPhrase.find(' ')));\n                }\n            }\n        }\n    }\n\n    return std::vector<std::string>(result.begin(), result.end());\n}\n```\n    \n    1. Create a mapping of first words to their corresponding phrases.\n2. For each phrase, check if the last word is a key in the mapping, then iterate through the phrases that have the last word as their first word.\n3. If the current phrase and the original phrase are not the same, merge the phrases to create a puzzle and add it to the result set.\n4. Convert the result set to a list/array, sort it and return it.\n    ",
        "js": "\n    ```javascript\nfunction beforeAndAfterPuzzles(phrases) {\n    const firstWordMap = new Map();\n    const result = new Set();\n\n    for (const phrase of phrases) {\n        const firstWord = phrase.split(' ')[0];\n        if (!firstWordMap.has(firstWord)) {\n            firstWordMap.set(firstWord, new Set());\n        }\n        firstWordMap.get(firstWord).add(phrase);\n    }\n\n    for (const phrase of phrases) {\n        const lastWord = phrase.split(' ').pop();\n        if (firstWordMap.has(lastWord)) {\n            for (const curPhrase of firstWordMap.get(lastWord)) {\n                if (phrase !== curPhrase) {\n                    result.add(phrase + curPhrase.slice(curPhrase.indexOf(' ')));\n                }\n            }\n        }\n    }\n\n    return Array.from(result).sort();\n}\n```\n    \n    1. Create a mapping of first words to their corresponding phrases.\n2. For each phrase, check if the last word is a key in the mapping, then iterate through the phrases that have the last word as their first word.\n3. If the current phrase and the original phrase are not the same, merge the phrases to create a puzzle and add it to the result set.\n4. Convert the result set to a list/array, sort it and return it.\n    "
    },
    {
        "id": 197,
        "title": "Shortest Distance to Target Color",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `colors`, in which there are three colors: `1`, `2` and `3`.\n\nYou are also given some queries. Each query consists of two integers `i` and `c`, return the shortest distance between the given index `i` and the target color `c`. If there is no solution return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** colors = \\[1,1,2,1,3,2,2,3,3\\], queries = \\[\\[1,3\\],\\[2,2\\],\\[6,1\\]\\]\n**Output:** \\[3,0,3\\]\n**Explanation:** \nThe nearest 3 from index 1 is at index 4 (3 steps away).\nThe nearest 2 from index 2 is at index 2 itself (0 steps away).\nThe nearest 1 from index 6 is at index 3 (3 steps away).\n\n",
                "**Example 2:**\n\n**Input:** colors = \\[1,2\\], queries = \\[\\[0,3\\]\\]\n**Output:** \\[-1\\]\n**Explanation:** There is no 3 in the array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= colors.length <= 5*10^4`\n*   `1 <= colors[i] <= 3`\n*   `1 <= queries.length <= 5*10^4`\n*   `queries[i].length == 2`\n*   `0 <= queries[i][0] < colors.length`\n*   `1 <= queries[i][1] <= 3`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,1,2,1,3,2,2,3,3],[[1,3],[2,2],[6,1]]",
                "output": "[3,0,3]"
            },
            {
                "input": "[1,2],[[0,3]]",
                "output": "[-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> shortestDistance(int[] colors, int[][] queries) {\n    List<Integer> result = new ArrayList<>();\n    List<List<Integer>> positions = new ArrayList<>(3);\n\n    for (int i = 0; i < 3; i++) {\n        positions.add(new ArrayList<>());\n    }\n\n    for (int i = 0; i < colors.length; i++) {\n        positions.get(colors[i] - 1).add(i);\n    }\n\n    for (int[] query : queries) {\n        List<Integer> indexPositions = positions.get(query[1] - 1);\n\n        if (indexPositions.isEmpty()) {\n            result.add(-1);\n        } else {\n            int dist = Integer.MAX_VALUE;\n\n            for (int pos : indexPositions) {\n                dist = Math.min(dist, Math.abs(pos - query[0]));\n            }\n\n            result.add(dist);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm maintains a list with 3 inner lists (named `positions`), representing the positions where each color (`1`, `2`, or `3`) appear in the input list `colors`. \n\nFor each query, we get the index positions of the target color (query[1]) from the `positions` list. If there are no index positions, we append `-1` to our `result` list. Otherwise, we calculate the distance between each target color position and the index `i` given in the query by finding the absolute difference of their indices. We keep the minimum distance found, and append it to our `result` list.\n\nFinally, we return the `result` list containing the shortest distances for each query.\n    ",
        "python": "\n    ```python\ndef shortestDistance(colors, queries):\n    result = []\n    positions = [[] for _ in range(3)]\n\n    for i, color in enumerate(colors):\n        positions[color - 1].append(i)\n\n    for query in queries:\n        index_positions = positions[query[1] - 1]\n\n        if not index_positions:\n            result.append(-1)\n        else:\n            dist = float('inf')\n\n            for pos in index_positions:\n                dist = min(dist, abs(pos - query[0]))\n\n            result.append(dist)\n\n    return result\n```\n    \n    The algorithm maintains a list with 3 inner lists (named `positions`), representing the positions where each color (`1`, `2`, or `3`) appear in the input list `colors`. \n\nFor each query, we get the index positions of the target color (query[1]) from the `positions` list. If there are no index positions, we append `-1` to our `result` list. Otherwise, we calculate the distance between each target color position and the index `i` given in the query by finding the absolute difference of their indices. We keep the minimum distance found, and append it to our `result` list.\n\nFinally, we return the `result` list containing the shortest distances for each query.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n\nstd::vector<int> shortestDistance(std::vector<int>& colors, std::vector<std::vector<int>>& queries) {\n    std::vector<int> result;\n    std::vector<std::vector<int>> positions(3);\n\n    for(int i = 0; i < colors.size(); i++) {\n        positions[colors[i] - 1].push_back(i);\n    }\n\n    for(auto &query : queries) {\n        auto &index_positions = positions[query[1] - 1];\n\n        if (index_positions.empty()) {\n            result.push_back(-1);\n        } else {\n            int dist = INT_MAX;\n\n            for (auto pos : index_positions) {\n                dist = std::min(dist, std::abs(pos - query[0]));\n            }\n\n            result.push_back(dist);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm maintains a list with 3 inner lists (named `positions`), representing the positions where each color (`1`, `2`, or `3`) appear in the input list `colors`. \n\nFor each query, we get the index positions of the target color (query[1]) from the `positions` list. If there are no index positions, we append `-1` to our `result` list. Otherwise, we calculate the distance between each target color position and the index `i` given in the query by finding the absolute difference of their indices. We keep the minimum distance found, and append it to our `result` list.\n\nFinally, we return the `result` list containing the shortest distances for each query.\n    ",
        "js": "\n    ```javascript\nfunction shortestDistance(colors, queries) {\n    const result = [];\n    const positions = [[], [], []];\n\n    colors.forEach((color, i) => {\n        positions[color - 1].push(i);\n    });\n\n    queries.forEach(query => {\n        const indexPositions = positions[query[1] - 1];\n\n        if (!indexPositions.length) {\n            result.push(-1);\n        } else {\n            let dist = Infinity;\n\n            indexPositions.forEach(pos => {\n                dist = Math.min(dist, Math.abs(pos - query[0]));\n            });\n\n            result.push(dist);\n        }\n    });\n\n    return result;\n}\n```\n    \n    The algorithm maintains a list with 3 inner lists (named `positions`), representing the positions where each color (`1`, `2`, or `3`) appear in the input list `colors`. \n\nFor each query, we get the index positions of the target color (query[1]) from the `positions` list. If there are no index positions, we append `-1` to our `result` list. Otherwise, we calculate the distance between each target color position and the index `i` given in the query by finding the absolute difference of their indices. We keep the minimum distance found, and append it to our `result` list.\n\nFinally, we return the `result` list containing the shortest distances for each query.\n    "
    },
    {
        "id": 198,
        "title": "Maximum Number of Ones",
        "difficulty": "Hard",
        "content": {
            "problem": "Consider a matrix `M` with dimensions `width * height`, such that every cell has value `0` or `1`, and any **square** sub-matrix of `M` of size `sideLength * sideLength` has at most `maxOnes` ones.\n\nReturn the maximum possible number of ones that the matrix `M` can have.",
            "examples": [
                "**Example 1:**\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 1\n**Output:** 4\n**Explanation:**\nIn a 3\\*3 matrix, no 2\\*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n\\[1,0,1\\]\n\\[0,0,0\\]\n\\[1,0,1\\]\n\n",
                "**Example 2:**\n\n**Input:** width = 3, height = 3, sideLength = 2, maxOnes = 2\n**Output:** 6\n**Explanation:**\n\\[1,0,1\\]\n\\[1,0,1\\]\n\\[1,0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= width, height <= 100`\n*   `1 <= sideLength <= width, height`\n*   `0 <= maxOnes <= sideLength * sideLength`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,3,2,1",
                "output": "4"
            },
            {
                "input": "3,3,2,2",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic double[] sampleStats(int[] count) {\n    double minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;\n    long totalCount = 0, modeCount = 0, curCount = 0;\n    double sum = 0;\n\n    for (int i = 0; i <= 255; i++) {\n        if (count[i] > 0) {\n            if (minVal == -1) minVal = i;\n            maxVal = i;\n            sum += (double) i * count[i];\n            totalCount += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n\n    mean = sum / totalCount;\n    boolean isEven = (totalCount % 2 == 0);\n    long mid1 = totalCount / 2, mid2 = mid1 - 1;\n    if (isEven) mid2++;\n\n    for (int i = 0; i <= 255; i++) {\n        curCount += count[i];\n        if (isEven && curCount >= mid2) {\n            median += i;\n            mid2 = totalCount;\n            isEven = false;\n        }\n\n        if (curCount >= mid1) {\n            median += i;\n            break;\n        }\n    }\n\n    if (!isEven) median /= 2;\n    return new double[]{minVal, maxVal, mean, median, mode};\n}\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    ",
        "python": "\n    ```python\ndef sampleStats(count):\n    minVal, maxVal, mode, median, mean = -1, -1, 0, 0, 0\n    totalCount, modeCount, curCount = 0, 0, 0\n    sum = 0\n\n    for i in range(256):\n        if count[i] > 0:\n            if minVal == -1:\n                minVal = i\n            maxVal = i\n            sum += i * count[i]\n            totalCount += count[i]\n            if count[i] > modeCount:\n                modeCount = count[i]\n                mode = i\n\n    mean = sum / totalCount\n    isEven = (totalCount % 2 == 0)\n    mid1 = totalCount // 2\n    mid2 = mid1 - 1\n    if isEven:\n        mid2 += 1\n\n    for i in range(256):\n        curCount += count[i]\n        if isEven and curCount >= mid2:\n            median += i\n            mid2 = totalCount\n            isEven = False\n\n        if curCount >= mid1:\n            median += i\n            break\n\n    if not isEven:\n        median /= 2\n    return [minVal, maxVal, mean, median, mode]\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<double> sampleStats(std::vector<int>& count) {\n    double minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;\n    long long totalCount = 0, modeCount = 0, curCount = 0;\n    double sum = 0;\n\n    for (int i = 0; i <= 255; i++) {\n        if (count[i] > 0) {\n            if (minVal == -1) minVal = i;\n            maxVal = i;\n            sum += static_cast<double>(i) * count[i];\n            totalCount += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n\n    mean = sum / totalCount;\n    bool isEven = (totalCount % 2 == 0);\n    long long mid1 = totalCount / 2, mid2 = mid1 - 1;\n    if (isEven) mid2++;\n\n    for (int i = 0; i <= 255; i++) {\n        curCount += count[i];\n        if (isEven && curCount >= mid2) {\n            median += i;\n            mid2 = totalCount;\n            isEven = false;\n        }\n\n        if (curCount >= mid1) {\n            median += i;\n            break;\n        }\n    }\n\n    if (!isEven) median /= 2;\n    return {minVal, maxVal, mean, median, mode};\n}\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    ",
        "js": "\n    ```javascript\nfunction sampleStats(count) {\n    let minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;\n    let totalCount = 0, modeCount = 0, curCount = 0;\n    let sum = 0;\n\n    for (let i = 0; i <= 255; i++) {\n        if (count[i] > 0) {\n            if (minVal === -1) minVal = i;\n            maxVal = i;\n            sum += i * count[i];\n            totalCount += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n\n    mean = sum / totalCount;\n    let isEven = (totalCount % 2 === 0);\n    let mid1 = Math.floor(totalCount / 2), mid2 = mid1 - 1;\n    if (isEven) mid2++;\n\n    for (let i = 0; i <= 255; i++) {\n        curCount += count[i];\n        if (isEven && curCount >= mid2) {\n            median += i;\n            mid2 = totalCount;\n            isEven = false;\n        }\n\n        if (curCount >= mid1) {\n            median += i;\n            break;\n        }\n    }\n\n    if (!isEven) median /= 2;\n    return [minVal, maxVal, mean, median, mode];\n}\n```\n    \n    The algorithm starts by initializing variables for min, max, mean, mode, and median, as well as some others used for calculations. It then iterates through the count array from 0 to 255. For each value, it updates the min and max values if necessary, calculates the sum of the elements and total count (which will be used to calculate the mean later), and updates the mode if the count for that value is greater than the current mode count.\n\nAfter the initial loop, the mean is calculated by dividing the sum by the total count. The median is calculated by finding the middle value(s) using the total count. If the total count is even, it will be the average of the two middle values; otherwise, it will be just the middle value. This is done by keeping track of the current count of values visited, and adding the index i to the median whenever any of the middle values are reached. The median is then divided by 2 if there was only one middle value, to account for the fact that it was added twice during the median calculation loop.\n\nFinally, the results are returned in an array with the format [minimum, maximum, mean, median, mode].\n    "
    },
    {
        "id": 199,
        "title": "How Many Apples Can You Put into the Basket",
        "difficulty": "Easy",
        "content": {
            "problem": "You have some apples and a basket that can carry up to `5000` units of weight.\n\nGiven an integer array `weight` where `weight[i]` is the weight of the `ith` apple, return _the maximum number of apples you can put in the basket_.",
            "examples": [
                "**Example 1:**\n\n**Input:** weight = \\[100,200,150,1000\\]\n**Output:** 4\n**Explanation:** All 4 apples can be carried by the basket since their sum of weights is 1450.\n\n",
                "**Example 2:**\n\n**Input:** weight = \\[900,950,800,1000,700,800\\]\n**Output:** 5\n**Explanation:** The sum of weights of the 6 apples exceeds 5000 so we choose any 5 of them."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= weight.length <= 103`\n*   `1 <= weight[i] <= 103`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[100,200,150,1000]",
                "output": "4"
            },
            {
                "input": "[900,950,800,1000,700,800]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minHeightShelves(int[][] books, int shelfWidth) {\n    int n = books.length;\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, 1000000);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        int width = 0, height = 0;\n        for (int j = i; j >= 1; j--) {\n            width += books[j - 1][0];\n            height = Math.max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = Math.min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "python": "\n    ```python\ndef minHeightShelves(books, shelfWidth):\n    n = len(books)\n    dp = [1000000] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        width = 0\n        height = 0\n        j = i\n        while j >= 1:\n            width += books[j - 1][0]\n            height = max(height, books[j - 1][1])\n            \n            if width <= shelfWidth:\n                dp[i] = min(dp[i], dp[j - 1] + height)\n            j -= 1\n    \n    return dp[n]\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minHeightShelves(std::vector<std::vector<int>>& books, int shelfWidth) {\n    int n = books.size();\n    std::vector<int> dp(n + 1, 1000000);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        int width = 0, height = 0;\n        for (int j = i; j >= 1; --j) {\n            width += books[j - 1][0];\n            height = std::max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = std::min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "js": "\n    ```javascript\nfunction minHeightShelves(books, shelfWidth) {\n    const n = books.length;\n    const dp = new Array(n + 1).fill(1000000);\n    dp[0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        let width = 0, height = 0;\n        for (let j = i; j >= 1; j--) {\n            width += books[j - 1][0];\n            height = Math.max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = Math.min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    "
    },
    {
        "id": 200,
        "title": "Minimum Knight Moves",
        "difficulty": "Medium",
        "content": {
            "problem": "In an **infinite** chess board with coordinates from `-infinity` to `+infinity`, you have a **knight** at square `[0, 0]`.\n\nA knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\n\nReturn _the minimum number of steps needed to move the knight to the square_ `[x, y]`. It is guaranteed the answer exists.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 2, y = 1\n**Output:** 1\n**Explanation:** \\[0, 0\\] -> \\[2, 1\\]\n\n",
                "**Example 2:**\n\n**Input:** x = 5, y = 5\n**Output:** 4\n**Explanation:** \\[0, 0\\] -> \\[2, 1\\] -> \\[4, 2\\] -> \\[3, 4\\] -> \\[5, 5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `-300 <= x, y <= 300`\n*   `0 <= |x| + |y| <= 300`\n\n\"t\", evaluating to True; \"f\", evaluating to False; \"!(expression)\", evaluating to the logical NOT of the expression inside the parentheses; \"&(expression1,expression2,...)\", evaluating to the logical AND of 2 or more expressions; \"|(expression1,expression2,...)\", evaluating to the logical OR of 2 or more expressions.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2,1",
                "output": "1"
            },
            {
                "input": "5,5",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic boolean parseBoolExpr(String expression, int[] pos) {\n    char current = expression.charAt(pos[0]++);\n    switch (current) {\n        case 't': return true;\n        case 'f': return false;\n        case '!': return !parseBoolExpr(expression, ++pos);\n        case '&': {\n            pos[0]++;\n            boolean result = true;\n            while (expression.charAt(pos[0]) != ')') {\n                result &= parseBoolExpr(expression, pos);\n                if(expression.charAt(pos[0]) == ',') pos[0]++;\n            }\n            pos[0]++;\n            return result;\n        }\n        case '|': {\n            pos[0]++;\n            boolean result = false;\n            while (expression.charAt(pos[0]) != ')') {\n                result |= parseBoolExpr(expression, pos);\n                if(expression.charAt(pos[0]) == ',') pos[0]++;\n            }\n            pos[0]++;\n            return result;\n        }\n    }\n    return false;\n}\n\npublic boolean parseBoolExpr(String expression) {\n    int[] pos = new int[] {0};\n    return parseBoolExpr(expression, pos);\n}\n```\n    \n    The algorithm uses a recursive descent parser. It evaluates the given boolean expression string by iterating over each character and processing it based on its type.\n\nFor each character encountered in the input string, the algorithm takes the following actions:\n1. If it is 't' or 'f', it returns true or false, respectively.\n2. If it is '!', it increments the position and evaluates the expression inside the parenthesis, returning its negation.\n3. If it is '&', it evaluates all expressions inside the parentheses, taking the logical AND of the results.\n4. If it is '|', it evaluates all expressions inside the parentheses, taking the logical OR of the results.\n\nIn each case, the parser uses a position variable (`pos`) to keep track of the current position in the expression string. The parser increments the position throughout the evaluation process to handle nested boolean expressions properly.\n\nFor languages like Java and JavaScript, which lack support for reference variables, an array of a single element (e.g., `int[] pos` or `pos = [0]`) is used to emulate pass-by-reference. This way, the position is shared and updated among recursive calls.\n    ",
        "python": "\n    ```python\ndef parse_bool_expr(expression, pos=None):\n    if pos is None:\n        pos = [0]\n    current = expression[pos[0]]\n    pos[0] += 1\n    if current == 't': return True\n    if current == 'f': return False\n    if current == '!':\n        pos[0] += 1\n        return not parse_bool_expr(expression, pos)\n    if current == '&':\n        pos[0] += 1\n        result = True\n        while expression[pos[0]] != ')':\n            result &= parse_bool_expr(expression, pos)\n            if expression[pos[0]] == ',': pos[0] += 1\n    elif current == '|':\n        pos[0] += 1\n        result = False\n        while expression[pos[0]] != ')':\n            result |= parse_bool_expr(expression, pos)\n            if expression[pos[0]] == ',': pos[0] += 1\n    pos[0] += 1\n    return result\n```\n    \n    The algorithm uses a recursive descent parser. It evaluates the given boolean expression string by iterating over each character and processing it based on its type.\n\nFor each character encountered in the input string, the algorithm takes the following actions:\n1. If it is 't' or 'f', it returns true or false, respectively.\n2. If it is '!', it increments the position and evaluates the expression inside the parenthesis, returning its negation.\n3. If it is '&', it evaluates all expressions inside the parentheses, taking the logical AND of the results.\n4. If it is '|', it evaluates all expressions inside the parentheses, taking the logical OR of the results.\n\nIn each case, the parser uses a position variable (`pos`) to keep track of the current position in the expression string. The parser increments the position throughout the evaluation process to handle nested boolean expressions properly.\n\nFor languages like Java and JavaScript, which lack support for reference variables, an array of a single element (e.g., `int[] pos` or `pos = [0]`) is used to emulate pass-by-reference. This way, the position is shared and updated among recursive calls.\n    ",
        "c++": "\n    ```cpp\nbool parseBoolExpr(string expression, int &pos) {\n    switch (expression[pos++]) {\n        case 't': return true;\n        case 'f': return false;\n        case '!': return !parseBoolExpr(expression, ++pos);\n        case '&': {\n            pos++; \n            bool result = true;\n            while (expression[pos] != ')') {\n                result &= parseBoolExpr(expression, pos);\n                if(expression[pos] == ',') pos++;\n            }\n            pos++;\n            return result;\n        }\n        case '|': {\n            pos++;\n            bool result = false;\n            while (expression[pos] != ')') {\n                result |= parseBoolExpr(expression, pos);\n                if(expression[pos] == ',') pos++;\n            }\n            pos++;\n            return result;\n        }\n    }\n}\n\nbool parseBoolExpr(string expression) {\n    int pos = 0;\n    return parseBoolExpr(expression, pos);\n}\n```\n    \n    The algorithm uses a recursive descent parser. It evaluates the given boolean expression string by iterating over each character and processing it based on its type.\n\nFor each character encountered in the input string, the algorithm takes the following actions:\n1. If it is 't' or 'f', it returns true or false, respectively.\n2. If it is '!', it increments the position and evaluates the expression inside the parenthesis, returning its negation.\n3. If it is '&', it evaluates all expressions inside the parentheses, taking the logical AND of the results.\n4. If it is '|', it evaluates all expressions inside the parentheses, taking the logical OR of the results.\n\nIn each case, the parser uses a position variable (`pos`) to keep track of the current position in the expression string. The parser increments the position throughout the evaluation process to handle nested boolean expressions properly.\n\nFor languages like Java and JavaScript, which lack support for reference variables, an array of a single element (e.g., `int[] pos` or `pos = [0]`) is used to emulate pass-by-reference. This way, the position is shared and updated among recursive calls.\n    ",
        "js": "\n    ```javascript\nfunction parseBoolExpr(expression, pos = [0]) {\n    const current = expression[pos[0]++];\n    if (current === 't') return true;\n    if (current === 'f') return false;\n    if (current === '!') {\n        pos[0]++;\n        return !parseBoolExpr(expression, pos);\n    }\n    if (current === '&') {\n        pos[0]++;\n        let result = true;\n        while (expression[pos[0]] !== ')') {\n            result &= parseBoolExpr(expression, pos);\n            if (expression[pos[0]] === ',') pos[0]++;\n        }\n    } else if (current === '|') {\n        pos[0]++;\n        let result = false;\n        while (expression[pos[0]] !== ')') {\n            result |= parseBoolExpr(expression, pos);\n            if (expression[pos[0]] === ',') pos[0]++;\n        }\n    }\n    pos[0]++;\n    return result;\n}\n```\n    \n    The algorithm uses a recursive descent parser. It evaluates the given boolean expression string by iterating over each character and processing it based on its type.\n\nFor each character encountered in the input string, the algorithm takes the following actions:\n1. If it is 't' or 'f', it returns true or false, respectively.\n2. If it is '!', it increments the position and evaluates the expression inside the parenthesis, returning its negation.\n3. If it is '&', it evaluates all expressions inside the parentheses, taking the logical AND of the results.\n4. If it is '|', it evaluates all expressions inside the parentheses, taking the logical OR of the results.\n\nIn each case, the parser uses a position variable (`pos`) to keep track of the current position in the expression string. The parser increments the position throughout the evaluation process to handle nested boolean expressions properly.\n\nFor languages like Java and JavaScript, which lack support for reference variables, an array of a single element (e.g., `int[] pos` or `pos = [0]`) is used to emulate pass-by-reference. This way, the position is shared and updated among recursive calls.\n    "
    },
    {
        "id": 201,
        "title": "Find Smallest Common Element in All Rows",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` matrix `mat` where every row is sorted in **strictly** **increasing** order, return _the **smallest common element** in all rows_.\n\nIf there is no common element, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,2,3,4,5\\],\\[2,4,5,8,10\\],\\[3,5,7,9,11\\],\\[1,3,5,7,9\\]\\]\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,2,3\\],\\[2,3,4\\],\\[2,3,5\\]\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 500`\n*   `1 <= mat[i][j] <= 104`\n*   `mat[i]` is sorted in strictly increasing order.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]",
                "output": "5"
            },
            {
                "input": "[[1,2,3],[2,3,4],[2,3,5]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int smallestCommonElement(int[][] mat) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    for (int[] row : mat) {\n        for (int num : row) {\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\n            if (counts.get(num) == mat.length) {\n                return num;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "python": "\n    ```python\ndef smallest_common_element(mat):\n    counts = {}\n    for row in mat:\n        for num in row:\n            counts[num] = counts.get(num, 0) + 1\n            if counts[num] == len(mat):\n                return num\n    return -1\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "c++": "\n    ```cpp\nint smallestCommonElement(vector<vector<int>>& mat) {\n    unordered_map<int, int> counts;\n    for (const auto& row : mat) {\n        for (int num : row) {\n            ++counts[num];\n            if (counts[num] == mat.size()) {\n                return num;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    ",
        "js": "\n    ```javascript\nfunction smallestCommonElement(mat) {\n    const counts = new Map();\n    for (const row of mat) {\n        for (const num of row) {\n            counts.set(num, (counts.get(num) || 0) + 1);\n            if (counts.get(num) === mat.length) {\n                return num;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through each value in the matrix and maintains an unordered_map (HashMap, dictionary, or Map, depending on the language) which stores the count of each value. Every time it encounters a value, it increments the counter in the map. If at any point, the count of a number equals the number of rows in the matrix ('mat.length' or 'len(mat)'), it returns that number as the smallest common element. If no common element is found, it returns -1.\n    "
    },
    {
        "id": 202,
        "title": "Minimum Time to Build Blocks",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a list of blocks, where `blocks[i] = t` means that the `i`\\-th block needs `t` units of time to be built. A block can only be built by exactly one worker.\n\nA worker can either split into two workers (number of workers increases by one) or build a block then go home. Both decisions cost some time.\n\nThe time cost of spliting one worker into two workers is given as an integer `split`. Note that if two workers split at the same time, they split in parallel so the cost would be `split`.\n\nOutput the minimum time needed to build all blocks.\n\nInitially, there is only **one** worker.",
            "examples": [
                "**Example 1:**\n\n**Input:** blocks = \\[1\\], split = 1\n**Output:** 1\n**Explanation:** We use 1 worker to build 1 block in 1 time unit.\n\n",
                "**Example 2:**\n\n**Input:** blocks = \\[1,2\\], split = 5\n**Output:** 7\n**Explanation:** We split the worker into 2 workers in 5 time units then assign each of them to a block so the cost is 5 + max(1, 2) = 7.\n\n",
                "**Example 3:**\n\n**Input:** blocks = \\[1,2,3\\], split = 1\n**Output:** 4\n**Explanation:** Split 1 worker into 2, then assign the first worker to the last block and split the second worker into 2.\nThen, use the two unassigned workers to build the first two blocks.\nThe cost is 1 + max(3, 1 + max(1, 2)) = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= blocks.length <= 1000`\n*   `1 <= blocks[i] <= 10^5`\n*   `1 <= split <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1],1",
                "output": "1"
            },
            {
                "input": "[1,2],5",
                "output": "7"
            },
            {
                "input": "[1,2,3],1",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minBuildTime(int[] blocks, int split) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    \n    for (int block : blocks) {\n        pq.add(block);\n    }\n    \n    while (pq.size() > 1) {\n        int a = pq.poll();\n        int b = pq.poll();\n        pq.add(b + split);\n    }\n    \n    return pq.poll();\n}\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef min_build_time(blocks, split):\n    heapq.heapify(blocks)\n    \n    while len(blocks) > 1:\n        a = heapq.heappop(blocks)\n        b = heapq.heappop(blocks)\n        heapq.heappush(blocks, b + split)\n    \n    return blocks[0]\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minBuildTime(std::vector<int>& blocks, int split) {\n    std::priority_queue<int, std::vector<int>, greater<int>> pq(blocks.begin(), blocks.end());\n    \n    while (pq.size() > 1) {\n        int a = pq.top();\n        pq.pop();\n        int b = pq.top();\n        pq.pop();\n        pq.push(b + split);\n    }\n    \n    return pq.top();\n}\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    ",
        "js": "\n    ```javascript\nfunction minBuildTime(blocks, split) {\n    const pq = new PriorityQueue();\n    for (const block of blocks) {\n        pq.add(block);\n    }\n    \n    while (pq.size() > 1) {\n        const a = pq.poll();\n        const b = pq.poll();\n        pq.add(b + split);\n    }\n    \n    return pq.poll();\n}\n```\n    \n    We use a priority queue to get the smallest time units of the blocks. In each iteration, we get the two smallest time units and insert the larger one plus the split time back into the priority queue. This is repeated until there is only one element left in the priority queue.\n\nThis results in the workers splitting and working on the blocks with the smallest time units.\n\nInitially, we insert all blocks' time units into the priority queue. Then we enter a loop where we get the two smallest elements (a and b), pop them from the priority queue, and add (b + split) back into the priority queue. We keep doing this until there's only one element left in the priority queue.\n\nFinally, we return the last remaining element as the minimum time needed to build all blocks.\n    "
    },
    {
        "id": 203,
        "title": "Intersection of Three Sorted Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[1,2,3,4,5\\], arr2 = \\[1,2,5,7,9\\], arr3 = \\[1,3,4,5,8\\]\n**Output:** \\[1,5\\]\n**Explanation:** Only 1 and 5 appeared in the three arrays.\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[197,418,523,876,1356\\], arr2 = \\[501,880,1593,1710,1870\\], arr3 = \\[521,682,1337,1395,1764\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length, arr3.length <= 1000`\n*   `1 <= arr1[i], arr2[i], arr3[i] <= 2000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5],[1,2,5,7,9],[1,3,4,5,8]",
                "output": "[1,5]"
            },
            {
                "input": "[197,418,523,876,1356],[501,880,1593,1710,1870],[521,682,1337,1395,1764]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {\n    int i = 0, j = 0, k = 0;\n    ArrayList<Integer> result = new ArrayList<>();\n    while (i < arr1.length && j < arr2.length && k < arr3.length) {\n        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {\n            result.add(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "python": "\n    ```python\ndef arraysIntersection(arr1, arr2, arr3):\n    i, j, k = 0, 0, 0\n    result = []\n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:\n            result.append(arr1[i])\n            i, j, k = i + 1, j + 1, k + 1\n        else:\n            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:\n                i += 1\n            elif arr2[j] <= arr3[k]:\n                j += 1\n            else:\n                k += 1\n    return result\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) {\n    int i = 0, j = 0, k = 0;\n    vector<int> result;\n    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {\n        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {\n            result.push_back(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "js": "\n    ```javascript\nfunction arraysIntersection(arr1, arr2, arr3) {\n    let i = 0, j = 0, k = 0;\n    let result = [];\n    while (i < arr1.length && j < arr2.length && k < arr3.length) {\n        if (arr1[i] === arr2[j] && arr2[j] === arr3[k]) {\n            result.push(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    "
    },
    {
        "id": 204,
        "title": "Two Sum BSTs",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the roots of two binary search trees, `root1` and `root2`, return `true` if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer `target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root1 = \\[2,1,4\\], root2 = \\[1,0,3\\], target = 5\n**Output:** true\n**Explanation:** 2 and 3 sum up to 5.\n\n",
                "**Example 2:**\n\n**Input:** root1 = \\[0,-10,10\\], root2 = \\[5,1,7,0,2\\], target = 18\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in each tree is in the range `[1, 5000]`.\n*   `-109 <= Node.val, target <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,4],[1,0,3],5",
                "output": "true"
            },
            {
                "input": "[0,-10,10],[5,1,7,0,2],18",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic boolean twoSumBSTs(TreeNode root1, TreeNode root2, int target) {\n    Set<Integer> set = new HashSet<>();\n    buildSet(root1, set);\n    return findPair(root2, target, set);\n}\n\nprivate void buildSet(TreeNode root, Set<Integer> set) {\n    if (root == null) return;\n    set.add(root.val);\n    buildSet(root.left, set);\n    buildSet(root.right, set);\n}\n\nprivate boolean findPair(TreeNode root, int target, Set<Integer> set) {\n    if (root == null) return false;\n    if (set.contains(target - root.val)) return true;\n    return findPair(root.left, target, set) || findPair(root.right, target, set);\n}\n```\n    \n    The algorithm consists of the following steps:\n\n1. Traverse the first binary search tree `root1` and store all its values in a set `s`.\n2. Traverse the second binary search tree `root2`, and for each node, check if `target - node.val` is present in set `s`.\n3. Return true if a pair of nodes from both trees sum up to `target` exists, otherwise, return false.\n\nThe time complexity is O(n1 + n2) where n1 and n2 are the number of nodes in each tree, and the space complexity is O(n1).\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef twoSumBSTs(root1, root2, target):\n    def build_set(node, s):\n        if node:\n            s.add(node.val)\n            build_set(node.left, s)\n            build_set(node.right, s)\n\n    def find_pair(node, target, s):\n        if node:\n            if target - node.val in s:\n                return True\n            return find_pair(node.left, target, s) or find_pair(node.right, target, s)\n        return False\n\n    s = set()\n    build_set(root1, s)\n    return find_pair(root2, target, s)\n```\n    \n    The algorithm consists of the following steps:\n\n1. Traverse the first binary search tree `root1` and store all its values in a set `s`.\n2. Traverse the second binary search tree `root2`, and for each node, check if `target - node.val` is present in set `s`.\n3. Return true if a pair of nodes from both trees sum up to `target` exists, otherwise, return false.\n\nThe time complexity is O(n1 + n2) where n1 and n2 are the number of nodes in each tree, and the space complexity is O(n1).\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nbool helper(TreeNode* root, int target, unordered_set<int>& s) {\n    if (!root) return false;\n    if (s.count(target - root->val)) return true;\n    s.insert(root->val);\n    return helper(root->left, target, s) || helper(root->right, target, s);\n}\n\nbool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {\n    unordered_set<int> s;\n    helper(root1, target, s);\n    return helper(root2, target, s);\n}\n```\n    \n    The algorithm consists of the following steps:\n\n1. Traverse the first binary search tree `root1` and store all its values in a set `s`.\n2. Traverse the second binary search tree `root2`, and for each node, check if `target - node.val` is present in set `s`.\n3. Return true if a pair of nodes from both trees sum up to `target` exists, otherwise, return false.\n\nThe time complexity is O(n1 + n2) where n1 and n2 are the number of nodes in each tree, and the space complexity is O(n1).\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction twoSumBSTs(root1, root2, target) {\n    const set = new Set();\n\n    const buildSet = (node, set) => {\n        if (node) {\n            set.add(node.val);\n            buildSet(node.left, set);\n            buildSet(node.right, set);\n        }\n    };\n\n    const findPair = (node, target, set) => {\n        if (node) {\n            if (set.has(target - node.val)) {\n                return true;\n            }\n            return findPair(node.left, target, set) || findPair(node.right, target, set);\n        }\n        return false;\n    };\n\n    buildSet(root1, set);\n    return findPair(root2, target, set);\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Traverse the first binary search tree `root1` and store all its values in a set `s`.\n2. Traverse the second binary search tree `root2`, and for each node, check if `target - node.val` is present in set `s`.\n3. Return true if a pair of nodes from both trees sum up to `target` exists, otherwise, return false.\n\nThe time complexity is O(n1 + n2) where n1 and n2 are the number of nodes in each tree, and the space complexity is O(n1).\n    "
    },
    {
        "id": 205,
        "title": "Stepping Numbers",
        "difficulty": "Medium",
        "content": {
            "problem": "A **stepping number** is an integer such that all of its adjacent digits have an absolute difference of exactly `1`.\n\n*   For example, `321` is a **stepping number** while `421` is not.\n\nGiven two integers `low` and `high`, return _a sorted list of all the **stepping numbers** in the inclusive range_ `[low, high]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** low = 0, high = 21\n**Output:** \\[0,1,2,3,4,5,6,7,8,9,10,12,21\\]\n\n",
                "**Example 2:**\n\n**Input:** low = 10, high = 15\n**Output:** \\[10,12\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= low <= high <= 2 * 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "0,21",
                "output": "[0,1,2,3,4,5,6,7,8,9,10,12,21]"
            },
            {
                "input": "10,15",
                "output": "[10,12]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> countSteppingNumbers(int low, int high) {\n    List<Integer> results = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n        int prev = -1;\n        int j = i;\n        boolean isStepping = true;\n        while (j > 0) {\n            int digit = j % 10;\n            if (prev != -1 && Math.abs(prev - digit) != 1) {\n                isStepping = false;\n                break;\n            }\n            prev = digit;\n            j /= 10;\n        }\n        if (isStepping) results.add(i);\n    }\n    return results;\n}\n```\n    \n    The algorithm starts by initializing an empty list for the final result. Then it iterates from `low` to `high` inclusive. For each integer `i` in the range, it checks whether it's a stepping number or not. To do so:\n1. Initialize a `prev` variable to store the previous digit and set it initially to -1.\n2. Initialize a variable `j` with the value of `i`.\n3. Initialize an `is_stepping` flag and set it to true.\n4. Create a while loop that continues until `j` is greater than 0.\n    - Calculate the current digit by taking the modulus of `j` and 10.\n    - If `prev` is not equal to -1 and the absolute difference between the current digit and the previous digit is not equal to 1, set the `is_stepping` flag to false and break the loop.\n    - Otherwise, set the `prev` variable to the current digit and divide `j` by 10 (using integer division).\n5. After the loop, if the `is_stepping` flag is still true, it means the number `i` is a stepping number, so add it to the result list.\n6. Finally, return the result list.\n    ",
        "python": "\n    ```python\ndef countSteppingNumbers(low, high):\n    results = []\n    for i in range(low, high+1):\n        prev = -1\n        j = i\n        is_stepping = True\n        while j > 0:\n            digit = j % 10\n            if prev != -1 and abs(prev - digit) != 1:\n                is_stepping = False\n                break\n            prev = digit\n            j //= 10\n        if is_stepping:\n            results.append(i)\n    return results\n```\n    \n    The algorithm starts by initializing an empty list for the final result. Then it iterates from `low` to `high` inclusive. For each integer `i` in the range, it checks whether it's a stepping number or not. To do so:\n1. Initialize a `prev` variable to store the previous digit and set it initially to -1.\n2. Initialize a variable `j` with the value of `i`.\n3. Initialize an `is_stepping` flag and set it to true.\n4. Create a while loop that continues until `j` is greater than 0.\n    - Calculate the current digit by taking the modulus of `j` and 10.\n    - If `prev` is not equal to -1 and the absolute difference between the current digit and the previous digit is not equal to 1, set the `is_stepping` flag to false and break the loop.\n    - Otherwise, set the `prev` variable to the current digit and divide `j` by 10 (using integer division).\n5. After the loop, if the `is_stepping` flag is still true, it means the number `i` is a stepping number, so add it to the result list.\n6. Finally, return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> countSteppingNumbers(int low, int high) {\n    std::vector<int> results;\n    for (int i = low; i <= high; i++) {\n        int prev = -1;\n        int j = i;\n        bool is_stepping = true;\n        while (j > 0) {\n            int digit = j % 10;\n            if (prev != -1 && std::abs(prev - digit) != 1) {\n                is_stepping = false;\n                break;\n            }\n            prev = digit;\n            j /= 10;\n        }\n        if (is_stepping) results.push_back(i);\n    }\n    return results;\n}\n```\n    \n    The algorithm starts by initializing an empty list for the final result. Then it iterates from `low` to `high` inclusive. For each integer `i` in the range, it checks whether it's a stepping number or not. To do so:\n1. Initialize a `prev` variable to store the previous digit and set it initially to -1.\n2. Initialize a variable `j` with the value of `i`.\n3. Initialize an `is_stepping` flag and set it to true.\n4. Create a while loop that continues until `j` is greater than 0.\n    - Calculate the current digit by taking the modulus of `j` and 10.\n    - If `prev` is not equal to -1 and the absolute difference between the current digit and the previous digit is not equal to 1, set the `is_stepping` flag to false and break the loop.\n    - Otherwise, set the `prev` variable to the current digit and divide `j` by 10 (using integer division).\n5. After the loop, if the `is_stepping` flag is still true, it means the number `i` is a stepping number, so add it to the result list.\n6. Finally, return the result list.\n    ",
        "js": "\n    ```javascript\nfunction countSteppingNumbers(low, high) {\n    const results = [];\n    for (let i = low; i <= high; i++) {\n        let prev = -1;\n        let j = i;\n        let isStepping = true;\n        while (j > 0) {\n            const digit = j % 10;\n            if (prev !== -1 && Math.abs(prev - digit) !== 1) {\n                isStepping = false;\n                break;\n            }\n            prev = digit;\n            j = Math.floor(j / 10);\n        }\n        if (isStepping) results.push(i);\n    }\n    return results;\n}\n```\n\n    \n    The algorithm starts by initializing an empty list for the final result. Then it iterates from `low` to `high` inclusive. For each integer `i` in the range, it checks whether it's a stepping number or not. To do so:\n1. Initialize a `prev` variable to store the previous digit and set it initially to -1.\n2. Initialize a variable `j` with the value of `i`.\n3. Initialize an `is_stepping` flag and set it to true.\n4. Create a while loop that continues until `j` is greater than 0.\n    - Calculate the current digit by taking the modulus of `j` and 10.\n    - If `prev` is not equal to -1 and the absolute difference between the current digit and the previous digit is not equal to 1, set the `is_stepping` flag to false and break the loop.\n    - Otherwise, set the `prev` variable to the current digit and divide `j` by 10 (using integer division).\n5. After the loop, if the `is_stepping` flag is still true, it means the number `i` is a stepping number, so add it to the result list.\n6. Finally, return the result list.\n    "
    },
    {
        "id": 206,
        "title": "Valid Palindrome III",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return `true` if `s` is a `k`**\\-palindrome**.\n\nA string is `k`**\\-palindrome** if it can be transformed into a palindrome by removing at most `k` characters from it.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcdeca \", k = 2\n**Output:** true\n**Explanation:** Remove 'b' and 'e' characters.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abbababa \", k = 1\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= s.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcdeca\",2",
                "output": "true"
            },
            {
                "input": "\"abbababa\",1",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.IntConsumer;\n\nclass ZeroEvenOdd {\n    private int n;\n    private int cnt;\n    private Lock lock;\n    private Condition condition;\n    \n    public ZeroEvenOdd(int n) {\n        this.n = n;\n        cnt = 1;\n        lock = new ReentrantLock();\n        condition = lock.newCondition();\n    }\n\n    public void zero(IntConsumer printNumber) throws InterruptedException {\n        for(int i = 1; i <= n; i++) {\n            lock.lock();\n            try {\n                while (cnt % 2 == 0)\n                    condition.await();\n                printNumber.accept(0);\n                cnt++;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public void even(IntConsumer printNumber) throws InterruptedException {\n        for(int i = 2; i <= n; i+=2) {\n            lock.lock();\n            try {\n                while (cnt != 2 * i)\n                    condition.await();\n                printNumber.accept(i);\n                cnt++;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public void odd(IntConsumer printNumber) throws InterruptedException {\n        for(int i = 1; i <= n; i+=2) {\n            lock.lock();\n            try {\n                while (cnt != 2 * i - 1)\n                    condition.await();\n                printNumber.accept(i);\n                cnt++;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    ",
        "python": "\n    ```python\nfrom threading import Lock\n\nclass ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n        self.cnt = 1\n        self.lock = Lock()\n\n    def zero(self, printNumber):\n        for i in range(1, self.n + 1):\n            with self.lock:\n                while self.cnt % 2 == 0:\n                    self.lock.wait()\n                printNumber(0)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def even(self, printNumber):\n        for i in range(2, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def odd(self, printNumber):\n        for i in range(1, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i - 1:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    ",
        "c++": "\n    ```cpp\n#include <functional>\n#include <mutex>\n#include <condition_variable>\n\nclass ZeroEvenOdd {\nprivate:\n    int n;\n    int cnt;\n    std::mutex mtx;\n    std::condition_variable cv;\n\npublic:\n    ZeroEvenOdd(int n) {\n        this->n = n;\n        cnt = 1;\n    }\n\n    void zero(function<void(int)> printNumber) {\n        for(int i = 1; i <= n; i++) {\n            unique_lock<mutex> lck(mtx);\n            cv.wait(lck, [this](){ return cnt % 2 != 0; });\n            printNumber(0);\n            cnt++;\n            cv.notify_all();\n        }\n    }\n\n    void even(function<void(int)> printNumber) {\n        for(int i = 2; i <= n; i+=2) {\n            unique_lock<mutex> lck(mtx);\n            cv.wait(lck, [this, i](){ return cnt == 2 * i; });\n            printNumber(i);\n            cnt++;\n            cv.notify_all();\n        }\n    }\n\n    void odd(function<void(int)> printNumber) {\n        for(int i = 1; i <= n; i+=2) {\n            unique_lock<mutex> lck(mtx);\n            cv.wait(lck, [this, i](){ return cnt == 2 * i - 1; });\n            printNumber(i);\n            cnt++;\n            cv.notify_all();\n        }\n    }\n};\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    ",
        "js": "\n    ```javascript\nclass ZeroEvenOdd {\n    constructor(n) {\n        this.n = n;\n        this.cnt = 1;\n        this.lock = new Promise(resolve => this.unlock = resolve);\n    }\n\n    async zero(printNumber) {\n        for(let i = 1; i <= this.n; i++) {\n            await this.lock;\n            while(this.cnt % 2 === 0) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n            printNumber(0);\n            this.cnt++;\n            this.unlock();\n        }\n    }\n\n    async even(printNumber) {\n        for(let i = 2; i <= this.n; i+=2) {\n            await this.lock;\n            while(this.cnt !== 2 * i) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n            printNumber(i);\n            this.cnt++;\n            this.unlock();\n        }\n    }\n\n    async odd(printNumber) {\n        for(let i = 1; i <= this.n; i+=2) {\n            await this.lock;\n            while(this.cnt !== 2 * i - 1) {\n                await new Promise(resolve => setTimeout(resolve, 10));\n            }\n            printNumber(i);\n            this.cnt++;\n            this.unlock();\n        }\n    }\n}\n```\n    \n    The algorithm uses condition variables (C++ and Java), locks (Python), or Promises (JavaScript). These are used to make sure that the three functions `zero`, `even`, and `odd` are called in the correct order. We maintain a counter `cnt` that is incremented after printing each number. The functions wait for the condition `cnt` to satisfy their respective conditions before they print the numbers and then they notify others to proceed. In the case of `zero`, it waits until `cnt` is odd and then prints 0, `even` waits until `cnt` equals 2 * current even number, and `odd` waits until `cnt` equals 2 * current odd number - 1. They repeat this process up to a length of 2n, producing the required series \"010203040506...\"\n    "
    },
    {
        "id": 207,
        "title": "Missing Number In Arithmetic Progression",
        "difficulty": "Easy",
        "content": {
            "problem": "In some array `arr`, the values were in arithmetic progression: the values `arr[i + 1] - arr[i]` are all equal for every `0 <= i < arr.length - 1`.\n\nA value from `arr` was removed that **was not the first or last value in the array**.\n\nGiven `arr`, return _the removed value_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[5,7,11,13\\]\n**Output:** 9\n**Explanation:** The previous array was \\[5,7,**9**,11,13\\].\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[15,13,12\\]\n**Output:** 14\n**Explanation:** The previous array was \\[15,**14**,13,12\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 1000`\n*   `0 <= arr[i] <= 105`\n*   The given array is **guaranteed** to be a valid array.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,7,11,13]",
                "output": "9"
            },
            {
                "input": "[15,13,12]",
                "output": "14"
            }
        ],
        "java": "\n    ```java\npublic int mctFromLeafValues(int[] arr) {\n    int n = arr.length;\n    int[][] dp = new int[n][n];\n    int[][] maxs = new int[n][n];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            maxs[i][j] = Arrays.stream(arr, i, j + 1).max().getAsInt();\n        }\n    }\n\n    for (int len = 1; len < n; ++len) {\n        for (int i = 0; i + len < n; ++i) {\n            int j = i + len;\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "python": "\n    ```python\ndef mctFromLeafValues(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    maxs = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            maxs[i][j] = max(arr[i:j+1])\n\n    for len_ in range(1, n):\n        for i in range(n - len_):\n            j = i + len_\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j])\n\n    return dp[0][n - 1]\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "c++": "\n    ```cpp\nint mctFromLeafValues(vector<int>& arr) {\n    int n = arr.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    vector<vector<int>> maxs(n, vector<int>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            maxs[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);\n        }\n    }\n\n    for (int len = 1; len < n; ++len) {\n        for (int i = 0; i + len < n; ++i) {\n            int j = i + len;\n            dp[i][j] = INT_MAX;\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "js": "\n    ```javascript\nfunction mctFromLeafValues(arr) {\n    const n = arr.length;\n    const dp = Array(n).fill(0).map(() => Array(n).fill(0));\n    const maxs = Array(n).fill(0).map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = i; j < n; ++j) {\n            maxs[i][j] = Math.max(...arr.slice(i, j + 1));\n        }\n    }\n\n    for (let len = 1; len < n; ++len) {\n        for (let i = 0; i + len < n; ++i) {\n            let j = i + len;\n            dp[i][j] = Number.MAX_SAFE_INTEGER;\n            for (let k = i; k < j; ++k) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    "
    },
    {
        "id": 208,
        "title": "Meeting Scheduler",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the availability time slots arrays `slots1` and `slots2` of two people and a meeting duration `duration`, return the **earliest time slot** that works for both of them and is of duration `duration`.\n\nIf there is no common time slot that satisfies the requirements, return an **empty array**.\n\nThe format of a time slot is an array of two elements `[start, end]` representing an inclusive time range from `start` to `end`.\n\nIt is guaranteed that no two availability slots of the same person intersect with each other. That is, for any two time slots `[start1, end1]` and `[start2, end2]` of the same person, either `start1 > end2` or `start2 > end1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** slots1 = \\[\\[10,50\\],\\[60,120\\],\\[140,210\\]\\], slots2 = \\[\\[0,15\\],\\[60,70\\]\\], duration = 8\n**Output:** \\[60,68\\]\n\n",
                "**Example 2:**\n\n**Input:** slots1 = \\[\\[10,50\\],\\[60,120\\],\\[140,210\\]\\], slots2 = \\[\\[0,15\\],\\[60,70\\]\\], duration = 12\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= slots1.length, slots2.length <= 104`\n*   `slots1[i].length, slots2[i].length == 2`\n*   `slots1[i][0] < slots1[i][1]`\n*   `slots2[i][0] < slots2[i][1]`\n*   `0 <= slots1[i][j], slots2[i][j] <= 109`\n*   `1 <= duration <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[10,50],[60,120],[140,210]],[[0,15],[60,70]],8",
                "output": "[60,68]"
            },
            {
                "input": "[[10,50],[60,120],[140,210]],[[0,15],[60,70]],12",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\n    List<List<Integer>>[] adjList = new ArrayList[n][2];\n\n    for (int i = 0; i < n; i++) {\n        adjList[i][0] = new ArrayList<>();\n        adjList[i][1] = new ArrayList<>();\n    }\n\n    for (int[] edge : redEdges) {\n        adjList[edge[0]][0].add(edge[1]);\n    }\n\n    for (int[] edge : blueEdges) {\n        adjList[edge[0]][1].add(edge[1]);\n    }\n\n    int[][] dist = new int[n][2];\n    for (int[] row : dist) {\n        Arrays.fill(row, -1);\n    }\n    dist[0][0] = 0;\n    dist[0][1] = 0;\n\n    Queue<int[]> q = new LinkedList<>();\n    q.offer(new int[]{0, 0});\n    q.offer(new int[]{0, 1});\n\n    while (!q.isEmpty()) {\n        int[] cur = q.poll();\n        int node = cur[0], color = cur[1];\n        int next_color = color ^ 1;\n\n        for (int neighbor : adjList[node][next_color]) {\n            if (dist[neighbor][next_color] == -1) {\n                dist[neighbor][next_color] = dist[node][color] + 1;\n                q.offer(new int[]{neighbor, next_color});\n            }\n        }\n    }\n\n    int[] result = new int[n];\n    for (int i = 0; i < n; i++) {\n        result[i] = Math.min(dist[i][0], dist[i][1]);\n        if (dist[i][0] == -1 || dist[i][1] == -1) {\n            result[i] = Math.max(dist[i][0], dist[i][1]);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm starts by constructing an adjacency list to store the graph's edges. It uses a 3D array (n x 2) for adjacency lists, where one dimension represents nodes, another represents the edge color (0 for red, 1 for blue), and the third is a list of connected neighbors.\n\nIt initializes a distance array (dist) to store the minimum distance from node 0 to each node by alternating edge colors. The initial distances are all set to -1, except for the distances from 0 to itself (0 for red and blue).\n\nThe algorithm then uses a standard BFS traversal. It alternates the edge colors at each step of the BFS by bitwise XOR (^) of the current edge color (this switches between 0 and 1). If the distance to a neighbor node by the next edge color hasn't been visited yet, it updates the distance and adds the neighbor to the queue.\n\nAfter the traversal, the algorithm constructs the result by iterating through the distances array and calculates the minimum of the distances by red and blue edges. If only one of the distances is -1, the other valid distance is considered, otherwise returns -1 if both are -1.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef shortestAlternatingPaths(n, redEdges, blueEdges):\n    adj_list = defaultdict(lambda: defaultdict(set))\n    \n    for u, v in redEdges:\n        adj_list[u][0].add(v)\n        \n    for u, v in blueEdges:\n        adj_list[u][1].add(v)\n        \n    dist = [[-1] * 2 for _ in range(n)]\n    dist[0] = [0, 0]\n    \n    q = deque([(0,0), (0,1)])\n\n    while q:\n        node, color = q.popleft()\n        next_color = color ^ 1\n        \n        for neighbor in adj_list[node][next_color]:\n            if dist[neighbor][next_color] == -1:\n                dist[neighbor][next_color] = dist[node][color] + 1\n                q.append((neighbor, next_color))\n                \n    result = []\n    for a, b in dist:\n        result.append(min(a, b) if a != -1 and b != -1 else max(a, b))\n        \n    return result\n```\n\n    \n    The algorithm starts by constructing an adjacency list to store the graph's edges. It uses a 3D array (n x 2) for adjacency lists, where one dimension represents nodes, another represents the edge color (0 for red, 1 for blue), and the third is a list of connected neighbors.\n\nIt initializes a distance array (dist) to store the minimum distance from node 0 to each node by alternating edge colors. The initial distances are all set to -1, except for the distances from 0 to itself (0 for red and blue).\n\nThe algorithm then uses a standard BFS traversal. It alternates the edge colors at each step of the BFS by bitwise XOR (^) of the current edge color (this switches between 0 and 1). If the distance to a neighbor node by the next edge color hasn't been visited yet, it updates the distance and adds the neighbor to the queue.\n\nAfter the traversal, the algorithm constructs the result by iterating through the distances array and calculates the minimum of the distances by red and blue edges. If only one of the distances is -1, the other valid distance is considered, otherwise returns -1 if both are -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n    vector<vector<vector<int>>> adjList(n, vector<vector<int>>(2));\n    \n    for (const auto& edge : redEdges) {\n        adjList[edge[0]][0].push_back(edge[1]);\n    }\n    \n    for (const auto& edge : blueEdges) {\n        adjList[edge[0]][1].push_back(edge[1]);\n    }\n    \n    vector<vector<int>> dist(n, vector<int>(2, -1));\n    dist[0] = {0, 0};\n    \n    queue<pair<int,int>> q;\n    q.push({0, 0});\n    q.push({0, 1});\n    \n    while (!q.empty()) {\n        int node = q.front().first, color = q.front().second;\n        q.pop();\n        int next_color = color ^ 1;\n        \n        for (int neighbor : adjList[node][next_color]) {\n            if (dist[neighbor][next_color] == -1) {\n                dist[neighbor][next_color] = dist[node][color] + 1;\n                q.push({neighbor, next_color});\n            }\n        }\n    }\n    \n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        result[i] = min(dist[i][0], dist[i][1]);\n        if (dist[i][0] == -1 || dist[i][1] == -1) {\n            result[i] = max(dist[i][0], dist[i][1]);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm starts by constructing an adjacency list to store the graph's edges. It uses a 3D array (n x 2) for adjacency lists, where one dimension represents nodes, another represents the edge color (0 for red, 1 for blue), and the third is a list of connected neighbors.\n\nIt initializes a distance array (dist) to store the minimum distance from node 0 to each node by alternating edge colors. The initial distances are all set to -1, except for the distances from 0 to itself (0 for red and blue).\n\nThe algorithm then uses a standard BFS traversal. It alternates the edge colors at each step of the BFS by bitwise XOR (^) of the current edge color (this switches between 0 and 1). If the distance to a neighbor node by the next edge color hasn't been visited yet, it updates the distance and adds the neighbor to the queue.\n\nAfter the traversal, the algorithm constructs the result by iterating through the distances array and calculates the minimum of the distances by red and blue edges. If only one of the distances is -1, the other valid distance is considered, otherwise returns -1 if both are -1.\n    ",
        "js": "\n    ```javascript\nfunction shortestAlternatingPaths(n, redEdges, blueEdges) {\n    const adjList = new Array(n).fill(null).map(_ => new Array(2).fill(null).map(_ => []));\n\n    for (const edge of redEdges) {\n        adjList[edge[0]][0].push(edge[1]);\n    }\n\n    for (const edge of blueEdges) {\n        adjList[edge[0]][1].push(edge[1]);\n    }\n\n    const dist = new Array(n).fill(null).map(_ => new Array(2).fill(-1));\n    dist[0][0] = 0;\n    dist[0][1] = 0;\n\n    const q = [[0, 0], [0, 1]];\n\n    while (q.length > 0) {\n        const [node, color] = q.shift();\n        const next_color = color ^ 1;\n\n        for (const neighbor of adjList[node][next_color]) {\n            if (dist[neighbor][next_color] === -1) {\n                dist[neighbor][next_color] = dist[node][color] + 1;\n                q.push([neighbor, next_color]);\n            }\n        }\n    }\n\n    const result = new Array(n);\n    for (let i = 0; i < n; i++) {\n        result[i] = Math.min(dist[i][0], dist[i][1]);\n        if (dist[i][0] === -1 || dist[i][1] === -1) {\n            result[i] = Math.max(dist[i][0], dist[i][1]);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm starts by constructing an adjacency list to store the graph's edges. It uses a 3D array (n x 2) for adjacency lists, where one dimension represents nodes, another represents the edge color (0 for red, 1 for blue), and the third is a list of connected neighbors.\n\nIt initializes a distance array (dist) to store the minimum distance from node 0 to each node by alternating edge colors. The initial distances are all set to -1, except for the distances from 0 to itself (0 for red and blue).\n\nThe algorithm then uses a standard BFS traversal. It alternates the edge colors at each step of the BFS by bitwise XOR (^) of the current edge color (this switches between 0 and 1). If the distance to a neighbor node by the next edge color hasn't been visited yet, it updates the distance and adds the neighbor to the queue.\n\nAfter the traversal, the algorithm constructs the result by iterating through the distances array and calculates the minimum of the distances by red and blue edges. If only one of the distances is -1, the other valid distance is considered, otherwise returns -1 if both are -1.\n    "
    },
    {
        "id": 209,
        "title": "Toss Strange Coins",
        "difficulty": "Medium",
        "content": {
            "problem": "You have some coins. The `i`\\-th coin has a probability `prob[i]` of facing heads when tossed.\n\nReturn the probability that the number of coins facing heads equals `target` if you toss every coin exactly once.",
            "examples": [
                "**Example 1:**\n\n**Input:** prob = \\[0.4\\], target = 1\n**Output:** 0.40000\n\n",
                "**Example 2:**\n\n**Input:** prob = \\[0.5,0.5,0.5,0.5,0.5\\], target = 0\n**Output:** 0.03125"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prob.length <= 1000`\n*   `0 <= prob[i] <= 1`\n*   `0 <= target` `<= prob.length`\n*   Answers will be accepted as correct if they are within `10^-5` of the correct answer.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0.4],1",
                "output": "0.40000"
            },
            {
                "input": "[0.5,0.5,0.5,0.5,0.5],0",
                "output": "0.03125"
            }
        ],
        "java": "\n    ```java\npublic int maxValue(int[] arr1, int[] arr2) {\n    int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE,\n        max3 = Integer.MIN_VALUE, max4 = Integer.MIN_VALUE;\n    int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE,\n        min3 = Integer.MAX_VALUE, min4 = Integer.MAX_VALUE;\n    int n = arr1.length;\n\n    for (int i = 0; i < n; i++) {\n        max1 = Math.max(max1, arr1[i] - arr2[i] + i);\n        max2 = Math.max(max2, arr1[i] + arr2[i] + i);\n        max3 = Math.max(max3, -arr1[i] + arr2[i] + i);\n        max4 = Math.max(max4, -arr1[i] - arr2[i] + i);\n\n        min1 = Math.min(min1, arr1[i] - arr2[i] + i);\n        min2 = Math.min(min2, arr1[i] + arr2[i] + i);\n        min3 = Math.min(min3, -arr1[i] + arr2[i] + i);\n        min4 = Math.min(min4, -arr1[i] - arr2[i] + i);\n    }\n    return Math.max(Math.max(max1 - min1, max2 - min2),\n            Math.max(max3 - min3, max4 - min4));\n}\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    ",
        "python": "\n    ```python\ndef max_value(arr1, arr2):\n    n = len(arr1)\n    max1 = max2 = max3 = max4 = float('-inf')\n    min1 = min2 = min3 = min4 = float('inf')\n\n    for i in range(n):\n        max1 = max(max1, arr1[i] - arr2[i] + i)\n        max2 = max(max2, arr1[i] + arr2[i] + i)\n        max3 = max(max3, -arr1[i] + arr2[i] + i)\n        max4 = max(max4, -arr1[i] - arr2[i] + i)\n\n        min1 = min(min1, arr1[i] - arr2[i] + i)\n        min2 = min(min2, arr1[i] + arr2[i] + i)\n        min3 = min(min3, -arr1[i] + arr2[i] + i)\n        min4 = min(min4, -arr1[i] - arr2[i] + i)\n\n    return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    ",
        "c++": "\n    ```cpp\nint max_value(int arr1[], int arr2[], int n) {\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN, max4 = INT_MIN;\n    int min1 = INT_MAX, min2 = INT_MAX, min3 = INT_MAX, min4 = INT_MAX;\n\n    for (int i = 0; i < n; i++) {\n        max1 = max(max1, arr1[i] - arr2[i] + i);\n        max2 = max(max2, arr1[i] + arr2[i] + i);\n        max3 = max(max3, -arr1[i] + arr2[i] + i);\n        max4 = max(max4, -arr1[i] - arr2[i] + i);\n\n        min1 = min(min1, arr1[i] - arr2[i] + i);\n        min2 = min(min2, arr1[i] + arr2[i] + i);\n        min3 = min(min3, -arr1[i] + arr2[i] + i);\n        min4 = min(min4, -arr1[i] - arr2[i] + i);\n    }\n    return max({max1 - min1, max2 - min2, max3 - min3, max4 - min4});\n}\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(arr1, arr2) {\n    let max1 = -Infinity, max2 = -Infinity, max3 = -Infinity, max4 = -Infinity;\n    let min1 = Infinity, min2 = Infinity, min3 = Infinity, min4 = Infinity;\n    let n = arr1.length;\n\n    for (let i = 0; i < n; i++) {\n        max1 = Math.max(max1, arr1[i] - arr2[i] + i);\n        max2 = Math.max(max2, arr1[i] + arr2[i] + i);\n        max3 = Math.max(max3, -arr1[i] + arr2[i] + i);\n        max4 = Math.max(max4, -arr1[i] - arr2[i] + i);\n\n        min1 = Math.min(min1, arr1[i] - arr2[i] + i);\n        min2 = Math.min(min2, arr1[i] + arr2[i] + i);\n        min3 = Math.min(min3, -arr1[i] + arr2[i] + i);\n        min4 = Math.min(min4, -arr1[i] - arr2[i] + i);\n    }\n    return Math.max(Math.max(max1 - min1, max2 - min2),\n            Math.max(max3 - min3, max4 - min4));\n}\n```\n\n    \n    The algorithm first initializes four maximum and four minimum values with appropriate maximum and minimum integer values for the specific programming language. \n\nFor each i in [0, arr1.length), the algorithm calculates the maximum and minimum values for the four possibilities of the expression, i.e.,\n1. arr1[i] - arr2[i] + i\n2. arr1[i] + arr2[i] + i\n3. -arr1[i] + arr2[i] + i\n4. -arr1[i] - arr2[i] + i\n\nAt the end of the loop, the algorithm returns the maximum value of the differences between each maximum value and its corresponding minimum value.\n\nThis approach ensures that the maximum value of the given expression is found efficiently in O(n) time complexity.\n    "
    },
    {
        "id": 210,
        "title": "Divide Chocolate",
        "difficulty": "Hard",
        "content": {
            "problem": "You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array `sweetness`.\n\nYou want to share the chocolate with your `k` friends so you start cutting the chocolate bar into `k + 1` pieces using `k` cuts, each piece consists of some **consecutive** chunks.\n\nBeing generous, you will eat the piece with the **minimum total sweetness** and give the other pieces to your friends.\n\nFind the **maximum total sweetness** of the piece you can get by cutting the chocolate bar optimally.",
            "examples": [
                "**Example 1:**\n\n**Input:** sweetness = \\[1,2,3,4,5,6,7,8,9\\], k = 5\n**Output:** 6\n**Explanation:** You can divide the chocolate to \\[1,2,3\\], \\[4,5\\], \\[6\\], \\[7\\], \\[8\\], \\[9\\]\n\n",
                "**Example 2:**\n\n**Input:** sweetness = \\[5,6,7,8,9,1,2,3,4\\], k = 8\n**Output:** 1\n**Explanation:** There is only one way to cut the bar into 9 pieces.\n\n",
                "**Example 3:**\n\n**Input:** sweetness = \\[1,2,2,1,2,2,1,2,2\\], k = 2\n**Output:** 5\n**Explanation:** You can divide the chocolate to \\[1,2,2\\], \\[1,2,2\\], \\[1,2,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= k < sweetness.length <= 104`\n*   `1 <= sweetness[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5,6,7,8,9],5",
                "output": "6"
            },
            {
                "input": "[5,6,7,8,9,1,2,3,4],8",
                "output": "1"
            },
            {
                "input": "[1,2,2,1,2,2,1,2,2],2",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int[] replaceElements(int[] arr) {\n    int n = arr.length;\n    int maxElement = -1;\n    for (int i = n - 1; i >= 0; i--) {\n        int temp = arr[i];\n        arr[i] = maxElement;\n        maxElement = Math.max(maxElement, temp);\n    }\n    return arr;\n}\n```\n    \n    The algorithm works by iterating through the array in reverse order. It keeps track of the maximum element found so far as it iterates through the array. In each iteration, the current element in the array is replaced with the maximum element found so far (initially set as -1, following the problem statement). The iteration then continues to the next element in reverse order and keeps updating the maximum element found. Finally, the modified array is returned.\n    ",
        "python": "\n    ```python\ndef replaceElements(arr):\n    n = len(arr)\n    maxElement = -1\n    for i in range(n - 1, -1, -1):\n        temp = arr[i]\n        arr[i] = maxElement\n        maxElement = max(maxElement, temp)\n    return arr\n```\n    \n    The algorithm works by iterating through the array in reverse order. It keeps track of the maximum element found so far as it iterates through the array. In each iteration, the current element in the array is replaced with the maximum element found so far (initially set as -1, following the problem statement). The iteration then continues to the next element in reverse order and keeps updating the maximum element found. Finally, the modified array is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> replaceElements(vector<int>& arr) {\n    int n = arr.size();\n    int maxElement = -1;\n    for (int i = n - 1; i >= 0; i--) {\n        int temp = arr[i];\n        arr[i] = maxElement;\n        maxElement = max(maxElement, temp);\n    }\n    return arr;\n}\n```\n    \n    The algorithm works by iterating through the array in reverse order. It keeps track of the maximum element found so far as it iterates through the array. In each iteration, the current element in the array is replaced with the maximum element found so far (initially set as -1, following the problem statement). The iteration then continues to the next element in reverse order and keeps updating the maximum element found. Finally, the modified array is returned.\n    ",
        "js": "\n    ```javascript\nfunction replaceElements(arr) {\n    let n = arr.length;\n    let maxElement = -1;\n    for (let i = n - 1; i >= 0; i--) {\n        let temp = arr[i];\n        arr[i] = maxElement;\n        maxElement = Math.max(maxElement, temp);\n    }\n    return arr;\n}\n```\n    \n    The algorithm works by iterating through the array in reverse order. It keeps track of the maximum element found so far as it iterates through the array. In each iteration, the current element in the array is replaced with the maximum element found so far (initially set as -1, following the problem statement). The iteration then continues to the next element in reverse order and keeps updating the maximum element found. Finally, the modified array is returned.\n    "
    },
    {
        "id": 211,
        "title": "Web Crawler",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a url `startUrl` and an interface `HtmlParser`, implement a web crawler to crawl all links that are under the **same hostname** as `startUrl`.\n\nReturn all urls obtained by your web crawler in **any** order.\n\nYour crawler should:\n\n*   Start from the page: `startUrl`\n*   Call `HtmlParser.getUrls(url)` to get all urls from a webpage of given url.\n*   Do not crawl the same link twice.\n*   Explore only the links that are under the **same hostname** as `startUrl`.\n\nAs shown in the example url above, the hostname is `example.org`. For simplicity sake, you may assume all urls use **http protocol** without any **port** specified. For example, the urls `http://leetcode.com/problems` and `http://leetcode.com/contest` are under the same hostname, while urls `http://example.org/test` and `http://example.com/abc` are not under the same hostname.\n\nThe `HtmlParser` interface is defined as such:\n\ninterface HtmlParser {\n  // Return a list of all urls from a webpage of given _url_.\n  public List getUrls(String url);\n}\n\nBelow are two examples explaining the functionality of the problem, for custom testing purposes you'll have three variables `urls`, `edges` and `startUrl`. Notice that you will only have access to `startUrl` in your code, while `urls` and `edges` are not directly accessible to you in code.\n\nNote: Consider the same URL with the trailing slash \"/ \" as a different URL. For example, \"http://news.yahoo.com \", and \"http://news.yahoo.com/ \" are different urls.",
            "examples": [
                "**Example 1:**\n\n**Input:**\nurls = \\[\n   \"http://news.yahoo.com \",\n   \"http://news.yahoo.com/news \",\n   \"http://news.yahoo.com/news/topics/ \",\n   \"http://news.google.com \",\n   \"http://news.yahoo.com/us \"\n\\]\nedges = \\[\\[2,0\\],\\[2,1\\],\\[3,2\\],\\[3,1\\],\\[0,4\\]\\]\nstartUrl =  \"http://news.yahoo.com/news/topics/ \"\n**Output:** \\[\n   \"http://news.yahoo.com \",\n   \"http://news.yahoo.com/news \",\n   \"http://news.yahoo.com/news/topics/ \",\n   \"http://news.yahoo.com/us \"\n\\]\n\n",
                "**Example 2:**\n\n**Input:** \nurls = \\[\n   \"http://news.yahoo.com \",\n   \"http://news.yahoo.com/news \",\n   \"http://news.yahoo.com/news/topics/ \",\n   \"http://news.google.com \"\n\\]\nedges = \\[\\[0,2\\],\\[2,1\\],\\[3,2\\],\\[3,1\\],\\[3,0\\]\\]\nstartUrl =  \"http://news.google.com \"\n**Output:** \\[ \"http://news.google.com \"\\]\n**Explanation:** The startUrl links to all other pages that do not share the same hostname."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= urls.length <= 1000`\n*   `1 <= urls[i].length <= 300`\n*   `startUrl` is one of the `urls`.\n*   Hostname label must be from 1 to 63 characters long, including the dots, may contain only the ASCII letters from 'a' to 'z', digits from '0' to '9' and the hyphen-minus character ('-').\n*   The hostname may not start or end with the hyphen-minus character ('-').\n*   See: [https://en.wikipedia.org/wiki/Hostname#Restrictions\\_on\\_valid\\_hostnames](https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames)\n*   You may assume there're no duplicates in url library.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\n\"http://news.yahoo.com\",\n\"http://news.yahoo.com/news\",\n\"http://news.yahoo.com/news/topics/\",\n\"http://news.google.com\",\n\"http://news.yahoo.com/us\"\n]\nedges=[[2,0],[2,1],[3,2],[3,1],[0,4]]\nstartUrl=\"http://news.yahoo.com/news/topics/\"",
                "output": "[\n\"http://news.yahoo.com\",\n\"http://news.yahoo.com/news\",\n\"http://news.yahoo.com/news/topics/\",\n\"http://news.yahoo.com/us\"\n]"
            },
            {
                "input": "[\n\"http://news.yahoo.com\",\n\"http://news.yahoo.com/news\",\n\"http://news.yahoo.com/news/topics/\",\n\"http://news.google.com\"\n]\nedges=[[0,2],[2,1],[3,2],[3,1],[3,0]]\nstartUrl=\"http://news.google.com\"",
                "output": "[\"http://news.google.com\"]"
            }
        ],
        "java": "\n    ```java\npublic int tribonacci(int n) {\n    if(n==0) return 0;\n    if(n==1 || n==2) return 1;\n    int a = 0, b = 1, c = 1, d;\n    for(int i = 3; i <= n; i++) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n```\n    \n    The algorithm initializes the first three Tribonacci numbers `a`, `b`, and `c` with the values `0`, `1`, and `1`, respectively. It then iterates from `i=3` to `i=n`, computing each next Tribonacci number as the sum of the previous three (`a, b, c`). After each iteration, it shifts the values of `a`, `b`, and `c` to the right, dropping the smallest one and assigning the new calculated value to the last position. This is done until the value of `c` is the nth Tribonacci number.\n\nFinally, the algorithm returns the latest value of `c`, which represents the desired Tribonacci number `Tn`.\n    ",
        "python": "\n    ```python\ndef tribonacci(n: int) -> int:\n    if n == 0: return 0\n    if n == 1 or n == 2: return 1\n    a, b, c = 0, 1, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c\n```\n    \n    The algorithm initializes the first three Tribonacci numbers `a`, `b`, and `c` with the values `0`, `1`, and `1`, respectively. It then iterates from `i=3` to `i=n`, computing each next Tribonacci number as the sum of the previous three (`a, b, c`). After each iteration, it shifts the values of `a`, `b`, and `c` to the right, dropping the smallest one and assigning the new calculated value to the last position. This is done until the value of `c` is the nth Tribonacci number.\n\nFinally, the algorithm returns the latest value of `c`, which represents the desired Tribonacci number `Tn`.\n    ",
        "c++": "\n    ```cpp\nint tribonacci(int n) {\n    if(n==0) return 0;\n    if(n==1 || n==2) return 1;\n    int a = 0, b = 1, c = 1, d;\n    for(int i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n```\n    \n    The algorithm initializes the first three Tribonacci numbers `a`, `b`, and `c` with the values `0`, `1`, and `1`, respectively. It then iterates from `i=3` to `i=n`, computing each next Tribonacci number as the sum of the previous three (`a, b, c`). After each iteration, it shifts the values of `a`, `b`, and `c` to the right, dropping the smallest one and assigning the new calculated value to the last position. This is done until the value of `c` is the nth Tribonacci number.\n\nFinally, the algorithm returns the latest value of `c`, which represents the desired Tribonacci number `Tn`.\n    ",
        "js": "\n    ```javascript\nfunction tribonacci(n) {\n    if(n==0) return 0;\n    if(n==1 || n==2) return 1;\n    let a = 0, b = 1, c = 1, d;\n    for(let i = 3; i <= n; ++i) {\n        d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n}\n```\n    \n    The algorithm initializes the first three Tribonacci numbers `a`, `b`, and `c` with the values `0`, `1`, and `1`, respectively. It then iterates from `i=3` to `i=n`, computing each next Tribonacci number as the sum of the previous three (`a, b, c`). After each iteration, it shifts the values of `a`, `b`, and `c` to the right, dropping the smallest one and assigning the new calculated value to the last position. This is done until the value of `c` is the nth Tribonacci number.\n\nFinally, the algorithm returns the latest value of `c`, which represents the desired Tribonacci number `Tn`.\n    "
    },
    {
        "id": 212,
        "title": "Array Transformation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an initial array `arr`, every day you produce a new array using the array of the previous day.\n\nOn the `i`\\-th day, you do the following operations on the array of day `i-1` to produce the array of day `i`:\n\n1.  If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.\n2.  If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.\n3.  The first and last elements never change.\n\nAfter some days, the array does not change. Return that final array.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[6,2,3,4\\]\n**Output:** \\[6,3,3,4\\]\n**Explanation:** \nOn the first day, the array is changed from \\[6,2,3,4\\] to \\[6,3,3,4\\].\nNo more operations can be done to this array.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,6,3,4,3,5\\]\n**Output:** \\[1,4,4,4,4,5\\]\n**Explanation:** \nOn the first day, the array is changed from \\[1,6,3,4,3,5\\] to \\[1,5,4,3,4,5\\].\nOn the second day, the array is changed from \\[1,5,4,3,4,5\\] to \\[1,4,4,4,4,5\\].\nNo more operations can be done to this array."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 100`\n*   `1 <= arr[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[6,2,3,4]",
                "output": "[6,3,3,4]"
            },
            {
                "input": "[1,6,3,4,3,5]",
                "output": "[1,4,4,4,4,5]"
            }
        ],
        "java": "\n    ```java\npublic int sumEvenGrandparent(TreeNode root) {\n    return sumEvenGrandparent(root, null, null);\n}\n\nprivate int sumEvenGrandparent(TreeNode root, TreeNode parent, TreeNode grandparent) {\n    if (root == null) return 0;\n    int sum = 0;\n    if (grandparent != null && grandparent.val % 2 == 0) {\n        sum += root.val;\n    }\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);\n    return sum;\n}\n```\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "python": "\n    ```python\ndef sumEvenGrandparent(root, parent=None, grandparent=None):\n    if not root:\n        return 0\n    sum = 0\n    if grandparent and grandparent.val % 2 == 0:\n        sum += root.val\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)\n    return sum\n```\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "c++": "\n    ```cpp\nint sumEvenGrandparent(TreeNode* root, TreeNode* parent = nullptr, TreeNode* grandparent = nullptr) {\n    if (!root) return 0;\n    int sum = 0;\n    if (grandparent && grandparent->val % 2 == 0) {\n        sum += root->val;\n    }\n    sum += sumEvenGrandparent(root->left, root, parent) + sumEvenGrandparent(root->right, root, parent);\n    return sum;\n}\n```\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "js": "\n    ```javascript\nfunction sumEvenGrandparent(root, parent = null, grandparent = null) {\n    if (!root) return 0;\n    let sum = 0;\n    if (grandparent && grandparent.val % 2 === 0) {\n        sum += root.val;\n    }\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);\n    return sum;\n}\n```\n\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    "
    },
    {
        "id": 213,
        "title": "Design A Leaderboard",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a Leaderboard class, which has 3 functions:\n\n1.  `addScore(playerId, score)`: Update the leaderboard by adding `score` to the given player's score. If there is no player with such id in the leaderboard, add him to the leaderboard with the given `score`.\n2.  `top(K)`: Return the score sum of the top `K` players.\n3.  `reset(playerId)`: Reset the score of the player with the given id to 0 (in other words erase it from the leaderboard). It is guaranteed that the player was added to the leaderboard before calling this function.\n\nInitially, the leaderboard is empty.",
            "examples": [
                "**Example 1:**\n\n**Input:** \n\\[ \"Leaderboard \", \"addScore \", \"addScore \", \"addScore \", \"addScore \", \"addScore \", \"top \", \"reset \", \"reset \", \"addScore \", \"top \"\\]\n\\[\\[\\],\\[1,73\\],\\[2,56\\],\\[3,39\\],\\[4,51\\],\\[5,4\\],\\[1\\],\\[1\\],\\[2\\],\\[2,51\\],\\[3\\]\\]\n**Output:** \n\\[null,null,null,null,null,null,73,null,null,null,141\\]\n\n**Explanation:** \nLeaderboard leaderboard = new Leaderboard ();\nleaderboard.addScore(1,73);   // leaderboard = \\[\\[1,73\\]\\];\nleaderboard.addScore(2,56);   // leaderboard = \\[\\[1,73\\],\\[2,56\\]\\];\nleaderboard.addScore(3,39);   // leaderboard = \\[\\[1,73\\],\\[2,56\\],\\[3,39\\]\\];\nleaderboard.addScore(4,51);   // leaderboard = \\[\\[1,73\\],\\[2,56\\],\\[3,39\\],\\[4,51\\]\\];\nleaderboard.addScore(5,4);    // leaderboard = \\[\\[1,73\\],\\[2,56\\],\\[3,39\\],\\[4,51\\],\\[5,4\\]\\];\nleaderboard.top(1);           // returns 73;\nleaderboard.reset(1);         // leaderboard = \\[\\[2,56\\],\\[3,39\\],\\[4,51\\],\\[5,4\\]\\];\nleaderboard.reset(2);         // leaderboard = \\[\\[3,39\\],\\[4,51\\],\\[5,4\\]\\];\nleaderboard.addScore(2,51);   // leaderboard = \\[\\[2,51\\],\\[3,39\\],\\[4,51\\],\\[5,4\\]\\];\nleaderboard.top(3);           // returns 141 = 51 + 51 + 39;"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= playerId, K <= 10000`\n*   It's guaranteed that `K` is less than or equal to the current number of players.\n*   `1 <= score <= 100`\n*   There will be at most `1000` function calls.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],],],],]]",
                "output": "\n[null,null,null,null,null,null,73,null,null,null,141]"
            }
        ],
        "java": "\n    ```java\nint numDistinctRepeatedSubstrings(String s) {\n    HashSet<String> seen = new HashSet<>();\n    for (int len = s.length() / 2; len >= 1; len--) {\n        for (int i = 0; i <= s.length() - 2 * len; i++) {\n            String substr = s.substring(i, i + len);\n            if (s.indexOf(substr, i + len) != -1)\n                seen.add(substr);\n        }\n    }\n    return seen.size();\n}\n```\n\n    \n    1. Initialize an empty set `seen` to store distinct substrings.\n2. Iterate over the possible lengths of a substring from half the length of the input string to 1 (inclusive), because the maximum length of the duplicated substring would be half the length of the text in case it's fully repeated.\n3. For each length, iterate over the string and extract a substring of that length starting at the current position.\n4. Check if there is another occurrence of this substring after the current position (i.e., if it can be concatenated with itself).\n5. If it satisfies the above condition, add it to the `seen` set.\n6. At the end of the iterations, return the size of the `seen` set to get the number of distinct non-empty substrings that can be written as a concatenation of some string with itself. \n    ",
        "python": "\n    ```python\ndef num_distinct_repeated_substrings(s):\n    seen = set()\n    for length in range(len(s) // 2, 0, -1):\n        for i in range(len(s) - 2 * length + 1):\n            substr = s[i:i + length]\n            if substr in s[i + length:]:\n                seen.add(substr)\n    return len(seen)\n```\n\n    \n    1. Initialize an empty set `seen` to store distinct substrings.\n2. Iterate over the possible lengths of a substring from half the length of the input string to 1 (inclusive), because the maximum length of the duplicated substring would be half the length of the text in case it's fully repeated.\n3. For each length, iterate over the string and extract a substring of that length starting at the current position.\n4. Check if there is another occurrence of this substring after the current position (i.e., if it can be concatenated with itself).\n5. If it satisfies the above condition, add it to the `seen` set.\n6. At the end of the iterations, return the size of the `seen` set to get the number of distinct non-empty substrings that can be written as a concatenation of some string with itself. \n    ",
        "c++": "\n    ```cpp\nint numDistinctRepeatedSubstrings(const string& s) {\n    unordered_set<string> seen;\n    for (int len = s.length() / 2; len >= 1; len--) {\n        for (int i = 0; i <= s.length() - 2 * len; i++) {\n            string substr = s.substr(i, len);\n            if (s.find(substr, i + len) != string::npos)\n                seen.insert(substr);\n        }\n    }\n    return seen.size();\n}\n```\n\n    \n    1. Initialize an empty set `seen` to store distinct substrings.\n2. Iterate over the possible lengths of a substring from half the length of the input string to 1 (inclusive), because the maximum length of the duplicated substring would be half the length of the text in case it's fully repeated.\n3. For each length, iterate over the string and extract a substring of that length starting at the current position.\n4. Check if there is another occurrence of this substring after the current position (i.e., if it can be concatenated with itself).\n5. If it satisfies the above condition, add it to the `seen` set.\n6. At the end of the iterations, return the size of the `seen` set to get the number of distinct non-empty substrings that can be written as a concatenation of some string with itself. \n    ",
        "js": "\n    ```javascript\nfunction numDistinctRepeatedSubstrings(s) {\n  let seen = new Set();\n  for (let len = Math.floor(s.length / 2); len >= 1; len--) {\n    for (let i = 0; i <= s.length - 2 * len; i++) {\n      let substr = s.slice(i, i + len);\n      if (s.indexOf(substr, i + len) !== -1)\n        seen.add(substr);\n    }\n  }\n  return seen.size;\n}\n```\n\n    \n    1. Initialize an empty set `seen` to store distinct substrings.\n2. Iterate over the possible lengths of a substring from half the length of the input string to 1 (inclusive), because the maximum length of the duplicated substring would be half the length of the text in case it's fully repeated.\n3. For each length, iterate over the string and extract a substring of that length starting at the current position.\n4. Check if there is another occurrence of this substring after the current position (i.e., if it can be concatenated with itself).\n5. If it satisfies the above condition, add it to the `seen` set.\n6. At the end of the iterations, return the size of the `seen` set to get the number of distinct non-empty substrings that can be written as a concatenation of some string with itself. \n    "
    },
    {
        "id": 214,
        "title": "Tree Diameter",
        "difficulty": "Medium",
        "content": {
            "problem": "The **diameter** of a tree is **the number of edges** in the longest path in that tree.\n\nThere is an undirected tree of `n` nodes labeled from `0` to `n - 1`. You are given a 2D array `edges` where `edges.length == n - 1` and `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the tree.\n\nReturn _the **diameter** of the tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[0,2\\]\\]\n**Output:** 2\n**Explanation:** The longest path of the tree is the path 1 - 0 - 2.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[1,4\\],\\[4,5\\]\\]\n**Output:** 4\n**Explanation:** The longest path of the tree is the path 3 - 2 - 1 - 4 - 5."
            ],
            "constraints": "**Constraints:**\n\n*   `n == edges.length + 1`\n*   `1 <= n <= 104`\n*   `0 <= ai, bi < n`\n*   `ai != bi`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1],[0,2]]",
                "output": "2"
            },
            {
                "input": "[[0,1],[1,2],[2,3],[1,4],[4,5]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int treeDiameter(int[][] edges) {\n        Map<Integer, List<Integer>> tree = new HashMap<>();\n        for (int[] edge : edges) {\n            tree.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\n            tree.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\n        }\n\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[] {0, 0});\n        int furthest = 0;\n        int maxDistance = 0;\n        while (!queue.isEmpty()) {\n            int[] info = queue.poll();\n            int node = info[0];\n            int distance = info[1];\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                furthest = node;\n            }\n            for (int neighbor : tree.get(node)) {\n                tree.get(neighbor).remove((Integer)node);\n                queue.add(new int[] {neighbor, distance + 1});\n            }\n        }\n\n        queue.add(new int[] {furthest, 0});\n        maxDistance = 0;\n        while (!queue.isEmpty()) {\n            int[] info = queue.poll();\n            int node = info[0];\n            int distance = info[1];\n            if (distance > maxDistance) {\n                maxDistance = distance;\n            }\n            for (int neighbor : tree.get(node)) {\n                tree.get(neighbor).remove((Integer)node);\n                queue.add(new int[] {neighbor, distance + 1});\n            }\n        }\n\n        return maxDistance;\n    }\n}\n```\n    \n    To calculate the diameter of the tree, we can perform two breadth-first searches (BFS). First, we start a BFS from any arbitrary node (we can choose node 0) and find the furthest node in the tree. Then, we start another BFS from the furthest node found in the previous step and find its furthest node. The distance between these two nodes is the diameter of the tree.\n\n1. Construct the tree from the given edges, storing each node's neighbors in a data structure (hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript).\n\n2. Perform the first BFS:\n   - Initialize a queue with the starting node (0) and its distance (0).\n   - Track the furthest node and its maximum distance from the starting node.\n   - While the queue is not empty:\n     - Dequeue the current node and its distance.\n     - If the current distance is greater than the current maximum distance, update the furthest node and maximum distance.\n     - For each neighbor of the current node:\n       - Remove the edge between the current node and its neighbor.\n       - Enqueue the neighbor and its distance from the current node (distance + 1).\n\n3. Perform the second BFS (similar to the first BFS) from the furthest node found in the previous step. Calculate the new maximum distance, which is the diameter of the tree.\n\n4. Return the diameter of the tree.\n    ",
        "python": "\n    ```python\nfrom collections import deque, defaultdict\n\ndef tree_diameter(edges):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n\n    queue = deque([(0, 0)])\n    furthest, max_distance = 0, 0\n    while queue:\n        node, distance = queue.popleft()\n        if distance > max_distance:\n            max_distance = distance\n            furthest = node\n        for neighbor in tree[node]:\n            tree[neighbor].remove(node)\n            queue.append((neighbor, distance + 1))\n\n    queue.append((furthest, 0))\n    max_distance = 0\n    while queue:\n        node, distance = queue.popleft()\n        if distance > max_distance:\n            max_distance = distance\n        for neighbor in tree[node]:\n            tree[neighbor].remove(node)\n            queue.append((neighbor, distance + 1))\n\n    return max_distance\n```\n    \n    To calculate the diameter of the tree, we can perform two breadth-first searches (BFS). First, we start a BFS from any arbitrary node (we can choose node 0) and find the furthest node in the tree. Then, we start another BFS from the furthest node found in the previous step and find its furthest node. The distance between these two nodes is the diameter of the tree.\n\n1. Construct the tree from the given edges, storing each node's neighbors in a data structure (hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript).\n\n2. Perform the first BFS:\n   - Initialize a queue with the starting node (0) and its distance (0).\n   - Track the furthest node and its maximum distance from the starting node.\n   - While the queue is not empty:\n     - Dequeue the current node and its distance.\n     - If the current distance is greater than the current maximum distance, update the furthest node and maximum distance.\n     - For each neighbor of the current node:\n       - Remove the edge between the current node and its neighbor.\n       - Enqueue the neighbor and its distance from the current node (distance + 1).\n\n3. Perform the second BFS (similar to the first BFS) from the furthest node found in the previous step. Calculate the new maximum distance, which is the diameter of the tree.\n\n4. Return the diameter of the tree.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nint treeDiameter(vector<vector<int>>& edges) {\n    unordered_map<int, vector<int>> tree;\n    for (const auto& edge : edges) {\n        tree[edge[0]].push_back(edge[1]);\n        tree[edge[1]].push_back(edge[0]);\n    }\n    \n    queue<pair<int, int>> q;\n    q.push({0, 0});\n    int furthest = 0;\n    int max_distance = 0;\n    while (!q.empty()) {\n        int node = q.front().first;\n        int distance = q.front().second;\n        q.pop();\n        if (distance > max_distance) {\n            max_distance = distance;\n            furthest = node;\n        }\n        for (int neighbor : tree[node]) {\n            tree[neighbor].erase(remove(tree[neighbor].begin(), tree[neighbor].end(), node), tree[neighbor].end());\n            q.push({neighbor, distance + 1});\n        }\n    }\n    \n    q.push({furthest, 0});\n    max_distance = 0;\n    while (!q.empty()) {\n        int node = q.front().first;\n        int distance = q.front().second;\n        q.pop();\n        if (distance > max_distance) {\n            max_distance = distance;\n        }\n        for (int neighbor : tree[node]) {\n            tree[neighbor].erase(remove(tree[neighbor].begin(), tree[neighbor].end(), node), tree[neighbor].end());\n            q.push({neighbor, distance + 1});\n        }\n    }\n    \n    return max_distance;\n}\n```\n    \n    To calculate the diameter of the tree, we can perform two breadth-first searches (BFS). First, we start a BFS from any arbitrary node (we can choose node 0) and find the furthest node in the tree. Then, we start another BFS from the furthest node found in the previous step and find its furthest node. The distance between these two nodes is the diameter of the tree.\n\n1. Construct the tree from the given edges, storing each node's neighbors in a data structure (hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript).\n\n2. Perform the first BFS:\n   - Initialize a queue with the starting node (0) and its distance (0).\n   - Track the furthest node and its maximum distance from the starting node.\n   - While the queue is not empty:\n     - Dequeue the current node and its distance.\n     - If the current distance is greater than the current maximum distance, update the furthest node and maximum distance.\n     - For each neighbor of the current node:\n       - Remove the edge between the current node and its neighbor.\n       - Enqueue the neighbor and its distance from the current node (distance + 1).\n\n3. Perform the second BFS (similar to the first BFS) from the furthest node found in the previous step. Calculate the new maximum distance, which is the diameter of the tree.\n\n4. Return the diameter of the tree.\n    ",
        "js": "\n    ```javascript\n/**\n * @param {number[][]} edges\n * @return {number}\n */\nvar treeDiameter = function(edges) {\n    const tree = new Map();\n    \n    for (const edge of edges) {\n        if (!tree.has(edge[0])) tree.set(edge[0], []);\n        if (!tree.has(edge[1])) tree.set(edge[1], []);\n        \n        tree.get(edge[0]).push(edge[1]);\n        tree.get(edge[1]).push(edge[0]);\n    }\n    \n    const queue = [[0, 0]];\n    let furthest = 0;\n    let maxDistance = 0;\n    \n    while (queue.length > 0) {\n        const [node, distance] = queue.shift();\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            furthest = node;\n        }\n        \n        for (const neighbor of tree.get(node)) {\n            tree.get(neighbor).splice(tree.get(neighbor).indexOf(node), 1);\n            queue.push([neighbor, distance + 1]);\n        }\n    }\n    \n    queue.push([furthest, 0]);\n    maxDistance = 0;\n    \n    while (queue.length > 0) {\n        const [node, distance] = queue.shift();\n        if (distance > maxDistance) {\n            maxDistance = distance;\n        }\n        \n        for (const neighbor of tree.get(node)) {\n            tree.get(neighbor).splice(tree.get(neighbor).indexOf(node), 1);\n            queue.push([neighbor, distance + 1]);\n        }\n    }\n    \n    return maxDistance;\n};\n```\n    \n    To calculate the diameter of the tree, we can perform two breadth-first searches (BFS). First, we start a BFS from any arbitrary node (we can choose node 0) and find the furthest node in the tree. Then, we start another BFS from the furthest node found in the previous step and find its furthest node. The distance between these two nodes is the diameter of the tree.\n\n1. Construct the tree from the given edges, storing each node's neighbors in a data structure (hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript).\n\n2. Perform the first BFS:\n   - Initialize a queue with the starting node (0) and its distance (0).\n   - Track the furthest node and its maximum distance from the starting node.\n   - While the queue is not empty:\n     - Dequeue the current node and its distance.\n     - If the current distance is greater than the current maximum distance, update the furthest node and maximum distance.\n     - For each neighbor of the current node:\n       - Remove the edge between the current node and its neighbor.\n       - Enqueue the neighbor and its distance from the current node (distance + 1).\n\n3. Perform the second BFS (similar to the first BFS) from the furthest node found in the previous step. Calculate the new maximum distance, which is the diameter of the tree.\n\n4. Return the diameter of the tree.\n    "
    },
    {
        "id": 215,
        "title": "Palindrome Removal",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `arr`.\n\nIn one move, you can select a **palindromic** subarray `arr[i], arr[i + 1], ..., arr[j]` where `i <= j`, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal.\n\nReturn _the minimum number of moves needed to remove all numbers from the array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,2\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,3,4,1,5\\]\n**Output:** 3\n**Explanation:** Remove \\[4\\] then remove \\[1,3,1\\] then remove \\[5\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 100`\n*   `1 <= arr[i] <= 20`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2]",
                "output": "2"
            },
            {
                "input": "[1,3,4,1,5]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minimumMoves(int[] arr) {\n    int[][] dp = new int[arr.length][arr.length];\n    for (int[] row : dp)\n        Arrays.fill(row, -1);\n    return minRemovals(arr, 0, arr.length - 1, dp);\n}\n\nprivate int minRemovals(int[] arr, int i, int j, int[][] dp) {\n    if (i > j) return 0;\n    if (i == j) return 1;\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int ans = minRemovals(arr, i + 1, j, dp) + 1;\n    for (int k = i + 1; k <= j; k++) {\n        if (arr[i] == arr[k])\n            ans = Math.min(ans, minRemovals(arr, i + 1, k - 1, dp) + minRemovals(arr, k + 1, j, dp));\n    }\n    return dp[i][j] = ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach by storing results from subproblems in the `dp` array. This reduces the number of computations required. It uses a helper function `minRemovals` to recursively compute results for subproblems.\n\n1. If `i` is greater than `j`, the subarray is empty, and no moves are needed, so return 0.\n2. If `i` is equal to `j`, the subarray has one element, which is always a palindrome, so return 1.\n3. If the current subarray has been solved before (i.e., `dp[i][j] != -1`), return the precomputed result.\n4. Initialize a variable `ans` with the value of removing subarray[i] itself and finding the remaining moves for the rest of the subarray.\n5. Loop through each element in the subarray and check for elements that are equal to the first element (arr[i]). For each matching element, find the moves using the helper function for the subarrays arr[i+1...k-1] and arr[k+1...j]. Update `ans` to the minimum of the current value of `ans` and the sum of moves found for the subarrays.\n6. Save the result in the `dp` array and return `ans`.\n7. Finally, call helper function with the initial subarray and return the result.\n    ",
        "python": "\n    ```python\ndef minimumMoves(arr):\n    def minRemovals(i, j):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        if dp[i][j] != -1:\n            return dp[i][j]\n\n        ans = minRemovals(i + 1, j) + 1\n        for k in range(i + 1, j + 1):\n            if arr[i] == arr[k]:\n                ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j))\n        dp[i][j] = ans\n        return ans\n\n    dp = [[-1] * len(arr) for _ in range(len(arr))]\n    return minRemovals(0, len(arr) - 1)\n```\n    \n    The algorithm uses a dynamic programming approach by storing results from subproblems in the `dp` array. This reduces the number of computations required. It uses a helper function `minRemovals` to recursively compute results for subproblems.\n\n1. If `i` is greater than `j`, the subarray is empty, and no moves are needed, so return 0.\n2. If `i` is equal to `j`, the subarray has one element, which is always a palindrome, so return 1.\n3. If the current subarray has been solved before (i.e., `dp[i][j] != -1`), return the precomputed result.\n4. Initialize a variable `ans` with the value of removing subarray[i] itself and finding the remaining moves for the rest of the subarray.\n5. Loop through each element in the subarray and check for elements that are equal to the first element (arr[i]). For each matching element, find the moves using the helper function for the subarrays arr[i+1...k-1] and arr[k+1...j]. Update `ans` to the minimum of the current value of `ans` and the sum of moves found for the subarrays.\n6. Save the result in the `dp` array and return `ans`.\n7. Finally, call helper function with the initial subarray and return the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint dp[101][101];\n\nbool isPalindrome(const vector<int>& arr, int i, int j) {\n    while (i < j)\n        if (arr[i++] != arr[j--]) return false;\n    return true;\n}\n\nint minRemovals(vector<int>& arr, int i, int j) {\n    if (i > j) return 0;\n    if (i == j) return 1;\n    if (dp[i][j] != -1) return dp[i][j];\n\n    int ans = minRemovals(arr, i + 1, j) + 1;\n    for (int k = i + 1; k <= j; k++)\n        if (arr[i] == arr[k])\n            ans = min(ans, minRemovals(arr, i + 1, k - 1) + minRemovals(arr, k + 1, j));\n    return dp[i][j] = ans;\n}\n\nint minimumMoves(vector<int>& arr) {\n    memset(dp, -1, sizeof(dp));\n    return minRemovals(arr, 0, arr.size() - 1);\n}\n```\n    \n    The algorithm uses a dynamic programming approach by storing results from subproblems in the `dp` array. This reduces the number of computations required. It uses a helper function `minRemovals` to recursively compute results for subproblems.\n\n1. If `i` is greater than `j`, the subarray is empty, and no moves are needed, so return 0.\n2. If `i` is equal to `j`, the subarray has one element, which is always a palindrome, so return 1.\n3. If the current subarray has been solved before (i.e., `dp[i][j] != -1`), return the precomputed result.\n4. Initialize a variable `ans` with the value of removing subarray[i] itself and finding the remaining moves for the rest of the subarray.\n5. Loop through each element in the subarray and check for elements that are equal to the first element (arr[i]). For each matching element, find the moves using the helper function for the subarrays arr[i+1...k-1] and arr[k+1...j]. Update `ans` to the minimum of the current value of `ans` and the sum of moves found for the subarrays.\n6. Save the result in the `dp` array and return `ans`.\n7. Finally, call helper function with the initial subarray and return the result.\n    ",
        "js": "\n    ```javascript\nvar minimumMoves = function (arr) {\n    let dp = [];\n    for (let i = 0; i < arr.length; i++) {\n        dp[i] = Array.from({ length: arr.length }, () => -1);\n    }\n\n    function minRemovals(i, j) {\n        if (i > j) return 0;\n        if (i == j) return 1;\n        if (dp[i][j] != -1) return dp[i][j];\n\n        let ans = minRemovals(i + 1, j) + 1;\n        for (let k = i + 1; k <= j; k++) {\n            if (arr[i] == arr[k])\n                ans = Math.min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j));\n        }\n        dp[i][j] = ans;\n        return ans;\n    }\n\n    return minRemovals(0, arr.length - 1);\n};\n```\n    \n    The algorithm uses a dynamic programming approach by storing results from subproblems in the `dp` array. This reduces the number of computations required. It uses a helper function `minRemovals` to recursively compute results for subproblems.\n\n1. If `i` is greater than `j`, the subarray is empty, and no moves are needed, so return 0.\n2. If `i` is equal to `j`, the subarray has one element, which is always a palindrome, so return 1.\n3. If the current subarray has been solved before (i.e., `dp[i][j] != -1`), return the precomputed result.\n4. Initialize a variable `ans` with the value of removing subarray[i] itself and finding the remaining moves for the rest of the subarray.\n5. Loop through each element in the subarray and check for elements that are equal to the first element (arr[i]). For each matching element, find the moves using the helper function for the subarrays arr[i+1...k-1] and arr[k+1...j]. Update `ans` to the minimum of the current value of `ans` and the sum of moves found for the subarrays.\n6. Save the result in the `dp` array and return `ans`.\n7. Finally, call helper function with the initial subarray and return the result.\n    "
    },
    {
        "id": 216,
        "title": "Encode Number",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a non-negative integer `num`, Return its _encoding_ string.\n\nThe encoding is done by converting the integer to a string using a secret function that you should deduce from the following table:",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 23\n**Output:**  \"1000 \"\n\n",
                "**Example 2:**\n\n**Input:** num = 107\n**Output:**  \"101100 \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 10^9`\n\n\\- Rank is an integer starting from 1. - The larger the element, the larger the rank. If two elements are the same, their rank must be the same. - Rank should be as small as possible. Function signature: \\`int\\[\\] arrayRankTransform(int\\[\\] arr)\\`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "23",
                "output": "\"1000\""
            },
            {
                "input": "107",
                "output": "\"101100\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic int[] arrayRankTransform(int[] arr) {\n    int[] sortedArr = arr.clone();\n    Arrays.sort(sortedArr);\n    HashMap<Integer, Integer> rankMap = new HashMap<>();\n    int rank = 1;\n\n    for(int num : sortedArr) {\n        if(!rankMap.containsKey(num)) {\n            rankMap.put(num, rank++);\n        }\n    }\n\n    for(int i = 0; i < arr.length; i++) {\n        arr[i] = rankMap.get(arr[i]);\n    }\n\n    return arr;\n}\n```\n    \n    1. Create a new array, `sorted_arr`, that contains the elements of the given `arr` sorted in ascending order.\n2. Create a hash map or dictionary, `rank_map`, that will store the rank for each unique integer in the array.\n3. Initialize a `rank` variable to 1.\n4. Iterate through the sorted array, and for each unique integer not in the `rank_map`, assign its rank and increment the rank counter.\n5. Iterate through the original array, replacing each element with its corresponding rank from the `rank_map`.\n6. Return the modified array.\n    ",
        "python": "\n    ```python\ndef arrayRankTransform(arr):\n    sorted_arr = sorted(arr)\n    rank_map = {}\n    rank = 1\n\n    for num in sorted_arr:\n        if num not in rank_map:\n            rank_map[num] = rank\n            rank += 1\n\n    return [rank_map[num] for num in arr]\n```\n    \n    1. Create a new array, `sorted_arr`, that contains the elements of the given `arr` sorted in ascending order.\n2. Create a hash map or dictionary, `rank_map`, that will store the rank for each unique integer in the array.\n3. Initialize a `rank` variable to 1.\n4. Iterate through the sorted array, and for each unique integer not in the `rank_map`, assign its rank and increment the rank counter.\n5. Iterate through the original array, replacing each element with its corresponding rank from the `rank_map`.\n6. Return the modified array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> arrayRankTransform(vector<int>& arr) {\n    vector<int> sorted_arr = arr;\n    sort(sorted_arr.begin(), sorted_arr.end());\n    unordered_map<int, int> rank_map;\n    int rank = 1;\n\n    for(int num : sorted_arr) {\n        if(rank_map.find(num) == rank_map.end()) {\n            rank_map[num] = rank++;\n        }\n    }\n\n    for(int i = 0; i < arr.size(); i++) {\n        arr[i] = rank_map[arr[i]];\n    }\n\n    return arr;\n}\n```\n    \n    1. Create a new array, `sorted_arr`, that contains the elements of the given `arr` sorted in ascending order.\n2. Create a hash map or dictionary, `rank_map`, that will store the rank for each unique integer in the array.\n3. Initialize a `rank` variable to 1.\n4. Iterate through the sorted array, and for each unique integer not in the `rank_map`, assign its rank and increment the rank counter.\n5. Iterate through the original array, replacing each element with its corresponding rank from the `rank_map`.\n6. Return the modified array.\n    ",
        "js": "\n    ```javascript\nfunction arrayRankTransform(arr) {\n    const sortedArr = [...arr].sort((a, b) => a - b);\n    const rankMap = {};\n    let rank = 1;\n\n    for(const num of sortedArr) {\n        if(!(num in rankMap)) {\n            rankMap[num] = rank++;\n        }\n    }\n\n    return arr.map(num => rankMap[num]);\n}\n```\n    \n    1. Create a new array, `sorted_arr`, that contains the elements of the given `arr` sorted in ascending order.\n2. Create a hash map or dictionary, `rank_map`, that will store the rank for each unique integer in the array.\n3. Initialize a `rank` variable to 1.\n4. Iterate through the sorted array, and for each unique integer not in the `rank_map`, assign its rank and increment the rank counter.\n5. Iterate through the original array, replacing each element with its corresponding rank from the `rank_map`.\n6. Return the modified array.\n    "
    },
    {
        "id": 217,
        "title": "Smallest Common Region",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given some lists of `regions` where the first region of each list includes all other regions in that list.\n\nNaturally, if a region `x` contains another region `y` then `x` is bigger than `y`. Also, by definition, a region `x` contains itself.\n\nGiven two regions: `region1` and `region2`, return _the smallest region that contains both of them_.\n\nIf you are given regions `r1`, `r2`, and `r3` such that `r1` includes `r3`, it is guaranteed there is no `r2` such that `r2` includes `r3`.\n\nIt is guaranteed the smallest region exists.",
            "examples": [
                "**Example 1:**\n\n**Input:**\nregions = \\[\\[ \"Earth \", \"North America \", \"South America \"\\],\n\\[ \"North America \", \"United States \", \"Canada \"\\],\n\\[ \"United States \", \"New York \", \"Boston \"\\],\n\\[ \"Canada \", \"Ontario \", \"Quebec \"\\],\n\\[ \"South America \", \"Brazil \"\\]\\],\nregion1 =  \"Quebec \",\nregion2 =  \"New York \"\n**Output:**  \"North America \"\n\n",
                "**Example 2:**\n\n**Input:** regions = \\[\\[ \"Earth \",  \"North America \",  \"South America \"\\],\\[ \"North America \",  \"United States \",  \"Canada \"\\],\\[ \"United States \",  \"New York \",  \"Boston \"\\],\\[ \"Canada \",  \"Ontario \",  \"Quebec \"\\],\\[ \"South America \",  \"Brazil \"\\]\\], region1 =  \"Canada \", region2 =  \"South America \"\n**Output:**  \"Earth \""
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= regions.length <= 104`\n*   `2 <= regions[i].length <= 20`\n*   `1 <= regions[i][j].length, region1.length, region2.length <= 20`\n*   `region1 != region2`\n*   `regions[i][j]`, `region1`, and `region2` consist of English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"Earth\",\"NorthAmerica\",\"SouthAmerica\"],\n[\"NorthAmerica\",\"UnitedStates\",\"Canada\"],\n[\"UnitedStates\",\"NewYork\",\"Boston\"],\n[\"Canada\",\"Ontario\",\"Quebec\"],\n[\"SouthAmerica\",\"Brazil\"]],\"Quebec\",\"NewYork\"",
                "output": "\"NorthAmerica\""
            },
            {
                "input": "[[\"Earth\",\"NorthAmerica\",\"SouthAmerica\"],[\"NorthAmerica\",\"UnitedStates\",\"Canada\"],[\"UnitedStates\",\"NewYork\",\"Boston\"],[\"Canada\",\"Ontario\",\"Quebec\"],[\"SouthAmerica\",\"Brazil\"]],\"Canada\",\"SouthAmerica\"",
                "output": "\"Earth\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\nimport javafx.util.Pair;\nclass Solution {\n    public int[][] matrixRankTransform(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] rank = new int[m][n];\n        int[] sorted_row = new int[m], sorted_col = new int[n];\n    \n        for (int bound=0; bound<=200000; bound++) {\n            Queue<Pair<Integer, Integer>> q = new LinkedList<>();\n            for (int i = 0; i<m; ++i)\n                for (int j = 0; j<n; ++j)\n                    if (matrix[i][j] == bound && rank[i][j] == 0) q.add(new Pair<>(i, j));\n    \n            if (q.isEmpty()) break;\n            for (Pair<Integer, Integer> rc; !q.isEmpty(); q.poll()) {\n                int r = rc.getKey();\n                int c = rc.getValue();\n                int potential_rank = sorted_row[r] + 1;\n                for (Pair<Integer, Integer> neighbour: neighbours(r, c, m, n)) {\n                    int row = neighbour.getKey();\n                    int col = neighbour.getValue();\n                    if (matrix[row][col] <= matrix[r][c])\n                        potential_rank = Math.max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c] ? 0 : 1));\n                }\n                if (potential_rank == sorted_col[c] + 1) {\n                    rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank;\n                } else {\n                    q.add(rc);\n                }\n            }\n        }\n        return rank;\n    }\n    \n    private List<Pair<Integer, Integer>> neighbours(int r, int c, int m, int n) {\n        List<Pair<Integer, Integer>> res = new ArrayList<>();\n        for (int i=0; i<m; ++i) if (i != r) res.add(new Pair<>(i, c));\n        for (int i=0; i<n; ++i) if (i != c) res.add(new Pair<>(r, i));\n        return res;\n    }\n}\n```\n    \n    The algorithm uses a breadth-first search to determine the rank of each element in the given matrix. It maintains rank arrays for each row and column, sorted_row and sorted_col. These arrays store information about the ranks so far, which means while processing elements in the matrix, we can compare them with this rank information to determine their rank.\n\nWe use a loop for possible range of values in the matrix (0 to 200,000). Inside the loop, we populate a queue with elements that have their value equal to the current bound and have not been assigned a rank yet. If the queue is empty, we break the loop. Inside this loop for each element, we check its possible rank by looking at its neighboring elements in the corresponding row and column. If the potential_rank obtained is equal to (sorted_col[c] + 1), then we update the rank, sorted_row, and sorted_col arrays.\n\nThis process continues until each element has been assigned a rank.\n    ",
        "python": "\n    ```python\nfrom collections import deque\nfrom itertools import chain\n\ndef matrix_rank_transform(matrix):\n    def neighbours(r, c):\n        for i in range(m):\n            if i != r:\n                yield i, c\n        for i in range(n):\n            if i != c:\n                yield r, i\n\n    m, n = len(matrix), len(matrix[0])\n    rank = [[0] * n for _ in range(m)]\n    sorted_row = [0] * m\n    sorted_col = [0] * n\n\n    for bound in range(200001):\n        q = deque((r, c) for r in range(m) for c in range(n) if matrix[r][c] == bound and rank[r][c] == 0)\n        if not q:\n            break\n        while q:\n            r, c = rc = q.popleft()\n            potential_rank = sorted_row[r] + 1\n            for row, col in neighbours(r, c):\n                if matrix[row][col] <= matrix[r][c]:\n                    potential_rank = max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c]))\n            if potential_rank == sorted_col[c] + 1:\n                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank\n            else:\n                q.append(rc)\n    return rank\n```\n    \n    The algorithm uses a breadth-first search to determine the rank of each element in the given matrix. It maintains rank arrays for each row and column, sorted_row and sorted_col. These arrays store information about the ranks so far, which means while processing elements in the matrix, we can compare them with this rank information to determine their rank.\n\nWe use a loop for possible range of values in the matrix (0 to 200,000). Inside the loop, we populate a queue with elements that have their value equal to the current bound and have not been assigned a rank yet. If the queue is empty, we break the loop. Inside this loop for each element, we check its possible rank by looking at its neighboring elements in the corresponding row and column. If the potential_rank obtained is equal to (sorted_col[c] + 1), then we update the rank, sorted_row, and sorted_col arrays.\n\nThis process continues until each element has been assigned a rank.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nstd::vector<std::vector<int>> matrixRankTransform(std::vector<std::vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    std::vector<std::vector<int>> rank(m, std::vector<int>(n));\n    std::vector<int> sorted_row(m), sorted_col(n);\n\n    auto neighbours = [&](int r, int c) {\n        std::vector<std::pair<int, int>> res;\n        for (int i=0; i<m; ++i) if (i != r) res.push_back({i, c});\n        for (int i=0; i<n; ++i) if (i != c) res.push_back({r, i});\n        return res;\n    };\n\n    for (int bound=0; bound<=2e5; bound++) {\n        std::queue<std::pair<int, int>> q;\n        for (int i = 0; i<m; ++i)\n            for (int j = 0; j<n; ++j)\n                if (matrix[i][j] == bound && rank[i][j] == 0) q.push({i, j});\n\n        if (q.empty()) break;\n        for (std::pair<int, int> rc; !q.empty(); q.pop()) {\n            auto [r,c] = rc = q.front();\n            int potential_rank = sorted_row[r] + 1;\n            for (auto [row, col]: neighbours(r,c))\n                if (matrix[row][col] <= matrix[r][c])\n                    potential_rank = std::max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c] ? 0 : 1));\n            if (potential_rank == sorted_col[c] + 1) {\n                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank;\n            } else {\n                q.push(rc);\n            }\n        }\n    }\n    return rank;\n}\n```\n    \n    The algorithm uses a breadth-first search to determine the rank of each element in the given matrix. It maintains rank arrays for each row and column, sorted_row and sorted_col. These arrays store information about the ranks so far, which means while processing elements in the matrix, we can compare them with this rank information to determine their rank.\n\nWe use a loop for possible range of values in the matrix (0 to 200,000). Inside the loop, we populate a queue with elements that have their value equal to the current bound and have not been assigned a rank yet. If the queue is empty, we break the loop. Inside this loop for each element, we check its possible rank by looking at its neighboring elements in the corresponding row and column. If the potential_rank obtained is equal to (sorted_col[c] + 1), then we update the rank, sorted_row, and sorted_col arrays.\n\nThis process continues until each element has been assigned a rank.\n    ",
        "js": "\n    ```javascript\nfunction matrixRankTransform(matrix) {\n    function* neighbours(r, c) {\n        for (let i = 0; i < m; ++i) if (i != r) yield [i, c];\n        for (let i = 0; i < n; ++i) if (i != c) yield [r, i];\n    }\n\n    const m = matrix.length, n = matrix[0].length;\n    const rank = Array.from({length: m}, () => Array(n).fill(0));\n    const sorted_row = new Array(m).fill(0);\n    const sorted_col = new Array(n).fill(0);\n\n    for (let bound = 0; bound <= 200000; bound++) {\n        const q = [];\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (matrix[i][j] == bound && rank[i][j] == 0) {\n                    q.push([i, j]);\n                }\n            }\n        }\n        if (q.length === 0) break;\n        while (q.length > 0) {\n            const [r, c] = rc = q.shift();\n            let potential_rank = sorted_row[r] + 1;\n            for (const [row, col] of neighbours(r, c)) {\n                if (matrix[row][col] <= matrix[r][c]) {\n                    potential_rank = Math.max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c] ? 0 : 1));\n                }\n            }\n            if (potential_rank === (sorted_col[c] + 1)) {\n                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank;\n            } else {\n                q.push(rc);\n            }\n        }\n    }\n    return rank;\n}\n```\n    \n    The algorithm uses a breadth-first search to determine the rank of each element in the given matrix. It maintains rank arrays for each row and column, sorted_row and sorted_col. These arrays store information about the ranks so far, which means while processing elements in the matrix, we can compare them with this rank information to determine their rank.\n\nWe use a loop for possible range of values in the matrix (0 to 200,000). Inside the loop, we populate a queue with elements that have their value equal to the current bound and have not been assigned a rank yet. If the queue is empty, we break the loop. Inside this loop for each element, we check its possible rank by looking at its neighboring elements in the corresponding row and column. If the potential_rank obtained is equal to (sorted_col[c] + 1), then we update the rank, sorted_row, and sorted_col arrays.\n\nThis process continues until each element has been assigned a rank.\n    "
    },
    {
        "id": 218,
        "title": "Synonymous Sentences",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a list of equivalent string pairs `synonyms` where `synonyms[i] = [si, ti]` indicates that `si` and `ti` are equivalent strings. You are also given a sentence `text`.\n\nReturn _all possible synonymous sentences **sorted lexicographically**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** synonyms = \\[\\[ \"happy \", \"joy \"\\],\\[ \"sad \", \"sorrow \"\\],\\[ \"joy \", \"cheerful \"\\]\\], text =  \"I am happy today but was sad yesterday \"\n**Output:** \\[ \"I am cheerful today but was sad yesterday \", \"I am cheerful today but was sorrow yesterday \", \"I am happy today but was sad yesterday \", \"I am happy today but was sorrow yesterday \", \"I am joy today but was sad yesterday \", \"I am joy today but was sorrow yesterday \"\\]\n\n",
                "**Example 2:**\n\n**Input:** synonyms = \\[\\[ \"happy \", \"joy \"\\],\\[ \"cheerful \", \"glad \"\\]\\], text =  \"I am happy today but was sad yesterday \"\n**Output:** \\[ \"I am happy today but was sad yesterday \", \"I am joy today but was sad yesterday \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= synonyms.length <= 10`\n*   `synonyms[i].length == 2`\n*   `1 <= si.length, ti.length <= 10`\n*   `si != ti`\n*   `text` consists of at most `10` words.\n*   All the pairs of `synonyms` are **unique**.\n*   The words of `text` are separated by single spaces.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"happy\",\"joy\"],[\"sad\",\"sorrow\"],[\"joy\",\"cheerful\"]],\"Iamhappytodaybutwassadyesterday\"",
                "output": "[\"Iamcheerfultodaybutwassadyesterday\",\"Iamcheerfultodaybutwassorrowyesterday\",\"Iamhappytodaybutwassadyesterday\",\"Iamhappytodaybutwassorrowyesterday\",\"Iamjoytodaybutwassadyesterday\",\"Iamjoytodaybutwassorrowyesterday\"]"
            },
            {
                "input": "[[\"happy\",\"joy\"],[\"cheerful\",\"glad\"]],\"Iamhappytodaybutwassadyesterday\"",
                "output": "[\"Iamhappytodaybutwassadyesterday\",\"Iamjoytodaybutwassadyesterday\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> generateSentences(List<List<String>> synonyms, String text) {\n    Map<String, Set<String>> synonymMap = new HashMap<>();\n\n    for (List<String> synPair : synonyms) {\n        synonymMap.putIfAbsent(synPair.get(0), new HashSet<>());\n        synonymMap.putIfAbsent(synPair.get(1), new HashSet<>());\n        synonymMap.get(synPair.get(0)).add(synPair.get(1));\n        synonymMap.get(synPair.get(1)).add(synPair.get(0));\n    }\n\n    String[] words = text.split(\" \");\n    List<String> result = new ArrayList<>();\n    generateSentencesHelper(0, words, synonymMap, result, new StringBuilder());\n    Collections.sort(result);\n\n    return result;\n}\n\nprivate void generateSentencesHelper(int index, String[] words, Map<String, Set<String>> synonyms, List<String> result, StringBuilder curSentence) {\n    if (index == words.length) {\n        result.add(curSentence.toString());\n    } else {\n        Set<String> synSet = synonyms.getOrDefault(words[index], new HashSet<>());\n        synSet.add(words[index]);\n\n        int prevLength = curSentence.length();\n        for (String syn : synSet) {\n            if (prevLength > 0) {\n                curSentence.append(\" \");\n            }\n            curSentence.append(syn);\n\n            generateSentencesHelper(index + 1, words, synonyms, result, curSentence);\n\n            curSentence.setLength(prevLength);\n        }\n    }\n}\n```\n\n    \n    1. Build a map (`synonymMap`) for each word in the synonyms list so that we can look up its synonyms easily later.\n2. Split the input `text` into a list/array of words.\n3. Use a helper function (`generateSentencesHelper` or `helper`) to perform a depth-first search on combining words with their synonyms.\n4. The helper function takes the index of the current word being processed, and a current sentence being created as input.\n5. If the current index is equal to the length of the words list, we have processed all words, and we can add the current sentence to the result list.\n6. If the index is not at the end, we look up synonyms for the current word using the `synonymMap`. If there are no synonyms, we simply add the current word itself to the set.\n7. Iterate over the synonyms (including the current word itself), and recursively call the helper function with the next word index, and the current sentence with the appended synonym.\n8. After the recursive steps, remove the last word from the current sentence to backtrack.\n9. After completing the depth-first search, sort the results list and return it.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\n\ndef generateSentences(synonyms: List[List[str]], text: str) -> List[str]:\n    synonym_map = {}\n\n    for s, t in synonyms:\n        if s not in synonym_map:\n            synonym_map[s] = {s}\n        if t not in synonym_map:\n            synonym_map[t] = {t}\n        synonym_map[s].add(t)\n        synonym_map[t].add(s)\n\n    words = text.split()\n    results = []\n\n    def helper(index: int, cur_sentence: List[str]) -> None:\n        if index == len(words):\n            results.append(\" \".join(cur_sentence))\n            return\n        for w in synonym_map.get(words[index], {words[index]}):\n            cur_sentence.append(w)\n            helper(index + 1, cur_sentence)\n            cur_sentence.pop()\n\n    helper(0, [])\n\n    return sorted(results)\n```\n\n    \n    1. Build a map (`synonymMap`) for each word in the synonyms list so that we can look up its synonyms easily later.\n2. Split the input `text` into a list/array of words.\n3. Use a helper function (`generateSentencesHelper` or `helper`) to perform a depth-first search on combining words with their synonyms.\n4. The helper function takes the index of the current word being processed, and a current sentence being created as input.\n5. If the current index is equal to the length of the words list, we have processed all words, and we can add the current sentence to the result list.\n6. If the index is not at the end, we look up synonyms for the current word using the `synonymMap`. If there are no synonyms, we simply add the current word itself to the set.\n7. Iterate over the synonyms (including the current word itself), and recursively call the helper function with the next word index, and the current sentence with the appended synonym.\n8. After the recursive steps, remove the last word from the current sentence to backtrack.\n9. After completing the depth-first search, sort the results list and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nvoid generateSentencesHelper(int index, vector<string>& words, map<string, set<string>>& synonyms, vector<string>& result, string curSentence) {\n    if (index == words.size()) {\n        result.push_back(curSentence);\n    } else {\n        set<string>& synSet = synonyms[words[index]];\n        for (const auto& syn : synSet) {\n            generateSentencesHelper(index + 1, words, synonyms, result, curSentence + (curSentence.empty() ? \"\" : \" \") + syn);\n        }\n    }\n}\n\nvector<string> generateSentences(vector<vector<string>>& synonyms, string text) {\n    map<string, set<string>> synonymMap;\n\n    for (const auto& synPair : synonyms) {\n        synonymMap[synPair[0]].insert(synPair[0]);\n        synonymMap[synPair[0]].insert(synPair[1]);\n        synonymMap[synPair[1]].insert(synPair[0]);\n        synonymMap[synPair[1]].insert(synPair[1]);\n    }\n\n    vector<string> words;\n    size_t start = 0, end = text.find(' ');\n\n    while (end != string::npos) {\n        words.push_back(text.substr(start, end - start));\n        start = end + 1;\n        end = text.find(' ', start);\n    }\n\n    words.push_back(text.substr(start));\n\n    vector<string> result;\n    generateSentencesHelper(0, words, synonymMap, result, \"\");\n\n    return result;\n}\n```\n\n    \n    1. Build a map (`synonymMap`) for each word in the synonyms list so that we can look up its synonyms easily later.\n2. Split the input `text` into a list/array of words.\n3. Use a helper function (`generateSentencesHelper` or `helper`) to perform a depth-first search on combining words with their synonyms.\n4. The helper function takes the index of the current word being processed, and a current sentence being created as input.\n5. If the current index is equal to the length of the words list, we have processed all words, and we can add the current sentence to the result list.\n6. If the index is not at the end, we look up synonyms for the current word using the `synonymMap`. If there are no synonyms, we simply add the current word itself to the set.\n7. Iterate over the synonyms (including the current word itself), and recursively call the helper function with the next word index, and the current sentence with the appended synonym.\n8. After the recursive steps, remove the last word from the current sentence to backtrack.\n9. After completing the depth-first search, sort the results list and return it.\n    ",
        "js": "\n    ```javascript\nfunction generateSentences(synonyms, text) {\n    const synonymMap = new Map();\n\n    for (const [s, t] of synonyms) {\n        if (!synonymMap.has(s)) {\n            synonymMap.set(s, new Set([s]));\n        }\n        if (!synonymMap.has(t)) {\n            synonymMap.set(t, new Set([t]));\n        }\n        synonymMap.get(s).add(t);\n        synonymMap.get(t).add(s);\n    }\n\n    const words = text.split(\" \");\n    const results = [];\n\n    function helper(index, curSentence) {\n        if (index === words.length) {\n            results.push(curSentence.join(\" \"));\n        } else {\n            const synSet = synonymMap.get(words[index]) || new Set([words[index]]);\n\n            for (const w of synSet) {\n                curSentence.push(w);\n                helper(index + 1, curSentence);\n                curSentence.pop();\n            }\n        }\n    }\n\n    helper(0, []);\n\n    return results.sort();\n}\n```\n\n    \n    1. Build a map (`synonymMap`) for each word in the synonyms list so that we can look up its synonyms easily later.\n2. Split the input `text` into a list/array of words.\n3. Use a helper function (`generateSentencesHelper` or `helper`) to perform a depth-first search on combining words with their synonyms.\n4. The helper function takes the index of the current word being processed, and a current sentence being created as input.\n5. If the current index is equal to the length of the words list, we have processed all words, and we can add the current sentence to the result list.\n6. If the index is not at the end, we look up synonyms for the current word using the `synonymMap`. If there are no synonyms, we simply add the current word itself to the set.\n7. Iterate over the synonyms (including the current word itself), and recursively call the helper function with the next word index, and the current sentence with the appended synonym.\n8. After the recursive steps, remove the last word from the current sentence to backtrack.\n9. After completing the depth-first search, sort the results list and return it.\n    "
    },
    {
        "id": 219,
        "title": "Handshakes That Don't Cross",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an **even** number of people `numPeople` that stand around a circle and each person shakes hands with someone else so that there are `numPeople / 2` handshakes total.\n\nReturn _the number of ways these handshakes could occur such that none of the handshakes cross_.\n\nSince the answer could be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** numPeople = 4\n**Output:** 2\n**Explanation:** There are two ways to do it, the first way is \\[(1,2),(3,4)\\] and the second one is \\[(2,3),(4,1)\\].\n\n",
                "**Example 2:**\n\n**Input:** numPeople = 6\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= numPeople <= 1000`\n*   `numPeople` is even.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "6",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int numberOfWays(int numPeople) {\n    int MOD = 1000000007;\n    int[] dp = new int[numPeople / 2 + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= numPeople / 2; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            dp[i] = (dp[i] + (int)(((long) dp[i - j] * dp[j - 1]) % MOD )) % MOD;\n        }\n    }\n    return dp[numPeople / 2];\n}\n```\n\n    \n    The problem can be solved using dynamic programming. We can use dp[i] to represent the number of different ways i pairs of people can perform handshakes without crossing. We initialize dp[0] to 1 as there is one way to perform no handshakes.\n\nNow, we iterate from 1 to numPeople/2 inclusive. In each iteration, we consider one pair of people at a time. Suppose there are i pairs of people and the current pair to be considered is j. Then, the remaining pairs of people can be divided into two groups - one having j - 1 pairs and the other having i - j pairs. Thus, we can calculate dp[i] by using the previous values of dp[]. Specifically, dp[i] is updated as follows:\ndp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;\n\nFinally, we return dp[numPeople / 2].\n    ",
        "python": "\n    ```python\ndef numberOfWays(numPeople: int) -> int:\n    MOD = 1000000007\n    dp = [0] * (numPeople // 2 + 1)\n    dp[0] = 1\n    for i in range(1, numPeople // 2 + 1):\n        for j in range(1, i + 1):\n            dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD\n    return dp[numPeople // 2]\n```\n\n    \n    The problem can be solved using dynamic programming. We can use dp[i] to represent the number of different ways i pairs of people can perform handshakes without crossing. We initialize dp[0] to 1 as there is one way to perform no handshakes.\n\nNow, we iterate from 1 to numPeople/2 inclusive. In each iteration, we consider one pair of people at a time. Suppose there are i pairs of people and the current pair to be considered is j. Then, the remaining pairs of people can be divided into two groups - one having j - 1 pairs and the other having i - j pairs. Thus, we can calculate dp[i] by using the previous values of dp[]. Specifically, dp[i] is updated as follows:\ndp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;\n\nFinally, we return dp[numPeople / 2].\n    ",
        "c++": "\n    ```cpp\nint numberOfWays(int numPeople) {\n    const int MOD = 1000000007;\n    vector<int> dp(numPeople / 2 + 1);\n    dp[0] = 1;\n    for (int i = 1; i <= numPeople / 2; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            dp[i] = (dp[i] + ((long long) dp[i - j] * dp[j - 1]) % MOD) % MOD;\n        }\n    }\n    return dp[numPeople / 2];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can use dp[i] to represent the number of different ways i pairs of people can perform handshakes without crossing. We initialize dp[0] to 1 as there is one way to perform no handshakes.\n\nNow, we iterate from 1 to numPeople/2 inclusive. In each iteration, we consider one pair of people at a time. Suppose there are i pairs of people and the current pair to be considered is j. Then, the remaining pairs of people can be divided into two groups - one having j - 1 pairs and the other having i - j pairs. Thus, we can calculate dp[i] by using the previous values of dp[]. Specifically, dp[i] is updated as follows:\ndp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;\n\nFinally, we return dp[numPeople / 2].\n    ",
        "js": "\n    ```javascript\nfunction numberOfWays(numPeople) {\n    const MOD = 1000000007;\n    let dp = new Array(numPeople / 2 + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= numPeople / 2; ++i) {\n        for (let j = 1; j <= i; ++j) {\n            dp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;\n        }\n    }\n    return dp[numPeople / 2];\n}\n```\n\n    \n    The problem can be solved using dynamic programming. We can use dp[i] to represent the number of different ways i pairs of people can perform handshakes without crossing. We initialize dp[0] to 1 as there is one way to perform no handshakes.\n\nNow, we iterate from 1 to numPeople/2 inclusive. In each iteration, we consider one pair of people at a time. Suppose there are i pairs of people and the current pair to be considered is j. Then, the remaining pairs of people can be divided into two groups - one having j - 1 pairs and the other having i - j pairs. Thus, we can calculate dp[i] by using the previous values of dp[]. Specifically, dp[i] is updated as follows:\ndp[i] = (dp[i] + (dp[i - j] * dp[j - 1]) % MOD) % MOD;\n\nFinally, we return dp[numPeople / 2].\n    "
    },
    {
        "id": 220,
        "title": "Print Immutable Linked List in Reverse",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an immutable linked list, print out all values of each node in reverse with the help of the following interface:\n\n*   `ImmutableListNode`: An interface of immutable linked list, you are given the head of the list.\n\nYou need to use the following functions to access the linked list (you **can't** access the `ImmutableListNode` directly):\n\n*   `ImmutableListNode.printValue()`: Print value of the current node.\n*   `ImmutableListNode.getNext()`: Return the next node.\n\nThe input is only given to initialize the linked list internally. You must solve this problem without modifying the linked list. In other words, you must operate the linked list using only the mentioned APIs.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4\\]\n**Output:** \\[4,3,2,1\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[0,-4,-1,3,-5\\]\n**Output:** \\[-5,3,-1,-4,0\\]\n\n",
                "**Example 3:**\n\n**Input:** head = \\[-2,0,6,4,4,-6\\]\n**Output:** \\[-6,4,4,6,0,-2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The length of the linked list is between `[1, 1000]`.\n*   The value of each node in the linked list is between `[-1000, 1000]`.\n\n**",
            "follow_up": "Follow up:**\n\nCould you solve this problem in:\n\n*   Constant space complexity?\n*   Linear time complexity and less than linear space complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "[4,3,2,1]"
            },
            {
                "input": "[0,-4,-1,3,-5]",
                "output": "[-5,3,-1,-4,0]"
            },
            {
                "input": "[-2,0,6,4,4,-6]",
                "output": "[-6,4,4,6,0,-2]"
            }
        ],
        "java": "\n    ```java\npublic void printLinkedListInReverse(ImmutableListNode head) {\n    if (head != null) {\n        printLinkedListInReverse(head.getNext());\n        head.printValue();\n    }\n}\n```\n    \n    The algorithm uses a simple recursive approach to solve the problem. Starting from the head of the linked list, it checks if the current node is not null. If the current node is not null, it calls the function recursively with the next Node.\n\nOnce the recursion reaches the last Node, the function starts returning and executing the printValue() function for each Node, starting from the last one, which effectively prints the values in reverse order.\n\nThis approach uses constant space complexity, but a recursive approach means a linear time complexity. The recursion stack can also overflow for long linked lists. If we want to solve the recursion stack issue, we can use an iterative approach by storing each Node reference in a stack, which improves space complexity but would not be constant anymore (linear space complexity).\n    ",
        "python": "\n    ```python\ndef printLinkedListInReverse(head: 'ImmutableListNode') -> None:\n    if head is not None:\n        printLinkedListInReverse(head.getNext())\n        head.printValue()\n```\n    \n    The algorithm uses a simple recursive approach to solve the problem. Starting from the head of the linked list, it checks if the current node is not null. If the current node is not null, it calls the function recursively with the next Node.\n\nOnce the recursion reaches the last Node, the function starts returning and executing the printValue() function for each Node, starting from the last one, which effectively prints the values in reverse order.\n\nThis approach uses constant space complexity, but a recursive approach means a linear time complexity. The recursion stack can also overflow for long linked lists. If we want to solve the recursion stack issue, we can use an iterative approach by storing each Node reference in a stack, which improves space complexity but would not be constant anymore (linear space complexity).\n    ",
        "c++": "\n    ```cpp\nvoid printLinkedListInReverse(ImmutableListNode* head) {\n    if (head != nullptr) {\n        printLinkedListInReverse(head->getNext());\n        head->printValue();\n    }\n}\n```\n    \n    The algorithm uses a simple recursive approach to solve the problem. Starting from the head of the linked list, it checks if the current node is not null. If the current node is not null, it calls the function recursively with the next Node.\n\nOnce the recursion reaches the last Node, the function starts returning and executing the printValue() function for each Node, starting from the last one, which effectively prints the values in reverse order.\n\nThis approach uses constant space complexity, but a recursive approach means a linear time complexity. The recursion stack can also overflow for long linked lists. If we want to solve the recursion stack issue, we can use an iterative approach by storing each Node reference in a stack, which improves space complexity but would not be constant anymore (linear space complexity).\n    ",
        "js": "\n    ```javascript\nfunction printLinkedListInReverse(head) {\n    if (head !== null) {\n        printLinkedListInReverse(head.getNext());\n        head.printValue();\n    }\n}\n```\n    \n    The algorithm uses a simple recursive approach to solve the problem. Starting from the head of the linked list, it checks if the current node is not null. If the current node is not null, it calls the function recursively with the next Node.\n\nOnce the recursion reaches the last Node, the function starts returning and executing the printValue() function for each Node, starting from the last one, which effectively prints the values in reverse order.\n\nThis approach uses constant space complexity, but a recursive approach means a linear time complexity. The recursion stack can also overflow for long linked lists. If we want to solve the recursion stack issue, we can use an iterative approach by storing each Node reference in a stack, which improves space complexity but would not be constant anymore (linear space complexity).\n    "
    },
    {
        "id": 221,
        "title": "Hexspeak",
        "difficulty": "Easy",
        "content": {
            "problem": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"257 \"\n**Output:**  \"IOI \"\n**Explanation:** 257 is 101 in hexadecimal.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"3 \"\n**Output:**  \"ERROR \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 12`\n*   `num` does not contain leading zeros.\n*   num represents an integer in the range `[1, 1012]`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"257\"",
                "output": "\"IOI\""
            },
            {
                "input": "\"3\"",
                "output": "\"ERROR\""
            }
        ],
        "java": "\n    ```java\npublic String toHexspeak(String num) {\n    long n = Long.parseLong(num);\n    StringBuilder hex = new StringBuilder();\n    while (n != 0) {\n        int rem = (int)(n % 16);\n        if (rem == 1) hex.insert(0, 'I');\n        else if (rem == 0) hex.insert(0, 'O');\n        else if (rem > 9) hex.insert(0, (char)(rem - 10 + 'A'));\n        else return \"ERROR\";\n        n /= 16;\n    }\n    return hex.toString();\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "python": "\n    ```python\ndef to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string toHexspeak(std::string num) {\n    long n = std::stol(num);\n    std::string hex = \"\";\n    while (n) {\n        int rem = n % 16;\n        if (rem == 1) hex = \"I\" + hex;\n        else if (rem == 0) hex = \"O\" + hex;\n        else if (rem > 9) hex = (char)(rem - 10 + 'A') + hex;\n        else return \"ERROR\";\n        n /= 16;\n    }\n    return hex;\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "js": "\n    ```javascript\nfunction toHexspeak(num) {\n    let n = BigInt(num);\n    let hex = '';\n    while (n) {\n        let rem = Number(n % 16n);\n        if (rem === 1) hex = 'I' + hex;\n        else if (rem === 0) hex = 'O' + hex;\n        else if (rem > 9) hex = String.fromCharCode(rem - 10 + 'A'.charCodeAt(0)) + hex;\n        else return 'ERROR';\n        n /= 16n;\n    }\n    return hex;\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    "
    },
    {
        "id": 222,
        "title": "Remove Interval",
        "difficulty": "Medium",
        "content": {
            "problem": "A set of real numbers can be represented as the union of several disjoint intervals, where each interval is in the form `[a, b)`. A real number `x` is in the set if one of its intervals `[a, b)` contains `x` (i.e. `a <= x < b`).\n\nYou are given a **sorted** list of disjoint intervals `intervals` representing a set of real numbers as described above, where `intervals[i] = [ai, bi]` represents the interval `[ai, bi)`. You are also given another interval `toBeRemoved`.\n\nReturn _the set of real numbers with the interval_ `toBeRemoved` _**removed** from_ `intervals`_. In other words, return the set of real numbers such that every_ `x` _in the set is in_ `intervals` _but **not** in_ `toBeRemoved`_. Your answer should be a **sorted** list of disjoint intervals as described above._",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[0,2\\],\\[3,4\\],\\[5,7\\]\\], toBeRemoved = \\[1,6\\]\n**Output:** \\[\\[0,1\\],\\[6,7\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[0,5\\]\\], toBeRemoved = \\[2,3\\]\n**Output:** \\[\\[0,2\\],\\[3,5\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** intervals = \\[\\[-5,-4\\],\\[-3,-2\\],\\[1,2\\],\\[3,5\\],\\[8,9\\]\\], toBeRemoved = \\[-1,4\\]\n**Output:** \\[\\[-5,-4\\],\\[-3,-2\\],\\[4,5\\],\\[8,9\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `-109 <= ai < bi <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,2],[3,4],[5,7]],[1,6]",
                "output": "[[0,1],[6,7]]"
            },
            {
                "input": "[[0,5]],[2,3]",
                "output": "[[0,2],[3,5]]"
            },
            {
                "input": "[[-5,-4],[-3,-2],[1,2],[3,5],[8,9]],[-1,4]",
                "output": "[[-5,-4],[-3,-2],[4,5],[8,9]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> invalidTransactions(String[] transactions) {\n    Map<String, List<String[]>> trans_map = new HashMap<>();\n\n    for (String trans : transactions) {\n        String[] temp = trans.split(\",\");\n        trans_map.putIfAbsent(temp[0], new ArrayList<>());\n        trans_map.get(temp[0]).add(temp);\n    }\n\n    List<String> ans = new ArrayList<>();\n\n    for (String trans : transactions) {\n        String[] temp = trans.split(\",\");\n        \n        if (Integer.parseInt(temp[2]) > 1000) {\n            ans.add(trans);\n            continue;\n        }\n\n        List<String[]> others = trans_map.get(temp[0]);\n\n        for (String[] other : others) {\n            if (!other[3].equals(temp[3]) && Math.abs(Integer.parseInt(other[1]) - Integer.parseInt(temp[1])) <= 60) {\n                ans.add(trans);\n                break;\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Create a map to store transactions by names.\n2. For each transaction, split it by the comma and add it to the map based on the name.\n3. Initialize an empty array to store invalid transactions.\n4. For each transaction, if the amount is greater than 1000, add it to the invalid transactions array.\n5. Iterate through the transactions of the same name and check if the city is different and the time difference is less than or equal to 60. If yes, add the transaction to the invalid transactions array.\n6. Return the invalid transactions array.\n    ",
        "python": "\n    ```python\ndef invalid_transactions(transactions):\n    trans_map = {}\n    \n    for trans in transactions:\n        temp = trans.split(\",\")\n        trans_map.setdefault(temp[0], []).append(temp)\n    \n    ans = []\n\n    for trans in transactions:\n        temp = trans.split(\",\")\n\n        if int(temp[2]) > 1000:\n            ans.append(trans)\n            continue\n\n        for other in trans_map[temp[0]]:\n            if other[3] != temp[3] and abs(int(other[1]) - int(temp[1])) <= 60:\n                ans.append(trans)\n                break\n\n    return ans\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Create a map to store transactions by names.\n2. For each transaction, split it by the comma and add it to the map based on the name.\n3. Initialize an empty array to store invalid transactions.\n4. For each transaction, if the amount is greater than 1000, add it to the invalid transactions array.\n5. Iterate through the transactions of the same name and check if the city is different and the time difference is less than or equal to 60. If yes, add the transaction to the invalid transactions array.\n6. Return the invalid transactions array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n\nstd::vector<std::string> invalidTransactions(std::vector<std::string>& transactions) {\n    std::unordered_map<std::string, std::vector<std::vector<std::string>>> trans_map;\n    \n    for (const auto& trans : transactions) {\n        std::stringstream ss(trans);\n        std::vector<std::string> temp;\n        std::string s;\n        \n        while (std::getline(ss, s, ','))\n            temp.push_back(s);\n        \n        trans_map[temp[0]].push_back(temp);\n    }\n    \n    std::vector<std::string> ans;\n    \n    for (const auto& trans : transactions) {\n        std::stringstream ss(trans);\n        std::vector<std::string> temp;\n        std::string s;\n        \n        while (std::getline(ss, s, ','))\n            temp.push_back(s);\n        \n        if (std::stoi(temp[2]) > 1000) {\n            ans.push_back(trans);\n            continue;\n        }\n        \n        for (const auto& other : trans_map[temp[0]]) {\n            if (other[3] != temp[3] && std::abs(std::stoi(other[1]) - std::stoi(temp[1])) <= 60) {\n                ans.push_back(trans);\n                break;\n            }\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Create a map to store transactions by names.\n2. For each transaction, split it by the comma and add it to the map based on the name.\n3. Initialize an empty array to store invalid transactions.\n4. For each transaction, if the amount is greater than 1000, add it to the invalid transactions array.\n5. Iterate through the transactions of the same name and check if the city is different and the time difference is less than or equal to 60. If yes, add the transaction to the invalid transactions array.\n6. Return the invalid transactions array.\n    ",
        "js": "\n    ```javascript\nfunction invalidTransactions(transactions) {\n    const trans_map = new Map();\n\n    for (let trans of transactions) {\n        let temp = trans.split(\",\");\n        if (!trans_map.has(temp[0])) {\n            trans_map.set(temp[0], []);\n        }\n        trans_map.get(temp[0]).push(temp);\n    }\n\n    let ans = [];\n\n    for (let trans of transactions) {\n        let temp = trans.split(\",\");\n\n        if (parseInt(temp[2]) > 1000) {\n            ans.push(trans);\n            continue;\n        }\n\n        let others = trans_map.get(temp[0]);\n\n        for (let other of others) {\n            if (other[3] !== temp[3] && Math.abs(parseInt(other[1]) - parseInt(temp[1])) <= 60) {\n                ans.push(trans);\n                break;\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Create a map to store transactions by names.\n2. For each transaction, split it by the comma and add it to the map based on the name.\n3. Initialize an empty array to store invalid transactions.\n4. For each transaction, if the amount is greater than 1000, add it to the invalid transactions array.\n5. Iterate through the transactions of the same name and check if the city is different and the time difference is less than or equal to 60. If yes, add the transaction to the invalid transactions array.\n6. Return the invalid transactions array.\n    "
    },
    {
        "id": 223,
        "title": "Delete Tree Nodes",
        "difficulty": "Medium",
        "content": {
            "problem": "A tree rooted at node 0 is given as follows:\n\n*   The number of nodes is `nodes`;\n*   The value of the `ith` node is `value[i]`;\n*   The parent of the `ith` node is `parent[i]`.\n\nRemove every subtree whose sum of values of nodes is zero.\n\nReturn _the number of the remaining nodes in the tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nodes = 7, parent = \\[-1,0,0,1,2,2,2\\], value = \\[1,-2,4,0,-2,-1,-1\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nodes = 7, parent = \\[-1,0,0,1,2,2,2\\], value = \\[1,-2,4,0,-2,-1,-2\\]\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nodes <= 104`\n*   `parent.length == nodes`\n*   `0 <= parent[i] <= nodes - 1`\n*   `parent[0] == -1` which indicates that `0` is the root.\n*   `value.length == nodes`\n*   `-105 <= value[i] <= 105`\n*   The given input is **guaranteed** to represent a **valid tree**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "7,[-1,0,0,1,2,2,2],[1,-2,4,0,-2,-1,-1]",
                "output": "2"
            },
            {
                "input": "7,[-1,0,0,1,2,2,2],[1,-2,4,0,-2,-1,-2]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] countSmallerFrequencies(String[] words, String[] queries) {\n    int[] freqWords = new int[words.length];\n    \n    for (int i = 0; i < words.length; i++) {\n        char minChar = words[i].chars().min().getAsInt();\n        freqWords[i] = (int) words[i].chars().filter(c -> c == minChar).count();\n    }\n    \n    int[] ans = new int[queries.length];\n    for (int i = 0; i < queries.length; i++) {\n        char minChar = queries[i].chars().min().getAsInt();\n        int freqQuery = (int) queries[i].chars().filter(c -> c == minChar).count();\n        \n        ans[i] = (int) Arrays.stream(freqWords).filter(f -> f > freqQuery).count();\n    }\n\n    return ans;\n}\n```\n    \n    1. First, we calculate the frequencies of the lexicographically smallest characters in each word of `words`. This is done by iterating through the words, finding the smallest character, counting its frequency, and store the result in a new array named `freqWords`.\n2. Next, we iterate through the queries in `queries`. For each query, we find the lexicographically smallest character, and count its frequency `freqQuery`.\n3. For each query, we count the number of elements in `freqWords` that are greater than the `freqQuery`. This is done using `count_if` in C++, `filter` followed by `count` in Java, a list comprehension with `sum` in Python, and `filter` followed by `length` in JavaScript.\n4. The result is appended to the `ans` array and returned at the end.\n    ",
        "python": "\n    ```python\ndef countSmallerFrequencies(words, queries):\n    freqWords = [word.count(min(word)) for word in words]\n    \n    ans = []\n    for query in queries:\n        freqQuery = query.count(min(query))\n        ans.append(sum(f > freqQuery for f in freqWords))\n        \n    return ans\n```\n    \n    1. First, we calculate the frequencies of the lexicographically smallest characters in each word of `words`. This is done by iterating through the words, finding the smallest character, counting its frequency, and store the result in a new array named `freqWords`.\n2. Next, we iterate through the queries in `queries`. For each query, we find the lexicographically smallest character, and count its frequency `freqQuery`.\n3. For each query, we count the number of elements in `freqWords` that are greater than the `freqQuery`. This is done using `count_if` in C++, `filter` followed by `count` in Java, a list comprehension with `sum` in Python, and `filter` followed by `length` in JavaScript.\n4. The result is appended to the `ans` array and returned at the end.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<int> countSmallerFrequencies(const std::vector<std::string>& words, const std::vector<std::string>& queries) {\n    std::vector<int> freqWords(words.size(), 0);\n    \n    for (int i = 0; i < words.size(); ++i) {\n        char minChar = *min_element(words[i].begin(), words[i].end());\n        freqWords[i] = count(words[i].begin(), words[i].end(), minChar);\n    }\n    \n    std::vector<int> ans(queries.size(), 0);\n    for (int i = 0; i < queries.size(); ++i) {\n        char minChar = *min_element(queries[i].begin(), queries[i].end());\n        int freqQuery = count(queries[i].begin(), queries[i].end(), minChar);\n        \n        ans[i] = count_if(freqWords.begin(), freqWords.end(), [freqQuery](int f) { return f > freqQuery; });\n    }\n\n    return ans;\n}\n```\n    \n    1. First, we calculate the frequencies of the lexicographically smallest characters in each word of `words`. This is done by iterating through the words, finding the smallest character, counting its frequency, and store the result in a new array named `freqWords`.\n2. Next, we iterate through the queries in `queries`. For each query, we find the lexicographically smallest character, and count its frequency `freqQuery`.\n3. For each query, we count the number of elements in `freqWords` that are greater than the `freqQuery`. This is done using `count_if` in C++, `filter` followed by `count` in Java, a list comprehension with `sum` in Python, and `filter` followed by `length` in JavaScript.\n4. The result is appended to the `ans` array and returned at the end.\n    ",
        "js": "\n    ```javascript\nfunction countSmallerFrequencies(words, queries) {\n    const freqWords = words.map(word => {\n        const minChar = Math.min(...word);\n        return word.split(minChar).length - 1;\n    });\n    \n    const ans = [];\n    for (const query of queries) {\n        const minChar = Math.min(...query);\n        const freqQuery = query.split(minChar).length - 1;\n        \n        ans.push(freqWords.filter(f => f > freqQuery).length);\n    }\n    \n    return ans;\n}\n```\n    \n    1. First, we calculate the frequencies of the lexicographically smallest characters in each word of `words`. This is done by iterating through the words, finding the smallest character, counting its frequency, and store the result in a new array named `freqWords`.\n2. Next, we iterate through the queries in `queries`. For each query, we find the lexicographically smallest character, and count its frequency `freqQuery`.\n3. For each query, we count the number of elements in `freqWords` that are greater than the `freqQuery`. This is done using `count_if` in C++, `filter` followed by `count` in Java, a list comprehension with `sum` in Python, and `filter` followed by `length` in JavaScript.\n4. The result is appended to the `ans` array and returned at the end.\n    "
    },
    {
        "id": 224,
        "title": "Number of Ships in a Rectangle",
        "difficulty": "Hard",
        "content": {
            "problem": "_(This problem is an **interactive problem**.)_\n\nEach ship is located at an integer point on the sea represented by a cartesian plane, and each integer point may contain at most 1 ship.\n\nYou have a function `Sea.hasShips(topRight, bottomLeft)` which takes two points as arguments and returns `true` If there is at least one ship in the rectangle represented by the two points, including on the boundary.\n\nGiven two points: the top right and bottom left corners of a rectangle, return the number of ships present in that rectangle. It is guaranteed that there are **at most 10 ships** in that rectangle.\n\nSubmissions making **more than 400 calls** to `hasShips` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n\n**Example :**\n\n**Input:** \nships = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[5,5\\]\\], topRight = \\[4,4\\], bottomLeft = \\[0,0\\]\n**Output:** 3\n**Explanation:** From \\[0,0\\] to \\[4,4\\] we can count 3 ships within the range.",
            "examples": [
                "**Example 2:**\n\n**Input:** ans = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\], topRight = \\[1000,1000\\], bottomLeft = \\[0,0\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   On the input `ships` is only given to initialize the map internally. You must solve this problem \"blindfolded \". In other words, you must find the answer using the given `hasShips` API, without knowing the `ships` position.\n*   `0 <= bottomLeft[0] <= topRight[0] <= 1000`\n*   `0 <= bottomLeft[1] <= topRight[1] <= 1000`\n*   `topRight != bottomLeft`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1],[2,2],[3,3]],[1000,1000],[0,0]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic int countDaysBetweenDates(String date1, String date2) {\n    LocalDate localDate1 = LocalDate.parse(date1);\n    LocalDate localDate2 = LocalDate.parse(date2);\n    return (int)ChronoUnit.DAYS.between(localDate1, localDate2);\n}\n```\n    \n    The algorithm to calculate the number of days between two dates is the same for all languages. First, parse the input strings into date objects. Then, calculate the time difference between the two date objects. Finally, convert the time difference into days.\n\nFor C++, we use `istringstream`, `tm`, and `get_time` for string parsing, and `mktime` and `difftime` for time calculation.\n\nFor Java, we use `LocalDate.parse` and `ChronoUnit.DAYS.between` methods from the java.time package.\n\nFor Python, we use `datetime.strptime` for string parsing and calculate the difference using the `-` (minus) operator.\n\nFor JavaScript, we parse the input strings into date objects using the `Date` constructor and calculate the time difference by subtracting them directly. Finally, we convert the time difference (in milliseconds) to days.\n    ",
        "python": "\n    ```python\nfrom datetime import datetime\n\ndef countDaysBetweenDates(date1, date2):\n    d1 = datetime.strptime(date1, \"%Y-%m-%d\")\n    d2 = datetime.strptime(date2, \"%Y-%m-%d\")\n    return abs((d2 - d1).days)\n```\n    \n    The algorithm to calculate the number of days between two dates is the same for all languages. First, parse the input strings into date objects. Then, calculate the time difference between the two date objects. Finally, convert the time difference into days.\n\nFor C++, we use `istringstream`, `tm`, and `get_time` for string parsing, and `mktime` and `difftime` for time calculation.\n\nFor Java, we use `LocalDate.parse` and `ChronoUnit.DAYS.between` methods from the java.time package.\n\nFor Python, we use `datetime.strptime` for string parsing and calculate the difference using the `-` (minus) operator.\n\nFor JavaScript, we parse the input strings into date objects using the `Date` constructor and calculate the time difference by subtracting them directly. Finally, we convert the time difference (in milliseconds) to days.\n    ",
        "c++": "\n    ```cpp\n#include <ctime>\n#include <iostream>\n#include <sstream>\n\nint countDaysBetweenDates(const std::string& date1, const std::string& date2) {\n    std::tm tm1 = {}, tm2 = {};\n    std::istringstream ss1(date1), ss2(date2);\n    ss1 >> std::get_time(&tm1, \"%Y-%m-%d\");\n    ss2 >> std::get_time(&tm2, \"%Y-%m-%d\");\n\n    std::time_t time1 = std::mktime(&tm1);\n    std::time_t time2 = std::mktime(&tm2);\n    double difference = std::difftime(time2, time1);\n    return difference / 86400;\n}\n```\n    \n    The algorithm to calculate the number of days between two dates is the same for all languages. First, parse the input strings into date objects. Then, calculate the time difference between the two date objects. Finally, convert the time difference into days.\n\nFor C++, we use `istringstream`, `tm`, and `get_time` for string parsing, and `mktime` and `difftime` for time calculation.\n\nFor Java, we use `LocalDate.parse` and `ChronoUnit.DAYS.between` methods from the java.time package.\n\nFor Python, we use `datetime.strptime` for string parsing and calculate the difference using the `-` (minus) operator.\n\nFor JavaScript, we parse the input strings into date objects using the `Date` constructor and calculate the time difference by subtracting them directly. Finally, we convert the time difference (in milliseconds) to days.\n    ",
        "js": "\n    ```javascript\nfunction countDaysBetweenDates(date1, date2) {\n    const d1 = new Date(date1);\n    const d2 = new Date(date2);\n    const difference = Math.abs(d2 - d1);\n    return Math.floor(difference / (1000 * 3600 * 24));\n}\n```\n    \n    The algorithm to calculate the number of days between two dates is the same for all languages. First, parse the input strings into date objects. Then, calculate the time difference between the two date objects. Finally, convert the time difference into days.\n\nFor C++, we use `istringstream`, `tm`, and `get_time` for string parsing, and `mktime` and `difftime` for time calculation.\n\nFor Java, we use `LocalDate.parse` and `ChronoUnit.DAYS.between` methods from the java.time package.\n\nFor Python, we use `datetime.strptime` for string parsing and calculate the difference using the `-` (minus) operator.\n\nFor JavaScript, we parse the input strings into date objects using the `Date` constructor and calculate the time difference by subtracting them directly. Finally, we convert the time difference (in milliseconds) to days.\n    "
    },
    {
        "id": 225,
        "title": "Element Appearing More Than 25% In Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array **sorted** in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,2,2,6,6,6,6,7,10\\]\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,2,6,6,6,6,7,10]",
                "output": "6"
            },
            {
                "input": "[1,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int shortestDistance(int[] distance, int start, int destination) {\n    int total_distance = 0, clockwise_distance = 0;\n    \n    for(int i = 0; i < distance.length; ++i) {\n        total_distance += distance[i];\n        if(i >= start && i < destination) {\n            clockwise_distance += distance[i];\n        }\n    }\n    \n    return Math.min(clockwise_distance, total_distance - clockwise_distance);\n}\n```\n    \n    1. Initialize two variables `total_distance` and `clockwise_distance`.\n2. Iterate through the input `distance` array and add the elements into the `total_distance`.\n3. For elements between the `start` and the `destination`, add elements into the `clockwise_distance`.\n4. After the iteration, we have the total distance of the circle and the distance from `start` to `destination` in the clockwise direction.\n5. The counterclockwise distance is then `total_distance - clockwise_distance`.\n6. Return the minimum of the clockwise and counterclockwise distances.\n    ",
        "python": "\n    ```python\ndef shortest_distance(distance, start, destination):\n    total_distance = sum(distance)\n    clockwise_distance = sum(distance[start:destination])\n    \n    return min(clockwise_distance, total_distance - clockwise_distance)\n```\n    \n    1. Initialize two variables `total_distance` and `clockwise_distance`.\n2. Iterate through the input `distance` array and add the elements into the `total_distance`.\n3. For elements between the `start` and the `destination`, add elements into the `clockwise_distance`.\n4. After the iteration, we have the total distance of the circle and the distance from `start` to `destination` in the clockwise direction.\n5. The counterclockwise distance is then `total_distance - clockwise_distance`.\n6. Return the minimum of the clockwise and counterclockwise distances.\n    ",
        "c++": "\n    ```cpp\nint shortestDistance(vector<int>& distance, int start, int destination) {\n    int total_distance = 0, clockwise_distance = 0;\n    \n    for (int i = 0; i < distance.size(); ++i) {\n        total_distance += distance[i];\n        if (i >= start && i < destination) {\n            clockwise_distance += distance[i];\n        }\n    }\n    \n    return min(clockwise_distance, total_distance - clockwise_distance);\n}\n```\n    \n    1. Initialize two variables `total_distance` and `clockwise_distance`.\n2. Iterate through the input `distance` array and add the elements into the `total_distance`.\n3. For elements between the `start` and the `destination`, add elements into the `clockwise_distance`.\n4. After the iteration, we have the total distance of the circle and the distance from `start` to `destination` in the clockwise direction.\n5. The counterclockwise distance is then `total_distance - clockwise_distance`.\n6. Return the minimum of the clockwise and counterclockwise distances.\n    ",
        "js": "\n    ```javascript\nfunction shortestDistance(distance, start, destination) {\n    let total_distance = 0, clockwise_distance = 0;\n    \n    for (let i = 0; i < distance.length; ++i) {\n        total_distance += distance[i];\n        if (i >= start && i < destination) {\n            clockwise_distance += distance[i];\n        }\n    }\n    \n    return Math.min(clockwise_distance, total_distance - clockwise_distance);\n}\n```\n    \n    1. Initialize two variables `total_distance` and `clockwise_distance`.\n2. Iterate through the input `distance` array and add the elements into the `total_distance`.\n3. For elements between the `start` and the `destination`, add elements into the `clockwise_distance`.\n4. After the iteration, we have the total distance of the circle and the distance from `start` to `destination` in the clockwise direction.\n5. The counterclockwise distance is then `total_distance - clockwise_distance`.\n6. Return the minimum of the clockwise and counterclockwise distances.\n    "
    },
    {
        "id": 226,
        "title": "Filter Restaurants by Vegan-Friendly, Price and Distance",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the array `restaurants` where `restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]`. You have to filter the restaurants using three filters.\n\nThe `veganFriendly` filter will be either _true_ (meaning you should only include restaurants with `veganFriendlyi` set to true) or _false_ (meaning you can include any restaurant). In addition, you have the filters `maxPrice` and `maxDistance` which are the maximum value for price and distance of restaurants you should consider respectively.\n\nReturn the array of restaurant _**IDs**_ after filtering, ordered by **rating** from highest to lowest. For restaurants with the same rating, order them by _**id**_ from highest to lowest. For simplicity `veganFriendlyi` and `veganFriendly` take value _1_ when it is _true_, and _0_ when it is _false_.",
            "examples": [
                "**Example 1:**\n\n**Input:** restaurants = \\[\\[1,4,1,40,10\\],\\[2,8,0,50,5\\],\\[3,8,1,30,4\\],\\[4,10,0,10,3\\],\\[5,1,1,15,1\\]\\], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n**Output:** \\[3,1,5\\] \n**Explanation:** \nThe restaurants are:\nRestaurant 1 \\[id=1, rating=4, veganFriendly=1, price=40, distance=10\\]\nRestaurant 2 \\[id=2, rating=8, veganFriendly=0, price=50, distance=5\\]\nRestaurant 3 \\[id=3, rating=8, veganFriendly=1, price=30, distance=4\\]\nRestaurant 4 \\[id=4, rating=10, veganFriendly=0, price=10, distance=3\\]\nRestaurant 5 \\[id=5, rating=1, veganFriendly=1, price=15, distance=1\\] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). \n\n",
                "**Example 2:**\n\n**Input:** restaurants = \\[\\[1,4,1,40,10\\],\\[2,8,0,50,5\\],\\[3,8,1,30,4\\],\\[4,10,0,10,3\\],\\[5,1,1,15,1\\]\\], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n**Output:** \\[4,3,2,1,5\\]\n**Explanation:** The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.\n\n",
                "**Example 3:**\n\n**Input:** restaurants = \\[\\[1,4,1,40,10\\],\\[2,8,0,50,5\\],\\[3,8,1,30,4\\],\\[4,10,0,10,3\\],\\[5,1,1,15,1\\]\\], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n**Output:** \\[4,5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= restaurants.length <= 10^4`\n*   `restaurants[i].length == 5`\n*   `1 <= idi, ratingi, pricei, distancei <= 10^5`\n*   `1 <= maxPrice, maxDistance <= 10^5`\n*   `veganFriendlyi` and `veganFriendly` are 0 or 1.\n*   All `idi` are distinct.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]],1,50,10",
                "output": "[3,1,5]"
            },
            {
                "input": "[[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]],0,50,10",
                "output": "[4,3,2,1,5]"
            },
            {
                "input": "[[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]],0,30,3",
                "output": "[4,5]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] sortBasedOnMapping(int[] mapping, int[] nums) {\n    Integer[] boxedNums = Arrays.stream(nums).boxed().toArray(Integer[]::new);\n    Arrays.sort(boxedNums, (a, b) -> {\n        String aStr = Integer.toString(a);\n        String bStr = Integer.toString(b);\n        for (int i = 0; i < aStr.length(); i++)\n            aStr = aStr.substring(0, i) + mapping[aStr.charAt(i) - '0'] + aStr.substring(i + 1);\n        for (int i = 0; i < bStr.length(); i++)\n            bStr = bStr.substring(0, i) + mapping[bStr.charAt(i) - '0'] + bStr.substring(i + 1);\n        return aStr.compareTo(bStr);\n    });\n    return Arrays.stream(boxedNums).mapToInt(Integer::intValue).toArray();\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Define a function to map the given number based on the mapping rules provided.\n2. For each number in the array, calculate and store its mapped value while maintaining the original number.\n3. Sort the numbers based on their mapped values.\n4. Return the sorted array.\n\nIn each language implementation, we start by defining a function to calculate the mapped value of a given number. We then use a sorting function provided by the language and pass a custom comparison function to sort the array based on the mapped values. Finally, we return the sorted array.\n    ",
        "python": "\n    ```python\ndef sort_based_on_mapping(mapping, nums):\n    def mapped_value(num):\n        return int(''.join(str(mapping[int(d)]) for d in str(num)))\n    \n    return sorted(nums, key=mapped_value)\n```\n    \n    The algorithm consists of the following steps:\n1. Define a function to map the given number based on the mapping rules provided.\n2. For each number in the array, calculate and store its mapped value while maintaining the original number.\n3. Sort the numbers based on their mapped values.\n4. Return the sorted array.\n\nIn each language implementation, we start by defining a function to calculate the mapped value of a given number. We then use a sorting function provided by the language and pass a custom comparison function to sort the array based on the mapped values. Finally, we return the sorted array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sortBasedOnMapping(std::vector<int>& mapping, std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end(), [&](int a, int b) {\n        std::string aStr = std::to_string(a);\n        std::string bStr = std::to_string(b);\n        for (char &c : aStr) c = '0' + mapping[c - '0'];\n        for (char &c : bStr) c = '0' + mapping[c - '0'];\n        return aStr < bStr;\n    });\n    return nums;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Define a function to map the given number based on the mapping rules provided.\n2. For each number in the array, calculate and store its mapped value while maintaining the original number.\n3. Sort the numbers based on their mapped values.\n4. Return the sorted array.\n\nIn each language implementation, we start by defining a function to calculate the mapped value of a given number. We then use a sorting function provided by the language and pass a custom comparison function to sort the array based on the mapped values. Finally, we return the sorted array.\n    ",
        "js": "\n    ```javascript\nfunction sortBasedOnMapping(mapping, nums) {\n    const mappedValue = num => {\n        return parseInt([...num.toString()].map(d => mapping[parseInt(d)]).join(''));\n    };\n\n    return nums.sort((a, b) => mappedValue(a) - mappedValue(b));\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Define a function to map the given number based on the mapping rules provided.\n2. For each number in the array, calculate and store its mapped value while maintaining the original number.\n3. Sort the numbers based on their mapped values.\n4. Return the sorted array.\n\nIn each language implementation, we start by defining a function to calculate the mapped value of a given number. We then use a sorting function provided by the language and pass a custom comparison function to sort the array based on the mapped values. Finally, we return the sorted array.\n    "
    },
    {
        "id": 227,
        "title": "Number of Ways to Paint N  3 Grid",
        "difficulty": "Hard",
        "content": {
            "problem": "You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\nGiven `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** 12\n**Explanation:** There are 12 possible way to paint the grid as shown.\n\n",
                "**Example 2:**\n\n**Input:** n = 5000\n**Output:** 30228214"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length`\n*   `1 <= n <= 5000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "1",
                "output": "12"
            },
            {
                "input": "5000",
                "output": "30228214"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic int getDecimalValue(ListNode head) {\n    int num = 0;\n    while (head != null) {\n        num = (num << 1) | head.val;\n        head = head.next;\n    }\n    return num;\n}\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nint getDecimalValue(ListNode* head) {\n    int num = 0;\n    while (head) {\n        num = (num << 1) | head->val;\n        head = head->next;\n    }\n    return num;\n}\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction getDecimalValue(head) {\n    let num = 0;\n    while (head) {\n        num = (num << 1) | head.val;\n        head = head.next;\n    }\n    return num;\n}\n```\n    \n    The algorithm iterates through the singly-linked list, starting at the head node. The binary number represented by the linked list is constructed by shifting the current value of `num` one bit to the left and performing a bitwise OR operation with the value of the current node. This process continues until the end of the linked list is reached. After the last node, `num` contains the decimal representation of the binary number, so the function returns it.\n    "
    },
    {
        "id": 228,
        "title": "Counting Elements",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `arr`, count how many elements `x` there are, such that `x + 1` is also in `arr`. If there are duplicates in `arr`, count them separately.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** 1 and 2 are counted cause 2 and 3 are in arr.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,1,3,3,5,5,7,7\\]\n**Output:** 0\n**Explanation:** No numbers are counted, cause there is no 2, 4, 6, or 8 in arr."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `0 <= arr[i] <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "2"
            },
            {
                "input": "[1,1,3,3,5,5,7,7]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int[] sumZero(int n) {\n    int[] res = new int[n];\n    for (int i = 1; i <= n / 2; i++) {\n        res[i - 1] = i;\n        res[n - i] = -i;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates from 1 to n/2 (inclusive). For each number i, it appends both i and -i to the result array, making their sum equal to 0. If the given integer n is odd, then there is one more number remaining which is 0, so we append 0 to the result array. By doing this, we create a unique array of integers adding up to 0. The time complexity of this algorithm is O(n/2) = O(n), and the space complexity is also O(n) as the size of the result array is equal to the given input n.\n    ",
        "python": "\n    ```python\ndef sum_zero(n):\n    res = []\n    for i in range(1, (n // 2) + 1):\n        res.append(i)\n        res.append(-i)\n    if n % 2 != 0:\n        res.append(0)\n    return res\n```\n    \n    The algorithm iterates from 1 to n/2 (inclusive). For each number i, it appends both i and -i to the result array, making their sum equal to 0. If the given integer n is odd, then there is one more number remaining which is 0, so we append 0 to the result array. By doing this, we create a unique array of integers adding up to 0. The time complexity of this algorithm is O(n/2) = O(n), and the space complexity is also O(n) as the size of the result array is equal to the given input n.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> sumZero(int n) {\n    std::vector<int> res;\n    for (int i = 1; i <= n / 2; i++) {\n        res.push_back(i);\n        res.push_back(-i);\n    }\n    if (n % 2 != 0) {\n        res.push_back(0);\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates from 1 to n/2 (inclusive). For each number i, it appends both i and -i to the result array, making their sum equal to 0. If the given integer n is odd, then there is one more number remaining which is 0, so we append 0 to the result array. By doing this, we create a unique array of integers adding up to 0. The time complexity of this algorithm is O(n/2) = O(n), and the space complexity is also O(n) as the size of the result array is equal to the given input n.\n    ",
        "js": "\n    ```javascript\nfunction sumZero(n) {\n    const res = [];\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\n        res.push(i);\n        res.push(-i);\n    }\n    if (n % 2 !== 0) {\n        res.push(0);\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates from 1 to n/2 (inclusive). For each number i, it appends both i and -i to the result array, making their sum equal to 0. If the given integer n is odd, then there is one more number remaining which is 0, so we append 0 to the result array. By doing this, we create a unique array of integers adding up to 0. The time complexity of this algorithm is O(n/2) = O(n), and the space complexity is also O(n) as the size of the result array is equal to the given input n.\n    "
    },
    {
        "id": 229,
        "title": "Perform String Shifts",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` containing lowercase English letters, and a matrix `shift`, where `shift[i] = [directioni, amounti]`:\n\n*   `directioni` can be `0` (for left shift) or `1` (for right shift).\n*   `amounti` is the amount by which string `s` is to be shifted.\n*   A left shift by 1 means remove the first character of `s` and append it to the end.\n*   Similarly, a right shift by 1 means remove the last character of `s` and add it to the beginning.\n\nReturn the final string after all operations.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abc \", shift = \\[\\[0,1\\],\\[1,2\\]\\]\n**Output:**  \"cab \"\n**Explanation:** \n\\[0,1\\] means shift to left by 1.  \"abc \" ->  \"bca \"\n\\[1,2\\] means shift to right by 2.  \"bca \" ->  \"cab \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdefg \", shift = \\[\\[1,1\\],\\[1,1\\],\\[0,2\\],\\[1,3\\]\\]\n**Output:**  \"efgabcd \"\n**Explanation:**  \n\\[1,1\\] means shift to right by 1.  \"abcdefg \" ->  \"gabcdef \"\n\\[1,1\\] means shift to right by 1.  \"gabcdef \" ->  \"fgabcde \"\n\\[0,2\\] means shift to left by 2.  \"fgabcde \" ->  \"abcdefg \"\n\\[1,3\\] means shift to right by 3.  \"abcdefg \" ->  \"efgabcd \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` only contains lower case English letters.\n*   `1 <= shift.length <= 100`\n*   `shift[i].length == 2`\n*   `directioni` is either `0` or `1`.\n*   `0 <= amounti <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abc\",[[0,1],[1,2]]",
                "output": "\"cab\""
            },
            {
                "input": "\"abcdefg\",[[1,1],[1,1],[0,2],[1,3]]",
                "output": "\"efgabcd\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int v) { val = v; }\n}\n\npublic List<Integer> inorder(TreeNode root, List<Integer> output) {\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode current = root;\n\n    while (current != null || !stack.isEmpty()) {\n        while (current != null) {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        output.add(current.val);\n        current = current.right;\n    }\n\n    return output;\n}\n\npublic List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    List<Integer> tree1 = new ArrayList<>();\n    List<Integer> tree2 = new ArrayList<>();\n    inorder(root1, tree1);\n    inorder(root2, tree2);\n\n    List<Integer> result = new ArrayList<>();\n    int i = 0, j = 0;\n    while (i < tree1.size() || j < tree2.size()) {\n        if (i < tree1.size() && (j >= tree2.size() || tree1.get(i) <= tree2.get(j))) {\n            result.add(tree1.get(i++));\n        } else {\n            result.add(tree2.get(j++));\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Create a helper function, `inorder`, which takes a root node and returns the inorder traversal of the tree, in the form of an array/vector/list.\n2. The `inorder` function uses a stack and a while loop to iterate through each node. It starts with the left-most node and iterates through to the right-most node.\n3. Call the `inorder` function on both `root1` and `root2` and store the results in two separate arrays.\n4. Initialize two pointers `i` and `j` and iterate through both arrays together.\n5. Compare the current element of both arrays, and push the smaller element onto the result array, incrementing the corresponding pointer.\n6. If one array reaches the end, push the remaining elements from the other array to the result array.\n7. Return the result array containing the sorted elements from both trees.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder(root):\n    output = []\n    stack = []\n    current = root\n\n    while current or stack:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        output.append(current.val)\n        current = current.right\n\n    return output\n\ndef getAllElements(root1, root2):\n    tree1 = inorder(root1)\n    tree2 = inorder(root2)\n    result = []\n    i, j = 0, 0\n\n    while i < len(tree1) or j < len(tree2):\n        if i < len(tree1) and (j >= len(tree2) or tree1[i] <= tree2[j]):\n            result.append(tree1[i])\n            i += 1\n        else:\n            result.append(tree2[j])\n            j += 1\n\n    return result\n```\n    \n    1. Create a helper function, `inorder`, which takes a root node and returns the inorder traversal of the tree, in the form of an array/vector/list.\n2. The `inorder` function uses a stack and a while loop to iterate through each node. It starts with the left-most node and iterates through to the right-most node.\n3. Call the `inorder` function on both `root1` and `root2` and store the results in two separate arrays.\n4. Initialize two pointers `i` and `j` and iterate through both arrays together.\n5. Compare the current element of both arrays, and push the smaller element onto the result array, incrementing the corresponding pointer.\n6. If one array reaches the end, push the remaining elements from the other array to the result array.\n7. Return the result array containing the sorted elements from both trees.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int v) : val(v), left(nullptr), right(nullptr) {}\n};\n\nvoid inorder(TreeNode* root, vector<int>& output) {\n    stack<TreeNode*> s;\n    TreeNode* current = root;\n\n    while (current || !s.empty()) {\n        while (current) {\n            s.push(current);\n            current = current->left;\n        }\n        current = s.top();\n        s.pop();\n        output.push_back(current->val);\n        current = current->right;\n    }\n}\n\nvector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n    vector<int> tree1, tree2;\n    inorder(root1, tree1);\n    inorder(root2, tree2);\n\n    vector<int> result;\n    int i = 0, j = 0;\n    while (i < tree1.size() || j < tree2.size()) {\n        if (i < tree1.size() && (j >= tree2.size() || tree1[i] <= tree2[j])) {\n            result.push_back(tree1[i++]);\n        } else {\n            result.push_back(tree2[j++]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Create a helper function, `inorder`, which takes a root node and returns the inorder traversal of the tree, in the form of an array/vector/list.\n2. The `inorder` function uses a stack and a while loop to iterate through each node. It starts with the left-most node and iterates through to the right-most node.\n3. Call the `inorder` function on both `root1` and `root2` and store the results in two separate arrays.\n4. Initialize two pointers `i` and `j` and iterate through both arrays together.\n5. Compare the current element of both arrays, and push the smaller element onto the result array, incrementing the corresponding pointer.\n6. If one array reaches the end, push the remaining elements from the other array to the result array.\n7. Return the result array containing the sorted elements from both trees.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorder(root) {\n    const output = [];\n    const stack = [];\n    let current = root;\n\n    while (current || stack.length) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        output.push(current.val);\n        current = current.right;\n    }\n\n    return output;\n}\n\nfunction getAllElements(root1, root2) {\n    const tree1 = inorder(root1);\n    const tree2 = inorder(root2);\n    const result = [];\n    let i = 0, j = 0;\n\n    while (i < tree1.length || j < tree2.length) {\n        if (i < tree1.length && (j >= tree2.length || tree1[i] <= tree2[j])) {\n            result.push(tree1[i++]);\n        } else {\n            result.push(tree2[j++]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Create a helper function, `inorder`, which takes a root node and returns the inorder traversal of the tree, in the form of an array/vector/list.\n2. The `inorder` function uses a stack and a while loop to iterate through each node. It starts with the left-most node and iterates through to the right-most node.\n3. Call the `inorder` function on both `root1` and `root2` and store the results in two separate arrays.\n4. Initialize two pointers `i` and `j` and iterate through both arrays together.\n5. Compare the current element of both arrays, and push the smaller element onto the result array, incrementing the corresponding pointer.\n6. If one array reaches the end, push the remaining elements from the other array to the result array.\n7. Return the result array containing the sorted elements from both trees.\n    "
    },
    {
        "id": 230,
        "title": "Leftmost Column with at Least a One",
        "difficulty": "Medium",
        "content": {
            "problem": "A **row-sorted binary matrix** means that all elements are `0` or `1` and each row of the matrix is sorted in non-decreasing order.\n\nGiven a **row-sorted binary matrix** `binaryMatrix`, return _the index (0-indexed) of the **leftmost column** with a 1 in it_. If such an index does not exist, return `-1`.\n\n**You can't access the Binary Matrix directly.** You may only access the matrix using a `BinaryMatrix` interface:\n\n*   `BinaryMatrix.get(row, col)` returns the element of the matrix at index `(row, col)` (0-indexed).\n*   `BinaryMatrix.dimensions()` returns the dimensions of the matrix as a list of 2 elements `[rows, cols]`, which means the matrix is `rows x cols`.\n\nSubmissions making more than `1000` calls to `BinaryMatrix.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n\nFor custom testing purposes, the input will be the entire binary matrix `mat`. You will not have access to the binary matrix directly.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[0,0\\],\\[1,1\\]\\]\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[0,0\\],\\[0,1\\]\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** mat = \\[\\[0,0\\],\\[0,0\\]\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `rows == mat.length`\n*   `cols == mat[i].length`\n*   `1 <= rows, cols <= 100`\n*   `mat[i][j]` is either `0` or `1`.\n*   `mat[i]` is sorted in non-decreasing order.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0],[1,1]]",
                "output": "0"
            },
            {
                "input": "[[0,0],[0,1]]",
                "output": "1"
            },
            {
                "input": "[[0,0],[0,0]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nboolean canReach(int[] arr, int start) {\n    if (start >= 0 && start < arr.length && arr[start] >= 0) {\n        if (arr[start] == 0)\n            return true;\n\n        arr[start] = -arr[start];\n        return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a depth-first search approach. At each index `i`, it checks if it's within the bounds of the array and if the value at the current index is non-negative.\n\nIf the current value is 0, it returns true because the goal is reached.\nIf not, it marks the current position as visited by negating the value and then checks if it can reach 0 with the available jump choices, `i + arr[i]` or `i - arr[i]`.\n\nThe function returns false if no valid path was found that reaches the 0 value.\n    ",
        "python": "\n    ```python\ndef canReach(arr: List[int], start: int) -> bool:\n    if 0 <= start < len(arr) and arr[start] >= 0:\n        if arr[start] == 0:\n            return True\n        \n        jump = arr[start]\n        arr[start] = -arr[start]\n        return canReach(arr, start + jump) or canReach(arr, start - jump)\n    return False\n```\n    \n    The algorithm uses a depth-first search approach. At each index `i`, it checks if it's within the bounds of the array and if the value at the current index is non-negative.\n\nIf the current value is 0, it returns true because the goal is reached.\nIf not, it marks the current position as visited by negating the value and then checks if it can reach 0 with the available jump choices, `i + arr[i]` or `i - arr[i]`.\n\nThe function returns false if no valid path was found that reaches the 0 value.\n    ",
        "c++": "\n    ```cpp\nbool canReach(vector<int> &arr, int start) {\n    if (start >= 0 && start < arr.size() && arr[start] >= 0) {\n        if (arr[start] == 0)\n            return true;\n\n        arr[start] = -arr[start];\n        return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a depth-first search approach. At each index `i`, it checks if it's within the bounds of the array and if the value at the current index is non-negative.\n\nIf the current value is 0, it returns true because the goal is reached.\nIf not, it marks the current position as visited by negating the value and then checks if it can reach 0 with the available jump choices, `i + arr[i]` or `i - arr[i]`.\n\nThe function returns false if no valid path was found that reaches the 0 value.\n    ",
        "js": "\n    ```javascript\nfunction canReach(arr, start) {\n    if (start >= 0 && start < arr.length && arr[start] >= 0) {\n        if (arr[start] === 0)\n            return true;\n\n        let jump = arr[start];\n        arr[start] = -arr[start];\n        return canReach(arr, start + jump) || canReach(arr, start - jump);\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a depth-first search approach. At each index `i`, it checks if it's within the bounds of the array and if the value at the current index is non-negative.\n\nIf the current value is 0, it returns true because the goal is reached.\nIf not, it marks the current position as visited by negating the value and then checks if it can reach 0 with the available jump choices, `i + arr[i]` or `i - arr[i]`.\n\nThe function returns false if no valid path was found that reaches the 0 value.\n    "
    },
    {
        "id": 231,
        "title": "First Unique Number",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a queue of integers, you need to retrieve the first unique integer in the queue.\n\nImplement the `FirstUnique` class:\n\n*   `FirstUnique(int[] nums)` Initializes the object with the numbers in the queue.\n*   `int showFirstUnique()` returns the value of **the first unique** integer of the queue, and returns **\\-1** if there is no such integer.\n*   `void add(int value)` insert value to the queue.",
            "examples": [
                "**Example 1:**\n\n**Input:** \n\\[ \"FirstUnique \", \"showFirstUnique \", \"add \", \"showFirstUnique \", \"add \", \"showFirstUnique \", \"add \", \"showFirstUnique \"\\]\n\\[\\[\\[2,3,5\\]\\],\\[\\],\\[5\\],\\[\\],\\[2\\],\\[\\],\\[3\\],\\[\\]\\]\n**Output:** \n\\[null,2,null,2,null,3,null,-1\\]\n**Explanation:** \nFirstUnique firstUnique = new FirstUnique(\\[2,3,5\\]);\nfirstUnique.showFirstUnique(); // return 2\nfirstUnique.add(5);            // the queue is now \\[2,3,5,5\\]\nfirstUnique.showFirstUnique(); // return 2\nfirstUnique.add(2);            // the queue is now \\[2,3,5,5,2\\]\nfirstUnique.showFirstUnique(); // return 3\nfirstUnique.add(3);            // the queue is now \\[2,3,5,5,2,3\\]\nfirstUnique.showFirstUnique(); // return -1\n\n",
                "**Example 2:**\n\n**Input:** \n\\[ \"FirstUnique \", \"showFirstUnique \", \"add \", \"add \", \"add \", \"add \", \"add \", \"showFirstUnique \"\\]\n\\[\\[\\[7,7,7,7,7,7\\]\\],\\[\\],\\[7\\],\\[3\\],\\[3\\],\\[7\\],\\[17\\],\\[\\]\\]\n**Output:** \n\\[null,-1,null,null,null,null,null,17\\]\n**Explanation:** \nFirstUnique firstUnique = new FirstUnique(\\[7,7,7,7,7,7\\]);\nfirstUnique.showFirstUnique(); // return -1\nfirstUnique.add(7);            // the queue is now \\[7,7,7,7,7,7,7\\]\nfirstUnique.add(3);            // the queue is now \\[7,7,7,7,7,7,7,3\\]\nfirstUnique.add(3);            // the queue is now \\[7,7,7,7,7,7,7,3,3\\]\nfirstUnique.add(7);            // the queue is now \\[7,7,7,7,7,7,7,3,3,7\\]\nfirstUnique.add(17);           // the queue is now \\[7,7,7,7,7,7,7,3,3,7,17\\]\nfirstUnique.showFirstUnique(); // return 17\n\n",
                "**Example 3:**\n\n**Input:** \n\\[ \"FirstUnique \", \"showFirstUnique \", \"add \", \"showFirstUnique \"\\]\n\\[\\[\\[809\\]\\],\\[\\],\\[809\\],\\[\\]\\]\n**Output:** \n\\[null,809,null,-1\\]\n**Explanation:** \nFirstUnique firstUnique = new FirstUnique(\\[809\\]);\nfirstUnique.showFirstUnique(); // return 809\nfirstUnique.add(809);          // the queue is now \\[809,809\\]\nfirstUnique.showFirstUnique(); // return -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 10^5`\n*   `1 <= nums[i] <= 10^8`\n*   `1 <= value <= 10^8`\n*   At most `50000` calls will be made to `showFirstUnique` and `add`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[],[5],[],[2],[],[3],[]]",
                "output": "\n[null,2,null,2,null,3,null,-1]"
            },
            {
                "input": "]\n]],[],[7],[3],[3],[7],[17],[]]",
                "output": "\n[null,-1,null,null,null,null,null,17]"
            },
            {
                "input": "]\n]],[],[809],[]]",
                "output": "\n[null,809,null,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Map;\n\npublic boolean isSolvable(Map<Character, Integer> words, int result) {\n    int sum = 0;\n    for (int value : words.values()) {\n        sum += value;\n    }\n    return sum % 10 == result % 10;\n}\n```\n    \n    The problem states that we need to check if the given equation is solvable based on a given mapping of characters to integers. The best data structure to represent this mapping is a dictionary (or map) for each language.\n\nThe algorithm is as follows:\n\n1. For each character in the words (left side of the equation), get the corresponding integer value from the map and add it to a sum variable.\n2. Check if the sum of the left side modulo 10 is equal to the right side of the equation modulo 10. If they are equal, return `true`, otherwise return `false`.\n\nThe reason for using the modulo operation is to ensure that the sum of the left side does not exceed the range of single-digit numbers, which is a constraint of the problem.\n    ",
        "python": "\n    ```python\ndef is_solvable(words, result):\n    return sum(words.values()) % 10 == result % 10\n```\n    \n    The problem states that we need to check if the given equation is solvable based on a given mapping of characters to integers. The best data structure to represent this mapping is a dictionary (or map) for each language.\n\nThe algorithm is as follows:\n\n1. For each character in the words (left side of the equation), get the corresponding integer value from the map and add it to a sum variable.\n2. Check if the sum of the left side modulo 10 is equal to the right side of the equation modulo 10. If they are equal, return `true`, otherwise return `false`.\n\nThe reason for using the modulo operation is to ensure that the sum of the left side does not exceed the range of single-digit numbers, which is a constraint of the problem.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n#include <string>\n\nbool isSolvable(std::map<char, int> words, int result) {\n    int sum = 0;\n    for (auto const& word : words) {\n        sum += word.second;\n    }\n    return sum % 10 == result % 10;\n}\n```\n    \n    The problem states that we need to check if the given equation is solvable based on a given mapping of characters to integers. The best data structure to represent this mapping is a dictionary (or map) for each language.\n\nThe algorithm is as follows:\n\n1. For each character in the words (left side of the equation), get the corresponding integer value from the map and add it to a sum variable.\n2. Check if the sum of the left side modulo 10 is equal to the right side of the equation modulo 10. If they are equal, return `true`, otherwise return `false`.\n\nThe reason for using the modulo operation is to ensure that the sum of the left side does not exceed the range of single-digit numbers, which is a constraint of the problem.\n    ",
        "js": "\n    ```javascript\nfunction isSolvable(words, result) {\n    let sum = 0;\n    for (let key in words) {\n        sum += words[key];\n    }\n    return sum % 10 === result % 10;\n}\n```\n    \n    The problem states that we need to check if the given equation is solvable based on a given mapping of characters to integers. The best data structure to represent this mapping is a dictionary (or map) for each language.\n\nThe algorithm is as follows:\n\n1. For each character in the words (left side of the equation), get the corresponding integer value from the map and add it to a sum variable.\n2. Check if the sum of the left side modulo 10 is equal to the right side of the equation modulo 10. If they are equal, return `true`, otherwise return `false`.\n\nThe reason for using the modulo operation is to ensure that the sum of the left side does not exceed the range of single-digit numbers, which is a constraint of the problem.\n    "
    },
    {
        "id": 232,
        "title": "Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a binary tree where each path going from the root to any leaf form a **valid sequence**, check if a given string is a **valid sequence** in such binary tree.\n\nWe get the given string from the concatenation of an array of integers `arr` and the concatenation of all values of the nodes along a path results in a **sequence** in the given binary tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[0,1,0,0,1,0,null,null,1,0,0\\], arr = \\[0,1,0,1\\]\n**Output:** true\n**Explanation:** \nThe path 0 -> 1 -> 0 -> 1 is a valid sequence (green color in the figure). \nOther valid sequences are: \n0 -> 1 -> 1 -> 0 \n0 -> 0 -> 0\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0,1,0,0,1,0,null,null,1,0,0\\], arr = \\[0,0,1\\]\n**Output:** false \n**Explanation:** The path 0 -> 0 -> 1 does not exist, therefore it is not even a sequence.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[0,1,0,0,1,0,null,null,1,0,0\\], arr = \\[0,1,1\\]\n**Output:** false\n**Explanation:** The path 0 -> 1 -> 1 is a sequence, but it is not a valid sequence."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 5000`\n*   `0 <= arr[i] <= 9`\n*   Each node's value is between \\[0 - 9\\].",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,0,0,1,0,null,null,1,0,0],[0,1,0,1]",
                "output": "true"
            },
            {
                "input": "[0,1,0,0,1,0,null,null,1,0,0],[0,0,1]",
                "output": "false"
            },
            {
                "input": "[0,1,0,0,1,0,null,null,1,0,0],[0,1,1]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic boolean isValidSequence(TreeNode root, int[] arr, int index) {\n    if (root == null || index >= arr.length || arr[index] != root.val) {\n        return false;\n    }\n    if (root.left == null && root.right == null) {\n        return index == arr.length - 1;\n    }\n    return isValidSequence(root.left, arr, index + 1) || isValidSequence(root.right, arr, index + 1);\n}\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to traverse the given binary tree. We pass the current root node, the input array `arr`, and the current index (starting with 0) into the `isValidSequence` function.\n\nWe use recursion to traverse the tree, checking the following conditions:\n- If the current root node is null, or the current index is out of bounds of the array, or the current node value is not equal to the array value at the current index, then we return false since this is not a valid sequence.\n- If the current root node is a leaf node (both left and right children are null), we check if the current index is the last index in the array. If it is, then the path is a valid sequence and we return true; otherwise, we return false.\n- For non-leaf nodes, we recursively call the `isValidSequence` function on the left and right children of the current node, increasing the index by 1. If either of these recursive calls return true, the overall result is true; otherwise, the result is false.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidSequence(root, arr, index=0):\n    if not root or index >= len(arr) or arr[index] != root.val:\n        return False\n    if not root.left and not root.right:\n        return index == len(arr) - 1\n    return isValidSequence(root.left, arr, index + 1) or isValidSequence(root.right, arr, index + 1)\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to traverse the given binary tree. We pass the current root node, the input array `arr`, and the current index (starting with 0) into the `isValidSequence` function.\n\nWe use recursion to traverse the tree, checking the following conditions:\n- If the current root node is null, or the current index is out of bounds of the array, or the current node value is not equal to the array value at the current index, then we return false since this is not a valid sequence.\n- If the current root node is a leaf node (both left and right children are null), we check if the current index is the last index in the array. If it is, then the path is a valid sequence and we return true; otherwise, we return false.\n- For non-leaf nodes, we recursively call the `isValidSequence` function on the left and right children of the current node, increasing the index by 1. If either of these recursive calls return true, the overall result is true; otherwise, the result is false.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool isValidSequence(TreeNode* root, vector<int>& arr, int index = 0) {\n    if (root == nullptr || index >= arr.size() || arr[index] != root->val) {\n        return false;\n    }\n    if (root->left == nullptr && root->right == nullptr) {\n        return index == arr.size() - 1;\n    }\n    return isValidSequence(root->left, arr, index + 1) || isValidSequence(root->right, arr, index + 1);\n}\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to traverse the given binary tree. We pass the current root node, the input array `arr`, and the current index (starting with 0) into the `isValidSequence` function.\n\nWe use recursion to traverse the tree, checking the following conditions:\n- If the current root node is null, or the current index is out of bounds of the array, or the current node value is not equal to the array value at the current index, then we return false since this is not a valid sequence.\n- If the current root node is a leaf node (both left and right children are null), we check if the current index is the last index in the array. If it is, then the path is a valid sequence and we return true; otherwise, we return false.\n- For non-leaf nodes, we recursively call the `isValidSequence` function on the left and right children of the current node, increasing the index by 1. If either of these recursive calls return true, the overall result is true; otherwise, the result is false.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isValidSequence(root, arr, index = 0) {\n    if (!root || index >= arr.length || arr[index] !== root.val) {\n        return false;\n    }\n    if (!root.left && !root.right) {\n        return index === arr.length - 1;\n    }\n    return isValidSequence(root.left, arr, index + 1) || isValidSequence(root.right, arr, index + 1);\n}\n```\n    \n    The algorithm uses a Depth-First Search (DFS) approach to traverse the given binary tree. We pass the current root node, the input array `arr`, and the current index (starting with 0) into the `isValidSequence` function.\n\nWe use recursion to traverse the tree, checking the following conditions:\n- If the current root node is null, or the current index is out of bounds of the array, or the current node value is not equal to the array value at the current index, then we return false since this is not a valid sequence.\n- If the current root node is a leaf node (both left and right children are null), we check if the current index is the last index in the array. If it is, then the path is a valid sequence and we return true; otherwise, we return false.\n- For non-leaf nodes, we recursively call the `isValidSequence` function on the left and right children of the current node, increasing the index by 1. If either of these recursive calls return true, the overall result is true; otherwise, the result is false.\n    "
    },
    {
        "id": 233,
        "title": "Check If All 1's Are at Least Length K Places Away",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an binary array `nums` and an integer `k`, return `true` _if all_ `1`_'s are at least_ `k` _places away from each other, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,0,0,0,1,0,0,1\\], k = 2\n**Output:** true\n**Explanation:** Each of the 1s are at least 2 places away from each other.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,0,1,0,1\\], k = 2\n**Output:** false\n**Explanation:** The second 1 and third 1 are only one apart from each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= k <= nums.length`\n*   `nums[i]` is `0` or `1`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,0,0,0,1,0,0,1],2",
                "output": "true"
            },
            {
                "input": "[1,0,0,1,0,1],2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nint minStepsToMakePalindrome(String s) {\n    int n = s.length();\n    int[][] dp = new int[n][n];\n\n    for (int i = n - 2; i >= 0; i--) {\n        for (int j = i + 1; j < n; j++) {\n            if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n```\n    \n    We use dynamic programming to find the minimum number of steps required to make a string palindrome. The `dp[i][j]` element of the 2D `dp` array represents the minimum number of steps required to make a palindrome from substring `s[i..j]`. We iterate through the string in reverse order, and for each pair of characters, if the characters are equal, we update the `dp[i][j]` value using the `dp[i+1][j-1]`. If they are not equal, we update the `dp[i][j]` using the minimum value between `dp[i+1][j]` and `dp[i][j-1]`, adding 1 to it. In the end, we return the value at `dp[0][n-1]`, which represents the minimum steps required to make the whole string palindrome.\n    ",
        "python": "\n    ```python\ndef min_steps_to_make_palindrome(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n```\n    \n    We use dynamic programming to find the minimum number of steps required to make a string palindrome. The `dp[i][j]` element of the 2D `dp` array represents the minimum number of steps required to make a palindrome from substring `s[i..j]`. We iterate through the string in reverse order, and for each pair of characters, if the characters are equal, we update the `dp[i][j]` value using the `dp[i+1][j-1]`. If they are not equal, we update the `dp[i][j]` using the minimum value between `dp[i+1][j]` and `dp[i][j-1]`, adding 1 to it. In the end, we return the value at `dp[0][n-1]`, which represents the minimum steps required to make the whole string palindrome.\n    ",
        "c++": "\n    ```cpp\nint minStepsToMakePalindrome(std::string s) {\n    int n = s.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n\n    for (int i = n - 2; i >= 0; i--) {\n        for (int j = i + 1; j < n; j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = 1 + std::min(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n```\n    \n    We use dynamic programming to find the minimum number of steps required to make a string palindrome. The `dp[i][j]` element of the 2D `dp` array represents the minimum number of steps required to make a palindrome from substring `s[i..j]`. We iterate through the string in reverse order, and for each pair of characters, if the characters are equal, we update the `dp[i][j]` value using the `dp[i+1][j-1]`. If they are not equal, we update the `dp[i][j]` using the minimum value between `dp[i+1][j]` and `dp[i][j-1]`, adding 1 to it. In the end, we return the value at `dp[0][n-1]`, which represents the minimum steps required to make the whole string palindrome.\n    ",
        "js": "\n    ```javascript\nfunction minStepsToMakePalindrome(s) {\n    const n = s.length;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n\n    for (let i = n - 2; i >= 0; i--) {\n        for (let j = i + 1; j < n; j++) {\n            if (s[i] === s[j]) {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n```\n    \n    We use dynamic programming to find the minimum number of steps required to make a string palindrome. The `dp[i][j]` element of the 2D `dp` array represents the minimum number of steps required to make a palindrome from substring `s[i..j]`. We iterate through the string in reverse order, and for each pair of characters, if the characters are equal, we update the `dp[i][j]` value using the `dp[i+1][j-1]`. If they are not equal, we update the `dp[i][j]` using the minimum value between `dp[i+1][j]` and `dp[i][j-1]`, adding 1 to it. In the end, we return the value at `dp[0][n-1]`, which represents the minimum steps required to make the whole string palindrome.\n    "
    },
    {
        "id": 234,
        "title": "Find All The Lonely Nodes",
        "difficulty": "Easy",
        "content": {
            "problem": "In a binary tree, a **lonely** node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.\n\nGiven the `root` of a binary tree, return _an array containing the values of all lonely nodes_ in the tree. Return the list **in any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,null,4\\]\n**Output:** \\[4\\]\n**Explanation:** Light blue node is the only lonely node.\nNode 1 is the root and is not lonely.\nNodes 2 and 3 have the same parent and are not lonely.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[7,1,4,6,null,5,3,null,null,null,null,null,2\\]\n**Output:** \\[6,2\\]\n**Explanation:** Light blue nodes are lonely nodes.\nPlease remember that order doesn't matter, \\[2,6\\] is also an acceptable answer.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[11,99,88,77,null,null,66,55,null,null,44,33,null,null,22\\]\n**Output:** \\[77,55,33,66,44,22\\]\n**Explanation:** Nodes 99 and 88 share the same parent. Node 11 is the root.\nAll other nodes are lonely."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the `tree` is in the range `[1, 1000].`\n*   `1 <= Node.val <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,null,4]",
                "output": "[4]"
            },
            {
                "input": "[7,1,4,6,null,5,3,null,null,null,null,null,2]",
                "output": "[6,2]"
            },
            {
                "input": "[11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]",
                "output": "[77,55,33,66,44,22]"
            }
        ],
        "java": "\n    ```java\npublic int minSteps(String s, String t) {\n    int[] countS = new int[26];\n    int[] countT = new int[26];\n    int steps = 0;\n\n    for (char c : s.toCharArray()) countS[c - 'a']++;\n    for (char c : t.toCharArray()) countT[c - 'a']++;\n\n    for (int i = 0; i < 26; i++) {\n        steps += Math.abs(countS[i] - countT[i]);\n    }\n\n    return steps / 2;\n}\n```\n    \n    1. Initialize two frequency count arrays `countS` and `countT` of size 26 (to represent the English alphabet) and fill it with zeros.\n2. Loop through the string `s` and increment the count of each character in `countS`.\n3. Loop through the string `t` and increment the count of each character in `countT`.\n4. Loop through the frequency arrays from 0 to 25, calculate the absolute difference of the count of each character in `countS` and `countT`, and add the differences to a variable `steps`.\n5. Return half of the `steps` since the question asks for the minimum number of steps to make `t` an anagram of `s`. All differences in characters count are double-accounted when calculating the absolute difference (e.g., one less of a character in `t` also counts as one more of the same character in `s`).\n    ",
        "python": "\n    ```python\ndef min_steps(s, t):\n    count_s = [0] * 26\n    count_t = [0] * 26\n    steps = 0\n    \n    for c in s:\n        count_s[ord(c) - ord('a')] += 1\n    for c in t:\n        count_t[ord(c) - ord('a')] += 1\n    \n    for i in range(26):\n        steps += abs(count_s[i] - count_t[i])\n    \n    return steps // 2\n```\n    \n    1. Initialize two frequency count arrays `countS` and `countT` of size 26 (to represent the English alphabet) and fill it with zeros.\n2. Loop through the string `s` and increment the count of each character in `countS`.\n3. Loop through the string `t` and increment the count of each character in `countT`.\n4. Loop through the frequency arrays from 0 to 25, calculate the absolute difference of the count of each character in `countS` and `countT`, and add the differences to a variable `steps`.\n5. Return half of the `steps` since the question asks for the minimum number of steps to make `t` an anagram of `s`. All differences in characters count are double-accounted when calculating the absolute difference (e.g., one less of a character in `t` also counts as one more of the same character in `s`).\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minSteps(string s, string t) {\n    vector<int> countS(26, 0);\n    vector<int> countT(26, 0);\n    int steps = 0;\n\n    for (char c : s) countS[c - 'a']++;\n    for (char c : t) countT[c - 'a']++;\n\n    for (int i = 0; i < 26; i++) {\n        steps += abs(countS[i] - countT[i]);\n    }\n\n    return steps / 2;\n}\n```\n    \n    1. Initialize two frequency count arrays `countS` and `countT` of size 26 (to represent the English alphabet) and fill it with zeros.\n2. Loop through the string `s` and increment the count of each character in `countS`.\n3. Loop through the string `t` and increment the count of each character in `countT`.\n4. Loop through the frequency arrays from 0 to 25, calculate the absolute difference of the count of each character in `countS` and `countT`, and add the differences to a variable `steps`.\n5. Return half of the `steps` since the question asks for the minimum number of steps to make `t` an anagram of `s`. All differences in characters count are double-accounted when calculating the absolute difference (e.g., one less of a character in `t` also counts as one more of the same character in `s`).\n    ",
        "js": "\n    ```javascript\nfunction minSteps(s, t) {\n    const countS = new Array(26).fill(0);\n    const countT = new Array(26).fill(0);\n    let steps = 0;\n\n    for (let c of s) countS[c.charCodeAt() - 'a'.charCodeAt()]++;\n    for (let c of t) countT[c.charCodeAt() - 'a'.charCodeAt()]++;\n\n    for (let i = 0; i < 26; i++) {\n        steps += Math.abs(countS[i] - countT[i]);\n    }\n\n    return steps / 2;\n}\n```\n    \n    1. Initialize two frequency count arrays `countS` and `countT` of size 26 (to represent the English alphabet) and fill it with zeros.\n2. Loop through the string `s` and increment the count of each character in `countS`.\n3. Loop through the string `t` and increment the count of each character in `countT`.\n4. Loop through the frequency arrays from 0 to 25, calculate the absolute difference of the count of each character in `countS` and `countT`, and add the differences to a variable `steps`.\n5. Return half of the `steps` since the question asks for the minimum number of steps to make `t` an anagram of `s`. All differences in characters count are double-accounted when calculating the absolute difference (e.g., one less of a character in `t` also counts as one more of the same character in `s`).\n    "
    },
    {
        "id": 235,
        "title": "Delete N Nodes After M Nodes of a Linked List",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the `head` of a linked list and two integers `m` and `n`.\n\nTraverse the linked list and remove some nodes in the following way:\n\n*   Start with the head as the current node.\n*   Keep the first `m` nodes starting with the current node.\n*   Remove the next `n` nodes\n*   Keep repeating steps 2 and 3 until you reach the end of the list.\n\nReturn _the head of the modified list after removing the mentioned nodes_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5,6,7,8,9,10,11,12,13\\], m = 2, n = 3\n**Output:** \\[1,2,6,7,11,12\\]\n**Explanation:** Keep the first (m = 2) nodes starting from the head of the linked List  (1 ->2) show in black nodes.\nDelete the next (n = 3) nodes (3 -> 4 -> 5) show in read nodes.\nContinue with the same procedure until reaching the tail of the Linked List.\nHead of the linked list after removing nodes is returned.\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2,3,4,5,6,7,8,9,10,11\\], m = 1, n = 3\n**Output:** \\[1,5,9\\]\n**Explanation:** Head of linked list after removing nodes is returned."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 104]`.\n*   `1 <= Node.val <= 106`\n*   `1 <= m, n <= 1000`\n\n**",
            "follow_up": "Follow up:** Could you solve this problem by modifying the list in-place?"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5,6,7,8,9,10,11,12,13],2,3",
                "output": "[1,2,6,7,11,12]"
            },
            {
                "input": "[1,2,3,4,5,6,7,8,9,10,11],1,3",
                "output": "[1,5,9]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    int maxLen = 0;\n\n    public int longestZigZag(TreeNode root) {\n        longestZigZagUtil(root, true);\n        longestZigZagUtil(root, false);\n        return maxLen;\n    }\n\n    private int longestZigZagUtil(TreeNode root, boolean left) {\n        if (root == null)\n            return -1;\n\n        int leftZig = longestZigZagUtil(root.left, true);\n        int rightZig = longestZigZagUtil(root.right, false);\n\n        maxLen = Math.max(maxLen, Math.max(leftZig, rightZig) + 1);\n        return left ? rightZig + 1 : leftZig + 1;\n    }\n}\n```\n\n    \n    The algorithm is a recursive depth-first search on the binary tree. The `longestZigZagUtil` function is called with two arguments: a tree node, and a boolean value indicating if the zigzag direction is left (`True`) or right (`False`).\n\nFor each recursive call, we calculate the zigzag lengths of the left and right child nodes by calling the utility function with `left` as `True` and `False`, respectively. We update the maximum zigzag length by comparing the current maximum length with the sum of the maximum lengths of the left and right child nodes, plus one.\n\nThe base case is when `root` is `null` (Python: `None`, Java: `null`, JavaScript: `null`), in which case we return -1 as the zigzag length.\n\nFinally, we call the utility function for both left (`True`) and right (`False`) directions to find the maximum length and return it.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef longestZigZag(root: TreeNode) -> int:\n    maxLen = [0]\n    \n    def longestZigZagUtil(root, left):\n        if not root:\n            return -1\n\n        leftZig = longestZigZagUtil(root.left, True)\n        rightZig = longestZigZagUtil(root.right, False)\n\n        maxLen[0] = max(maxLen[0], max(leftZig, rightZig) + 1)\n        return rightZig + 1 if left else leftZig + 1\n\n    longestZigZagUtil(root, True)\n    longestZigZagUtil(root, False)\n    return maxLen[0]\n```\n\n    \n    The algorithm is a recursive depth-first search on the binary tree. The `longestZigZagUtil` function is called with two arguments: a tree node, and a boolean value indicating if the zigzag direction is left (`True`) or right (`False`).\n\nFor each recursive call, we calculate the zigzag lengths of the left and right child nodes by calling the utility function with `left` as `True` and `False`, respectively. We update the maximum zigzag length by comparing the current maximum length with the sum of the maximum lengths of the left and right child nodes, plus one.\n\nThe base case is when `root` is `null` (Python: `None`, Java: `null`, JavaScript: `null`), in which case we return -1 as the zigzag length.\n\nFinally, we call the utility function for both left (`True`) and right (`False`) directions to find the maximum length and return it.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint longestZigZagUtil(TreeNode* root, bool left, int& maxLen) {\n    if (!root)\n        return -1;\n    \n    int leftZig = longestZigZagUtil(root->left, true, maxLen);\n    int rightZig = longestZigZagUtil(root->right, false, maxLen);\n    \n    maxLen = max(maxLen, max(leftZig, rightZig) + 1);\n    return left ? rightZig + 1 : leftZig + 1;\n}\n\nint longestZigZag(TreeNode* root) {\n    int maxLen = 0;\n    longestZigZagUtil(root, true, maxLen);\n    longestZigZagUtil(root, false, maxLen);\n    return maxLen;\n}\n```\n\n    \n    The algorithm is a recursive depth-first search on the binary tree. The `longestZigZagUtil` function is called with two arguments: a tree node, and a boolean value indicating if the zigzag direction is left (`True`) or right (`False`).\n\nFor each recursive call, we calculate the zigzag lengths of the left and right child nodes by calling the utility function with `left` as `True` and `False`, respectively. We update the maximum zigzag length by comparing the current maximum length with the sum of the maximum lengths of the left and right child nodes, plus one.\n\nThe base case is when `root` is `null` (Python: `None`, Java: `null`, JavaScript: `null`), in which case we return -1 as the zigzag length.\n\nFinally, we call the utility function for both left (`True`) and right (`False`) directions to find the maximum length and return it.\n    ",
        "js": "\n    ```javascript\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nvar longestZigZag = function(root) {\n    let maxLen = 0;\n    \n    const longestZigZagUtil = (root, left) => {\n        if (!root)\n            return -1;\n\n        const leftZig = longestZigZagUtil(root.left, true);\n        const rightZig = longestZigZagUtil(root.right, false);\n\n        maxLen = Math.max(maxLen, Math.max(leftZig, rightZig) + 1);\n        return left ? rightZig + 1 : leftZig + 1;\n    }\n\n    longestZigZagUtil(root, true);\n    longestZigZagUtil(root, false);\n    return maxLen;\n};\n```\n\n    \n    The algorithm is a recursive depth-first search on the binary tree. The `longestZigZagUtil` function is called with two arguments: a tree node, and a boolean value indicating if the zigzag direction is left (`True`) or right (`False`).\n\nFor each recursive call, we calculate the zigzag lengths of the left and right child nodes by calling the utility function with `left` as `True` and `False`, respectively. We update the maximum zigzag length by comparing the current maximum length with the sum of the maximum lengths of the left and right child nodes, plus one.\n\nThe base case is when `root` is `null` (Python: `None`, Java: `null`, JavaScript: `null`), in which case we return -1 as the zigzag length.\n\nFinally, we call the utility function for both left (`True`) and right (`False`) directions to find the maximum length and return it.\n    "
    },
    {
        "id": 236,
        "title": "Clone Binary Tree With Random Pointer",
        "difficulty": "Medium",
        "content": {
            "problem": "A binary tree is given such that each node contains an additional random pointer which could point to any node in the tree or null.\n\nReturn a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the tree.\n\nThe tree is represented in the same input/output way as normal binary trees where each node is represented as a pair of `[val, random_index]` where:\n\n*   `val`: an integer representing `Node.val`\n*   `random_index`: the index of the node (in the input) where the random pointer points to, or `null` if it does not point to any node.\n\nYou will be given the tree in class `Node` and you should return the cloned tree in class `NodeCopy`. `NodeCopy` class is just a clone of `Node` class with the same attributes and constructors.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[\\[1,null\\],null,\\[4,3\\],\\[7,0\\]\\]\n**Output:** \\[\\[1,null\\],null,\\[4,3\\],\\[7,0\\]\\]\n**Explanation:** The original binary tree is \\[1,null,4,7\\].\nThe random pointer of node one is null, so it is represented as \\[1, null\\].\nThe random pointer of node 4 is node 7, so it is represented as \\[4, 3\\] where 3 is the index of node 7 in the array representing the tree.\nThe random pointer of node 7 is node 1, so it is represented as \\[7, 0\\] where 0 is the index of node 1 in the array representing the tree.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\[1,4\\],null,\\[1,0\\],null,\\[1,5\\],\\[1,5\\]\\]\n**Output:** \\[\\[1,4\\],null,\\[1,0\\],null,\\[1,5\\],\\[1,5\\]\\]\n**Explanation:** The random pointer of a node can be the node itself.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[\\[1,6\\],\\[2,5\\],\\[3,4\\],\\[4,3\\],\\[5,2\\],\\[6,1\\],\\[7,0\\]\\]\n**Output:** \\[\\[1,6\\],\\[2,5\\],\\[3,4\\],\\[4,3\\],\\[5,2\\],\\[6,1\\],\\[7,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the `tree` is in the range `[0, 1000].`\n*   `1 <= Node.val <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,null],null,[4,3],[7,0]]",
                "output": "[[1,null],null,[4,3],[7,0]]"
            },
            {
                "input": "[[1,4],null,[1,0],null,[1,5],[1,5]]",
                "output": "[[1,4],null,[1,0],null,[1,5],[1,5]]"
            },
            {
                "input": "[[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]",
                "output": "[[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic int minCost(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][] cost = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            cost[i][j] = 1_000_000;\n        }\n    }\n    Queue<int[]> q = new LinkedList<>();\n    dfs(grid, cost, q, 0, 0, 0);\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!q.isEmpty()) {\n        int[] pos = q.poll();\n        int r = pos[0], c = pos[1];\n        for (int i = 0; i < 4; i++) {\n            int nr = r + directions[i][0], nc = c + directions[i][1];\n            dfs(grid, cost, q, nr, nc, cost[r][c] + (grid[r][c] == i + 1 ? 0 : 1));\n        }\n    }\n    \n    return cost[m - 1][n - 1];\n}\n\nvoid dfs(int[][] grid, int[][] cost, Queue<int[]> q, int r, int c, int d) {\n    int m = grid.length, n = grid[0].length;\n    if (r >= 0 && r < m && c >= 0 && c < n && d < cost[r][c]) {\n        cost[r][c] = d;\n        q.add(new int[]{r, c});\n    }\n}\n```\n    \n    The algorithm is to use a Depth-First Search on the grid, only updating the cost when it finds a lower-cost path. The search starts at (0, 0) and follows the directions in the grid while prioritizing modifying the signs as little as possible.\n\nThe cost of each cell in the grid is initially set to a large value. A queue is used to iteratively apply the DFS procedure. A cell is checked if it is within the boundaries of the grid and if the distance to it is less than the currently stored cost, then update the cost of the cell and push the cell coordinates onto the queue.\n\nFor each dequeued cell, iterate over all four directions, calculate the new cell coordinates according to the direction, check if the grid value matches the current direction (+1 because 1-indexed). If it does not match, increase the cost by 1. Call the DFS procedure with the new cell's row, column, and the cost.\n\nOnce the DFS procedure has been applied to all cells, the minimum cost of reaching the bottom-right cell is stored in `cost[m - 1][n - 1]`.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef minCost(grid):\n    def dfs(r, c, d):\n        if 0 <= r < m and 0 <= c < n and d < cost[r][c]:\n            cost[r][c] = d\n            q.append((r, c))\n\n    m, n = len(grid), len(grid[0])\n    cost = [[1e6] * n for _ in range(m)]\n\n    q = deque()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    dfs(0, 0, 0)\n\n    while q:\n        r, c = q.popleft()\n        for i, (dr, dc) in enumerate(directions):\n            dfs(r + dr, c + dc, cost[r][c] + (grid[r][c] != i + 1))\n\n    return cost[-1][-1]\n```\n    \n    The algorithm is to use a Depth-First Search on the grid, only updating the cost when it finds a lower-cost path. The search starts at (0, 0) and follows the directions in the grid while prioritizing modifying the signs as little as possible.\n\nThe cost of each cell in the grid is initially set to a large value. A queue is used to iteratively apply the DFS procedure. A cell is checked if it is within the boundaries of the grid and if the distance to it is less than the currently stored cost, then update the cost of the cell and push the cell coordinates onto the queue.\n\nFor each dequeued cell, iterate over all four directions, calculate the new cell coordinates according to the direction, check if the grid value matches the current direction (+1 because 1-indexed). If it does not match, increase the cost by 1. Call the DFS procedure with the new cell's row, column, and the cost.\n\nOnce the DFS procedure has been applied to all cells, the minimum cost of reaching the bottom-right cell is stored in `cost[m - 1][n - 1]`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nint minCost(std::vector<std::vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    std::vector<std::vector<int>> cost(m, std::vector<int>(n, 1e6));\n    std::queue<std::pair<int, int>> q;\n\n    auto dfs = [&](int r, int c, int d) {\n        if (r >= 0 && c >= 0 && r < m && c < n && (d < cost[r][c])) {\n            cost[r][c] = d;\n            q.push({r, c});\n        }\n    };\n\n    dfs(0, 0, 0);\n    const std::vector<std::pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!q.empty()) {\n        int r = q.front().first;\n        int c = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nr = r + directions[i].first;\n            int nc = c + directions[i].second;\n            dfs(nr, nc, cost[r][c] + (grid[r][c] != i + 1));\n        }\n    }\n    return cost.back().back();\n}\n```\n    \n    The algorithm is to use a Depth-First Search on the grid, only updating the cost when it finds a lower-cost path. The search starts at (0, 0) and follows the directions in the grid while prioritizing modifying the signs as little as possible.\n\nThe cost of each cell in the grid is initially set to a large value. A queue is used to iteratively apply the DFS procedure. A cell is checked if it is within the boundaries of the grid and if the distance to it is less than the currently stored cost, then update the cost of the cell and push the cell coordinates onto the queue.\n\nFor each dequeued cell, iterate over all four directions, calculate the new cell coordinates according to the direction, check if the grid value matches the current direction (+1 because 1-indexed). If it does not match, increase the cost by 1. Call the DFS procedure with the new cell's row, column, and the cost.\n\nOnce the DFS procedure has been applied to all cells, the minimum cost of reaching the bottom-right cell is stored in `cost[m - 1][n - 1]`.\n    ",
        "js": "\n    ```javascript\nfunction minCost(grid) {\n    function dfs(r, c, d) {\n        if (r >= 0 && c >= 0 && r < m && c < n && d < cost[r][c]) {\n            cost[r][c] = d;\n            q.push([r, c]);\n        }\n    }\n\n    const m = grid.length;\n    const n = grid[0].length;\n    const cost = Array.from({length: m}, () => new Array(n).fill(1e6));\n    const q = [];\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n\n    dfs(0, 0, 0);\n\n    while (q.length) {\n        const [r, c] = q.shift();\n        for (let i = 0; i < 4; i++) {\n            const nr = r + directions[i][0];\n            const nc = c + directions[i][1];\n            dfs(nr, nc, cost[r][c] + (grid[r][c] !== i + 1));\n        }\n    }\n    \n    return cost[m - 1][n - 1];\n}\n```\n    \n    The algorithm is to use a Depth-First Search on the grid, only updating the cost when it finds a lower-cost path. The search starts at (0, 0) and follows the directions in the grid while prioritizing modifying the signs as little as possible.\n\nThe cost of each cell in the grid is initially set to a large value. A queue is used to iteratively apply the DFS procedure. A cell is checked if it is within the boundaries of the grid and if the distance to it is less than the currently stored cost, then update the cost of the cell and push the cell coordinates onto the queue.\n\nFor each dequeued cell, iterate over all four directions, calculate the new cell coordinates according to the direction, check if the grid value matches the current direction (+1 because 1-indexed). If it does not match, increase the cost by 1. Call the DFS procedure with the new cell's row, column, and the cost.\n\nOnce the DFS procedure has been applied to all cells, the minimum cost of reaching the bottom-right cell is stored in `cost[m - 1][n - 1]`.\n    "
    },
    {
        "id": 237,
        "title": "Clone N-ary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `root` of an N-ary tree, return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the tree.\n\nEach node in the n-ary tree contains a val (`int`) and a list (`List[Node]`) of its children.\n\nclass Node {\n    public int val;\n    public List children;\n}\n\n_Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples)._",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** \\[1,null,3,2,4,null,5,6\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The depth of the n-ary tree is less than or equal to `1000`.\n*   The total number of nodes is between `[0, 104]`.\n\n**",
            "follow_up": "Follow up:** Can your solution work for the [graph problem](https://leetcode.com/problems/clone-graph/)?"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "[1,null,3,2,4,null,5,6]"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    public String generateTheString(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n - 1; i++) {\n            sb.append('a');\n        }\n        if (n % 2 == 0) {\n            sb.append('b');\n        } else {\n            sb.append('a');\n        }\n        return sb.toString();\n    }\n}\n```\n    \n    The algorithm constructs a string with 'n' characters, making sure that the count of every character is odd. \n\nHere is a simple approach:\n1. We start by adding 'n' times the character 'a' to the string.\n2. If 'n' is odd, then the string already satisfies the condition, and we return it.\n3. If 'n' is even, we change the last character of the string to 'b'. Now, the string has 'n - 1' occurrences of 'a' (which is odd) and 1 occurrence of 'b' (also odd), and then we return the string.\n4. With this approach, at most, two different characters are used, and both their counts are odd, satisfying the problem conditions. \n\nThus, we have a valid solution with a time complexity of O(n) for string construction, and it's possible to return any of the multiple valid strings.\n    ",
        "python": "\n    ```python\ndef generate_the_string(n: int) -> str:\n    if n % 2 == 0:\n        return 'a' * (n - 1) + 'b'\n    else:\n        return 'a' * n\n```\n    \n    The algorithm constructs a string with 'n' characters, making sure that the count of every character is odd. \n\nHere is a simple approach:\n1. We start by adding 'n' times the character 'a' to the string.\n2. If 'n' is odd, then the string already satisfies the condition, and we return it.\n3. If 'n' is even, we change the last character of the string to 'b'. Now, the string has 'n - 1' occurrences of 'a' (which is odd) and 1 occurrence of 'b' (also odd), and then we return the string.\n4. With this approach, at most, two different characters are used, and both their counts are odd, satisfying the problem conditions. \n\nThus, we have a valid solution with a time complexity of O(n) for string construction, and it's possible to return any of the multiple valid strings.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string generateTheString(int n) {\n    std::string result(n, 'a');\n    if (n % 2 == 0) {\n        result[n - 1] = 'b';\n    }\n    return result;\n}\n```\n    \n    The algorithm constructs a string with 'n' characters, making sure that the count of every character is odd. \n\nHere is a simple approach:\n1. We start by adding 'n' times the character 'a' to the string.\n2. If 'n' is odd, then the string already satisfies the condition, and we return it.\n3. If 'n' is even, we change the last character of the string to 'b'. Now, the string has 'n - 1' occurrences of 'a' (which is odd) and 1 occurrence of 'b' (also odd), and then we return the string.\n4. With this approach, at most, two different characters are used, and both their counts are odd, satisfying the problem conditions. \n\nThus, we have a valid solution with a time complexity of O(n) for string construction, and it's possible to return any of the multiple valid strings.\n    ",
        "js": "\n    ```javascript\nfunction generateTheString(n) {\n    let result = \"\";\n    for (let i = 0; i < n - 1; i++) {\n        result += 'a';\n    }\n    if (n % 2 === 0) {\n        result += 'b';\n    } else {\n        result += 'a';\n    }\n    return result;\n}\n```\n    \n    The algorithm constructs a string with 'n' characters, making sure that the count of every character is odd. \n\nHere is a simple approach:\n1. We start by adding 'n' times the character 'a' to the string.\n2. If 'n' is odd, then the string already satisfies the condition, and we return it.\n3. If 'n' is even, we change the last character of the string to 'b'. Now, the string has 'n - 1' occurrences of 'a' (which is odd) and 1 occurrence of 'b' (also odd), and then we return the string.\n4. With this approach, at most, two different characters are used, and both their counts are odd, satisfying the problem conditions. \n\nThus, we have a valid solution with a time complexity of O(n) for string construction, and it's possible to return any of the multiple valid strings.\n    "
    },
    {
        "id": 238,
        "title": "Longest Subarray of 1's After Deleting One Element",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a binary array `nums`, you should delete one element from it.\n\nReturn _the size of the longest non-empty subarray containing only_ `1`_'s in the resulting array_. Return `0` if there is no such subarray.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,0,1\\]\n**Output:** 3\n**Explanation:** After deleting the number in position 2, \\[1,1,1\\] contains 3 numbers with value of 1's.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,1,1,0,1,1,0,1\\]\n**Output:** 5\n**Explanation:** After deleting the number in position 4, \\[0,1,1,1,1,1,0,1\\] longest subarray with value of 1's is \\[1,1,1,1,1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** You must delete one element."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,1,0,1]",
                "output": "3"
            },
            {
                "input": "[0,1,1,1,0,1,1,0,1]",
                "output": "5"
            },
            {
                "input": "[1,1,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic double frogPosition(int n, int[][] edges, int t, int target) {\n    List<Integer>[] graph = new ArrayList[n + 1];\n    for (int i = 0; i <= n; i++) {\n        graph[i] = new ArrayList<>();\n    }\n    for (int[] edge : edges) {\n        graph[edge[0]].add(edge[1]);\n        graph[edge[1]].add(edge[0]);\n    }\n    return dfs(1, -1, t, target, graph);\n}\n\nprivate double dfs(int node, int parent, int t, int target, List<Integer>[] graph) {\n    if (t == 0) {\n        return node == target ? 1.0 : 0.0;\n    }\n    double probability = 0.0;\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            probability += dfs(neighbor, node, t - 1, target, graph);\n        }\n    }\n    return probability / (graph[node].size() - (parent == -1 ? 0 : 1));\n}\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return dfs(1, -1, t, target, graph)\n\ndef dfs(node, parent, t, target, graph):\n    if t == 0:\n        return 1.0 if node == target else 0.0\n    probability = 0.0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            probability += dfs(neighbor, node, t - 1, target, graph)\n    return probability / (len(graph[node]) - (0 if parent == -1 else 1))\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\ndouble dfs(int node, int parent, int t, int target, vector<vector<int>>& graph) {\n    if (t == 0) {\n        return node == target ? 1.0 : 0.0;\n    }\n    double probability = 0.0;\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            probability += dfs(neighbor, node, t - 1, target, graph);\n        }\n    }\n    return probability / (graph[node].size() - (parent == -1 ? 0 : 1));\n}\n\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n    vector<vector<int>> graph(n + 1);\n    for (vector<int>& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    return dfs(1, -1, t, target, graph);\n}\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    ",
        "js": "\n    ```javascript\nfunction frogPosition(n, edges, t, target) {\n    const graph = Array.from({ length: n + 1 }, () => []);\n    for (const edge of edges) {\n        graph[edge[0]].push(edge[1]);\n        graph[edge[1]].push(edge[0]);\n    }\n    return dfs(1, -1, t, target, graph);\n}\n\nfunction dfs(node, parent, t, target, graph) {\n    if (t === 0) {\n        return node === target ? 1.0 : 0.0;\n    }\n    let probability = 0.0;\n    for (const neighbor of graph[node]) {\n        if (neighbor !== parent) {\n            probability += dfs(neighbor, node, t - 1, target, graph);\n        }\n    }\n    return probability / (graph[node].length - (parent === -1 ? 0 : 1));\n}\n```\n\n    \n    The algorithm can be solved using Depth-First Search. To set up the environment, we first create an adjacency list called `graph` to represent the tree. We then perform the DFS from the first vertex, passing the parent, remaining time, target vertex, and graph as arguments.\n\nInside the helper function `dfs`, we have a base case when there are no more remaining seconds. In that case, we return 1.0 if the current node matches the target, otherwise, we return 0.0.\n\nNext, we traverse the neighbors of the current node, skipping the parent node to avoid cycles. We perform DFS for each neighbor, subtracting one from the remaining time. As we recurse back, we accumulate the probability from each DFS call and divide it by the number of neighbors minus one (the parent). This correctly calculates the probability of reaching the target vertex after a certain period of time.\n\nFinally, we return the probability from the DFS call.\n    "
    },
    {
        "id": 239,
        "title": "Design a File Sharing System",
        "difficulty": "Medium",
        "content": {
            "problem": "We will use a file-sharing system to share a very large file which consists of `m` small **chunks** with IDs from `1` to `m`.\n\nWhen users join the system, the system should assign **a unique** ID to them. The unique ID should be used **once** for each user, but when a user leaves the system, the ID can be **reused** again.\n\nUsers can request a certain chunk of the file, the system should return a list of IDs of all the users who own this chunk. If the user receives a non-empty list of IDs, they receive the requested chunk successfully.\n\n  \nImplement the `FileSharing` class:\n\n*   `FileSharing(int m)` Initializes the object with a file of `m` chunks.\n*   `int join(int[] ownedChunks)`: A new user joined the system owning some chunks of the file, the system should assign an id to the user which is the **smallest positive integer** not taken by any other user. Return the assigned id.\n*   `void leave(int userID)`: The user with `userID` will leave the system, you cannot take file chunks from them anymore.\n*   `int[] request(int userID, int chunkID)`: The user `userID` requested the file chunk with `chunkID`. Return a list of the IDs of all users that own this chunk sorted in ascending order.",
            "examples": [
                "**Example:**\n\n**Input:**\n\\[ \"FileSharing \", \"join \", \"join \", \"join \", \"request \", \"request \", \"leave \", \"request \", \"leave \", \"join \"\\]\n\\[\\[4\\],\\[\\[1,2\\]\\],\\[\\[2,3\\]\\],\\[\\[4\\]\\],\\[1,3\\],\\[2,2\\],\\[1\\],\\[2,1\\],\\[2\\],\\[\\[\\]\\]\\]\n**Output:**\n\\[null,1,2,3,\\[2\\],\\[1,2\\],null,\\[\\],null,1\\]\n**Explanation:**\nFileSharing fileSharing = new FileSharing(4); // We use the system to share a file of 4 chunks.\n\nfileSharing.join(\\[1, 2\\]);    // A user who has chunks \\[1,2\\] joined the system, assign id = 1 to them and return 1.\n\nfileSharing.join(\\[2, 3\\]);    // A user who has chunks \\[2,3\\] joined the system, assign id = 2 to them and return 2.\n\nfileSharing.join(\\[4\\]);       // A user who has chunk \\[4\\] joined the system, assign id = 3 to them and return 3.\n\nfileSharing.request(1, 3);   // The user with id = 1 requested the third file chunk, as only the user with id = 2 has the file, return \\[2\\] . Notice that user 1 now has chunks \\[1,2,3\\].\n\nfileSharing.request(2, 2);   // The user with id = 2 requested the second file chunk, users with ids \\[1,2\\] have this chunk, thus we return \\[1,2\\].\n\nfileSharing.leave(1);        // The user with id = 1 left the system, all the file chunks with them are no longer available for other users.\n\nfileSharing.request(2, 1);   // The user with id = 2 requested the first file chunk, no one in the system has this chunk, we return empty list \\[\\].\n\nfileSharing.leave(2);        // The user with id = 2 left the system.\n\nfileSharing.join(\\[\\]);        // A user who doesn't have any chunks joined the system, assign id = 1 to them and return 1. Notice that ids 1 and 2 are free and we can reuse them."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m <= 105`\n*   `0 <= ownedChunks.length <= min(100, m)`\n*   `1 <= ownedChunks[i] <= m`\n*   Values of `ownedChunks` are unique.\n*   `1 <= chunkID <= m`\n*   `userID` is guaranteed to be a user in the system if you **assign** the IDs **correctly**.\n*   At most `104` calls will be made to `join`, `leave` and `request`.\n*   Each call to `leave` will have a matching call for `join`.\n\n**",
            "follow_up": "Follow-up:**\n\n*   What happens if the system identifies the user by their IP address instead of their unique ID and users disconnect and connect from the system with the same IP?\n*   If the users in the system join and leave the system frequently without requesting any chunks, will your solution still be efficient?\n*   If all users join the system one time, request all files, and then leave, will your solution still be efficient?\n*   If the system will be used to share `n` files where the `ith` file consists of `m[i]`, what are the changes you have to make?"
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],]],[]],[]],[1,3],[2,2],[1],[2,1],[2],[]]]",
                "output": "\n[null,1,2,3,[2],[1,2],null,[],null,1]"
            }
        ],
        "java": "\n    ```java\npublic int countLargestGroup(int n) {\n    int[] freq = new int[37];\n    int maxGroupSize = 0, maxGroupCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int sum = 0, num = i;\n        while (num != 0) {\n            sum += num % 10;\n            num = num / 10;\n        }\n        freq[sum]++;\n        maxGroupSize = Math.max(maxGroupSize, freq[sum]);\n    }\n\n    for (int i = 0; i < 37; i++) {\n        if (freq[i] == maxGroupSize) {\n            maxGroupCount++;\n        }\n    }\n\n    return maxGroupCount;\n}\n```\n\n    \n    We create an array `freq` to store the frequency of the sizes of the groups. Iterate through numbers 1 to `n` and calculate the sum of the digits of each number. Use this sum as an index to increment the frequency count in the array. At each step, we also update the maximum group size.\n\nAfter that, we iterate through the frequency array and count the number of groups that have the maximum group size.\n\nFinally, return the count of the largest groups.\n    ",
        "python": "\n    ```python\ndef countLargestGroup(n: int) -> int:\n    freq = [0] * 37\n    max_group_size = 0\n    max_group_count = 0\n    \n    for i in range(1, n + 1):\n        _sum = sum(map(int, str(i)))\n        freq[_sum] += 1\n        max_group_size = max(max_group_size, freq[_sum])\n    \n    for count in freq:\n        if count == max_group_size:\n            max_group_count += 1\n\n    return max_group_count\n```\n\n    \n    We create an array `freq` to store the frequency of the sizes of the groups. Iterate through numbers 1 to `n` and calculate the sum of the digits of each number. Use this sum as an index to increment the frequency count in the array. At each step, we also update the maximum group size.\n\nAfter that, we iterate through the frequency array and count the number of groups that have the maximum group size.\n\nFinally, return the count of the largest groups.\n    ",
        "c++": "\n    ```cpp\n#include <iostream>\nusing namespace std;\n\nint countLargestGroup(int n) {\n    int freq[37] = {0}, maxGroupSize = 0, maxGroupCount = 0;\n    \n    for(int i = 1; i <= n; i++) {\n        int sum = 0, num = i;\n        while(num) {\n            sum += num % 10;\n            num /= 10;\n        }\n        freq[sum]++;\n        maxGroupSize = max(maxGroupSize, freq[sum]);\n    }\n\n    for(int i = 0; i < 37; i++)\n        if(freq[i] == maxGroupSize)\n            maxGroupCount++;\n    \n    return maxGroupCount;\n}\n```\n\n    \n    We create an array `freq` to store the frequency of the sizes of the groups. Iterate through numbers 1 to `n` and calculate the sum of the digits of each number. Use this sum as an index to increment the frequency count in the array. At each step, we also update the maximum group size.\n\nAfter that, we iterate through the frequency array and count the number of groups that have the maximum group size.\n\nFinally, return the count of the largest groups.\n    ",
        "js": "\n    ```javascript\nfunction countLargestGroup(n) {\n    let freq = new Array(37).fill(0);\n    let maxGroupSize = 0, maxGroupCount = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        let sum = 0, num = i;\n        while (num !== 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        freq[sum]++;\n        maxGroupSize = Math.max(maxGroupSize, freq[sum]);\n    }\n\n    for (let i = 0; i < 37; i++) {\n        if (freq[i] === maxGroupSize) {\n            maxGroupCount++;\n        }\n    }\n    \n    return maxGroupCount;\n}\n```\n\n    \n    We create an array `freq` to store the frequency of the sizes of the groups. Iterate through numbers 1 to `n` and calculate the sum of the digits of each number. Use this sum as an index to increment the frequency count in the array. At each step, we also update the maximum group size.\n\nAfter that, we iterate through the frequency array and count the number of groups that have the maximum group size.\n\nFinally, return the count of the largest groups.\n    "
    },
    {
        "id": 240,
        "title": "Find Root of N-Ary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given all the nodes of an **[N-ary tree](https://leetcode.com/explore/learn/card/n-ary-tree/)** as an array of `Node` objects, where each node has a **unique value**.\n\nReturn _the **root** of the N-ary tree_.\n\n**Custom testing:**\n\nAn N-ary tree can be serialized as represented in its level order traversal where each group of children is separated by the `null` value (see examples).\n\nFor example, the above tree is serialized as `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.\n\nThe testing will be done in the following way:\n\n1.  The **input data** should be provided as a serialization of the tree.\n2.  The driver code will construct the tree from the serialized input data and put each `Node` object into an array **in an arbitrary order**.\n3.  The driver code will pass the array to `findRoot`, and your function should find and return the root `Node` object in the array.\n4.  The driver code will take the returned `Node` object and serialize it. If the serialized value and the input data are the **same**, the test **passes**.",
            "examples": [
                "**Example 1:**\n\n**Input:** tree = \\[1,null,3,2,4,null,5,6\\]\n**Output:** \\[1,null,3,2,4,null,5,6\\]\n**Explanation:** The tree from the input data is shown above.\nThe driver code creates the tree and gives findRoot the Node objects in an arbitrary order.\nFor example, the passed array could be \\[Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)\\] or \\[Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)\\].\nThe findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data.\nThe input data and serialized Node(1) are the same, so the test passes.\n\n",
                "**Example 2:**\n\n**Input:** tree = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The total number of nodes is between `[1, 5 * 104]`.\n*   Each node has a **unique** value.\n\n**",
            "follow_up": "Follow up:**\n\n*   Could you solve this problem in constant space complexity with a linear time algorithm?"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "[1,null,3,2,4,null,5,6]"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public Node findRoot(List<Node> nodes) {\n        int valueSum = 0;\n        \n        for (Node node : nodes) {\n            valueSum += node.val;\n            \n            for (Node child : node.children) {\n                valueSum -= child.val;\n            }\n        }\n        \n        for (Node node : nodes) {\n            if (node.val == valueSum) {\n                return node;\n            }\n        }\n        \n        return null;\n    }\n}\n```\n\n    \n    The solution iterates over all the nodes twice. In the first iteration, the sum of the node values is calculated, and for each child node, its value is subtracted from the sum. This will result in the root value being stored in the `value_sum`. In the second iteration, we simply iterated over the nodes to find the node with the `value_sum` and return it as a root node.\n\nThis solution has a linear time complexity O(n), and the space complexity is constant as no extra data structure is being used.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def findRoot(self, nodes: List['Node']) -> 'Node':\n        value_sum = 0\n        \n        for node in nodes:\n            value_sum += node.val\n            \n            for child in node.children:\n                value_sum -= child.val\n        \n        for node in nodes:\n            if node.val == value_sum:\n                return node\n                \n        return None\n```\n\n    \n    The solution iterates over all the nodes twice. In the first iteration, the sum of the node values is calculated, and for each child node, its value is subtracted from the sum. This will result in the root value being stored in the `value_sum`. In the second iteration, we simply iterated over the nodes to find the node with the `value_sum` and return it as a root node.\n\nThis solution has a linear time complexity O(n), and the space complexity is constant as no extra data structure is being used.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\npublic:\n    Node* findRoot(vector<Node*> nodes) {\n        int value_sum = 0;\n        \n        for (auto& node : nodes) {\n            value_sum += node->val;\n            \n            for (auto& child : node->children) {\n                value_sum -= child->val;\n            }\n        }\n        \n        for (auto& node : nodes) {\n            if (node->val == value_sum) {\n                return node;\n            }\n        }\n        \n        return nullptr;\n    }\n};\n```\n\n    \n    The solution iterates over all the nodes twice. In the first iteration, the sum of the node values is calculated, and for each child node, its value is subtracted from the sum. This will result in the root value being stored in the `value_sum`. In the second iteration, we simply iterated over the nodes to find the node with the `value_sum` and return it as a root node.\n\nThis solution has a linear time complexity O(n), and the space complexity is constant as no extra data structure is being used.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    findRoot(nodes) {\n        let valueSum = 0;\n        \n        for (let node of nodes) {\n            valueSum += node.val;\n\n            for (let child of node.children) {\n                valueSum -= child.val;\n            }\n        }\n\n        for (let node of nodes) {\n            if (node.val === valueSum) {\n                return node;\n            }\n        }\n        \n        return null;\n    }\n}\n```\n\n    \n    The solution iterates over all the nodes twice. In the first iteration, the sum of the node values is calculated, and for each child node, its value is subtracted from the sum. This will result in the root value being stored in the `value_sum`. In the second iteration, we simply iterated over the nodes to find the node with the `value_sum` and return it as a root node.\n\nThis solution has a linear time complexity O(n), and the space complexity is constant as no extra data structure is being used.\n    "
    },
    {
        "id": 241,
        "title": "Move Sub-Tree of N-Ary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the `root` of an N-ary tree of unique values, and two nodes of the tree `p` and `q`.\n\nYou should move the subtree of the node `p` to become a direct child of node `q`. If `p` is already a direct child of `q`, do not change anything. Node `p` **must be** the last child in the children list of node `q`.\n\nReturn _the root of the tree_ after adjusting it.\n\nThere are 3 cases for nodes `p` and `q`:\n\n1.  Node `q` is in the sub-tree of node `p`.\n2.  Node `p` is in the sub-tree of node `q`.\n3.  Neither node `p` is in the sub-tree of node `q` nor node `q` is in the sub-tree of node `p`.\n\nIn cases 2 and 3, you just need to move `p` (with its sub-tree) to be a child of `q`, but in case 1 the tree may be disconnected, thus you need to reconnect the tree again. **Please read the examples carefully before solving this problem.**\n\n_Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples)._\n\nFor example, the above tree is serialized as `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,3,null,4,5,null,6,null,7,8\\], p = 4, q = 1\n**Output:** \\[1,null,2,3,4,null,5,null,6,null,7,8\\]\n**Explanation:** This example follows the second case as node p is in the sub-tree of node q. We move node p with its sub-tree to be a direct child of node q.\nNotice that node 4 is the last child of node 1.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,3,null,4,5,null,6,null,7,8\\], p = 7, q = 4\n**Output:** \\[1,null,2,3,null,4,5,null,6,null,7,8\\]\n**Explanation:** Node 7 is already a direct child of node 4. We don't change anything.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,null,2,3,null,4,5,null,6,null,7,8\\], p = 3, q = 8\n**Output:** \\[1,null,2,null,4,5,null,7,8,null,null,null,3,null,6\\]\n**Explanation:** This example follows case 3 because node p is not in the sub-tree of node q and vice-versa. We can move node 3 with its sub-tree and make it as node 8's child."
            ],
            "constraints": "**Constraints:**\n\n*   The total number of nodes is between `[2, 1000]`.\n*   Each node has a **unique** value.\n*   `p != null`\n*   `q != null`\n*   `p` and `q` are two different nodes (i.e. `p != q`).",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,2,3,null,4,5,null,6,null,7,8],4,1",
                "output": "[1,null,2,3,4,null,5,null,6,null,7,8]"
            },
            {
                "input": "[1,null,2,3,null,4,5,null,6,null,7,8],7,4",
                "output": "[1,null,2,3,null,4,5,null,6,null,7,8]"
            },
            {
                "input": "[1,null,2,3,null,4,5,null,6,null,7,8],3,8",
                "output": "[1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic String getHappyString(int n, int k) {\n    List<String> happyStrings = new ArrayList<>();\n    dfs(happyStrings, n, \"\", ' ');\n    return k <= happyStrings.size() ? happyStrings.get(k - 1) : \"\";\n}\n\nprivate void dfs(List<String> happyStrings, int n, String s, char prev) {\n    if (s.length() == n) {\n        happyStrings.add(s);\n        return;\n    }\n    for (char c = 'a'; c <= 'c'; c++) {\n        if (c != prev) {\n            dfs(happyStrings, n, s + c, c);\n        }\n    }\n}\n```\n    \n    The algorithm is a depth-first search approach to generate all happy strings of length n. Since the maximum length of n is 10, and we only need to iterate through 3 characters each time, the solution's complexity is acceptable. \n\nWe start with an empty string and a space as the previous character. The DFS function checks if the given string has reached the length n. If it has, we add the string to our list of happy strings and return.\n\nIf the string has not reached length n, we iterate through the characters 'a', 'b', and 'c'. If the current character is not equal to the previous character, we call the DFS function with the updated string and the current character as the new previous character. This ensures that we construct happy strings by never including consecutive same characters.\n\nAfter the DFS function is done traversing all possible happy strings, we check if k is less than or equal to the length of our happy string list. If it is, we return the kth element (k - 1 due to zero-based indexing). Otherwise, we return an empty string since there are fewer than k happy strings of length n.\n    ",
        "python": "\n    ```python\ndef get_happy_string(n, k):\n    def dfs(s, prev):\n        if len(s) == n:\n            happy_strings.append(s)\n            return\n        for c in 'abc':\n            if c != prev:\n                dfs(s + c, c)\n\n    happy_strings = []\n    dfs(\"\", ' ')\n    return happy_strings[k - 1] if k <= len(happy_strings) else \"\"\n```\n    \n    The algorithm is a depth-first search approach to generate all happy strings of length n. Since the maximum length of n is 10, and we only need to iterate through 3 characters each time, the solution's complexity is acceptable. \n\nWe start with an empty string and a space as the previous character. The DFS function checks if the given string has reached the length n. If it has, we add the string to our list of happy strings and return.\n\nIf the string has not reached length n, we iterate through the characters 'a', 'b', and 'c'. If the current character is not equal to the previous character, we call the DFS function with the updated string and the current character as the new previous character. This ensures that we construct happy strings by never including consecutive same characters.\n\nAfter the DFS function is done traversing all possible happy strings, we check if k is less than or equal to the length of our happy string list. If it is, we return the kth element (k - 1 due to zero-based indexing). Otherwise, we return an empty string since there are fewer than k happy strings of length n.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string getHappyString(int n, int k) {\n    std::vector<std::string> happyStrings;\n    std::function<void(std::string, char)> dfs = [&](std::string s, char prev) {\n        if (s.length() == n) {\n            happyStrings.push_back(s);\n            return;\n        }\n        for (char c = 'a'; c <= 'c'; c++) {\n            if (c != prev) {\n                dfs(s + c, c);\n            }\n        }\n    };\n    dfs(\"\", ' ');\n    return k <= happyStrings.size() ? happyStrings[k - 1] : \"\";\n}\n```\n    \n    The algorithm is a depth-first search approach to generate all happy strings of length n. Since the maximum length of n is 10, and we only need to iterate through 3 characters each time, the solution's complexity is acceptable. \n\nWe start with an empty string and a space as the previous character. The DFS function checks if the given string has reached the length n. If it has, we add the string to our list of happy strings and return.\n\nIf the string has not reached length n, we iterate through the characters 'a', 'b', and 'c'. If the current character is not equal to the previous character, we call the DFS function with the updated string and the current character as the new previous character. This ensures that we construct happy strings by never including consecutive same characters.\n\nAfter the DFS function is done traversing all possible happy strings, we check if k is less than or equal to the length of our happy string list. If it is, we return the kth element (k - 1 due to zero-based indexing). Otherwise, we return an empty string since there are fewer than k happy strings of length n.\n    ",
        "js": "\n    ```javascript\nfunction getHappyString(n, k) {\n    const happyStrings = [];\n    const dfs = (s, prev) => {\n        if (s.length === n) {\n            happyStrings.push(s);\n            return;\n        }\n        for (let c = 'a'.charCodeAt(); c <= 'c'.charCodeAt(); c++) {\n            const char = String.fromCharCode(c);\n            if (char !== prev) {\n                dfs(s + char, char);\n            }\n        }\n    };\n    dfs('', ' ');\n    return k <= happyStrings.length ? happyStrings[k - 1] : \"\";\n}\n```\n    \n    The algorithm is a depth-first search approach to generate all happy strings of length n. Since the maximum length of n is 10, and we only need to iterate through 3 characters each time, the solution's complexity is acceptable. \n\nWe start with an empty string and a space as the previous character. The DFS function checks if the given string has reached the length n. If it has, we add the string to our list of happy strings and return.\n\nIf the string has not reached length n, we iterate through the characters 'a', 'b', and 'c'. If the current character is not equal to the previous character, we call the DFS function with the updated string and the current character as the new previous character. This ensures that we construct happy strings by never including consecutive same characters.\n\nAfter the DFS function is done traversing all possible happy strings, we check if k is less than or equal to the length of our happy string list. If it is, we return the kth element (k - 1 due to zero-based indexing). Otherwise, we return an empty string since there are fewer than k happy strings of length n.\n    "
    },
    {
        "id": 242,
        "title": "Diameter of N-Ary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `root` of an [N-ary tree](https://leetcode.com/articles/introduction-to-n-ary-trees/), you need to compute the length of the diameter of the tree.\n\nThe diameter of an N-ary tree is the length of the **longest** path between any two nodes in the tree. This path may or may not pass through the root.\n\n(_Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)_",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,5,6\\]\n**Output:** 3\n**Explanation:** Diameter is shown in red color.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2,null,3,4,null,5,null,6\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\\]\n**Output:** 7"
            ],
            "constraints": "**Constraints:**\n\n*   The depth of the n-ary tree is less than or equal to `1000`.\n*   The total number of nodes is between `[1, 104]`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,null,3,2,4,null,5,6]",
                "output": "3"
            },
            {
                "input": "[1,null,2,null,3,4,null,5,null,6]",
                "output": "4"
            },
            {
                "input": "[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic String stoneGameIII(int[] stoneValue) {\n    int n = stoneValue.length;\n    int[] dp = new int[n + 1];\n    dp[n - 1] = stoneValue[n - 1];\n    for (int i = n - 2; i >= 0; --i) {\n        dp[i] = stoneValue[i] - dp[i + 1];\n        for (int j = 1; j < 3; ++j) {\n            if (i + j < n)\n                dp[i] = Math.max(dp[i], stoneValue[i + j] - dp[i + j + 1]);\n        }\n    }\n    if (dp[0] > 0) return \"Alice\";\n    if (dp[0] < 0) return \"Bob\";\n    return \"Tie\";\n}\n```\n    \n    We use a dynamic programming approach with a dp array. The dp array is used to store the difference in stone values for each optimal move. We initialize the last element of the dp array as the last element of the stoneValue array. We run a for loop iterating from the second-last element to the first element of the stoneValue array. For each iteration, we initialize dp[i] as the stone value at index i minus the dp value of the next index. Then, we run another for loop inside this loop for two iterations (since players can take up to 3 stones but we already considered taking 1 stone) and update dp[i] by taking the maximum value between the current dp[i] and the value of the stones for each iteration. After completing the loops, we check if dp[0] is positive, negative, or zero and return \"Alice\", \"Bob\", or \"Tie\" accordingly.\n    ",
        "python": "\n    ```python\ndef stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    dp[n - 1] = stoneValue[n - 1]\n    for i in range(n - 2, -1, -1):\n        dp[i] = stoneValue[i] - dp[i + 1]\n        for j in range(1, 3):\n            if i + j < n:\n                dp[i] = max(dp[i], stoneValue[i + j] - dp[i + j + 1])\n    if dp[0] > 0: return \"Alice\"\n    if dp[0] < 0: return \"Bob\"\n    return \"Tie\"\n```\n    \n    We use a dynamic programming approach with a dp array. The dp array is used to store the difference in stone values for each optimal move. We initialize the last element of the dp array as the last element of the stoneValue array. We run a for loop iterating from the second-last element to the first element of the stoneValue array. For each iteration, we initialize dp[i] as the stone value at index i minus the dp value of the next index. Then, we run another for loop inside this loop for two iterations (since players can take up to 3 stones but we already considered taking 1 stone) and update dp[i] by taking the maximum value between the current dp[i] and the value of the stones for each iteration. After completing the loops, we check if dp[0] is positive, negative, or zero and return \"Alice\", \"Bob\", or \"Tie\" accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring stoneGameIII(const vector<int>& stoneValue) {\n    int n = stoneValue.size();\n    vector<int> dp(n + 1, 0);\n    dp[n - 1] = stoneValue[n - 1];\n    for (int i = n - 2; i >= 0; --i) {\n        dp[i] = stoneValue[i] - dp[i + 1];\n        for (int j = 1; j < 3; ++j) {\n            if (i + j < n)\n                dp[i] = max(dp[i], stoneValue[i + j] - dp[i + j + 1]);\n        }\n    }\n    if (dp[0] > 0) return \"Alice\";\n    if (dp[0] < 0) return \"Bob\";\n    return \"Tie\";\n}\n```\n    \n    We use a dynamic programming approach with a dp array. The dp array is used to store the difference in stone values for each optimal move. We initialize the last element of the dp array as the last element of the stoneValue array. We run a for loop iterating from the second-last element to the first element of the stoneValue array. For each iteration, we initialize dp[i] as the stone value at index i minus the dp value of the next index. Then, we run another for loop inside this loop for two iterations (since players can take up to 3 stones but we already considered taking 1 stone) and update dp[i] by taking the maximum value between the current dp[i] and the value of the stones for each iteration. After completing the loops, we check if dp[0] is positive, negative, or zero and return \"Alice\", \"Bob\", or \"Tie\" accordingly.\n    ",
        "js": "\n    ```javascript\nfunction stoneGameIII(stoneValue) {\n    const n = stoneValue.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[n - 1] = stoneValue[n - 1];\n    for (let i = n - 2; i >= 0; --i) {\n        dp[i] = stoneValue[i] - dp[i + 1];\n        for (let j = 1; j < 3; ++j) {\n            if (i + j < n)\n                dp[i] = Math.max(dp[i], stoneValue[i + j] - dp[i + j + 1]);\n        }\n    }\n    if (dp[0] > 0) return \"Alice\";\n    if (dp[0] < 0) return \"Bob\";\n    return \"Tie\";\n}\n```\n    \n    We use a dynamic programming approach with a dp array. The dp array is used to store the difference in stone values for each optimal move. We initialize the last element of the dp array as the last element of the stoneValue array. We run a for loop iterating from the second-last element to the first element of the stoneValue array. For each iteration, we initialize dp[i] as the stone value at index i minus the dp value of the next index. Then, we run another for loop inside this loop for two iterations (since players can take up to 3 stones but we already considered taking 1 stone) and update dp[i] by taking the maximum value between the current dp[i] and the value of the stones for each iteration. After completing the loops, we check if dp[0] is positive, negative, or zero and return \"Alice\", \"Bob\", or \"Tie\" accordingly.\n    "
    },
    {
        "id": 243,
        "title": "Find the Index of the Large Integer",
        "difficulty": "Medium",
        "content": {
            "problem": "We have an integer array `arr`, where all the integers in `arr` are equal except for one integer which is **larger** than the rest of the integers. You will not be given direct access to the array, instead, you will have an **API** `ArrayReader` which have the following functions:\n\n*   `int compareSub(int l, int r, int x, int y)`: where `0 <= l, r, x, y < ArrayReader.length()`, `l <= r and` `x <= y`. The function compares the sum of sub-array `arr[l..r]` with the sum of the sub-array `arr[x..y]` and returns:\n    *   **1** if `arr[l]+arr[l+1]+...+arr[r] > arr[x]+arr[x+1]+...+arr[y]`.\n    *   **0** if `arr[l]+arr[l+1]+...+arr[r] == arr[x]+arr[x+1]+...+arr[y]`.\n    *   **\\-1** if `arr[l]+arr[l+1]+...+arr[r] < arr[x]+arr[x+1]+...+arr[y]`.\n*   `int length()`: Returns the size of the array.\n\nYou are allowed to call `compareSub()` **20 times** at most. You can assume both functions work in `O(1)` time.\n\nReturn _the index of the array `arr` which has the largest integer_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[7,7,7,7,10,7,7,7\\]\n**Output:** 4\n**Explanation:** The following calls to the API\nreader.compareSub(0, 0, 1, 1) // returns 0 this is a query comparing the sub-array (0, 0) with the sub array (1, 1), (i.e. compares arr\\[0\\] with arr\\[1\\]).\nThus we know that arr\\[0\\] and arr\\[1\\] doesn't contain the largest element.\nreader.compareSub(2, 2, 3, 3) // returns 0, we can exclude arr\\[2\\] and arr\\[3\\].\nreader.compareSub(4, 4, 5, 5) // returns 1, thus for sure arr\\[4\\] is the largest element in the array.\nNotice that we made only 3 calls, so the answer is valid.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,6,12\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= arr.length <= 5 * 105`\n*   `1 <= arr[i] <= 100`\n*   All elements of `arr` are equal except for one element which is larger than all other elements.\n\n**",
            "follow_up": "Follow up:**\n\n*   What if there are two numbers in `arr` that are bigger than all other numbers?\n*   What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?"
        },
        "tag": [],
        "example": [
            {
                "input": "[7,7,7,7,10,7,7,7]",
                "output": "4"
            },
            {
                "input": "[6,6,12]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<List<String>> displayTable(List<List<String>> orders) {\n    TreeSet<String> foodItems = new TreeSet<>();\n    TreeMap<Integer, Map<String, Integer>> tableOrders = new TreeMap<>();\n\n    for (List<String> order : orders) {\n        foodItems.add(order.get(2));\n        int tableNumber = Integer.parseInt(order.get(1));\n        tableOrders.putIfAbsent(tableNumber, new HashMap<>());\n        tableOrders.get(tableNumber).put(order.get(2), tableOrders.get(tableNumber).getOrDefault(order.get(2), 0) + 1);\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> header = new ArrayList<>();\n    header.add(\"Table\");\n    header.addAll(foodItems);\n    result.add(header);\n\n    for (Map.Entry<Integer, Map<String, Integer>> entry : tableOrders.entrySet()) {\n        List<String> row = new ArrayList<>();\n        row.add(String.valueOf(entry.getKey()));\n        for (String food : foodItems) {\n            row.add(String.valueOf(entry.getValue().getOrDefault(food, 0)));\n        }\n        result.add(row);\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize a set for unique food items and a map for table orders.\n2. Iterate over all orders and add food items to the set and update the table orders map.\n3. Prepare a header row with the sorted food items.\n4. Iterate over the sorted table orders and create an array for each table with the number of food items ordered.\n5. Return the result with the header and table order rows.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\nfrom typing import List\n\ndef displayTable(orders: List[List[str]]) -> List[List[str]]:\n    foodItems = set()\n    tableOrders = defaultdict(lambda: defaultdict(int))\n\n    for order in orders:\n        foodItems.add(order[2])\n        tableOrders[int(order[1])][order[2]] += 1\n\n    foodItems = sorted(foodItems)\n    header = [\"Table\"] + foodItems\n    result = [header]\n\n    for tableNumber, foodOrder in sorted(tableOrders.items()):\n        row = [str(tableNumber)] + [str(foodOrder[food]) for food in foodItems]\n        result.append(row)\n\n    return result\n```\n\n    \n    1. Initialize a set for unique food items and a map for table orders.\n2. Iterate over all orders and add food items to the set and update the table orders map.\n3. Prepare a header row with the sorted food items.\n4. Iterate over the sorted table orders and create an array for each table with the number of food items ordered.\n5. Return the result with the header and table order rows.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<string>> displayTable(vector<vector<string>>& orders) {\n    set<string> foodItems;\n    map<int, map<string, int>> tableOrders;\n    \n    for (const auto& order : orders) {\n        foodItems.insert(order[2]);\n        tableOrders[stoi(order[1])][order[2]]++;\n    }\n\n    vector<vector<string>> result;\n    vector<string> header;\n    header.push_back(\"Table\");\n    header.insert(header.end(), foodItems.begin(), foodItems.end());\n    result.push_back(header);\n    \n    for (const auto& entry : tableOrders) {\n        vector<string> row;\n        row.push_back(to_string(entry.first));\n        for (const auto& food : foodItems) {\n            row.push_back(to_string(entry.second[food]));\n        }\n        result.push_back(row);\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize a set for unique food items and a map for table orders.\n2. Iterate over all orders and add food items to the set and update the table orders map.\n3. Prepare a header row with the sorted food items.\n4. Iterate over the sorted table orders and create an array for each table with the number of food items ordered.\n5. Return the result with the header and table order rows.\n    ",
        "js": "\n    ```javascript\nfunction displayTable(orders) {\n    const foodItems = new Set();\n    const tableOrders = new Map();\n\n    for (const order of orders) {\n        foodItems.add(order[2]);\n        const tableNumber = parseInt(order[1]);\n        if (!tableOrders.has(tableNumber)) {\n            tableOrders.set(tableNumber, new Map());\n        }\n        const table = tableOrders.get(tableNumber);\n        table.set(order[2], (table.get(order[2]) || 0) + 1);\n    }\n\n    const sortedFoodItems = Array.from(foodItems).sort();\n    const header = ['Table', ...sortedFoodItems];\n    const result = [header];\n\n    for (const [tableNumber, foodOrder] of [...tableOrders.entries()].sort((a, b) => a[0] - b[0])) {\n        const row = [tableNumber.toString(), ...sortedFoodItems.map(food => (foodOrder.get(food) || 0).toString())];\n        result.push(row);\n    }\n\n    return result;\n}\n```\n\n    \n    1. Initialize a set for unique food items and a map for table orders.\n2. Iterate over all orders and add food items to the set and update the table orders map.\n3. Prepare a header row with the sorted food items.\n4. Iterate over the sorted table orders and create an array for each table with the number of food items ordered.\n5. Return the result with the header and table order rows.\n    "
    },
    {
        "id": 244,
        "title": "Guess the Majority in a Hidden Array",
        "difficulty": "Medium",
        "content": {
            "problem": "We have an integer array `nums`, where all the integers in `nums` are **0** or **1**. You will not be given direct access to the array, instead, you will have an **API** `ArrayReader` which have the following functions:\n\n*   `int query(int a, int b, int c, int d)`: where `0 <= a < b < c < d < ArrayReader.length()`. The function returns the distribution of the value of the 4 elements and returns:\n    *   **4** : if the values of the 4 elements are the same (0 or 1).\n    *   **2** : if three elements have a value equal to 0 and one element has value equal to 1 or vice versa.\n    *   **0** : if two element have a value equal to 0 and two elements have a value equal to 1.\n*   `int length()`: Returns the size of the array.\n\nYou are allowed to call `query()` **2 \\* n times** at most where n is equal to `ArrayReader.length()`.\n\nReturn **any** index of the most frequent value in `nums`, in case of tie, return -1.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,0,1,0,1,1,1,1\\]\n**Output:** 5\n**Explanation:** The following calls to the API\nreader.length() // returns 8 because there are 8 elements in the hidden array.\nreader.query(0,1,2,3) // returns 2 this is a query that compares the elements nums\\[0\\], nums\\[1\\], nums\\[2\\], nums\\[3\\]\n// Three elements have a value equal to 0 and one element has value equal to 1 or viceversa.\nreader.query(4,5,6,7) // returns 4 because nums\\[4\\], nums\\[5\\], nums\\[6\\], nums\\[7\\] have the same value.\nwe can infer that the most frequent value is found in the last 4 elements.\nIndex 2, 4, 6, 7 is also a correct answer.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,0\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,0,1,0,1,0,1,0\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `5 <= nums.length <= 105`\n*   `0 <= nums[i] <= 1`\n\n**",
            "follow_up": "Follow up:** What is the minimum number of calls needed to find the majority element?"
        },
        "tag": [],
        "example": [
            {
                "input": "[0,0,1,0,1,1,1,1]",
                "output": "5"
            },
            {
                "input": "[0,0,1,1,0]",
                "output": "0"
            },
            {
                "input": "[1,0,1,0,1,0,1,0]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int[] cardPoints, int k) {\n    int n = cardPoints.length;\n    int total = 0;\n    for (int i = 0; i < k; i++) {\n        total += cardPoints[i];\n    }\n\n    int maxScore = total;\n    for (int i = k - 1, j = n - 1; i >= 0; i--, j--) {\n        total += cardPoints[j] - cardPoints[i];\n        maxScore = Math.max(maxScore, total);\n    }\n\n    return maxScore;\n}\n```\n\n    \n    The algorithm starts by taking the first k cards and calculating the initial total score. Then, in a loop, it iteratively removes the first card and adds the next card from the end. By doing this, it explores all possible combinations of taking `k` cards from the beginning or the end of the row. The maximum score is updated each time a potentially higher score is found. The loop ends when all combinations are explored, and the resulting maximum score is returned.\n    ",
        "python": "\n    ```python\ndef maxScore(cardPoints, k):\n    n = len(cardPoints)\n    total = sum(cardPoints[:k])\n\n    max_score = total\n    for i in range(k - 1, -1, -1):\n        j = n - k + i\n        total += cardPoints[j] - cardPoints[i]\n        max_score = max(max_score, total)\n\n    return max_score\n```\n\n    \n    The algorithm starts by taking the first k cards and calculating the initial total score. Then, in a loop, it iteratively removes the first card and adds the next card from the end. By doing this, it explores all possible combinations of taking `k` cards from the beginning or the end of the row. The maximum score is updated each time a potentially higher score is found. The loop ends when all combinations are explored, and the resulting maximum score is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint maxScore(vector<int>& cardPoints, int k) {\n    int n = cardPoints.size();\n    int total = 0;\n    for (int i = 0; i < k; ++i) {\n        total += cardPoints[i];\n    }\n\n    int maxScore = total;\n    for (int i = k - 1, j = n - 1; i >= 0; --i, --j) {\n        total += cardPoints[j] - cardPoints[i];\n        maxScore = max(maxScore, total);\n    }\n\n    return maxScore;\n}\n```\n\n    \n    The algorithm starts by taking the first k cards and calculating the initial total score. Then, in a loop, it iteratively removes the first card and adds the next card from the end. By doing this, it explores all possible combinations of taking `k` cards from the beginning or the end of the row. The maximum score is updated each time a potentially higher score is found. The loop ends when all combinations are explored, and the resulting maximum score is returned.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(cardPoints, k) {\n    let n = cardPoints.length;\n    let total = 0;\n    for (let i = 0; i < k; i++) {\n        total += cardPoints[i];\n    }\n\n    let maxScore = total;\n    for (let i = k - 1, j = n - 1; i >= 0; i--, j--) {\n        total += cardPoints[j] - cardPoints[i];\n        maxScore = Math.max(maxScore, total);\n    }\n\n    return maxScore;\n}\n```\n\n    \n    The algorithm starts by taking the first k cards and calculating the initial total score. Then, in a loop, it iteratively removes the first card and adds the next card from the end. By doing this, it explores all possible combinations of taking `k` cards from the beginning or the end of the row. The maximum score is updated each time a potentially higher score is found. The loop ends when all combinations are explored, and the resulting maximum score is returned.\n    "
    },
    {
        "id": 245,
        "title": "The Most Similar Path in a Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "We have `n` cities and `m` bi-directional `roads` where `roads[i] = [ai, bi]` connects city `ai` with city `bi`. Each city has a name consisting of exactly three upper-case English letters given in the string array `names`. Starting at any city `x`, you can reach any city `y` where `y != x` (i.e., the cities and the roads are forming an undirected connected graph).\n\nYou will be given a string array `targetPath`. You should find a path in the graph of the **same length** and with the **minimum edit distance** to `targetPath`.\n\nYou need to return _the order of the nodes in the path with the minimum edit distance_. The path should be of the same length of `targetPath` and should be valid (i.e., there should be a direct road between `ans[i]` and `ans[i + 1]`). If there are multiple answers return any one of them.\n\nThe **edit distance** is defined as follows:",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, roads = \\[\\[0,2\\],\\[0,3\\],\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[2,4\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"DXB \", \"HND \"\\], targetPath = \\[ \"ATL \", \"DXB \", \"HND \", \"LAX \"\\]\n**Output:** \\[0,2,4,2\\]\n**Explanation:** \\[0,2,4,2\\], \\[0,3,0,2\\] and \\[0,3,1,2\\] are accepted answers.\n\\[0,2,4,2\\] is equivalent to \\[ \"ATL \", \"LAX \", \"HND \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\\[0,3,0,2\\] is equivalent to \\[ \"ATL \", \"DXB \", \"ATL \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\\[0,3,1,2\\] is equivalent to \\[ \"ATL \", \"DXB \", \"PEK \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,0\\],\\[2,0\\],\\[3,0\\],\\[2,1\\],\\[3,1\\],\\[3,2\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"DXB \"\\], targetPath = \\[ \"ABC \", \"DEF \", \"GHI \", \"JKL \", \"MNO \", \"PQR \", \"STU \", \"VWX \"\\]\n**Output:** \\[0,1,0,1,0,1,0,1\\]\n**Explanation:** Any path in this graph has edit distance = 8 with targetPath.\n\n",
                "**Example 3:**\n\n**Input:** n = 6, roads = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"ATL \", \"DXB \", \"HND \"\\], targetPath = \\[ \"ATL \", \"DXB \", \"HND \", \"DXB \", \"ATL \", \"LAX \", \"PEK \"\\]\n**Output:** \\[3,4,5,4,3,2,1\\]\n**Explanation:** \\[3,4,5,4,3,2,1\\] is the only path with edit distance = 0 with targetPath.\nIt's equivalent to \\[ \"ATL \", \"DXB \", \"HND \", \"DXB \", \"ATL \", \"LAX \", \"PEK \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 100`\n*   `m == roads.length`\n*   `n - 1 <= m <= (n * (n - 1) / 2)`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   The graph is guaranteed to be **connected** and each pair of nodes may have **at most one** direct road.\n*   `names.length == n`\n*   `names[i].length == 3`\n*   `names[i]` consists of upper-case English letters.\n*   There can be two cities with **the same** name.\n*   `1 <= targetPath.length <= 100`\n*   `targetPath[i].length == 3`\n*   `targetPath[i]` consists of upper-case English letters.\n\n**",
            "follow_up": "Follow up:** If each node can be visited only once in the path, What should you change in your solution?"
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]],[\"ATL\",\"PEK\",\"LAX\",\"DXB\",\"HND\"],[\"ATL\",\"DXB\",\"HND\",\"LAX\"]",
                "output": "[0,2,4,2]"
            },
            {
                "input": "4,[[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]],[\"ATL\",\"PEK\",\"LAX\",\"DXB\"],[\"ABC\",\"DEF\",\"GHI\",\"JKL\",\"MNO\",\"PQR\",\"STU\",\"VWX\"]",
                "output": "[0,1,0,1,0,1,0,1]"
            },
            {
                "input": "6,[[0,1],[1,2],[2,3],[3,4],[4,5]],[\"ATL\",\"PEK\",\"LAX\",\"ATL\",\"DXB\",\"HND\"],[\"ATL\",\"DXB\",\"HND\",\"DXB\",\"ATL\",\"LAX\",\"PEK\"]",
                "output": "[3,4,5,4,3,2,1]"
            }
        ],
        "java": "\n    ```java\npublic boolean kLengthApart(int[] nums, int k) {\n    int last_one = -1;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == 1) {\n            if (last_one != -1 && i - last_one <= k) {\n                return false;\n            }\n            last_one = i;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    ",
        "python": "\n    ```python\ndef kLengthApart(nums, k):\n    last_one = -1\n    for i, num in enumerate(nums):\n        if num == 1:\n            if last_one != -1 and i - last_one <= k:\n                return False\n            last_one = i\n    return True\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool kLengthApart(vector<int>& nums, int k) {\n    int last_one = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == 1) {\n            if (last_one != -1 && i - last_one <= k) {\n                return false;\n            }\n            last_one = i;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    ",
        "js": "\n    ```javascript\nfunction kLengthApart(nums, k) {\n    let last_one = -1;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 1) {\n            if (last_one !== -1 && i - last_one <= k) {\n                return false;\n            }\n            last_one = i;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the binary array `nums`. As it iterates, it keeps track of the position of the last 1 it encountered in the array, which is initially set to -1. When it finds a 1 in the array, it checks if the distance between this 1 and the previous 1 is greater than or equal to `k` (i.e., the distance should be more than `k`). If yes, it updates the last 1's position. If not, the function returns false. If the loop completes without finding any two 1s closer than `k` places from each other, the function returns true.\n    "
    },
    {
        "id": 246,
        "title": "Strings Differ by One Character",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a list of strings `dict` where all the strings are of the same length.\n\nReturn `true` if there are 2 strings that only differ by 1 character in the same index, otherwise return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** dict = \\[ \"abcd \", \"acbd \",  \"aacd \"\\]\n**Output:** true\n**Explanation:** Strings  \"a**b**cd \" and  \"a**a**cd \" differ only by one character in the index 1.\n\n",
                "**Example 2:**\n\n**Input:** dict = \\[ \"ab \", \"cd \", \"yz \"\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** dict = \\[ \"abcd \", \"cccc \", \"abyd \", \"abab \"\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   The number of characters in `dict <= 105`\n*   `dict[i].length == dict[j].length`\n*   `dict[i]` should be unique.\n*   `dict[i]` contains only lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Could you solve this problem in `O(n * m)` where n is the length of `dict` and `m` is the length of each string."
        },
        "tag": [],
        "example": [
            {
                "input": "[\"abcd\",\"acbd\",\"aacd\"]",
                "output": "true"
            },
            {
                "input": "[\"ab\",\"cd\",\"yz\"]",
                "output": "false"
            },
            {
                "input": "[\"abcd\",\"cccc\",\"abyd\",\"abab\"]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minTime(int n, int[][] edges, boolean[] hasApple) {\n    Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\n\n    for (int[] edge : edges) {\n        graph.computeIfAbsent(edge[0], k -> new HashMap<>()).put(edge[1], 0);\n        graph.computeIfAbsent(edge[1], k -> new HashMap<>()).put(edge[0], 0);\n    }\n\n    return dfs(n, 0, -1, hasApple, graph);\n}\n\nprivate int dfs(int n, int v, int parent, boolean[] hasApple, Map<Integer, Map<Integer, Integer>> graph) {\n    int ans = 0;\n    for (int u : graph.get(v).keySet()) {\n        if (u == parent) continue;\n        ans += dfs(n, u, v, hasApple, graph) * 2;\n    }\n\n    return ans + ((hasApple[v] || ans > 0) ? 1 : 0);\n}\n```\n    \n    The algorithm works as follows:\n1. Build a graph representation using a hashmap with the given edges.\n2. Implement a depth-first search (dfs) function to traverse the tree.\n   - The input parameters are the vertex, and it's parent.\n   - The output is the minimum time required to collect apples from the sub-tree rooted at the given vertex.\n3. During the dfs traversal, visit each neighbor of the current vertex (ignoring the parent).\n   - For each neighbor, accumulator (ans) is incremented by (dfs(neighbor) * 2). The reason it's multiplied by 2 is because you have to spend time going to and coming back from the neighbor.\n4. Finally, include the time spent at the current vertex if it has an apple or if some time was spent in its sub-tree.\n5. Call the dfs function with the root vertex (0) and parent (-1).\n6. Return the result obtained from the dfs function.\n\nThe time complexity is O(n) as each vertex is visited once.\n    ",
        "python": "\n    ```python\ndef minTime(n, edges, hasApple):\n    graph = {i: {} for i in range(n)}\n\n    for a, b in edges:\n        graph[a][b] = 0\n        graph[b][a] = 0\n\n    def dfs(v, parent):\n        ans = 0\n        for u in graph[v]:\n            if u == parent:\n                continue\n            ans += dfs(u, v) * 2\n        return ans + int(hasApple[v] or ans > 0)\n\n    return dfs(0, -1)\n```\n    \n    The algorithm works as follows:\n1. Build a graph representation using a hashmap with the given edges.\n2. Implement a depth-first search (dfs) function to traverse the tree.\n   - The input parameters are the vertex, and it's parent.\n   - The output is the minimum time required to collect apples from the sub-tree rooted at the given vertex.\n3. During the dfs traversal, visit each neighbor of the current vertex (ignoring the parent).\n   - For each neighbor, accumulator (ans) is incremented by (dfs(neighbor) * 2). The reason it's multiplied by 2 is because you have to spend time going to and coming back from the neighbor.\n4. Finally, include the time spent at the current vertex if it has an apple or if some time was spent in its sub-tree.\n5. Call the dfs function with the root vertex (0) and parent (-1).\n6. Return the result obtained from the dfs function.\n\nThe time complexity is O(n) as each vertex is visited once.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint minTime(int n, std::vector<std::vector<int>>& edges, std::vector<bool>& hasApple) {\n    std::unordered_map<int, std::unordered_map<int, int>> graph;\n\n    for (const auto& edge : edges) {\n        graph[edge[0]][edge[1]] = 0;\n        graph[edge[1]][edge[0]] = 0;\n    }\n\n    std::function<int(int, int)> dfs = [&](int v, int parent) {\n        int ans = 0;\n        for (auto& [u, _] : graph[v]) {\n            if (u == parent) continue;\n            ans += dfs(u, v) * 2;\n        }\n        return ans + (hasApple[v] || ans);\n    };\n\n    return dfs(0, -1);\n}\n```\n    \n    The algorithm works as follows:\n1. Build a graph representation using a hashmap with the given edges.\n2. Implement a depth-first search (dfs) function to traverse the tree.\n   - The input parameters are the vertex, and it's parent.\n   - The output is the minimum time required to collect apples from the sub-tree rooted at the given vertex.\n3. During the dfs traversal, visit each neighbor of the current vertex (ignoring the parent).\n   - For each neighbor, accumulator (ans) is incremented by (dfs(neighbor) * 2). The reason it's multiplied by 2 is because you have to spend time going to and coming back from the neighbor.\n4. Finally, include the time spent at the current vertex if it has an apple or if some time was spent in its sub-tree.\n5. Call the dfs function with the root vertex (0) and parent (-1).\n6. Return the result obtained from the dfs function.\n\nThe time complexity is O(n) as each vertex is visited once.\n    ",
        "js": "\n    ```javascript\nfunction minTime(n, edges, hasApple) {\n  const graph = Array.from({ length: n }, () => new Map());\n\n  for (const [a, b] of edges) {\n    graph[a].set(b, 0);\n    graph[b].set(a, 0);\n  }\n\n  function dfs(v, parent) {\n    let ans = 0;\n    for (const [u, _] of graph[v]) {\n      if (u === parent) continue;\n      ans += dfs(u, v) * 2;\n    }\n\n    return ans + (hasApple[v] || ans > 0 ? 1 : 0);\n  }\n\n  return dfs(0, -1);\n}\n```\n    \n    The algorithm works as follows:\n1. Build a graph representation using a hashmap with the given edges.\n2. Implement a depth-first search (dfs) function to traverse the tree.\n   - The input parameters are the vertex, and it's parent.\n   - The output is the minimum time required to collect apples from the sub-tree rooted at the given vertex.\n3. During the dfs traversal, visit each neighbor of the current vertex (ignoring the parent).\n   - For each neighbor, accumulator (ans) is incremented by (dfs(neighbor) * 2). The reason it's multiplied by 2 is because you have to spend time going to and coming back from the neighbor.\n4. Finally, include the time spent at the current vertex if it has an apple or if some time was spent in its sub-tree.\n5. Call the dfs function with the root vertex (0) and parent (-1).\n6. Return the result obtained from the dfs function.\n\nThe time complexity is O(n) as each vertex is visited once.\n    "
    },
    {
        "id": 247,
        "title": "Most Visited Sector in  a Circular Track",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n` and an integer array `rounds`. We have a circular track which consists of `n` sectors labeled from `1` to `n`. A marathon will be held on this track, the marathon consists of `m` rounds. The `ith` round starts at sector `rounds[i - 1]` and ends at sector `rounds[i]`. For example, round 1 starts at sector `rounds[0]` and ends at sector `rounds[1]`\n\nReturn _an array of the most visited sectors_ sorted in **ascending** order.\n\nNotice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, rounds = \\[1,3,1,2\\]\n**Output:** \\[1,2\\]\n**Explanation:** The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, rounds = \\[2,1,2,1,2,1,2,1,2\\]\n**Output:** \\[2\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 7, rounds = \\[1,3,5,7\\]\n**Output:** \\[1,2,3,4,5,6,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= m <= 100`\n*   `rounds.length == m + 1`\n*   `1 <= rounds[i] <= n`\n*   `rounds[i] != rounds[i + 1]` for `0 <= i < m`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "4,[1,3,1,2]",
                "output": "[1,2]"
            },
            {
                "input": "2,[2,1,2,1,2,1,2,1,2]",
                "output": "[2]"
            },
            {
                "input": "7,[1,3,5,7]",
                "output": "[1,2,3,4,5,6,7]"
            }
        ],
        "java": "\n    ```java\npublic int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n    int count = 0;\n    for (int i = 0; i < startTime.length; i++) {\n        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of iterating through the startTime and endTime arrays in parallel, by checking if the queryTime lies within the range of startTime[i] and endTime[i]. If it's within the range, increment the count. Finally, return the count as the result. The code is quite similar across the different languages.\n    ",
        "python": "\n    ```python\ndef busy_student(start_time, end_time, query_time):\n    count = 0\n    for i in range(len(start_time)):\n        if start_time[i] <= query_time <= end_time[i]:\n            count += 1\n    return count\n```\n    \n    The algorithm consists of iterating through the startTime and endTime arrays in parallel, by checking if the queryTime lies within the range of startTime[i] and endTime[i]. If it's within the range, increment the count. Finally, return the count as the result. The code is quite similar across the different languages.\n    ",
        "c++": "\n    ```cpp\nint busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\n    int count = 0;\n    for (int i = 0; i < startTime.size(); i++) {\n        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of iterating through the startTime and endTime arrays in parallel, by checking if the queryTime lies within the range of startTime[i] and endTime[i]. If it's within the range, increment the count. Finally, return the count as the result. The code is quite similar across the different languages.\n    ",
        "js": "\n    ```javascript\nfunction busyStudent(startTime, endTime, queryTime) {\n    let count = 0;\n    for (let i = 0; i < startTime.length; i++) {\n        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of iterating through the startTime and endTime arrays in parallel, by checking if the queryTime lies within the range of startTime[i] and endTime[i]. If it's within the range, increment the count. Finally, return the count as the result. The code is quite similar across the different languages.\n    "
    },
    {
        "id": 248,
        "title": "Put Boxes Into the Warehouse I",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labelled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.\n\nBoxes are put into the warehouse by the following rules:\n\n*   Boxes cannot be stacked.\n*   You can rearrange the insertion order of the boxes.\n*   Boxes can only be pushed into the warehouse from left to right only.\n*   If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.\n\nReturn _the maximum number of boxes you can put into the warehouse._",
            "examples": [
                "**Example 1:**\n\n**Input:** boxes = \\[4,3,4,1\\], warehouse = \\[5,3,3,4,1\\]\n**Output:** 3\n**Explanation:** \n \nWe can first put the box of height 1 in room 4. Then we can put the box of height 3 in either of the 3 rooms 1, 2, or 3. Lastly, we can put one box of height 4 in room 0.\nThere is no way we can fit all 4 boxes in the warehouse.\n\n",
                "**Example 2:**\n\n**Input:** boxes = \\[1,2,2,3,4\\], warehouse = \\[3,4,1,2\\]\n**Output:** 3\n**Explanation:** \n \nNotice that it's not possible to put the box of height 4 into the warehouse since it cannot pass the first room of height 3.\nAlso, for the last two rooms, 2 and 3, only boxes of height 1 can fit.\nWe can fit 3 boxes maximum as shown above. The yellow box can also be put in room 2 instead.\nSwapping the orange and green boxes is also valid, or swapping one of them with the red box.\n\n",
                "**Example 3:**\n\n**Input:** boxes = \\[1,2,3\\], warehouse = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:** Since the first room in the warehouse is of height 1, we can only put boxes of height 1."
            ],
            "constraints": "**Constraints:**\n\n*   `n == warehouse.length`\n*   `1 <= boxes.length, warehouse.length <= 105`\n*   `1 <= boxes[i], warehouse[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,3,4,1],[5,3,3,4,1]",
                "output": "3"
            },
            {
                "input": "[1,2,2,3,4],[3,4,1,2]",
                "output": "3"
            },
            {
                "input": "[1,2,3],[1,2,3,4]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxBoxesInWarehouse(int[] boxes, int[] warehouse) {\n    int n = warehouse.length;\n    for (int i = 1; i < n; i++)\n        warehouse[i] = Math.min(warehouse[i], warehouse[i - 1]);\n    Arrays.sort(boxes);\n    int boxIndex = boxes.length - 1;\n    int boxesCount = 0;\n    for (int i = 0; i < n && boxIndex >= 0; i++) {\n        if (boxes[boxIndex] <= warehouse[i]) {\n            boxesCount++;\n            boxIndex--;\n        }\n    }\n    return boxesCount;\n}\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    ",
        "python": "\n    ```python\ndef maxBoxesInWarehouse(boxes, warehouse):\n    n = len(warehouse)\n    for i in range(1, n):\n        warehouse[i] = min(warehouse[i], warehouse[i - 1])\n    boxes.sort(reverse=True)\n    boxIndex = 0\n    boxesCount = 0\n    for i in range(n):\n        if boxIndex < len(boxes) and boxes[boxIndex] <= warehouse[i]:\n            boxesCount += 1\n            boxIndex += 1\n    return boxesCount\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    ",
        "c++": "\n    ```cpp\nint maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) {\n    int n = warehouse.size();\n    for (int i = 1; i < n; i++)\n        warehouse[i] = min(warehouse[i], warehouse[i - 1]);\n    sort(boxes.rbegin(), boxes.rend());\n    int boxIndex = 0;\n    int boxesCount = 0;\n    for (int i = 0; i < n && boxIndex < boxes.size(); i++) {\n        if (boxes[boxIndex] <= warehouse[i]) {\n            boxesCount++;\n            boxIndex++;\n        }\n    }\n    return boxesCount;\n}\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    ",
        "js": "\n    ```javascript\nfunction maxBoxesInWarehouse(boxes, warehouse) {\n    let n = warehouse.length;\n    for (let i = 1; i < n; i++)\n        warehouse[i] = Math.min(warehouse[i], warehouse[i - 1]);\n    boxes.sort((a, b) => b - a);\n    let boxIndex = 0;\n    let boxesCount = 0;\n    for (let i = 0; i < n && boxIndex < boxes.length; i++) {\n        if (boxes[boxIndex] <= warehouse[i]) {\n            boxesCount++;\n            boxIndex++;\n        }\n    }\n    return boxesCount;\n}\n```\n\n    \n    The main idea of the algorithm is to first preprocess the warehouse array such that for each room, it stores the minimum height up to that room. This is done to find the maximum height a box can have to be placed in a room considering previous rooms' heights. Then, reverse sort the boxes array to have the largest box first. Finally, iterate through the preprocessed warehouse array and compare the height of the current largest box with the height of the current room. If the box can fit, increment the count of boxes and move to the next box in the sorted array.\n    "
    },
    {
        "id": 249,
        "title": "Dot Product of Two Sparse Vectors",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two sparse vectors, compute their dot product.\n\nImplement class `SparseVector`:\n\n*   `SparseVector(nums)` Initializes the object with the vector `nums`\n*   `dotProduct(vec)` Compute the dot product between the instance of _SparseVector_ and `vec`\n\nA **sparse vector** is a vector that has mostly zero values, you should store the sparse vector **efficiently** and compute the dot product between two _SparseVector_.\n\n**Follow up:** What if only one of the vectors is sparse?",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,0,0,2,3\\], nums2 = \\[0,3,0,4,0\\]\n**Output:** 8\n**Explanation:** v1 = SparseVector(nums1) , v2 = SparseVector(nums2)\nv1.dotProduct(v2) = 1\\*0 + 0\\*3 + 0\\*0 + 2\\*4 + 3\\*0 = 8\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[0,1,0,0,0\\], nums2 = \\[0,0,0,0,2\\]\n**Output:** 0\n**Explanation:** v1 = SparseVector(nums1) , v2 = SparseVector(nums2)\nv1.dotProduct(v2) = 0\\*0 + 1\\*0 + 0\\*0 + 0\\*0 + 0\\*2 = 0\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[0,1,0,0,2,0,0\\], nums2 = \\[1,0,0,0,3,0,4\\]\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 10^5`\n*   `0 <= nums1[i], nums2[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,0,0,2,3],[0,3,0,4,0]",
                "output": "8"
            },
            {
                "input": "[0,1,0,0,0],[0,0,0,0,2]",
                "output": "0"
            },
            {
                "input": "[0,1,0,0,2,0,0],[1,0,0,0,3,0,4]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int[] finalPrices(int[] prices) {\n    for(int i = 0; i < prices.length; i++) {\n        for(int j = i + 1; j < prices.length; j++) {\n            if(prices[j] <= prices[i]) {\n                prices[i] -= prices[j];\n                break;\n            }\n        }\n    }\n    return prices;\n}\n```\n    \n    The algorithm iterates through each element `i` in the `prices` array. For each element, it iterates through the remaining elements (from `i+1` to the end), looking for an element `j` such that `prices[j] <= prices[i]`. If such an element is found, we subtract `prices[j]` from `prices[i]` and then move on to the next element. This is done using nested loops.\n\nThe outer loop iterates through all the elements in the array, and the inner loop checks for eligible discounts. Only one discount per item is applied, hence the `break` statement after an applicable discount is found.\n\nThe running time complexity of this algorithm is O(n^2), where \"n\" is the length of the input array. This is because, in the worst case, all pairs of elements need to be checked.\n    ",
        "python": "\n    ```python\ndef final_prices(prices):\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            if prices[j] <= prices[i]:\n                prices[i] -= prices[j]\n                break\n    return prices\n```\n    \n    The algorithm iterates through each element `i` in the `prices` array. For each element, it iterates through the remaining elements (from `i+1` to the end), looking for an element `j` such that `prices[j] <= prices[i]`. If such an element is found, we subtract `prices[j]` from `prices[i]` and then move on to the next element. This is done using nested loops.\n\nThe outer loop iterates through all the elements in the array, and the inner loop checks for eligible discounts. Only one discount per item is applied, hence the `break` statement after an applicable discount is found.\n\nThe running time complexity of this algorithm is O(n^2), where \"n\" is the length of the input array. This is because, in the worst case, all pairs of elements need to be checked.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> finalPrices(vector<int>& prices) {\n    for(int i = 0; i < prices.size(); i++) {\n        for(int j = i + 1; j < prices.size(); j++) {\n            if(prices[j] <= prices[i]) {\n                prices[i] -= prices[j];\n                break;\n            }\n        }\n    }\n    return prices;\n}\n```\n    \n    The algorithm iterates through each element `i` in the `prices` array. For each element, it iterates through the remaining elements (from `i+1` to the end), looking for an element `j` such that `prices[j] <= prices[i]`. If such an element is found, we subtract `prices[j]` from `prices[i]` and then move on to the next element. This is done using nested loops.\n\nThe outer loop iterates through all the elements in the array, and the inner loop checks for eligible discounts. Only one discount per item is applied, hence the `break` statement after an applicable discount is found.\n\nThe running time complexity of this algorithm is O(n^2), where \"n\" is the length of the input array. This is because, in the worst case, all pairs of elements need to be checked.\n    ",
        "js": "\n    ```javascript\nfunction finalPrices(prices) {\n    for(let i = 0; i < prices.length; i++) {\n        for(let j = i + 1; j < prices.length; j++) {\n            if(prices[j] <= prices[i]) {\n                prices[i] -= prices[j];\n                break;\n            }\n        }\n    }\n    return prices;\n}\n```\n    \n    The algorithm iterates through each element `i` in the `prices` array. For each element, it iterates through the remaining elements (from `i+1` to the end), looking for an element `j` such that `prices[j] <= prices[i]`. If such an element is found, we subtract `prices[j]` from `prices[i]` and then move on to the next element. This is done using nested loops.\n\nThe outer loop iterates through all the elements in the array, and the inner loop checks for eligible discounts. Only one discount per item is applied, hence the `break` statement after an applicable discount is found.\n\nThe running time complexity of this algorithm is O(n^2), where \"n\" is the length of the input array. This is because, in the worst case, all pairs of elements need to be checked.\n    "
    },
    {
        "id": 250,
        "title": "Replace All ?'s to Avoid Consecutive Repeating Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` containing only lowercase English letters and the `'?'` character, convert **all** the `'?'` characters into lowercase letters such that the final string does not contain any **consecutive repeating** characters. You **cannot** modify the non `'?'` characters.\n\nIt is **guaranteed** that there are no consecutive repeating characters in the given string **except** for `'?'`.\n\nReturn _the final string after all the conversions (possibly zero) have been made_. If there is more than one solution, return **any of them**. It can be shown that an answer is always possible with the given constraints.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"?zs \"\n**Output:**  \"azs \"\n**Explanation:** There are 25 solutions for this problem. From  \"azs \" to  \"yzs \", all are valid. Only  \"z \" is an invalid modification as the string will consist of consecutive repeating characters in  \"zzs \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ubv?w \"\n**Output:**  \"ubvaw \"\n**Explanation:** There are 24 solutions for this problem. Only  \"v \" and  \"w \" are invalid modifications as the strings will consist of consecutive repeating characters in  \"ubvvw \" and  \"ubvww \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consist of lowercase English letters and `'?'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"?zs\"",
                "output": "\"azs\""
            },
            {
                "input": "\"ubv?w\"",
                "output": "\"ubvaw\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public void dfs(int node, int parent, List<List<Integer>> graph, int[] count) {\n        if (node != 0 && parent == 0) count[0]++;\n    \n        for (int neighbor : graph.get(node)) {\n            if (neighbor != parent) {\n                dfs(neighbor, node, graph, count);\n            }\n        }\n    }\n    \n    public int minReorder(int n, int[][] connections) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n    \n        for (int[] c : connections) {\n            graph.get(c[0]).add(c[1]);\n            graph.get(c[1]).add(c[0]);\n        }\n\n        int[] count = {0};\n        dfs(0, -1, graph, count);\n        return count[0];\n    }\n}\n```\n    \n    The algorithm used in the code snippet uses a Depth-First Search (DFS) approach for traversing the given graph of cities represented by nodes and roads represented by connections. The dfs() functions are called on every node and their respective parents, and the result stores the minimum number of edges that should be changed.\n\nInitially, the graph is created with each city having a list of its neighboring cities (bi-directional). The DFS algorithm starts traversing the graph from city 0 and recursively visits its neighboring nodes, and the edges that need to be adjusted are kept track of with the 'count' variable.\n\nWhenever DFS encounters a city with a direct road towards city 0, 1 is added to the count. The minimum number of required edge changes will be the value of count. The final answer returned is the count of edges needed to be changed for all cities to reach city 0.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, count):\n    if node != 0 and parent == 0:\n        count[0] += 1\n\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, graph, count)\n\ndef minReorder(n, connections):\n    graph = defaultdict(list)\n    for a, b in connections:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    count = [0]\n    dfs(0, -1, graph, count)\n    return count[0]\n```\n    \n    The algorithm used in the code snippet uses a Depth-First Search (DFS) approach for traversing the given graph of cities represented by nodes and roads represented by connections. The dfs() functions are called on every node and their respective parents, and the result stores the minimum number of edges that should be changed.\n\nInitially, the graph is created with each city having a list of its neighboring cities (bi-directional). The DFS algorithm starts traversing the graph from city 0 and recursively visits its neighboring nodes, and the edges that need to be adjusted are kept track of with the 'count' variable.\n\nWhenever DFS encounters a city with a direct road towards city 0, 1 is added to the count. The minimum number of required edge changes will be the value of count. The final answer returned is the count of edges needed to be changed for all cities to reach city 0.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, int parent, vector<vector<int>> &graph, int &count) {\n    if (node != 0 && parent == 0) count++;\n\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, graph, count);\n        }\n    }\n}\n\nint minReorder(int n, vector<vector<int>> &connections) {\n    vector<vector<int>> graph(n);\n    for (auto &c : connections) {\n        graph[c[0]].push_back(c[1]);\n        graph[c[1]].push_back(c[0]);\n    }\n\n    int count = 0;\n    dfs(0, -1, graph, count);\n    return count;\n}\n```\n    \n    The algorithm used in the code snippet uses a Depth-First Search (DFS) approach for traversing the given graph of cities represented by nodes and roads represented by connections. The dfs() functions are called on every node and their respective parents, and the result stores the minimum number of edges that should be changed.\n\nInitially, the graph is created with each city having a list of its neighboring cities (bi-directional). The DFS algorithm starts traversing the graph from city 0 and recursively visits its neighboring nodes, and the edges that need to be adjusted are kept track of with the 'count' variable.\n\nWhenever DFS encounters a city with a direct road towards city 0, 1 is added to the count. The minimum number of required edge changes will be the value of count. The final answer returned is the count of edges needed to be changed for all cities to reach city 0.\n    ",
        "js": "\n    ```javascript\nfunction dfs(node, parent, graph, count) {\n    if (node !== 0 && parent === 0) count[0]++;\n    \n    for (let neighbor of graph[node]) {\n        if (neighbor !== parent) {\n            dfs(neighbor, node, graph, count);\n        }\n    }\n}\n\nfunction minReorder(n, connections) {\n    const graph = Array.from({length: n}, () => []);\n    for (const [a, b] of connections) {\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n\n    const count = [0];\n    dfs(0, -1, graph, count);\n    return count[0];\n}\n```\n    \n    The algorithm used in the code snippet uses a Depth-First Search (DFS) approach for traversing the given graph of cities represented by nodes and roads represented by connections. The dfs() functions are called on every node and their respective parents, and the result stores the minimum number of edges that should be changed.\n\nInitially, the graph is created with each city having a list of its neighboring cities (bi-directional). The DFS algorithm starts traversing the graph from city 0 and recursively visits its neighboring nodes, and the edges that need to be adjusted are kept track of with the 'count' variable.\n\nWhenever DFS encounters a city with a direct road towards city 0, 1 is added to the count. The minimum number of required edge changes will be the value of count. The final answer returned is the count of edges needed to be changed for all cities to reach city 0.\n    "
    },
    {
        "id": 251,
        "title": "Put Boxes Into the Warehouse II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labeled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.\n\nBoxes are put into the warehouse by the following rules:\n\n*   Boxes cannot be stacked.\n*   You can rearrange the insertion order of the boxes.\n*   Boxes can be pushed into the warehouse from **either side** (left or right)\n*   If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.\n\nReturn _the maximum number of boxes you can put into the warehouse._",
            "examples": [
                "**Example 1:**\n\n**Input:** boxes = \\[1,2,2,3,4\\], warehouse = \\[3,4,1,2\\]\n**Output:** 4\n**Explanation:**\n \nWe can store the boxes in the following order:\n1- Put the yellow box in room 2 from either the left or right side.\n2- Put the orange box in room 3 from the right side.\n3- Put the green box in room 1 from the left side.\n4- Put the red box in room 0 from the left side.\nNotice that there are other valid ways to put 4 boxes such as swapping the red and green boxes or the red and orange boxes.\n\n",
                "**Example 2:**\n\n**Input:** boxes = \\[3,5,5,2\\], warehouse = \\[2,1,3,4,5\\]\n**Output:** 3\n**Explanation:**\n \nIt is not possible to put the two boxes of height 5 in the warehouse since there's only 1 room of height >= 5.\nOther valid solutions are to put the green box in room 2 or to put the orange box first in room 2 before putting the green and red boxes."
            ],
            "constraints": "**Constraints:**\n\n*   `n == warehouse.length`\n*   `1 <= boxes.length, warehouse.length <= 105`\n*   `1 <= boxes[i], warehouse[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,2,3,4],[3,4,1,2]",
                "output": "4"
            },
            {
                "input": "[3,5,5,2],[2,1,3,4,5]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int[] shuffle(int[] nums, int n) {\n    int[] shuffled = new int[nums.length];\n    for(int i = 0; i < n; i++) {\n        shuffled[2*i] = nums[i];\n        shuffled[2*i+1] = nums[i+n];\n    }\n    return shuffled;\n}\n```\n\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    ",
        "python": "\n    ```python\ndef shuffle(nums, n):\n    shuffled = []\n    for i in range(n):\n        shuffled.append(nums[i])\n        shuffled.append(nums[i+n])\n    return shuffled\n```\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvector<int> shuffle(vector<int>& nums, int n) {\n    vector<int> shuffled;\n    for(int i = 0; i < n; ++i) {\n        shuffled.push_back(nums[i]);\n        shuffled.push_back(nums[i+n]);\n    }\n    return shuffled;\n}\n```\n\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    ",
        "js": "\n    ```javascript\nfunction shuffle(nums, n) {\n    const shuffled = [];\n    for(let i = 0; i < n; i++) {\n        shuffled.push(nums[i]);\n        shuffled.push(nums[i+n]);\n    }\n    return shuffled;\n}\n```\n    \n    The algorithm for solving this problem is quite simple:\n1. Initialize an empty array called \"shuffled\" to store the shuffled elements.\n2. Iterate through the first n elements of the input array (nums).\n3. For each element at index i, add nums[i] and nums[i+n] to the \"shuffled\" array in that order.\n4. Return the \"shuffled\" array.\n    "
    },
    {
        "id": 252,
        "title": "Binary Search Tree Iterator II",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST):\n\n*   `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n*   `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n*   `int next()` Moves the pointer to the right, then returns the number at the pointer.\n*   `boolean hasPrev()` Returns `true` if there exists a number in the traversal to the left of the pointer, otherwise returns `false`.\n*   `int prev()` Moves the pointer to the left, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\n\nYou may assume that `next()` and `prev()` calls will always be valid. That is, there will be at least a next/previous number in the in-order traversal when `next()`/`prev()` is called.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"BSTIterator \",  \"next \",  \"next \",  \"prev \",  \"next \",  \"hasNext \",  \"next \",  \"next \",  \"next \",  \"hasNext \",  \"hasPrev \",  \"prev \",  \"prev \"\\]\n\\[\\[\\[7, 3, 15, null, null, 9, 20\\]\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\]\\]\n**Output**\n\\[null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9\\]\n\n**Explanation**\n// The underlined element is where the pointer currently is.\nBSTIterator bSTIterator = new BSTIterator(\\[7, 3, 15, null, null, 9, 20\\]); // state is  \\[3, 7, 9, 15, 20\\]\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 3\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 7\nbSTIterator.prev(); // state becomes \\[3, 7, 9, 15, 20\\], return 3\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 7\nbSTIterator.hasNext(); // return true\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 9\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 15\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 20\nbSTIterator.hasNext(); // return false\nbSTIterator.hasPrev(); // return true\nbSTIterator.prev(); // state becomes \\[3, 7, 9, 15, 20\\], return 15\nbSTIterator.prev(); // state becomes \\[3, 7, 9, 15, 20\\], return 9"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 105]`.\n*   `0 <= Node.val <= 106`\n*   At most `105` calls will be made to `hasNext`, `next`, `hasPrev`, and `prev`.\n\n**",
            "follow_up": "Follow up:** Could you solve the problem without precalculating the values of the tree?"
        },
        "tag": [],
        "example": [
            {
                "input": "]\n]],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null]]",
                "output": "**Output**\n[null,3,7,3,7,true,9,15,20,false,true,15,9]"
            }
        ],
        "java": "\n    ```java\npublic int findMaxLength(int[] nums) {\n    int max_length = 0, zeroes = 0, ones = 0;\n    HashMap<Integer, Integer> count_map = new HashMap<>();\n    count_map.put(0, -1);\n\n    for(int i = 0; i < nums.length; ++i) {\n        if(nums[i] == 0)\n            zeroes++;\n        else\n            ones++;\n\n        if(!count_map.containsKey(zeroes - ones))\n            count_map.put(zeroes - ones, i);\n        else\n            max_length = Math.max(max_length, i - count_map.get(zeroes - ones));\n    }\n    return max_length;\n}\n```\n    \n    The algorithm uses a hashmap `count_map` to store the difference between the counts of 0's and 1's encountered in the array. We iterate through the input binary array `nums`, and for each element, we update the count of 0's and the count of 1's.\n\nIf the difference `(zeroes - ones)` is not present in the hashmap, we store it along with its index `i`. If the difference is already present in the hashmap, it means that we have found a subarray where 0's and 1's occur with a balanced frequency. We then update the maximum length of such a subarray if the difference with the stored index is larger than the current max_length.\n\nThe algorithm returns the max_length of balanced subarrays after iteration, accounting for the single element deletion, as it inherently checks for subarrays with equal numbers of 1's and 0's.\n    ",
        "python": "\n    ```python\ndef findMaxLength(nums):\n    max_length, zeroes, ones = 0, 0, 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num == 0:\n            zeroes += 1\n        else:\n            ones += 1\n\n        if zeroes - ones not in count_map:\n            count_map[zeroes - ones] = i\n        else:\n            max_length = max(max_length, i - count_map[zeroes - ones])\n\n    return max_length\n```\n    \n    The algorithm uses a hashmap `count_map` to store the difference between the counts of 0's and 1's encountered in the array. We iterate through the input binary array `nums`, and for each element, we update the count of 0's and the count of 1's.\n\nIf the difference `(zeroes - ones)` is not present in the hashmap, we store it along with its index `i`. If the difference is already present in the hashmap, it means that we have found a subarray where 0's and 1's occur with a balanced frequency. We then update the maximum length of such a subarray if the difference with the stored index is larger than the current max_length.\n\nThe algorithm returns the max_length of balanced subarrays after iteration, accounting for the single element deletion, as it inherently checks for subarrays with equal numbers of 1's and 0's.\n    ",
        "c++": "\n    ```cpp\nint findMaxLength(vector<int>& nums) {\n    int max_length = 0, zeroes = 0, ones = 0;\n    unordered_map<int, int> count_map;\n    count_map[0] = -1;\n\n    for(int i = 0; i < nums.size(); ++i) {\n        if(nums[i] == 0)\n            zeroes++;\n        else\n            ones++;\n\n        if(count_map.count(zeroes - ones) == 0)\n            count_map[zeroes - ones] = i;\n        else\n            max_length = max(max_length, i - count_map[zeroes - ones]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm uses a hashmap `count_map` to store the difference between the counts of 0's and 1's encountered in the array. We iterate through the input binary array `nums`, and for each element, we update the count of 0's and the count of 1's.\n\nIf the difference `(zeroes - ones)` is not present in the hashmap, we store it along with its index `i`. If the difference is already present in the hashmap, it means that we have found a subarray where 0's and 1's occur with a balanced frequency. We then update the maximum length of such a subarray if the difference with the stored index is larger than the current max_length.\n\nThe algorithm returns the max_length of balanced subarrays after iteration, accounting for the single element deletion, as it inherently checks for subarrays with equal numbers of 1's and 0's.\n    ",
        "js": "\n    ```javascript\nfunction findMaxLength(nums) {\n    let max_length = 0, zeroes = 0, ones = 0;\n    let count_map = new Map();\n    count_map.set(0, -1);\n\n    for(let i = 0; i < nums.length; ++i) {\n        if(nums[i] === 0)\n            zeroes++;\n        else\n            ones++;\n\n        if(!count_map.has(zeroes - ones))\n            count_map.set(zeroes - ones, i);\n        else\n            max_length = Math.max(max_length, i - count_map.get(zeroes - ones));\n    }\n    return max_length;\n}\n```\n    \n    The algorithm uses a hashmap `count_map` to store the difference between the counts of 0's and 1's encountered in the array. We iterate through the input binary array `nums`, and for each element, we update the count of 0's and the count of 1's.\n\nIf the difference `(zeroes - ones)` is not present in the hashmap, we store it along with its index `i`. If the difference is already present in the hashmap, it means that we have found a subarray where 0's and 1's occur with a balanced frequency. We then update the maximum length of such a subarray if the difference with the stored index is larger than the current max_length.\n\nThe algorithm returns the max_length of balanced subarrays after iteration, accounting for the single element deletion, as it inherently checks for subarrays with equal numbers of 1's and 0's.\n    "
    },
    {
        "id": 253,
        "title": "Build Binary Expression Tree From Infix Expression",
        "difficulty": "Hard",
        "content": {
            "problem": "A **[binary expression tree](https://en.wikipedia.org/wiki/Binary_expression_tree)** is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators `'+'` (addition), `'-'` (subtraction), `'*'` (multiplication), and `'/'` (division).\n\nFor each internal node with operator `o`, the [**infix expression**](https://en.wikipedia.org/wiki/Infix_notation) it represents is `(A o B)`, where `A` is the expression the left subtree represents and `B` is the expression the right subtree represents.\n\nYou are given a string `s`, an **infix expression** containing operands, the operators described above, and parentheses `'('` and `')'`.\n\nReturn _any valid **binary expression tree**, whose **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** reproduces_ `s` _after omitting the parenthesis from it._\n\n**Please note that order of operations applies in** `s`**.** That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction.\n\nOperands must also appear in the **same order** in both `s` and the in-order traversal of the tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"3\\*4-2\\*5 \"\n**Output:** \\[-,\\*,\\*,3,4,2,5\\]\n**Explanation:** The tree above is the only valid tree whose inorder traversal produces s.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"2-3/(5\\*2)+1 \"\n**Output:** \\[+,-,1,2,/,null,null,null,null,3,\\*,null,null,5,2\\]\n**Explanation:** The inorder traversal of the tree above is 2-3/5\\*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s.\nThe tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value.\n \nThe third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s.\n \n\n",
                "**Example 3:**\n\n**Input:** s =  \"1+2+3+4+5 \"\n**Output:** \\[+,+,5,+,4,null,null,+,3,null,null,1,2\\]\n**Explanation:** The tree \\[+,+,5,+,+,null,null,1,2,3,4\\] is also one of many other valid trees."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of digits and the characters `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Operands in `s` are **exactly** 1 digit.\n*   It is guaranteed that `s` is a valid expression.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"3*4-2*5\"",
                "output": "[-,*,*,3,4,2,5]"
            },
            {
                "input": "\"2-3/(5*2)+1\"",
                "output": "[+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]"
            },
            {
                "input": "\"1+2+3+4+5\"",
                "output": "[+,+,5,+,4,null,null,+,3,null,null,1,2]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public TreeNode expTree(String s) {\n        Stack<TreeNode> nodes = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n        for (int i = 0; i < s.length(); ++i) {\n            if (Character.isDigit(s.charAt(i))) {\n                nodes.push(new TreeNode(s.charAt(i)));\n            } else if (s.charAt(i) == '(') {\n                ops.push(s.charAt(i));\n            } else if (s.charAt(i) == ')') {\n                while (ops.peek() != '(') {\n                    process(nodes, ops);\n                }\n                ops.pop();\n            } else {\n                while (!ops.empty() && precedence(ops.peek(), s.charAt(i))) {\n                    process(nodes, ops);\n                }\n                ops.push(s.charAt(i));\n            }\n        }\n        while (!ops.empty()) {\n            process(nodes, ops);\n        }\n        return nodes.peek();\n    }\n    \n    private boolean precedence(char a, char b) {\n        if (a == '(') return false;\n        if (b == '(' || b == ')') return true;\n        if ((a == '*' || a == '/') && (b == '+' || b == '-')) return true;\n        return false;\n    }\n    \n    private void process(Stack<TreeNode> nodes, Stack<Character> ops) {\n        TreeNode right = nodes.pop();\n        TreeNode left = nodes.pop();\n        TreeNode oper = new TreeNode(ops.pop());\n        oper.left = left;\n        oper.right = right;\n        nodes.push(oper);\n    }\n}\n```\n    \n    This solution follows the algorithm of the well-known Shunting Yard algorithm. We process the input string `s` character by character. \n\n1. If the character `s[i]` is a digit, create a `TreeNode` with the value and push it to the `nodes` stack.\n2. If the character is an opening parenthesis, push it to the `ops` stack.\n3. If the character is a closing parenthesis, pop the operators from the `ops` stack and process them with the corresponding `TreeNode` operands until an opening parenthesis is found. Then, pop the opening parenthesis.\n4. If the character is an operator (+, -, *, or /), pop the operators from the `ops` stack and process them with the corresponding operands until there is a lower precedence operator on the top or the stack is empty. Finally, push the current operator onto the `ops` stack.\n\nAfter processing all characters in the input string `s`, process the remaining operators left in the `ops` stack.\n\nThe Shunting Yard algorithm guarantees that the resulting expression tree will have the correct precedence and associativity rules applied.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def expTree(self, s: str) -> 'Node':\n        def precedence(a, b):\n            if a == '(':\n                return False\n            if b == '(' or b == ')':\n                return True\n            if (a in {'*', '/'}) and (b in {'+', '-'}):\n                return True\n            return False\n        \n        def process(nodes, ops):\n            right = nodes.pop()\n            left = nodes.pop()\n            oper = Node(ops.pop())\n            oper.left = left\n            oper.right = right\n            nodes.append(oper)\n            \n        nodes = []\n        ops = []\n        for i in s:\n            if i.isdigit():\n                nodes.append(Node(i))\n            elif i == '(':\n                ops.append(i)\n            elif i == ')':\n                while ops[-1] != '(':\n                    process(nodes, ops)\n                ops.pop()\n            else:\n                while ops and precedence(ops[-1], i):\n                    process(nodes, ops)\n                ops.append(i)\n        while ops:\n            process(nodes, ops)\n        return nodes[0]\n```\n    \n    This solution follows the algorithm of the well-known Shunting Yard algorithm. We process the input string `s` character by character. \n\n1. If the character `s[i]` is a digit, create a `TreeNode` with the value and push it to the `nodes` stack.\n2. If the character is an opening parenthesis, push it to the `ops` stack.\n3. If the character is a closing parenthesis, pop the operators from the `ops` stack and process them with the corresponding `TreeNode` operands until an opening parenthesis is found. Then, pop the opening parenthesis.\n4. If the character is an operator (+, -, *, or /), pop the operators from the `ops` stack and process them with the corresponding operands until there is a lower precedence operator on the top or the stack is empty. Finally, push the current operator onto the `ops` stack.\n\nAfter processing all characters in the input string `s`, process the remaining operators left in the `ops` stack.\n\nThe Shunting Yard algorithm guarantees that the resulting expression tree will have the correct precedence and associativity rules applied.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\npublic:\n    struct TreeNode {\n        char val;\n        TreeNode* left;\n        TreeNode* right;\n        TreeNode(char x) : val(x), left(NULL), right(NULL) {}\n    };\n    \n    TreeNode* expTree(string s) {\n        stack<TreeNode*> nodes;\n        stack<char> ops;\n        for (int i = 0; i < s.size(); ++i) {\n            if (isdigit(s[i])) {\n                nodes.push(new TreeNode(s[i]));\n            } else if (s[i] == '(') {\n                ops.push(s[i]);\n            } else if (s[i] == ')') {\n                while (ops.top() != '(') {\n                    process(nodes, ops);\n                }\n                ops.pop();\n            } else {\n                while (!ops.empty() && precedence(ops.top(), s[i])) {\n                    process(nodes, ops);\n                }\n                ops.push(s[i]);\n            }\n        }\n        while (!ops.empty()) {\n            process(nodes, ops);\n        }\n        return nodes.top();\n    }\n    \n    bool precedence(char a, char b) {\n        if (a == '(') return false;\n        if (b == '(' || b == ')') return true;\n        if ((a == '*' || a == '/') && (b == '+' || b == '-')) return true;\n        return false;\n    }\n    \n    void process(stack<TreeNode*>& nodes, stack<char>& ops) {\n        TreeNode* right = nodes.top(); nodes.pop();\n        TreeNode* left = nodes.top(); nodes.pop();\n        TreeNode* oper = new TreeNode(ops.top()); ops.pop();\n        oper->left = left;\n        oper->right = right;\n        nodes.push(oper);\n    }\n};\n```\n    \n    This solution follows the algorithm of the well-known Shunting Yard algorithm. We process the input string `s` character by character. \n\n1. If the character `s[i]` is a digit, create a `TreeNode` with the value and push it to the `nodes` stack.\n2. If the character is an opening parenthesis, push it to the `ops` stack.\n3. If the character is a closing parenthesis, pop the operators from the `ops` stack and process them with the corresponding `TreeNode` operands until an opening parenthesis is found. Then, pop the opening parenthesis.\n4. If the character is an operator (+, -, *, or /), pop the operators from the `ops` stack and process them with the corresponding operands until there is a lower precedence operator on the top or the stack is empty. Finally, push the current operator onto the `ops` stack.\n\nAfter processing all characters in the input string `s`, process the remaining operators left in the `ops` stack.\n\nThe Shunting Yard algorithm guarantees that the resulting expression tree will have the correct precedence and associativity rules applied.\n    ",
        "js": "\n    ```javascript\nvar expTree = function(s) {\n    function precedence(a, b) {\n        if (a === '(') return false;\n        if (b === '(' || b === ')') return true;\n        if (('*/'.includes(a)) && ('+-'.includes(b))) return true;\n        return false;\n    }\n    \n    function process(nodes, ops) {\n        const right = nodes.pop();\n        const left = nodes.pop();\n        const oper = new TreeNode(ops.pop());\n        oper.left = left;\n        oper.right = right;\n        nodes.push(oper);\n    }\n    \n    const nodes = [];\n    const ops = [];\n    for (let i = 0; i < s.length; ++i) {\n        if (s[i] >= '0' && s[i] <= '9') {\n            nodes.push(new TreeNode(s[i]));\n        } else if (s[i] === '(') {\n            ops.push(s[i]);\n        } else if (s[i] === ')') {\n            while (ops[ops.length - 1] !== '(') {\n                process(nodes, ops);\n            }\n            ops.pop();\n        } else {\n            while (ops.length && precedence(ops[ops.length - 1], s[i])) {\n                process(nodes, ops);\n            }\n            ops.push(s[i]);\n        }\n    }\n    while (ops.length) {\n        process(nodes, ops);\n    }\n    return nodes[0];\n};\n```\n    \n    This solution follows the algorithm of the well-known Shunting Yard algorithm. We process the input string `s` character by character. \n\n1. If the character `s[i]` is a digit, create a `TreeNode` with the value and push it to the `nodes` stack.\n2. If the character is an opening parenthesis, push it to the `ops` stack.\n3. If the character is a closing parenthesis, pop the operators from the `ops` stack and process them with the corresponding `TreeNode` operands until an opening parenthesis is found. Then, pop the opening parenthesis.\n4. If the character is an operator (+, -, *, or /), pop the operators from the `ops` stack and process them with the corresponding operands until there is a lower precedence operator on the top or the stack is empty. Finally, push the current operator onto the `ops` stack.\n\nAfter processing all characters in the input string `s`, process the remaining operators left in the `ops` stack.\n\nThe Shunting Yard algorithm guarantees that the resulting expression tree will have the correct precedence and associativity rules applied.\n    "
    },
    {
        "id": 254,
        "title": "Find Nearest Right Node in Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree and a node `u` in the tree, return _the **nearest** node on the **same level** that is to the **right** of_ `u`_, or return_ `null` _if_ `u` _is the rightmost node in its level_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,null,4,5,6\\], u = 4\n**Output:** 5\n**Explanation:** The nearest node on the same level to the right of node 4 is node 5.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,null,4,2\\], u = 2\n**Output:** null\n**Explanation:** There are no nodes to the right of 2."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 105]`.\n*   `1 <= Node.val <= 105`\n*   All values in the tree are **distinct**.\n*   `u` is a node in the binary tree rooted at `root`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,null,4,5,6],4",
                "output": "5"
            },
            {
                "input": "[3,null,4,2],2",
                "output": "null"
            }
        ],
        "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic TreeNode findNearestRightNode(TreeNode root, TreeNode u) {\n    if (root == null) return null;\n    \n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n    \n    while (!q.isEmpty()) {\n        int n = q.size();\n        \n        for (int i = 0; i < n; i++) {\n            TreeNode current = q.poll();\n            \n            if (current == u) {\n                return i < n - 1 ? q.peek() : null;\n            }\n            \n            if (current.left != null) q.add(current.left);\n            if (current.right != null) q.add(current.right);\n        }\n    }\n    \n    return null;\n}\n```\n    \n    The algorithm is based on level-order traversal (breadth-first search). We use a queue to traverse the tree nodes level by level.\n\n1. We first check if the root is not null, otherwise, return null.\n2. Initialize an empty queue and push the root node into it.\n3. While the queue is not empty, we start a loop:\n   1. Store the current size of the queue (n).\n   2. Loop through the nodes in the current level (from 0 to n).\n      1. Pop the front node from the queue (current).\n      2. Check if this node is equal to the target node (u).\n         1. If yes, return the next node in the queue if the current node is not the last node in the level. Otherwise, return null.\n      3. If the current node has any left and/or right child, push them into the queue.\n4. If we finished traversing the tree and didn't find any nearest node, return null.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_nearest_right_node(root, u):\n    if not root:\n        return None\n    \n    q = [root]\n    \n    while q:\n        n = len(q)\n        \n        for i in range(n):\n            current = q.pop(0)\n            \n            if current == u:\n                return q[0] if i < n - 1 else None\n            \n            if current.left:\n                q.append(current.left)\n            if current.right:\n                q.append(current.right)\n    \n    return None\n```\n    \n    The algorithm is based on level-order traversal (breadth-first search). We use a queue to traverse the tree nodes level by level.\n\n1. We first check if the root is not null, otherwise, return null.\n2. Initialize an empty queue and push the root node into it.\n3. While the queue is not empty, we start a loop:\n   1. Store the current size of the queue (n).\n   2. Loop through the nodes in the current level (from 0 to n).\n      1. Pop the front node from the queue (current).\n      2. Check if this node is equal to the target node (u).\n         1. If yes, return the next node in the queue if the current node is not the last node in the level. Otherwise, return null.\n      3. If the current node has any left and/or right child, push them into the queue.\n4. If we finished traversing the tree and didn't find any nearest node, return null.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nTreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\n    if (!root) return nullptr;\n    \n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    while (!q.empty()) {\n        int n = q.size();\n        \n        for (int i = 0; i < n; i++) {\n            TreeNode* current = q.front();\n            q.pop();\n            \n            if (current == u) {\n                return i < n - 1 ? q.front() : nullptr;\n            }\n            \n            if (current->left) q.push(current->left);\n            if (current->right) q.push(current->right);\n        }\n    }\n    \n    return nullptr;\n}\n```\n    \n    The algorithm is based on level-order traversal (breadth-first search). We use a queue to traverse the tree nodes level by level.\n\n1. We first check if the root is not null, otherwise, return null.\n2. Initialize an empty queue and push the root node into it.\n3. While the queue is not empty, we start a loop:\n   1. Store the current size of the queue (n).\n   2. Loop through the nodes in the current level (from 0 to n).\n      1. Pop the front node from the queue (current).\n      2. Check if this node is equal to the target node (u).\n         1. If yes, return the next node in the queue if the current node is not the last node in the level. Otherwise, return null.\n      3. If the current node has any left and/or right child, push them into the queue.\n4. If we finished traversing the tree and didn't find any nearest node, return null.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction findNearestRightNode(root, u) {\n  if (!root) return null;\n\n  const q = [root];\n\n  while (q.length > 0) {\n    const n = q.length;\n\n    for (let i = 0; i < n; i++) {\n      const current = q.shift();\n\n      if (current === u) {\n        return i < n - 1 ? q[0] : null;\n      }\n\n      if (current.left) q.push(current.left);\n      if (current.right) q.push(current.right);\n    }\n  }\n\n  return null;\n}\n```\n    \n    The algorithm is based on level-order traversal (breadth-first search). We use a queue to traverse the tree nodes level by level.\n\n1. We first check if the root is not null, otherwise, return null.\n2. Initialize an empty queue and push the root node into it.\n3. While the queue is not empty, we start a loop:\n   1. Store the current size of the queue (n).\n   2. Loop through the nodes in the current level (from 0 to n).\n      1. Pop the front node from the queue (current).\n      2. Check if this node is equal to the target node (u).\n         1. If yes, return the next node in the queue if the current node is not the last node in the level. Otherwise, return null.\n      3. If the current node has any left and/or right child, push them into the queue.\n4. If we finished traversing the tree and didn't find any nearest node, return null.\n    "
    },
    {
        "id": 255,
        "title": "Check If Two Expression Trees are Equivalent",
        "difficulty": "Medium",
        "content": {
            "problem": "A **[binary expression tree](https://en.wikipedia.org/wiki/Binary_expression_tree)** is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the `'+'` operator (i.e. addition).\n\nYou are given the roots of two binary expression trees, `root1` and `root2`. Return `true` _if the two binary expression trees are equivalent_. Otherwise, return `false`.\n\nTwo binary expression trees are equivalent if they **evaluate to the same value** regardless of what the variables are set to.",
            "examples": [
                "**Example 1:**\n\n**Input:** root1 = \\[x\\], root2 = \\[x\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root1 = \\[+,a,+,null,null,b,c\\], root2 = \\[+,+,a,b,c\\]\n**Output:** true\n**Explaination:** `a + (b + c) == (b + c) + a`\n\n",
                "**Example 3:**\n\n**Input:** root1 = \\[+,a,+,null,null,b,c\\], root2 = \\[+,+,a,b,d\\]\n**Output:** false\n**Explaination:** `a + (b + c) != (b + d) + a`"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in both trees are equal, odd and, in the range `[1, 4999]`.\n*   `Node.val` is `'+'` or a lower-case English letter.\n*   It's **guaranteed** that the tree given is a valid binary expression tree.\n\n**",
            "follow_up": "Follow up:** What will you change in your solution if the tree also supports the `'-'` operator (i.e. subtraction)?"
        },
        "tag": [],
        "example": [
            {
                "input": "[x],[x]",
                "output": "true"
            },
            {
                "input": "[+,a,+,null,null,b,c],[+,+,a,b,c]",
                "output": "true\n**Explaination:**`a+(b+c)==(b+c)+a`"
            },
            {
                "input": "[+,a,+,null,null,b,c],[+,+,a,b,d]",
                "output": "false\n**Explaination:**`a+(b+c)!=(b+d)+a`"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] avoidFlood(int[] rains) {\n        int[] res = new int[rains.length];\n        Arrays.fill(res, -1);\n        Map<Integer, Integer> filledLakes = new HashMap<>();\n        TreeSet<Integer> dryDays = new TreeSet<>();\n\n        for (int i = 0; i < rains.length; i++) {\n            if (rains[i] == 0) {\n                dryDays.add(i);\n            } else {\n                int lake = rains[i];\n                if (filledLakes.containsKey(lake)) {\n                    Integer day = dryDays.ceiling(filledLakes.get(lake));\n                    if (day == null) return new int[0];\n                    res[day] = lake;\n                    dryDays.remove(day);\n                }\n                filledLakes.put(lake, i);\n            }\n        }\n\n        for (int day : dryDays) {\n            res[day] = 1;\n        }\n\n        return res;\n    }\n}\n```\n\n    \n    1. Initialize a result array with the same length as rains, filled with -1. Create a map for filled lakes and a set for dry days.\n2. Loop through rains array:\n   - If the rain amount is 0, add the current day to dry days set.\n   - Otherwise, check if the lake is already filled:\n     - If it is, find a dry day after the lake was filled last time. If no valid dry day is found, return an empty array.\n     - Update the result array with the current lake number on the found dry day, then remove this day from the dry days set.\n   - Update the filled lakes map with the current day.\n3. Loop through the remaining dry days and set the result array with 1 on those days.\n4. Return the result array.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedSet\n\ndef avoidFlood(rains: List[int]) -> List[int]:\n    res = [-1] * len(rains)\n    filled_lakes = {}\n    dry_days = SortedSet()\n\n    for i, lake in enumerate(rains):\n        if lake == 0:\n            dry_days.add(i)\n        else:\n            if lake in filled_lakes:\n                day = dry_days.ceiling(filled_lakes[lake])\n                if day is None:\n                    return []\n                res[day] = lake\n                dry_days.remove(day)\n            filled_lakes[lake] = i\n\n    for day in dry_days:\n        res[day] = 1\n\n    return res\n```\n\n    \n    1. Initialize a result array with the same length as rains, filled with -1. Create a map for filled lakes and a set for dry days.\n2. Loop through rains array:\n   - If the rain amount is 0, add the current day to dry days set.\n   - Otherwise, check if the lake is already filled:\n     - If it is, find a dry day after the lake was filled last time. If no valid dry day is found, return an empty array.\n     - Update the result array with the current lake number on the found dry day, then remove this day from the dry days set.\n   - Update the filled lakes map with the current day.\n3. Loop through the remaining dry days and set the result array with 1 on those days.\n4. Return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <unordered_map>\n\nstd::vector<int> avoidFlood(std::vector<int>& rains) {\n    std::vector<int> res(rains.size(), -1);\n    std::unordered_map<int, int> filled_lakes;\n    std::set<int> dry_days;\n\n    for (int i = 0; i < rains.size(); ++i) {\n        if (rains[i] == 0) {\n            dry_days.insert(i);\n        } else {\n            int lake = rains[i];\n            if (filled_lakes.count(lake)) {\n                auto it = dry_days.lower_bound(filled_lakes[lake]);\n                if (it == dry_days.end()) return {};\n                res[*it] = lake;\n                dry_days.erase(it);\n            }\n            filled_lakes[lake] = i;\n        }\n    }\n    \n    for (int day : dry_days) {\n        res[day] = 1;\n    }\n\n    return res;\n}\n```\n\n    \n    1. Initialize a result array with the same length as rains, filled with -1. Create a map for filled lakes and a set for dry days.\n2. Loop through rains array:\n   - If the rain amount is 0, add the current day to dry days set.\n   - Otherwise, check if the lake is already filled:\n     - If it is, find a dry day after the lake was filled last time. If no valid dry day is found, return an empty array.\n     - Update the result array with the current lake number on the found dry day, then remove this day from the dry days set.\n   - Update the filled lakes map with the current day.\n3. Loop through the remaining dry days and set the result array with 1 on those days.\n4. Return the result array.\n    ",
        "js": "\n    ```javascript\nfunction avoidFlood(rains) {\n    const res = new Array(rains.length).fill(-1);\n    const filledLakes = new Map();\n    const dryDays = new Set();\n\n    for (let i = 0; i < rains.length; i++) {\n        if (rains[i] === 0) {\n            dryDays.add(i);\n        } else {\n            const lake = rains[i];\n            if (filledLakes.has(lake)) {\n                const day = [...dryDays].find(d => d > filledLakes.get(lake));\n                if (day === undefined) return [];\n                res[day] = lake;\n                dryDays.delete(day);\n            }\n            filledLakes.set(lake, i);\n        }\n    }\n\n    for (const day of dryDays) {\n        res[day] = 1;\n    }\n\n    return res;\n}\n```\n\n    \n    1. Initialize a result array with the same length as rains, filled with -1. Create a map for filled lakes and a set for dry days.\n2. Loop through rains array:\n   - If the rain amount is 0, add the current day to dry days set.\n   - Otherwise, check if the lake is already filled:\n     - If it is, find a dry day after the lake was filled last time. If no valid dry day is found, return an empty array.\n     - Update the result array with the current lake number on the found dry day, then remove this day from the dry days set.\n   - Update the filled lakes map with the current day.\n3. Loop through the remaining dry days and set the result array with 1 on those days.\n4. Return the result array.\n    "
    },
    {
        "id": 256,
        "title": "Maximum Font to Fit a Sentence in a Screen",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `text`. We want to display `text` on a screen of width `w` and height `h`. You can choose any font size from array `fonts`, which contains the available font sizes **in ascending order**.\n\nYou can use the `FontInfo` interface to get the width and height of any character at any available font size.\n\nThe `FontInfo` interface is defined as such:\n\ninterface FontInfo {\n  // Returns the width of character ch on the screen using font size fontSize.\n  // O(1) per call\n  public int getWidth(int fontSize, char ch);\n\n  // Returns the height of any character on the screen using font size fontSize.\n  // O(1) per call\n  public int getHeight(int fontSize);\n}\n\nThe calculated width of `text` for some `fontSize` is the **sum** of every `getWidth(fontSize, text[i])` call for each `0 <= i < text.length` (**0-indexed**). The calculated height of `text` for some `fontSize` is `getHeight(fontSize)`. Note that `text` is displayed on a **single line**.\n\nIt is guaranteed that `FontInfo` will return the same value if you call `getHeight` or `getWidth` with the same parameters.\n\nIt is also guaranteed that for any font size `fontSize` and any character `ch`:\n\n*   `getHeight(fontSize) <= getHeight(fontSize+1)`\n*   `getWidth(fontSize, ch) <= getWidth(fontSize+1, ch)`\n\nReturn _the maximum font size you can use to display_ `text` _on the screen_. If `text` cannot fit on the display with any font size, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"helloworld \", w = 80, h = 20, fonts = \\[6,8,10,12,14,16,18,24,36\\]\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** text =  \"leetcode \", w = 1000, h = 50, fonts = \\[1,2,4\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** text =  \"easyquestion \", w = 100, h = 100, fonts = \\[10,15,20,25\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 50000`\n*   `text` contains only lowercase English letters.\n*   `1 <= w <= 107`\n*   `1 <= h <= 104`\n*   `1 <= fonts.length <= 105`\n*   `1 <= fonts[i] <= 105`\n*   `fonts` is sorted in ascending order and does not contain duplicates.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"helloworld\",80,20,[6,8,10,12,14,16,18,24,36]",
                "output": "6"
            },
            {
                "input": "\"leetcode\",1000,50,[1,2,4]",
                "output": "4"
            },
            {
                "input": "\"easyquestion\",100,100,[10,15,20,25]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nint maxFontSize(String text, int w, int h, int[] fonts, FontInfo fontInfo) {\n    int left = 0, right = fonts.length - 1, mid, ans = -1;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        int fontSize = fonts[mid];\n        int width = 0, height = fontInfo.getHeight(fontSize);\n        for (char ch : text.toCharArray())\n            width += fontInfo.getWidth(fontSize, ch);\n        if (width <= w && height <= h) {\n            ans = fontSize;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    First, use a binary search to find the maximum valid font size in the `fonts` array since it is sorted in ascending order. The binary search is effective because we are searching for the maximum value of the fonts.\n\nWhen we are at the mid position on each iteration, we check whether the current font size can fit the entire text in the screen. To do this, we calculate the width and height of the entire text using the font size.\n\nIf the current font size meets the width and height requirement, we update the left pointer and store the current font size as the answer. Otherwise, we move the right pointer to the left.\n\nAfter the binary search finishes, the answer will be the maximum font size that can fit the entire text within the width and height of the screen. If no font size fits on the screen, the answer will remain -1.\n    ",
        "python": "\n    ```python\ndef max_font_size(text: str, w: int, h: int, fonts: List[int], font_info) -> int:\n    left, right, ans = 0, len(fonts) - 1, -1\n    while left <= right:\n        mid = left + (right - left) // 2\n        font_size = fonts[mid]\n        width, height = sum(font_info.getWidth(font_size, ch) for ch in text), font_info.getHeight(font_size)\n        if width <= w and height <= h:\n            ans = font_size\n            left = mid + 1\n        else:\n            right = mid - 1\n    return ans\n```\n    \n    First, use a binary search to find the maximum valid font size in the `fonts` array since it is sorted in ascending order. The binary search is effective because we are searching for the maximum value of the fonts.\n\nWhen we are at the mid position on each iteration, we check whether the current font size can fit the entire text in the screen. To do this, we calculate the width and height of the entire text using the font size.\n\nIf the current font size meets the width and height requirement, we update the left pointer and store the current font size as the answer. Otherwise, we move the right pointer to the left.\n\nAfter the binary search finishes, the answer will be the maximum font size that can fit the entire text within the width and height of the screen. If no font size fits on the screen, the answer will remain -1.\n    ",
        "c++": "\n    ```cpp\nint maxFontSize(string text, int w, int h, vector<int>& fonts, FontInfo fontInfo) {\n    int left = 0, right = fonts.size() - 1, mid, ans = -1;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        int fontSize = fonts[mid];\n        int width = 0, height = fontInfo.getHeight(fontSize);\n        for (char ch : text)\n            width += fontInfo.getWidth(fontSize, ch);\n        if (width <= w && height <= h) {\n            ans = fontSize;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    First, use a binary search to find the maximum valid font size in the `fonts` array since it is sorted in ascending order. The binary search is effective because we are searching for the maximum value of the fonts.\n\nWhen we are at the mid position on each iteration, we check whether the current font size can fit the entire text in the screen. To do this, we calculate the width and height of the entire text using the font size.\n\nIf the current font size meets the width and height requirement, we update the left pointer and store the current font size as the answer. Otherwise, we move the right pointer to the left.\n\nAfter the binary search finishes, the answer will be the maximum font size that can fit the entire text within the width and height of the screen. If no font size fits on the screen, the answer will remain -1.\n    ",
        "js": "\n    ```javascript\nfunction maxFontSize(text, w, h, fonts, fontInfo) {\n    let left = 0, right = fonts.length - 1, mid, ans = -1;\n    while (left <= right) {\n        mid = left + ((right - left) / 2) | 0;\n        let fontSize = fonts[mid];\n        let width = 0, height = fontInfo.getHeight(fontSize);\n        for (let ch of text)\n            width += fontInfo.getWidth(fontSize, ch);\n        if (width <= w && height <= h) {\n            ans = fontSize;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    First, use a binary search to find the maximum valid font size in the `fonts` array since it is sorted in ascending order. The binary search is effective because we are searching for the maximum value of the fonts.\n\nWhen we are at the mid position on each iteration, we check whether the current font size can fit the entire text in the screen. To do this, we calculate the width and height of the entire text using the font size.\n\nIf the current font size meets the width and height requirement, we update the left pointer and store the current font size as the answer. Otherwise, we move the right pointer to the left.\n\nAfter the binary search finishes, the answer will be the maximum font size that can fit the entire text within the width and height of the screen. If no font size fits on the screen, the answer will remain -1.\n    "
    },
    {
        "id": 257,
        "title": "Design an Expression Tree With Evaluate Function",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `postfix` tokens of an arithmetic expression, build and return _the binary expression tree that represents this expression._\n\n**Postfix** notation is a notation for writing arithmetic expressions in which the operands (numbers) appear before their operators. For example, the postfix tokens of the expression `4*(5-(7+2))` are represented in the array `postfix = [ \"4 \", \"5 \", \"7 \", \"2 \", \"+ \", \"- \", \"* \"]`.\n\nThe class `Node` is an interface you should use to implement the binary expression tree. The returned tree will be tested using the `evaluate` function, which is supposed to evaluate the tree's value. You should not remove the `Node` class; however, you can modify it as you wish, and you can define other classes to implement it if needed.\n\nA **[binary expression tree](https://en.wikipedia.org/wiki/Binary_expression_tree)** is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with two children) correspond to the operators `'+'` (addition), `'-'` (subtraction), `'*'` (multiplication), and `'/'` (division).\n\nIt's guaranteed that no subtree will yield a value that exceeds `109` in absolute value, and all the operations are valid (i.e., no division by zero).\n\n**Follow up:** Could you design the expression tree such that it is more modular? For example, is your design able to support additional operators without making changes to your existing `evaluate` implementation?",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \\[ \"3 \", \"4 \", \"+ \", \"2 \", \"\\* \", \"7 \", \"/ \"\\]\n**Output:** 2\n**Explanation:** this expression evaluates to the above binary tree with expression (`(3+4)*2)/7) = 14/7 = 2.`\n\n",
                "**Example 2:**\n\n**Input:** s = \\[ \"4 \", \"5 \", \"2 \", \"7 \", \"+ \", \"- \", \"\\* \"\\]\n**Output:** -16\n**Explanation:** this expression evaluates to the above binary tree with expression 4\\*(5-`(2+7)) = 4*(-4) = -16.`"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length < 100`\n*   `s.length` is odd.\n*   `s` consists of numbers and the characters `'+'`, `'-'`, `'*'`, and `'/'`.\n*   If `s[i]` is a number, its integer representation is no more than `105`.\n*   It is guaranteed that `s` is a valid expression.\n*   The absolute value of the result and intermediate values will not exceed `109`.\n*   It is guaranteed that no expression will include division by zero.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"3\",\"4\",\"+\",\"2\",\"*\",\"7\",\"/\"]",
                "output": "2"
            },
            {
                "input": "[\"4\",\"5\",\"2\",\"7\",\"+\",\"-\",\"*\"]",
                "output": "-16"
            }
        ],
        "java": "\n    ```java\npublic int numSubmat(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    int[][] dp = new int[m][n];\n    int count = 0;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 1) {\n                dp[i][j] = (j == 0) ? 1 : dp[i][j - 1] + 1;\n                int minWidth = dp[i][j];\n                for (int k = i; k >= 0; k--) {\n                    minWidth = Math.min(minWidth, dp[k][j]);\n                    count += minWidth;\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Create a DP matrix of the same dimensions as the given binary matrix, and a `count` variable.\n2. Loop through each cell of the binary matrix. If the cell contains a 1, update the DP matrix cell with either 1 if it's the first column, or add 1 to the value of the previous column in the same row.\n3. For each cell with a 1, iterate from its row to the first row, calculating the minimum width found in the DP matrix, and update the count with the minimum width.\n4. The final count value will be the number of submatrices containing all ones.\n    ",
        "python": "\n    ```python\ndef numSubmat(mat):\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    count = 0\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                dp[i][j] = (1 if j == 0 else dp[i][j - 1] + 1)\n                minWidth = dp[i][j]\n                for k in range(i, -1, -1):\n                    minWidth = min(minWidth, dp[k][j])\n                    count += minWidth\n\n    return count\n```\n    \n    1. Create a DP matrix of the same dimensions as the given binary matrix, and a `count` variable.\n2. Loop through each cell of the binary matrix. If the cell contains a 1, update the DP matrix cell with either 1 if it's the first column, or add 1 to the value of the previous column in the same row.\n3. For each cell with a 1, iterate from its row to the first row, calculating the minimum width found in the DP matrix, and update the count with the minimum width.\n4. The final count value will be the number of submatrices containing all ones.\n    ",
        "c++": "\n    ```cpp\nint numSubmat(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n    int count = 0;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 1) {\n                dp[i][j] = (j == 0) ? 1 : dp[i][j - 1] + 1;\n                int minWidth = dp[i][j];\n                for (int k = i; k >= 0; k--) {\n                    minWidth = min(minWidth, dp[k][j]);\n                    count += minWidth;\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Create a DP matrix of the same dimensions as the given binary matrix, and a `count` variable.\n2. Loop through each cell of the binary matrix. If the cell contains a 1, update the DP matrix cell with either 1 if it's the first column, or add 1 to the value of the previous column in the same row.\n3. For each cell with a 1, iterate from its row to the first row, calculating the minimum width found in the DP matrix, and update the count with the minimum width.\n4. The final count value will be the number of submatrices containing all ones.\n    ",
        "js": "\n    ```javascript\nfunction numSubmat(mat) {\n    const m = mat.length, n = mat[0].length;\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\n    let count = 0;\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (mat[i][j] === 1) {\n                dp[i][j] = (j === 0) ? 1 : dp[i][j - 1] + 1;\n                let minWidth = dp[i][j];\n                for (let k = i; k >= 0; k--) {\n                    minWidth = Math.min(minWidth, dp[k][j]);\n                    count += minWidth;\n                }\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. Create a DP matrix of the same dimensions as the given binary matrix, and a `count` variable.\n2. Loop through each cell of the binary matrix. If the cell contains a 1, update the DP matrix cell with either 1 if it's the first column, or add 1 to the value of the previous column in the same row.\n3. For each cell with a 1, iterate from its row to the first row, calculating the minimum width found in the DP matrix, and update the count with the minimum width.\n4. The final count value will be the number of submatrices containing all ones.\n    "
    },
    {
        "id": 258,
        "title": "Add Two Polynomials Represented as Linked Lists",
        "difficulty": "Medium",
        "content": {
            "problem": "A polynomial linked list is a special type of linked list where every node represents a term in a polynomial expression.\n\nEach node has three attributes:\n\n*   `coefficient`: an integer representing the number multiplier of the term. The coefficient of the term `**9**x4` is `9`.\n*   `power`: an integer representing the exponent. The power of the term `9x**4**` is `4`.\n*   `next`: a pointer to the next node in the list, or `null` if it is the last node of the list.\n\nFor example, the polynomial `5x3 + 4x - 7` is represented by the polynomial linked list illustrated below:\n\nThe polynomial linked list must be in its standard form: the polynomial must be in **strictly** descending order by its `power` value. Also, terms with a `coefficient` of `0` are omitted.\n\nGiven two polynomial linked list heads, `poly1` and `poly2`, add the polynomials together and return _the head of the sum of the polynomials_.\n\n**`PolyNode` format:**\n\nThe input/output format is as a list of `n` nodes, where each node is represented as its `[coefficient, power]`. For example, the polynomial `5x3 + 4x - 7` would be represented as: `[[5,3],[4,1],[-7,0]]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** poly1 = \\[\\[1,1\\]\\], poly2 = \\[\\[1,0\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,0\\]\\]\n**Explanation:** poly1 = x. poly2 = 1. The sum is x + 1.\n\n",
                "**Example 2:**\n\n**Input:** poly1 = \\[\\[2,2\\],\\[4,1\\],\\[3,0\\]\\], poly2 = \\[\\[3,2\\],\\[-4,1\\],\\[-1,0\\]\\]\n**Output:** \\[\\[5,2\\],\\[2,0\\]\\]\n**Explanation:** poly1 = 2x2 + 4x + 3. poly2 = 3x2 - 4x - 1. The sum is 5x2 + 2. Notice that we omit the  \"0x \" term.\n\n",
                "**Example 3:**\n\n**Input:** poly1 = \\[\\[1,2\\]\\], poly2 = \\[\\[-1,2\\]\\]\n**Output:** \\[\\]\n**Explanation:** The sum is 0. We return an empty list."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 104`\n*   `-109 <= PolyNode.coefficient <= 109`\n*   `PolyNode.coefficient != 0`\n*   `0 <= PolyNode.power <= 109`\n*   `PolyNode.power > PolyNode.next.power`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1]],[[1,0]]",
                "output": "[[1,1],[1,0]]"
            },
            {
                "input": "[[2,2],[4,1],[3,0]],[[3,2],[-4,1],[-1,0]]",
                "output": "[[5,2],[2,0]]"
            },
            {
                "input": "[[1,2]],[[-1,2]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nclass PolyNode {\n    int coefficient, power;\n    PolyNode next;\n    PolyNode(int c, int p) {\n        coefficient = c;\n        power = p;\n        next = null;\n    }\n}\n    \nPolyNode addPoly(PolyNode poly1, PolyNode poly2) {\n    PolyNode dummy = new PolyNode(0, 0);\n    PolyNode current = dummy;\n\n    while (poly1 != null && poly2 != null) {\n        if (poly1.power > poly2.power) {\n            current.next = poly1;\n            poly1 = poly1.next;\n        } else if (poly1.power < poly2.power) {\n            current.next = poly2;\n            poly2 = poly2.next;\n        } else {\n            int sum = poly1.coefficient + poly2.coefficient;\n            if (sum != 0) {\n                current.next = new PolyNode(sum, poly1.power);\n                current = current.next;\n            }\n            poly1 = poly1.next;\n            poly2 = poly2.next;\n        }\n        current = current.next;\n    }\n\n    if (poly1 != null) {\n        current.next = poly1;\n    } else {\n        current.next = poly2;\n    }\n    return dummy.next;\n}\n```\n\n    \n    The algorithm uses a dummy node to create a new linked list representing the sum of the given polynomials. A `current` pointer iterates through the polynomials, adding the terms with the same powers and appending it into the new linked list if the coefficient sum is not 0. Polynomials with different powers are simply appended into the new linked list. When one of the linked lists is finished, it simply appends the remaining nodes of the other list to the new linked list. Finally, return the `next` pointer of the dummy node as the head of the new linked list representing the sum of polynomials.\n    ",
        "python": "\n    ```python\nclass PolyNode:\n    def __init__(self, c: int, p: int, next: 'PolyNode' = None):\n        self.coefficient = c\n        self.power = p\n        self.next = next\n\ndef addPoly(poly1: PolyNode, poly2: PolyNode) -> PolyNode:\n    dummy = PolyNode(0, 0)\n    current = dummy\n\n    while poly1 and poly2:\n        if poly1.power > poly2.power:\n            current.next = poly1\n            poly1 = poly1.next\n        elif poly1.power < poly2.power:\n            current.next = poly2\n            poly2 = poly2.next\n        else:\n            sum = poly1.coefficient + poly2.coefficient\n            if sum != 0:\n                current.next = PolyNode(sum, poly1.power)\n                current = current.next\n            poly1 = poly1.next\n            poly2 = poly2.next\n        current = current.next\n\n    current.next = poly1 if poly1 else poly2\n    return dummy.next\n```\n\n    \n    The algorithm uses a dummy node to create a new linked list representing the sum of the given polynomials. A `current` pointer iterates through the polynomials, adding the terms with the same powers and appending it into the new linked list if the coefficient sum is not 0. Polynomials with different powers are simply appended into the new linked list. When one of the linked lists is finished, it simply appends the remaining nodes of the other list to the new linked list. Finally, return the `next` pointer of the dummy node as the head of the new linked list representing the sum of polynomials.\n    ",
        "c++": "\n    ```cpp\nclass PolyNode {\npublic:\n    int coefficient, power;\n    PolyNode* next;\n    PolyNode(int c, int p): coefficient(c), power(p), next(nullptr) {}\n};\n\nPolyNode* addPoly(PolyNode* poly1, PolyNode* poly2) {\n    PolyNode* dummy = new PolyNode(0, 0);\n    PolyNode* current = dummy;\n\n    while (poly1 && poly2) {\n        if (poly1->power > poly2->power) {\n            current->next = poly1;\n            poly1 = poly1->next;\n        } else if (poly1->power < poly2->power) {\n            current->next = poly2;\n            poly2 = poly2->next;\n        } else {\n            int sum = poly1->coefficient + poly2->coefficient;\n            if (sum != 0) {\n                current->next = new PolyNode(sum, poly1->power);\n                current = current->next;\n            }\n            poly1 = poly1->next;\n            poly2 = poly2->next;\n        }\n        current = current->next;\n    }\n\n    if (poly1) {\n        current->next = poly1;\n    } else {\n        current->next = poly2;\n    }\n    return dummy->next;\n}\n```\n\n    \n    The algorithm uses a dummy node to create a new linked list representing the sum of the given polynomials. A `current` pointer iterates through the polynomials, adding the terms with the same powers and appending it into the new linked list if the coefficient sum is not 0. Polynomials with different powers are simply appended into the new linked list. When one of the linked lists is finished, it simply appends the remaining nodes of the other list to the new linked list. Finally, return the `next` pointer of the dummy node as the head of the new linked list representing the sum of polynomials.\n    ",
        "js": "\n    ```javascript\nclass PolyNode {\n    constructor(c, p, next = null) {\n        this.coefficient = c;\n        this.power = p;\n        this.next = next;\n    }\n}\n\nfunction addPoly(poly1, poly2) {\n    let dummy = new PolyNode(0, 0);\n    let current = dummy;\n\n    while (poly1 && poly2) {\n        if (poly1.power > poly2.power) {\n            current.next = poly1;\n            poly1 = poly1.next;\n        } else if (poly1.power < poly2.power) {\n            current.next = poly2;\n            poly2 = poly2.next;\n        } else {\n            let sum = poly1.coefficient + poly2.coefficient;\n            if (sum !== 0) {\n                current.next = new PolyNode(sum, poly1.power);\n                current = current.next;\n            }\n            poly1 = poly1.next;\n            poly2 = poly2.next;\n        }\n        current = current.next;\n    }\n\n    current.next = poly1 ? poly1 : poly2;\n    return dummy.next;\n}\n```\n\n    \n    The algorithm uses a dummy node to create a new linked list representing the sum of the given polynomials. A `current` pointer iterates through the polynomials, adding the terms with the same powers and appending it into the new linked list if the coefficient sum is not 0. Polynomials with different powers are simply appended into the new linked list. When one of the linked lists is finished, it simply appends the remaining nodes of the other list to the new linked list. Finally, return the `next` pointer of the dummy node as the head of the new linked list representing the sum of polynomials.\n    "
    },
    {
        "id": 259,
        "title": "Lowest Common Ancestor of a Binary Tree II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the lowest common ancestor (LCA) of two given nodes,_ `p` _and_ `q`. If either node `p` or `q` **does not exist** in the tree, return `null`. All values of the nodes in the tree are **unique**.\n\nAccording to the **[definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor)**: \"The lowest common ancestor of two nodes `p` and `q` in a binary tree `T` is the lowest node that has both `p` and `q` as **descendants** (where we allow **a node to be a descendant of itself**) \". A **descendant** of a node `x` is a node `y` that is on the path from node `x` to some leaf node.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 1\n**Output:** 3\n**Explanation:** The LCA of nodes 5 and 1 is 3.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 4\n**Output:** 5\n**Explanation:** The LCA of nodes 5 and 4 is 5. A node can be a descendant of itself according to the definition of LCA.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 10\n**Output:** null\n**Explanation:** Node 10 does not exist in the tree, so return null."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p != q`\n\n**",
            "follow_up": "Follow up:** Can you find the LCA traversing the tree, without checking nodes existence?"
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,1",
                "output": "3"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,4",
                "output": "5"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,10",
                "output": "null"
            }
        ],
        "java": "\n    ```java\npublic List<String> maxNumOfSubstrings(String s) {\n    int[] last = new int[26];\n    Arrays.fill(last, -1);\n    for (int i = 0; i < s.length(); ++i) {\n        last[s.charAt(i) - 'a'] = i;\n    }\n    \n    List<String> res = new ArrayList<>();\n    int pre = -1, maxRight = -1;\n    for (int i = 0; i < s.length(); ++i) {\n        maxRight = Math.max(maxRight, last[s.charAt(i) - 'a']);\n        if (maxRight == i) {\n            res.add(s.substring(pre + 1, maxRight + 1));\n            pre = i;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    1. We initialize an array `last` to store the last position of each character in string `s`.\n2. We fill the array `last` by iterating over the string and updating the last index for each character.\n3. We initialize an empty result array `res`, a variable `pre` to -1, and a variable `maxRight` to -1.\n4. We iterate over the string, updating `maxRight` to the maximum of its current value and the last position of the current character in `s`. \n5. If `maxRight` equals the current index, we add the substring from `pre + 1` to `maxRight + 1` to the result array and set `pre` to the current index.\n6. After the iteration, the result array `res` contains the maximum number of non-empty substrings that meet the given conditions.\n    ",
        "python": "\n    ```python\ndef max_num_of_substrings(s: str) -> List[str]:\n    last = [-1] * 26\n    for i, ch in enumerate(s):\n        last[ord(ch) - ord('a')] = i\n    \n    res = []\n    pre, max_right = -1, -1\n    for i, ch in enumerate(s):\n        max_right = max(max_right, last[ord(ch) - ord('a')])\n        if max_right == i:\n            res.append(s[pre + 1:max_right + 1])\n            pre = i\n    \n    return res\n```\n    \n    1. We initialize an array `last` to store the last position of each character in string `s`.\n2. We fill the array `last` by iterating over the string and updating the last index for each character.\n3. We initialize an empty result array `res`, a variable `pre` to -1, and a variable `maxRight` to -1.\n4. We iterate over the string, updating `maxRight` to the maximum of its current value and the last position of the current character in `s`. \n5. If `maxRight` equals the current index, we add the substring from `pre + 1` to `maxRight + 1` to the result array and set `pre` to the current index.\n6. After the iteration, the result array `res` contains the maximum number of non-empty substrings that meet the given conditions.\n    ",
        "c++": "\n    ```cpp\nstd::vector<std::string> maxNumOfSubstrings(std::string s) {\n    std::vector<int> last(26, -1);\n    for (int i = 0; i < (int)s.size(); ++i) {\n        last[s[i] - 'a'] = i;\n    }\n    \n    std::vector<std::string> res;\n    int pre = -1, maxRight = -1;\n    for (int i = 0; i < (int)s.size(); ++i) {\n        maxRight = std::max(maxRight, last[s[i] - 'a']);\n        if (maxRight == i) {\n            res.push_back(s.substr(pre + 1, maxRight - pre));\n            pre = i;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    1. We initialize an array `last` to store the last position of each character in string `s`.\n2. We fill the array `last` by iterating over the string and updating the last index for each character.\n3. We initialize an empty result array `res`, a variable `pre` to -1, and a variable `maxRight` to -1.\n4. We iterate over the string, updating `maxRight` to the maximum of its current value and the last position of the current character in `s`. \n5. If `maxRight` equals the current index, we add the substring from `pre + 1` to `maxRight + 1` to the result array and set `pre` to the current index.\n6. After the iteration, the result array `res` contains the maximum number of non-empty substrings that meet the given conditions.\n    ",
        "js": "\n    ```javascript\nfunction maxNumOfSubstrings(s) {\n    const last = new Array(26).fill(-1);\n    for (let i = 0; i < s.length; ++i) {\n        last[s.charCodeAt(i) - 'a'.charCodeAt(0)] = i;\n    }\n    \n    let res = [];\n    let pre = -1;\n    let maxRight = -1;\n    for (let i = 0; i < s.length; ++i) {\n        maxRight = Math.max(maxRight, last[s.charCodeAt(i) - 'a'.charCodeAt(0)]);\n        if (maxRight === i) {\n            res.push(s.substring(pre + 1, maxRight + 1));\n            pre = i;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    1. We initialize an array `last` to store the last position of each character in string `s`.\n2. We fill the array `last` by iterating over the string and updating the last index for each character.\n3. We initialize an empty result array `res`, a variable `pre` to -1, and a variable `maxRight` to -1.\n4. We iterate over the string, updating `maxRight` to the maximum of its current value and the last position of the current character in `s`. \n5. If `maxRight` equals the current index, we add the substring from `pre + 1` to `maxRight + 1` to the result array and set `pre` to the current index.\n6. After the iteration, the result array `res` contains the maximum number of non-empty substrings that meet the given conditions.\n    "
    },
    {
        "id": 260,
        "title": "Lowest Common Ancestor of a Binary Tree III",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two nodes of a binary tree `p` and `q`, return _their lowest common ancestor (LCA)_.\n\nEach node will have a reference to its parent node. The definition for `Node` is below:\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n\nAccording to the **[definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor)**: \"The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow **a node to be a descendant of itself**). \"",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 1\n**Output:** 3\n**Explanation:** The LCA of nodes 5 and 1 is 3.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 4\n**Output:** 5\n**Explanation:** The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,2\\], p = 1, q = 2\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 105]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p != q`\n*   `p` and `q` exist in the tree.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,1",
                "output": "3"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,4",
                "output": "5"
            },
            {
                "input": "[1,2],1,2",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n\npublic Node lowestCommonAncestor(Node p, Node q) {\n    Node a = p;\n    Node b = q;\n    while (a != b) {\n        a = a.parent != null ? a.parent : q;\n        b = b.parent != null ? b.parent : p;\n    }\n    return a;\n}\n```\n    \n    We initialize two pointers, `a` and `b`, to be the input nodes `p` and `q`. Then, we run a while loop which terminates when `a` and `b` meet. In each iteration, we move `a` to its parent if it exists, otherwise we move it to node `q`. Similarly, we move `b` to its parent if it exists, otherwise we move it to node `p`.\n\nSince we are traversing each node's ancestors and switching to the other node's ancestors, eventually `a` and `b` will meet at the lowest common ancestor of the two input nodes. This method ensures that we cover nodes up the tree and helps find the LCA in O(h) time, where h is the height of the tree.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=0, left=None, right=None, parent=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\ndef lowest_common_ancestor(p, q):\n    a, b = p, q\n    while a != b:\n        a = a.parent if a.parent else q\n        b = b.parent if b.parent else p\n    return a\n```\n    \n    We initialize two pointers, `a` and `b`, to be the input nodes `p` and `q`. Then, we run a while loop which terminates when `a` and `b` meet. In each iteration, we move `a` to its parent if it exists, otherwise we move it to node `q`. Similarly, we move `b` to its parent if it exists, otherwise we move it to node `p`.\n\nSince we are traversing each node's ancestors and switching to the other node's ancestors, eventually `a` and `b` will meet at the lowest common ancestor of the two input nodes. This method ensures that we cover nodes up the tree and helps find the LCA in O(h) time, where h is the height of the tree.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* parent;\n};\n\nNode* lowestCommonAncestor(Node* p, Node* q) {\n    Node* a = p;\n    Node* b = q;\n    while (a != b) {\n        a = a->parent ? a->parent : q;\n        b = b->parent ? b->parent : p;\n    }\n    return a;\n}\n```\n    \n    We initialize two pointers, `a` and `b`, to be the input nodes `p` and `q`. Then, we run a while loop which terminates when `a` and `b` meet. In each iteration, we move `a` to its parent if it exists, otherwise we move it to node `q`. Similarly, we move `b` to its parent if it exists, otherwise we move it to node `p`.\n\nSince we are traversing each node's ancestors and switching to the other node's ancestors, eventually `a` and `b` will meet at the lowest common ancestor of the two input nodes. This method ensures that we cover nodes up the tree and helps find the LCA in O(h) time, where h is the height of the tree.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val=0, left=null, right=null, parent=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n        this.parent = parent;\n    }\n}\n\nfunction lowestCommonAncestor(p, q) {\n    let a = p;\n    let b = q;\n    while (a !== b) {\n        a = a.parent ? a.parent : q;\n        b = b.parent ? b.parent : p;\n    }\n    return a;\n}\n```\n    \n    We initialize two pointers, `a` and `b`, to be the input nodes `p` and `q`. Then, we run a while loop which terminates when `a` and `b` meet. In each iteration, we move `a` to its parent if it exists, otherwise we move it to node `q`. Similarly, we move `b` to its parent if it exists, otherwise we move it to node `p`.\n\nSince we are traversing each node's ancestors and switching to the other node's ancestors, eventually `a` and `b` will meet at the lowest common ancestor of the two input nodes. This method ensures that we cover nodes up the tree and helps find the LCA in O(h) time, where h is the height of the tree.\n    "
    },
    {
        "id": 261,
        "title": "Correct a Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a binary tree with a small defect. There is **exactly one** invalid node where its right child incorrectly points to another node at the **same depth** but to the **invalid node's right**.\n\nGiven the root of the binary tree with this defect, `root`, return _the root of the binary tree after **removing** this invalid node **and every node underneath it** (minus the node it incorrectly points to)._\n\n**Custom testing:**\n\nThe test input is read as 3 lines:\n\n*   `TreeNode root`\n*   `int fromNode` (**not available to** `correctBinaryTree`)\n*   `int toNode` (**not available to** `correctBinaryTree`)\n\nAfter the binary tree rooted at `root` is parsed, the `TreeNode` with value of `fromNode` will have its right child pointer pointing to the `TreeNode` with a value of `toNode`. Then, `root` is passed to `correctBinaryTree`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\], fromNode = 2, toNode = 3\n**Output:** \\[1,null,3\\]\n**Explanation:** The node with value 2 is invalid, so remove it.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[8,3,1,7,null,9,4,2,null,null,null,5,6\\], fromNode = 7, toNode = 4\n**Output:** \\[8,3,1,null,null,9,4,null,null,5,6\\]\n**Explanation:** The node with value 7 is invalid, so remove it and the node underneath it, node 2."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[3, 104]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `fromNode != toNode`\n*   `fromNode` and `toNode` will exist in the tree and will be on the same depth.\n*   `toNode` is to the **right** of `fromNode`.\n*   `fromNode.right` is `null` in the initial tree from the test data.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3],2,3",
                "output": "[1,null,3]"
            },
            {
                "input": "[8,3,1,7,null,9,4,2,null,null,null,5,6],7,4",
                "output": "[8,3,1,null,null,9,4,null,null,5,6]"
            }
        ],
        "java": "\n    ```java\npublic String thousandSeparator(int n) {\n    String result = Integer.toString(n);\n    int count = 0;\n    for (int i = result.length() - 1; i > 0; --i) {\n        count++;\n        if (count % 3 == 0) {\n            result = result.substring(0, i) + \".\" + result.substring(i);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm first converts the given integer `n` into a string format. We'll be iterating through the string in reverse order (from last to first character) to insert dots at the thousands positions. \n\nWe keep a count initialized to 0. During the iteration, we increment the count until it's divisible by 3 (meaning we reached a thousands position). At this point, we insert the dot in the string at position `i`. The insertion process is slightly different for each programming language, but the overall idea is the same.\n\nAfter the iteration is complete, we return the modified string with dots as thousands separators. This solution works for each of the mentioned programming languages using similar logic and some language-specific syntax adjustments.\n    ",
        "python": "\n    ```python\ndef thousand_separator(n: int) -> str:\n    result = str(n)\n    count = 0\n    for i in range(len(result) - 1, 0, -1):\n        count += 1\n        if count % 3 == 0:\n            result = result[:i] + '.' + result[i:]\n    return result\n```\n    \n    The algorithm first converts the given integer `n` into a string format. We'll be iterating through the string in reverse order (from last to first character) to insert dots at the thousands positions. \n\nWe keep a count initialized to 0. During the iteration, we increment the count until it's divisible by 3 (meaning we reached a thousands position). At this point, we insert the dot in the string at position `i`. The insertion process is slightly different for each programming language, but the overall idea is the same.\n\nAfter the iteration is complete, we return the modified string with dots as thousands separators. This solution works for each of the mentioned programming languages using similar logic and some language-specific syntax adjustments.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string thousandSeparator(int n) {\n    std::string result = std::to_string(n);\n    int count = 0;\n    for (int i = result.size() - 1; i > 0; --i) {\n        count++;\n        if (count % 3 == 0) {\n            result.insert(i, \".\");\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm first converts the given integer `n` into a string format. We'll be iterating through the string in reverse order (from last to first character) to insert dots at the thousands positions. \n\nWe keep a count initialized to 0. During the iteration, we increment the count until it's divisible by 3 (meaning we reached a thousands position). At this point, we insert the dot in the string at position `i`. The insertion process is slightly different for each programming language, but the overall idea is the same.\n\nAfter the iteration is complete, we return the modified string with dots as thousands separators. This solution works for each of the mentioned programming languages using similar logic and some language-specific syntax adjustments.\n    ",
        "js": "\n    ```javascript\nfunction thousandSeparator(n) {\n    let result = String(n);\n    let count = 0;\n    for (let i = result.length - 1; i > 0; --i) {\n        count++;\n        if (count % 3 === 0) {\n            result = result.slice(0, i) + '.' + result.slice(i);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm first converts the given integer `n` into a string format. We'll be iterating through the string in reverse order (from last to first character) to insert dots at the thousands positions. \n\nWe keep a count initialized to 0. During the iteration, we increment the count until it's divisible by 3 (meaning we reached a thousands position). At this point, we insert the dot in the string at position `i`. The insertion process is slightly different for each programming language, but the overall idea is the same.\n\nAfter the iteration is complete, we return the modified string with dots as thousands separators. This solution works for each of the mentioned programming languages using similar logic and some language-specific syntax adjustments.\n    "
    },
    {
        "id": 262,
        "title": "Change the Root of a Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree and a `leaf` node, reroot the tree so that the `leaf` is the new root.\n\nYou can reroot the tree with the following steps for each node `cur` on the path **starting from the** `leaf` up to the `root` **excluding the root**:\n\n1.  If `cur` has a left child, then that child becomes `cur`'s right child.\n2.  `cur`'s original parent becomes `cur`'s left child. Note that in this process the original parent's pointer to `cur` becomes `null`, making it have at most one child.\n\nReturn _the new root_ _of the rerooted tree._\n\n**Note:** Ensure that your solution sets the `Node.parent` pointers correctly after rerooting or you will receive \"Wrong Answer \".",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], leaf = 7\n**Output:** \\[7,2,null,5,4,3,6,null,null,null,1,null,null,0,8\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], leaf = 0\n**Output:** \\[0,1,null,3,8,5,null,null,null,6,2,null,null,7,4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 100]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `leaf` exist in the tree.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],7",
                "output": "[7,2,null,5,4,3,6,null,null,null,1,null,null,0,8]"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],0",
                "output": "[0,1,null,3,8,5,null,null,null,6,2,null,null,7,4]"
            }
        ],
        "java": "\n    ```java\npublic String makeGood(String s) {\n    StringBuilder result = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        int length = result.length();\n        if (length > 0 && Math.abs(result.charAt(length - 1) - c) == 32) {\n            result.deleteCharAt(length - 1);\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    The algorithm iterates through the input string. For each character, it checks whether the last character in the result string has the same letter but different case (i.e., the ASCII distance between the two characters is 32). If so, it removes the last character from the result string. Otherwise, it appends the current character to the result string. The final result is then returned.\n    ",
        "python": "\n    ```python\ndef make_good(s: str) -> str:\n    result = []\n    for c in s:\n        if result and abs(ord(result[-1]) - ord(c)) == 32:\n            result.pop()\n        else:\n            result.append(c)\n    return \"\".join(result)\n```\n\n    \n    The algorithm iterates through the input string. For each character, it checks whether the last character in the result string has the same letter but different case (i.e., the ASCII distance between the two characters is 32). If so, it removes the last character from the result string. Otherwise, it appends the current character to the result string. The final result is then returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string makeGood(std::string s) {\n    std::string result;\n    for (char c : s) {\n        if (!result.empty() && abs(result.back() - c) == 32) {\n            result.pop_back();\n        } else {\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm iterates through the input string. For each character, it checks whether the last character in the result string has the same letter but different case (i.e., the ASCII distance between the two characters is 32). If so, it removes the last character from the result string. Otherwise, it appends the current character to the result string. The final result is then returned.\n    ",
        "js": "\n    ```javascript\nfunction makeGood(s) {\n    let result = [];\n    for (let c of s) {\n        if (result.length > 0 && Math.abs(result[result.length - 1].charCodeAt(0) - c.charCodeAt(0)) === 32) {\n            result.pop();\n        } else {\n            result.push(c);\n        }\n    }\n    return result.join(\"\");\n}\n```\n\n    \n    The algorithm iterates through the input string. For each character, it checks whether the last character in the result string has the same letter but different case (i.e., the ASCII distance between the two characters is 32). If so, it removes the last character from the result string. Otherwise, it appends the current character to the result string. The final result is then returned.\n    "
    },
    {
        "id": 263,
        "title": "Lowest Common Ancestor of a Binary Tree IV",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree and an array of `TreeNode` objects `nodes`, return _the lowest common ancestor (LCA) of **all the nodes** in_ `nodes`. All the nodes will exist in the tree, and all values of the tree's nodes are **unique**.\n\nExtending the **[definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor)**: \"The lowest common ancestor of `n` nodes `p1`, `p2`, ..., `pn` in a binary tree `T` is the lowest node that has every `pi` as a **descendant** (where we allow **a node to be a descendant of itself**) for every valid `i` \". A **descendant** of a node `x` is a node `y` that is on the path from node `x` to some leaf node.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], nodes = \\[4,7\\]\n**Output:** 2\n**Explanation:** The lowest common ancestor of nodes 4 and 7 is node 2.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], nodes = \\[1\\]\n**Output:** 1\n**Explanation:** The lowest common ancestor of a single node is the node itself.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], nodes = \\[7,6,2,4\\]\n**Output:** 5\n**Explanation:** The lowest common ancestor of the nodes 7, 6, 2, and 4 is node 5."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   All `nodes[i]` will exist in the tree.\n*   All `nodes[i]` are distinct.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],[4,7]",
                "output": "2"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],[1]",
                "output": "1"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],[7,6,2,4]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) {\n    if (root == null || Arrays.asList(nodes).contains(root))\n        return root;\n    TreeNode left = lowestCommonAncestor(root.left, nodes);\n    TreeNode right = lowestCommonAncestor(root.right, nodes);\n    if (left != null && right != null)\n        return root;\n    return left != null ? left : right;\n}\n```\n\n    \n    The algorithm used here is a recursive depth-first search approach. We start at the given root node and make a recursive call for both left and right subtrees. If the current node is null or it exists in the given input array, we return the current node.\n\nOnce the left and right recursive calls are completed, we check if left and right are not null, which means we have found at least two target nodes in both the subtrees. In that case, the current node is the LCA we are looking for, so return it. If one of the left or right is null, then we return the one which is not null (i.e., has the target node(s) as its descendant).\n\nThe base case is a node that is either null or exists in the input nodes array. When we reach such a point, we return that node.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, nodes):\n    if root is None or root in nodes:\n        return root\n    left = lowestCommonAncestor(root.left, nodes)\n    right = lowestCommonAncestor(root.right, nodes)\n    if left is not None and right is not None:\n        return root\n    return left if left is not None else right\n```\n\n    \n    The algorithm used here is a recursive depth-first search approach. We start at the given root node and make a recursive call for both left and right subtrees. If the current node is null or it exists in the given input array, we return the current node.\n\nOnce the left and right recursive calls are completed, we check if left and right are not null, which means we have found at least two target nodes in both the subtrees. In that case, the current node is the LCA we are looking for, so return it. If one of the left or right is null, then we return the one which is not null (i.e., has the target node(s) as its descendant).\n\nThe base case is a node that is either null or exists in the input nodes array. When we reach such a point, we return that node.\n    ",
        "c++": "\n    ```cpp\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* lowestCommonAncestor(TreeNode* root, const vector<TreeNode*> &nodes) {\n    if (root == nullptr || find(nodes.begin(), nodes.end(), root) != nodes.end())\n        return root;\n    TreeNode* left = lowestCommonAncestor(root->left, nodes);\n    TreeNode* right = lowestCommonAncestor(root->right, nodes);\n    if (left != nullptr && right != nullptr)\n        return root;\n    return left != nullptr ? left : right;\n}\n```\n\n    \n    The algorithm used here is a recursive depth-first search approach. We start at the given root node and make a recursive call for both left and right subtrees. If the current node is null or it exists in the given input array, we return the current node.\n\nOnce the left and right recursive calls are completed, we check if left and right are not null, which means we have found at least two target nodes in both the subtrees. In that case, the current node is the LCA we are looking for, so return it. If one of the left or right is null, then we return the one which is not null (i.e., has the target node(s) as its descendant).\n\nThe base case is a node that is either null or exists in the input nodes array. When we reach such a point, we return that node.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction lowestCommonAncestor(root, nodes) {\n    if (root === null || nodes.includes(root))\n        return root;\n    let left = lowestCommonAncestor(root.left, nodes);\n    let right = lowestCommonAncestor(root.right, nodes);\n    if (left !== null && right !== null)\n        return root;\n    return left !== null ? left : right;\n}\n```\n\n    \n    The algorithm used here is a recursive depth-first search approach. We start at the given root node and make a recursive call for both left and right subtrees. If the current node is null or it exists in the given input array, we return the current node.\n\nOnce the left and right recursive calls are completed, we check if left and right are not null, which means we have found at least two target nodes in both the subtrees. In that case, the current node is the LCA we are looking for, so return it. If one of the left or right is null, then we return the one which is not null (i.e., has the target node(s) as its descendant).\n\nThe base case is a node that is either null or exists in the input nodes array. When we reach such a point, we return that node.\n    "
    },
    {
        "id": 264,
        "title": "Longest Palindromic Subsequence II",
        "difficulty": "Medium",
        "content": {
            "problem": "A subsequence of a string `s` is considered a **good palindromic subsequence** if:\n\n*   It is a subsequence of `s`.\n*   It is a palindrome (has the same value if reversed).\n*   It has an **even** length.\n*   No two consecutive characters are equal, except the two middle ones.\n\nFor example, if `s = \"abcabcabb \"`, then `\"abba \"` is considered a **good palindromic subsequence**, while `\"bcb \"` (not even length) and `\"bbbb \"` (has equal consecutive characters) are not.\n\nGiven a string `s`, return _the **length** of the **longest good palindromic subsequence** in_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"bbabab \"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is  \"baab \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"dcbccacdb \"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is  \"dccd \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 250`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"bbabab\"",
                "output": "4"
            },
            {
                "input": "\"dcbccacdb\"",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> mostVisited(int n, int[] rounds) {\n    int[] visited = new int[n + 1];\n    for (int i = 1; i < rounds.length; ++i) {\n        for (int start = rounds[i - 1], end = rounds[i]; start != end; start = start % n + 1) {\n            ++visited[start];\n        }\n    }\n    ++visited[rounds[rounds.length - 1]];\n\n    int maxVisits = Arrays.stream(visited).max().getAsInt();\n    List<Integer> result = new ArrayList<>();\n\n    for (int i = 1; i <= n; ++i) {\n        if (visited[i] == maxVisits) {\n            result.add(i);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    ",
        "python": "\n    ```python\ndef most_visited(n, rounds):\n    visited = [0] * (n + 1)\n    \n    for i in range(1, len(rounds)):\n        start, end = rounds[i - 1], rounds[i]\n        while start != end:\n            visited[start] += 1\n            start = (start % n) + 1\n    visited[rounds[-1]] += 1\n    \n    max_visits = max(visited);\n    return [i for i in range(1, n + 1) if visited[i] == max_visits]\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> mostVisited(int n, vector<int>& rounds) {\n    vector<int> visited(n + 1, 0);\n    \n    for (int i = 1; i < rounds.size(); i++) {\n        int start = rounds[i - 1], end = rounds[i];\n        while (start != end) {\n            visited[start]++;\n            start = start % n + 1;\n        }\n    }\n    visited[rounds.back()]++;\n    \n    int maxVisits = *max_element(visited.begin(), visited.end());\n    vector<int> result;\n    \n    for (int i = 1; i <= n; i++) {\n        if (visited[i] == maxVisits)\n            result.push_back(i);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    ",
        "js": "\n    ```javascript\nfunction mostVisited(n, rounds) {\n    const visited = new Array(n + 1).fill(0);\n    \n    for (let i = 1; i < rounds.length; ++i) {\n        for (let start = rounds[i - 1], end = rounds[i]; start !== end; start = start % n + 1) {\n            ++visited[start];\n        }\n    }\n    ++visited[rounds[rounds.length - 1]];\n    \n    const maxVisits = Math.max(...visited);\n    const result = [];\n    \n    for (let i = 1; i <= n; ++i) {\n        if (visited[i] === maxVisits) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an array `visited` that counts the visits for each sector. We iterate over the given `rounds` array, and for each consecutive pair of sectors (i.e., from `rounds[i - 1]` to `rounds[i]`), we increment the count of visits for each sector in between (inclusive of the starting sector). After updating the visit count for each round, we find the maximum number of visits (`maxVisits`). Lastly, we iterate over the `visited` array and create a list of all sectors with maximum visits (`result`). The function returns the `result` list.\n    "
    },
    {
        "id": 265,
        "title": "Count Ways to Distribute Candies",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` **unique** candies (labeled `1` through `n`) and `k` bags. You are asked to distribute **all** the candies into the bags such that every bag has **at least** one candy.\n\nThere can be multiple ways to distribute the candies. Two ways are considered **different** if the candies in one bag in the first way are not all in the same bag in the second way. The order of the bags and the order of the candies within each bag do not matter.\n\nFor example, `(1), (2,3)` and `(2), (1,3)` are considered different because candies `2` and `3` in the bag `(2,3)` in the first way are not in the same bag in the second way (they are split between the bags `(2)` and `(1,3)`). However, `(1), (2,3)` and `(3,2), (1)` are considered the same because the candies in each bag are all in the same bags in both ways.\n\nGiven two integers, `n` and `k`, return _the **number** of different ways to distribute the candies_. As the answer may be too large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 3\n**Explanation:** You can distribute 3 candies into 2 bags in 3 ways:\n(1), (2,3)\n(1,2), (3)\n(1,3), (2)\n\n",
                "**Example 2:**\n\n**Input:** n = 4, k = 2\n**Output:** 7\n**Explanation:** You can distribute 4 candies into 2 bags in 7 ways:\n(1), (2,3,4)\n(1,2), (3,4)\n(1,3), (2,4)\n(1,4), (2,3)\n(1,2,3), (4)\n(1,2,4), (3)\n(1,3,4), (2)\n\n",
                "**Example 3:**\n\n**Input:** n = 20, k = 5\n**Output:** 206085257\n**Explanation:** You can distribute 20 candies into 5 bags in 1881780996 ways. 1881780996 modulo 109 + 7 = 206085257."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= n <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3,2",
                "output": "3"
            },
            {
                "input": "4,2",
                "output": "7"
            },
            {
                "input": "20,5",
                "output": "206085257"
            }
        ],
        "java": "\n    ```java\npublic int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n            dp[i] %= 1000000007;\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    ",
        "python": "\n    ```python\ndef numTrees(n: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n            dp[i] %= (10**9 + 7)\n\n    return dp[n]\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint numTrees(int n) {\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n            dp[i] %= 1000000007;\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    ",
        "js": "\n    ```javascript\nfunction numTrees(n) {\n    const dp = Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - 1 - j];\n            dp[i] %= 1000000007;\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a function `numTrees(i)` that returns the number of possible binary search trees with `i` nodes. We iterate through each possible number of nodes `i` from 2 to `n`. For each of these, we iterate through all possible left sub-tree sizes `j` (from 0 to i-1). Now, the total number of possible right sub-trees for the current `i` will be `i - 1 - j`. \n\nThus, the total number of possible BSTs for the current `i` will be the Cartesian product of the possible left sub-trees and possible right sub-trees. Hence, we can update `dp[i]` as `dp[i] += dp[j] * dp[i - 1 - j]`. \n\nWe continue doing this for all values of `i` until we reach `n`. The final answer will be `dp[n]`, the number of possible BSTs with `n` nodes. Note that we take the answer modulo 10^9 + 7 as the result can be quite large.\n    "
    },
    {
        "id": 266,
        "title": "Number of Distinct Substrings in a String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the number of **distinct** substrings of_ `s`.\n\nA **substring** of a string is obtained by deleting any number of characters (possibly zero) from the front of the string and any number (possibly zero) from the back of the string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aabbaba \"\n**Output:** 21\n**Explanation:** The set of distinct strings is \\[ \"a \", \"b \", \"aa \", \"bb \", \"ab \", \"ba \", \"aab \", \"abb \", \"bab \", \"bba \", \"aba \", \"aabb \", \"abba \", \"bbab \", \"baba \", \"aabba \", \"abbab \", \"bbaba \", \"aabbab \", \"abbaba \", \"aabbaba \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdefg \"\n**Output:** 28"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Can you solve this problem in `O(n)` time complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "\"aabbaba\"",
                "output": "21"
            },
            {
                "input": "\"abcdefg\"",
                "output": "28"
            }
        ],
        "java": "\n    ```java\npublic String modifyString(String s) {\n    char[] result = s.toCharArray();\n    for (int i = 0; i < result.length; i++) {\n        if (result[i] == '?') {\n            for (char c = 'a'; c <= 'z'; c++) {\n                if ((i - 1 < 0 || result[i - 1] != c) && (i + 1 >= result.length || result[i + 1] != c)) {\n                    result[i] = c;\n                    break;\n                }\n            }\n        }\n    }\n    return new String(result);\n}\n```\n\n    \n    The algorithm iterates through each character in the input string s. If it encounters the '?' character, it iterates through the lowercase English alphabet (from 'a' to 'z') and checks if any character doesn't match the adjacent characters (previous and next, if available). If such a character is found, replace the '?' with it and break the character search loop. Once done iterating through the whole string, return the modified string. This ensures that no consecutive repeating characters are there in the final string.\n    ",
        "python": "\n    ```python\ndef modifyString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in range(ord('a'), ord('z') + 1):\n                if (i - 1 < 0 or s[i - 1] != chr(c)) and (i + 1 >= len(s) or s[i + 1] != chr(c)):\n                    s[i] = chr(c)\n                    break\n    return ''.join(s)\n```\n\n    \n    The algorithm iterates through each character in the input string s. If it encounters the '?' character, it iterates through the lowercase English alphabet (from 'a' to 'z') and checks if any character doesn't match the adjacent characters (previous and next, if available). If such a character is found, replace the '?' with it and break the character search loop. Once done iterating through the whole string, return the modified string. This ensures that no consecutive repeating characters are there in the final string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string modifyString(std::string s) {\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '?') {\n            for (char c = 'a'; c <= 'z'; c++) {\n                if ((i - 1 < 0 || s[i - 1] != c) && (i + 1 >= s.size() || s[i + 1] != c)) {\n                    s[i] = c;\n                    break;\n                }\n            }\n        }\n    }\n    return s;\n}\n```\n\n    \n    The algorithm iterates through each character in the input string s. If it encounters the '?' character, it iterates through the lowercase English alphabet (from 'a' to 'z') and checks if any character doesn't match the adjacent characters (previous and next, if available). If such a character is found, replace the '?' with it and break the character search loop. Once done iterating through the whole string, return the modified string. This ensures that no consecutive repeating characters are there in the final string.\n    ",
        "js": "\n    ```javascript\nfunction modifyString(s) {\n    s = s.split('');\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '?') {\n            for (let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++) {\n                if ((i - 1 < 0 || s[i - 1] !== String.fromCharCode(c)) && (i + 1 >= s.length || s[i + 1] !== String.fromCharCode(c))) {\n                    s[i] = String.fromCharCode(c);\n                    break;\n                }\n            }\n        }\n    }\n    return s.join('');\n}\n```\n\n    \n    The algorithm iterates through each character in the input string s. If it encounters the '?' character, it iterates through the lowercase English alphabet (from 'a' to 'z') and checks if any character doesn't match the adjacent characters (previous and next, if available). If such a character is found, replace the '?' with it and break the character search loop. Once done iterating through the whole string, return the modified string. This ensures that no consecutive repeating characters are there in the final string.\n    "
    },
    {
        "id": 267,
        "title": "Largest Subarray Length K",
        "difficulty": "Easy",
        "content": {
            "problem": "An array `A` is larger than some array `B` if for the first index `i` where `A[i] != B[i]`, `A[i] > B[i]`.\n\nFor example, consider `0`\\-indexing:\n\n*   `[1,3,2,4] > [1,2,2,4]`, since at index `1`, `3 > 2`.\n*   `[1,4,4,4] < [2,1,1,1]`, since at index `0`, `1 < 2`.\n\nA subarray is a contiguous subsequence of the array.\n\nGiven an integer array `nums` of **distinct** integers, return the **largest** subarray of `nums` of length `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,4,5,2,3\\], k = 3\n**Output:** \\[5,2,3\\]\n**Explanation:** The subarrays of size 3 are: \\[1,4,5\\], \\[4,5,2\\], and \\[5,2,3\\].\nOf these, \\[5,2,3\\] is the largest.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,4,5,2,3\\], k = 4\n**Output:** \\[4,5,2,3\\]\n**Explanation:** The subarrays of size 4 are: \\[1,4,5,2\\], and \\[4,5,2,3\\].\nOf these, \\[4,5,2,3\\] is the largest.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,4,5,2,3\\], k = 1\n**Output:** \\[5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   All the integers of `nums` are **unique**.\n\n**",
            "follow_up": "Follow up:** What if the integers in `nums` are not distinct?"
        },
        "tag": [],
        "example": [
            {
                "input": "[1,4,5,2,3],3",
                "output": "[5,2,3]"
            },
            {
                "input": "[1,4,5,2,3],4",
                "output": "[4,5,2,3]"
            },
            {
                "input": "[1,4,5,2,3],1",
                "output": "[5]"
            }
        ],
        "java": "\n    ```java\npublic class ParkingSystem {\n    private int[] slots;\n\n    public ParkingSystem(int big, int medium, int small) {\n        slots = new int[]{big, medium, small};\n    }\n    \n    public boolean addCar(int carType) {\n        if (slots[carType - 1] > 0) {\n            slots[carType - 1]--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    ",
        "python": "\n    ```python\nclass ParkingSystem:\n\n    def __init__(self, big: int, medium: int, small: int):\n        self.slots = [big, medium, small]\n\n    def addCar(self, carType: int) -> bool:\n        if self.slots[carType - 1] > 0:\n            self.slots[carType - 1] -= 1\n            return True\n        else:\n            return False\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    ",
        "c++": "\n    ```cpp\nclass ParkingSystem {\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        slots = {big, medium, small};\n    }\n    \n    bool addCar(int carType) {\n        if (slots[carType - 1] > 0) {\n            slots[carType - 1]--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\nprivate:\n    vector<int> slots;\n};\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    ",
        "js": "\n    ```javascript\nclass ParkingSystem {\n    constructor(big, medium, small) {\n        this.slots = [big, medium, small];\n    }\n    \n    addCar(carType) {\n        if (this.slots[carType - 1] > 0) {\n            this.slots[carType - 1]--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n    \n    The ParkingSystem class is designed such that an instance of the class contains an array of integers 'slots', representing the number of big, medium, and small slots available. The constructor takes in the respective number of big, medium, and small slots as arguments and assigns the input values to the slots array.\n\nThe addCar() function is then implemented to take in an integer value carType (1, 2, or 3) representing the type of car. We then check if the number of slots for that specific type of car is more than 0. If there is available space (i.e., the respective slot count is > 0), we decrement the slot count and return true. If there is no space available (i.e., slot count is 0), we return false.\n\nThe solution is O(1) for addCar() as it directly accesses and modifies the slots array.\n    "
    },
    {
        "id": 268,
        "title": "Sum Of Special Evenly-Spaced Elements In Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` consisting of `n` non-negative integers.\n\nYou are also given an array `queries`, where `queries[i] = [xi, yi]`. The answer to the `ith` query is the sum of all `nums[j]` where `xi <= j < n` and `(j - xi)` is divisible by `yi`.\n\nReturn _an array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query **modulo**_ `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,3,4,5,6,7\\], queries = \\[\\[0,3\\],\\[5,1\\],\\[4,2\\]\\]\n**Output:** \\[9,18,10\\]\n**Explanation:** The answers of the queries are as follows:\n1) The j indices that satisfy this query are 0, 3, and 6. nums\\[0\\] + nums\\[3\\] + nums\\[6\\] = 9\n2) The j indices that satisfy this query are 5, 6, and 7. nums\\[5\\] + nums\\[6\\] + nums\\[7\\] = 18\n3) The j indices that satisfy this query are 4 and 6. nums\\[4\\] + nums\\[6\\] = 10\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[100,200,101,201,102,202,103,203\\], queries = \\[\\[0,7\\]\\]\n**Output:** \\[303\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `0 <= nums[i] <= 109`\n*   `1 <= queries.length <= 1.5 * 105`\n*   `0 <= xi < n`\n*   `1 <= yi <= 5 * 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,2,3,4,5,6,7],[[0,3],[5,1],[4,2]]",
                "output": "[9,18,10]"
            },
            {
                "input": "[100,200,101,201,102,202,103,203],[[0,7]]",
                "output": "[303]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String reorderSpaces(String text) {\n    int spaces = 0;\n    List<String> words = new ArrayList<>();\n    \n    String[] splitText = text.split(\"\\\\s+\");\n    for (String word : splitText) {\n        words.add(word);\n        spaces += word.length() - word.trim().length();\n    }\n    \n    if (words.size() == 1) {\n        return words.get(0) + \" \".repeat(spaces);\n    }\n\n    int spaceBetweenWords = spaces / (words.size() - 1);\n    int extraSpaces = spaces % (words.size() - 1);\n    StringBuilder result = new StringBuilder();\n    \n    for (int i = 0; i < words.size(); i++) {\n        result.append(words.get(i));\n        if (i < words.size() - 1) {\n            result.append(\" \".repeat(spaceBetweenWords));\n        }\n    }\n    \n    result.append(\" \".repeat(extraSpaces));\n\n    return result.toString();\n}\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    ",
        "python": "\n    ```python\ndef reorder_spaces(text: str) -> str:\n    spaces = text.count(' ')\n    words = text.split()\n    \n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n\n    space_between_words = spaces // (len(words) - 1)\n    extra_spaces = spaces % (len(words) - 1)\n    result = ''\n    \n    for i, word in enumerate(words):\n        result += word\n        if i < len(words) - 1:\n            result += ' ' * space_between_words\n    \n    result += ' ' * extra_spaces\n\n    return result\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n\nstd::string reorderSpaces(const std::string& text) {\n    int spaces = 0;\n    std::vector<std::string> words;\n    \n    std::stringstream ss(text);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n        spaces += std::count(word.begin(), word.end(), ' ');\n    }\n    \n    if (words.size() == 1) {\n        return words[0] + std::string(spaces, ' ');\n    }\n\n    int space_between_words = spaces / (words.size() - 1);\n    int extra_spaces = spaces % (words.size() - 1);\n    std::string result;\n    \n    for (size_t i = 0; i < words.size(); i++) {\n        result += words[i];\n        if (i < words.size() - 1) {\n            result += std::string(space_between_words, ' ');\n        }\n    }\n    \n    result += std::string(extra_spaces, ' ');\n\n    return result;\n}\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    ",
        "js": "\n    ```javascript\nfunction reorderSpaces(text) {\n    const spaces = text.split('').filter(char => char === ' ').length;\n    const words = text.trim().split(/\\s+/);\n    \n    if (words.length === 1) {\n        return words[0] + ' '.repeat(spaces);\n    }\n\n    const spaceBetweenWords = Math.floor(spaces / (words.length - 1));\n    const extraSpaces = spaces % (words.length - 1);\n    let result = '';\n    \n    for (let i = 0; i < words.length; i++) {\n        result += words[i];\n        if (i < words.length - 1) {\n            result += ' '.repeat(spaceBetweenWords);\n        }\n    }\n    \n    result += ' '.repeat(extraSpaces);\n\n    return result;\n}\n```\n    \n    1. Count the number of spaces and split the text into a list/vector of words.\n2. If there's only one word, return the word followed by all spaces.\n3. Calculate the number of spaces to be distributed between words, as well as the extra spaces that remain.\n4. Iterate through the words, and for each word, append it to the result variable. If the current word is not the last one, append the appropriate number of spaces.\n5. After the loop, append any extra spaces to the result variable.\n6. Return the result variable.\n    "
    },
    {
        "id": 269,
        "title": "Checking Existence of Edge Length Limited Paths II",
        "difficulty": "Hard",
        "content": {
            "problem": "An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be **multiple** edges between two nodes, and the graph may not be connected.\n\nImplement the `DistanceLimitedPathsExist` class:\n\n*   `DistanceLimitedPathsExist(int n, int[][] edgeList)` Initializes the class with an undirected graph.\n*   `boolean query(int p, int q, int limit)` Returns `true` if there exists a path from `p` to `q` such that each edge on the path has a distance **strictly less than** `limit`, and otherwise `false`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"DistanceLimitedPathsExist \",  \"query \",  \"query \",  \"query \",  \"query \"\\]\n\\[\\[6, \\[\\[0, 2, 4\\], \\[0, 3, 2\\], \\[1, 2, 3\\], \\[2, 3, 1\\], \\[4, 5, 5\\]\\]\\], \\[2, 3, 2\\], \\[1, 3, 3\\], \\[2, 0, 3\\], \\[0, 5, 6\\]\\]\n**Output**\n\\[null, true, false, true, false\\]\n\n**Explanation**\nDistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, \\[\\[0, 2, 4\\], \\[0, 3, 2\\], \\[1, 2, 3\\], \\[2, 3, 1\\], \\[4, 5, 5\\]\\]);\ndistanceLimitedPathsExist.query(2, 3, 2); // return true. There is an edge from 2 to 3 of distance 1, which is less than 2.\ndistanceLimitedPathsExist.query(1, 3, 3); // return false. There is no way to go from 1 to 3 with distances **strictly** less than 3.\ndistanceLimitedPathsExist.query(2, 0, 3); // return true. There is a way to go from 2 to 0 with distance < 3: travel from 2 to 3 to 0.\ndistanceLimitedPathsExist.query(0, 5, 6); // return false. There are no paths from 0 to 5.\n\n`"
            ],
            "constraints": "**Constraints:**`\n\n*   `2 <= n <= 104`\n*   `0 <= edgeList.length <= 104`\n*   `edgeList[i].length == 3`\n*   `0 <= ui, vi, p, q <= n-1`\n*   `ui != vi`\n*   `p != q`\n*   `1 <= disi, limit <= 109`\n*   At most `104` calls will be made to `query`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],]]],[2,3,2],[1,3,3],[2,0,3],[0,5,6]]",
                "output": "**Output**\n[null,true,false,true,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.ArrayList;\n\nclass DistanceLimitedPathsExist {\n    public DistanceLimitedPathsExist(int n, int[][] edgeList) {\n        id = new int[n];\n        for (int i = 0; i < n; ++i) {\n            id[i] = i;\n        }\n        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));\n        for (int[] edge : edgeList) {\n            int p = find(edge[0]);\n            int q = find(edge[1]);\n            if (p != q) {\n                id[p] = id[q];\n                mst.add(edge);\n            }\n        }\n    }\n\n    public boolean query(int p, int q, int limit) {\n        for (int[] edge : mst) {\n            if (edge[2] >= limit) break;\n            p = union_set(edge[0], p);\n            q = union_set(edge[1], q);\n            if (p == q) return true;\n        }\n        return false;\n    }\n\n    private int find(int x) {\n        if (id[x] != x) {\n            id[x] = find(id[x]);\n        }\n        return id[x];\n    }\n\n    private int union_set(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        if (px != py) {\n            id[px] = py;\n        }\n        return py;\n    }\n\n    private int[] id;\n    private ArrayList<int[]> mst = new ArrayList<>();\n}\n```\n    \n    The solution is based on the Kruskal algorithm, which helps to find the minimum spanning tree (MST). In this case, it will construct a data structure that represents the graph in MST form. We first initialize the disjoint set data structure for union-find operations.\n\nIn the constructor, we sort the `edgeList` by the edge weights (distance). Then, we iterate through the sorted edge list, performing union-find operations based on the minimum cost. We add the merged edges to the `mst` data structure.\n\nFor the `query()` function, we iterate through the MST and attempt to create a path from `p` to `q` with the given distance constraints. If the path is found, we return `true`, and if not, we return `false`.\n\nThe `find()` and `union_set()` are simple helper functions for the union-find operations.\n\nNote that this algorithm does not guarantee the overall minimum distance between two nodes but helps to find paths with distances less than the given `limit`. To find the minimum distance for all pairs of nodes, you could use the Floyd-Warshall algorithm. However, implementing Floyd-Warshall is not necessary for this problem statement.\n    ",
        "python": "\n    ```python\nclass DistanceLimitedPathsExist:\n    def __init__(self, n: int, edgeList: List[List[int]]):\n        self.id = list(range(n))\n        edgeList.sort(key=lambda x: x[2])\n        self.mst = []\n        for edge in edgeList:\n            p, q = self.find(edge[0]), self.find(edge[1])\n            if p != q:\n                self.id[p] = self.id[q]\n                self.mst.append(edge)\n\n    def query(self, p: int, q: int, limit: int) -> bool:\n        for edge in self.mst:\n            if edge[2] >= limit:\n                break\n            p, q = self.union_set(edge[0], p), self.union_set(edge[1], q)\n            if p == q:\n                return True\n        return False\n\n    def find(self, x: int) -> int:\n        if self.id[x] != x:\n            self.id[x] = self.find(self.id[x])\n        return self.id[x]\n\n    def union_set(self, x: int, y: int) -> int:\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.id[px] = py\n        return py\n```\n    \n    The solution is based on the Kruskal algorithm, which helps to find the minimum spanning tree (MST). In this case, it will construct a data structure that represents the graph in MST form. We first initialize the disjoint set data structure for union-find operations.\n\nIn the constructor, we sort the `edgeList` by the edge weights (distance). Then, we iterate through the sorted edge list, performing union-find operations based on the minimum cost. We add the merged edges to the `mst` data structure.\n\nFor the `query()` function, we iterate through the MST and attempt to create a path from `p` to `q` with the given distance constraints. If the path is found, we return `true`, and if not, we return `false`.\n\nThe `find()` and `union_set()` are simple helper functions for the union-find operations.\n\nNote that this algorithm does not guarantee the overall minimum distance between two nodes but helps to find paths with distances less than the given `limit`. To find the minimum distance for all pairs of nodes, you could use the Floyd-Warshall algorithm. However, implementing Floyd-Warshall is not necessary for this problem statement.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nclass DistanceLimitedPathsExist {\npublic:\n    DistanceLimitedPathsExist(int n, const std::vector<std::vector<int>>& edgeList) {\n        id.resize(n);\n        for (int i = 0; i < n; ++i) {\n            id[i] = i;\n        }\n        std::sort(edgeList.begin(), edgeList.end(), [](const auto& a, const auto& b) {\n            return a[2] < b[2];\n        });\n        for (const auto& edge : edgeList) {\n            int p = find(edge[0]);\n            int q = find(edge[1]);\n            if (p != q) {\n                id[p] = id[q];\n                mst.emplace_back(edge);\n            }\n        }\n    }\n    \n    bool query(int p, int q, int limit) {\n        for (const auto& edge : mst) {\n            if (edge[2] >= limit) break;\n            p = union_set(edge[0], p);\n            q = union_set(edge[1], q);\n            if (p == q) return true;\n        }\n        return false;\n    }\n\nprivate:\n    int find(int x) {\n        if (id[x] != x) {\n            id[x] = find(id[x]);\n        }\n        return id[x];\n    }\n\n    int union_set(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        if (px != py) {\n            id[px] = py;\n        }\n        return py;\n    }\n    \n    std::vector<int> id;\n    std::vector<std::vector<int>> mst;\n};\n```\n    \n    The solution is based on the Kruskal algorithm, which helps to find the minimum spanning tree (MST). In this case, it will construct a data structure that represents the graph in MST form. We first initialize the disjoint set data structure for union-find operations.\n\nIn the constructor, we sort the `edgeList` by the edge weights (distance). Then, we iterate through the sorted edge list, performing union-find operations based on the minimum cost. We add the merged edges to the `mst` data structure.\n\nFor the `query()` function, we iterate through the MST and attempt to create a path from `p` to `q` with the given distance constraints. If the path is found, we return `true`, and if not, we return `false`.\n\nThe `find()` and `union_set()` are simple helper functions for the union-find operations.\n\nNote that this algorithm does not guarantee the overall minimum distance between two nodes but helps to find paths with distances less than the given `limit`. To find the minimum distance for all pairs of nodes, you could use the Floyd-Warshall algorithm. However, implementing Floyd-Warshall is not necessary for this problem statement.\n    ",
        "js": "\n    ```javascript\nclass DistanceLimitedPathsExist {\n    constructor(n, edgeList) {\n        this.id = Array.from({ length: n }, (_, i) => i);\n        edgeList.sort((a, b) => a[2] - b[2]);\n        this.mst = [];\n        for (const edge of edgeList) {\n            const p = this.find(edge[0]);\n            const q = this.find(edge[1]);\n            if (p !== q) {\n                this.id[p] = this.id[q];\n                this.mst.push(edge);\n            }\n        }\n    }\n\n    query(p, q, limit) {\n        for (const edge of this.mst) {\n            if (edge[2] >= limit) break;\n            p = this.union_set(edge[0], p);\n            q = this.union_set(edge[1], q);\n            if (p === q) return true;\n        }\n        return false;\n    }\n\n    find(x) {\n        if (this.id[x] !== x) {\n            this.id[x] = this.find(this.id[x]);\n        }\n        return this.id[x];\n    }\n\n    union_set(x, y) {\n        const px = this.find(x);\n        const py = this.find(y);\n        if (px !== py) {\n            this.id[px] = py;\n        }\n        return py;\n    }\n}\n```\n    \n    The solution is based on the Kruskal algorithm, which helps to find the minimum spanning tree (MST). In this case, it will construct a data structure that represents the graph in MST form. We first initialize the disjoint set data structure for union-find operations.\n\nIn the constructor, we sort the `edgeList` by the edge weights (distance). Then, we iterate through the sorted edge list, performing union-find operations based on the minimum cost. We add the merged edges to the `mst` data structure.\n\nFor the `query()` function, we iterate through the MST and attempt to create a path from `p` to `q` with the given distance constraints. If the path is found, we return `true`, and if not, we return `false`.\n\nThe `find()` and `union_set()` are simple helper functions for the union-find operations.\n\nNote that this algorithm does not guarantee the overall minimum distance between two nodes but helps to find paths with distances less than the given `limit`. To find the minimum distance for all pairs of nodes, you could use the Floyd-Warshall algorithm. However, implementing Floyd-Warshall is not necessary for this problem statement.\n    "
    },
    {
        "id": 270,
        "title": "Shortest Path to Get Food",
        "difficulty": "Medium",
        "content": {
            "problem": "You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.\n\nYou are given an `m x n` character matrix, `grid`, of these different types of cells:\n\n*   `'*'` is your location. There is **exactly one** `'*'` cell.\n*   `'#'` is a food cell. There may be **multiple** food cells.\n*   `'O'` is free space, and you can travel through these cells.\n*   `'X'` is an obstacle, and you cannot travel through these cells.\n\nYou can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.\n\nReturn _the **length** of the shortest path for you to reach **any** food cell_. If there is no path for you to reach food, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[ \"X \", \"X \", \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"\\* \", \"O \", \"O \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"# \", \"O \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \", \"X \", \"X \"\\]\\]\n**Output:** 3\n**Explanation:** It takes 3 steps to reach the food.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[ \"X \", \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"\\* \", \"X \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"# \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \", \"X \"\\]\\]\n**Output:** -1\n**Explanation:** It is not possible to reach the food.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[ \"X \", \"X \", \"X \", \"X \", \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"\\* \", \"O \", \"X \", \"O \", \"# \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"X \", \"O \", \"O \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"O \", \"O \", \"# \", \"O \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \", \"X \", \"X \", \"X \", \"X \"\\]\\]\n**Output:** 6\n**Explanation:** There can be multiple food cells. It only takes 6 steps to reach the bottom food."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[row][col]` is `'*'`, `'X'`, `'O'`, or `'#'`.\n*   The `grid` contains **exactly one** `'*'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]]",
                "output": "3"
            },
            {
                "input": "[[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"#\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]",
                "output": "-1"
            },
            {
                "input": "[[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"O\",\"X\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int findSpecialInteger(int[] nums) {\n    for (int x = 1; x <= nums.length; ++x) {\n        int count = 0;\n        for (int num : nums) {\n            if (num >= x) {\n                ++count;\n            }\n        }\n        if (count == x) {\n            return x;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through all integer values of x from 1 to the length of nums. For each value of x, it counts how many elements in nums are greater than or equal to x. If the count is equal to x, the array is considered special and the value of x is returned. If no such x is found after iterating through all possible values, the algorithm returns -1.\n    ",
        "python": "\n    ```python\ndef find_special_integer(nums):\n    for x in range(1, len(nums) + 1):\n        count = sum(1 for num in nums if num >= x)\n        if count == x:\n            return x\n    return -1\n```\n    \n    The algorithm iterates through all integer values of x from 1 to the length of nums. For each value of x, it counts how many elements in nums are greater than or equal to x. If the count is equal to x, the array is considered special and the value of x is returned. If no such x is found after iterating through all possible values, the algorithm returns -1.\n    ",
        "c++": "\n    ```cpp\nint findSpecialInteger(const std::vector<int>& nums) {\n    for (int x = 1; x <= nums.size(); ++x) {\n        int count = 0;\n        for (int num : nums) {\n            if (num >= x) {\n                ++count;\n            }\n        }\n        if (count == x) {\n            return x;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through all integer values of x from 1 to the length of nums. For each value of x, it counts how many elements in nums are greater than or equal to x. If the count is equal to x, the array is considered special and the value of x is returned. If no such x is found after iterating through all possible values, the algorithm returns -1.\n    ",
        "js": "\n    ```javascript\nfunction findSpecialInteger(nums) {\n    for (let x = 1; x <= nums.length; ++x) {\n        let count = 0;\n        for (let num of nums) {\n            if (num >= x) {\n                ++count;\n            }\n        }\n        if (count === x) {\n            return x;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through all integer values of x from 1 to the length of nums. For each value of x, it counts how many elements in nums are greater than or equal to x. If the count is equal to x, the array is considered special and the value of x is returned. If no such x is found after iterating through all possible values, the algorithm returns -1.\n    "
    },
    {
        "id": 271,
        "title": "Find Distance in a Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the root of a binary tree and two integers `p` and `q`, return _the **distance** between the nodes of value_ `p` _and value_ `q` _in the tree_.\n\nThe **distance** between two nodes is the number of edges on the path from one to the other.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 0\n**Output:** 3\n**Explanation:** There are 3 edges between 5 and 0: 5-3-1-0.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 7\n**Output:** 2\n**Explanation:** There are 2 edges between 5 and 7: 5-2-7.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 5\n**Output:** 0\n**Explanation:** The distance between a node and itself is 0."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p` and `q` are values in the tree.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,0",
                "output": "3"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,7",
                "output": "2"
            },
            {
                "input": "[3,5,1,6,2,0,8,null,null,7,4],5,5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int[] countSubgraphsForEachD(int n, int[][] edges) {\n    List<List<Integer>> tree = new ArrayList<>();\n    for (int i = 0; i <= n; i++) {\n        tree.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        tree.get(edge[0]).add(edge[1]);\n        tree.get(edge[1]).add(edge[0]);\n    }\n    \n    int[] ans = new int[n - 1];\n    for (int i = 1; i <= n; i++) {\n        int maxD = dfs(tree, i, 0);\n        if (maxD > 0) ans[maxD - 1]++;\n    }\n    return ans;\n}\n\nprivate int dfs(List<List<Integer>> tree, int node, int parent) {\n    int depth = 0;\n    for (int child : tree.get(node)) {\n        if (child != parent) depth = Math.max(depth, 1 + dfs(tree, child, node));\n    }\n    return depth;\n}\n```\n    \n    1. Convert the given edges into a tree data structure (an adjacency list).\n2. Write a recursive depth-first search (dfs) function that returns the maximum depth of a given node from its children, excluding the parent.\n3. Loop through each city from 1 to n and call the dfs function with the city as the starting node and 0 as the parent. Calculate the maximum distance (maxD) for each city.\n4. Increment the count in the ans array for the index of maxD - 1.\n5. The ans array now contains the count of subtrees for each distance d.\n\n(Note: This solution counts each subtree twice, but it doesn't affect the final result, as every subtree is counted twice, which cancels out the multiplicity.)\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef countSubgraphsForEachD(n, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def dfs(node, parent):\n        depth = 0\n        for child in tree[node]:\n            if child != parent:\n                depth = max(depth, 1 + dfs(child, node))\n        return depth\n\n    ans = [0] * (n - 1)\n    for i in range(1, n + 1):\n        maxD = dfs(i, 0)\n        if maxD > 0:\n            ans[maxD - 1] += 1\n\n    return ans\n```\n    \n    1. Convert the given edges into a tree data structure (an adjacency list).\n2. Write a recursive depth-first search (dfs) function that returns the maximum depth of a given node from its children, excluding the parent.\n3. Loop through each city from 1 to n and call the dfs function with the city as the starting node and 0 as the parent. Calculate the maximum distance (maxD) for each city.\n4. Increment the count in the ans array for the index of maxD - 1.\n5. The ans array now contains the count of subtrees for each distance d.\n\n(Note: This solution counts each subtree twice, but it doesn't affect the final result, as every subtree is counted twice, which cancels out the multiplicity.)\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<int> countSubgraphsForEachD(int n, vector<pair<int, int>>& edges) {\n    vector<vector<int>> tree(n + 1);\n    for (auto &edge : edges) {\n        tree[edge.first].push_back(edge.second);\n        tree[edge.second].push_back(edge.first);\n    }\n    \n    function<int(int, int)> dfs = [&](int node, int parent) {\n        int depth = 0;\n        for (int child : tree[node]) {\n            if (child != parent) depth = max(depth, 1 + dfs(child, node));\n        }\n        return depth;\n    };\n    \n    vector<int> ans(n - 1);\n    for (int i = 1; i <= n; ++i) {\n        int maxD = dfs(i, 0);\n        if (maxD > 0) ans[maxD - 1]++;\n    }\n    return ans;\n}\n```\n    \n    1. Convert the given edges into a tree data structure (an adjacency list).\n2. Write a recursive depth-first search (dfs) function that returns the maximum depth of a given node from its children, excluding the parent.\n3. Loop through each city from 1 to n and call the dfs function with the city as the starting node and 0 as the parent. Calculate the maximum distance (maxD) for each city.\n4. Increment the count in the ans array for the index of maxD - 1.\n5. The ans array now contains the count of subtrees for each distance d.\n\n(Note: This solution counts each subtree twice, but it doesn't affect the final result, as every subtree is counted twice, which cancels out the multiplicity.)\n    ",
        "js": "\n    ```javascript\nfunction countSubgraphsForEachD(n, edges) {\n    const tree = Array.from({ length: n + 1 }, () => []);\n    for (const [u, v] of edges) {\n        tree[u].push(v);\n        tree[v].push(u);\n    }\n\n    function dfs(node, parent) {\n        let depth = 0;\n        for (const child of tree[node]) {\n            if (child !== parent) depth = Math.max(depth, 1 + dfs(child, node));\n        }\n        return depth;\n    }\n\n    const ans = new Array(n - 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        const maxD = dfs(i, 0);\n        if (maxD > 0) ans[maxD - 1]++;\n    }\n    return ans;\n}\n```\n    \n    1. Convert the given edges into a tree data structure (an adjacency list).\n2. Write a recursive depth-first search (dfs) function that returns the maximum depth of a given node from its children, excluding the parent.\n3. Loop through each city from 1 to n and call the dfs function with the city as the starting node and 0 as the parent. Calculate the maximum distance (maxD) for each city.\n4. Increment the count in the ans array for the index of maxD - 1.\n5. The ans array now contains the count of subtrees for each distance d.\n\n(Note: This solution counts each subtree twice, but it doesn't affect the final result, as every subtree is counted twice, which cancels out the multiplicity.)\n    "
    },
    {
        "id": 272,
        "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **(0-indexed)** array of positive integers `candiesCount` where `candiesCount[i]` represents the number of candies of the `ith` type you have. You are also given a 2D array `queries` where `queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]`.\n\nYou play a game with the following rules:\n\n*   You start eating candies on day `**0**`.\n*   You **cannot** eat **any** candy of type `i` unless you have eaten **all** candies of type `i - 1`.\n*   You must eat **at least** **one** candy per day until you have eaten all the candies.\n\nConstruct a boolean array `answer` such that `answer.length == queries.length` and `answer[i]` is `true` if you can eat a candy of type `favoriteTypei` on day `favoriteDayi` without eating **more than** `dailyCapi` candies on **any** day, and `false` otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.\n\nReturn _the constructed array_ `answer`.",
            "examples": [
                "**Example 1:**\n\n**Input:** candiesCount = \\[7,4,5,3,8\\], queries = \\[\\[0,2,2\\],\\[4,2,4\\],\\[2,13,1000000000\\]\\]\n**Output:** \\[true,false,true\\]\n**Explanation:**\n1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.\n2- You can eat at most 4 candies each day.\n   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.\n   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.\n3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.\n\n",
                "**Example 2:**\n\n**Input:** candiesCount = \\[5,2,6,4,1\\], queries = \\[\\[3,1,2\\],\\[4,10,3\\],\\[3,10,100\\],\\[4,100,30\\],\\[1,3,1\\]\\]\n**Output:** \\[false,true,true,false,false\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= candiesCount.length <= 105`\n*   `1 <= candiesCount[i] <= 105`\n*   `1 <= queries.length <= 105`\n*   `queries[i].length == 3`\n*   `0 <= favoriteTypei < candiesCount.length`\n*   `0 <= favoriteDayi <= 109`\n*   `1 <= dailyCapi <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[7,4,5,3,8],[[0,2,2],[4,2,4],[2,13,1000000000]]",
                "output": "[true,false,true]"
            },
            {
                "input": "[5,2,6,4,1],[[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]",
                "output": "[false,true,true,false,false]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int numWays(List<String> words, String target) {\n    int n = words.size(), m = target.length();\n    int MOD = 1000000007;\n    int[] cnt = new int[26];\n    for (String word : words) {\n        for (char ch : word.toCharArray()) {\n            cnt[ch - 'a']++;\n        }\n    }\n    long[] dp = new long[m + 1];\n    dp[0] = 1;\n    for (char ch : target.toCharArray()) {\n        for (int i = m - 1; i >= 0; i--) {\n            dp[i + 1] += dp[i] * cnt[ch - 'a'];\n            dp[i + 1] %= MOD;\n        }\n    }\n    return (int)dp[m];\n}\n```\n    \n    First, we count the frequency of each character in the given words and store it in an array `cnt`. Then, we use dynamic programming. Initialize a `dp` array of size m+1 (where m is the length of the target string) and set `dp[0] = 1`.\n\nIterate through all characters in the target string, and for each character, iterate through the `dp` array in reverse order from m-1 to 0. Update `dp[i+1]` as: `dp[i+1] += dp[i] * cnt[ch - 'a']`, taking the modulo 1e9+7 at every step.\n\nIn the end, return `dp[m]` which contains the number of ways to form the target from the given words.\n    ",
        "python": "\n    ```python\ndef num_ways(words, target):\n    n, m = len(words), len(target)\n    MOD = 10**9 + 7\n    cnt = [0] * 26\n    for word in words:\n        for ch in word:\n            cnt[ord(ch) - ord('a')] += 1\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    for ch in target:\n        for i in range(m - 1, -1, -1):\n            dp[i + 1] += dp[i] * cnt[ord(ch) - ord('a')]\n            dp[i + 1] %= MOD\n    return dp[m]\n```\n    \n    First, we count the frequency of each character in the given words and store it in an array `cnt`. Then, we use dynamic programming. Initialize a `dp` array of size m+1 (where m is the length of the target string) and set `dp[0] = 1`.\n\nIterate through all characters in the target string, and for each character, iterate through the `dp` array in reverse order from m-1 to 0. Update `dp[i+1]` as: `dp[i+1] += dp[i] * cnt[ch - 'a']`, taking the modulo 1e9+7 at every step.\n\nIn the end, return `dp[m]` which contains the number of ways to form the target from the given words.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nconst int MOD = 1e9 + 7;\n\nint numWays(std::vector<std::string>& words, std::string& target) {\n    int n = words.size(), m = target.size();\n    std::vector<int> cnt(26);\n    for (const std::string& word : words) {\n        for (char ch : word) {\n            cnt[ch - 'a']++;\n        }\n    }\n    std::vector<long long> dp(m + 1);\n    dp[0] = 1;\n    for (char ch : target) {\n        for (int i = m - 1; i >= 0; i--) {\n            dp[i + 1] += dp[i] * cnt[ch - 'a'];\n            dp[i + 1] %= MOD;\n        }\n    }\n    return dp[m];\n}\n```\n    \n    First, we count the frequency of each character in the given words and store it in an array `cnt`. Then, we use dynamic programming. Initialize a `dp` array of size m+1 (where m is the length of the target string) and set `dp[0] = 1`.\n\nIterate through all characters in the target string, and for each character, iterate through the `dp` array in reverse order from m-1 to 0. Update `dp[i+1]` as: `dp[i+1] += dp[i] * cnt[ch - 'a']`, taking the modulo 1e9+7 at every step.\n\nIn the end, return `dp[m]` which contains the number of ways to form the target from the given words.\n    ",
        "js": "\n    ```javascript\nfunction numWays(words, target) {\n    let n = words.length, m = target.length;\n    const MOD = 1e9 + 7;\n    let cnt = Array(26).fill(0);\n    for (let word of words) {\n        for (let ch of word) {\n            cnt[ch.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n    }\n    let dp = Array(m + 1).fill(0);\n    dp[0] = 1;\n    for (let ch of target) {\n        for (let i = m - 1; i >= 0; i--) {\n            dp[i + 1] += dp[i] * cnt[ch.charCodeAt(0) - 'a'.charCodeAt(0)];\n            dp[i + 1] %= MOD;\n        }\n    }\n    return dp[m];\n}\n```\n    \n    First, we count the frequency of each character in the given words and store it in an array `cnt`. Then, we use dynamic programming. Initialize a `dp` array of size m+1 (where m is the length of the target string) and set `dp[0] = 1`.\n\nIterate through all characters in the target string, and for each character, iterate through the `dp` array in reverse order from m-1 to 0. Update `dp[i+1]` as: `dp[i+1] += dp[i] * cnt[ch - 'a']`, taking the modulo 1e9+7 at every step.\n\nIn the end, return `dp[m]` which contains the number of ways to form the target from the given words.\n    "
    },
    {
        "id": 273,
        "title": "Maximum Subarray Sum After One Operation",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums`. You must perform **exactly one** operation where you can **replace** one element `nums[i]` with `nums[i] * nums[i]`.\n\nReturn _the **maximum** possible subarray sum after **exactly one** operation_. The subarray must be non-empty.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,-1,-4,-3\\]\n**Output:** 17\n**Explanation:** You can perform the operation on index 2 (0-indexed) to make nums = \\[2,-1,**16**,-3\\]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,-1,1,1,-1,-1,1\\]\n**Output:** 4\n**Explanation:** You can perform the operation on index 1 (0-indexed) to make nums = \\[1,**1**,1,1,-1,-1,1\\]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,-1,-4,-3]",
                "output": "17"
            },
            {
                "input": "[1,-1,1,1,-1,-1,1]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxLengthBetweenEqualCharacters(String s) {\n    int maxLength = -1;\n    HashMap<Character, Integer> charIndexMap = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char currentChar = s.charAt(i);\n\n        if (charIndexMap.containsKey(currentChar)) {\n            maxLength = Math.max(maxLength, i - charIndexMap.get(currentChar) - 1);\n        } else {\n            charIndexMap.put(currentChar, i);\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    ",
        "python": "\n    ```python\ndef maxLengthBetweenEqualCharacters(s: str) -> int:\n    max_length = -1\n    char_index_map = {}\n\n    for i, char in enumerate(s):\n        if char in char_index_map:\n            max_length = max(max_length, i - char_index_map[char] - 1)\n        else:\n            char_index_map[char] = i\n\n    return max_length\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    ",
        "c++": "\n    ```cpp\nint maxLengthBetweenEqualCharacters(std::string s) {\n    int maxLength = -1;\n    std::unordered_map<char, int> charIndexMap;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (charIndexMap.count(s[i])) {\n            maxLength = std::max(maxLength, i - charIndexMap[s[i]] - 1);\n        } else {\n            charIndexMap[s[i]] = i;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    ",
        "js": "\n    ```javascript\nfunction maxLengthBetweenEqualCharacters(s) {\n    let maxLength = -1;\n    let charIndexMap = new Map();\n\n    for (let i = 0; i < s.length; i++) {\n        if (charIndexMap.has(s[i])) {\n            maxLength = Math.max(maxLength, i - charIndexMap.get(s[i]) - 1);\n        } else {\n            charIndexMap.set(s[i], i);\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    1. Initialize maxLength to -1 and create a hash map (or dictionary) called charIndexMap.\n2. Iterate through the string s and for each character:\n   a. If the character is already in charIndexMap, update maxLength with the maximum value between the current maxLength and the distance between the current index and the previous index of the character minus 1.\n   b. If the character is not in the charIndexMap, store the character and its index in the map.\n3. Return maxLength. If maxLength is never updated (no equal characters found), it will return -1 as required.\n    "
    },
    {
        "id": 274,
        "title": "Design Most Recently Used Queue",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a queue-like data structure that moves the most recently used element to the end of the queue.\n\nImplement the `MRUQueue` class:\n\n*   `MRUQueue(int n)` constructs the `MRUQueue` with `n` elements: `[1,2,3,...,n]`.\n*   `int fetch(int k)` moves the `kth` element **(1-indexed)** to the end of the queue and returns it.",
            "examples": [
                "**Example 1:**\n\n**Input:**\n\\[ \"MRUQueue \",  \"fetch \",  \"fetch \",  \"fetch \",  \"fetch \"\\]\n\\[\\[8\\], \\[3\\], \\[5\\], \\[2\\], \\[8\\]\\]\n**Output:**\n\\[null, 3, 6, 2, 2\\]\n\n**Explanation:**\nMRUQueue mRUQueue = new MRUQueue(8); // Initializes the queue to \\[1,2,3,4,5,6,7,8\\].\nmRUQueue.fetch(3); // Moves the 3rd element (3) to the end of the queue to become \\[1,2,4,5,6,7,8,3\\] and returns it.\nmRUQueue.fetch(5); // Moves the 5th element (6) to the end of the queue to become \\[1,2,4,5,7,8,3,6\\] and returns it.\nmRUQueue.fetch(2); // Moves the 2nd element (2) to the end of the queue to become \\[1,4,5,7,8,3,6,2\\] and returns it.\nmRUQueue.fetch(8); // The 8th element (2) is already at the end of the queue so just return it."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `1 <= k <= n`\n*   At most `2000` calls will be made to `fetch`.\n\n**",
            "follow_up": "Follow up:** Finding an `O(n)` algorithm per `fetch` is a bit easy. Can you find an algorithm with a better complexity for each `fetch` call?"
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],]]",
                "output": "\n[null,3,6,2,2]"
            }
        ],
        "java": "\n    ```java\npublic int minDeletions(String s) {\n    int aCount = 0, bCount = 0, deletions = 0;\n    for (char c : s.toCharArray()) {\n        if (c == 'a') {\n            aCount++;\n        } else {\n            if (aCount > 0) {\n                aCount--;\n            } else {\n                deletions++;\n            }\n        }\n    }\n    return deletions;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize counters for the number of 'a' characters seen (`aCount`) and the number of deletions needed (`deletions`).\n2. Iterate through the characters in the input string `s`.\n3. If the current character is 'a', increment the `aCount` counter.\n4. If the current character is 'b', check if the `aCount` counter is greater than 0.\n5. If `aCount` is greater than 0, it means we can pair a previously seen 'a' with this 'b', so decrement `aCount`.\n6. If `aCount` is not greater than 0, it means there are no 'a's to pair with this 'b', so increment the `deletions` counter.\n7. At the end of the loop, return the `deletions` counter as the result.\n\nThis algorithm ensures that for each 'b' character we encounter, we either pair it with a previously seen 'a' character or delete it if there are no 'a's to pair with. As a result, we minimize the number of deletions needed to make the string balanced.\n    ",
        "python": "\n    ```python\ndef min_deletions(s: str) -> int:\n    a_count, deletions = 0, 0\n    for c in s:\n        if c == 'a':\n            a_count += 1\n        else:\n            if a_count > 0:\n                a_count -= 1\n            else:\n                deletions += 1\n    return deletions\n```\n    \n    The algorithm works as follows:\n1. Initialize counters for the number of 'a' characters seen (`aCount`) and the number of deletions needed (`deletions`).\n2. Iterate through the characters in the input string `s`.\n3. If the current character is 'a', increment the `aCount` counter.\n4. If the current character is 'b', check if the `aCount` counter is greater than 0.\n5. If `aCount` is greater than 0, it means we can pair a previously seen 'a' with this 'b', so decrement `aCount`.\n6. If `aCount` is not greater than 0, it means there are no 'a's to pair with this 'b', so increment the `deletions` counter.\n7. At the end of the loop, return the `deletions` counter as the result.\n\nThis algorithm ensures that for each 'b' character we encounter, we either pair it with a previously seen 'a' character or delete it if there are no 'a's to pair with. As a result, we minimize the number of deletions needed to make the string balanced.\n    ",
        "c++": "\n    ```cpp\nint minDeletions(string s) {\n    int aCount = 0, bCount = 0, deletions = 0;\n    for (char c : s) {\n        if (c == 'a') {\n            aCount++;\n        } else {\n            if (aCount > 0) {\n                aCount--;\n            } else {\n                deletions++;\n            }\n        }\n    }\n    return deletions;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize counters for the number of 'a' characters seen (`aCount`) and the number of deletions needed (`deletions`).\n2. Iterate through the characters in the input string `s`.\n3. If the current character is 'a', increment the `aCount` counter.\n4. If the current character is 'b', check if the `aCount` counter is greater than 0.\n5. If `aCount` is greater than 0, it means we can pair a previously seen 'a' with this 'b', so decrement `aCount`.\n6. If `aCount` is not greater than 0, it means there are no 'a's to pair with this 'b', so increment the `deletions` counter.\n7. At the end of the loop, return the `deletions` counter as the result.\n\nThis algorithm ensures that for each 'b' character we encounter, we either pair it with a previously seen 'a' character or delete it if there are no 'a's to pair with. As a result, we minimize the number of deletions needed to make the string balanced.\n    ",
        "js": "\n    ```javascript\nfunction minDeletions(s) {\n    let aCount = 0, deletions = 0;\n    for (let c of s) {\n        if (c === 'a') {\n            aCount++;\n        } else {\n            if (aCount > 0) {\n                aCount--;\n            } else {\n                deletions++;\n            }\n        }\n    }\n    return deletions;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize counters for the number of 'a' characters seen (`aCount`) and the number of deletions needed (`deletions`).\n2. Iterate through the characters in the input string `s`.\n3. If the current character is 'a', increment the `aCount` counter.\n4. If the current character is 'b', check if the `aCount` counter is greater than 0.\n5. If `aCount` is greater than 0, it means we can pair a previously seen 'a' with this 'b', so decrement `aCount`.\n6. If `aCount` is not greater than 0, it means there are no 'a's to pair with this 'b', so increment the `deletions` counter.\n7. At the end of the loop, return the `deletions` counter as the result.\n\nThis algorithm ensures that for each 'b' character we encounter, we either pair it with a previously seen 'a' character or delete it if there are no 'a's to pair with. As a result, we minimize the number of deletions needed to make the string balanced.\n    "
    },
    {
        "id": 275,
        "title": "Buildings With an Ocean View",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` buildings in a line. You are given an integer array `heights` of size `n` that represents the heights of the buildings in the line.\n\nThe ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a **smaller** height.\n\nReturn a list of indices **(0-indexed)** of buildings that have an ocean view, sorted in increasing order.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[4,2,3,1\\]\n**Output:** \\[0,2,3\\]\n**Explanation:** Building 1 (0-indexed) does not have an ocean view because building 2 is taller.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[4,3,2,1\\]\n**Output:** \\[0,1,2,3\\]\n**Explanation:** All the buildings have an ocean view.\n\n",
                "**Example 3:**\n\n**Input:** heights = \\[1,3,2,4\\]\n**Output:** \\[3\\]\n**Explanation:** Only building 3 has an ocean view."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,3,1]",
                "output": "[0,2,3]"
            },
            {
                "input": "[4,3,2,1]",
                "output": "[0,1,2,3]"
            },
            {
                "input": "[1,3,2,4]",
                "output": "[3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int furthestBuilding(int[] heights, int bricks, int ladders) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int i = 0; i < heights.length - 1; ++i) {\n        int diff = heights[i + 1] - heights[i];\n        if (diff > 0) {\n            minHeap.offer(diff);\n            if (minHeap.size() > ladders) {\n                bricks -= minHeap.poll();\n                if (bricks < 0) {\n                    return i;\n                }\n            }\n        }\n    }\n    return heights.length - 1;\n}\n```\n\n    \n    The algorithm uses a priority queue (min heap) to store the differences in height for each consecutive pair of buildings. As we go through the list of buildings, if the height difference is positive (meaning we need to climb), we push the difference into the min heap. If the size of the min heap becomes larger than the number of ladders we have, it means we have to use bricks. Therefore, we remove the smallest height difference from the min heap and subtract it from our remaining bricks. If we run out of bricks (bricks < 0), we return the last building index we could reach. If we successfully go through the entire loop, we return the last building index in the list.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef furthest_building(heights, bricks, ladders):\n    min_heap = []\n    for i in range(len(heights) - 1):\n        diff = heights[i + 1] - heights[i]\n        if diff > 0:\n            heapq.heappush(min_heap, diff)\n            if len(min_heap) > ladders:\n                bricks -= heapq.heappop(min_heap)\n                if bricks < 0:\n                    return i\n    return len(heights) - 1\n```\n\n    \n    The algorithm uses a priority queue (min heap) to store the differences in height for each consecutive pair of buildings. As we go through the list of buildings, if the height difference is positive (meaning we need to climb), we push the difference into the min heap. If the size of the min heap becomes larger than the number of ladders we have, it means we have to use bricks. Therefore, we remove the smallest height difference from the min heap and subtract it from our remaining bricks. If we run out of bricks (bricks < 0), we return the last building index we could reach. If we successfully go through the entire loop, we return the last building index in the list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nint furthestBuilding(std::vector<int>& heights, int bricks, int ladders) {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    for (int i = 0; i < heights.size() - 1; ++i) {\n        int diff = heights[i + 1] - heights[i];\n        if (diff > 0) {\n            min_heap.push(diff);\n            if (min_heap.size() > ladders) {\n                bricks -= min_heap.top();\n                min_heap.pop();\n                if (bricks < 0) {\n                    return i;\n                }\n            }\n        }\n    }\n    return heights.size() - 1;\n}\n```\n\n    \n    The algorithm uses a priority queue (min heap) to store the differences in height for each consecutive pair of buildings. As we go through the list of buildings, if the height difference is positive (meaning we need to climb), we push the difference into the min heap. If the size of the min heap becomes larger than the number of ladders we have, it means we have to use bricks. Therefore, we remove the smallest height difference from the min heap and subtract it from our remaining bricks. If we run out of bricks (bricks < 0), we return the last building index we could reach. If we successfully go through the entire loop, we return the last building index in the list.\n    ",
        "js": "\n    ```javascript\nfunction furthestBuilding(heights, bricks, ladders) {\n    const minHeap = [];\n    for (let i = 0; i < heights.length - 1; ++i) {\n        const diff = heights[i + 1] - heights[i];\n        if (diff > 0) {\n            minHeap.push(diff);\n            minHeap.sort((a, b) => a - b);\n            if (minHeap.length > ladders) {\n                bricks -= minHeap.shift();\n                if (bricks < 0) {\n                    return i;\n                }\n            }\n        }\n    }\n    return heights.length - 1;\n}\n```\n\n    \n    The algorithm uses a priority queue (min heap) to store the differences in height for each consecutive pair of buildings. As we go through the list of buildings, if the height difference is positive (meaning we need to climb), we push the difference into the min heap. If the size of the min heap becomes larger than the number of ladders we have, it means we have to use bricks. Therefore, we remove the smallest height difference from the min heap and subtract it from our remaining bricks. If we run out of bricks (bricks < 0), we return the last building index we could reach. If we successfully go through the entire loop, we return the last building index in the list.\n    "
    },
    {
        "id": 276,
        "title": "Sort Features by Popularity",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string array `features` where `features[i]` is a single word that represents the name of a feature of the latest product you are working on. You have made a survey where users have reported which features they like. You are given a string array `responses`, where each `responses[i]` is a string containing space-separated words.\n\nThe **popularity** of a feature is the number of `responses[i]` that contain the feature. You want to sort the features in non-increasing order by their popularity. If two features have the same popularity, order them by their original index in `features`. Notice that one response could contain the same feature multiple times; this feature is only counted once in its popularity.\n\nReturn _the features in sorted order._",
            "examples": [
                "**Example 1:**\n\n**Input:** features = \\[ \"cooler \", \"lock \", \"touch \"\\], responses = \\[ \"i like cooler cooler \", \"lock touch cool \", \"locker like touch \"\\]\n**Output:** \\[ \"touch \", \"cooler \", \"lock \"\\]\n**Explanation:** appearances( \"cooler \") = 1, appearances( \"lock \") = 1, appearances( \"touch \") = 2. Since  \"cooler \" and  \"lock \" both had 1 appearance,  \"cooler \" comes first because  \"cooler \" came first in the features array.\n\n",
                "**Example 2:**\n\n**Input:** features = \\[ \"a \", \"aa \", \"b \", \"c \"\\], responses = \\[ \"a \", \"a aa \", \"a a a a a \", \"b a \"\\]\n**Output:** \\[ \"a \", \"aa \", \"b \", \"c \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= features.length <= 104`\n*   `1 <= features[i].length <= 10`\n*   `features` contains no duplicates.\n*   `features[i]` consists of lowercase letters.\n*   `1 <= responses.length <= 102`\n*   `1 <= responses[i].length <= 103`\n*   `responses[i]` consists of lowercase letters and spaces.\n*   `responses[i]` contains no two consecutive spaces.\n*   `responses[i]` has no leading or trailing spaces.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"cooler\",\"lock\",\"touch\"],[\"ilikecoolercooler\",\"locktouchcool\",\"lockerliketouch\"]",
                "output": "[\"touch\",\"cooler\",\"lock\"]"
            },
            {
                "input": "[\"a\",\"aa\",\"b\",\"c\"],[\"a\",\"aaa\",\"aaaaa\",\"ba\"]",
                "output": "[\"a\",\"aa\",\"b\",\"c\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeSet;\n\nclass Solution {\n    final int MOD = 1000000007;\n    \n    public int createSortedArray(int[] instructions) {\n        TreeSet<Integer> set = new TreeSet<>();\n        int cost = 0;\n\n        for (int i : instructions) {\n            set.add(i);\n            int less_than = set.headSet(i).size();\n            int greater_than = set.tailSet(i + 1).size();\n            cost = (cost + Math.min(less_than, greater_than)) % MOD;\n        }\n\n        return cost;\n    }\n}\n```\n    \n    First, initialize a container `s` and `cost` variable to store elements and cost. Iterate through each element in instructions. For each element, calculate the count of elements less than and greater than the current element in the container. Add minimum of the counts to the `cost` and apply modulo 1e9 + 7 to the cost. Finally, insert the element into the container. After the iteration, return the total `cost`.\n\nNote that for higher efficiency, we use specific data structures with built-in functionality, such as C++'s `multiset` or Python's `SortedList`, so time complexity is kept at O(N * log(N)). \n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\nMOD = int(1e9) + 7\n\ndef create_sorted_array(instructions):\n    s = SortedList()\n    cost = 0\n\n    for i in instructions:\n        less_than = s.bisect_left(i)\n        greater_than = len(s) - s.bisect_right(i)\n        cost = (cost + min(less_than, greater_than)) % MOD\n        s.add(i)\n\n    return cost\n```\n    \n    First, initialize a container `s` and `cost` variable to store elements and cost. Iterate through each element in instructions. For each element, calculate the count of elements less than and greater than the current element in the container. Add minimum of the counts to the `cost` and apply modulo 1e9 + 7 to the cost. Finally, insert the element into the container. After the iteration, return the total `cost`.\n\nNote that for higher efficiency, we use specific data structures with built-in functionality, such as C++'s `multiset` or Python's `SortedList`, so time complexity is kept at O(N * log(N)). \n    ",
        "c++": "\n    ```cpp\n#include <set>\n\nconst int MOD = 1e9 + 7;\n\nint createSortedArray(vector<int>& instructions) {\n    multiset<int> s;\n    int cost = 0;\n\n    for (int i : instructions) {\n        s.insert(i);\n        int less_than = distance(s.begin(), s.lower_bound(i));\n        int greater_than = distance(s.upper_bound(i), s.end());\n        cost = (cost + min(less_than, greater_than)) % MOD;\n    }\n\n    return cost;\n}\n```\n    \n    First, initialize a container `s` and `cost` variable to store elements and cost. Iterate through each element in instructions. For each element, calculate the count of elements less than and greater than the current element in the container. Add minimum of the counts to the `cost` and apply modulo 1e9 + 7 to the cost. Finally, insert the element into the container. After the iteration, return the total `cost`.\n\nNote that for higher efficiency, we use specific data structures with built-in functionality, such as C++'s `multiset` or Python's `SortedList`, so time complexity is kept at O(N * log(N)). \n    ",
        "js": "\n    ```javascript\nconst MOD = 1e9 + 7\n\nfunction createSortedArray(instructions) {\n    let nums = new Set();\n    let cost = 0;\n\n    for (let i of instructions) {\n        nums.add(i);\n        let sortedNums = Array.from(nums).sort((a, b) => a - b);\n        let less_than = sortedNums.filter(x => x < i).length;\n        let greater_than = sortedNums.filter(x => x > i).length;\n        cost = (cost + Math.min(less_than, greater_than)) % MOD;\n        nums = new Set(sortedNums);\n    }\n\n    return cost;\n}\n```\n    \n    First, initialize a container `s` and `cost` variable to store elements and cost. Iterate through each element in instructions. For each element, calculate the count of elements less than and greater than the current element in the container. Add minimum of the counts to the `cost` and apply modulo 1e9 + 7 to the cost. Finally, insert the element into the container. After the iteration, return the total `cost`.\n\nNote that for higher efficiency, we use specific data structures with built-in functionality, such as C++'s `multiset` or Python's `SortedList`, so time complexity is kept at O(N * log(N)). \n    "
    },
    {
        "id": 277,
        "title": "Shortest Path in a Hidden Grid",
        "difficulty": "Medium",
        "content": {
            "problem": "This is an **interactive problem**.\n\nThere is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size `m x n`, and each cell in the grid is either empty or blocked. It is **guaranteed** that the starting cell and the target cell are different, and neither of them is blocked.\n\nYou want to find the minimum distance to the target cell. However, you **do not know** the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the `GridMaster` object.\n\nThr `GridMaster` class has the following functions:\n\n*   `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.\n*   `void move(char direction)` Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored**, and the robot will remain in the same position.\n*   `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.\n\nNote that `direction` in the above functions should be a character from `{'U','D','L','R'}`, representing the directions up, down, left, and right, respectively.\n\nReturn _the **minimum distance** between the robot's initial starting cell and the target cell. If there is no valid path between the cells, return_ `-1`.\n\n**Custom testing:**\n\nThe test input is read as a 2D matrix `grid` of size `m x n` where:\n\n*   `grid[i][j] == -1` indicates that the robot is in cell `(i, j)` (the starting cell).\n*   `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.\n*   `grid[i][j] == 1` indicates that the cell `(i, j)` is empty.\n*   `grid[i][j] == 2` indicates that the cell `(i, j)` is the target cell.\n\nThere is exactly one `-1` and `2` in `grid`. Remember that you will **not** have this information in your code.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,2\\],\\[-1,0\\]\\]\n**Output:** 2\n**Explanation:** One possible interaction is described below:\nThe robot is initially standing on cell (1, 0), denoted by the -1.\n- master.canMove('U') returns true.\n- master.canMove('D') returns false.\n- master.canMove('L') returns false.\n- master.canMove('R') returns false.\n- master.move('U') moves the robot to the cell (0, 0).\n- master.isTarget() returns false.\n- master.canMove('U') returns false.\n- master.canMove('D') returns true.\n- master.canMove('L') returns false.\n- master.canMove('R') returns true.\n- master.move('R') moves the robot to the cell (0, 1).\n- master.isTarget() returns true. \nWe now know that the target is the cell (0, 1), and the shortest path to the target cell is 2.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,0,-1\\],\\[1,1,1\\],\\[2,0,0\\]\\]\n**Output:** 4\n**Explanation:** The minimum distance between the robot and the target cell is 4.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[-1,0\\],\\[0,2\\]\\]\n**Output:** -1\n**Explanation:** There is no path from the robot to the target cell."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n, m <= 500`\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `grid[i][j]` is either `-1`, `0`, `1`, or `2`.\n*   There is **exactly one** `-1` in `grid`.\n*   There is **exactly one** `2` in `grid`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,2],[-1,0]]",
                "output": "2"
            },
            {
                "input": "[[0,0,-1],[1,1,1],[2,0,0]]",
                "output": "4"
            },
            {
                "input": "[[-1,0],[0,2]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nint[][][][] dp = new int[6][6][37][64];\nboolean[][][][] seen = new boolean[6][6][37][64];\n\nint maxHappy(int m, int n, int introvertsCount, int extrovertsCount, int y, int mask) {\n    if (y == n)\n        return 0;\n\n    if (seen[m][n][introvertsCount][mask])\n        return dp[m][n][introvertsCount][mask];\n    seen[m][n][introvertsCount][mask] = true;\n\n    int cur = y * m, ans = 0;\n    for (int x = 0; x <= m; ++x) {\n        int happiness = 0;\n        if ((mask >> x) & 1) {\n            happiness -= 30;\n            if (x > 0 && (mask & 1))\n                happiness -= 30;\n            else\n                happiness += 20;\n        }\n        ans = Math.max(ans, happiness + maxHappy(m, n, introvertsCount, extrovertsCount, y + 1, (mask | (1 << x)) >> 1));\n    }\n\n    return dp[m][n][introvertsCount][mask] = ans;\n}\n\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    return maxHappy(m, n, introvertsCount, extrovertsCount, 0, 0);\n}\n```\n\n    \n    We use a dynamic programming approach to solve this problem. \n1. First we define the function maxHappy(y, mask) to find the maximum happiness.\n2. We loop through all possible \"x\" values (i.e., we loop through all the cells in the m * n grid).\n3. For each \"x\" value, we calculate the happiness.\n4. We decide whether to add an introvert or extrovert in the current cell.\n5. We add the happiness of that person and call the function maxHappy() recursively for next row.\n6. We cache the result of maxHappy() to avoid redundant calculations.\n7. The result will be the maximum happiness of the grid.\n\nThe main function getMaxGridHappiness() initializes the required values and calls the maxHappy() function. \n    ",
        "python": "\n    ```python\nfrom functools import lru_cache\n\ndef getMaxGridHappiness(m, n, introvertsCount, extrovertsCount):\n    @lru_cache(None)\n    def maxHappy(y, mask):\n        if y == n:\n            return 0\n\n        ans = 0\n        for x in range(m + 1):\n            happiness = 0\n            if mask >> x & 1:\n                happiness -= 30\n                if x > 0 and mask & 1:\n                    happiness -= 30\n                else:\n                    happiness += 20\n            ans = max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1))\n\n        return ans\n\n    return maxHappy(0, 0)\n```\n\n    \n    We use a dynamic programming approach to solve this problem. \n1. First we define the function maxHappy(y, mask) to find the maximum happiness.\n2. We loop through all possible \"x\" values (i.e., we loop through all the cells in the m * n grid).\n3. For each \"x\" value, we calculate the happiness.\n4. We decide whether to add an introvert or extrovert in the current cell.\n5. We add the happiness of that person and call the function maxHappy() recursively for next row.\n6. We cache the result of maxHappy() to avoid redundant calculations.\n7. The result will be the maximum happiness of the grid.\n\nThe main function getMaxGridHappiness() initializes the required values and calls the maxHappy() function. \n    ",
        "c++": "\n    ```cpp\nint maxHappy(int m, int n, int introvertsCount, int extrovertsCount, int y = 0, int mask = 0) {\n    if (y == n)\n        return 0;\n\n    static int dp[6][6][6 * 6][1 << 6];\n    static bool seen[6][6][6 * 6][1 << 6] = {};\n    if (seen[m][n][introvertsCount][mask])\n        return dp[m][n][introvertsCount][mask];\n    seen[m][n][introvertsCount][mask] = true;\n\n    int cur = y * m, ans = 0;\n    for (int x = 0; x <= m; ++x) {\n        int happiness = 0;\n        if ((mask >> x) & 1) {\n            happiness -= 30;\n            if (x > 0 && (mask & 1))\n                happiness -= 30;\n            else\n                happiness += 20;\n        }\n        ans = max(ans, happiness + maxHappy(m, n, introvertsCount, extrovertsCount, y + 1, (mask | (1 << x)) >> 1));\n    }\n\n    return dp[m][n][introvertsCount][mask] = ans;\n}\n\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    return maxHappy(m, n, introvertsCount, extrovertsCount);\n}\n```\n\n    \n    We use a dynamic programming approach to solve this problem. \n1. First we define the function maxHappy(y, mask) to find the maximum happiness.\n2. We loop through all possible \"x\" values (i.e., we loop through all the cells in the m * n grid).\n3. For each \"x\" value, we calculate the happiness.\n4. We decide whether to add an introvert or extrovert in the current cell.\n5. We add the happiness of that person and call the function maxHappy() recursively for next row.\n6. We cache the result of maxHappy() to avoid redundant calculations.\n7. The result will be the maximum happiness of the grid.\n\nThe main function getMaxGridHappiness() initializes the required values and calls the maxHappy() function. \n    ",
        "js": "\n    ```javascript\nfunction getMaxGridHappiness(m, n, introvertsCount, extrovertsCount) {\n    const dp = Array.from({ length: 6 }, () => Array.from({ length: 6 }, () => Array.from({ length: 37 }, () => Array(64).fill(0))));\n    const seen = Array.from({ length: 6 }, () => Array.from({ length: 6 }, () => Array.from({ length: 37 }, () => Array(64).fill(false))));\n\n    function maxHappy(y, mask) {\n        if (y == n)\n            return 0;\n\n        if (seen[m][n][introvertsCount][mask])\n            return dp[m][n][introvertsCount][mask];\n        seen[m][n][introvertsCount][mask] = true;\n\n        let ans = 0;\n        for (let x = 0; x <= m; ++x) {\n            let happiness = 0;\n            if (mask >> x & 1) {\n                happiness -= 30;\n                if (x > 0 && mask & 1)\n                    happiness -= 30;\n                else\n                    happiness += 20;\n            }\n            ans = Math.max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1));\n        }\n\n        return dp[m][n][introvertsCount][mask] = ans;\n    }\n\n    return maxHappy(0, 0);\n}\n```\n\n    \n    We use a dynamic programming approach to solve this problem. \n1. First we define the function maxHappy(y, mask) to find the maximum happiness.\n2. We loop through all possible \"x\" values (i.e., we loop through all the cells in the m * n grid).\n3. For each \"x\" value, we calculate the happiness.\n4. We decide whether to add an introvert or extrovert in the current cell.\n5. We add the happiness of that person and call the function maxHappy() recursively for next row.\n6. We cache the result of maxHappy() to avoid redundant calculations.\n7. The result will be the maximum happiness of the grid.\n\nThe main function getMaxGridHappiness() initializes the required values and calls the maxHappy() function. \n    "
    },
    {
        "id": 278,
        "title": "Maximize the Beauty of the Garden",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a garden of `n` flowers, and each flower has an integer beauty value. The flowers are arranged in a line. You are given an integer array `flowers` of size `n` and each `flowers[i]` represents the beauty of the `ith` flower.\n\nA garden is **valid** if it meets these conditions:\n\n*   The garden has at least two flowers.\n*   The first and the last flower of the garden have the same beauty value.\n\nAs the appointed gardener, you have the ability to **remove** any (possibly none) flowers from the garden. You want to remove flowers in a way that makes the remaining garden **valid**. The beauty of the garden is the sum of the beauty of all the remaining flowers.\n\nReturn the maximum possible beauty of some **valid** garden after you have removed any (possibly none) flowers.",
            "examples": [
                "**Example 1:**\n\n**Input:** flowers = \\[1,2,3,1,2\\]\n**Output:** 8\n**Explanation:** You can produce the valid garden \\[2,3,1,2\\] to have a total beauty of 2 + 3 + 1 + 2 = 8.\n\n",
                "**Example 2:**\n\n**Input:** flowers = \\[100,1,1,-3,1\\]\n**Output:** 3\n**Explanation:** You can produce the valid garden \\[1,1,1\\] to have a total beauty of 1 + 1 + 1 = 3.\n\n",
                "**Example 3:**\n\n**Input:** flowers = \\[-1,-2,0,-1\\]\n**Output:** -2\n**Explanation:** You can produce the valid garden \\[-1,-1\\] to have a total beauty of -1 + -1 = -2."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= flowers.length <= 105`\n*   `-104 <= flowers[i] <= 104`\n*   It is possible to create a valid garden by removing some (possibly none) flowers.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,1,2]",
                "output": "8"
            },
            {
                "input": "[100,1,1,-3,1]",
                "output": "3"
            },
            {
                "input": "[-1,-2,0,-1]",
                "output": "-2"
            }
        ],
        "java": "\n    ```java\npublic int stoneGameVI(int[] aliceValues, int[] bobValues) {\n    int n = aliceValues.length;\n    Integer[] indexes = new Integer[n];\n    for (int i = 0; i < n; ++i) {\n        indexes[i] = i;\n    }\n\n    Arrays.sort(indexes, (a, b) -> (bobValues[b] + aliceValues[b]) - (bobValues[a] + aliceValues[a]));\n    \n    int aliceScore = 0, bobScore = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) aliceScore += aliceValues[indexes[i]];\n        else bobScore += bobValues[indexes[i]];\n    }\n    \n    return Integer.compare(aliceScore, bobScore);\n}\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    ",
        "python": "\n    ```python\ndef stoneGameVI(aliceValues, bobValues):\n    n = len(aliceValues)\n    sums = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n    \n    aliceScore = sum(aliceValues[i] for _, i in sums[::2])\n    bobScore = sum(bobValues[i] for _, i in sums[1::2])\n    \n    return 0 if aliceScore == bobScore else 1 if aliceScore > bobScore else -1\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    ",
        "c++": "\n    ```cpp\nint stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n    int n = aliceValues.size();\n    vector<pair<int, int>> sums;\n    \n    for (int i = 0; i < n; ++i) {\n        sums.push_back({aliceValues[i] + bobValues[i], i});\n    }\n    \n    sort(sums.rbegin(), sums.rend());\n    \n    int aliceScore = 0, bobScore = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) aliceScore += aliceValues[sums[i].second];\n        else bobScore += bobValues[sums[i].second];\n    }\n    \n    return (aliceScore == bobScore) ? 0 : (aliceScore > bobScore) ? 1 : -1;\n}\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    ",
        "js": "\n    ```javascript\nfunction stoneGameVI(aliceValues, bobValues) {\n    const n = aliceValues.length;\n    const sums = aliceValues.map((v, i) => [v + bobValues[i], i]).sort((a, b) => b[0] - a[0]);\n\n    let aliceScore = 0, bobScore = 0;\n    for (let i = 0; i < n; ++i) {\n        if (i % 2 === 0) aliceScore += aliceValues[sums[i][1]];\n        else bobScore += bobValues[sums[i][1]];\n    }\n\n    return aliceScore === bobScore ? 0 : aliceScore > bobScore ? 1 : -1;\n}\n```\n    \n    The game is played optimally. Therefore, each player will pick the stones that maximize the difference in scores. To achieve this, both players will consider the sum of their values and the opponent's values for each stone. Sort the stone indices in descending order according to the sums of Alice's and Bob's values. Then, each player takes turns picking stones according to this sorted order. Calculate the total scores for Alice and Bob. Finally, return 0 if the scores are equal, 1 if Alice has a higher score, and -1 if Bob has a higher score.\n    "
    },
    {
        "id": 279,
        "title": "Count Pairs of Equal Substrings With Minimum Difference",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two strings `firstString` and `secondString` that are **0-indexed** and consist only of lowercase English letters. Count the number of index quadruples `(i,j,a,b)` that satisfy the following conditions:\n\n*   `0 <= i <= j < firstString.length`\n*   `0 <= a <= b < secondString.length`\n*   The substring of `firstString` that starts at the `ith` character and ends at the `jth` character (inclusive) is **equal** to the substring of `secondString` that starts at the `ath` character and ends at the `bth` character (inclusive).\n*   `j - a` is the **minimum** possible value among all quadruples that satisfy the previous conditions.\n\nReturn _the **number** of such quadruples_.",
            "examples": [
                "**Example 1:**\n\n**Input:** firstString =  \"abcd \", secondString =  \"bccda \"\n**Output:** 1\n**Explanation:** The quadruple (0,0,4,4) is the only one that satisfies all the conditions and minimizes j - a.\n\n",
                "**Example 2:**\n\n**Input:** firstString =  \"ab \", secondString =  \"cd \"\n**Output:** 0\n**Explanation:** There are no quadruples satisfying all the conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= firstString.length, secondString.length <= 2 * 105`\n*   Both strings consist only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcd\",\"bccda\"",
                "output": "1"
            },
            {
                "input": "\"ab\",\"cd\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minimumDeviation(int[] nums) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    int min_val = Integer.MAX_VALUE;\n    \n    for (int num : nums) {\n        if (num % 2 == 0) {\n            pq.offer(num);\n        } else {\n            pq.offer(num * 2);\n        }\n        min_val = Math.min(min_val, num);\n    }\n    \n    int result = Integer.MAX_VALUE;\n    while (true) {\n        int top = pq.poll();\n        result = Math.min(result, top - min_val);\n        \n        if (top % 2 == 1) break;\n        pq.offer(top / 2);\n        min_val = Math.min(min_val, top / 2);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef minimum_deviation(nums):\n    pq = []\n    min_val = float(\"inf\")\n\n    for num in nums:\n        if num % 2 == 0:\n            heapq.heappush(pq, -num)\n        else:\n            heapq.heappush(pq, -(num * 2))\n        min_val = min(min_val, num)\n\n    result = float(\"inf\")\n    while True:\n        top = -heapq.heappop(pq)\n        result = min(result, top - min_val)\n\n        if top % 2 == 1:\n            break\n        heapq.heappush(pq, -(top // 2))\n        min_val = min(min_val, top // 2)\n\n    return result\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint minimumDeviation(vector<int>& nums) {\n    priority_queue<int> pq;\n    int min_val = INT_MAX;\n    int n = nums.size();\n    \n    for (int num: nums) {\n        if (num % 2 == 0) {\n            pq.push(num);\n        } else {\n            pq.push(num * 2);\n        }\n        min_val = min(min_val, num);\n    }\n    \n    int result = INT_MAX;\n    while (true) {\n        int top = pq.top();\n        pq.pop();\n        result = min(result, top - min_val);\n        \n        if (top % 2 == 1) break;\n        pq.push(top / 2);\n        min_val = min(min_val, top / 2);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    ",
        "js": "\n    ```javascript\nfunction minimumDeviation(nums) {\n    const pq = new MaxPriorityQueue();\n    let min_val = Infinity;\n\n    for (const num of nums) {\n        if (num % 2 === 0) {\n            pq.enqueue(num);\n        } else {\n            pq.enqueue(num * 2);\n        }\n        min_val = Math.min(min_val, num);\n    }\n\n    let result = Infinity;\n    while (true) {\n        const top = pq.dequeue().element;\n        result = Math.min(result, top - min_val);\n\n        if (top % 2 === 1) break;\n        pq.enqueue(Math.floor(top / 2));\n        min_val = Math.min(min_val, Math.floor(top / 2));\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a max priority queue and find the minimum value of the input array.\n2. Double the odd number elements in the array and push all the elements into the max priority queue.\n3. While the maximum value in the queue is even, divide the maximum value by 2 and push it back into the queue.\n4. Calculate the deviation as the difference between the max value and the min value and minimize the result.\n    "
    },
    {
        "id": 280,
        "title": "Minimum Path Cost in a Hidden Grid",
        "difficulty": "Medium",
        "content": {
            "problem": "This is an **interactive problem**.\n\nThere is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size `m x n`, and each cell in the grid is either empty or blocked. It is **guaranteed** that the starting cell and the target cell are different, and neither of them is blocked.\n\nEach cell has a **cost** that you need to pay each time you **move** to the cell. The starting cell's cost is **not** applied before the robot moves.\n\nYou want to find the minimum total cost to move the robot to the target cell. However, you **do not know** the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the `GridMaster` object.\n\nThe `GridMaster` class has the following functions:\n\n*   `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.\n*   `int move(char direction)` Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored**, the robot will remain in the same position, and the function will return `-1`.\n*   `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.\n\nNote that `direction` in the above functions should be a character from `{'U','D','L','R'}`, representing the directions up, down, left, and right, respectively.\n\nReturn _the **minimum total cost** to get the robot from its initial starting cell to the target cell. If there is no valid path between the cells, return_ `-1`.\n\n**Custom testing:**\n\nThe test input is read as a 2D matrix `grid` of size `m x n` and four integers `r1`, `c1`, `r2`, and `c2` where:\n\n*   `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.\n*   `grid[i][j] >= 1` indicates that the cell `(i, j)` is empty and `grid[i][j]` is the **cost** to move to that cell.\n*   `(r1, c1)` is the starting cell of the robot.\n*   `(r2, c2)` is the target cell of the robot.\n\nRemember that you will **not** have this information in your code.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[2,3\\],\\[1,1\\]\\], r1 = 0, c1 = 1, r2 = 1, c2 = 0\n**Output:** 2\n**Explanation:** One possible interaction is described below:\nThe robot is initially standing on cell (0, 1), denoted by the 3.\n- master.canMove('U') returns false.\n- master.canMove('D') returns true.\n- master.canMove('L') returns true.\n- master.canMove('R') returns false.\n- master.move('L') moves the robot to the cell (0, 0) and returns 2.\n- master.isTarget() returns false.\n- master.canMove('U') returns false.\n- master.canMove('D') returns true.\n- master.canMove('L') returns false.\n- master.canMove('R') returns true.\n- master.move('D') moves the robot to the cell (1, 0) and returns 1.\n- master.isTarget() returns true.\n- master.move('L') doesn't move the robot and returns -1.\n- master.move('R') moves the robot to the cell (1, 1) and returns 1.\nWe now know that the target is the cell (1, 0), and the minimum total cost to reach it is 2. \n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,3,1\\],\\[3,4,2\\],\\[1,2,0\\]\\], r1 = 2, c1 = 0, r2 = 0, c2 = 2\n**Output:** 9\n**Explanation:** The minimum cost path is (2,0) -> (2,1) -> (1,1) -> (1,2) -> (0,2).\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\], r1 = 0, c1 = 0, r2 = 1, c2 = 1\n**Output:** -1\n**Explanation:** There is no path from the robot to the target cell."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n, m <= 100`\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `0 <= grid[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[2,3],[1,1]],0,1,1,0",
                "output": "2"
            },
            {
                "input": "[[0,3,1],[3,4,2],[1,2,0]],2,0,0,2",
                "output": "9"
            },
            {
                "input": "[[1,0],[0,1]],0,0,1,1",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    int[] dirs = {-1, 0, 1, 0, -1};\n    char[] dirChar = {'U', 'R', 'D', 'L'};\n    char[] oppositeDirChar = {'D', 'L', 'U', 'R'};\n    HashMap<Pair<Integer, Integer>, Integer> grid = new HashMap<>();\n    Pair<Integer, Integer> target = new Pair<>(Integer.MAX_VALUE, Integer.MAX_VALUE);\n\n    public int findShortestPath(GridMaster master) {\n        dfs(master, 0, 0);\n        if (target.getKey() == Integer.MAX_VALUE) {\n            return -1;\n        }\n        return bfs();\n    }\n\n    void dfs(GridMaster master, int x, int y) {\n        if (master.isTarget()) {\n            target = new Pair<>(x, y);\n        }\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dirs[i], ny = y + dirs[i + 1];\n            Pair<Integer, Integer> newPos = new Pair<>(nx, ny);\n            if (grid.containsKey(newPos)) continue;\n            if (master.canMove(dirChar[i])) {\n                int cost = master.move(dirChar[i]);\n                grid.put(newPos, cost);\n                dfs(master, nx, ny);\n                master.move(oppositeDirChar[i]);\n            }\n        }\n    }\n\n    int bfs() {\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\n        q.offer(new Pair<>(0, 0));\n        grid.put(new Pair<>(0, 0), 0);\n        while (!q.isEmpty()) {\n            Pair<Integer, Integer> pos = q.poll();\n            int x = pos.getKey(), y = pos.getValue();\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dirs[i], ny = y + dirs[i + 1];\n                Pair<Integer, Integer> newPos = new Pair<>(nx, ny), oldPos = new Pair<>(x, y);\n                int cost = grid.get(oldPos) + grid.getOrDefault(newPos, 0);\n                if (grid.containsKey(newPos) && grid.get(newPos) > cost) {\n                    grid.put(newPos, cost);\n                    if (nx != target.getKey() || ny != target.getValue()) {\n                        q.offer(new Pair<>(nx, ny));\n                    }\n                }\n            }\n        }\n        return grid.getOrDefault(target, -1);\n    }\n}\n```\n    \n    We are asked to find the minimum cost to go from the starting cell to the target cell without knowing the structure of the grid. To solve this problem, we can take the following steps:\n\n1. Start doing DFS from the robot's starting position called DFS function that recursively calls itself while navigating the grid using GridMaster functions. We maintain a dictionary `grid` to record the traversed cells and their costs, and also to mark the target cell.\n\n2. Once we found the target cell and constructed the grid, we can create a BFS function. Start BFS from the starting cell and update the minimum cost to reach each cell with the help of the `grid` dictionary. We stop when reaching the target cell.\n\n3. Return the cost at the target cell position. If it hasn't been reached or not found, return -1.\n\nBy doing DFS, we can uncover and find the cost of each cell and leveraging BFS to process the minimum cost of navigating to the target cell. The grid is not known beforehand, so the combined BFS-DFS approach is effective in exploring and finding the optimal path.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def findShortestPath(self, master: 'GridMaster') -> int:\n        def dfs(master, x, y):\n            nonlocal target\n            if master.isTarget():\n                target = (x, y)\n            for i in range(4):\n                nx, ny = x + dirs[i], y + dirs[i + 1]\n                if (nx, ny) in grid:\n                    continue\n                if master.canMove(DIR_CHAR[i]):\n                    cost = master.move(DIR_CHAR[i])\n                    grid[(nx, ny)] = cost\n                    dfs(master, nx, ny)\n                    master.move(OPPOSITE_DIR_CHAR[i])\n                    \n        def bfs():\n            q = deque([(0, 0)])\n            grid[(0, 0)] = 0\n            while q:\n                x, y = q.popleft()\n                for i in range(4):\n                    nx, ny = x + dirs[i], y + dirs[i + 1]\n                    cost = grid[(x, y)] + grid.get((nx, ny), 0)\n                    if (nx, ny) in grid and grid[(nx, ny)] > cost:\n                        grid[(nx, ny)] = cost\n                        if (nx, ny) != target:\n                            q.append((nx, ny))\n            return grid.get(target, -1)\n        \n        dirs = [-1, 0, 1, 0, -1]\n        DIR_CHAR = \"URDL\"\n        OPPOSITE_DIR_CHAR = \"DLUR\"\n        grid = {}\n        target = None\n        \n        dfs(master, 0, 0)\n        if target is None:\n            return -1\n        \n        return bfs()\n```\n    \n    We are asked to find the minimum cost to go from the starting cell to the target cell without knowing the structure of the grid. To solve this problem, we can take the following steps:\n\n1. Start doing DFS from the robot's starting position called DFS function that recursively calls itself while navigating the grid using GridMaster functions. We maintain a dictionary `grid` to record the traversed cells and their costs, and also to mark the target cell.\n\n2. Once we found the target cell and constructed the grid, we can create a BFS function. Start BFS from the starting cell and update the minimum cost to reach each cell with the help of the `grid` dictionary. We stop when reaching the target cell.\n\n3. Return the cost at the target cell position. If it hasn't been reached or not found, return -1.\n\nBy doing DFS, we can uncover and find the cost of each cell and leveraging BFS to process the minimum cost of navigating to the target cell. The grid is not known beforehand, so the combined BFS-DFS approach is effective in exploring and finding the optimal path.\n    ",
        "c++": "\n    ```cpp\nclass Solution {\npublic:\n    int findShortestPath(GridMaster &master) {\n        dfs(master, 0, 0);\n        if(target.first == INT_MAX) {\n            return -1;\n        }\n        return bfs();\n    }\n    \nprivate:\n    map<pair<int, int>, int> grid;\n    pair<int, int> target = {INT_MAX, INT_MAX};\n    int dirs[5] = {-1, 0, 1, 0, -1};\n    \n    void dfs(GridMaster &master, int x, int y) {\n        if (master.isTarget()) {\n            target = {x, y};\n        }\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dirs[i], ny = y + dirs[i + 1];\n            if(grid.count({nx, ny})) continue;\n            if (master.canMove(dir_char[i])) {\n                int cost = master.move(dir_char[i]);\n                grid[{nx, ny}] = cost;\n                dfs(master, nx, ny);\n                master.move(opposite_dir_char[i]);\n            }\n        }\n    }\n    \n    int bfs() {\n        queue<pair<int, int>> q;\n        q.push({0, 0});\n        grid[{0, 0}] = 0;\n        while(!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dirs[i], ny = y + dirs[i + 1];\n                int cost = grid[{x, y}] + grid[{nx, ny}];\n                if(grid.count({nx, ny}) && grid[{nx, ny}] > cost) {\n                    grid[{nx, ny}] = cost;\n                    if (nx != target.first || ny != target.second) {\n                        q.push({nx, ny});\n                    }\n                }\n            }\n        }\n        return grid[target];\n    }\n    \n    char dir_char[4] = {'U', 'R', 'D', 'L'};\n    char opposite_dir_char[4] = {'D', 'L', 'U', 'R'};\n};\n```\n    \n    We are asked to find the minimum cost to go from the starting cell to the target cell without knowing the structure of the grid. To solve this problem, we can take the following steps:\n\n1. Start doing DFS from the robot's starting position called DFS function that recursively calls itself while navigating the grid using GridMaster functions. We maintain a dictionary `grid` to record the traversed cells and their costs, and also to mark the target cell.\n\n2. Once we found the target cell and constructed the grid, we can create a BFS function. Start BFS from the starting cell and update the minimum cost to reach each cell with the help of the `grid` dictionary. We stop when reaching the target cell.\n\n3. Return the cost at the target cell position. If it hasn't been reached or not found, return -1.\n\nBy doing DFS, we can uncover and find the cost of each cell and leveraging BFS to process the minimum cost of navigating to the target cell. The grid is not known beforehand, so the combined BFS-DFS approach is effective in exploring and finding the optimal path.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    dirs = [-1, 0, 1, 0, -1];\n    dirChar = ['U', 'R', 'D', 'L'];\n    oppositeDirChar = ['D', 'L', 'U', 'R'];\n    grid = new Map();\n    target = [Infinity, Infinity];\n\n    findShortestPath(master) {\n        this.dfs(master, 0, 0);\n        if (this.target[0] === Infinity) {\n            return -1;\n        }\n        return this.bfs();\n    }\n\n    cellKey(x, y) {\n        return `${x},${y}`;\n    }\n\n    dfs(master, x, y) {\n        if (master.isTarget()){\n            this.target = [x, y];\n        }\n        for (let i = 0; i < 4; i++) {\n            let nx = x + this.dirs[i], ny = y + this.dirs[i + 1];\n            let newPos = this.cellKey(nx, ny);\n            if (this.grid.has(newPos)) continue;\n            if (master.canMove(this.dirChar[i])) {\n                let cost = master.move(this.dirChar[i]);\n                this.grid.set(newPos, cost);\n                this.dfs(master, nx, ny);\n                master.move(this.oppositeDirChar[i]);\n            }\n        }\n    }\n\n    bfs() {\n        let q = [[0, 0]];\n        this.grid.set(this.cellKey(0, 0), 0);\n        while (q.length > 0) {\n            let pos = q.shift();\n            let x = pos[0], y = pos[1];\n            for (let i = 0; i < 4; i++) {\n                let nx = x + this.dirs[i], ny = y + this.dirs[i + 1];\n                let newPos = this.cellKey(nx, ny), oldPos = this.cellKey(x, y);\n                let cost = this.grid.get(oldPos) + (this.grid.get(newPos) || 0);\n                if (this.grid.has(newPos) && this.grid.get(newPos) > cost) {\n                    this.grid.set(newPos, cost);\n                    if (nx !== this.target[0] || ny !== this.target[1]) {\n                        q.push([nx, ny]);\n                    }\n                }\n            }\n        }\n        return this.grid.get(this.cellKey(this.target[0], this.target[1])) || -1;\n    }\n}\n```\n    \n    We are asked to find the minimum cost to go from the starting cell to the target cell without knowing the structure of the grid. To solve this problem, we can take the following steps:\n\n1. Start doing DFS from the robot's starting position called DFS function that recursively calls itself while navigating the grid using GridMaster functions. We maintain a dictionary `grid` to record the traversed cells and their costs, and also to mark the target cell.\n\n2. Once we found the target cell and constructed the grid, we can create a BFS function. Start BFS from the starting cell and update the minimum cost to reach each cell with the help of the `grid` dictionary. We stop when reaching the target cell.\n\n3. Return the cost at the target cell position. If it hasn't been reached or not found, return -1.\n\nBy doing DFS, we can uncover and find the cost of each cell and leveraging BFS to process the minimum cost of navigating to the target cell. The grid is not known beforehand, so the combined BFS-DFS approach is effective in exploring and finding the optimal path.\n    "
    },
    {
        "id": 281,
        "title": "Maximum Number of Accepted Invitations",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `m` boys and `n` girls in a class attending an upcoming party.\n\nYou are given an `m x n` integer matrix `grid`, where `grid[i][j]` equals `0` or `1`. If `grid[i][j] == 1`, then that means the `ith` boy can invite the `jth` girl to the party. A boy can invite at most **one girl**, and a girl can accept at most **one invitation** from a boy.\n\nReturn _the **maximum** possible number of accepted invitations._",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1\\],\n               \\[1,0,1\\],\n               \\[0,0,1\\]\\]\n**Output:** 3\n**Explanation:** The invitations are sent as follows:\n- The 1st boy invites the 2nd girl.\n- The 2nd boy invites the 1st girl.\n- The 3rd boy invites the 3rd girl.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,0,1,0\\],\n               \\[1,0,0,0\\],\n               \\[0,0,1,0\\],\n               \\[1,1,1,0\\]\\]\n**Output:** 3\n**Explanation:** The invitations are sent as follows:\n-The 1st boy invites the 3rd girl.\n-The 2nd boy invites the 1st girl.\n-The 3rd boy invites no one.\n-The 4th boy invites the 2nd girl."
            ],
            "constraints": "**Constraints:**\n\n*   `grid.length == m`\n*   `grid[i].length == n`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,1],\n[1,0,1],\n[0,0,1]]",
                "output": "3"
            },
            {
                "input": "[[1,0,1,0],\n[1,0,0,0],\n[0,0,1,0],\n[1,1,1,0]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int countTrees(int[][] pairs) {\n    int nodes = pairs.length + 1;\n    int[] in_degrees = new int[nodes];\n    for (int[] pair : pairs) {\n        in_degrees[pair[1]]++;\n    }\n    \n    int res = 1;\n    for (int i = 1; i < nodes; i++) {\n        res *= in_degrees[i];\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm first calculates the number of nodes in the tree. Then, it initializes an array `in_degrees` of size `nodes`, which will store the in-degree (the number of incoming edges) of each node. It iterates through the given pairs and increases the in-degree of the parent node.\n\nFinally, the result is initialized to 1, and the algorithm multiplies the result by each value in the `in_degrees` list, starting from position 1 (skipping the root node). The result of this multiplication is the number of rooted trees that satisfy the conditions.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes.\n    ",
        "python": "\n    ```python\ndef count_trees(pairs):\n    nodes = len(pairs) + 1\n    in_degrees = [0] * nodes\n    for x, y in pairs:\n        in_degrees[y] += 1\n    \n    res = 1\n    for in_degree in in_degrees[1:]:\n        res *= in_degree\n    \n    return res\n```\n    \n    The algorithm first calculates the number of nodes in the tree. Then, it initializes an array `in_degrees` of size `nodes`, which will store the in-degree (the number of incoming edges) of each node. It iterates through the given pairs and increases the in-degree of the parent node.\n\nFinally, the result is initialized to 1, and the algorithm multiplies the result by each value in the `in_degrees` list, starting from position 1 (skipping the root node). The result of this multiplication is the number of rooted trees that satisfy the conditions.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint countTrees(vector<vector<int>>& pairs) {\n    int nodes = pairs.size() + 1;\n    vector<int> in_degrees(nodes, 0);\n    for (vector<int>& pair : pairs) {\n        in_degrees[pair[1]]++;\n    }\n    \n    int res = 1;\n    for (int i = 1; i < nodes; i++) {\n        res *= in_degrees[i];\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm first calculates the number of nodes in the tree. Then, it initializes an array `in_degrees` of size `nodes`, which will store the in-degree (the number of incoming edges) of each node. It iterates through the given pairs and increases the in-degree of the parent node.\n\nFinally, the result is initialized to 1, and the algorithm multiplies the result by each value in the `in_degrees` list, starting from position 1 (skipping the root node). The result of this multiplication is the number of rooted trees that satisfy the conditions.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes.\n    ",
        "js": "\n    ```javascript\nfunction countTrees(pairs) {\n    const nodes = pairs.length + 1;\n    const in_degrees = new Array(nodes).fill(0);\n    \n    for (const [x, y] of pairs) {\n        in_degrees[y]++;\n    }\n    \n    let res = 1;\n    for (let i = 1; i < nodes; i++) {\n        res *= in_degrees[i];\n    }\n    \n    return res;\n}\n```\n    \n    The algorithm first calculates the number of nodes in the tree. Then, it initializes an array `in_degrees` of size `nodes`, which will store the in-degree (the number of incoming edges) of each node. It iterates through the given pairs and increases the in-degree of the parent node.\n\nFinally, the result is initialized to 1, and the algorithm multiplies the result by each value in the `in_degrees` list, starting from position 1 (skipping the root node). The result of this multiplication is the number of rooted trees that satisfy the conditions.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes.\n    "
    },
    {
        "id": 282,
        "title": "Faulty Sensor",
        "difficulty": "Easy",
        "content": {
            "problem": "An experiment is being conducted in a lab. To ensure accuracy, there are **two** sensors collecting data simultaneously. You are given two arrays `sensor1` and `sensor2`, where `sensor1[i]` and `sensor2[i]` are the `ith` data points collected by the two sensors.\n\nHowever, this type of sensor has a chance of being defective, which causes **exactly one** data point to be dropped. After the data is dropped, all the data points to the **right** of the dropped data are **shifted** one place to the left, and the last data point is replaced with some **random value**. It is guaranteed that this random value will **not** be equal to the dropped value.\n\n*   For example, if the correct data is `[1,2,**3**,4,5]` and `3` is dropped, the sensor could return `[1,2,4,5,**7**]` (the last position can be **any** value, not just `7`).\n\nWe know that there is a defect in **at most one** of the sensors. Return _the sensor number (_`1` _or_ `2`_) with the defect. If there is **no defect** in either sensor or if it is **impossible** to determine the defective sensor, return_ `-1`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** sensor1 = \\[2,3,4,5\\], sensor2 = \\[2,1,3,4\\]\n**Output:** 1\n**Explanation:** Sensor 2 has the correct values.\nThe second data point from sensor 2 is dropped, and the last value of sensor 1 is replaced by a 5.\n\n",
                "**Example 2:**\n\n**Input:** sensor1 = \\[2,2,2,2,2\\], sensor2 = \\[2,2,2,2,5\\]\n**Output:** -1\n**Explanation:** It is impossible to determine which sensor has a defect.\nDropping the last value for either sensor could produce the output for the other sensor.\n\n",
                "**Example 3:**\n\n**Input:** sensor1 = \\[2,3,2,2,3,2\\], sensor2 = \\[2,3,2,3,2,7\\]\n**Output:** 2\n**Explanation:** Sensor 1 has the correct values.\nThe fourth data point from sensor 1 is dropped, and the last value of sensor 1 is replaced by a 7."
            ],
            "constraints": "**Constraints:**\n\n*   `sensor1.length == sensor2.length`\n*   `1 <= sensor1.length <= 100`\n*   `1 <= sensor1[i], sensor2[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,3,4,5],[2,1,3,4]",
                "output": "1"
            },
            {
                "input": "[2,2,2,2,2],[2,2,2,2,5]",
                "output": "-1"
            },
            {
                "input": "[2,3,2,2,3,2],[2,3,2,3,2,7]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int[] maximizeXor(int[] nums, int[][] queries) {\n    int[][] newQueries = new int[queries.length][];\n    Arrays.sort(nums);\n    for (int i = 0; i < queries.length; ++i) {\n        newQueries[i] = new int[]{queries[i][0], queries[i][1], i};\n    }\n    Arrays.sort(newQueries, Comparator.comparingInt(a -> a[1]));\n\n    int[] ans = new int[queries.length];\n    int[][] trie = new int[200010][2];\n    int[] sum = new int[200010];\n    sum[0] = 1;\n    int idx = 0, cnt = 0;\n    for (int[] q : newQueries) {\n        int x = q[0], m = q[1], k = q[2], p = 0;\n        while (idx < nums.length && nums[idx] <= m) {\n            int cur = 0, t = nums[idx++];\n            for (int i = 31; i >= 0; --i) {\n                int bit = ((t >> i) & 1);\n                if (trie[cur][bit] == 0) {\n                    trie[cur][bit] = ++cnt;\n                }\n                cur = trie[cur][bit];\n            }\n            sum[cur]++;\n        }\n        if (cnt == 0) { \n            ans[k] = -1; \n            continue; \n        }\n        int cur = 0, ans2 = 0;\n        for (int i = 31; i >= 0; --i) {\n            int bit = ((x >> i) & 1);\n            if (trie[cur][bit ^ 1] != 0) {\n                cur = trie[cur][bit ^ 1];\n                ans2 |= (1 << i);\n            } else {\n                cur = trie[cur][bit];\n            }\n        }\n        ans[k] = ans2;\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses a Trie data structure to store the binary representation of numbers in the nums array. \n\n1. First, sort the nums array in ascending order.\n2. Create a new queries array, adding the index to each query, and sort according to the mi value.\n3. Iterate through the sorted queries array and update Trie with nums elements that are less than or equal to mi. \n4. For each x in the query, traverse the Trie and find the highest XOR value achievable.\n5. If there are no Trie nodes, set the answer to -1 for that query.\n6. Store the answer of each query in the ans array at the index originally present in the original query array.\n7. Return the ans array containing the answer to all queries.\n    ",
        "python": "\n    ```python\ndef maximizeXor(nums, queries):\n    trie = {}\n    nums.sort()\n\n    new_queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda x: x[1])\n\n    ans = [0] * len(queries)\n\n    idx = 0\n    for x, m, i in new_queries:\n        while idx < len(nums) and nums[idx] <= m:\n            t = nums[idx]\n            idx += 1\n            cur = trie\n            for j in range(31, -1, -1):\n                bit = (t >> j) & 1\n                cur = cur.setdefault(bit, {})\n        cur = trie\n        xor_value = 0\n        for j in range(31, -1, -1):\n            bit = (x >> j) & 1\n            if 1 ^ bit in cur:\n                cur = cur[1 ^ bit]\n                xor_value |= 1 << j\n            else:\n                cur = cur[bit]\n        ans[i] = xor_value if cur else -1\n\n    return ans\n```\n\n    \n    The algorithm uses a Trie data structure to store the binary representation of numbers in the nums array. \n\n1. First, sort the nums array in ascending order.\n2. Create a new queries array, adding the index to each query, and sort according to the mi value.\n3. Iterate through the sorted queries array and update Trie with nums elements that are less than or equal to mi. \n4. For each x in the query, traverse the Trie and find the highest XOR value achievable.\n5. If there are no Trie nodes, set the answer to -1 for that query.\n6. Store the answer of each query in the ans array at the index originally present in the original query array.\n7. Return the ans array containing the answer to all queries.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < queries.size(); ++i) {\n        queries[i].push_back(i);\n    }\n    sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b) {\n        return a[1] < b[1];\n    });\n\n    vector<int> ans(queries.size());\n    int idx = 0, trie[200010][2] = {}, sum[200010] = {1}, cnt = 0;\n    for (const auto &q : queries) {\n        int x = q[0], m = q[1], k = q[2], p = 0;\n        while (idx < nums.size() && nums[idx] <= m) {\n            int cur = 0, t = nums[idx++];\n            for (int i = 31; i >= 0; --i) {\n                int bit = ((t >> i) & 1);\n                if (!trie[cur][bit]) {\n                    trie[cur][bit] = ++cnt;\n                }\n                cur = trie[cur][bit];\n            }\n            sum[cur]++;\n        }\n        if (!cnt) { \n            ans[k] = -1; \n            continue; \n        }\n        int cur = 0, ans2 = 0;\n        for (int i = 31; i >= 0; --i) {\n            int bit = ((x >> i) & 1);\n            if (trie[cur][bit ^ 1]) {\n                cur = trie[cur][bit ^ 1];\n                ans2 |= (1 << i);\n            } else {\n                cur = trie[cur][bit];\n            }\n        }\n        ans[k] = ans2;\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses a Trie data structure to store the binary representation of numbers in the nums array. \n\n1. First, sort the nums array in ascending order.\n2. Create a new queries array, adding the index to each query, and sort according to the mi value.\n3. Iterate through the sorted queries array and update Trie with nums elements that are less than or equal to mi. \n4. For each x in the query, traverse the Trie and find the highest XOR value achievable.\n5. If there are no Trie nodes, set the answer to -1 for that query.\n6. Store the answer of each query in the ans array at the index originally present in the original query array.\n7. Return the ans array containing the answer to all queries.\n    ",
        "js": "\n    ```javascript\nfunction maximizeXor(nums, queries) {\n    nums.sort((a, b) => a - b);\n    const newQueries = queries.map((q, idx) => [q[0], q[1], idx]).sort((a, b) => a[1] - b[1]);\n\n    const trie = new Array(200010).fill(null).map(() => new Array(2).fill(0));\n    const sum = new Array(200010).fill(0);\n    sum[0] = 1;\n\n    let idx = 0, cnt = 0;\n    const ans = new Array(queries.length).fill(0);\n\n    for (const q of newQueries) {\n        const [x, m, k] = q;\n        let p = 0;\n        while (idx < nums.length && nums[idx] <= m) {\n            let cur = 0, t = nums[idx++];\n            for (let i = 31; i >= 0; --i) {\n                const bit = ((t >> i) & 1);\n                if (!trie[cur][bit]) {\n                    trie[cur][bit] = ++cnt;\n                }\n                cur = trie[cur][bit];\n            }\n            sum[cur]++;\n        }\n        if (!cnt) { \n            ans[k] = -1; \n            continue; \n        }\n        let cur = 0, ans2 = 0;\n        for (let i = 31; i >= 0; --i) {\n            const bit = ((x >> i) & 1);\n            if (trie[cur][bit ^ 1]) {\n                cur = trie[cur][bit ^ 1];\n                ans2 |= (1 << i);\n            } else {\n                cur = trie[cur][bit];\n            }\n        }\n        ans[k] = ans2;\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm uses a Trie data structure to store the binary representation of numbers in the nums array. \n\n1. First, sort the nums array in ascending order.\n2. Create a new queries array, adding the index to each query, and sort according to the mi value.\n3. Iterate through the sorted queries array and update Trie with nums elements that are less than or equal to mi. \n4. For each x in the query, traverse the Trie and find the highest XOR value achievable.\n5. If there are no Trie nodes, set the answer to -1 for that query.\n6. Store the answer of each query in the ans array at the index originally present in the original query array.\n7. Return the ans array containing the answer to all queries.\n    "
    },
    {
        "id": 283,
        "title": "Remove Duplicates From an Unsorted Linked List",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `head` of a linked list, find all the values that appear **more than once** in the list and delete the nodes that have any of those values.\n\nReturn _the linked list after the deletions._",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,2\\]\n**Output:** \\[1,3\\]\n**Explanation:** 2 appears twice in the linked list, so all 2's should be deleted. After deleting all 2's, we are left with \\[1,3\\].\n\n",
                "**Example 2:**\n\n**Input:** head = \\[2,1,1,2\\]\n**Output:** \\[\\]\n**Explanation:** 2 and 1 both appear twice. All the elements should be deleted.\n\n",
                "**Example 3:**\n\n**Input:** head = \\[3,2,2,1,3,2,4\\]\n**Output:** \\[1,4\\]\n**Explanation:** 3 appears twice and 2 appears three times. After deleting all 3's and 2's, we are left with \\[1,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 105]`\n*   `1 <= Node.val <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,2]",
                "output": "[1,3]"
            },
            {
                "input": "[2,1,1,2]",
                "output": "[]"
            },
            {
                "input": "[3,2,2,1,3,2,4]",
                "output": "[1,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Vector;\n\npublic class Solution {\n    static final int MOD = 1000000007;\n\n    public static ArrayList<Integer> productWays(int[][] queries) {\n        ArrayList<Integer> res = new ArrayList<>();\n        for (int[] q : queries) {\n            int n = q[0], k = q[1];\n\n            List<Integer> pf = new ArrayList<>();\n            Map<Integer, Integer> pm = new HashMap<>();\n            for (int i = 2; i * i <= k; ++i) {\n                int cnt = 0;\n                while (k % i == 0) {\n                    cnt++;\n                    k /= i;\n                }\n                if (cnt != 0) {\n                    pf.add(cnt);\n                    pm.put(cnt, pm.getOrDefault(cnt, 0) + 1);\n                }\n            }\n\n            if (k > 1) {\n                pm.put(k, pm.getOrDefault(k, 0) + 1);\n                pf.add(1);\n            }\n\n            long ans = 1;\n            for (int p : pf) {\n                ans = (ans * (p * (n - 1) + 1)) % MOD;\n            }\n\n            res.add((int) ans);\n        }\n        return res;\n    }\n}\n```\n    \n    1. For each query, find the prime factors of number k.\n2. Store the counts of each prime factor in an array and a map.\n3. Initialize the answer for the current query to 1.\n4. Iterate through the array of prime factor counts and multiply the answer with the result of each count multiplied by n-1 and added 1. Take the modulo (1e9 + 7) in each step.\n5. Append the answer for the current query to the result list and return the result list.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef product_ways(queries: List[List[int]]) -> List[int]:\n    res = []\n    for n, k in queries:\n        pf = []\n        pm = defaultdict(int)\n\n        i = 2\n        while i * i <= k:\n            cnt = 0\n            while k % i == 0:\n                cnt += 1\n                k //= i\n            if cnt:\n                pf.append(cnt)\n                pm[cnt] += 1\n            i += 1\n\n        if k > 1:\n            pm[k] += 1\n            pf.append(1)\n\n        ans = 1\n        for p in pf:\n            ans = (ans * (p * (n - 1) + 1)) % MOD\n\n        res.append(ans)\n    return res\n```\n    \n    1. For each query, find the prime factors of number k.\n2. Store the counts of each prime factor in an array and a map.\n3. Initialize the answer for the current query to 1.\n4. Iterate through the array of prime factor counts and multiply the answer with the result of each count multiplied by n-1 and added 1. Take the modulo (1e9 + 7) in each step.\n5. Append the answer for the current query to the result list and return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<int> productWays(vector<vector<int>>& queries) {\n    vector<int> res;\n    for (auto& q : queries) {\n        int n = q[0], k = q[1];\n\n        vector<int> pf;\n        map<int, int> pm;\n        for (int i = 2; i * i <= k; ++i) {\n            int cnt = 0;\n            while (k % i == 0) {\n                cnt++;\n                k /= i;\n            }\n            if (cnt) {\n                pf.push_back(cnt);\n                pm[cnt]++;\n            }\n        }\n\n        if (k > 1) {\n            pm[k]++;\n            pf.push_back(1);\n        }\n\n        long long ans = 1;\n        for (int p : pf) {\n            ans = (ans * (p * (n - 1) + 1)) % MOD;\n        }\n\n        res.push_back(ans);\n    }\n    return res;\n}\n```\n    \n    1. For each query, find the prime factors of number k.\n2. Store the counts of each prime factor in an array and a map.\n3. Initialize the answer for the current query to 1.\n4. Iterate through the array of prime factor counts and multiply the answer with the result of each count multiplied by n-1 and added 1. Take the modulo (1e9 + 7) in each step.\n5. Append the answer for the current query to the result list and return the result list.\n    ",
        "js": "\n    ```javascript\nconst MOD = 1e9 + 7;\n\nfunction productWays(queries) {\n    const res = [];\n    for (const [n, k] of queries) {\n        const pf = [];\n        const pm = {};\n\n        for (let i = 2; i * i <= k; i++) {\n            let cnt = 0;\n            let kMutable = k;\n            while (kMutable % i === 0) {\n                cnt++;\n                kMutable /= i;\n            }\n            if (cnt !== 0) {\n                pf.push(cnt);\n                if (!pm[cnt]) pm[cnt] = 0;\n                pm[cnt]++;\n            }\n        }\n\n        if (k > 1) {\n            if (!pm[k]) pm[k] = 0;\n            pm[k]++;\n            pf.push(1);\n        }\n\n        let ans = 1;\n        for (const p of pf) {\n            ans = (ans * (p * (n - 1) + 1)) % MOD;\n        }\n\n        res.push(ans);\n    }\n    return res;\n}\n```\n    \n    1. For each query, find the prime factors of number k.\n2. Store the counts of each prime factor in an array and a map.\n3. Initialize the answer for the current query to 1.\n4. Iterate through the array of prime factor counts and multiply the answer with the result of each count multiplied by n-1 and added 1. Take the modulo (1e9 + 7) in each step.\n5. Append the answer for the current query to the result list and return the result list.\n    "
    },
    {
        "id": 284,
        "title": "Next Palindrome Using Same Digits",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a numeric string `num`, representing a very large **palindrome**.\n\nReturn _the **smallest palindrome larger than**_ `num` _that can be created by rearranging its digits. If no such palindrome exists, return an empty string_ `\" \"`.\n\nA **palindrome** is a number that reads the same backward as forward.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"1221 \"\n**Output:**  \"2112 \"\n**Explanation:** The next palindrome larger than  \"1221 \" is  \"2112 \".\n\n",
                "**Example 2:**\n\n**Input:** num =  \"32123 \"\n**Output:**  \" \"\n**Explanation:** No palindromes larger than  \"32123 \" can be made by rearranging the digits.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"45544554 \"\n**Output:**  \"54455445 \"\n**Explanation:** The next palindrome larger than  \"45544554 \" is  \"54455445 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 105`\n*   `num` is a **palindrome**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"1221\"",
                "output": "\"2112\""
            },
            {
                "input": "\"32123\"",
                "output": "\"\""
            },
            {
                "input": "\"45544554\"",
                "output": "\"54455445\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Solution {\n    public String nextPalindrome(String num) {\n        int n = num.length();\n        char[] firstHalf = num.substring(0, (n + 1) / 2).toCharArray();\n        if (!nextPermutation(firstHalf)) return \"\";\n\n        String secondHalf = new StringBuilder(String.valueOf(firstHalf)).reverse().toString();\n        if (n % 2 == 1) secondHalf = secondHalf.substring(1);\n        return String.valueOf(firstHalf) + secondHalf;\n    }\n\n    private boolean nextPermutation(char[] array) {\n        int n = array.length;\n        int k = n - 2;\n        while (k >= 0 && array[k] >= array[k + 1]) k--;\n\n        if (k == -1) return false;\n\n        int l = n - 1;\n        while (array[l] <= array[k]) l--;\n\n        char temp = array[k];\n        array[k] = array[l];\n        array[l] = temp;\n\n        int left = k + 1, right = n - 1;\n        while (left < right) {\n            temp = array[left];\n            array[left++] = array[right];\n            array[right--] = temp;\n        }\n\n        return true;\n    }\n}\n```\n    \n    The idea here is to generate the next possible larger palindrome by just manipulating the first half of the input string (since it's already a palindrome). We first extract the first half of the input string. For odd lengths, the middle character will be included in the first half as well.\n\nNext, we generate the next permutation of the first half in lexicographically increasing order (hence it is guaranteed to be greater). If there's no such permutation, we return an empty string. For Python, we generate all possible permutations, convert them back to strings and return the smallest possible greater one. Note that it may not be the most efficient way for Python.\n\nFor the other half, we simply reverse the first half, and skip the middle character if the input length is odd.\n\nFinally, we concatenate both halves and return the resulting string. If there's no next greater palindrome, the function returns an empty string.\n    ",
        "python": "\n    ```python\nfrom itertools import permutations\n\ndef nextPalindrome(num: str) -> str:\n    n = len(num)\n    first_half = num[:(n + 1) // 2]\n    candidates = sorted(set(int(\"\".join(p)) for p in permutations(first_half)))\n\n    for c in candidates:\n        c_str = str(c)\n        second_half = c_str[::-1]\n        if n % 2 == 1: second_half = second_half[1:]\n        candidate_str = c_str + second_half\n\n        if candidate_str > num:\n            return candidate_str\n\n    return \"\"\n```\n    \n    The idea here is to generate the next possible larger palindrome by just manipulating the first half of the input string (since it's already a palindrome). We first extract the first half of the input string. For odd lengths, the middle character will be included in the first half as well.\n\nNext, we generate the next permutation of the first half in lexicographically increasing order (hence it is guaranteed to be greater). If there's no such permutation, we return an empty string. For Python, we generate all possible permutations, convert them back to strings and return the smallest possible greater one. Note that it may not be the most efficient way for Python.\n\nFor the other half, we simply reverse the first half, and skip the middle character if the input length is odd.\n\nFinally, we concatenate both halves and return the resulting string. If there's no next greater palindrome, the function returns an empty string.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring nextPalindrome(string num) {\n    int n = num.size();\n    string firstHalf = num.substr(0, (n + 1) / 2);\n    next_permutation(firstHalf.begin(), firstHalf.end());\n\n    if (firstHalf > num.substr(0, (n + 1) / 2)) {\n        string secondHalf = firstHalf;\n        reverse(secondHalf.begin(), secondHalf.end());\n        if (n % 2 == 1) secondHalf = secondHalf.substr(1);\n        return firstHalf + secondHalf;\n    }\n\n    return \"\";\n}\n```\n    \n    The idea here is to generate the next possible larger palindrome by just manipulating the first half of the input string (since it's already a palindrome). We first extract the first half of the input string. For odd lengths, the middle character will be included in the first half as well.\n\nNext, we generate the next permutation of the first half in lexicographically increasing order (hence it is guaranteed to be greater). If there's no such permutation, we return an empty string. For Python, we generate all possible permutations, convert them back to strings and return the smallest possible greater one. Note that it may not be the most efficient way for Python.\n\nFor the other half, we simply reverse the first half, and skip the middle character if the input length is odd.\n\nFinally, we concatenate both halves and return the resulting string. If there's no next greater palindrome, the function returns an empty string.\n    ",
        "js": "\n    ```javascript\nfunction nextPermutation(array) {\n    let n = array.length;\n    let k = n - 2;\n    while (k >= 0 && array[k] >= array[k + 1]) k--;\n\n    if (k === -1) return false;\n\n    let l = n - 1;\n    while (array[l] <= array[k]) l--;\n\n    [array[k], array[l]] = [array[l], array[k]];\n\n    let left = k + 1, right = n - 1;\n    while (left < right) {\n        [array[left], array[right]] = [array[right], array[left]];\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nfunction nextPalindrome(num) {\n    let n = num.length;\n    let firstHalf = num.slice(0, (n + 1) / 2).split('');\n    if (!nextPermutation(firstHalf)) return \"\";\n\n    let secondHalf = firstHalf.slice().reverse();\n    if (n % 2 === 1) secondHalf.shift();\n    return firstHalf.join('') + secondHalf.join('');\n}\n```\n    \n    The idea here is to generate the next possible larger palindrome by just manipulating the first half of the input string (since it's already a palindrome). We first extract the first half of the input string. For odd lengths, the middle character will be included in the first half as well.\n\nNext, we generate the next permutation of the first half in lexicographically increasing order (hence it is guaranteed to be greater). If there's no such permutation, we return an empty string. For Python, we generate all possible permutations, convert them back to strings and return the smallest possible greater one. Note that it may not be the most efficient way for Python.\n\nFor the other half, we simply reverse the first half, and skip the middle character if the input length is odd.\n\nFinally, we concatenate both halves and return the resulting string. If there's no next greater palindrome, the function returns an empty string.\n    "
    },
    {
        "id": 285,
        "title": "Minimum Distance to the Target Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` **(0-indexed)** and two integers `target` and `start`, find an index `i` such that `nums[i] == target` and `abs(i - start)` is **minimized**. Note that `abs(x)` is the absolute value of `x`.\n\nReturn `abs(i - start)`.\n\nIt is **guaranteed** that `target` exists in `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\], target = 5, start = 3\n**Output:** 1\n**Explanation:** nums\\[4\\] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\], target = 1, start = 0\n**Output:** 0\n**Explanation:** nums\\[0\\] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,1,1,1,1,1,1,1\\], target = 1, start = 0\n**Output:** 0\n**Explanation:** Every value of nums is 1, but nums\\[0\\] minimizes abs(i - start), which is abs(0 - 0) = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n*   `0 <= start < nums.length`\n*   `target` is in `nums`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,4,5],5,3",
                "output": "1"
            },
            {
                "input": "[1],1,0",
                "output": "0"
            },
            {
                "input": "[1,1,1,1,1,1,1,1,1,1],1,0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int sumOfUniqueElements(int[] nums) {\n    Map<Integer, Integer> elemCount = new HashMap<>();\n    for (int num : nums) {\n        elemCount.put(num, elemCount.getOrDefault(num, 0) + 1);\n    }\n    int sum = 0;\n    for (Map.Entry<Integer, Integer> entry : elemCount.entrySet()) {\n        if (entry.getValue() == 1) {\n            sum += entry.getKey();\n        }\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm starts by creating an empty hash map (or dictionary in Python) to store the count of each element in the input array. After that, it iterates through the input array and increments the count of each element in the hash map. Finally, it iterates through the hash map and checks the count of each element. If the count is 1, it adds the element to the sum. Once iteration is complete, the total sum of unique elements is returned.\n    ",
        "python": "\n    ```python\ndef sum_of_unique_elements(nums):\n    elem_count = {}\n    for num in nums:\n        elem_count[num] = elem_count.get(num, 0) + 1\n    sum = 0\n    for elem, count in elem_count.items():\n        if count == 1:\n            sum += elem\n    return sum\n```\n\n    \n    The algorithm starts by creating an empty hash map (or dictionary in Python) to store the count of each element in the input array. After that, it iterates through the input array and increments the count of each element in the hash map. Finally, it iterates through the hash map and checks the count of each element. If the count is 1, it adds the element to the sum. Once iteration is complete, the total sum of unique elements is returned.\n    ",
        "c++": "\n    ```cpp\nint sumOfUniqueElements(const std::vector<int>& nums) {\n    std::unordered_map<int, int> elemCount;\n    for (const int num : nums) {\n        elemCount[num]++;\n    }\n    int sum = 0;\n    for (const auto &[elem, count] : elemCount) {\n        if (count == 1) {\n            sum += elem;\n        }\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm starts by creating an empty hash map (or dictionary in Python) to store the count of each element in the input array. After that, it iterates through the input array and increments the count of each element in the hash map. Finally, it iterates through the hash map and checks the count of each element. If the count is 1, it adds the element to the sum. Once iteration is complete, the total sum of unique elements is returned.\n    ",
        "js": "\n    ```javascript\nfunction sumOfUniqueElements(nums) {\n    const elemCount = {};\n    for (const num of nums) {\n        elemCount[num] = (elemCount[num] || 0) + 1;\n    }\n    let sum = 0;\n    for (const [elem, count] of Object.entries(elemCount)) {\n        if (count === 1) {\n            sum += parseInt(elem);\n        }\n    }\n    return sum;\n}\n```\n\n    \n    The algorithm starts by creating an empty hash map (or dictionary in Python) to store the count of each element in the input array. After that, it iterates through the input array and increments the count of each element in the hash map. Finally, it iterates through the hash map and checks the count of each element. If the count is 1, it adds the element to the sum. Once iteration is complete, the total sum of unique elements is returned.\n    "
    },
    {
        "id": 286,
        "title": "Distinct Numbers in Each Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, you are asked to construct the array `ans` of size `n-k+1` where `ans[i]` is the number of **distinct** numbers in the subarray `nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]]`.\n\nReturn _the array_ `ans`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,2,2,1,3\\], k = 3\n**Output:** \\[3,2,2,2,3\\]\n**Explanation:** The number of distinct elements in each subarray goes as follows:\n- nums\\[0:2\\] = \\[1,2,3\\] so ans\\[0\\] = 3\n- nums\\[1:3\\] = \\[2,3,2\\] so ans\\[1\\] = 2\n- nums\\[2:4\\] = \\[3,2,2\\] so ans\\[2\\] = 2\n- nums\\[3:5\\] = \\[2,2,1\\] so ans\\[3\\] = 2\n- nums\\[4:6\\] = \\[2,1,3\\] so ans\\[4\\] = 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,2,3,4\\], k = 4\n**Output:** \\[1,2,3,4\\]\n**Explanation:** The number of distinct elements in each subarray goes as follows:\n- nums\\[0:3\\] = \\[1,1,1,1\\] so ans\\[0\\] = 1\n- nums\\[1:4\\] = \\[1,1,1,2\\] so ans\\[1\\] = 2\n- nums\\[2:5\\] = \\[1,1,2,3\\] so ans\\[2\\] = 3\n- nums\\[3:6\\] = \\[1,2,3,4\\] so ans\\[3\\] = 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,3,2,2,1,3],3",
                "output": "[3,2,2,2,3]"
            },
            {
                "input": "[1,1,1,1,2,3,4],4",
                "output": "[1,2,3,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.ArrayList;\n\npublic int[] distinctNumbersInSubarrays(int[] nums, int k) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    ArrayList<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);\n        if (i >= k) {\n            counts.put(nums[i - k], counts.get(nums[i - k]) - 1);\n            if (counts.get(nums[i - k]) == 0) {\n                counts.remove(nums[i - k]);\n            }\n        }\n        if (i >= k - 1) {\n            ans.add(counts.size());\n        }\n    }\n    return ans.stream().mapToInt(i -> i).toArray();\n}\n```\n    \n    We use a sliding window approach to keep track of a subarray of the size k in the given array. To find the distinct elements in the subarray, we maintain a hash map named `counts` to store the frequency of each element in the subarray. We iterate through the given array and perform the following steps for each element:\n\n1. Increment the frequency count of the element in the `counts` hash map.\n2. If the index `i` is larger or equal to `k`, we know the subarray of size k has moved to the next index. We decrement the frequency count of the element at `nums[i - k]`. If the frequency count becomes zero, we remove this element from the hash map.\n3. If the index `i` is larger or equal to `k - 1`, we have a valid subarray of size k. In this case, we append the length of the hash map (which represents the number of distinct elements) to the `ans` array.\n\nAt the end, we return the `ans` array.\n    ",
        "python": "\n    ```python\ndef distinct_numbers_in_subarrays(nums, k):\n    counts = {}\n    ans = []\n    for i, num in enumerate(nums):\n        counts[num] = counts.get(num, 0) + 1\n        if i >= k:\n            counts[nums[i - k]] -= 1\n            if counts[nums[i - k]] == 0:\n                del counts[nums[i - k]]\n        if i >= k - 1:\n            ans.append(len(counts))\n    return ans\n```\n    \n    We use a sliding window approach to keep track of a subarray of the size k in the given array. To find the distinct elements in the subarray, we maintain a hash map named `counts` to store the frequency of each element in the subarray. We iterate through the given array and perform the following steps for each element:\n\n1. Increment the frequency count of the element in the `counts` hash map.\n2. If the index `i` is larger or equal to `k`, we know the subarray of size k has moved to the next index. We decrement the frequency count of the element at `nums[i - k]`. If the frequency count becomes zero, we remove this element from the hash map.\n3. If the index `i` is larger or equal to `k - 1`, we have a valid subarray of size k. In this case, we append the length of the hash map (which represents the number of distinct elements) to the `ans` array.\n\nAt the end, we return the `ans` array.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvector<int> distinctNumbersInSubarrays(vector<int>& nums, int k) {\n    unordered_map<int, int> counts;\n    vector<int> ans;\n    for (int i = 0; i < nums.size(); i++) {\n        counts[nums[i]]++;\n        if (i >= k) {\n            counts[nums[i - k]]--;\n            if (counts[nums[i - k]] == 0) {\n                counts.erase(nums[i - k]);\n            }\n        }\n        if (i >= k - 1) {\n            ans.push_back(counts.size());\n        }\n    }\n    return ans;\n}\n```\n    \n    We use a sliding window approach to keep track of a subarray of the size k in the given array. To find the distinct elements in the subarray, we maintain a hash map named `counts` to store the frequency of each element in the subarray. We iterate through the given array and perform the following steps for each element:\n\n1. Increment the frequency count of the element in the `counts` hash map.\n2. If the index `i` is larger or equal to `k`, we know the subarray of size k has moved to the next index. We decrement the frequency count of the element at `nums[i - k]`. If the frequency count becomes zero, we remove this element from the hash map.\n3. If the index `i` is larger or equal to `k - 1`, we have a valid subarray of size k. In this case, we append the length of the hash map (which represents the number of distinct elements) to the `ans` array.\n\nAt the end, we return the `ans` array.\n    ",
        "js": "\n    ```javascript\nfunction distinctNumbersInSubarrays(nums, k) {\n    let counts = new Map();\n    let ans = [];\n    for (let i = 0; i < nums.length; i++) {\n        counts.set(nums[i], (counts.get(nums[i]) || 0) + 1);\n        if (i >= k) {\n            counts.set(nums[i - k], counts.get(nums[i - k]) - 1);\n            if (counts.get(nums[i - k]) === 0) {\n                counts.delete(nums[i - k]);\n            }\n        }\n        if (i >= k - 1) {\n            ans.push(counts.size);\n        }\n    }\n    return ans;\n}\n```\n    \n    We use a sliding window approach to keep track of a subarray of the size k in the given array. To find the distinct elements in the subarray, we maintain a hash map named `counts` to store the frequency of each element in the subarray. We iterate through the given array and perform the following steps for each element:\n\n1. Increment the frequency count of the element in the `counts` hash map.\n2. If the index `i` is larger or equal to `k`, we know the subarray of size k has moved to the next index. We decrement the frequency count of the element at `nums[i - k]`. If the frequency count becomes zero, we remove this element from the hash map.\n3. If the index `i` is larger or equal to `k - 1`, we have a valid subarray of size k. In this case, we append the length of the hash map (which represents the number of distinct elements) to the `ans` array.\n\nAt the end, we return the `ans` array.\n    "
    },
    {
        "id": 287,
        "title": "Longest Word With All Prefixes",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of strings `words`, find the **longest** string in `words` such that **every prefix** of it is also in `words`.\n\n*   For example, let `words = [ \"a \", \"app \", \"ap \"]`. The string `\"app \"` has prefixes `\"ap \"` and `\"a \"`, all of which are in `words`.\n\nReturn _the string described above. If there is more than one string with the same length, return the **lexicographically smallest** one, and if no string exists, return_ `\" \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"k \", \"ki \", \"kir \", \"kira \",  \"kiran \"\\]\n**Output:**  \"kiran \"\n**Explanation:**  \"kiran \" has prefixes  \"kira \",  \"kir \",  \"ki \", and  \"k \", and all of them appear in words.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \",  \"banana \",  \"app \",  \"appl \",  \"ap \",  \"apply \",  \"apple \"\\]\n**Output:**  \"apple \"\n**Explanation:** Both  \"apple \" and  \"apply \" have all their prefixes in words.\nHowever,  \"apple \" is lexicographically smaller, so we return that.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"abc \",  \"bc \",  \"ab \",  \"qwe \"\\]\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 105`\n*   `1 <= words[i].length <= 105`\n*   `1 <= sum(words[i].length) <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[\"k\",\"ki\",\"kir\",\"kira\",\"kiran\"]",
                "output": "\"kiran\""
            },
            {
                "input": "[\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
                "output": "\"apple\""
            },
            {
                "input": "[\"abc\",\"bc\",\"ab\",\"qwe\"]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String maximumTime(String time) {\n    char[] result = time.toCharArray();\n    if (result[0] == '?') {\n        result[0] = (result[1] == '?' || result[1] - '0' < 4) ? '2' : '1';\n    }\n    if (result[1] == '?') {\n        result[1] = (result[0] == '2') ? '3' : '9';\n    }\n    if (result[3] == '?') {\n        result[3] = '5';\n    }\n    if (result[4] == '?') {\n        result[4] = '9';\n    }\n    return new String(result);\n}\n```\n    \n    The algorithm checks the appearance of the '?' character in each position (0, 1, 3, and 4) in the time string, replacing it with the maximum possible valid digit based on the constraints. \n\n1. If the first character of the hour is '?' and the second character is either '?' or less than 4, replace it with '2', otherwise replace it with '1'. \n2. Based on the first character, if the second character is '?', replace it with either '3' or '9'.\n3. If the character in the minutes' left position is '?', replace it with a '5' since this is the maximum valid digit.\n4. If the character in the minutes' right position is '?', replace it with a '9'.\n\nFinally, join the characters back into a string (if applicable) and return the result.\n    ",
        "python": "\n    ```python\ndef maximum_time(time: str) -> str:\n    time = list(time)\n    if time[0] == \"?\":\n        time[0] = \"2\" if time[1] == \"?\" or int(time[1]) < 4 else \"1\"\n    if time[1] == \"?\":\n        time[1] = \"3\" if time[0] == \"2\" else \"9\"\n    if time[3] == \"?\":\n        time[3] = \"5\"\n    if time[4] == \"?\":\n        time[4] = \"9\"\n    return \"\".join(time)\n```\n    \n    The algorithm checks the appearance of the '?' character in each position (0, 1, 3, and 4) in the time string, replacing it with the maximum possible valid digit based on the constraints. \n\n1. If the first character of the hour is '?' and the second character is either '?' or less than 4, replace it with '2', otherwise replace it with '1'. \n2. Based on the first character, if the second character is '?', replace it with either '3' or '9'.\n3. If the character in the minutes' left position is '?', replace it with a '5' since this is the maximum valid digit.\n4. If the character in the minutes' right position is '?', replace it with a '9'.\n\nFinally, join the characters back into a string (if applicable) and return the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring maximumTime(string time) {\n    if (time[0] == '?') {\n        time[0] = (time[1] == '?' || time[1] - '0' < 4) ? '2' : '1';\n    }\n    if (time[1] == '?') {\n        time[1] = (time[0] == '2') ? '3' : '9';\n    }\n    if (time[3] == '?') {\n        time[3] = '5';\n    }\n    if (time[4] == '?') {\n        time[4] = '9';\n    }\n    return time;\n}\n```\n    \n    The algorithm checks the appearance of the '?' character in each position (0, 1, 3, and 4) in the time string, replacing it with the maximum possible valid digit based on the constraints. \n\n1. If the first character of the hour is '?' and the second character is either '?' or less than 4, replace it with '2', otherwise replace it with '1'. \n2. Based on the first character, if the second character is '?', replace it with either '3' or '9'.\n3. If the character in the minutes' left position is '?', replace it with a '5' since this is the maximum valid digit.\n4. If the character in the minutes' right position is '?', replace it with a '9'.\n\nFinally, join the characters back into a string (if applicable) and return the result.\n    ",
        "js": "\n    ```javascript\nfunction maximumTime(time) {\n    let result = time.split('');\n    if (result[0] === '?') {\n        result[0] = (result[1] === '?' || parseInt(result[1]) < 4) ? '2' : '1';\n    }\n    if (result[1] === '?') {\n        result[1] = (result[0] === '2') ? '3' : '9';\n    }\n    if (result[3] === '?') {\n        result[3] = '5';\n    }\n    if (result[4] === '?') {\n        result[4] = '9';\n    }\n    return result.join('');\n}\n```\n    \n    The algorithm checks the appearance of the '?' character in each position (0, 1, 3, and 4) in the time string, replacing it with the maximum possible valid digit based on the constraints. \n\n1. If the first character of the hour is '?' and the second character is either '?' or less than 4, replace it with '2', otherwise replace it with '1'. \n2. Based on the first character, if the second character is '?', replace it with either '3' or '9'.\n3. If the character in the minutes' left position is '?', replace it with a '5' since this is the maximum valid digit.\n4. If the character in the minutes' right position is '?', replace it with a '9'.\n\nFinally, join the characters back into a string (if applicable) and return the result.\n    "
    },
    {
        "id": 288,
        "title": "Product of Two Run-Length Encoded Arrays",
        "difficulty": "Medium",
        "content": {
            "problem": "**Run-length encoding** is a compression algorithm that allows for an integer array `nums` with many segments of **consecutive repeated** numbers to be represented by a (generally smaller) 2D array `encoded`. Each `encoded[i] = [vali, freqi]` describes the `ith` segment of repeated numbers in `nums` where `vali` is the value that is repeated `freqi` times.\n\n*   For example, `nums = [1,1,1,2,2,2,2,2]` is represented by the **run-length encoded** array `encoded = [[1,3],[2,5]]`. Another way to read this is \"three `1`'s followed by five `2`'s \".\n\nThe **product** of two run-length encoded arrays `encoded1` and `encoded2` can be calculated using the following steps:\n\n1.  **Expand** both `encoded1` and `encoded2` into the full arrays `nums1` and `nums2` respectively.\n2.  Create a new array `prodNums` of length `nums1.length` and set `prodNums[i] = nums1[i] * nums2[i]`.\n3.  **Compress** `prodNums` into a run-length encoded array and return it.\n\nYou are given two **run-length encoded** arrays `encoded1` and `encoded2` representing full arrays `nums1` and `nums2` respectively. Both `nums1` and `nums2` have the **same length**. Each `encoded1[i] = [vali, freqi]` describes the `ith` segment of `nums1`, and each `encoded2[j] = [valj, freqj]` describes the `jth` segment of `nums2`.\n\nReturn _the **product** of_ `encoded1` _and_ `encoded2`.\n\n**Note:** Compression should be done such that the run-length encoded array has the **minimum** possible length.",
            "examples": [
                "**Example 1:**\n\n**Input:** encoded1 = \\[\\[1,3\\],\\[2,3\\]\\], encoded2 = \\[\\[6,3\\],\\[3,3\\]\\]\n**Output:** \\[\\[6,6\\]\\]\n**Explanation:** encoded1 expands to \\[1,1,1,2,2,2\\] and encoded2 expands to \\[6,6,6,3,3,3\\].\nprodNums = \\[6,6,6,6,6,6\\], which is compressed into the run-length encoded array \\[\\[6,6\\]\\].\n\n",
                "**Example 2:**\n\n**Input:** encoded1 = \\[\\[1,3\\],\\[2,1\\],\\[3,2\\]\\], encoded2 = \\[\\[2,3\\],\\[3,3\\]\\]\n**Output:** \\[\\[2,3\\],\\[6,1\\],\\[9,2\\]\\]\n**Explanation:** encoded1 expands to \\[1,1,1,2,3,3\\] and encoded2 expands to \\[2,2,2,3,3,3\\].\nprodNums = \\[2,2,2,6,9,9\\], which is compressed into the run-length encoded array \\[\\[2,3\\],\\[6,1\\],\\[9,2\\]\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= encoded1.length, encoded2.length <= 105`\n*   `encoded1[i].length == 2`\n*   `encoded2[j].length == 2`\n*   `1 <= vali, freqi <= 104` for each `encoded1[i]`.\n*   `1 <= valj, freqj <= 104` for each `encoded2[j]`.\n*   The full arrays that `encoded1` and `encoded2` represent are the same length.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,3],[2,3]],[[6,3],[3,3]]",
                "output": "[[6,6]]"
            },
            {
                "input": "[[1,3],[2,1],[3,2]],[[2,3],[3,3]]",
                "output": "[[2,3],[6,1],[9,2]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> findRLEProduct(List<List<Integer>> encoded1, List<List<Integer>> encoded2) {\n    List<List<Integer>> result = new ArrayList<>();\n    int i = 0, j = 0, count1 = 0, count2 = 0;\n\n    while (i < encoded1.size() && j < encoded2.size()) {\n        int product = encoded1.get(i).get(0) * encoded2.get(j).get(0);\n        int count = Math.min(encoded1.get(i).get(1) - count1, encoded2.get(j).get(1) - count2);\n        count1 += count;\n        count2 += count;\n\n        if (!result.isEmpty() && result.get(result.size() - 1).get(0) == product) {\n            result.get(result.size() - 1).set(1, result.get(result.size() - 1).get(1) + count);\n        } else {\n            List<Integer> pair = new ArrayList<>();\n            pair.add(product);\n            pair.add(count);\n            result.add(pair);\n        }\n\n        if (count1 == encoded1.get(i).get(1)) {\n            i++;\n            count1 = 0;\n        }\n\n        if (count2 == encoded2.get(j).get(1)) {\n            j++;\n            count2 = 0;\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm simply iterate through both `encoded1` and `encoded2` arrays, calculating the products at every segment, compressing it into a formatted run-length encoded array in the form of [val, freq], and appending the compressed parts to the `result` list. I utilize two pointers `i` and `j` to iterate through `encoded1` and `encoded2` respectively, and two additional counters `count1` and `count2` to keep track of the elements consumed in the respective arrays. At every iteration, I calculate the minimum count of consecutive elements to consume and update the result.\n\nThis way, the algorithm does not need to expand the entire `encoded1` and `encoded2` arrays, thus improving the time complexity from O(n) to O(len(encoded1) + len(encoded2)). Each segment is calculated and compressed on-the-fly, and stored in `result`. Finally, after both arrays are consumed, just return the `result`.\n    ",
        "python": "\n    ```python\ndef findRLEProduct(encoded1, encoded2):\n    result = []\n    i, j, count1, count2 = 0, 0, 0, 0\n\n    while i < len(encoded1) and j < len(encoded2):\n        product = encoded1[i][0] * encoded2[j][0]\n        count = min(encoded1[i][1] - count1, encoded2[j][1] - count2)\n        count1 += count\n        count2 += count\n\n        if result and result[-1][0] == product:\n            result[-1][1] += count\n        else:\n            result.append([product, count])\n\n        if count1 == encoded1[i][1]:\n            i += 1\n            count1 = 0\n\n        if count2 == encoded2[j][1]:\n            j += 1\n            count2 = 0\n\n    return result\n```\n    \n    The algorithm simply iterate through both `encoded1` and `encoded2` arrays, calculating the products at every segment, compressing it into a formatted run-length encoded array in the form of [val, freq], and appending the compressed parts to the `result` list. I utilize two pointers `i` and `j` to iterate through `encoded1` and `encoded2` respectively, and two additional counters `count1` and `count2` to keep track of the elements consumed in the respective arrays. At every iteration, I calculate the minimum count of consecutive elements to consume and update the result.\n\nThis way, the algorithm does not need to expand the entire `encoded1` and `encoded2` arrays, thus improving the time complexity from O(n) to O(len(encoded1) + len(encoded2)). Each segment is calculated and compressed on-the-fly, and stored in `result`. Finally, after both arrays are consumed, just return the `result`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> findRLEProduct(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2) {\n    vector<vector<int>> result;\n    int i = 0, j = 0, count1 = 0, count2 = 0;\n\n    while (i < encoded1.size() && j < encoded2.size()) {\n        int product = encoded1[i][0] * encoded2[j][0];\n        int count = min(encoded1[i][1] - count1, encoded2[j][1] - count2);\n        count1 += count;\n        count2 += count;\n\n        if (!result.empty() && result.back()[0] == product) {\n            result.back()[1] += count;\n        } else {\n            result.push_back({product, count});\n        }\n\n        if (count1 == encoded1[i][1]) {\n            i++;\n            count1 = 0;\n        }\n\n        if (count2 == encoded2[j][1]) {\n            j++;\n            count2 = 0;\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm simply iterate through both `encoded1` and `encoded2` arrays, calculating the products at every segment, compressing it into a formatted run-length encoded array in the form of [val, freq], and appending the compressed parts to the `result` list. I utilize two pointers `i` and `j` to iterate through `encoded1` and `encoded2` respectively, and two additional counters `count1` and `count2` to keep track of the elements consumed in the respective arrays. At every iteration, I calculate the minimum count of consecutive elements to consume and update the result.\n\nThis way, the algorithm does not need to expand the entire `encoded1` and `encoded2` arrays, thus improving the time complexity from O(n) to O(len(encoded1) + len(encoded2)). Each segment is calculated and compressed on-the-fly, and stored in `result`. Finally, after both arrays are consumed, just return the `result`.\n    ",
        "js": "\n    ```javascript\nfunction findRLEProduct(encoded1, encoded2) {\n    const result = [];\n    let i = 0, j = 0, count1 = 0, count2 = 0;\n\n    while (i < encoded1.length && j < encoded2.length) {\n        const product = encoded1[i][0] * encoded2[j][0];\n        const count = Math.min(encoded1[i][1] - count1, encoded2[j][1] - count2);\n        count1 += count;\n        count2 += count;\n        \n        if (result.length > 0 && result[result.length - 1][0] === product) {\n            result[result.length - 1][1] += count;\n        } else {\n            result.push([product, count]);\n        }\n\n        if (count1 === encoded1[i][1]) {\n            i++;\n            count1 = 0;\n        }\n\n        if (count2 === encoded2[j][1]) {\n            j++;\n            count2 = 0;\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm simply iterate through both `encoded1` and `encoded2` arrays, calculating the products at every segment, compressing it into a formatted run-length encoded array in the form of [val, freq], and appending the compressed parts to the `result` list. I utilize two pointers `i` and `j` to iterate through `encoded1` and `encoded2` respectively, and two additional counters `count1` and `count2` to keep track of the elements consumed in the respective arrays. At every iteration, I calculate the minimum count of consecutive elements to consume and update the result.\n\nThis way, the algorithm does not need to expand the entire `encoded1` and `encoded2` arrays, thus improving the time complexity from O(n) to O(len(encoded1) + len(encoded2)). Each segment is calculated and compressed on-the-fly, and stored in `result`. Finally, after both arrays are consumed, just return the `result`.\n    "
    },
    {
        "id": 289,
        "title": "Minimize Product Sum of Two Arrays",
        "difficulty": "Medium",
        "content": {
            "problem": "The **product sum** of two equal-length arrays `a` and `b` is equal to the sum of `a[i] * b[i]` for all `0 <= i < a.length` (**0-indexed**).\n\n*   For example, if `a = [1,2,3,4]` and `b = [5,2,3,1]`, the **product sum** would be `1*5 + 2*2 + 3*3 + 4*1 = 22`.\n\nGiven two arrays `nums1` and `nums2` of length `n`, return _the **minimum product sum** if you are allowed to **rearrange** the **order** of the elements in_ `nums1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[5,3,4,2\\], nums2 = \\[4,2,2,5\\]\n**Output:** 40\n**Explanation:** We can rearrange nums1 to become \\[3,5,4,2\\]. The product sum of \\[3,5,4,2\\] and \\[4,2,2,5\\] is 3\\*4 + 5\\*2 + 4\\*2 + 2\\*5 = 40.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[2,1,4,5,7\\], nums2 = \\[3,2,4,8,6\\]\n**Output:** 65\n**Explanation:** We can rearrange nums1 to become \\[5,7,4,1,2\\]. The product sum of \\[5,7,4,1,2\\] and \\[3,2,4,8,6\\] is 5\\*3 + 7\\*2 + 4\\*4 + 1\\*8 + 2\\*6 = 65."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `1 <= nums1[i], nums2[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,3,4,2],[4,2,2,5]",
                "output": "40"
            },
            {
                "input": "[2,1,4,5,7],[3,2,4,8,6]",
                "output": "65"
            }
        ],
        "java": "\n    ```java\npublic boolean canChoose(int[][] groups, int[] nums) {\n    int g_i = 0, n_i = 0;\n    while (g_i < groups.length && n_i + groups[g_i].length <= nums.length) {\n        boolean match = true;\n        for (int i = 0; i < groups[g_i].length; ++i) {\n            if (groups[g_i][i] != nums[n_i + i]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            n_i += groups[g_i].length;\n            g_i++;\n        } else {\n            n_i++;\n        }\n    }\n    return g_i == groups.length;\n}\n```\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    ",
        "python": "\n    ```python\ndef can_choose(groups, nums):\n    g_i, n_i = 0, 0\n    while g_i < len(groups) and n_i + len(groups[g_i]) <= len(nums):\n        if nums[n_i : n_i + len(groups[g_i])] == groups[g_i]:\n            n_i += len(groups[g_i])\n            g_i += 1\n        else:\n            n_i += 1\n    return g_i == len(groups)\n```\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool canChoose(const std::vector<std::vector<int>>& groups, const std::vector<int>& nums) {\n    int g_i = 0, n_i = 0;\n    while (g_i < groups.size() && n_i + groups[g_i].size() <= nums.size()) {\n        bool match = true;\n        for (int i = 0; i < groups[g_i].size(); ++i) {\n            if (groups[g_i][i] != nums[n_i + i]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            n_i += groups[g_i].size();\n            g_i++;\n        } else {\n            n_i++;\n        }\n    }\n    return g_i == groups.size();\n}\n```\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    ",
        "js": "\n    ```javascript\nfunction canChoose(groups, nums) {\n    let g_i = 0, n_i = 0;\n    while (g_i < groups.length && n_i + groups[g_i].length <= nums.length) {\n        const match = groups[g_i].every((val, i) => val === nums[n_i + i]);\n        if (match) {\n            n_i += groups[g_i].length;\n            g_i++;\n        } else {\n            n_i++;\n        }\n    }\n    return g_i === groups.length;\n}\n```\n\n    \n    We initialize two indices, `g_i` for tracking the position in the `groups` array, and `n_i` for tracking the position in the `nums` array. We iterate using a `while` loop, checking if it's possible to process the next group. If it is, we compare the subarray in `nums` starting at `n_i` with the current `groups` element. If they match, we move to the next group and increment the index `n_i` based on the length of the current group. If not, we increment `n_i` by 1.\n\nIf we reach the end of the `groups` array, it means we've matched all the groups to disjoint subarrays, so we return true. Otherwise, we return false.\n    "
    },
    {
        "id": 290,
        "title": "Count Pairs in Two Arrays",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2` of length `n`, count the pairs of indices `(i, j)` such that `i < j` and `nums1[i] + nums1[j] > nums2[i] + nums2[j]`.\n\nReturn _the **number of pairs** satisfying the condition._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[2,1,2,1\\], nums2 = \\[1,2,1,2\\]\n**Output:** 1\n**Explanation**: The pairs satisfying the condition are:\n- (0, 2) where 2 + 2 > 1 + 1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,10,6,2\\], nums2 = \\[1,4,1,5\\]\n**Output:** 5\n**Explanation**: The pairs satisfying the condition are:\n- (0, 1) where 1 + 10 > 1 + 4.\n- (0, 2) where 1 + 6 > 1 + 1.\n- (1, 2) where 10 + 6 > 4 + 1.\n- (1, 3) where 10 + 2 > 4 + 5.\n- (2, 3) where 6 + 2 > 1 + 5."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `1 <= nums1[i], nums2[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,2,1],[1,2,1,2]",
                "output": "1"
            },
            {
                "input": "[1,10,6,2],[1,4,1,5]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nint countHomogenous(String s) {\n    int res = 0, count = 1, mod = 1000000007;\n    for (int i = 1; i < s.length(); ++i) {\n        count = (s.charAt(i) == s.charAt(i - 1)) ? count + 1 : 1;\n        res = (res + count) % mod;\n    }\n    return res;\n}\n```\n    \n    The algorithm to solve this problem involves iterating through the given string and keeping track of counts for similar contiguous characters. Initialize a result variable, a count variable and the modulo for 10^9 + 7 to avoid large number problems.\n\nLoop through the string starting from the second character. Compare the current character to the previous character. If the characters are the same, increment the count, otherwise reset it to 1. Add the count value to the result and perform modulo on the result after the addition.\n\nAfter looping through the entire string, return the result. This approach has a time complexity of O(n), where n is the length of the input string.\n    ",
        "python": "\n    ```python\ndef count_homogenous(s: str) -> int:\n    res, count, mod = 0, 1, 10**9 + 7\n    for i in range(1, len(s)):\n        count = count + 1 if s[i] == s[i - 1] else 1\n        res = (res + count) % mod\n    return res\n```\n    \n    The algorithm to solve this problem involves iterating through the given string and keeping track of counts for similar contiguous characters. Initialize a result variable, a count variable and the modulo for 10^9 + 7 to avoid large number problems.\n\nLoop through the string starting from the second character. Compare the current character to the previous character. If the characters are the same, increment the count, otherwise reset it to 1. Add the count value to the result and perform modulo on the result after the addition.\n\nAfter looping through the entire string, return the result. This approach has a time complexity of O(n), where n is the length of the input string.\n    ",
        "c++": "\n    ```cpp\nint countHomogenous(std::string s) {\n    int res = 0, count = 1, mod = 1e9 + 7;\n    for (int i = 1; i < s.size(); ++i) {\n        count = (s[i] == s[i - 1]) ? count + 1 : 1;\n        res = (res + count) % mod;\n    }\n    return res;\n}\n```\n    \n    The algorithm to solve this problem involves iterating through the given string and keeping track of counts for similar contiguous characters. Initialize a result variable, a count variable and the modulo for 10^9 + 7 to avoid large number problems.\n\nLoop through the string starting from the second character. Compare the current character to the previous character. If the characters are the same, increment the count, otherwise reset it to 1. Add the count value to the result and perform modulo on the result after the addition.\n\nAfter looping through the entire string, return the result. This approach has a time complexity of O(n), where n is the length of the input string.\n    ",
        "js": "\n    ```javascript\nfunction countHomogenous(s) {\n    let res = 0, count = 1, mod = 1e9 + 7;\n    for (let i = 1; i < s.length; ++i) {\n        count = (s[i] === s[i - 1]) ? count + 1 : 1;\n        res = (res + count) % mod;\n    }\n    return res;\n}\n```\n    \n    The algorithm to solve this problem involves iterating through the given string and keeping track of counts for similar contiguous characters. Initialize a result variable, a count variable and the modulo for 10^9 + 7 to avoid large number problems.\n\nLoop through the string starting from the second character. Compare the current character to the previous character. If the characters are the same, increment the count, otherwise reset it to 1. Add the count value to the result and perform modulo on the result after the addition.\n\nAfter looping through the entire string, return the result. This approach has a time complexity of O(n), where n is the length of the input string.\n    "
    },
    {
        "id": 291,
        "title": "Depth of BST Given Insertion Order",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `order` of length `n`, a **permutation** of integers from `1` to `n` representing the **order** of insertion into a **binary search tree**.\n\nA binary search tree is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n\nThe binary search tree is constructed as follows:\n\n*   `order[0]` will be the **root** of the binary search tree.\n*   All subsequent elements are inserted as the **child** of **any** existing node such that the binary search tree properties hold.\n\nReturn _the **depth** of the binary search tree_.\n\nA binary tree's **depth** is the number of **nodes** along the **longest path** from the root node down to the farthest leaf node.",
            "examples": [
                "**Example 1:**\n\n**Input:** order = \\[2,1,4,3\\]\n**Output:** 3\n**Explanation:** The binary search tree has a depth of 3 with path 2->3->4.\n\n",
                "**Example 2:**\n\n**Input:** order = \\[2,1,3,4\\]\n**Output:** 3\n**Explanation:** The binary search tree has a depth of 3 with path 2->3->4.\n\n",
                "**Example 3:**\n\n**Input:** order = \\[1,2,3,4\\]\n**Output:** 4\n**Explanation:** The binary search tree has a depth of 4 with path 1->2->3->4."
            ],
            "constraints": "**Constraints:**\n\n*   `n == order.length`\n*   `1 <= n <= 105`\n*   `order` is a permutation of integers between `1` and `n`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,4,3]",
                "output": "3"
            },
            {
                "input": "[2,1,3,4]",
                "output": "3"
            },
            {
                "input": "[1,2,3,4]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\nclass Solution {\n    public double[] getCollisionTimes(int[][] cars) {\n        int n = cars.length;\n        double[] collisions = new double[n];\n        Arrays.fill(collisions, -1);\n        for (int i = n - 1; i >= 0; --i) {\n            double time_to_collision = 1e9;\n            for (int j = i + 1; j < n; ++j) {\n                if (cars[j][1] > cars[i][1]) continue;\n                double current_collision = (double) (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);\n                if(current_collision < time_to_collision) {\n                    time_to_collision = Math.min(time_to_collision, Math.min(collisions[j], current_collision));\n                }\n            }\n            collisions[i] = time_to_collision == 1e9 ? -1.0 : time_to_collision;\n        }\n        return collisions;\n    }\n}\n```\n    \n    Starting from the last car to the first, we calculate the time it takes for each car to collide with the car ahead. We only consider collisions if the current car is moving slower than the car ahead (cars[j][1] > cars[i][1]). For each collision, we calculate the collision time as the distance between the cars divided by the speed difference (current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])). We then update the minimum collision time if the current collision time is smaller, and also ensure we store the smallest between the minimum collision time and any collision times that are already recorded for the car ahead. The collision time for each car is updated in an array, with the value `-1` when a car does not collide with the car ahead. Finally, the function returns the array of collision times. \n    ",
        "python": "\n    ```python\ndef get_collision_times(cars):\n    n = len(cars)\n    collisions = [-1] * n\n    for i in range(n-1, -1, -1):\n        time_to_collision = 1e9\n        for j in range(i+1, n):\n            if cars[j][1] > cars[i][1]:\n                continue\n            current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])\n            if current_collision < time_to_collision:\n                time_to_collision = min(time_to_collision, min(collisions[j], current_collision))\n        collisions[i] = -1.0 if time_to_collision == 1e9 else time_to_collision\n    return collisions\n```\n    \n    Starting from the last car to the first, we calculate the time it takes for each car to collide with the car ahead. We only consider collisions if the current car is moving slower than the car ahead (cars[j][1] > cars[i][1]). For each collision, we calculate the collision time as the distance between the cars divided by the speed difference (current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])). We then update the minimum collision time if the current collision time is smaller, and also ensure we store the smallest between the minimum collision time and any collision times that are already recorded for the car ahead. The collision time for each car is updated in an array, with the value `-1` when a car does not collide with the car ahead. Finally, the function returns the array of collision times. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<double> getCollisionTimes(vector<vector<int>>& cars) {\n    vector<double> collisions(cars.size(), -1);\n    for (int i = cars.size() - 1; i >= 0; --i) {\n        double time_to_collision = 1e9;\n        for (int j = i + 1; j < cars.size(); ++j) {\n            if (cars[j][1] > cars[i][1]) continue;\n            double current_collision = (double)(cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);\n            if(current_collision < time_to_collision) {\n                time_to_collision = min(time_to_collision, min(collisions[j], current_collision));\n            }\n        }\n        collisions[i] = time_to_collision == 1e9 ? -1.0 : time_to_collision;\n    }\n    return collisions;\n}\n```\n    \n    Starting from the last car to the first, we calculate the time it takes for each car to collide with the car ahead. We only consider collisions if the current car is moving slower than the car ahead (cars[j][1] > cars[i][1]). For each collision, we calculate the collision time as the distance between the cars divided by the speed difference (current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])). We then update the minimum collision time if the current collision time is smaller, and also ensure we store the smallest between the minimum collision time and any collision times that are already recorded for the car ahead. The collision time for each car is updated in an array, with the value `-1` when a car does not collide with the car ahead. Finally, the function returns the array of collision times. \n    ",
        "js": "\n    ```javascript\nfunction getCollisionTimes(cars) {\n    const n = cars.length;\n    const collisions = new Array(n).fill(-1);\n    for (let i = n - 1; i >= 0; --i) {\n        let time_to_collision = 1e9;\n        for (let j = i + 1; j < n; ++j) {\n            if (cars[j][1] > cars[i][1]) continue;\n            let current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);\n            if(current_collision < time_to_collision) {\n                time_to_collision = Math.min(time_to_collision, Math.min(collisions[j], current_collision));\n            }\n        }\n        collisions[i] = time_to_collision === 1e9 ? -1.0 : time_to_collision;\n    }\n    return collisions;\n}\n```\n    \n    Starting from the last car to the first, we calculate the time it takes for each car to collide with the car ahead. We only consider collisions if the current car is moving slower than the car ahead (cars[j][1] > cars[i][1]). For each collision, we calculate the collision time as the distance between the cars divided by the speed difference (current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])). We then update the minimum collision time if the current collision time is smaller, and also ensure we store the smallest between the minimum collision time and any collision times that are already recorded for the car ahead. The collision time for each car is updated in an array, with the value `-1` when a car does not collide with the car ahead. Finally, the function returns the array of collision times. \n    "
    },
    {
        "id": 292,
        "title": "Kth Smallest Subarray Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of length `n` and an integer `k`, return _the_ `kth` _**smallest subarray sum**._\n\nA **subarray** is defined as a **non-empty** contiguous sequence of elements in an array. A **subarray sum** is the sum of all elements in the subarray.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,3\\], k = 4\n**Output:** 3\n**Explanation:** The subarrays of \\[2,1,3\\] are:\n- \\[2\\] with sum 2\n- \\[1\\] with sum 1\n- \\[3\\] with sum 3\n- \\[2,1\\] with sum 3\n- \\[1,3\\] with sum 4\n- \\[2,1,3\\] with sum 6 \nOrdering the sums from smallest to largest gives 1, 2, 3, 3, 4, 6. The 4th smallest is 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,3,5,5\\], k = 7\n**Output:** 10\n**Explanation:** The subarrays of \\[3,3,5,5\\] are:\n- \\[3\\] with sum 3\n- \\[3\\] with sum 3\n- \\[5\\] with sum 5\n- \\[5\\] with sum 5\n- \\[3,3\\] with sum 6\n- \\[3,5\\] with sum 8\n- \\[5,5\\] with sum 10\n- \\[3,3,5\\], with sum 11\n- \\[3,5,5\\] with sum 13\n- \\[3,3,5,5\\] with sum 16\nOrdering the sums from smallest to largest gives 3, 3, 5, 5, 6, 8, 10, 11, 13, 16. The 7th smallest is 10."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 2 * 104`\n*   `1 <= nums[i] <= 5 * 104`\n*   `1 <= k <= n * (n + 1) / 2`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,3],4",
                "output": "3"
            },
            {
                "input": "[3,3,5,5],7",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int[] nums, int k) {\n    int n = nums.length;\n    int result = 0;\n    for (int i = k; i >= 0; i--) {\n        for (int j = k; j < n; j++) {\n            int minVal = nums[i];\n            for (int x = i; x <= j; x++)\n                minVal = Math.min(minVal, nums[x]);\n            result = Math.max(result, minVal * (j - i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    1. Loop through i from k to 0 (inclusive) in reverse order because we want subarrays containing the k-th index.\n2. Iterate through j from k to the end of the array (nums.size() in C++ and nums.length in Java/JavaScript, len(nums) in Python).\n3. Calculate the minimum element in the subarray (i, j) using a loop, increment variable x from i up to j, and keep track of the minimum element encountered.\n4. Calculate the current subarray score by multiplying the min_val with the length of the subarray (j - i + 1).\n5. Keep track of the maximum score encountered in the variable \"result\".\n6. After all loops have completed, return the result as the maximum score of the good subarray.\n    ",
        "python": "\n    ```python\ndef maxScore(nums: List[int], k: int) -> int:\n    n = len(nums)\n    result = 0\n    for i in range(k, -1, -1):\n        for j in range(k, n):\n            min_val = min(nums[i:j+1])\n            result = max(result, min_val * (j - i + 1))\n    return result\n```\n    \n    1. Loop through i from k to 0 (inclusive) in reverse order because we want subarrays containing the k-th index.\n2. Iterate through j from k to the end of the array (nums.size() in C++ and nums.length in Java/JavaScript, len(nums) in Python).\n3. Calculate the minimum element in the subarray (i, j) using a loop, increment variable x from i up to j, and keep track of the minimum element encountered.\n4. Calculate the current subarray score by multiplying the min_val with the length of the subarray (j - i + 1).\n5. Keep track of the maximum score encountered in the variable \"result\".\n6. After all loops have completed, return the result as the maximum score of the good subarray.\n    ",
        "c++": "\n    ```cpp\nint maxScore(vector<int>& nums, int k) {\n    int n = nums.size();\n    int result = 0;\n    for (int i = k; i >= 0; i--) {\n        for (int j = k; j < n; j++) {\n            int min_val = nums[i];\n            for (int x = i; x <= j; x++)\n                min_val = min(min_val, nums[x]);\n            result = max(result, min_val * (j - i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    1. Loop through i from k to 0 (inclusive) in reverse order because we want subarrays containing the k-th index.\n2. Iterate through j from k to the end of the array (nums.size() in C++ and nums.length in Java/JavaScript, len(nums) in Python).\n3. Calculate the minimum element in the subarray (i, j) using a loop, increment variable x from i up to j, and keep track of the minimum element encountered.\n4. Calculate the current subarray score by multiplying the min_val with the length of the subarray (j - i + 1).\n5. Keep track of the maximum score encountered in the variable \"result\".\n6. After all loops have completed, return the result as the maximum score of the good subarray.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(nums, k) {\n    const n = nums.length;\n    let result = 0;\n    for (let i = k; i >= 0; i--) {\n        for (let j = k; j < n; j++) {\n            let minVal = nums[i];\n            for (let x = i; x <= j; x++)\n                minVal = Math.min(minVal, nums[x]);\n            result = Math.max(result, minVal * (j - i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    1. Loop through i from k to 0 (inclusive) in reverse order because we want subarrays containing the k-th index.\n2. Iterate through j from k to the end of the array (nums.size() in C++ and nums.length in Java/JavaScript, len(nums) in Python).\n3. Calculate the minimum element in the subarray (i, j) using a loop, increment variable x from i up to j, and keep track of the minimum element encountered.\n4. Calculate the current subarray score by multiplying the min_val with the length of the subarray (j - i + 1).\n5. Keep track of the maximum score encountered in the variable \"result\".\n6. After all loops have completed, return the result as the maximum score of the good subarray.\n    "
    },
    {
        "id": 293,
        "title": "Erect the Fence II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D integer array `trees` where `trees[i] = [xi, yi]` represents the location of the `ith` tree in the garden.\n\nYou are asked to fence the entire garden using the minimum length of rope possible. The garden is well-fenced only if **all the trees are enclosed** and the rope used **forms a perfect circle**. A tree is considered enclosed if it is inside or on the border of the circle.\n\nMore formally, you must form a circle using the rope with a center `(x, y)` and radius `r` where all trees lie inside or on the circle and `r` is **minimum**.\n\nReturn _the center and radius of the circle as a length 3 array_ `[x, y, r]`_._ Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** trees = \\[\\[1,1\\],\\[2,2\\],\\[2,0\\],\\[2,4\\],\\[3,3\\],\\[4,2\\]\\]\n**Output:** \\[2.00000,2.00000,2.00000\\]\n**Explanation:** The fence will have center = (2, 2) and radius = 2\n\n",
                "**Example 2:**\n\n**Input:** trees = \\[\\[1,2\\],\\[2,2\\],\\[4,2\\]\\]\n**Output:** \\[2.50000,2.00000,1.50000\\]\n**Explanation:** The fence will have center = (2.5, 2) and radius = 1.5"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= trees.length <= 3000`\n*   `trees[i].length == 2`\n*   `0 <= xi, yi <= 3000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]",
                "output": "[2.00000,2.00000,2.00000]"
            },
            {
                "input": "[[1,2],[2,2],[4,2]]",
                "output": "[2.50000,2.00000,1.50000]"
            }
        ],
        "java": "\n    ```java\npublic int maxHappyGroups(int batchSize, int[] groups) {\n    int[] remainders = new int[batchSize];\n    for (int g : groups) {\n        remainders[g % batchSize]++;\n    }\n\n    int result = remainders[0];\n    int i = 1, j = batchSize - 1;\n\n    while (i < j) {\n        result += Math.min(remainders[i], remainders[j]);\n        i++;\n        j--;\n    }\n    if (i == j) {\n        result += remainders[i] / 2;\n    }\n\n    return result;\n}\n```\n    \n    The solution consists of calculating the remainders of the groups' sizes when divided by the batchSize. This is done to find out how many donuts are left after serving each group. Then, for each possible remainder `i`, we try to pair it with the complement `j` such that `(i + j) % batchSize = 0`. By doing this, we can make both groups happy by rearranging the groups. This is done until `i` is equal to or greater than `j`. If `i == j` (meaning there is only one unique remainder left), then we can make them happy by dividing the group with the same remainder into half. Finally, we return the sum of happy groups found during pairing steps.\n    ",
        "python": "\n    ```python\ndef max_happy_groups(batchSize, groups):\n    remainders = [0] * batchSize\n    for g in groups:\n        remainders[g % batchSize] += 1\n\n    result = remainders[0]\n    i, j = 1, batchSize - 1\n\n    while i < j:\n        result += min(remainders[i], remainders[j])\n        i += 1\n        j -= 1\n\n    if i == j:\n        result += remainders[i] // 2\n\n    return result\n```\n    \n    The solution consists of calculating the remainders of the groups' sizes when divided by the batchSize. This is done to find out how many donuts are left after serving each group. Then, for each possible remainder `i`, we try to pair it with the complement `j` such that `(i + j) % batchSize = 0`. By doing this, we can make both groups happy by rearranging the groups. This is done until `i` is equal to or greater than `j`. If `i == j` (meaning there is only one unique remainder left), then we can make them happy by dividing the group with the same remainder into half. Finally, we return the sum of happy groups found during pairing steps.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxHappyGroups(int batchSize, std::vector<int> &groups) {\n    std::vector<int> remainders(batchSize, 0);\n    for (int g : groups) {\n        remainders[g % batchSize]++;\n    }\n    \n    int result = remainders[0];\n    int i = 1, j = batchSize - 1;\n    \n    while (i < j) {\n        result += std::min(remainders[i], remainders[j]);\n        i++;\n        j--;\n    }\n    if (i == j) {\n        result += remainders[i] / 2;\n    }\n    \n    return result;\n}\n```\n    \n    The solution consists of calculating the remainders of the groups' sizes when divided by the batchSize. This is done to find out how many donuts are left after serving each group. Then, for each possible remainder `i`, we try to pair it with the complement `j` such that `(i + j) % batchSize = 0`. By doing this, we can make both groups happy by rearranging the groups. This is done until `i` is equal to or greater than `j`. If `i == j` (meaning there is only one unique remainder left), then we can make them happy by dividing the group with the same remainder into half. Finally, we return the sum of happy groups found during pairing steps.\n    ",
        "js": "\n    ```javascript\nfunction maxHappyGroups(batchSize, groups) {\n    let remainders = new Array(batchSize).fill(0);\n    for (let g of groups) {\n        remainders[g % batchSize]++;\n    }\n\n    let result = remainders[0];\n    let i = 1, j = batchSize - 1;\n\n    while (i < j) {\n        result += Math.min(remainders[i], remainders[j]);\n        i++;\n        j--;\n    }\n    if (i === j) {\n        result += Math.floor(remainders[i] / 2);\n    }\n\n    return result;\n}\n```\n    \n    The solution consists of calculating the remainders of the groups' sizes when divided by the batchSize. This is done to find out how many donuts are left after serving each group. Then, for each possible remainder `i`, we try to pair it with the complement `j` such that `(i + j) % batchSize = 0`. By doing this, we can make both groups happy by rearranging the groups. This is done until `i` is equal to or greater than `j`. If `i == j` (meaning there is only one unique remainder left), then we can make them happy by dividing the group with the same remainder into half. Finally, we return the sum of happy groups found during pairing steps.\n    "
    },
    {
        "id": 294,
        "title": "Check if String Is Decomposable Into Value-Equal Substrings",
        "difficulty": "Easy",
        "content": {
            "problem": "A **value-equal** string is a string where **all** characters are the same.\n\n*   For example, `\"1111 \"` and `\"33 \"` are value-equal strings.\n*   In contrast, `\"123 \"` is not a value-equal string.\n\nGiven a digit string `s`, decompose the string into some number of **consecutive value-equal** substrings where **exactly one** substring has a **length of** `2` and the remaining substrings have a **length of** `3`.\n\nReturn `true` _if you can decompose_ `s` _according to the above rules. Otherwise, return_ `false`.\n\nA **substring** is a contiguous sequence of characters in a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"000111000 \"\n**Output:** false\n**Explanation:** s cannot be decomposed according to the rules because \\[ \"000 \",  \"111 \",  \"000 \"\\] does not have a substring of length 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"00011111222 \"\n**Output:** true\n**Explanation:** s can be decomposed into \\[ \"000 \",  \"111 \",  \"11 \",  \"222 \"\\].\n\n",
                "**Example 3:**\n\n**Input:** s =  \"011100022233 \"\n**Output:** false\n**Explanation:** s cannot be decomposed according to the rules because of the first '0'."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of only digits `'0'` through `'9'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"000111000\"",
                "output": "false"
            },
            {
                "input": "\"00011111222\"",
                "output": "true"
            },
            {
                "input": "\"011100022233\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int numDifferentIntegers(String word) {\n    for (int i = 0; i < word.length(); i++) {\n        if (!Character.isDigit(word.charAt(i))) {\n            word = word.substring(0, i) + \" \" + word.substring(i + 1);\n        }\n    }\n    String[] nums = word.split(\"\\\\s+\");\n    Set<String> uniqueNums = new HashSet<>();\n    for (String num : nums) {\n        num = num.replaceFirst(\"^0+(?!$)\", \"\");\n        uniqueNums.add(num);\n    }\n    return uniqueNums.size();\n}\n```\n    \n    1. Replace all non-digit characters with a space in `word`.\n2. Split the modified `word` by spaces to get the list of integers.\n3. Initialize an empty Set named `uniqueNums` to store unique integers.\n4. For each integer in the list, remove leading zeros (if any) and add it to the `uniqueNums` set.\n5. Return the size of `uniqueNums` which is the count of unique integers.\n    ",
        "python": "\n    ```python\ndef num_different_integers(word):\n    for c in word:\n        if not c.isdigit():\n            word = word.replace(c, ' ')\n    nums = word.split()\n    unique_nums = set()\n    for num in nums:\n        num = num.lstrip('0') or '0'\n        unique_nums.add(num)\n    return len(unique_nums)\n```\n    \n    1. Replace all non-digit characters with a space in `word`.\n2. Split the modified `word` by spaces to get the list of integers.\n3. Initialize an empty Set named `uniqueNums` to store unique integers.\n4. For each integer in the list, remove leading zeros (if any) and add it to the `uniqueNums` set.\n5. Return the size of `uniqueNums` which is the count of unique integers.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_set>\n\nint numDifferentIntegers(std::string word) {\n    for (char &c : word) {\n        if (c < '0' || c > '9') {\n            c = ' ';\n        }\n    }\n    std::istringstream iss(word);\n    std::string num;\n    std::unordered_set<std::string> uniqueNums;\n    while (iss >> num) {\n        num.erase(0, num.find_first_not_of('0'));\n        uniqueNums.insert(num);\n    }\n    return uniqueNums.size();\n}\n```\n    \n    1. Replace all non-digit characters with a space in `word`.\n2. Split the modified `word` by spaces to get the list of integers.\n3. Initialize an empty Set named `uniqueNums` to store unique integers.\n4. For each integer in the list, remove leading zeros (if any) and add it to the `uniqueNums` set.\n5. Return the size of `uniqueNums` which is the count of unique integers.\n    ",
        "js": "\n    ```javascript\nfunction numDifferentIntegers(word) {\n  word = word.replace(/\\D/g, \" \");\n  let nums = word.split(/\\s+/).filter(Boolean);\n  let uniqueNums = new Set();\n  for (let num of nums) {\n    num = num.replace(/^0+/, \"\") || \"0\";\n    uniqueNums.add(num);\n  }\n  return uniqueNums.size;\n}\n```\n    \n    1. Replace all non-digit characters with a space in `word`.\n2. Split the modified `word` by spaces to get the list of integers.\n3. Initialize an empty Set named `uniqueNums` to store unique integers.\n4. For each integer in the list, remove leading zeros (if any) and add it to the `uniqueNums` set.\n5. Return the size of `uniqueNums` which is the count of unique integers.\n    "
    },
    {
        "id": 295,
        "title": "Maximum of Minimum Values in All Subarrays",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` of size `n`. You are asked to solve `n` queries for each integer `i` in the range `0 <= i < n`.\n\nTo solve the `ith` query:\n\n1.  Find the **minimum value** in each possible subarray of size `i + 1` of the array `nums`.\n2.  Find the **maximum** of those minimum values. This maximum is the **answer** to the query.\n\nReturn _a **0-indexed** integer array_ `ans` _of size_ `n` _such that_ `ans[i]` _is the answer to the_ `ith` _query_.\n\nA **subarray** is a contiguous sequence of elements in an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,4\\]\n**Output:** \\[4,2,1,0\\]\n**Explanation:**\ni=0:\n- The subarrays of size 1 are \\[0\\], \\[1\\], \\[2\\], \\[4\\]. The minimum values are 0, 1, 2, 4.\n- The maximum of the minimum values is 4.\ni=1:\n- The subarrays of size 2 are \\[0,1\\], \\[1,2\\], \\[2,4\\]. The minimum values are 0, 1, 2.\n- The maximum of the minimum values is 2.\ni=2:\n- The subarrays of size 3 are \\[0,1,2\\], \\[1,2,4\\]. The minimum values are 0, 1.\n- The maximum of the minimum values is 1.\ni=3:\n- There is one subarray of size 4, which is \\[0,1,2,4\\]. The minimum value is 0.\n- There is only one value, so the maximum is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,20,50,10\\]\n**Output:** \\[50,20,10,10\\]\n**Explanation:**\ni=0:\n- The subarrays of size 1 are \\[10\\], \\[20\\], \\[50\\], \\[10\\]. The minimum values are 10, 20, 50, 10.\n- The maximum of the minimum values is 50.\ni=1:\n- The subarrays of size 2 are \\[10,20\\], \\[20,50\\], \\[50,10\\]. The minimum values are 10, 20, 10.\n- The maximum of the minimum values is 20.\ni=2:\n- The subarrays of size 3 are \\[10,20,50\\], \\[20,50,10\\]. The minimum values are 10, 10.\n- The maximum of the minimum values is 10.\ni=3:\n- There is one subarray of size 4, which is \\[10,20,50,10\\]. The minimum value is 10.\n- There is only one value, so the maximum is 10."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `0 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,2,4]",
                "output": "[4,2,1,0]"
            },
            {
                "input": "[10,20,50,10]",
                "output": "[50,20,10,10]"
            }
        ],
        "java": "\n    ```java\npublic int signFunc(int x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\npublic int arraySign(int[] nums) {\n    int product = 1;\n    for (int x : nums) {\n        product *= x;\n    }\n    return signFunc(product);\n}\n```\n    \n    1. The signFunc function is implemented to return 1 if the input number is positive, -1 if it's negative and 0 if it's zero.\n2. The arraySign function initializes the product variable with 1.\n3. It iterates the input array nums and multiplies each element with the current product.\n4. After the loop, the final product is passed to the signFunc function and its return value is returned.\n\nThe logic is the same in all the languages, only the syntax is different.\n    ",
        "python": "\n    ```python\ndef sign_func(x):\n    if x > 0:\n        return 1\n    elif x < 0:\n        return -1\n    else:\n        return 0\n\ndef array_sign(nums):\n    product = 1\n    for x in nums:\n        product *= x\n    return sign_func(product)\n```\n    \n    1. The signFunc function is implemented to return 1 if the input number is positive, -1 if it's negative and 0 if it's zero.\n2. The arraySign function initializes the product variable with 1.\n3. It iterates the input array nums and multiplies each element with the current product.\n4. After the loop, the final product is passed to the signFunc function and its return value is returned.\n\nThe logic is the same in all the languages, only the syntax is different.\n    ",
        "c++": "\n    ```cpp\nint signFunc(int x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\nint arraySign(vector<int>& nums) {\n    int product = 1;\n    for (int x : nums) {\n        product *= x;\n    }\n    return signFunc(product);\n}\n```\n    \n    1. The signFunc function is implemented to return 1 if the input number is positive, -1 if it's negative and 0 if it's zero.\n2. The arraySign function initializes the product variable with 1.\n3. It iterates the input array nums and multiplies each element with the current product.\n4. After the loop, the final product is passed to the signFunc function and its return value is returned.\n\nThe logic is the same in all the languages, only the syntax is different.\n    ",
        "js": "\n    ```javascript\nfunction signFunc(x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\nfunction arraySign(nums) {\n    let product = 1;\n    for (let x of nums) {\n        product *= x;\n    }\n    return signFunc(product);\n}\n```\n    \n    1. The signFunc function is implemented to return 1 if the input number is positive, -1 if it's negative and 0 if it's zero.\n2. The arraySign function initializes the product variable with 1.\n3. It iterates the input array nums and multiplies each element with the current product.\n4. After the loop, the final product is passed to the signFunc function and its return value is returned.\n\nThe logic is the same in all the languages, only the syntax is different.\n    "
    },
    {
        "id": 296,
        "title": "Minimum Time For K Virus Variants to Spread",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` **unique** virus variants in an infinite 2D grid. You are given a 2D array `points`, where `points[i] = [xi, yi]` represents a virus originating at `(xi, yi)` on day `0`. Note that it is possible for **multiple** virus variants to originate at the **same** point.\n\nEvery day, each cell infected with a virus variant will spread the virus to **all** neighboring points in the **four** cardinal directions (i.e. up, down, left, and right). If a cell has multiple variants, all the variants will spread without interfering with each other.\n\nGiven an integer `k`, return _the **minimum integer** number of days for **any** point to contain **at least**_ `k` _of the unique virus variants_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[6,1\\]\\], k = 2\n**Output:** 3\n**Explanation:** On day 3, points (3,1) and (4,1) will contain both virus variants. Note that these are not the only points that will contain both virus variants.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[3,3\\],\\[1,2\\],\\[9,2\\]\\], k = 2\n**Output:** 2\n**Explanation:** On day 2, points (1,3), (2,3), (2,2), and (3,2) will contain the first two viruses. Note that these are not the only points that will contain both virus variants.\n\n",
                "**Example 3:**\n\n**Input:** points = \\[\\[3,3\\],\\[1,2\\],\\[9,2\\]\\], k = 3\n**Output:** 4\n**Explanation:** On day 4, the point (5,2) will contain all 3 viruses. Note that this is not the only point that will contain all 3 virus variants."
            ],
            "constraints": "**Constraints:**\n\n*   `n == points.length`\n*   `2 <= n <= 50`\n*   `points[i].length == 2`\n*   `1 <= xi, yi <= 100`\n*   `2 <= k <= n`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1],[6,1]],2",
                "output": "3"
            },
            {
                "input": "[[3,3],[1,2],[9,2]],2",
                "output": "2"
            },
            {
                "input": "[[3,3],[1,2],[9,2]],3",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxElement(int[] arr) {\n    int max_val = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_val = Math.max(max_val, arr[i]);\n    }\n    return max_val / 2;\n}\n```\n    \n    To maximize the array element after performing the operations, we first find the maximum element in the array. Since we can perform any number of operations and divide the value by 2, we can just divide the maximum value by 2 to satisfy the conditions. As the problem states that we have to return an integer, we use integer division or floor division where applicable. Since the array consists of positive integers, the result is guaranteed to be positive.\n\nThe algorithm's time complexity is O(n), where n is the length of the input array as it only iterates over the array once.\n    ",
        "python": "\n    ```python\ndef max_element(arr):\n    max_val = max(arr)\n    return max_val // 2\n```\n    \n    To maximize the array element after performing the operations, we first find the maximum element in the array. Since we can perform any number of operations and divide the value by 2, we can just divide the maximum value by 2 to satisfy the conditions. As the problem states that we have to return an integer, we use integer division or floor division where applicable. Since the array consists of positive integers, the result is guaranteed to be positive.\n\nThe algorithm's time complexity is O(n), where n is the length of the input array as it only iterates over the array once.\n    ",
        "c++": "\n    ```cpp\nint maxElement(vector<int>& arr) {\n    int max_val = *max_element(arr.begin(), arr.end());\n    return max_val / 2;\n}\n```\n    \n    To maximize the array element after performing the operations, we first find the maximum element in the array. Since we can perform any number of operations and divide the value by 2, we can just divide the maximum value by 2 to satisfy the conditions. As the problem states that we have to return an integer, we use integer division or floor division where applicable. Since the array consists of positive integers, the result is guaranteed to be positive.\n\nThe algorithm's time complexity is O(n), where n is the length of the input array as it only iterates over the array once.\n    ",
        "js": "\n    ```javascript\nfunction maxElement(arr) {\n    const max_val = Math.max(...arr);\n    return Math.floor(max_val / 2);\n}\n```\n    \n    To maximize the array element after performing the operations, we first find the maximum element in the array. Since we can perform any number of operations and divide the value by 2, we can just divide the maximum value by 2 to satisfy the conditions. As the problem states that we have to return an integer, we use integer division or floor division where applicable. Since the array consists of positive integers, the result is guaranteed to be positive.\n\nThe algorithm's time complexity is O(n), where n is the length of the input array as it only iterates over the array once.\n    "
    },
    {
        "id": 297,
        "title": "Binary Searchable Numbers in an Unsorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Consider a function that implements an algorithm **similar** to [Binary Search](https://leetcode.com/explore/learn/card/binary-search/). The function has two input parameters: `sequence` is a sequence of integers, and `target` is an integer value. The purpose of the function is to find if the `target` exists in the `sequence`.\n\nThe pseudocode of the function is as follows:\n\nfunc(sequence, target)\n  while sequence is not empty\n    **randomly** choose an element from sequence as the pivot\n    if pivot = target, return **true**\n    else if pivot < target, remove pivot and all elements to its left from the sequence\n    else, remove pivot and all elements to its right from the sequence\n  end while\n  return **false**\n\nWhen the `sequence` is sorted, the function works correctly for **all** values. When the `sequence` is not sorted, the function does not work for all values, but may still work for **some** values.\n\nGiven an integer array `nums`, representing the `sequence`, that contains **unique** numbers and **may or may not be sorted**, return _the number of values that are **guaranteed** to be found using the function, for **every possible** pivot selection_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7\\]\n**Output:** 1\n**Explanation**: \nSearching for value 7 is guaranteed to be found.\nSince the sequence has only one element, 7 will be chosen as the pivot. Because the pivot equals the target, the function will return true.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,5,2\\]\n**Output:** 1\n**Explanation**: \nSearching for value -1 is guaranteed to be found.\nIf -1 was chosen as the pivot, the function would return true.\nIf 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only -1 and the function would return true.\nIf 2 was chosen as the pivot, 2 would be removed. In the next loop, the sequence would have -1 and 5. No matter which number was chosen as the next pivot, the function would find -1 and return true.\n\nSearching for value 5 is NOT guaranteed to be found.\nIf 2 was chosen as the pivot, -1, 5 and 2 would be removed. The sequence would be empty and the function would return false.\n\nSearching for value 2 is NOT guaranteed to be found.\nIf 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only -1 and the function would return false.\n\nBecause only -1 is guaranteed to be found, you should return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`\n*   All the values of `nums` are **unique**.\n\n**",
            "follow_up": "Follow-up:** If `nums` has **duplicates**, would you modify your algorithm? If so, how?"
        },
        "tag": [],
        "example": [
            {
                "input": "[7]",
                "output": "1"
            },
            {
                "input": "[-1,5,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxFrequency(int[] nums, int k) {\n    Arrays.sort(nums);\n    int max_freq = 1, n = nums.length;\n    long sum = 0;\n    for (int i = 0, j = 0; j < n; ++j) {\n        sum += nums[j];\n        while (sum < (long) nums[j] * (j - i + 1) - k) {\n            sum -= nums[i++];\n        }\n        max_freq = Math.max(max_freq, j - i + 1);\n    }\n    return max_freq;\n}\n```\n    \n    1. Sort the input array, nums, in non-decreasing order.\n2. Traverse the sorted array using two pointers, i and j. Initialize sum and max_freq to 0 and 1, respectively.\n3. In each step, increment the sum by the element at index j (nums[j]).\n4. Use a while loop to check if the current sum is less than the required sum to make all elements in the current range equal to nums[j]. If this is the case, decrement the sum by the element at index i (nums[i]) and move the index i one step forward.\n5. Update the max_freq by comparing it with the current range length (j - i + 1), and pick the maximum value.\n6. Continue iterating until the end of the array and return the max_freq.\n    ",
        "python": "\n    ```python\ndef maxFrequency(nums, k):\n    nums.sort()\n    max_freq, n, total = 1, len(nums), 0\n    i = 0\n    for j in range(n):\n        total += nums[j]\n        while total < nums[j] * (j - i + 1) - k:\n            total -= nums[i]\n            i += 1\n        max_freq = max(max_freq, j - i + 1)\n    return max_freq\n```\n    \n    1. Sort the input array, nums, in non-decreasing order.\n2. Traverse the sorted array using two pointers, i and j. Initialize sum and max_freq to 0 and 1, respectively.\n3. In each step, increment the sum by the element at index j (nums[j]).\n4. Use a while loop to check if the current sum is less than the required sum to make all elements in the current range equal to nums[j]. If this is the case, decrement the sum by the element at index i (nums[i]) and move the index i one step forward.\n5. Update the max_freq by comparing it with the current range length (j - i + 1), and pick the maximum value.\n6. Continue iterating until the end of the array and return the max_freq.\n    ",
        "c++": "\n    ```cpp\nint maxFrequency(vector<int>& nums, int k) {\n    sort(nums.begin(), nums.end());\n    int max_freq = 1, n = nums.size();\n    long long sum = 0;\n    for (int i = 0, j = 0; j < n; ++j) {\n        sum += nums[j];\n        while (sum < static_cast<long long>(nums[j]) * (j - i + 1) - k) {\n            sum -= nums[i++];\n        }\n        max_freq = max(max_freq, j - i + 1);\n    }\n    return max_freq;\n}\n```\n    \n    1. Sort the input array, nums, in non-decreasing order.\n2. Traverse the sorted array using two pointers, i and j. Initialize sum and max_freq to 0 and 1, respectively.\n3. In each step, increment the sum by the element at index j (nums[j]).\n4. Use a while loop to check if the current sum is less than the required sum to make all elements in the current range equal to nums[j]. If this is the case, decrement the sum by the element at index i (nums[i]) and move the index i one step forward.\n5. Update the max_freq by comparing it with the current range length (j - i + 1), and pick the maximum value.\n6. Continue iterating until the end of the array and return the max_freq.\n    ",
        "js": "\n    ```javascript\nfunction maxFrequency(nums, k) {\n    nums.sort((a, b) => a - b);\n    let max_freq = 1, n = nums.length;\n    let sum = 0;\n    for (let i = 0, j = 0; j < n; ++j) {\n        sum += nums[j];\n        while (sum < nums[j] * (j - i + 1) - k) {\n            sum -= nums[i++];\n        }\n        max_freq = Math.max(max_freq, j - i + 1);\n    }\n    return max_freq;\n}\n```\n    \n    1. Sort the input array, nums, in non-decreasing order.\n2. Traverse the sorted array using two pointers, i and j. Initialize sum and max_freq to 0 and 1, respectively.\n3. In each step, increment the sum by the element at index j (nums[j]).\n4. Use a while loop to check if the current sum is less than the required sum to make all elements in the current range equal to nums[j]. If this is the case, decrement the sum by the element at index i (nums[i]) and move the index i one step forward.\n5. Update the max_freq by comparing it with the current range length (j - i + 1), and pick the maximum value.\n6. Continue iterating until the end of the array and return the max_freq.\n    "
    },
    {
        "id": 298,
        "title": "Count Nodes Equal to Sum of Descendants",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the number of nodes where the value of the node is equal to the **sum** of the values of its descendants_.\n\nA **descendant** of a node `x` is any node that is on the path from node `x` to some leaf node. The sum is considered to be `0` if the node has no descendants.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[10,3,4,2,1\\]\n**Output:** 2\n**Explanation:**\nFor the node with value 10: The sum of its descendants is 3+4+2+1 = 10.\nFor the node with value 3: The sum of its descendants is 2+1 = 3.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,3,null,2,null\\]\n**Output:** 0\n**Explanation:**\nNo node has a value that is equal to the sum of its descendants.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[0\\]\n**Output:** 1\nFor the node with value 0: The sum of its descendants is 0 since it has no descendants."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 105]`.\n*   `0 <= Node.val <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[10,3,4,2,1]",
                "output": "2"
            },
            {
                "input": "[2,3,null,2,null]",
                "output": "0"
            },
            {
                "input": "[0]",
                "output": "1\nForthenodewithvalue0:Thesumofitsdescendantsis0sinceithasnodescendants."
            }
        ],
        "java": "\n    ```java\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    private int dfs(TreeNode root, int[] count) {\n        if(root == null) return 0;\n        int left_sum = dfs(root.left, count);\n        int right_sum = dfs(root.right, count);\n        if(root.val == left_sum + right_sum) count[0]++;\n        return root.val + left_sum + right_sum;\n    }\n\n    public int equalToDescendants(TreeNode root) {\n        int[] count = new int[1];\n        dfs(root, count);\n        return count[0];\n    }\n}\n```\n    \n    We start by defining a `TreeNode` class for each language to represent nodes in our binary tree.\n\nTo count the number of nodes with values equal to its descendants' sum, we use a Depth-First Search traversal. The `dfs` helper function is called on the left and right children of a node, which returns their sum. We then compare the sum of the left and right children with the node's value. If they are equal, we increment the count. Finally, we return the sum of the current node's value and its descendants.\n\nThe `equalToDescendants` function initializes the count and calls the `dfs` function on the root of the binary tree. It returns the final count.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def dfs(self, root, count):\n        if not root:\n            return 0\n        left_sum = self.dfs(root.left, count)\n        right_sum = self.dfs(root.right, count)\n        if root.val == left_sum + right_sum:\n            count[0] += 1\n        return root.val + left_sum + right_sum\n\n    def equalToDescendants(self, root):\n        count = [0]\n        self.dfs(root, count)\n        return count[0]\n```\n    \n    We start by defining a `TreeNode` class for each language to represent nodes in our binary tree.\n\nTo count the number of nodes with values equal to its descendants' sum, we use a Depth-First Search traversal. The `dfs` helper function is called on the left and right children of a node, which returns their sum. We then compare the sum of the left and right children with the node's value. If they are equal, we increment the count. Finally, we return the sum of the current node's value and its descendants.\n\nThe `equalToDescendants` function initializes the count and calls the `dfs` function on the root of the binary tree. It returns the final count.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int dfs(TreeNode* root, int& count) {\n        if(!root) return 0;\n        int left_sum = dfs(root->left, count);\n        int right_sum = dfs(root->right, count);\n        if(root->val == left_sum + right_sum) count++;\n        return root->val + left_sum + right_sum;\n    }\n\n    int equalToDescendants(TreeNode* root) {\n        int count = 0;\n        dfs(root, count);\n        return count;\n    }\n};\n```\n    \n    We start by defining a `TreeNode` class for each language to represent nodes in our binary tree.\n\nTo count the number of nodes with values equal to its descendants' sum, we use a Depth-First Search traversal. The `dfs` helper function is called on the left and right children of a node, which returns their sum. We then compare the sum of the left and right children with the node's value. If they are equal, we increment the count. Finally, we return the sum of the current node's value and its descendants.\n\nThe `equalToDescendants` function initializes the count and calls the `dfs` function on the root of the binary tree. It returns the final count.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    dfs(root, count) {\n        if (!root) return 0;\n        const left_sum = this.dfs(root.left, count);\n        const right_sum = this.dfs(root.right, count);\n        if (root.val == left_sum + right_sum) count[0]++;\n        return root.val + left_sum + right_sum;\n    }\n\n    equalToDescendants(root) {\n        const count = [0];\n        this.dfs(root, count);\n        return count[0];\n    }\n}\n```\n    \n    We start by defining a `TreeNode` class for each language to represent nodes in our binary tree.\n\nTo count the number of nodes with values equal to its descendants' sum, we use a Depth-First Search traversal. The `dfs` helper function is called on the left and right children of a node, which returns their sum. We then compare the sum of the left and right children with the node's value. If they are equal, we increment the count. Finally, we return the sum of the current node's value and its descendants.\n\nThe `equalToDescendants` function initializes the count and calls the `dfs` function on the root of the binary tree. It returns the final count.\n    "
    },
    {
        "id": 299,
        "title": "Widest Pair of Indices With Equal Range Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two **0-indexed** binary arrays `nums1` and `nums2`. Find the **widest** pair of indices `(i, j)` such that `i <= j` and `nums1[i] + nums1[i+1] + ... + nums1[j] == nums2[i] + nums2[i+1] + ... + nums2[j]`.\n\nThe **widest** pair of indices is the pair with the **largest** **distance** between `i` and `j`. The **distance** between a pair of indices is defined as `j - i + 1`.\n\nReturn _the **distance** of the **widest** pair of indices. If no pair of indices meets the conditions, return_ `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,1,0,1\\], nums2 = \\[0,1,1,0\\]\n**Output:** 3\n**Explanation:**\nIf i = 1 and j = 3:\nnums1\\[1\\] + nums1\\[2\\] + nums1\\[3\\] = 1 + 0 + 1 = 2.\nnums2\\[1\\] + nums2\\[2\\] + nums2\\[3\\] = 1 + 1 + 0 = 2.\nThe distance between i and j is j - i + 1 = 3 - 1 + 1 = 3.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[0,1\\], nums2 = \\[1,1\\]\n**Output:** 1\n**Explanation:**\nIf i = 1 and j = 1:\nnums1\\[1\\] = 1.\nnums2\\[1\\] = 1.\nThe distance between i and j is j - i + 1 = 1 - 1 + 1 = 1.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[0\\], nums2 = \\[1\\]\n**Output:** 0\n**Explanation:**\nThere are no pairs of indices that meet the requirements."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `nums1[i]` is either `0` or `1`.\n*   `nums2[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,1,0,1],[0,1,1,0]",
                "output": "3"
            },
            {
                "input": "[0,1],[1,1]",
                "output": "1"
            },
            {
                "input": "[0],[1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxAliveYear(int[][] logs) {\n    int[] years = new int[2051];\n    \n    for(int[] log : logs) {\n        years[log[0]]++;\n        years[log[1]]--;\n    }\n    \n    int max_population = 0;\n    int max_year = 0;\n    int population = 0;\n    for(int i = 1950; i < 2051; i++) {\n        population += years[i];\n        if(population > max_population) {\n            max_population = population;\n            max_year = i;\n        }\n    }\n    \n    return max_year;\n}\n```\n\n    \n    For every person in the `logs` array, we increment the birth year index in the `years` array and decrement the death year index in the same `years` array. This essentially keeps track of the net population change for each year.\n\nNext, we iterate through the `years` array from 1950 to 2050, calculating the cumulative population at each year. If the population of a given year is greater than the maximum population found so far, we update the max_population value and the max_year. Finally, we return the `max_year` which has the maximum population.\n    ",
        "python": "\n    ```python\ndef max_alive_year(logs):\n    years = [0] * 2051\n    \n    for log in logs:\n        years[log[0]] += 1\n        years[log[1]] -= 1\n    \n    max_population = 0\n    max_year = 0\n    population = 0\n    for i in range(1950, 2051):\n        population += years[i]\n        if population > max_population:\n            max_population = population\n            max_year = i\n\n    return max_year\n```\n\n    \n    For every person in the `logs` array, we increment the birth year index in the `years` array and decrement the death year index in the same `years` array. This essentially keeps track of the net population change for each year.\n\nNext, we iterate through the `years` array from 1950 to 2050, calculating the cumulative population at each year. If the population of a given year is greater than the maximum population found so far, we update the max_population value and the max_year. Finally, we return the `max_year` which has the maximum population.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxAliveYear(std::vector<std::vector<int>>& logs) {\n    std::vector<int> years(2051, 0);\n    \n    for(auto& log : logs) {\n        years[log[0]]++;\n        years[log[1]]--;\n    }\n    \n    int max_population = 0;\n    int max_year = 0;\n    int population = 0;\n    for(int i = 1950; i < 2051; i++) {\n        population += years[i];\n        if(population > max_population) {\n            max_population = population;\n            max_year = i;\n        }\n    }\n    \n    return max_year;\n}\n```\n\n    \n    For every person in the `logs` array, we increment the birth year index in the `years` array and decrement the death year index in the same `years` array. This essentially keeps track of the net population change for each year.\n\nNext, we iterate through the `years` array from 1950 to 2050, calculating the cumulative population at each year. If the population of a given year is greater than the maximum population found so far, we update the max_population value and the max_year. Finally, we return the `max_year` which has the maximum population.\n    ",
        "js": "\n    ```javascript\nfunction maxAliveYear(logs) {\n    const years = new Array(2051).fill(0);\n    \n    logs.forEach(log => {\n        years[log[0]]++;\n        years[log[1]]--;\n    });\n    \n    let max_population = 0;\n    let max_year = 0;\n    let population = 0;\n    for(let i = 1950; i < 2051; i++) {\n        population += years[i];\n        if(population > max_population) {\n            max_population = population;\n            max_year = i;\n        }\n    }\n    \n    return max_year;\n}\n```\n\n    \n    For every person in the `logs` array, we increment the birth year index in the `years` array and decrement the death year index in the same `years` array. This essentially keeps track of the net population change for each year.\n\nNext, we iterate through the `years` array from 1950 to 2050, calculating the cumulative population at each year. If the population of a given year is greater than the maximum population found so far, we update the max_population value and the max_year. Finally, we return the `max_year` which has the maximum population.\n    "
    },
    {
        "id": 300,
        "title": "Maximum Number of People That Can Be Caught in Tag",
        "difficulty": "Medium",
        "content": {
            "problem": "You are playing a game of tag with your friends. In tag, people are divided into two teams: people who are \"it \", and people who are not \"it \". The people who are \"it \" want to catch as many people as possible who are not \"it \".\n\nYou are given a **0-indexed** integer array `team` containing only zeros (denoting people who are **not** \"it \") and ones (denoting people who are \"it \"), and an integer `dist`. A person who is \"it \" at index `i` can catch any **one** person whose index is in the range `[i - dist, i + dist]` (**inclusive**) and is **not** \"it \".\n\nReturn _the **maximum** number of people that the people who are \"it \" can catch_.",
            "examples": [
                "**Example 1:**\n\n**Input:** team = \\[0,1,0,1,0\\], dist = 3\n**Output:** 2\n**Explanation:**\nThe person who is  \"it \" at index 1 can catch people in the range \\[i-dist, i+dist\\] = \\[1-3, 1+3\\] = \\[-2, 4\\].\nThey can catch the person who is not  \"it \" at index 2.\nThe person who is  \"it \" at index 3 can catch people in the range \\[i-dist, i+dist\\] = \\[3-3, 3+3\\] = \\[0, 6\\].\nThey can catch the person who is not  \"it \" at index 0.\nThe person who is not  \"it \" at index 4 will not be caught because the people at indices 1 and 3 are already catching one person.\n\n",
                "**Example 2:**\n\n**Input:** team = \\[1\\], dist = 1\n**Output:** 0\n**Explanation:**\nThere are no people who are not  \"it \" to catch.\n\n",
                "**Example 3:**\n\n**Input:** team = \\[0\\], dist = 1\n**Output:** 0\n**Explanation:**\nThere are no people who are  \"it \" to catch people."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= team.length <= 105`\n*   `0 <= team[i] <= 1`\n*   `1 <= dist <= team.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,0,1,0],3",
                "output": "2"
            },
            {
                "input": "[1],1",
                "output": "0"
            },
            {
                "input": "[0],1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minimumXorSum(int[] nums1, int[] nums2) {\n    Arrays.sort(nums2);\n    int xorSum = 0;\n    for (int i = 0; i < nums1.length; i++) {\n        xorSum += nums1[i] ^ nums2[i];\n    }\n    return xorSum;\n}\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    ",
        "python": "\n    ```python\ndef minimum_xor_sum(nums1, nums2):\n    nums2.sort()\n    xor_sum = 0\n    for i in range(len(nums1)):\n        xor_sum += nums1[i] ^ nums2[i]\n    return xor_sum\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minimum_xor_sum(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::sort(nums2.begin(), nums2.end());\n    int xor_sum = 0;\n    for (int i = 0; i < nums1.size(); ++i) {\n        xor_sum += nums1[i] ^ nums2[i];\n    }\n    return xor_sum;\n}\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    ",
        "js": "\n    ```javascript\nfunction minimumXorSum(nums1, nums2) {\n    nums2.sort((a, b) => a - b);\n    let xorSum = 0;\n    for (let i = 0; i < nums1.length; i++) {\n        xorSum += nums1[i] ^ nums2[i];\n    }\n    return xorSum;\n}\n```\n    \n    The algorithm to minimize XOR sum works as follows:\n\n1. Sort the array nums2 in ascending order.\n2. Calculate the XOR sum between elements of array nums1 and nums2, iterating through both arrays simultaneously.\n3. Return the XOR sum of the two arrays.\n\nBy sorting the nums2 array, we are effectively minimizing the XOR sum because when doing bitwise XOR, if the corresponding bit is 1 in one number and 0 in the other number, the resultant bit will be 1. Sorting nums2 guarantees that we minimize the number of 1's in the resultant XOR operation.\n    "
    },
    {
        "id": 301,
        "title": "Smallest Greater Multiple Made of Two Digits",
        "difficulty": "Medium",
        "content": {
            "problem": "Given three integers, `k`, `digit1`, and `digit2`, you want to find the **smallest** integer that is:\n\n*   **Larger** than `k`,\n*   A **multiple** of `k`, and\n*   Comprised of **only** the digits `digit1` and/or `digit2`.\n\nReturn _the **smallest** such integer. If no such integer exists or the integer exceeds the limit of a signed 32-bit integer (_`231 - 1`_), return_ `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 2, digit1 = 0, digit2 = 2\n**Output:** 20\n**Explanation:**\n20 is the first integer larger than 2, a multiple of 2, and comprised of only the digits 0 and/or 2.\n\n",
                "**Example 2:**\n\n**Input:** k = 3, digit1 = 4, digit2 = 2\n**Output:** 24\n**Explanation:**\n24 is the first integer larger than 3, a multiple of 3, and comprised of only the digits 4 and/or 2.\n\n",
                "**Example 3:**\n\n**Input:** k = 2, digit1 = 0, digit2 = 0\n**Output:** -1\n**Explanation:**\nNo integer meets the requirements so return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 1000`\n*   `0 <= digit1 <= 9`\n*   `0 <= digit2 <= 9`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2,0,2",
                "output": "20"
            },
            {
                "input": "3,4,2",
                "output": "24"
            },
            {
                "input": "2,0,0",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic boolean checkZeroOnes(String s) {\n    int longestZero = 0;\n    int longestOne = 0;\n    int currentZero = 0;\n    int currentOne = 0;\n    \n    for (char c : s.toCharArray()) {\n        if (c == '0') {\n            currentZero++;\n            longestZero = Math.max(longestZero, currentZero);\n            currentOne = 0;\n        } else {\n            currentOne++;\n            longestOne = Math.max(longestOne, currentOne);\n            currentZero = 0;\n        }\n    }\n    return longestOne > longestZero;\n}\n```\n\n    \n    1. Initialize variables for tracking the lengths of the longest and current segments of 0's and 1's.\n2. Iterate through the string.\n3. For each character, update the corresponding current segment length and compare it with the longest segment length.\n   a. If the current character is '0', increment the current segment of 0's, update the longest segment of 0's if necessary, and reset the current segment of 1's.\n   b. If the current character is '1', increment the current segment of 1's, update the longest segment of 1's if necessary, and reset the current segment of 0's.\n4. After the iteration, compare the lengths of the longest segments of 0's and 1's and return the result as a boolean.\n    ",
        "python": "\n    ```python\ndef checkZeroOnes(s: str) -> bool:\n    longest_zero = longest_one = current_zero = current_one = 0\n    \n    for c in s:\n        if c == '0':\n            current_zero += 1\n            longest_zero = max(longest_zero, current_zero)\n            current_one = 0\n        else:\n            current_one += 1\n            longest_one = max(longest_one, current_one)\n            current_zero = 0\n            \n    return longest_one > longest_zero\n```\n\n    \n    1. Initialize variables for tracking the lengths of the longest and current segments of 0's and 1's.\n2. Iterate through the string.\n3. For each character, update the corresponding current segment length and compare it with the longest segment length.\n   a. If the current character is '0', increment the current segment of 0's, update the longest segment of 0's if necessary, and reset the current segment of 1's.\n   b. If the current character is '1', increment the current segment of 1's, update the longest segment of 1's if necessary, and reset the current segment of 0's.\n4. After the iteration, compare the lengths of the longest segments of 0's and 1's and return the result as a boolean.\n    ",
        "c++": "\n    ```cpp\nbool checkZeroOnes(std::string s) {\n    int longestZero = 0;\n    int longestOne = 0;\n    int currentZero = 0;\n    int currentOne = 0;\n    \n    for (char c : s) {\n        if (c == '0') {\n            currentZero++;\n            longestZero = std::max(longestZero, currentZero);\n            currentOne = 0;\n        } else {\n            currentOne++;\n            longestOne = std::max(longestOne, currentOne);\n            currentZero = 0;\n        }\n    }\n    return longestOne > longestZero;\n}\n```\n\n    \n    1. Initialize variables for tracking the lengths of the longest and current segments of 0's and 1's.\n2. Iterate through the string.\n3. For each character, update the corresponding current segment length and compare it with the longest segment length.\n   a. If the current character is '0', increment the current segment of 0's, update the longest segment of 0's if necessary, and reset the current segment of 1's.\n   b. If the current character is '1', increment the current segment of 1's, update the longest segment of 1's if necessary, and reset the current segment of 0's.\n4. After the iteration, compare the lengths of the longest segments of 0's and 1's and return the result as a boolean.\n    ",
        "js": "\n    ```javascript\nfunction checkZeroOnes(s) {\n    let longestZero = 0;\n    let longestOne = 0;\n    let currentZero = 0;\n    let currentOne = 0;\n\n    for (let c of s) {\n        if (c === '0') {\n            currentZero++;\n            longestZero = Math.max(longestZero, currentZero);\n            currentOne = 0;\n        } else {\n            currentOne++;\n            longestOne = Math.max(longestOne, currentOne);\n            currentZero = 0;\n        }\n    }\n    return longestOne > longestZero;\n}\n```\n\n    \n    1. Initialize variables for tracking the lengths of the longest and current segments of 0's and 1's.\n2. Iterate through the string.\n3. For each character, update the corresponding current segment length and compare it with the longest segment length.\n   a. If the current character is '0', increment the current segment of 0's, update the longest segment of 0's if necessary, and reset the current segment of 1's.\n   b. If the current character is '1', increment the current segment of 1's, update the longest segment of 1's if necessary, and reset the current segment of 0's.\n4. After the iteration, compare the lengths of the longest segments of 0's and 1's and return the result as a boolean.\n    "
    },
    {
        "id": 302,
        "title": "Subtree Removal Game with Fibonacci Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "A **Fibonacci** tree is a binary tree created using the order function `order(n)`:\n\n*   `order(0)` is the empty tree.\n*   `order(1)` is a binary tree with only **one node**.\n*   `order(n)` is a binary tree that consists of a root node with the left subtree as `order(n - 2)` and the right subtree as `order(n - 1)`.\n\nAlice and Bob are playing a game with a **Fibonacci** tree with Alice staring first. On each turn, a player selects a node and removes that node **and** its subtree. The player that is forced to delete `root` loses.\n\nGiven the integer `n`, return `true` if Alice wins the game or `false` if Bob wins, assuming both players play optimally.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.",
            "examples": [
                "**Example 1:**  \n\n**Input:** n = 3\n**Output:** true\n**Explanation:**\nAlice takes the node 1 in the right subtree.\nBob takes either the 1 in the left subtree or the 2 in the right subtree.\nAlice takes whichever node Bob doesn't take.\nBob is forced to take the root node 3, so Bob will lose.\nReturn true because Alice wins.\n\n",
                "**Example 2:**  \n\n**Input:** n = 1\n**Output:** false\n**Explanation:**\nAlice is forced to take the root node 1, so Alice will lose.\nReturn false because Alice loses.\n\n",
                "**Example 3:**  \n\n**Input:** n = 2\n**Output:** true\n**Explanation:**\nAlice takes the node 1.\nBob is forced to take the root node 2, so Bob will lose.\nReturn true because Alice wins."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "3",
                "output": "true"
            },
            {
                "input": "1",
                "output": "false"
            },
            {
                "input": "2",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isCovered(int[][] ranges, int left, int right) {\n    for (int i = left; i <= right; i++) {\n        boolean isCovered = false;\n        for (int[] range : ranges) {\n            if (i >= range[0] && i <= range[1]) {\n                isCovered = true;\n                break;\n            }\n        }\n        if (!isCovered) return false;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm iterates through the range of integers from left to right (inclusive). For each integer, it checks if there is an interval in the given list `ranges` that covers it. If for any integer in the range, there is no interval that covers it, the algorithm returns false. If all the integers are covered by at least one interval, it returns true.\n    ",
        "python": "\n    ```python\ndef is_covered(ranges, left, right):\n    for i in range(left, right + 1):\n        is_covered = False\n        for range_ in ranges:\n            if i >= range_[0] and i <= range_[1]:\n                is_covered = True\n                break\n        if not is_covered:\n            return False\n    return True\n```\n\n    \n    The algorithm iterates through the range of integers from left to right (inclusive). For each integer, it checks if there is an interval in the given list `ranges` that covers it. If for any integer in the range, there is no interval that covers it, the algorithm returns false. If all the integers are covered by at least one interval, it returns true.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool isCovered(std::vector<std::vector<int>>& ranges, int left, int right) {\n    for (int i = left; i <= right; i++) {\n        bool is_covered = false;\n        for (const auto& range : ranges) {\n            if (i >= range[0] && i <= range[1]) {\n                is_covered = true;\n                break;\n            }\n        }\n        if (!is_covered) return false;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm iterates through the range of integers from left to right (inclusive). For each integer, it checks if there is an interval in the given list `ranges` that covers it. If for any integer in the range, there is no interval that covers it, the algorithm returns false. If all the integers are covered by at least one interval, it returns true.\n    ",
        "js": "\n    ```javascript\nfunction isCovered(ranges, left, right) {\n    for (let i = left; i <= right; i++) {\n        let isCovered = false;\n        for (const range of ranges) {\n            if (i >= range[0] && i <= range[1]) {\n                isCovered = true;\n                break;\n            }\n        }\n        if (!isCovered) return false;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm iterates through the range of integers from left to right (inclusive). For each integer, it checks if there is an interval in the given list `ranges` that covers it. If for any integer in the range, there is no interval that covers it, the algorithm returns false. If all the integers are covered by at least one interval, it returns true.\n    "
    },
    {
        "id": 303,
        "title": "Average Height of Buildings in Each Segment",
        "difficulty": "Medium",
        "content": {
            "problem": "A perfectly straight street is represented by a number line. The street has building(s) on it and is represented by a 2D integer array `buildings`, where `buildings[i] = [starti, endi, heighti]`. This means that there is a building with `heighti` in the **half-closed segment** `[starti, endi)`.\n\nYou want to **describe** the heights of the buildings on the street with the **minimum** number of non-overlapping **segments**. The street can be represented by the 2D integer array `street` where `street[j] = [leftj, rightj, averagej]` describes a **half-closed segment** `[leftj, rightj)` of the road where the **average** heights of the buildings in the **segment** is `averagej`.\n\n*   For example, if `buildings = [[1,5,2],[3,10,4]],` the street could be represented by `street = [[1,3,2],[3,5,3],[5,10,4]]` because:\n    *   From 1 to 3, there is only the first building with an average height of `2 / 1 = 2`.\n    *   From 3 to 5, both the first and the second building are there with an average height of `(2+4) / 2 = 3`.\n    *   From 5 to 10, there is only the second building with an average height of `4 / 1 = 4`.\n\nGiven `buildings`, return _the 2D integer array_ `street` _as described above (**excluding** any areas of the street where there are no buldings). You may return the array in **any order**_.\n\nThe **average** of `n` elements is the **sum** of the `n` elements divided (**integer division**) by `n`.\n\nA **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** buildings = \\[\\[1,4,2\\],\\[3,9,4\\]\\]\n**Output:** \\[\\[1,3,2\\],\\[3,4,3\\],\\[4,9,4\\]\\]\n**Explanation:**\nFrom 1 to 3, there is only the first building with an average height of 2 / 1 = 2.\nFrom 3 to 4, both the first and the second building are there with an average height of (2+4) / 2 = 3.\nFrom 4 to 9, there is only the second building with an average height of 4 / 1 = 4.\n\n",
                "**Example 2:**\n\n**Input:** buildings = \\[\\[1,3,2\\],\\[2,5,3\\],\\[2,8,3\\]\\]\n**Output:** \\[\\[1,3,2\\],\\[3,8,3\\]\\]\n**Explanation:**\nFrom 1 to 2, there is only the first building with an average height of 2 / 1 = 2.\nFrom 2 to 3, all three buildings are there with an average height of (2+3+3) / 3 = 2.\nFrom 3 to 5, both the second and the third building are there with an average height of (3+3) / 2 = 3.\nFrom 5 to 8, there is only the last building with an average height of 3 / 1 = 3.\nThe average height from 1 to 3 is the same so we can group them into one segment.\nThe average height from 3 to 8 is the same so we can group them into one segment.\n\n",
                "**Example 3:**\n\n**Input:** buildings = \\[\\[1,2,1\\],\\[5,6,1\\]\\]\n**Output:** \\[\\[1,2,1\\],\\[5,6,1\\]\\]\n**Explanation:**\nFrom 1 to 2, there is only the first building with an average height of 1 / 1 = 1.\nFrom 2 to 5, there are no buildings, so it is not included in the output.\nFrom 5 to 6, there is only the second building with an average height of 1 / 1 = 1.\nWe cannot group the segments together because an empty space with no buildings seperates the segments."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= buildings.length <= 105`\n*   `buildings[i].length == 3`\n*   `0 <= starti < endi <= 108`\n*   `1 <= heighti <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,4,2],[3,9,4]]",
                "output": "[[1,3,2],[3,4,3],[4,9,4]]"
            },
            {
                "input": "[[1,3,2],[2,5,3],[2,8,3]]",
                "output": "[[1,3,2],[3,8,3]]"
            },
            {
                "input": "[[1,2,1],[5,6,1]]",
                "output": "[[1,2,1],[5,6,1]]"
            }
        ],
        "java": "\n    ```java\npublic boolean findRotation(int[][] mat, int[][] target) {\n    for (int i = 0; i < 4; ++i) {\n        if (Arrays.deepEquals(mat, target)) return true;\n        int n = mat.length;\n        for (int r = 0; r < (n + 1) / 2; ++r)\n            for (int c = 0; c < n / 2; ++c) {\n                int temp = mat[r][c];\n                mat[r][c] = mat[n - 1 - c][r];\n                mat[n - 1 - c][r] = mat[n - 1 - r][n - 1 - c];\n                mat[n - 1 - r][n - 1 - c] = mat[c][n - 1 - r];\n                mat[c][n - 1 - r] = temp;\n            }\n    }\n    return false;\n}\n```\n    \n    The implemented algorithm tries to find if the `mat` matrix is equal to the `target` matrix after being rotated 0, 90, 180, or 270 degrees. To achieve this, the algorithm performs the following steps:\n\n1. Loop through each possible rotation, from 0 to 270 degrees (0, 90, 180, 270).\n2. Check if the current rotated `mat` is equal to `target`. If they are equal, return true.\n3. If not equal, perform a 90-degree clockwise rotation in `mat`.\n- To rotate the `mat` matrix, loop through the top-left quadrant of the matrix.\n- For every element in this quadrant, perform a 4-way swap with corresponding elements from the other 3 quadrants (top-right, bottom-right, bottom-left).\n4. If no match is found after all rotations, return false.\n    ",
        "python": "\n    ```python\ndef findRotation(mat, target):\n    for _ in range(4):\n        if mat == target:\n            return True\n        n = len(mat)\n        for r in range((n + 1) // 2):\n            for c in range(n // 2):\n                mat[r][c], mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r] = mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r], mat[r][c]\n    return False\n```\n    \n    The implemented algorithm tries to find if the `mat` matrix is equal to the `target` matrix after being rotated 0, 90, 180, or 270 degrees. To achieve this, the algorithm performs the following steps:\n\n1. Loop through each possible rotation, from 0 to 270 degrees (0, 90, 180, 270).\n2. Check if the current rotated `mat` is equal to `target`. If they are equal, return true.\n3. If not equal, perform a 90-degree clockwise rotation in `mat`.\n- To rotate the `mat` matrix, loop through the top-left quadrant of the matrix.\n- For every element in this quadrant, perform a 4-way swap with corresponding elements from the other 3 quadrants (top-right, bottom-right, bottom-left).\n4. If no match is found after all rotations, return false.\n    ",
        "c++": "\n    ```cpp\nbool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\n    for (int i = 0; i < 4; ++i) {\n        if (mat == target) return true;\n        int n = mat.size();\n        for (int r = 0; r < (n + 1) / 2; ++r)\n            for (int c = 0; c < n / 2; ++c)\n                swap(mat[r][c], mat[c][n - 1 - r], mat[n - 1 - r][n - 1 - c], mat[n - 1 - c][r]);\n    }\n    return false;\n}\n```\n    \n    The implemented algorithm tries to find if the `mat` matrix is equal to the `target` matrix after being rotated 0, 90, 180, or 270 degrees. To achieve this, the algorithm performs the following steps:\n\n1. Loop through each possible rotation, from 0 to 270 degrees (0, 90, 180, 270).\n2. Check if the current rotated `mat` is equal to `target`. If they are equal, return true.\n3. If not equal, perform a 90-degree clockwise rotation in `mat`.\n- To rotate the `mat` matrix, loop through the top-left quadrant of the matrix.\n- For every element in this quadrant, perform a 4-way swap with corresponding elements from the other 3 quadrants (top-right, bottom-right, bottom-left).\n4. If no match is found after all rotations, return false.\n    ",
        "js": "\n    ```javascript\nfunction findRotation(mat, target) {\n    for (let i = 0; i < 4; ++i) {\n        if (JSON.stringify(mat) === JSON.stringify(target)) return true;\n        const n = mat.length;\n        for (let r = 0; r < (n + 1) / 2; ++r)\n            for (let c = 0; c < n / 2; ++c) {\n                let temp = mat[r][c];\n                mat[r][c] = mat[n - 1 - c][r];\n                mat[n - 1 - c][r] = mat[n - 1 - r][n - 1 - c];\n                mat[n - 1 - r][n - 1 - c] = mat[c][n - 1 - r];\n                mat[c][n - 1 - r] = temp;\n            }\n    }\n    return false;\n}\n```\n\n    \n    The implemented algorithm tries to find if the `mat` matrix is equal to the `target` matrix after being rotated 0, 90, 180, or 270 degrees. To achieve this, the algorithm performs the following steps:\n\n1. Loop through each possible rotation, from 0 to 270 degrees (0, 90, 180, 270).\n2. Check if the current rotated `mat` is equal to `target`. If they are equal, return true.\n3. If not equal, perform a 90-degree clockwise rotation in `mat`.\n- To rotate the `mat` matrix, loop through the top-left quadrant of the matrix.\n- For every element in this quadrant, perform a 4-way swap with corresponding elements from the other 3 quadrants (top-right, bottom-right, bottom-left).\n4. If no match is found after all rotations, return false.\n    "
    },
    {
        "id": 304,
        "title": "Brightest Position on Street",
        "difficulty": "Medium",
        "content": {
            "problem": "A perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array `lights`. Each `lights[i] = [positioni, rangei]` indicates that there is a street lamp at position `positioni` that lights up the area from `[positioni - rangei, positioni + rangei]` (**inclusive**).\n\nThe **brightness** of a position `p` is defined as the number of street lamp that light up the position `p`.\n\nGiven `lights`, return _the **brightest** position on the_ _street. If there are multiple brightest positions, return the **smallest** one._",
            "examples": [
                "**Example 1:**\n\n**Input:** lights = \\[\\[-3,2\\],\\[1,2\\],\\[3,3\\]\\]\n**Output:** -1\n**Explanation:**\nThe first street lamp lights up the area from \\[(-3) - 2, (-3) + 2\\] = \\[-5, -1\\].\nThe second street lamp lights up the area from \\[1 - 2, 1 + 2\\] = \\[-1, 3\\].\nThe third street lamp lights up the area from \\[3 - 3, 3 + 3\\] = \\[0, 6\\].\n\nPosition -1 has a brightness of 2, illuminated by the first and second street light.\nPositions 0, 1, 2, and 3 have a brightness of 2, illuminated by the second and third street light.\nOut of all these positions, -1 is the smallest, so return it.\n\n",
                "**Example 2:**\n\n**Input:** lights = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 1\n**Explanation:**\nThe first street lamp lights up the area from \\[1 - 0, 1 + 0\\] = \\[1, 1\\].\nThe second street lamp lights up the area from \\[0 - 1, 0 + 1\\] = \\[-1, 1\\].\n\nPosition 1 has a brightness of 2, illuminated by the first and second street light.\nReturn 1 because it is the brightest position on the street.\n\n",
                "**Example 3:**\n\n**Input:** lights = \\[\\[1,2\\]\\]\n**Output:** -1\n**Explanation:**\nThe first street lamp lights up the area from \\[1 - 2, 1 + 2\\] = \\[-1, 3\\].\n\nPositions -1, 0, 1, 2, and 3 have a brightness of 1, illuminated by the first street light.\nOut of all these positions, -1 is the smallest, so return it."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= lights.length <= 105`\n*   `lights[i].length == 2`\n*   `-108 <= positioni <= 108`\n*   `0 <= rangei <= 108`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[-3,2],[1,2],[3,3]]",
                "output": "-1"
            },
            {
                "input": "[[1,0],[0,1]]",
                "output": "1"
            },
            {
                "input": "[[1,2]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic String removeOccurrences(String s, String part) {\n    while (s.contains(part)) {\n        s = s.replaceFirst(part, \"\");\n    }\n    return s;\n}\n```\n    \n    The algorithm for this problem is simple and straightforward. We'll use a loop to keep checking if the given substring `part` is present in the main string `s` or not. If it is, we remove it from the string.\n\nIn each language implementation, we perform the following steps:\n\n1. Use a loop to keep checking if the string `s` contains the substring `part`.\n2. If it does, remove the first occurrence of `part` from the string `s`.\n3. Repeat this process until there are no more occurrences of `part` in the string `s`.\n\nThese steps are common for all the languages. However, the syntax for checking the presence of a substring, and to replace the substring with an empty string, may vary slightly between different languages as shown in the code samples above.\n    ",
        "python": "\n    ```python\ndef remove_occurrences(s, part):\n    while part in s:\n        s = s.replace(part, '', 1)\n    return s\n```\n    \n    The algorithm for this problem is simple and straightforward. We'll use a loop to keep checking if the given substring `part` is present in the main string `s` or not. If it is, we remove it from the string.\n\nIn each language implementation, we perform the following steps:\n\n1. Use a loop to keep checking if the string `s` contains the substring `part`.\n2. If it does, remove the first occurrence of `part` from the string `s`.\n3. Repeat this process until there are no more occurrences of `part` in the string `s`.\n\nThese steps are common for all the languages. However, the syntax for checking the presence of a substring, and to replace the substring with an empty string, may vary slightly between different languages as shown in the code samples above.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string removeOccurrences(std::string s, std::string part) {\n    size_t pos = 0;\n    while ((pos = s.find(part, pos)) != std::string::npos) {\n        s.erase(pos, part.length());\n    }\n    return s;\n}\n```\n    \n    The algorithm for this problem is simple and straightforward. We'll use a loop to keep checking if the given substring `part` is present in the main string `s` or not. If it is, we remove it from the string.\n\nIn each language implementation, we perform the following steps:\n\n1. Use a loop to keep checking if the string `s` contains the substring `part`.\n2. If it does, remove the first occurrence of `part` from the string `s`.\n3. Repeat this process until there are no more occurrences of `part` in the string `s`.\n\nThese steps are common for all the languages. However, the syntax for checking the presence of a substring, and to replace the substring with an empty string, may vary slightly between different languages as shown in the code samples above.\n    ",
        "js": "\n    ```javascript\nfunction removeOccurrences(s, part) {\n    while (s.includes(part)) {\n        s = s.replace(part, '');\n    }\n    return s;\n}\n```\n    \n    The algorithm for this problem is simple and straightforward. We'll use a loop to keep checking if the given substring `part` is present in the main string `s` or not. If it is, we remove it from the string.\n\nIn each language implementation, we perform the following steps:\n\n1. Use a loop to keep checking if the string `s` contains the substring `part`.\n2. If it does, remove the first occurrence of `part` from the string `s`.\n3. Repeat this process until there are no more occurrences of `part` in the string `s`.\n\nThese steps are common for all the languages. However, the syntax for checking the presence of a substring, and to replace the substring with an empty string, may vary slightly between different languages as shown in the code samples above.\n    "
    },
    {
        "id": 305,
        "title": "Count Subarrays With More Ones Than Zeros",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a binary array `nums` containing only the integers `0` and `1`. Return _the number of **subarrays** in nums that have **more**_ `1`'_s than_ `0`_'s. Since the answer may be very large, return it **modulo**_ `109 + 7`.\n\nA **subarray** is a contiguous sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,1,0,1\\]\n**Output:** 9\n**Explanation:**\nThe subarrays of size 1 that have more ones than zeros are: \\[1\\], \\[1\\], \\[1\\]\nThe subarrays of size 2 that have more ones than zeros are: \\[1,1\\]\nThe subarrays of size 3 that have more ones than zeros are: \\[0,1,1\\], \\[1,1,0\\], \\[1,0,1\\]\nThe subarrays of size 4 that have more ones than zeros are: \\[1,1,0,1\\]\nThe subarrays of size 5 that have more ones than zeros are: \\[0,1,1,0,1\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** 0\n**Explanation:**\nNo subarrays have more ones than zeros.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:**\nThe subarrays of size 1 that have more ones than zeros are: \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 1`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,1,0,1]",
                "output": "9"
            },
            {
                "input": "[0]",
                "output": "0"
            },
            {
                "input": "[1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minMoves(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = i;\n        for (int x = 1; x < i; x++) {\n            int broken = x - 1;\n            int unbroken = i - x;\n            dp[i] = Math.min(dp[i], 1 + Math.max(dp[broken], dp[unbroken]));\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    We can use dynamic programming to solve this problem. Start with two base cases: \n\n1. If there are no floors (n=0), the minimum moves required is 0.\n2. If there is only one floor (n=1), the minimum moves required is 1.\n\nCreate an array `dp` with `n+1` elements, initializing `dp[0]` to 0 and `dp[1]` to 1.\n\nFor each floor `i` from 2 to `n`, start with `dp[i]` as `i`. For each potential drop floor `x` from 1 to `i-1`, we can calculate the number of moves required as the maximum moves between when the egg breaks (`x-1`) and when the egg doesn't break (`i-x`), plus 1 for the current move. Update `dp[i]` as the minimum between its current value and the calculated number of moves.\n\nOnce we have processed all floors, `dp[n]` contains the minimum number of moves required to determine floor `f` with certainty.\n    ",
        "python": "\n    ```python\ndef min_moves(n):\n    dp = [0, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n        dp[i] = i\n        for x in range(1, i):\n            broken = x - 1\n            unbroken = i - x\n            dp[i] = min(dp[i], 1 + max(dp[broken], dp[unbroken]))\n\n    return dp[n]\n```\n    \n    We can use dynamic programming to solve this problem. Start with two base cases: \n\n1. If there are no floors (n=0), the minimum moves required is 0.\n2. If there is only one floor (n=1), the minimum moves required is 1.\n\nCreate an array `dp` with `n+1` elements, initializing `dp[0]` to 0 and `dp[1]` to 1.\n\nFor each floor `i` from 2 to `n`, start with `dp[i]` as `i`. For each potential drop floor `x` from 1 to `i-1`, we can calculate the number of moves required as the maximum moves between when the egg breaks (`x-1`) and when the egg doesn't break (`i-x`), plus 1 for the current move. Update `dp[i]` as the minimum between its current value and the calculated number of moves.\n\nOnce we have processed all floors, `dp[n]` contains the minimum number of moves required to determine floor `f` with certainty.\n    ",
        "c++": "\n    ```cpp\nint minMoves(int n) {\n    int dp[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = i;\n        for (int x = 1; x < i; x++) {\n            int broken = x - 1;\n            int unbroken = i - x;\n            dp[i] = std::min(dp[i], 1 + std::max(dp[broken], dp[unbroken]));\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    We can use dynamic programming to solve this problem. Start with two base cases: \n\n1. If there are no floors (n=0), the minimum moves required is 0.\n2. If there is only one floor (n=1), the minimum moves required is 1.\n\nCreate an array `dp` with `n+1` elements, initializing `dp[0]` to 0 and `dp[1]` to 1.\n\nFor each floor `i` from 2 to `n`, start with `dp[i]` as `i`. For each potential drop floor `x` from 1 to `i-1`, we can calculate the number of moves required as the maximum moves between when the egg breaks (`x-1`) and when the egg doesn't break (`i-x`), plus 1 for the current move. Update `dp[i]` as the minimum between its current value and the calculated number of moves.\n\nOnce we have processed all floors, `dp[n]` contains the minimum number of moves required to determine floor `f` with certainty.\n    ",
        "js": "\n    ```javascript\nfunction minMoves(n) {\n    const dp = new Array(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++) {\n        dp[i] = i;\n        for (let x = 1; x < i; x++) {\n            const broken = x - 1;\n            const unbroken = i - x;\n            dp[i] = Math.min(dp[i], 1 + Math.max(dp[broken], dp[unbroken]));\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    We can use dynamic programming to solve this problem. Start with two base cases: \n\n1. If there are no floors (n=0), the minimum moves required is 0.\n2. If there is only one floor (n=1), the minimum moves required is 1.\n\nCreate an array `dp` with `n+1` elements, initializing `dp[0]` to 0 and `dp[1]` to 1.\n\nFor each floor `i` from 2 to `n`, start with `dp[i]` as `i`. For each potential drop floor `x` from 1 to `i-1`, we can calculate the number of moves required as the maximum moves between when the egg breaks (`x-1`) and when the egg doesn't break (`i-x`), plus 1 for the current move. Update `dp[i]` as the minimum between its current value and the calculated number of moves.\n\nOnce we have processed all floors, `dp[n]` contains the minimum number of moves required to determine floor `f` with certainty.\n    "
    },
    {
        "id": 306,
        "title": "Stock Price Fluctuation ",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a stream of **records** about a particular stock. Each record contains a **timestamp** and the corresponding **price** of the stock at that timestamp.\n\nUnfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream **correcting** the price of the previous wrong record.\n\nDesign an algorithm that:\n\n*   **Updates** the price of the stock at a particular timestamp, **correcting** the price from any previous records at the timestamp.\n*   Finds the **latest price** of the stock based on the current records. The **latest price** is the price at the latest timestamp recorded.\n*   Finds the **maximum price** the stock has been based on the current records.\n*   Finds the **minimum price** the stock has been based on the current records.\n\nImplement the `StockPrice` class:\n\n*   `StockPrice()` Initializes the object with no price records.\n*   `void update(int timestamp, int price)` Updates the `price` of the stock at the given `timestamp`.\n*   `int current()` Returns the **latest price** of the stock.\n*   `int maximum()` Returns the **maximum price** of the stock.\n*   `int minimum()` Returns the **minimum price** of the stock.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"StockPrice \",  \"update \",  \"update \",  \"current \",  \"maximum \",  \"update \",  \"maximum \",  \"update \",  \"minimum \"\\]\n\\[\\[\\], \\[1, 10\\], \\[2, 5\\], \\[\\], \\[\\], \\[1, 3\\], \\[\\], \\[4, 2\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 5, 10, null, 5, null, 2\\]\n\n**Explanation**\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // Timestamps are \\[1\\] with corresponding prices \\[10\\].\nstockPrice.update(2, 5);  // Timestamps are \\[1,2\\] with corresponding prices \\[10,5\\].\nstockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.\nstockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.\nstockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.\n                          // Timestamps are \\[1,2\\] with corresponding prices \\[3,5\\].\nstockPrice.maximum();     // return 5, the maximum price is 5 after the correction.\nstockPrice.update(4, 2);  // Timestamps are \\[1,2,4\\] with corresponding prices \\[3,5,2\\].\nstockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= timestamp, price <= 109`\n*   At most `105` calls will be made **in total** to `update`, `current`, `maximum`, and `minimum`.\n*   `current`, `maximum`, and `minimum` will be called **only after** `update` has been called **at least once**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,5,10,null,5,null,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] min_absolute_difference(int[] nums, int[][] queries) {\n    int[] result = new int[queries.length];\n\n    for (int i = 0; i < queries.length; i++) {\n        int left = queries[i][0];\n        int right = queries[i][1];\n        TreeSet<Integer> unique = new TreeSet<>();\n\n        for (int j = left; j <= right; j++)\n            unique.add(nums[j]);\n\n        if (unique.size() == 1) {\n            result[i] = -1;\n        } else {\n            int min_diff = Integer.MAX_VALUE;\n            for (Iterator<Integer> it = unique.iterator(); it.hasNext(); ) {\n                int curr = (int) it.next();\n                if (!it.hasNext()) break;\n                int next = (int) it.next();\n                min_diff = Math.min(min_diff, next - curr);\n                it.previous();\n            }\n\n            result[i] = min_diff;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. Loop through all the queries: for each query:\n   1. Get the left and right indexes.\n   2. Create a set of unique elements between the left and right indexes.\n   3. If there is only one unique element, the minimum difference is -1, add it to the result list.\n   4. Otherwise, sort the unique elements and find the minimum difference between adjacent elements. Add the minimum difference to the result list.\n3. Return the result list.\n    ",
        "python": "\n    ```python\ndef min_absolute_difference(nums, queries):\n    result = []\n\n    for query in queries:\n        left, right = query\n        unique = list(set(nums[left:right + 1]))\n\n        if len(unique) == 1:\n            result.append(-1)\n        else:\n            unique.sort()\n            min_diff = float('inf')\n            for i in range(1, len(unique)):\n                min_diff = min(min_diff, unique[i] - unique[i - 1])\n\n            result.append(min_diff)\n\n    return result\n```\n    \n    1. Create an empty result list.\n2. Loop through all the queries: for each query:\n   1. Get the left and right indexes.\n   2. Create a set of unique elements between the left and right indexes.\n   3. If there is only one unique element, the minimum difference is -1, add it to the result list.\n   4. Otherwise, sort the unique elements and find the minimum difference between adjacent elements. Add the minimum difference to the result list.\n3. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\n\nstd::vector<int> min_absolute_difference(std::vector<int>& nums, std::vector<std::vector<int>>& queries) {\n    std::vector<int> result;\n\n    for (std::vector<int> query : queries) {\n        int left = query[0];\n        int right = query[1];\n        std::set<int> unique;\n       \n        for (int i = left; i <= right; ++i)\n            unique.insert(nums[i]);\n\n        if (unique.size() == 1) {\n            result.push_back(-1);\n        } else {\n            int min_diff = INT_MAX;\n            for (auto it = std::next(unique.begin()); it != unique.end(); ++it)\n                min_diff = std::min(min_diff, *it - *std::prev(it));\n\n            result.push_back(min_diff);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. Loop through all the queries: for each query:\n   1. Get the left and right indexes.\n   2. Create a set of unique elements between the left and right indexes.\n   3. If there is only one unique element, the minimum difference is -1, add it to the result list.\n   4. Otherwise, sort the unique elements and find the minimum difference between adjacent elements. Add the minimum difference to the result list.\n3. Return the result list.\n    ",
        "js": "\n    ```javascript\nfunction min_absolute_difference(nums, queries) {\n    const result = [];\n\n    for (const query of queries) {\n        const left = query[0];\n        const right = query[1];\n        const unique = new Set(nums.slice(left, right + 1));\n\n        if (unique.size === 1) {\n            result.push(-1);\n        } else {\n            const sorted = Array.from(unique).sort((a, b) => a - b);\n            let min_diff = Number.MAX_SAFE_INTEGER;\n            for (let i = 1; i < sorted.length; i++)\n                min_diff = Math.min(min_diff, sorted[i] - sorted[i - 1]);\n\n            result.push(min_diff);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. Loop through all the queries: for each query:\n   1. Get the left and right indexes.\n   2. Create a set of unique elements between the left and right indexes.\n   3. If there is only one unique element, the minimum difference is -1, add it to the result list.\n   4. Otherwise, sort the unique elements and find the minimum difference between adjacent elements. Add the minimum difference to the result list.\n3. Return the result list.\n    "
    },
    {
        "id": 307,
        "title": "Maximum Alternating Subarray Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "A **subarray** of a **0-indexed** integer array is a contiguous **non-empty** sequence of elements within an array.\n\nThe **alternating subarray sum** of a subarray that ranges from index `i` to `j` (**inclusive**, `0 <= i <= j < nums.length`) is `nums[i] - nums[i+1] + nums[i+2] - ... +/- nums[j]`.\n\nGiven a **0-indexed** integer array `nums`, return _the **maximum alternating subarray sum** of any subarray of_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,-1,1,2\\]\n**Output:** 5\n**Explanation:**\nThe subarray \\[3,-1,1\\] has the largest alternating subarray sum.\nThe alternating subarray sum is 3 - (-1) + 1 = 5.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 2\n**Explanation:**\nThe subarrays \\[2\\], \\[2,2,2\\], and \\[2,2,2,2,2\\] have the largest alternating subarray sum.\nThe alternating subarray sum of \\[2\\] is 2.\nThe alternating subarray sum of \\[2,2,2\\] is 2 - 2 + 2 = 2.\nThe alternating subarray sum of \\[2,2,2,2,2\\] is 2 - 2 + 2 - 2 + 2 = 2.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:**\nThere is only one non-empty subarray, which is \\[1\\].\nThe alternating subarray sum is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,-1,1,2]",
                "output": "5"
            },
            {
                "input": "[2,2,2,2,2]",
                "output": "2"
            },
            {
                "input": "[1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxAlternatingSum(int[] nums) {\n    long odd = 0, even = 0;\n    for (int num : nums) {\n        long newOdd = Math.max(even + num, odd);\n        even = Math.max(odd - num, even);\n        odd = newOdd;\n    }\n    return (int)odd;\n}\n```\n    \n    We will use dynamic programming approach to solve this problem. We will keep track of two variables: `odd` and `even`, which represent the maximum alternating subarray sum ending at odd and even indices, respectively. We will loop through the input array `nums` and update `odd` and `even`. For each number in the array, the new maximum subarray sum ending at odd index is maximum of previous maximum subarray sum ending at even index plus current number, and previous maximum subarray sum ending at odd index. Similarly, the new maximum subarray sum ending at even index is maximum of previous maximum subarray sum ending at odd index minus current number, and previous maximum subarray sum ending at even index. At the end of the loop, `odd` stores the maximum alternating subarray sum of the input array.\n    ",
        "python": "\n    ```python\ndef maxAlternatingSum(nums):\n    odd, even = 0, 0\n    for num in nums:\n        newOdd = max(even + num, odd)\n        even = max(odd - num, even)\n        odd = newOdd\n    return odd\n```\n    \n    We will use dynamic programming approach to solve this problem. We will keep track of two variables: `odd` and `even`, which represent the maximum alternating subarray sum ending at odd and even indices, respectively. We will loop through the input array `nums` and update `odd` and `even`. For each number in the array, the new maximum subarray sum ending at odd index is maximum of previous maximum subarray sum ending at even index plus current number, and previous maximum subarray sum ending at odd index. Similarly, the new maximum subarray sum ending at even index is maximum of previous maximum subarray sum ending at odd index minus current number, and previous maximum subarray sum ending at even index. At the end of the loop, `odd` stores the maximum alternating subarray sum of the input array.\n    ",
        "c++": "\n    ```cpp\nint maxAlternatingSum(vector<int>& nums) {\n    long odd = 0, even = 0;\n    for (int num: nums) {\n        long newOdd = max(even + num, odd);\n        even = max(odd - num, even);\n        odd = newOdd;\n    }\n    return odd;\n}\n```\n    \n    We will use dynamic programming approach to solve this problem. We will keep track of two variables: `odd` and `even`, which represent the maximum alternating subarray sum ending at odd and even indices, respectively. We will loop through the input array `nums` and update `odd` and `even`. For each number in the array, the new maximum subarray sum ending at odd index is maximum of previous maximum subarray sum ending at even index plus current number, and previous maximum subarray sum ending at odd index. Similarly, the new maximum subarray sum ending at even index is maximum of previous maximum subarray sum ending at odd index minus current number, and previous maximum subarray sum ending at even index. At the end of the loop, `odd` stores the maximum alternating subarray sum of the input array.\n    ",
        "js": "\n    ```javascript\nfunction maxAlternatingSum(nums) {\n    let odd = 0, even = 0;\n    for (const num of nums) {\n        const newOdd = Math.max(even + num, odd);\n        even = Math.max(odd - num, even);\n        odd = newOdd;\n    }\n    return odd;\n}\n```\n    \n    We will use dynamic programming approach to solve this problem. We will keep track of two variables: `odd` and `even`, which represent the maximum alternating subarray sum ending at odd and even indices, respectively. We will loop through the input array `nums` and update `odd` and `even`. For each number in the array, the new maximum subarray sum ending at odd index is maximum of previous maximum subarray sum ending at even index plus current number, and previous maximum subarray sum ending at odd index. Similarly, the new maximum subarray sum ending at even index is maximum of previous maximum subarray sum ending at odd index minus current number, and previous maximum subarray sum ending at even index. At the end of the loop, `odd` stores the maximum alternating subarray sum of the input array.\n    "
    },
    {
        "id": 308,
        "title": "Sort Linked List Already Sorted Using Absolute Values",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `head` of a singly linked list that is sorted in **non-decreasing** order using the **absolute values** of its nodes, return _the list sorted in **non-decreasing** order using the **actual values** of its nodes_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[0,2,-5,5,10,-10\\]\n**Output:** \\[-10,-5,0,2,5,10\\]\n**Explanation:**\nThe list sorted in non-descending order using the absolute values of the nodes is \\[0,2,-5,5,10,-10\\].\nThe list sorted in non-descending order using the actual values is \\[-10,-5,0,2,5,10\\].\n\n",
                "**Example 2:**\n\n**Input:** head = \\[0,1,2\\]\n**Output:** \\[0,1,2\\]\n**Explanation:**\nThe linked list is already sorted in non-decreasing order.\n\n",
                "**Example 3:**\n\n**Input:** head = \\[1\\]\n**Output:** \\[1\\]\n**Explanation:**\nThe linked list is already sorted in non-decreasing order."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is the range `[1, 105]`.\n*   `-5000 <= Node.val <= 5000`\n*   `head` is sorted in non-decreasing order using the absolute value of its nodes.\n\n**",
            "follow_up": "Follow up:**\n\n*   Can you think of a solution with `O(n)` time complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "[0,2,-5,5,10,-10]",
                "output": "[-10,-5,0,2,5,10]"
            },
            {
                "input": "[0,1,2]",
                "output": "[0,1,2]"
            },
            {
                "input": "[1]",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode sortedList(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    ListNode prev = head;\n    ListNode cur = head.next;\n\n    while (cur != null) {\n        if (cur.val < prev.val) {\n            prev.next = cur.next;\n            cur.next = head;\n            head = cur;\n            cur = prev;\n        } else {\n            prev = cur;\n        }\n        cur = cur.next;\n    }\n    return head;\n}\n```\n    \n    The given linked list is sorted in non-decreasing order using absolute values of its nodes. We need to sort the linked list in non-decreasing order using the actual values of the nodes.\n1. Start with two pointers, `prev` and `cur` initially pointing to the head and head's next respectively.\n2. Traverse the linked list using a while loop.\n3. Inside the loop, check if the value of `cur` is less than the value of `prev`.\n   - If true, then move the current node to the front of the list, update `prev` and `cur`.\n   - Else, set the `prev` to the current node.\n4. Continue the traversal until the end of the list is reached.\n\nTime complexity: O(n)\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sortedList(head):\n    if not head or not head.next:\n        return head\n\n    prev = head\n    cur = head.next\n\n    while cur:\n        if cur.val < prev.val:\n            prev.next = cur.next\n            cur.next = head\n            head = cur\n            cur = prev\n        else:\n            prev = cur\n        cur = cur.next\n    return head\n```\n    \n    The given linked list is sorted in non-decreasing order using absolute values of its nodes. We need to sort the linked list in non-decreasing order using the actual values of the nodes.\n1. Start with two pointers, `prev` and `cur` initially pointing to the head and head's next respectively.\n2. Traverse the linked list using a while loop.\n3. Inside the loop, check if the value of `cur` is less than the value of `prev`.\n   - If true, then move the current node to the front of the list, update `prev` and `cur`.\n   - Else, set the `prev` to the current node.\n4. Continue the traversal until the end of the list is reached.\n\nTime complexity: O(n)\n    ",
        "c++": "\n    ```cpp\nclass ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int val, ListNode* next = nullptr) : val(val), next(next) {}\n};\n\nListNode* sortedList(ListNode* head) {\n    if (!head || !head->next) return head;\n\n    ListNode* prev = head;\n    ListNode* cur = head->next;\n\n    while (cur) {\n        if (cur->val < prev->val) {\n            prev->next = cur->next;\n            cur->next = head;\n            head = cur;\n            cur = prev;\n        } else {\n            prev = cur;\n        }\n        cur = cur->next;\n    }\n    return head;\n}\n```\n    \n    The given linked list is sorted in non-decreasing order using absolute values of its nodes. We need to sort the linked list in non-decreasing order using the actual values of the nodes.\n1. Start with two pointers, `prev` and `cur` initially pointing to the head and head's next respectively.\n2. Traverse the linked list using a while loop.\n3. Inside the loop, check if the value of `cur` is less than the value of `prev`.\n   - If true, then move the current node to the front of the list, update `prev` and `cur`.\n   - Else, set the `prev` to the current node.\n4. Continue the traversal until the end of the list is reached.\n\nTime complexity: O(n)\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction sortedList(head) {\n    if (!head || !head.next) return head;\n\n    let prev = head;\n    let cur = head.next;\n\n    while (cur) {\n        if (cur.val < prev.val) {\n            prev.next = cur.next;\n            cur.next = head;\n            head = cur;\n            cur = prev;\n        } else {\n            prev = cur;\n        }\n        cur = cur.next;\n    }\n    return head;\n}\n```\n    \n    The given linked list is sorted in non-decreasing order using absolute values of its nodes. We need to sort the linked list in non-decreasing order using the actual values of the nodes.\n1. Start with two pointers, `prev` and `cur` initially pointing to the head and head's next respectively.\n2. Traverse the linked list using a while loop.\n3. Inside the loop, check if the value of `cur` is less than the value of `prev`.\n   - If true, then move the current node to the front of the list, update `prev` and `cur`.\n   - Else, set the `prev` to the current node.\n4. Continue the traversal until the end of the list is reached.\n\nTime complexity: O(n)\n    "
    },
    {
        "id": 309,
        "title": "Minimum Cost to Separate Sentence Into Rows",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `sentence` containing words separated by spaces, and an integer `k`. Your task is to separate `sentence` into **rows** where the number of characters in each row is **at most** `k`. You may assume that `sentence` does not begin or end with a space, and the words in `sentence` are separated by a single space.\n\nYou can split `sentence` into rows by inserting line breaks between words in `sentence`. A word **cannot** be split between two rows. Each word must be used exactly once, and the word order cannot be rearranged. Adjacent words in a row should be separated by a single space, and rows should not begin or end with spaces.\n\nThe **cost** of a row with length `n` is `(k - n)2`, and the **total cost** is the sum of the **costs** for all rows **except** the last one.\n\n*   For example if `sentence = \"i love leetcode \"` and `k = 12`:\n    *   Separating `sentence` into `\"i \"`, `\"love \"`, and `\"leetcode \"` has a cost of `(12 - 1)2 + (12 - 4)2 = 185`.\n    *   Separating `sentence` into `\"i love \"`, and `\"leetcode \"` has a cost of `(12 - 6)2 = 36`.\n    *   Separating `sentence` into `\"i \"`, and `\"love leetcode \"` is not possible because the length of `\"love leetcode \"` is greater than `k`.\n\nReturn _the **minimum** possible total cost of separating_ `sentence` _into rows._",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence =  \"i love leetcode \", k = 12\n**Output:** 36\n**Explanation:**\nSeparating sentence into  \"i \",  \"love \", and  \"leetcode \" has a cost of (12 - 1)2 + (12 - 4)2 = 185.\nSeparating sentence into  \"i love \", and  \"leetcode \" has a cost of (12 - 6)2 = 36.\nSeparating sentence into  \"i \",  \"love leetcode \" is not possible because  \"love leetcode \" has length 13.\n36 is the minimum possible total cost so return it.\n\n",
                "**Example 2:**\n\n**Input:** sentence =  \"apples and bananas taste great \", k = 7\n**Output:** 21\n**Explanation**\nSeparating sentence into  \"apples \",  \"and \",  \"bananas \",  \"taste \", and  \"great \" has a cost of (7 - 6)2 + (7 - 3)2 + (7 - 7)2 + (7 - 5)2 \\= 21.\n21 is the minimum possible total cost so return it.\n\n",
                "**Example 3:**\n\n**Input:** sentence =  \"a \", k = 5\n**Output:** 0\n**Explanation:**\nThe cost of the last row is not included in the total cost, and since there is only one row, return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 5000`\n*   `1 <= k <= 5000`\n*   The length of each word in `sentence` is at most `k`.\n*   `sentence` consists of only lowercase English letters and spaces.\n*   `sentence` does not begin or end with a space.\n*   Words in `sentence` are separated by a single space.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"iloveleetcode\",12",
                "output": "36"
            },
            {
                "input": "\"applesandbananastastegreat\",7",
                "output": "21"
            },
            {
                "input": "\"a\",5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minCost(String sentence, int k) {\n\tString[] words = sentence.split(\" \");\n\tint[] dp = new int[words.length + 1];\n\tArrays.fill(dp, Integer.MAX_VALUE);\n\tdp[0] = 0;\n\tfor (int i = 0; i < words.length; i++) {\n\t\tint length = 0;\n\t\tfor (int j = i; j >= 0; j--) {\n\t\t\tlength += words[j].length();\n\t\t\tif (length + (i - j) <= k) {\n\t\t\t\tdp[i + 1] = Math.min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)));\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlength += 1;\n\t\t}\n\t}\n\treturn dp[dp.length - 1];\n}\n```\n\n    \n    1. Split `sentence` into words separated by spaces.\n2. Initialize the dynamic programming table `dp` to store the minimum total cost of splitting the `i` first words. `dp[0] = 0`.\n3. For each word with index `i` in the smaller string, calculate the cost for putting it in a single row with some of the previous words. This is done by iterating backwards through the words from `i`, joining consecutive words one at a time until the row length is greater than `k`.\n4. If the row length is less or equal to `k`, calculate the row cost for this combination of words and update `dp[i + 1] = min(dp[i + 1], dp[j] + cost)`. Otherwise, break the inner loop since adding more words will only make the row length even larger.\n5. Return the last value in `dp`, which represents the minimum total cost for splitting the entire sentence into rows.\n    ",
        "python": "\n    ```python\ndef minCost(sentence: str, k: int) -> int:\n    words = sentence.split()\n    dp = [float('inf')] * (len(words) + 1)\n    dp[0] = 0\n    for i in range(len(words)):\n        length = 0\n        j = i\n        while j >= 0:\n            length += len(words[j])\n            if length + (i - j) <= k:\n                dp[i + 1] = min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)))\n            else:\n                break\n            length += 1\n            j -= 1\n    return dp[-1]\n```\n\n    \n    1. Split `sentence` into words separated by spaces.\n2. Initialize the dynamic programming table `dp` to store the minimum total cost of splitting the `i` first words. `dp[0] = 0`.\n3. For each word with index `i` in the smaller string, calculate the cost for putting it in a single row with some of the previous words. This is done by iterating backwards through the words from `i`, joining consecutive words one at a time until the row length is greater than `k`.\n4. If the row length is less or equal to `k`, calculate the row cost for this combination of words and update `dp[i + 1] = min(dp[i + 1], dp[j] + cost)`. Otherwise, break the inner loop since adding more words will only make the row length even larger.\n5. Return the last value in `dp`, which represents the minimum total cost for splitting the entire sentence into rows.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nint minCost(string sentence, int k) {\n    vector<string> words;\n    string word;\n    for (const char c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n            word.clear();\n        } else {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n    vector<int> dp(words.size() + 1, numeric_limits<int>::max());\n    dp[0] = 0;\n    for (int i = 0; i < words.size(); ++i) {\n        int length = 0;\n        for (int j = i; j >= 0; --j) {\n            length += words[j].size();\n            if (length + (i - j) <= k) {\n                dp[i + 1] = min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)));\n            } else {\n                break;\n            }\n            length += 1;\n        }\n    }\n    return dp.back();\n}\n```\n    \n    1. Split `sentence` into words separated by spaces.\n2. Initialize the dynamic programming table `dp` to store the minimum total cost of splitting the `i` first words. `dp[0] = 0`.\n3. For each word with index `i` in the smaller string, calculate the cost for putting it in a single row with some of the previous words. This is done by iterating backwards through the words from `i`, joining consecutive words one at a time until the row length is greater than `k`.\n4. If the row length is less or equal to `k`, calculate the row cost for this combination of words and update `dp[i + 1] = min(dp[i + 1], dp[j] + cost)`. Otherwise, break the inner loop since adding more words will only make the row length even larger.\n5. Return the last value in `dp`, which represents the minimum total cost for splitting the entire sentence into rows.\n    ",
        "js": "\n    ```javascript\nfunction minCost(sentence, k) {\n    const words = sentence.split(' ');\n    const dp = new Array(words.length + 1).fill(Infinity);\n    dp[0] = 0;\n    for (let i = 0; i < words.length; ++i) {\n        let length = 0;\n        for (let j = i; j >= 0; --j) {\n            length += words[j].length;\n            if (length + (i - j) <= k) {\n                dp[i + 1] = Math.min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)));\n            } else {\n                break;\n            }\n            length += 1;\n        }\n    }\n    return dp[dp.length - 1];\n}\n```\n\n    \n    1. Split `sentence` into words separated by spaces.\n2. Initialize the dynamic programming table `dp` to store the minimum total cost of splitting the `i` first words. `dp[0] = 0`.\n3. For each word with index `i` in the smaller string, calculate the cost for putting it in a single row with some of the previous words. This is done by iterating backwards through the words from `i`, joining consecutive words one at a time until the row length is greater than `k`.\n4. If the row length is less or equal to `k`, calculate the row cost for this combination of words and update `dp[i + 1] = min(dp[i + 1], dp[j] + cost)`. Otherwise, break the inner loop since adding more words will only make the row length even larger.\n5. Return the last value in `dp`, which represents the minimum total cost for splitting the entire sentence into rows.\n    "
    },
    {
        "id": 310,
        "title": "Number of Spaces Cleaning Robot Cleaned",
        "difficulty": "Medium",
        "content": {
            "problem": "A room is represented by a **0-indexed** 2D binary matrix `room` where a `0` represents an **empty** space and a `1` represents a space with an **object**. The top left corner of the room will be empty in all test cases.\n\nA cleaning robot starts at the top left corner of the room and is facing right. The robot will continue heading straight until it reaches the edge of the room or it hits an object, after which it will turn 90 degrees **clockwise** and repeat this process. The starting space and all spaces that the robot visits are **cleaned** by it.\n\nReturn _the number of **clean** spaces in the room if the robot runs indefinetely._",
            "examples": [
                "**Example 1:**  \n\n**Input:** room = \\[\\[0,0,0\\],\\[1,1,0\\],\\[0,0,0\\]\\]\n**Output:** 7\n**Explanation:**\nThe robot cleans the spaces at (0, 0), (0, 1), and (0, 2).\nThe robot is at the edge of the room, so it turns 90 degrees clockwise and now faces down.\nThe robot cleans the spaces at (1, 2), and (2, 2).\nThe robot is at the edge of the room, so it turns 90 degrees clockwise and now faces left.\nThe robot cleans the spaces at (2, 1), and (2, 0).\nThe robot has cleaned all 7 empty spaces, so return 7.\n\n",
                "**Example 2:**  \n\n**Input:** room = \\[\\[0,1,0\\],\\[1,0,0\\],\\[0,0,0\\]\\]\n**Output:** 1\n**Explanation:**\nThe robot cleans the space at (0, 0).\nThe robot hits an object, so it turns 90 degrees clockwise and now faces down.\nThe robot hits an object, so it turns 90 degrees clockwise and now faces left.\nThe robot is at the edge of the room, so it turns 90 degrees clockwise and now faces up.\nThe robot is at the edge of the room, so it turns 90 degrees clockwise and now faces right.\nThe robot is back at its starting position.\nThe robot has cleaned 1 space, so return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `m == room.length`\n*   `n == room[r].length`\n*   `1 <= m, n <= 300`\n*   `room[r][c]` is either `0` or `1`.\n*   `room[0][0] == 0`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,0,0],[1,1,0],[0,0,0]]",
                "output": "7"
            },
            {
                "input": "[[0,1,0],[1,0,0],[0,0,0]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int colorTheGrid(int m, int n) {\n    long mod = 1000000007;\n    long[] dp = {6, 6};\n    long[] dpf = {3, 3};\n\n    for (int i = 2; i <= Math.max(m, n); ++i) {\n        long temp = dp[1];\n        dp[1] = (dpf[1] * 2) % mod;\n        dp[0] = temp;\n        dpf[1] = (dpf[1] + dpf[0]) % mod;\n        dpf[0] = (dpf[0] + temp) % mod;\n    }\n\n    return (int)((dp[m == 1 ? 0 : 1] * dpf[n == 1 ? 0 : 1]) % mod);\n}\n```\n    \n    The problem can be solved by dynamic programming. We can use two DP arrays, dp and dpf. The dp array is used to store the number of ways to fill the first i columns, where dp[0] represents filling the first i columns with 3-cell components, and dp[1] represents filling with 2-cell components. The dpf array is similar, but it's used for the vertical direction.\n\nIn each iteration of the loop from 2 to max(m, n), we calculate the number of ways to fill the first i columns for both 2-cell and 3-cell components and update the dp and dpf arrays accordingly.\n\nAfter the loop, the result is the multiplication of the values corresponding to m and n, modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef colorTheGrid(m, n):\n    mod = 10**9 + 7\n    dp = [6, 6]\n    dpf = [3, 3]\n\n    for _ in range(2, max(m, n) + 1):\n        temp = dp[1]\n        dp[1] = (dpf[1] * 2) % mod\n        dp[0] = temp\n        dpf[1] = (dpf[1] + dpf[0]) % mod\n        dpf[0] = (dpf[0] + temp) % mod\n\n    return (dp[0 if m == 1 else 1] * dpf[0 if n == 1 else 1]) % mod\n```\n    \n    The problem can be solved by dynamic programming. We can use two DP arrays, dp and dpf. The dp array is used to store the number of ways to fill the first i columns, where dp[0] represents filling the first i columns with 3-cell components, and dp[1] represents filling with 2-cell components. The dpf array is similar, but it's used for the vertical direction.\n\nIn each iteration of the loop from 2 to max(m, n), we calculate the number of ways to fill the first i columns for both 2-cell and 3-cell components and update the dp and dpf arrays accordingly.\n\nAfter the loop, the result is the multiplication of the values corresponding to m and n, modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\nint colorTheGrid(int m, int n) {\n    long long int mod = 1e9 + 7;\n    long long int dp[2] = {6, 6}, dpf[2] = {3, 3};\n    \n    for (int i = 2; i <= max(m, n); ++i) {\n        long long int temp = dp[1];\n        dp[1] = (dpf[1] * 2) % mod;\n        dp[0] = temp;\n        dpf[1] = (dpf[1] + dpf[0]) % mod;\n        dpf[0] = (dpf[0] + temp) % mod;\n    }\n    \n    return (dp[m == 1] * dpf[n == 1]) % mod;\n}\n```\n    \n    The problem can be solved by dynamic programming. We can use two DP arrays, dp and dpf. The dp array is used to store the number of ways to fill the first i columns, where dp[0] represents filling the first i columns with 3-cell components, and dp[1] represents filling with 2-cell components. The dpf array is similar, but it's used for the vertical direction.\n\nIn each iteration of the loop from 2 to max(m, n), we calculate the number of ways to fill the first i columns for both 2-cell and 3-cell components and update the dp and dpf arrays accordingly.\n\nAfter the loop, the result is the multiplication of the values corresponding to m and n, modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction colorTheGrid(m, n) {\n    const mod = 1000000007;\n    const dp = [6, 6];\n    const dpf = [3, 3];\n    \n    for (let i = 2; i <= Math.max(m, n); ++i) {\n        const temp = dp[1];\n        dp[1] = (dpf[1] * 2) % mod;\n        dp[0] = temp;\n        dpf[1] = (dpf[1] + dpf[0]) % mod;\n        dpf[0] = (dpf[0] + temp) % mod;\n    }\n    \n    return (dp[m === 1 ? 0 : 1] * dpf[n === 1 ? 0 : 1]) % mod;\n}\n```\n    \n    The problem can be solved by dynamic programming. We can use two DP arrays, dp and dpf. The dp array is used to store the number of ways to fill the first i columns, where dp[0] represents filling the first i columns with 3-cell components, and dp[1] represents filling with 2-cell components. The dpf array is similar, but it's used for the vertical direction.\n\nIn each iteration of the loop from 2 to max(m, n), we calculate the number of ways to fill the first i columns for both 2-cell and 3-cell components and update the dp and dpf arrays accordingly.\n\nAfter the loop, the result is the multiplication of the values corresponding to m and n, modulo 10^9 + 7.\n    "
    },
    {
        "id": 311,
        "title": "Number of Equal Count Substrings",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** string `s` consisting of only lowercase English letters, and an integer `count`. A **substring** of `s` is said to be an **equal count substring** if, for each **unique** letter in the substring, it appears exactly `count` times in the substring.\n\nReturn _the number of **equal count substrings** in_ `s`.\n\nA **substring** is a contiguous non-empty sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaabcbbcc \", count = 3\n**Output:** 3\n**Explanation:**\nThe substring that starts at index 0 and ends at index 2 is  \"aaa \".\nThe letter 'a' in the substring appears exactly 3 times.\nThe substring that starts at index 3 and ends at index 8 is  \"bcbbcc \".\nThe letters 'b' and 'c' in the substring appear exactly 3 times.\nThe substring that starts at index 0 and ends at index 8 is  \"aaabcbbcc \".\nThe letters 'a', 'b', and 'c' in the substring appear exactly 3 times.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcd \", count = 2\n**Output:** 0\n**Explanation:**\nThe number of times each letter appears in s is less than count.\nTherefore, no substrings in s are equal count substrings, so return 0.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a \", count = 5\n**Output:** 0\n**Explanation:**\nThe number of times each letter appears in s is less than count.\nTherefore, no substrings in s are equal count substrings, so return 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 104`\n*   `1 <= count <= 3 * 104`\n*   `s` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aaabcbbcc\",3",
                "output": "3"
            },
            {
                "input": "\"abcd\",2",
                "output": "0"
            },
            {
                "input": "\"a\",5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int[][] points) {\n    int m = points.length, n = points[0].length;\n    int[][] dp = new int[m][n];\n    dp[0] = points[0];\n\n    for (int r = 1; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n            int score = points[r][c];\n            for (int c_prev = 0; c_prev < n; c_prev++) {\n                dp[r][c] = Math.max(dp[r][c], dp[r - 1][c_prev] + score - Math.abs(c - c_prev));\n            }\n        }\n    }\n\n    int max = dp[m - 1][0];\n    for (int i = 1; i < n; i++) {\n        max = Math.max(max, dp[m - 1][i]);\n    }\n    return max;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The `dp` array has the same dimensions as the input matrix, `m` rows and `n` columns. The value `dp[r][c]` corresponds to the maximum score achievable when picking the cell at row `r` and column `c`. \n\nAt the start, the first row of `dp` is initialized with the values of the corresponding first row of the input `points` matrix because there's no previous row.\n\nFor each subsequent row `r`, iterate through all its columns `c`, and calculate the maximum score of picking the cell at (r, c) by iterating through all possible previous column positions `c_prev` and using the following formula:\n\n`dp[r][c] = max(dp[r - 1][c_prev] + current score - abs(c - c_prev))`\n\nWhere `current score = points[r][c]`. After filling the entire `dp` array, the maximum score achievable is the maximum value in the last row of the `dp` array.\n    ",
        "python": "\n    ```python\ndef maxScore(points):\n    m, n = len(points), len(points[0])\n    dp = [points[0]]\n\n    for r in range(1, m):\n        dp.append([0] * n)\n        for c in range(n):\n            score = points[r][c]\n            dp[r][c] = max(dp[r - 1][c_prev] + score - abs(c - c_prev) for c_prev in range(n))\n            \n    return max(dp[m - 1])\n```\n\n    \n    The algorithm uses dynamic programming. The `dp` array has the same dimensions as the input matrix, `m` rows and `n` columns. The value `dp[r][c]` corresponds to the maximum score achievable when picking the cell at row `r` and column `c`. \n\nAt the start, the first row of `dp` is initialized with the values of the corresponding first row of the input `points` matrix because there's no previous row.\n\nFor each subsequent row `r`, iterate through all its columns `c`, and calculate the maximum score of picking the cell at (r, c) by iterating through all possible previous column positions `c_prev` and using the following formula:\n\n`dp[r][c] = max(dp[r - 1][c_prev] + current score - abs(c - c_prev))`\n\nWhere `current score = points[r][c]`. After filling the entire `dp` array, the maximum score achievable is the maximum value in the last row of the `dp` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxScore(std::vector<std::vector<int>>& points) {\n    int m = points.size(), n = points[0].size();\n    std::vector<std::vector<int>> dp(m, std::vector<int>(n));\n    dp[0] = points[0];\n\n    for (int r = 1; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n            int score = points[r][c];\n            for (int c_prev = 0; c_prev < n; c_prev++) {\n                dp[r][c] = std::max(dp[r][c], dp[r - 1][c_prev] + score - abs(c - c_prev));\n            }\n        }\n    }\n\n    return *std::max_element(dp[m - 1].begin(), dp[m - 1].end());\n}\n```\n\n    \n    The algorithm uses dynamic programming. The `dp` array has the same dimensions as the input matrix, `m` rows and `n` columns. The value `dp[r][c]` corresponds to the maximum score achievable when picking the cell at row `r` and column `c`. \n\nAt the start, the first row of `dp` is initialized with the values of the corresponding first row of the input `points` matrix because there's no previous row.\n\nFor each subsequent row `r`, iterate through all its columns `c`, and calculate the maximum score of picking the cell at (r, c) by iterating through all possible previous column positions `c_prev` and using the following formula:\n\n`dp[r][c] = max(dp[r - 1][c_prev] + current score - abs(c - c_prev))`\n\nWhere `current score = points[r][c]`. After filling the entire `dp` array, the maximum score achievable is the maximum value in the last row of the `dp` array.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(points) {\n    let m = points.length, n = points[0].length;\n    let dp = [points[0]];\n\n    for (let r = 1; r < m; r++) {\n        dp.push(Array(n).fill(0));\n        for (let c = 0; c < n; c++) {\n            let score = points[r][c];\n            for (let c_prev = 0; c_prev < n; c_prev++) {\n                dp[r][c] = Math.max(dp[r][c], dp[r - 1][c_prev] + score - Math.abs(c - c_prev));\n            }\n        }\n    }\n\n    return Math.max(...dp[m - 1]);\n}\n```\n\n    \n    The algorithm uses dynamic programming. The `dp` array has the same dimensions as the input matrix, `m` rows and `n` columns. The value `dp[r][c]` corresponds to the maximum score achievable when picking the cell at row `r` and column `c`. \n\nAt the start, the first row of `dp` is initialized with the values of the corresponding first row of the input `points` matrix because there's no previous row.\n\nFor each subsequent row `r`, iterate through all its columns `c`, and calculate the maximum score of picking the cell at (r, c) by iterating through all possible previous column positions `c_prev` and using the following formula:\n\n`dp[r][c] = max(dp[r - 1][c_prev] + current score - abs(c - c_prev))`\n\nWhere `current score = points[r][c]`. After filling the entire `dp` array, the maximum score achievable is the maximum value in the last row of the `dp` array.\n    "
    },
    {
        "id": 312,
        "title": "Paths in Maze That Lead to Same Room",
        "difficulty": "Medium",
        "content": {
            "problem": "A maze consists of `n` rooms numbered from `1` to `n`, and some rooms are connected by corridors. You are given a 2D integer array `corridors` where `corridors[i] = [room1i, room2i]` indicates that there is a corridor connecting `room1i` and `room2i`, allowing a person in the maze to go from `room1i` to `room2i` **and vice versa**.\n\nThe designer of the maze wants to know how confusing the maze is. The **confusion** **score** of the maze is the number of different cycles of **length 3**.\n\n*   For example, `1 -> 2 -> 3 -> 1` is a cycle of length 3, but `1 -> 2 -> 3 -> 4` and `1 -> 2 -> 3 -> 2 -> 1` are not.\n\nTwo cycles are considered to be **different** if one or more of the rooms visited in the first cycle is **not** in the second cycle.\n\nReturn _the_ _**confusion** **score** of the maze._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, corridors = \\[\\[1,2\\],\\[5,2\\],\\[4,1\\],\\[2,4\\],\\[3,1\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:**\nOne cycle of length 3 is 4 -> 1 -> 3 -> 4, denoted in red.\nNote that this is the same cycle as 3 -> 4 -> 1 -> 3 or 1 -> 3 -> 4 -> 1 because the rooms are the same.\nAnother cycle of length 3 is 1 -> 2 -> 4 -> 1, denoted in blue.\nThus, there are two different cycles of length 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, corridors = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** 0\n**Explanation:**\nThere are no cycles of length 3."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= corridors.length <= 5 * 104`\n*   `corridors[i].length == 2`\n*   `1 <= room1i, room2i <= n`\n*   `room1i != room2i`\n*   There are no duplicate corridors.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[1,2],[5,2],[4,1],[2,4],[3,1],[3,4]]",
                "output": "2"
            },
            {
                "input": "4,[[1,2],[3,4]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic String maximumNumber(String num, int[] change) {\n    boolean mutatable = false;\n    char[] numArray = num.toCharArray();\n    for (int i = 0; i < numArray.length; i++) {\n        int digit = numArray[i] - '0';\n        if (digit < change[digit]) {\n            if (!mutatable) mutatable = true;\n            numArray[i] = (char) (change[digit] + '0');\n        } else if (digit > change[digit] && mutatable) {\n            break;\n        }\n    }\n    return new String(numArray);\n}\n```\n    \n    1. Convert the input string to a mutable data structure (C++: string, Java: char array, Python: list of characters, JavaScript: array of characters).\n2. Initialize a boolean variable `mutatable` to keep track of whether we have started mutating or not.\n3. Iterate through the digits of input string `num`.\n4. For each digit, compare it to the corresponding value in the `change` array. \n5. If the digit is smaller than its corresponding change value and mutatable is false, set mutatable to true, and replace the digit with the change value.\n6. If the digit is larger than its corresponding change value and mutatable is true, break the loop because the string is now non-increasing.\n7. Convert the mutable data structure back to the string and return it.\n    ",
        "python": "\n    ```python\ndef maximumNumber(num: str, change: List[int]) -> str:\n    num = list(num)\n    mutatable = False\n    for i in range(len(num)):\n        digit = int(num[i])\n        if digit < change[digit]:\n            if not mutatable: mutatable = True\n            num[i] = str(change[digit])\n        elif digit > change[digit] and mutatable:\n            break\n    return \"\".join(num)\n```\n    \n    1. Convert the input string to a mutable data structure (C++: string, Java: char array, Python: list of characters, JavaScript: array of characters).\n2. Initialize a boolean variable `mutatable` to keep track of whether we have started mutating or not.\n3. Iterate through the digits of input string `num`.\n4. For each digit, compare it to the corresponding value in the `change` array. \n5. If the digit is smaller than its corresponding change value and mutatable is false, set mutatable to true, and replace the digit with the change value.\n6. If the digit is larger than its corresponding change value and mutatable is true, break the loop because the string is now non-increasing.\n7. Convert the mutable data structure back to the string and return it.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring maximumNumber(string num, vector<int>& change) {\n    bool mutatable = false;\n    for (int i = 0; i < num.size(); i++) {\n        int digit = num[i] - '0';\n        if (digit < change[digit]) {\n            if (!mutatable) mutatable = true;\n            num[i] = change[digit] + '0';\n        } else if (digit > change[digit] && mutatable) {\n            break;\n        }\n    }\n    return num;\n}\n```\n    \n    1. Convert the input string to a mutable data structure (C++: string, Java: char array, Python: list of characters, JavaScript: array of characters).\n2. Initialize a boolean variable `mutatable` to keep track of whether we have started mutating or not.\n3. Iterate through the digits of input string `num`.\n4. For each digit, compare it to the corresponding value in the `change` array. \n5. If the digit is smaller than its corresponding change value and mutatable is false, set mutatable to true, and replace the digit with the change value.\n6. If the digit is larger than its corresponding change value and mutatable is true, break the loop because the string is now non-increasing.\n7. Convert the mutable data structure back to the string and return it.\n    ",
        "js": "\n    ```javascript\nfunction maximumNumber(num, change) {\n    let mutatable = false;\n    let numArray = num.split('');\n    for (let i = 0; i < numArray.length; i++) {\n        let digit = numArray[i] - '0';\n        if (digit < change[digit]) {\n            if (!mutatable) mutatable = true;\n            numArray[i] = change[digit] + '0';\n        } else if (digit > change[digit] && mutatable) {\n            break;\n        }\n    }\n    return numArray.join('');\n}\n```\n    \n    1. Convert the input string to a mutable data structure (C++: string, Java: char array, Python: list of characters, JavaScript: array of characters).\n2. Initialize a boolean variable `mutatable` to keep track of whether we have started mutating or not.\n3. Iterate through the digits of input string `num`.\n4. For each digit, compare it to the corresponding value in the `change` array. \n5. If the digit is smaller than its corresponding change value and mutatable is false, set mutatable to true, and replace the digit with the change value.\n6. If the digit is larger than its corresponding change value and mutatable is true, break the loop because the string is now non-increasing.\n7. Convert the mutable data structure back to the string and return it.\n    "
    },
    {
        "id": 313,
        "title": "Substrings That Begin and End With the Same Letter",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** string `s` consisting of only lowercase English letters. Return _the number of **substrings** in_ `s` _that begin and end with the **same** character._\n\nA **substring** is a contiguous non-empty sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcba \"\n**Output:** 7\n**Explanation:**\nThe substrings of length 1 that start and end with the same letter are:  \"a \",  \"b \",  \"c \",  \"b \", and  \"a \".\nThe substring of length 3 that starts and ends with the same letter is:  \"bcb \".\nThe substring of length 5 that starts and ends with the same letter is:  \"abcba \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abacad \"\n**Output:** 9\n**Explanation:**\nThe substrings of length 1 that start and end with the same letter are:  \"a \",  \"b \",  \"a \",  \"c \",  \"a \", and  \"d \".\nThe substrings of length 3 that start and end with the same letter are:  \"aba \" and  \"aca \".\nThe substring of length 5 that starts and ends with the same letter is:  \"abaca \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:**\nThe substring of length 1 that starts and ends with the same letter is:  \"a \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcba\"",
                "output": "7"
            },
            {
                "input": "\"abacad\"",
                "output": "9"
            },
            {
                "input": "\"a\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nboolean hasThreeDivisors(int n) {\n    int count = 0;\n    for (int i = 1; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) {\n            if (n / i == i)\n                count++;\n            else\n                count += 2;\n        }\n        if (count > 3)\n            break;\n    }\n    return count == 3;\n}\n```\n    \n    The algorithm iterates through every integer i from 1 to the square root of n. For each integer i, it checks if n is divisible by i, indicating that i is a divisor of n. If n is divisible by i, the algorithm further calculates n/i, which is the other divisor. If i and n/i are equal, count is incremented by 1; otherwise, count is incremented by 2, as there are two distinct divisors. If the count goes over 3, the loop is broken since we only care about finding exactly three divisors. At the end of the loop, it checks if count is equal to 3, and returns true if it is, otherwise it returns false.\n\nGiven an integer n, this algorithm will return true if n has exactly three positive divisors, otherwise, it will return false.\n    ",
        "python": "\n    ```python\ndef has_three_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n        if count > 3:\n            break\n    return count == 3\n```\n    \n    The algorithm iterates through every integer i from 1 to the square root of n. For each integer i, it checks if n is divisible by i, indicating that i is a divisor of n. If n is divisible by i, the algorithm further calculates n/i, which is the other divisor. If i and n/i are equal, count is incremented by 1; otherwise, count is incremented by 2, as there are two distinct divisors. If the count goes over 3, the loop is broken since we only care about finding exactly three divisors. At the end of the loop, it checks if count is equal to 3, and returns true if it is, otherwise it returns false.\n\nGiven an integer n, this algorithm will return true if n has exactly three positive divisors, otherwise, it will return false.\n    ",
        "c++": "\n    ```cpp\nbool hasThreeDivisors(int n) {\n    int count = 0;\n    for (int i = 1; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            if (n / i == i)\n                count++;\n            else\n                count += 2;\n        }\n        if (count > 3)\n            break;\n    }\n    return count == 3;\n}\n```\n    \n    The algorithm iterates through every integer i from 1 to the square root of n. For each integer i, it checks if n is divisible by i, indicating that i is a divisor of n. If n is divisible by i, the algorithm further calculates n/i, which is the other divisor. If i and n/i are equal, count is incremented by 1; otherwise, count is incremented by 2, as there are two distinct divisors. If the count goes over 3, the loop is broken since we only care about finding exactly three divisors. At the end of the loop, it checks if count is equal to 3, and returns true if it is, otherwise it returns false.\n\nGiven an integer n, this algorithm will return true if n has exactly three positive divisors, otherwise, it will return false.\n    ",
        "js": "\n    ```javascript\nfunction hasThreeDivisors(n) {\n    let count = 0;\n    for (let i = 1; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            if (n / i === i)\n                count++;\n            else\n                count += 2;\n        }\n        if (count > 3)\n            break;\n    }\n    return count === 3;\n}\n```\n    \n    The algorithm iterates through every integer i from 1 to the square root of n. For each integer i, it checks if n is divisible by i, indicating that i is a divisor of n. If n is divisible by i, the algorithm further calculates n/i, which is the other divisor. If i and n/i are equal, count is incremented by 1; otherwise, count is incremented by 2, as there are two distinct divisors. If the count goes over 3, the loop is broken since we only care about finding exactly three divisors. At the end of the loop, it checks if count is equal to 3, and returns true if it is, otherwise it returns false.\n\nGiven an integer n, this algorithm will return true if n has exactly three positive divisors, otherwise, it will return false.\n    "
    },
    {
        "id": 314,
        "title": "Minimum Cost to Reach City With Discounts",
        "difficulty": "Medium",
        "content": {
            "problem": "A series of highways connect `n` cities numbered from `0` to `n - 1`. You are given a 2D integer array `highways` where `highways[i] = [city1i, city2i, tolli]` indicates that there is a highway that connects `city1i` and `city2i`, allowing a car to go from `city1i` to `city2i` **and vice versa** for a cost of `tolli`.\n\nYou are also given an integer `discounts` which represents the number of discounts you have. You can use a discount to travel across the `ith` highway for a cost of `tolli / 2` (**integer** **division**). Each discount may only be used **once**, and you can only use at most **one** discount per highway.\n\nReturn _the **minimum total cost** to go from city_ `0` _to city_ `n - 1`_, or_ `-1` _if it is not possible to go from city_ `0` _to city_ `n - 1`_._",
            "examples": [
                "**Example 1:**  \n\n**Input:** n = 5, highways = \\[\\[0,1,4\\],\\[2,1,3\\],\\[1,4,11\\],\\[3,2,3\\],\\[3,4,2\\]\\], discounts = 1\n**Output:** 9\n**Explanation:**\nGo from 0 to 1 for a cost of 4.\nGo from 1 to 4 and use a discount for a cost of 11 / 2 = 5.\nThe minimum cost to go from 0 to 4 is 4 + 5 = 9.\n\n",
                "**Example 2:**  \n\n**Input:** n = 4, highways = \\[\\[1,3,17\\],\\[1,2,7\\],\\[3,2,5\\],\\[0,1,6\\],\\[3,0,20\\]\\], discounts = 20\n**Output:** 8\n**Explanation:**\nGo from 0 to 1 and use a discount for a cost of 6 / 2 = 3.\nGo from 1 to 2 and use a discount for a cost of 7 / 2 = 3.\nGo from 2 to 3 and use a discount for a cost of 5 / 2 = 2.\nThe minimum cost to go from 0 to 3 is 3 + 3 + 2 = 8.\n\n",
                "**Example 3:**  \n\n**Input:** n = 4, highways = \\[\\[0,1,3\\],\\[2,3,2\\]\\], discounts = 0\n**Output:** -1\n**Explanation:**\nIt is impossible to go from 0 to 3 so return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= highways.length <= 1000`\n*   `highways[i].length == 3`\n*   `0 <= city1i, city2i <= n - 1`\n*   `city1i != city2i`\n*   `0 <= tolli <= 105`\n*   `0 <= discounts <= 500`\n*   There are no duplicate highways.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]],1",
                "output": "9"
            },
            {
                "input": "4,[[1,3,17],[1,2,7],[3,2,5],[0,1,6],[3,0,20]],20",
                "output": "8"
            },
            {
                "input": "4,[[0,1,3],[2,3,2]],0",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic boolean isPrefixString(String s, String[] words) {\n    StringBuilder sb = new StringBuilder();\n    for (String word : words) {\n        sb.append(word);\n        if (sb.toString().equals(s)) return true;\n        if (sb.length() > s.length()) break;\n    }\n    return false;\n}\n```\n    \n    The algorithm does the following to determine if the given string s is a prefix string of words:\n\n1. Create an empty temporary string (temp).\n2. Iterate through each word in the words array:\n   a. Concatenate the word to the temporary string.\n   b. Check if the temporary string is equal to the given string s. If it is, return true.\n   c. If the length of the temporary string is greater than the length of the given string s, break the loop.\n3. If the loop completes without returning true, return false. This means that the given string s is not a prefix string of words.\n\nThis algorithm has a time complexity of O(n * m) where n is the number of words and m is the length of the longest word in words.\n    ",
        "python": "\n    ```python\ndef is_prefix_string(s, words):\n    temp = \"\"\n    for word in words:\n        temp += word\n        if temp == s:\n            return True\n        if len(temp) > len(s):\n            break\n    return False\n```\n    \n    The algorithm does the following to determine if the given string s is a prefix string of words:\n\n1. Create an empty temporary string (temp).\n2. Iterate through each word in the words array:\n   a. Concatenate the word to the temporary string.\n   b. Check if the temporary string is equal to the given string s. If it is, return true.\n   c. If the length of the temporary string is greater than the length of the given string s, break the loop.\n3. If the loop completes without returning true, return false. This means that the given string s is not a prefix string of words.\n\nThis algorithm has a time complexity of O(n * m) where n is the number of words and m is the length of the longest word in words.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nbool isPrefixString(std::string s, std::vector<std::string>& words) {\n    std::string temp = \"\";\n    for (std::string word : words) {\n        temp += word;\n        if (temp == s) return true;\n        if (temp.size() > s.size()) break;\n    }\n    return false;\n}\n```\n    \n    The algorithm does the following to determine if the given string s is a prefix string of words:\n\n1. Create an empty temporary string (temp).\n2. Iterate through each word in the words array:\n   a. Concatenate the word to the temporary string.\n   b. Check if the temporary string is equal to the given string s. If it is, return true.\n   c. If the length of the temporary string is greater than the length of the given string s, break the loop.\n3. If the loop completes without returning true, return false. This means that the given string s is not a prefix string of words.\n\nThis algorithm has a time complexity of O(n * m) where n is the number of words and m is the length of the longest word in words.\n    ",
        "js": "\n    ```javascript\nfunction isPrefixString(s, words) {\n    let temp = \"\";\n    for (const word of words) {\n        temp += word;\n        if (temp === s) return true;\n        if (temp.length > s.length) break;\n    }\n    return false;\n}\n```\n    \n    The algorithm does the following to determine if the given string s is a prefix string of words:\n\n1. Create an empty temporary string (temp).\n2. Iterate through each word in the words array:\n   a. Concatenate the word to the temporary string.\n   b. Check if the temporary string is equal to the given string s. If it is, return true.\n   c. If the length of the temporary string is greater than the length of the given string s, break the loop.\n3. If the loop completes without returning true, return false. This means that the given string s is not a prefix string of words.\n\nThis algorithm has a time complexity of O(n * m) where n is the number of words and m is the length of the longest word in words.\n    "
    },
    {
        "id": 315,
        "title": "Subsequence of Size K With the Largest Even Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `k`. Find the **largest even sum** of any subsequence of `nums` that has a length of `k`.\n\nReturn _this sum, or_ `-1` _if such a sum does not exist_.\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,1,5,3,1\\], k = 3\n**Output:** 12\n**Explanation:**\nThe subsequence with the largest possible even sum is \\[4,5,3\\]. It has a sum of 4 + 5 + 3 = 12.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,6,2\\], k = 3\n**Output:** 12\n**Explanation:**\nThe subsequence with the largest possible even sum is \\[4,6,2\\]. It has a sum of 4 + 6 + 2 = 12.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,3,5\\], k = 1\n**Output:** -1\n**Explanation:**\nNo subsequence of nums with length 1 has an even sum."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`\n*   `1 <= k <= nums.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,1,5,3,1],3",
                "output": "12"
            },
            {
                "input": "[4,6,2],3",
                "output": "12"
            },
            {
                "input": "[1,3,5],1",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int largestEvenSum(int[] nums, int k) {\n    List<Integer> evens = new ArrayList<>();\n    List<Integer> odds = new ArrayList<>();\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            evens.add(num);\n        } else {\n            odds.add(num);\n        }\n    }\n    evens.sort(Collections.reverseOrder());\n    odds.sort(Collections.reverseOrder());\n\n    int sum = 0;\n    for (int i = 0; i < k && !evens.isEmpty(); i++) {\n        sum += evens.remove(evens.size() - 1);\n    }\n\n    for (int i = 0; i < k - 1 && !odds.isEmpty(); i += 2) {\n        int first = odds.remove(odds.size() - 1);\n        if (!odds.isEmpty()) {\n            int second = odds.remove(odds.size() - 1);\n            sum += first + second;\n        }\n    }\n\n    if (sum % 2 == 0) {\n        return sum;\n    } else {\n        return -1;\n    }\n}\n```\n\n    \n    The algorithm first splits the input numbers into two separate arrays, one for even numbers and one for odd numbers, and then sorts both arrays in decreasing order.\n\nWe take all even numbers until we reach the specified length `k`.\n\nThen, we take pairs of odd numbers from the sorted odd numbers array and add their sums to the total sum. We take pairs of odd numbers because the sum of two odd numbers is always even.\n\nFinally, we check if the sum is even, and if so, we return the sum. If not, we return -1 since no such sum exists for the given constraint.\n    ",
        "python": "\n    ```python\ndef largest_even_sum(nums, k):\n    evens = sorted([num for num in nums if num % 2 == 0], reverse=True)\n    odds = sorted([num for num in nums if num % 2 != 0], reverse=True)\n\n    sum = 0\n    for _ in range(k):\n        if evens:\n            sum += evens.pop()\n\n    for _ in range(0, k - 1, 2):\n        if odds:\n            first = odds.pop()\n            if odds:\n                second = odds.pop()\n                sum += first + second\n\n    return sum if sum % 2 == 0 else -1\n```\n\n    \n    The algorithm first splits the input numbers into two separate arrays, one for even numbers and one for odd numbers, and then sorts both arrays in decreasing order.\n\nWe take all even numbers until we reach the specified length `k`.\n\nThen, we take pairs of odd numbers from the sorted odd numbers array and add their sums to the total sum. We take pairs of odd numbers because the sum of two odd numbers is always even.\n\nFinally, we check if the sum is even, and if so, we return the sum. If not, we return -1 since no such sum exists for the given constraint.\n    ",
        "c++": "\n    ```cpp\nint largestEvenSum(const std::vector<int>& nums, int k) {\n    std::vector<int> evens, odds;\n    for (auto num : nums) {\n        if (num % 2 == 0) {\n            evens.push_back(num);\n        } else {\n            odds.push_back(num);\n        }\n    }\n    sort(evens.rbegin(), evens.rend());\n    sort(odds.rbegin(), odds.rend());\n\n    int sum = 0;\n    for (int i = 0; i < k && !evens.empty(); i++) {\n        sum += evens.back();\n        evens.pop_back();\n    }\n\n    for (int i = 0; i < k - 1 && !odds.empty(); i += 2) {\n        int first = odds.back();\n        odds.pop_back();\n        if (!odds.empty()) {\n            int second = odds.back();\n            odds.pop_back();\n            sum += first + second;\n        }\n    }\n\n    if (sum % 2 == 0) {\n        return sum;\n    } else {\n        return -1;\n    }\n}\n```\n\n    \n    The algorithm first splits the input numbers into two separate arrays, one for even numbers and one for odd numbers, and then sorts both arrays in decreasing order.\n\nWe take all even numbers until we reach the specified length `k`.\n\nThen, we take pairs of odd numbers from the sorted odd numbers array and add their sums to the total sum. We take pairs of odd numbers because the sum of two odd numbers is always even.\n\nFinally, we check if the sum is even, and if so, we return the sum. If not, we return -1 since no such sum exists for the given constraint.\n    ",
        "js": "\n    ```javascript\nfunction largestEvenSum(nums, k) {\n  const evens = nums.filter(num => num % 2 === 0).sort((a, b) => b - a);\n  const odds = nums.filter(num => num % 2 !== 0).sort((a, b) => b - a);\n\n  let sum = 0;\n  for (let i = 0; i < k && evens.length > 0; i++) {\n    sum += evens.pop();\n  }\n\n  for (let i = 0; i < k - 1 && odds.length > 0; i += 2) {\n    let first = odds.pop();\n    if (odds.length > 0) {\n      let second = odds.pop();\n      sum += first + second;\n    }\n  }\n\n  return sum % 2 === 0 ? sum : -1;\n}\n```\n\n    \n    The algorithm first splits the input numbers into two separate arrays, one for even numbers and one for odd numbers, and then sorts both arrays in decreasing order.\n\nWe take all even numbers until we reach the specified length `k`.\n\nThen, we take pairs of odd numbers from the sorted odd numbers array and add their sums to the total sum. We take pairs of odd numbers because the sum of two odd numbers is always even.\n\nFinally, we check if the sum is even, and if so, we return the sum. If not, we return -1 since no such sum exists for the given constraint.\n    "
    },
    {
        "id": 316,
        "title": "Number of Unique Flavors After Sharing K Candies",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `candies`, where `candies[i]` represents the flavor of the `ith` candy. Your mom wants you to share these candies with your little sister by giving her `k` **consecutive** candies, but you want to keep as many flavors of candies as possible.\n\nReturn _the **maximum** number of **unique** flavors of candy you can keep after sharing_ _with your sister._",
            "examples": [
                "**Example 1:**\n\n**Input:** candies = \\[1,2,2,3,4,3\\], k = 3\n**Output:** 3\n**Explanation:** \nGive the candies in the range \\[1, 3\\] (inclusive) with flavors \\[2,2,3\\].\nYou can eat candies with flavors \\[1,4,3\\].\nThere are 3 unique flavors, so return 3.\n\n",
                "**Example 2:**\n\n**Input:** candies = \\[2,2,2,2,3,3\\], k = 2\n**Output:** 2\n**Explanation:** \nGive the candies in the range \\[3, 4\\] (inclusive) with flavors \\[2,3\\].\nYou can eat candies with flavors \\[2,2,2,3\\].\nThere are 2 unique flavors, so return 2.\nNote that you can also share the candies with flavors \\[2,2\\] and eat the candies with flavors \\[2,2,3,3\\].\n\n",
                "**Example 3:**\n\n**Input:** candies = \\[2,4,5\\], k = 0\n**Output:** 3\n**Explanation:** \nYou do not have to give any candies.\nYou can eat the candies with flavors \\[2,4,5\\].\nThere are 3 unique flavors, so return 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= candies.length <= 105`\n*   `1 <= candies[i] <= 105`\n*   `0 <= k <= candies.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,2,3,4,3],3",
                "output": "3"
            },
            {
                "input": "[2,2,2,2,3,3],2",
                "output": "2"
            },
            {
                "input": "[2,4,5],0",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic String findDifferentBinaryString(String[] nums) {\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < nums.length; i++) {\n        result.append(nums[i].charAt(i) == '0' ? '1' : '0');\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm iterates through the array of strings `nums` and creates a new binary string `result` by following this rule for each character at position i: if the character in the original string at position i is '0', add '1' to the result; otherwise, add '0'. This way, the resulting string will differ from every binary string in the input array in at least one position.\n    ",
        "python": "\n    ```python\ndef find_different_binary_string(nums):\n    return \"\".join(\"1\" if nums[i][i] == \"0\" else \"0\" for i in range(len(nums)))\n```\n    \n    The algorithm iterates through the array of strings `nums` and creates a new binary string `result` by following this rule for each character at position i: if the character in the original string at position i is '0', add '1' to the result; otherwise, add '0'. This way, the resulting string will differ from every binary string in the input array in at least one position.\n    ",
        "c++": "\n    ```cpp\nstd::string findDifferentBinaryString(std::vector<std::string>& nums) {\n    std::string result;\n    for (int i = 0; i < nums.size(); i++) {\n        result.push_back(nums[i][i] == '0' ? '1' : '0');\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the array of strings `nums` and creates a new binary string `result` by following this rule for each character at position i: if the character in the original string at position i is '0', add '1' to the result; otherwise, add '0'. This way, the resulting string will differ from every binary string in the input array in at least one position.\n    ",
        "js": "\n    ```javascript\nfunction findDifferentBinaryString(nums) {\n    let result = \"\";\n    for (let i = 0; i < nums.length; i++) {\n        result += nums[i][i] === '0' ? '1' : '0';\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the array of strings `nums` and creates a new binary string `result` by following this rule for each character at position i: if the character in the original string at position i is '0', add '1' to the result; otherwise, add '0'. This way, the resulting string will differ from every binary string in the input array in at least one position.\n    "
    },
    {
        "id": 317,
        "title": "Elements in Array After Removing and Replacing Elements",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. Initially on minute `0`, the array is unchanged. Every minute, the **leftmost** element in `nums` is removed until no elements remain. Then, every minute, one element is appended to the **end** of `nums`, in the order they were removed in, until the original array is restored. This process repeats indefinitely.\n\n*   For example, the array `[0,1,2]` would change as follows: `[0,1,2] -> [1,2] -> [2] -> [] -> [0] -> [0,1] -> [0,1,2] -> [1,2] -> [2] -> [] -> [0] -> [0,1] -> [0,1,2] -> ...`\n\nYou are also given a 2D integer array `queries` of size `n` where `queries[j] = [timej, indexj]`. The answer to the `jth` query is:\n\n*   `nums[indexj]` if `indexj < nums.length` at minute `timej`\n*   `-1` if `indexj >= nums.length` at minute `timej`\n\nReturn _an integer array `ans` of size_ `n` _where_ `ans[j]` _is the answer to the_ `jth` _query_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2\\], queries = \\[\\[0,2\\],\\[2,0\\],\\[3,2\\],\\[5,0\\]\\]\n**Output:** \\[2,2,-1,0\\]\n**Explanation:**\nMinute 0: \\[0,1,2\\] - All elements are in the nums.\nMinute 1: \\[1,2\\]   - The leftmost element, 0, is removed.\nMinute 2: \\[2\\]     - The leftmost element, 1, is removed.\nMinute 3: \\[\\]      - The leftmost element, 2, is removed.\nMinute 4: \\[0\\]     - 0 is added to the end of nums.\nMinute 5: \\[0,1\\]   - 1 is added to the end of nums.\n\nAt minute 0, nums\\[2\\] is 2.\nAt minute 2, nums\\[0\\] is 2.\nAt minute 3, nums\\[2\\] does not exist.\nAt minute 5, nums\\[0\\] is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2\\], queries = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\],\\[3,0\\]\\]\n**Output:** \\[2,-1,2,-1\\]\nMinute 0: \\[2\\] - All elements are in the nums.\nMinute 1: \\[\\]  - The leftmost element, 2, is removed.\nMinute 2: \\[2\\] - 2 is added to the end of nums.\nMinute 3: \\[\\]  - The leftmost element, 2, is removed.\n\nAt minute 0, nums\\[0\\] is 2.\nAt minute 1, nums\\[0\\] does not exist.\nAt minute 2, nums\\[0\\] is 2.\nAt minute 3, nums\\[0\\] does not exist."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`\n*   `n == queries.length`\n*   `1 <= n <= 105`\n*   `queries[j].length == 2`\n*   `0 <= timej <= 105`\n*   `0 <= indexj < nums.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,2],[[0,2],[2,0],[3,2],[5,0]]",
                "output": "[2,2,-1,0]"
            },
            {
                "input": "[2],[[0,0],[1,0],[2,0],[3,0]]",
                "output": "[2,-1,2,-1]\nMinute0:[2]-Allelementsareinthenums.\nMinute1:[]-Theleftmostelement,2,isremoved.\nMinute2:[2]-2isaddedtotheendofnums.\nMinute3:[]-Theleftmostelement,2,isremoved.\n\nAtminute0,nums[0]is2.\nAtminute1,nums[0]doesnotexist.\nAtminute2,nums[0]is2.\nAtminute3,nums[0]doesnotexist."
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic String kthLargestNumber(String[] nums, int k) {\n    Arrays.sort(nums, (a, b) -> {\n        if (a.length() == b.length()) return a.compareTo(b);\n        return a.length() - b.length();\n    });\n    return nums[nums.length - k];\n}\n```\n    \n    1. Sort the given nums array of strings based on their lengths (i.e., based on the number of digits). If the lengths are equal, sort the strings lexicographically.\n2. Return the element at index (length - k), as it represents the kth largest number in the sorted array.\n    ",
        "python": "\n    ```python\ndef kthLargestNumber(nums, k):\n    nums.sort(key=lambda x: (len(x), x))\n    return nums[-k]\n```\n    \n    1. Sort the given nums array of strings based on their lengths (i.e., based on the number of digits). If the lengths are equal, sort the strings lexicographically.\n2. Return the element at index (length - k), as it represents the kth largest number in the sorted array.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n#include <vector>\n\nstd::string kthLargestNumber(std::vector<std::string> &nums, int k) {\n    std::sort(nums.begin(), nums.end(), [](const std::string &a, const std::string &b) {\n        if (a.size() == b.size()) return a < b;\n        return a.size() < b.size();\n    });\n    return nums[nums.size() - k];\n}\n```\n    \n    1. Sort the given nums array of strings based on their lengths (i.e., based on the number of digits). If the lengths are equal, sort the strings lexicographically.\n2. Return the element at index (length - k), as it represents the kth largest number in the sorted array.\n    ",
        "js": "\n    ```javascript\nfunction kthLargestNumber(nums, k) {\n    nums.sort((a, b) => {\n        if (a.length == b.length) return a.localeCompare(b);\n        return a.length - b.length;\n    });\n    return nums[nums.length - k];\n}\n```\n    \n    1. Sort the given nums array of strings based on their lengths (i.e., based on the number of digits). If the lengths are equal, sort the strings lexicographically.\n2. Return the element at index (length - k), as it represents the kth largest number in the sorted array.\n    "
    },
    {
        "id": 318,
        "title": "Minimum Operations to Remove Adjacent Ones in Matrix",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** binary matrix `grid`. In one operation, you can flip any `1` in `grid` to be `0`.\n\nA binary matrix is **well-isolated** if there is no `1` in the matrix that is **4-directionally connected** (i.e., horizontal and vertical) to another `1`.\n\nReturn _the minimum number of operations to make_ `grid` _**well-isolated**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,0\\],\\[0,1,1\\],\\[1,1,1\\]\\]\n**Output:** 3\n**Explanation:** Use 3 operations to change grid\\[0\\]\\[1\\], grid\\[1\\]\\[2\\], and grid\\[2\\]\\[1\\] to 0.\nAfter, no more 1's are 4-directionally connected and grid is well-isolated.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** 0\n**Explanation:** There are no 1's in grid and it is well-isolated.\nNo operations were done so return 0.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 0\n**Explanation:** None of the 1's are 4-directionally connected and grid is well-isolated.\nNo operations were done so return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,0],[0,1,1],[1,1,1]]",
                "output": "3"
            },
            {
                "input": "[[0,0,0],[0,0,0],[0,0,0]]",
                "output": "0"
            },
            {
                "input": "[[0,1],[1,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int numberOfWeakCharacters(int[][] properties) {\n    Arrays.sort(properties, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n    \n    int maxDefense = 0, weakCount = 0;\n    for (int i = properties.length - 1; i >= 0; i--) {\n        if (properties[i][1] < maxDefense) {\n            weakCount++;\n        } else {\n            maxDefense = properties[i][1];\n        }\n    }\n    \n    return weakCount;\n}\n```\n    \n    1. Sort the properties array based on attack values in ascending order. If there's a tie between attack values, then sort based on defense values in descending order.\n2. Initialize two variables, `maxDefense` and `weakCount` to 0.\n3. Iterate through the sorted properties array in reverse order.\n   - If the defense value of the current character is less than the `maxDefense`, increment the `weakCount`.\n   - Else, update the `maxDefense` to the defense value of the current character.\n4. Return the `weakCount`.\n\nThe reason behind sorting attack values in ascending order and defense values in descending order is to process characters with higher attack values first. Doing so helps us maintain the maximum defense value found so far from characters of higher attack value, hence, allowing us to identify weak characters easily.\n    ",
        "python": "\n    ```python\ndef numberOfWeakCharacters(properties):\n    properties.sort(key=lambda x: (x[0], -x[1]))\n    \n    max_defense = 0\n    weak_count = 0\n    for attack, defense in reversed(properties):\n        if defense < max_defense:\n            weak_count += 1\n        else:\n            max_defense = defense\n            \n    return weak_count\n```\n    \n    1. Sort the properties array based on attack values in ascending order. If there's a tie between attack values, then sort based on defense values in descending order.\n2. Initialize two variables, `maxDefense` and `weakCount` to 0.\n3. Iterate through the sorted properties array in reverse order.\n   - If the defense value of the current character is less than the `maxDefense`, increment the `weakCount`.\n   - Else, update the `maxDefense` to the defense value of the current character.\n4. Return the `weakCount`.\n\nThe reason behind sorting attack values in ascending order and defense values in descending order is to process characters with higher attack values first. Doing so helps us maintain the maximum defense value found so far from characters of higher attack value, hence, allowing us to identify weak characters easily.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint numberOfWeakCharacters(std::vector<std::vector<int>>& properties) {\n    std::sort(properties.begin(), properties.end(), [](const auto& a, const auto& b) {\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n    \n    int maxDefense = 0, weakCount = 0;\n    for (int i = properties.size() - 1; i >= 0; --i) {\n        if (properties[i][1] < maxDefense) {\n            weakCount++;\n        } else {\n            maxDefense = properties[i][1];\n        }\n    }\n    \n    return weakCount;\n}\n```\n    \n    1. Sort the properties array based on attack values in ascending order. If there's a tie between attack values, then sort based on defense values in descending order.\n2. Initialize two variables, `maxDefense` and `weakCount` to 0.\n3. Iterate through the sorted properties array in reverse order.\n   - If the defense value of the current character is less than the `maxDefense`, increment the `weakCount`.\n   - Else, update the `maxDefense` to the defense value of the current character.\n4. Return the `weakCount`.\n\nThe reason behind sorting attack values in ascending order and defense values in descending order is to process characters with higher attack values first. Doing so helps us maintain the maximum defense value found so far from characters of higher attack value, hence, allowing us to identify weak characters easily.\n    ",
        "js": "\n    ```javascript\nfunction numberOfWeakCharacters(properties) {\n    properties.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\n    \n    let maxDefense = 0, weakCount = 0;\n    for (let i = properties.length - 1; i >= 0; i--) {\n        if (properties[i][1] < maxDefense) {\n            weakCount++;\n        } else {\n            maxDefense = properties[i][1];\n        }\n    }\n    \n    return weakCount;\n}\n```\n    \n    1. Sort the properties array based on attack values in ascending order. If there's a tie between attack values, then sort based on defense values in descending order.\n2. Initialize two variables, `maxDefense` and `weakCount` to 0.\n3. Iterate through the sorted properties array in reverse order.\n   - If the defense value of the current character is less than the `maxDefense`, increment the `weakCount`.\n   - Else, update the `maxDefense` to the defense value of the current character.\n4. Return the `weakCount`.\n\nThe reason behind sorting attack values in ascending order and defense values in descending order is to process characters with higher attack values first. Doing so helps us maintain the maximum defense value found so far from characters of higher attack value, hence, allowing us to identify weak characters easily.\n    "
    },
    {
        "id": 319,
        "title": "Check if All A's Appears Before All B's",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` consisting of **only** the characters `'a'` and `'b'`, return `true` _if **every**_ `'a'` _appears before **every**_ `'b'` _in the string_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaabbb \"\n**Output:** true\n**Explanation:**\nThe 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5.\nHence, every 'a' appears before every 'b' and we return true.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abab \"\n**Output:** false\n**Explanation:**\nThere is an 'a' at index 2 and a 'b' at index 1.\nHence, not every 'a' appears before every 'b' and we return false.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"bbb \"\n**Output:** true\n**Explanation:**\nThere are no 'a's, hence, every 'a' appears before every 'b' and we return true."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s[i]` is either `'a'` or `'b'`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aaabbb\"",
                "output": "true"
            },
            {
                "input": "\"abab\"",
                "output": "false"
            },
            {
                "input": "\"bbb\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic int firstDayBeenInAllRooms(int[] nextVisit) {\n    int n = nextVisit.length;\n    long ans = 0, MOD = 1000000007;\n    long[] dp = new long[n];\n\n    for (int i = 1; i < n; ++i) {\n        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD;\n        ans = (ans + dp[i]) % MOD;\n    }\n    return (int) ans;\n}\n```\n    \n    We can solve this problem using dynamic programming. We create an array `dp` of size n and initialize it with 0's. The `dp[i]` should represent the number of days it takes to go from room i to room i+1.\n\nStarting from the second room (i=1), we loop through all rooms and update each `dp[i]` value. To calculate dp[i], we need to perform a cumulative summation of the days it has taken to visit the previous room (dp[i - 1]) plus 1 extra day (day i) and subtract the value at the index stored in nextVisit for the previous room (dp[nextVisit[i - 1]]).\n\nFinally, we add the calculated value modulo 10^9 + 7 to the answer `ans`. Once we exit the loop, we return `ans` as the result.\n    ",
        "python": "\n    ```python\ndef firstDayBeenInAllRooms(nextVisit):\n    n = len(nextVisit)\n    ans = 0\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD\n        ans = (ans + dp[i]) % MOD\n    return ans\n```\n    \n    We can solve this problem using dynamic programming. We create an array `dp` of size n and initialize it with 0's. The `dp[i]` should represent the number of days it takes to go from room i to room i+1.\n\nStarting from the second room (i=1), we loop through all rooms and update each `dp[i]` value. To calculate dp[i], we need to perform a cumulative summation of the days it has taken to visit the previous room (dp[i - 1]) plus 1 extra day (day i) and subtract the value at the index stored in nextVisit for the previous room (dp[nextVisit[i - 1]]).\n\nFinally, we add the calculated value modulo 10^9 + 7 to the answer `ans`. Once we exit the loop, we return `ans` as the result.\n    ",
        "c++": "\n    ```cpp\nint firstDayBeenInAllRooms(vector<int>& nextVisit) {\n    int n = nextVisit.size();\n    long long ans = 0, MOD = 1e9 + 7;\n    vector<long long> dp(n, 0);\n\n    for (int i = 1; i < n; ++i) {\n        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD;\n        ans = (ans + dp[i]) % MOD;\n    }\n    return ans;\n}\n```\n    \n    We can solve this problem using dynamic programming. We create an array `dp` of size n and initialize it with 0's. The `dp[i]` should represent the number of days it takes to go from room i to room i+1.\n\nStarting from the second room (i=1), we loop through all rooms and update each `dp[i]` value. To calculate dp[i], we need to perform a cumulative summation of the days it has taken to visit the previous room (dp[i - 1]) plus 1 extra day (day i) and subtract the value at the index stored in nextVisit for the previous room (dp[nextVisit[i - 1]]).\n\nFinally, we add the calculated value modulo 10^9 + 7 to the answer `ans`. Once we exit the loop, we return `ans` as the result.\n    ",
        "js": "\n    ```javascript\nfunction firstDayBeenInAllRooms(nextVisit) {\n    const n = nextVisit.length;\n    let ans = 0, MOD = 1e9 + 7;\n    const dp = Array(n).fill(0);\n\n    for (let i = 1; i < n; ++i) {\n        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD;\n        ans = (ans + dp[i]) % MOD;\n    }\n    return ans;\n};\n```\n    \n    We can solve this problem using dynamic programming. We create an array `dp` of size n and initialize it with 0's. The `dp[i]` should represent the number of days it takes to go from room i to room i+1.\n\nStarting from the second room (i=1), we loop through all rooms and update each `dp[i]` value. To calculate dp[i], we need to perform a cumulative summation of the days it has taken to visit the previous room (dp[i - 1]) plus 1 extra day (day i) and subtract the value at the index stored in nextVisit for the previous room (dp[nextVisit[i - 1]]).\n\nFinally, we add the calculated value modulo 10^9 + 7 to the answer `ans`. Once we exit the loop, we return `ans` as the result.\n    "
    },
    {
        "id": 320,
        "title": "Remove All Ones With Row and Column Flips",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` binary matrix `grid`.\n\nIn one operation, you can choose **any** row or column and flip each value in that row or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\nReturn `true` _if it is possible to remove all_ `1`_'s from_ `grid` using **any** number of operations or `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0\\],\\[1,0,1\\],\\[0,1,0\\]\\]\n**Output:** true\n**Explanation:** One possible way to remove all 1's from grid is to:\n- Flip the middle row\n- Flip the middle column\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** false\n**Explanation:** It is impossible to remove all 1's from grid.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[0\\]\\]\n**Output:** true\n**Explanation:** There are no 1's in grid."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1,0],[1,0,1],[0,1,0]]",
                "output": "true"
            },
            {
                "input": "[[1,1,0],[0,0,0],[0,0,0]]",
                "output": "false"
            },
            {
                "input": "[[0]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic String reversePrefix(String word, char ch) {\n    int index = word.indexOf(ch);\n    if (index != -1) {\n        StringBuilder sb = new StringBuilder(word.substring(0, index + 1));\n        sb.reverse();\n        sb.append(word.substring(index + 1));\n        return sb.toString();\n    }\n    return word;\n}\n```\n    \n    1. Find the index of the first occurrence of character `ch` in the given string `word`. If the character is not found, return the original string as it is.\n2. If the character exists, reverse the substring starting from index 0 to this found index (inclusive).\n3. Append the rest of the string after the reversed substring (if any).\n4. Return the modified string as the result.\n    ",
        "python": "\n    ```python\ndef reverse_prefix(word: str, ch: str) -> str:\n    try:\n        index = word.index(ch)\n        return word[:index+1][::-1] + word[index+1:]\n    except ValueError:\n        return word\n```\n    \n    1. Find the index of the first occurrence of character `ch` in the given string `word`. If the character is not found, return the original string as it is.\n2. If the character exists, reverse the substring starting from index 0 to this found index (inclusive).\n3. Append the rest of the string after the reversed substring (if any).\n4. Return the modified string as the result.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nstd::string reversePrefix(std::string word, char ch) {\n    auto it = std::find(word.begin(), word.end(), ch);\n    if (it != word.end()) {\n        std::reverse(word.begin(), it + 1);\n    }\n    return word;\n}\n```\n    \n    1. Find the index of the first occurrence of character `ch` in the given string `word`. If the character is not found, return the original string as it is.\n2. If the character exists, reverse the substring starting from index 0 to this found index (inclusive).\n3. Append the rest of the string after the reversed substring (if any).\n4. Return the modified string as the result.\n    ",
        "js": "\n    ```javascript\nfunction reversePrefix(word, ch) {\n    const index = word.indexOf(ch);\n    if (index !== -1) {\n        return word.slice(0, index + 1).split('').reverse().join('') + word.slice(index + 1);\n    }\n    return word;\n}\n```\n    \n    1. Find the index of the first occurrence of character `ch` in the given string `word`. If the character is not found, return the original string as it is.\n2. If the character exists, reverse the substring starting from index 0 to this found index (inclusive).\n3. Append the rest of the string after the reversed substring (if any).\n4. Return the modified string as the result.\n    "
    },
    {
        "id": 321,
        "title": "Minimum Swaps to Group All 1's Together II",
        "difficulty": "Medium",
        "content": {
            "problem": "A **swap** is defined as taking two **distinct** positions in an array and swapping the values in them.\n\nA **circular** array is defined as an array where we consider the **first** element and the **last** element to be **adjacent**.\n\nGiven a **binary** **circular** array `nums`, return _the minimum number of swaps required to group all_ `1`_'s present in the array together at **any location**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,0,1,1,0,0\\]\n**Output:** 1\n**Explanation:** Here are a few of the ways to group all the 1's together:\n\\[0,0,1,1,1,0,0\\] using 1 swap.\n\\[0,1,1,1,0,0,0\\] using 1 swap.\n\\[1,1,0,0,0,0,1\\] using 2 swaps (using the circular property of the array).\nThere is no way to group all 1's together with 0 swaps.\nThus, the minimum number of swaps required is 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,1,1,0,0,1,1,0\\]\n**Output:** 2\n**Explanation:** Here are a few of the ways to group all the 1's together:\n\\[1,1,1,0,0,0,0,1,1\\] using 2 swaps (using the circular property of the array).\n\\[1,1,1,1,1,0,0,0,0\\] using 2 swaps.\nThere is no way to group all 1's together with 0 or 1 swaps.\nThus, the minimum number of swaps required is 2.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,0,0,1\\]\n**Output:** 0\n**Explanation:** All the 1's are already grouped together due to the circular property of the array.\nThus, the minimum number of swaps required is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[0,1,0,1,1,0,0]",
                "output": "1"
            },
            {
                "input": "[0,1,1,1,0,0,1,1,0]",
                "output": "2"
            },
            {
                "input": "[1,1,0,0,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxConsecutiveAnswers(String answerKey, int k) {\n    int n = answerKey.length();\n    int start = 0, maxLen = 0, maxCount = 0;\n    int[] count = new int[2];\n\n    for (int end = 0; end < n; end++) {\n        maxCount = Math.max(maxCount, ++count[answerKey.charAt(end) == 'T' ? 1 : 0]);\n\n        if (end - start + 1 - maxCount > k) {\n            count[answerKey.charAt(start) == 'T' ? 1 : 0]--;\n            start++;\n        }\n\n        maxLen = Math.max(maxLen, end - start + 1);\n    }\n\n    return maxLen;\n}\n```\n    \n    The algorithm uses a sliding window approach. We start with the left pointer `start` and the right pointer `end`, initially at position 0. For each element in the `answerKey`, we update the maximum count of consecutive 'T's or 'F's using the `count` dictionary. Then, we check if the current window size `(end - start + 1)` minus the maximum count of consecutive 'T's or 'F's is greater than `k`. If it is, we need to shrink the window from the left side by moving the `start` pointer to the right, adjusting the count for the removed character. Finally, we update the max length of consecutive 'T's or 'F's found so far using `maxLen`. When the loop is done, we return `maxLen`.\n\nThis algorithm ensures that we cost only O(n) time complexity as we process each character in the `answerKey` only once.\n    ",
        "python": "\n    ```python\ndef max_consecutive_answers(answer_key: str, k: int) -> int:\n    n = len(answer_key)\n    start, max_len, max_count = 0, 0, 0\n    count = {'T': 0, 'F': 0}\n\n    for end in range(n):\n        max_count = max(max_count, count.__setitem__(answer_key[end], count[answer_key[end]] + 1))\n\n        if end - start + 1 - max_count > k:\n            count[answer_key[start]] -= 1\n            start += 1\n\n        max_len = max(max_len, end - start + 1)\n\n    return max_len\n```\n    \n    The algorithm uses a sliding window approach. We start with the left pointer `start` and the right pointer `end`, initially at position 0. For each element in the `answerKey`, we update the maximum count of consecutive 'T's or 'F's using the `count` dictionary. Then, we check if the current window size `(end - start + 1)` minus the maximum count of consecutive 'T's or 'F's is greater than `k`. If it is, we need to shrink the window from the left side by moving the `start` pointer to the right, adjusting the count for the removed character. Finally, we update the max length of consecutive 'T's or 'F's found so far using `maxLen`. When the loop is done, we return `maxLen`.\n\nThis algorithm ensures that we cost only O(n) time complexity as we process each character in the `answerKey` only once.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nint maxConsecutiveAnswers(string answerKey, int k) {\n    int n = answerKey.size();\n    int start = 0, maxLen = 0, maxCount = 0;\n    vector<int> count(2, 0);\n\n    for (int end = 0; end < n; ++end) {\n        maxCount = max(maxCount, ++count[answerKey[end] == 'T']);\n\n        if (end - start + 1 - maxCount > k) {\n            count[answerKey[start] == 'T']--;\n            start++;\n        }\n\n        maxLen = max(maxLen, end - start + 1);\n    }\n\n    return maxLen;\n}\n```\n    \n    The algorithm uses a sliding window approach. We start with the left pointer `start` and the right pointer `end`, initially at position 0. For each element in the `answerKey`, we update the maximum count of consecutive 'T's or 'F's using the `count` dictionary. Then, we check if the current window size `(end - start + 1)` minus the maximum count of consecutive 'T's or 'F's is greater than `k`. If it is, we need to shrink the window from the left side by moving the `start` pointer to the right, adjusting the count for the removed character. Finally, we update the max length of consecutive 'T's or 'F's found so far using `maxLen`. When the loop is done, we return `maxLen`.\n\nThis algorithm ensures that we cost only O(n) time complexity as we process each character in the `answerKey` only once.\n    ",
        "js": "\n    ```javascript\nfunction maxConsecutiveAnswers(answerKey, k) {\n    const n = answerKey.length;\n    let start = 0, maxLen = 0, maxCount = 0;\n    let count = {'T': 0, 'F': 0};\n\n    for (let end = 0; end < n; end++) {\n        maxCount = Math.max(maxCount, count[answerKey[end]] += 1);\n\n        if (end - start + 1 - maxCount > k) {\n            count[answerKey[start]] -= 1;\n            start++;\n        }\n\n        maxLen = Math.max(maxLen, end - start + 1);\n    }\n\n    return maxLen;\n}\n```\n    \n    The algorithm uses a sliding window approach. We start with the left pointer `start` and the right pointer `end`, initially at position 0. For each element in the `answerKey`, we update the maximum count of consecutive 'T's or 'F's using the `count` dictionary. Then, we check if the current window size `(end - start + 1)` minus the maximum count of consecutive 'T's or 'F's is greater than `k`. If it is, we need to shrink the window from the left side by moving the `start` pointer to the right, adjusting the count for the removed character. Finally, we update the max length of consecutive 'T's or 'F's found so far using `maxLen`. When the loop is done, we return `maxLen`.\n\nThis algorithm ensures that we cost only O(n) time complexity as we process each character in the `answerKey` only once.\n    "
    },
    {
        "id": 322,
        "title": "Pour Water Between Buckets to Make Water Levels Equal",
        "difficulty": "Medium",
        "content": {
            "problem": "You have `n` buckets each containing some gallons of water in it, represented by a **0-indexed** integer array `buckets`, where the `ith` bucket contains `buckets[i]` gallons of water. You are also given an integer `loss`.\n\nYou want to make the amount of water in each bucket equal. You can pour any amount of water from one bucket to another bucket (not necessarily an integer). However, every time you pour `k` gallons of water, you spill `loss` **percent** of `k`.\n\nReturn _the **maximum** amount of water in each bucket after making the amount of water equal._ Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** buckets = \\[1,2,7\\], loss = 80\n**Output:** 2.00000\n**Explanation:** Pour 5 gallons of water from buckets\\[2\\] to buckets\\[0\\].\n5 \\* 80% = 4 gallons are spilled and buckets\\[0\\] only receives 5 - 4 = 1 gallon of water.\nAll buckets have 2 gallons of water in them so return 2.\n\n",
                "**Example 2:**\n\n**Input:** buckets = \\[2,4,6\\], loss = 50\n**Output:** 3.50000\n**Explanation:** Pour 0.5 gallons of water from buckets\\[1\\] to buckets\\[0\\].\n0.5 \\* 50% = 0.25 gallons are spilled and buckets\\[0\\] only receives 0.5 - 0.25 = 0.25 gallons of water.\nNow, buckets = \\[2.25, 3.5, 6\\].\nPour 2.5 gallons of water from buckets\\[2\\] to buckets\\[0\\].\n2.5 \\* 50% = 1.25 gallons are spilled and buckets\\[0\\] only receives 2.5 - 1.25 = 1.25 gallons of water.\nAll buckets have 3.5 gallons of water in them so return 3.5.\n\n",
                "**Example 3:**\n\n**Input:** buckets = \\[3,3,3,3\\], loss = 40\n**Output:** 3.00000\n**Explanation:** All buckets already have the same amount of water in them."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= buckets.length <= 105`\n*   `0 <= buckets[i] <= 105`\n*   `0 <= loss <= 99`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,7],80",
                "output": "2.00000"
            },
            {
                "input": "[2,4,6],50",
                "output": "3.50000"
            },
            {
                "input": "[3,3,3,3],40",
                "output": "3.00000"
            }
        ],
        "java": "\n    ```java\npublic int performOperations(String[] operations) {\n    int X = 0;\n    for (String op : operations) {\n        if (op.equals(\"++X\") || op.equals(\"X++\")) {\n            X++;\n        } else if (op.equals(\"--X\") || op.equals(\"X--\")) {\n            X--;\n        }\n    }\n    return X;\n}\n```\n    \n    We initialize the variable `X` to 0. Then, we loop through the given list of operations. If an operation is either \"++X\" or \"X++\", we increment the value of `X`. If an operation is either \"--X\" or \"X--\", we decrement the value of `X`. At the end of the loop, we return the final value of `X`. The implementation in each language is very similar, with only small differences in syntax.\n    ",
        "python": "\n    ```python\ndef perform_operations(operations):\n    X = 0\n    for op in operations:\n        if op == \"++X\" or op == \"X++\":\n            X += 1\n        elif op == \"--X\" or op == \"X--\":\n            X -= 1\n    return X\n```\n    \n    We initialize the variable `X` to 0. Then, we loop through the given list of operations. If an operation is either \"++X\" or \"X++\", we increment the value of `X`. If an operation is either \"--X\" or \"X--\", we decrement the value of `X`. At the end of the loop, we return the final value of `X`. The implementation in each language is very similar, with only small differences in syntax.\n    ",
        "c++": "\n    ```cpp\nint performOperations(vector<string>& operations) {\n    int X = 0;\n    for (auto& op : operations) {\n        if (op == \"++X\" || op == \"X++\") {\n            X++;\n        } else if (op == \"--X\" || op == \"X--\") {\n            X--;\n        }\n    }\n    return X;\n}\n```\n    \n    We initialize the variable `X` to 0. Then, we loop through the given list of operations. If an operation is either \"++X\" or \"X++\", we increment the value of `X`. If an operation is either \"--X\" or \"X--\", we decrement the value of `X`. At the end of the loop, we return the final value of `X`. The implementation in each language is very similar, with only small differences in syntax.\n    ",
        "js": "\n    ```javascript\nfunction performOperations(operations) {\n    let X = 0;\n    for (let op of operations) {\n        if (op === \"++X\" || op === \"X++\") {\n            X++;\n        } else if (op === \"--X\" || op === \"X--\") {\n            X--;\n        }\n    }\n    return X;\n}\n```\n    \n    We initialize the variable `X` to 0. Then, we loop through the given list of operations. If an operation is either \"++X\" or \"X++\", we increment the value of `X`. If an operation is either \"--X\" or \"X--\", we decrement the value of `X`. At the end of the loop, we return the final value of `X`. The implementation in each language is very similar, with only small differences in syntax.\n    "
    },
    {
        "id": 323,
        "title": "Choose Numbers From Two Arrays in Range",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `nums1` and `nums2` of length `n`.\n\nA range `[l, r]` (**inclusive**) where `0 <= l <= r < n` is **balanced** if:\n\n*   For every `i` in the range `[l, r]`, you pick either `nums1[i]` or `nums2[i]`.\n*   The sum of the numbers you pick from `nums1` equals to the sum of the numbers you pick from `nums2` (the sum is considered to be `0` if you pick no numbers from an array).\n\nTwo **balanced** ranges from `[l1, r1]` and `[l2, r2]` are considered to be **different** if at least one of the following is true:\n\n*   `l1 != l2`\n*   `r1 != r2`\n*   `nums1[i]` is picked in the first range, and `nums2[i]` is picked in the second range or **vice versa** for at least one `i`.\n\nReturn _the number of **different** ranges that are balanced._ Since the answer may be very large, return it **modulo** `109 + 7`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,5\\], nums2 = \\[2,6,3\\]\n**Output:** 3\n**Explanation:** The balanced ranges are:\n- \\[0, 1\\] where we choose nums2\\[0\\], and nums1\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 2 = 2.\n- \\[0, 2\\] where we choose nums1\\[0\\], nums2\\[1\\], and nums1\\[2\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 1 + 5 = 6.\n- \\[0, 2\\] where we choose nums1\\[0\\], nums1\\[1\\], and nums2\\[2\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 1 + 2 = 3.\nNote that the second and third balanced ranges are different.\nIn the second balanced range, we choose nums2\\[1\\] and in the third balanced range, we choose nums1\\[1\\].\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[0,1\\], nums2 = \\[1,0\\]\n**Output:** 4\n**Explanation:** The balanced ranges are:\n- \\[0, 0\\] where we choose nums1\\[0\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 0 = 0.\n- \\[1, 1\\] where we choose nums2\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 0 = 0.\n- \\[0, 1\\] where we choose nums1\\[0\\] and nums2\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 0 = 0.\n- \\[0, 1\\] where we choose nums2\\[0\\] and nums1\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 1 = 1."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 100`\n*   `0 <= nums1[i], nums2[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,2,5],[2,6,3]",
                "output": "3"
            },
            {
                "input": "[0,1],[1,0]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int numberOfBalancedRanges(int[] nums1, int[] nums2) {\n    \n    int n = nums1.length;\n    int[][][][] dp = new int[n][n][n][3];\n    dp[0][0][0][0] = 2;\n    int[] sums1 = new int[n + 1], sums2 = new int[n + 1];\n    for (int i = 0, s1 = 0, s2 = 0; i < nums1.length; i++) {\n        s1 += nums1[i];\n        s2 += nums2[i];\n        sums1[i + 1] = s1;\n        sums2[i + 1] = s2;\n    }\n    int MOD = 1_000_000_007;\n\n    int ans = 0;\n    for (int r = 0; r < nums1.length; ++r) {\n        for (int l = r + 1; --l >= 0;) {\n            for (int k = l; k <= r; ++k) {\n                int leftSum1 = sums1[l];\n                int rightSum1 = sums1[n] - sums1[k + 1];\n                int leftSum2 = sums2[l];\n                int rightSum2 = sums2[n] - sums2[r + 1];\n\n                if (leftSum1 + rightSum2 == leftSum2 && leftSum1 + rightSum1 == rightSum2) {\n                    for (int last = 0; last <= 2; ++last) {\n                        ans += dp[l][r][k][last];\n                        ans %= MOD;\n                        int next = last == 2 ? k + 1 : k;\n                        dp[next][k != 0 ? k : r + 1][k != 0 ? k - 1 : r + 2][last] +=\n                            dp[l][r][k][last];\n                        dp[l][r][k][last] =\n                            (dp[l][r][k][last] + (!last || last == 2)) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    We use dynamic programming to solve this problem. Initially, we compute the prefix sums for nums1 and nums2. It helps us to calculate the sum of the numbers picked from a range quickly. We create a 4D dp table to store the answer. The dimensions in the dp table represent the range start (l), range end (r), iterator (k), and the last balanced range. We initialize the dp table accordingly. We iterate over the length of nums1 and consider each possible subarrays of nums1 and nums2. Inside the nested loop, we compute the left and right sums of nums1 and nums2 for each range, and we check if the given range is balanced by matching the required conditions. If the range is balanced, we loop through the last 3 balanced ranges and update the dp table accordingly. Finally, we return the answer.\n    ",
        "python": "\n    ```python\ndef numberOfBalancedRanges(nums1, nums2):\n    MOD = 10**9 + 7\n    dp = [[[0] * (101) for _ in range(101)] for _ in range(101)]\n\n    dp[0][0] = 2\n    sums1, sums2 = [0] * (len(nums1) + 1), [0] * (len(nums1) + 1)\n    for i, (a, b) in enumerate(zip(nums1, nums2)):\n        sums1[i + 1], sums2[i + 1] = sums1[i] + a, sums2[i] + b\n\n    ans = 0\n    for r in range(len(nums1)):\n        for l in range(r, -1, -1):\n            for k in range(l, r + 1):\n                leftSum1 = sums1[l]\n                rightSum1 = sums1[len(nums1)] - sums1[k + 1]\n                leftSum2 = sums2[l]\n                rightSum2 = sums2[len(nums1)] - sums2[r + 1]\n\n                if leftSum1 + rightSum2 == leftSum2 and leftSum1 + rightSum1 == rightSum2:\n                    for last in range(3):\n                        ans += dp[l][r][k][last]\n                        ans %= MOD\n                        next = k + 1 if last == 2 else k\n                        dp[next][k if k else r + 1][k - 1 if k else r +\n                                                   2][last] += dp[l][r][k][last]\n                        dp[l][r][k][last] = (dp[l][r][k][last] +\n                                             ((!last) or last == 2)) % MOD\n    return ans\n```\n    \n    We use dynamic programming to solve this problem. Initially, we compute the prefix sums for nums1 and nums2. It helps us to calculate the sum of the numbers picked from a range quickly. We create a 4D dp table to store the answer. The dimensions in the dp table represent the range start (l), range end (r), iterator (k), and the last balanced range. We initialize the dp table accordingly. We iterate over the length of nums1 and consider each possible subarrays of nums1 and nums2. Inside the nested loop, we compute the left and right sums of nums1 and nums2 for each range, and we check if the given range is balanced by matching the required conditions. If the range is balanced, we loop through the last 3 balanced ranges and update the dp table accordingly. Finally, we return the answer.\n    ",
        "c++": "\n    ```cpp\nint numberOfBalancedRanges(vector<int>& nums1, vector<int>& nums2) {\n    int MOD = 1e9 + 7, transitions[101][101][101][3] = {}; // <l1, r1, k1, last> = Number of Ways\n    transitions[0][0][0][0] = 2;\n    int sum1[101] = {}, sum2[101] = {};\n    for (int i = 0, s1 = 0, s2 = 0; i < nums1.size(); ++i) {\n        s1 += nums1[i], s2 += nums2[i];\n        sum1[i + 1] = s1, sum2[i + 1] = s2;\n    }\n    auto valid = [&](int l, int r, int k) {\n        int leftN1 = sum1[nums1.size()] - sum1[k + 1];\n        return sum1[l] + sum2[r] - sum2[l] == sum2[k] &&\n               sum2[l] + sum1[nums1.size()] - sum1[r + 1] == rightN1;\n    };\n    int ans = 0;\n    for (int r = 0; r < nums1.size(); ++r) {\n        for (int l = r + 1; --l >= 0;) {\n            for (int k = l; k <= r; ++k) {\n                if (valid(l, r, k)) {\n                    for (int last = 0; last <= 2; ++last) {\n                        ans += transitions[l][r][k][last], ans %= MOD;\n                        int next = last == 2 ? k + 1 : k;\n                        transitions[next][k ? k : r + 1][k ? k - 1 : r + 2][last] +=\n                            transitions[l][r][k][last];\n                        transitions[l][r][k][last] =\n                            (transitions[l][r][k][last] + (!last || last == 2)) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    We use dynamic programming to solve this problem. Initially, we compute the prefix sums for nums1 and nums2. It helps us to calculate the sum of the numbers picked from a range quickly. We create a 4D dp table to store the answer. The dimensions in the dp table represent the range start (l), range end (r), iterator (k), and the last balanced range. We initialize the dp table accordingly. We iterate over the length of nums1 and consider each possible subarrays of nums1 and nums2. Inside the nested loop, we compute the left and right sums of nums1 and nums2 for each range, and we check if the given range is balanced by matching the required conditions. If the range is balanced, we loop through the last 3 balanced ranges and update the dp table accordingly. Finally, we return the answer.\n    ",
        "js": "\n    ```javascript\nvar numberOfBalancedRanges = function (nums1, nums2) {\n    const MOD = 1e9 + 7;\n    const dp = Array.from({ length: 101 }, () =>\n        Array.from({ length: 101 }, () => Array(101).fill(0))\n    );\n    dp[0][0] = 2;\n\n    const sums1 = [0];\n    const sums2 = [0];\n    for (let i = 0; i < nums1.length; ++i) {\n        sums1.push(sums1[i] + nums1[i]);\n        sums2.push(sums2[i] + nums2[i]);\n    }\n\n    let ans = 0;\n    for (let r = 0; r < nums1.length; ++r) {\n        for (let l = r + 1; --l >= 0;) {\n            for (let k = l; k <= r; ++k) {\n                const leftSum1 = sums1[l];\n                const rightSum1 = sums1[nums1.length] - sums1[k + 1];\n                const leftSum2 = sums2[l];\n                const rightSum2 = sums2[nums1.length] - sums2[r + 1];\n\n                if (\n                    leftSum1 + rightSum2 == leftSum2 &&\n                    leftSum1 + rightSum1 == rightSum2\n                ) {\n                    for (let last = 0; last <= 2; ++last) {\n                        ans += dp[l][r][k][last];\n                        ans %= MOD;\n                        const next = last == 2 ? k + 1 : k;\n                        dp[next][k ? k : r + 1][k ? k - 1 : r + 2][last] +=\n                            dp[l][r][k][last];\n                        dp[l][r][k][last] =\n                            (dp[l][r][k][last] + (!last || last == 2)) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n};\n```\n    \n    We use dynamic programming to solve this problem. Initially, we compute the prefix sums for nums1 and nums2. It helps us to calculate the sum of the numbers picked from a range quickly. We create a 4D dp table to store the answer. The dimensions in the dp table represent the range start (l), range end (r), iterator (k), and the last balanced range. We initialize the dp table accordingly. We iterate over the length of nums1 and consider each possible subarrays of nums1 and nums2. Inside the nested loop, we compute the left and right sums of nums1 and nums2 for each range, and we check if the given range is balanced by matching the required conditions. If the range is balanced, we loop through the last 3 balanced ranges and update the dp table accordingly. Finally, we return the answer.\n    "
    },
    {
        "id": 324,
        "title": "Count Elements With Strictly Smaller and Greater Elements ",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of elements that have **both** a strictly smaller and a strictly greater element appear in_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[11,7,2,15\\]\n**Output:** 2\n**Explanation:** The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in `nums`.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-3,3,3,90\\]\n**Output:** 2\n**Explanation:** The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in `nums`."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[11,7,2,15]",
                "output": "2"
            },
            {
                "input": "[-3,3,3,90]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minMoves(int[] seats, int[] students) {\n    Arrays.sort(seats);\n    Arrays.sort(students);\n\n    int moves = 0;\n    for (int i = 0; i < seats.length; i++) {\n        moves += Math.abs(seats[i] - students[i]);\n    }\n    return moves;\n}\n```\n    \n    1. Sort both the `seats` and `students` arrays in ascending order. \n   This ensures that students will be paired up with the nearest available seat.\n2. Initialize a variable `moves` to store the total number of moves.\n3. Iterate through both arrays simultaneously using a single index.\n4. In each iteration, add the absolute difference between the current seat and student position to the `moves` variable.\n5. After the iteration, return the `moves` variable for the minimum number of moves required.\n\nNote: This solution assumes that the input arrays have the same length and are non-empty.\n    ",
        "python": "\n    ```python\ndef min_moves(seats, students):\n    seats.sort()\n    students.sort()\n\n    moves = 0\n    for i in range(len(seats)):\n        moves += abs(seats[i] - students[i])\n    return moves\n```\n    \n    1. Sort both the `seats` and `students` arrays in ascending order. \n   This ensures that students will be paired up with the nearest available seat.\n2. Initialize a variable `moves` to store the total number of moves.\n3. Iterate through both arrays simultaneously using a single index.\n4. In each iteration, add the absolute difference between the current seat and student position to the `moves` variable.\n5. After the iteration, return the `moves` variable for the minimum number of moves required.\n\nNote: This solution assumes that the input arrays have the same length and are non-empty.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint min_moves(std::vector<int>& seats, std::vector<int>& students) {\n    std::sort(seats.begin(), seats.end());\n    std::sort(students.begin(), students.end());\n\n    int moves = 0;\n    for (int i = 0; i < seats.size(); i++) {\n        moves += std::abs(seats[i] - students[i]);\n    }\n    return moves;\n}\n```\n    \n    1. Sort both the `seats` and `students` arrays in ascending order. \n   This ensures that students will be paired up with the nearest available seat.\n2. Initialize a variable `moves` to store the total number of moves.\n3. Iterate through both arrays simultaneously using a single index.\n4. In each iteration, add the absolute difference between the current seat and student position to the `moves` variable.\n5. After the iteration, return the `moves` variable for the minimum number of moves required.\n\nNote: This solution assumes that the input arrays have the same length and are non-empty.\n    ",
        "js": "\n    ```javascript\nfunction minMoves(seats, students) {\n    seats.sort((a, b) => a - b);\n    students.sort((a, b) => a - b);\n\n    let moves = 0;\n    for (let i = 0; i < seats.length; i++) {\n        moves += Math.abs(seats[i] - students[i]);\n    }\n    return moves;\n}\n```\n    \n    1. Sort both the `seats` and `students` arrays in ascending order. \n   This ensures that students will be paired up with the nearest available seat.\n2. Initialize a variable `moves` to store the total number of moves.\n3. Iterate through both arrays simultaneously using a single index.\n4. In each iteration, add the absolute difference between the current seat and student position to the `moves` variable.\n5. After the iteration, return the `moves` variable for the minimum number of moves required.\n\nNote: This solution assumes that the input arrays have the same length and are non-empty.\n    "
    },
    {
        "id": 325,
        "title": "Minimum Number of Lines to Cover Points",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `points` where `points[i] = [xi, yi]` represents a point on an **X-Y** plane.\n\n**Straight lines** are going to be added to the **X-Y** plane, such that every point is covered by at **least** one line.\n\nReturn _the **minimum** number of **straight lines** needed to cover all the points_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[0,1\\],\\[2,3\\],\\[4,5\\],\\[4,3\\]\\]\n**Output:** 2\n**Explanation:** The minimum number of straight lines needed is two. One possible solution is to add:\n- One line connecting the point at (0, 1) to the point at (4, 5).\n- Another line connecting the point at (2, 3) to the point at (4, 3).\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[0,2\\],\\[-2,-2\\],\\[1,4\\]\\]\n**Output:** 1\n**Explanation:** The minimum number of straight lines needed is one. The only solution is to add:\n- One line connecting the point at (-2, -2) to the point at (1, 4)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 10`\n*   `points[i].length == 2`\n*   `-100 <= xi, yi <= 100`\n*   All the `points` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1],[2,3],[4,5],[4,3]]",
                "output": "2"
            },
            {
                "input": "[[0,2],[-2,-2],[1,4]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int minStraightLines(int[][] points) {\n    int len = points.length;\n    Set<Integer> set = new HashSet<>();\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n            int gcd = gcd(deltaX, deltaY);\n            int hash = deltaY / gcd * 1000 + deltaX / gcd;\n            set.add(hash);\n        }\n    }\n    return set.size();\n}\n\nprivate int gcd(int a, int b) {\n    return (b == 0) ? a : gcd(b, a % b);\n}\n```\n\n    \n    The algorithm checks all possible pairs of points in the plane, and calculates the line connecting them. To avoid duplicates, we use the greatest common divisor (gcd) to normalize the lines by calculating the slope `(dx, dy) // gcd`. Then, we store these lines in a hash set. The gcd is calculated using a helper function (JavaScript) or directly using the math library (Python) or built-in functions (C++).\n\nThe algorithm does not require any specific language implementation because it is based only on the basic concept of comparing slopes and keeping a count of unique slopes. For each pair of points, the algorithm calculates the slope, normalizes it using the gcd, and stores it in the hash set. The final answer is found by taking the size of the hash set.\n    ",
        "python": "\n    ```python\nfrom math import gcd\nfrom itertools import combinations\n\ndef minStraightLines(points):\n    lines = set()\n    for p1, p2 in combinations(points, 2):\n        dy, dx = p2[1] - p1[1], p2[0] - p1[0]\n        g = gcd(dx, dy)\n        lines.add((dy // g, dx // g))\n    return len(lines)\n```\n\n    \n    The algorithm checks all possible pairs of points in the plane, and calculates the line connecting them. To avoid duplicates, we use the greatest common divisor (gcd) to normalize the lines by calculating the slope `(dx, dy) // gcd`. Then, we store these lines in a hash set. The gcd is calculated using a helper function (JavaScript) or directly using the math library (Python) or built-in functions (C++).\n\nThe algorithm does not require any specific language implementation because it is based only on the basic concept of comparing slopes and keeping a count of unique slopes. For each pair of points, the algorithm calculates the slope, normalizes it using the gcd, and stores it in the hash set. The final answer is found by taking the size of the hash set.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_set>\n#include <utility>\n\nint minStraightLines(vector<vector<int>>& points) {\n    int len = points.size();\n    unordered_set<int> uh;\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            if (i != j) {\n                int delta_x = points[j][0] - points[i][0];\n                int delta_y = points[j][1] - points[i][1];\n                int gcd = __gcd(delta_x, delta_y);\n                delta_x /= gcd;\n                delta_y /= gcd;\n                uh.insert(delta_y * 1000 + delta_x);\n            }\n        }\n    }\n    return uh.size();\n}\n```\n\n    \n    The algorithm checks all possible pairs of points in the plane, and calculates the line connecting them. To avoid duplicates, we use the greatest common divisor (gcd) to normalize the lines by calculating the slope `(dx, dy) // gcd`. Then, we store these lines in a hash set. The gcd is calculated using a helper function (JavaScript) or directly using the math library (Python) or built-in functions (C++).\n\nThe algorithm does not require any specific language implementation because it is based only on the basic concept of comparing slopes and keeping a count of unique slopes. For each pair of points, the algorithm calculates the slope, normalizes it using the gcd, and stores it in the hash set. The final answer is found by taking the size of the hash set.\n    ",
        "js": "\n    ```javascript\nfunction minStraightLines(points) {\n    const set = new Set();\n    const len = points.length;\n\n    function gcd(a, b) {\n        return (b === 0) ? a : gcd(b, a % b);\n    }\n\n    for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n            const deltaX = points[j][0] - points[i][0];\n            const deltaY = points[j][1] - points[i][1];\n            const g = gcd(deltaY, deltaX);\n            const hash = deltaY / g * 1000 + deltaX / g;\n            set.add(hash);\n        }\n    }\n    return set.size;\n}\n```\n\n    \n    The algorithm checks all possible pairs of points in the plane, and calculates the line connecting them. To avoid duplicates, we use the greatest common divisor (gcd) to normalize the lines by calculating the slope `(dx, dy) // gcd`. Then, we store these lines in a hash set. The gcd is calculated using a helper function (JavaScript) or directly using the math library (Python) or built-in functions (C++).\n\nThe algorithm does not require any specific language implementation because it is based only on the basic concept of comparing slopes and keeping a count of unique slopes. For each pair of points, the algorithm calculates the slope, normalizes it using the gcd, and stores it in the hash set. The final answer is found by taking the size of the hash set.\n    "
    },
    {
        "id": 326,
        "title": "Amount of New Area Painted Each Day",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a long and thin painting that can be represented by a number line. You are given a **0-indexed** 2D integer array `paint` of length `n`, where `paint[i] = [starti, endi]`. This means that on the `ith` day you need to paint the area **between** `starti` and `endi`.\n\nPainting the same area multiple times will create an uneven painting so you only want to paint each area of the painting at most **once**.\n\nReturn _an integer array_ `worklog` _of length_ `n`_, where_ `worklog[i]` _is the amount of **new** area that you painted on the_ `ith` _day._",
            "examples": [
                "**Example 1:**\n\n**Input:** paint = \\[\\[1,4\\],\\[4,7\\],\\[5,8\\]\\]\n**Output:** \\[3,3,1\\]\n**Explanation:**\nOn day 0, paint everything between 1 and 4.\nThe amount of new area painted on day 0 is 4 - 1 = 3.\nOn day 1, paint everything between 4 and 7.\nThe amount of new area painted on day 1 is 7 - 4 = 3.\nOn day 2, paint everything between 7 and 8.\nEverything between 5 and 7 was already painted on day 1.\nThe amount of new area painted on day 2 is 8 - 7 = 1. \n\n",
                "**Example 2:**\n\n**Input:** paint = \\[\\[1,4\\],\\[5,8\\],\\[4,7\\]\\]\n**Output:** \\[3,3,1\\]\n**Explanation:**\nOn day 0, paint everything between 1 and 4.\nThe amount of new area painted on day 0 is 4 - 1 = 3.\nOn day 1, paint everything between 5 and 8.\nThe amount of new area painted on day 1 is 8 - 5 = 3.\nOn day 2, paint everything between 4 and 5.\nEverything between 5 and 7 was already painted on day 1.\nThe amount of new area painted on day 2 is 5 - 4 = 1. \n\n",
                "**Example 3:**\n\n**Input:** paint = \\[\\[1,5\\],\\[2,4\\]\\]\n**Output:** \\[4,0\\]\n**Explanation:**\nOn day 0, paint everything between 1 and 5.\nThe amount of new area painted on day 0 is 5 - 1 = 4.\nOn day 1, paint nothing because everything between 2 and 4 was already painted on day 0.\nThe amount of new area painted on day 1 is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= paint.length <= 105`\n*   `paint[i].length == 2`\n*   `0 <= starti < endi <= 5 * 104`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,4],[4,7],[5,8]]",
                "output": "[3,3,1]"
            },
            {
                "input": "[[1,4],[5,8],[4,7]]",
                "output": "[3,3,1]"
            },
            {
                "input": "[[1,5],[2,4]]",
                "output": "[4,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.Vector;\n\npublic Vector<Integer> paintingPlan(int[][] paint) {\n    Vector<Integer> worklog = new Vector<>(paint.length);\n    Set<Integer> painted = new HashSet<>();\n\n    for (int i = 0; i < paint.length; i++) {\n        int start = paint[i][0];\n        int end = paint[i][1];\n        int day_work = 0;\n\n        for (int j = start; j < end; j++) {\n            if (!painted.contains(j)) {\n                painted.add(j);\n                day_work++;\n            }\n        }\n\n        worklog.add(day_work);\n    }\n\n    return worklog;\n}\n```\n    \n    The algorithm follows these steps:\n1. Create an array or vector `worklog` which will store the new painted areas on each day, and set all the initial values to 0.\n2. Create a set `painted` which will store the areas (integer points) that have already been painted.\n3. Iterate through the given `paint` array, for each day:\n   1. Extract the start and end points of the painting area.\n   2. Iterate through the points between the start and end.\n   3. If the point is not in the `painted` set, add it to the set and increment the counter for the current day in the `worklog` array.\n4. Return the `worklog` array.\n    ",
        "python": "\n    ```python\ndef painting_plan(paint):\n    worklog = [0] * len(paint)\n    painted = set()\n\n    for i in range(len(paint)):\n        start, end = paint[i]\n\n        for j in range(start, end):\n            if j not in painted:\n                painted.add(j)\n                worklog[i] += 1\n\n    return worklog\n```\n    \n    The algorithm follows these steps:\n1. Create an array or vector `worklog` which will store the new painted areas on each day, and set all the initial values to 0.\n2. Create a set `painted` which will store the areas (integer points) that have already been painted.\n3. Iterate through the given `paint` array, for each day:\n   1. Extract the start and end points of the painting area.\n   2. Iterate through the points between the start and end.\n   3. If the point is not in the `painted` set, add it to the set and increment the counter for the current day in the `worklog` array.\n4. Return the `worklog` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<int> paintingPlan(const std::vector<std::vector<int>>& paint) {\n    std::vector<int> worklog(paint.size(), 0);\n    std::set<int> painted;\n\n    for (std::size_t i = 0; i < paint.size(); ++i) {\n        int start = paint[i][0];\n        int end = paint[i][1];\n\n        for (int j = start; j < end; ++j) {\n            if (painted.count(j) == 0) {\n                painted.insert(j);\n                worklog[i]++;\n            }\n        }\n    }\n\n    return worklog;\n}\n```\n    \n    The algorithm follows these steps:\n1. Create an array or vector `worklog` which will store the new painted areas on each day, and set all the initial values to 0.\n2. Create a set `painted` which will store the areas (integer points) that have already been painted.\n3. Iterate through the given `paint` array, for each day:\n   1. Extract the start and end points of the painting area.\n   2. Iterate through the points between the start and end.\n   3. If the point is not in the `painted` set, add it to the set and increment the counter for the current day in the `worklog` array.\n4. Return the `worklog` array.\n    ",
        "js": "\n    ```javascript\nfunction paintingPlan(paint) {\n    const worklog = new Array(paint.length).fill(0);\n    const painted = new Set();\n\n    for (let i = 0; i < paint.length; i++) {\n        const [start, end] = paint[i];\n\n        for (let j = start; j < end; j++) {\n            if (!painted.has(j)) {\n                painted.add(j);\n                worklog[i]++;\n            }\n        }\n    }\n\n    return worklog;\n}\n```\n    \n    The algorithm follows these steps:\n1. Create an array or vector `worklog` which will store the new painted areas on each day, and set all the initial values to 0.\n2. Create a set `painted` which will store the areas (integer points) that have already been painted.\n3. Iterate through the given `paint` array, for each day:\n   1. Extract the start and end points of the painting area.\n   2. Iterate through the points between the start and end.\n   3. If the point is not in the `painted` set, add it to the set and increment the counter for the current day in the `worklog` array.\n4. Return the `worklog` array.\n    "
    },
    {
        "id": 327,
        "title": "Unique Substrings With Equal Digit Frequency",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a digit string `s`, return _the number of **unique substrings** of_ `s` _where every digit appears the same number of times._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1212 \"\n**Output:** 5\n**Explanation:** The substrings that meet the requirements are  \"1 \",  \"2 \",  \"12 \",  \"21 \",  \"1212 \".\nNote that although the substring  \"12 \" appears twice, it is only counted once.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"12321 \"\n**Output:** 9\n**Explanation:** The substrings that meet the requirements are  \"1 \",  \"2 \",  \"3 \",  \"12 \",  \"23 \",  \"32 \",  \"21 \",  \"123 \",  \"321 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of digits.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"1212\"",
                "output": "5"
            },
            {
                "input": "\"12321\"",
                "output": "9"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean areNumbersIncreasing(String s) {\n    Scanner scanner = new Scanner(s);\n    ArrayList<Integer> numbers = new ArrayList<>();\n    \n    while (scanner.hasNext()) {\n        if (scanner.hasNextInt()) {\n            int num = scanner.nextInt();\n            if (!numbers.isEmpty() && numbers.get(numbers.size() - 1) >= num) {\n                return false;\n            }\n            numbers.add(num);\n        } else {\n            scanner.next();\n        }\n    }\n    \n    return true;\n}\n```\n    \n    This algorithm iterates through the tokens of the input sentence (s). It checks each token to see if it is a number, using language-specific functions like isdigit for C++/Python, Scanner for Java, or isNaN for JavaScript. If the token is a number, the algorithm checks if it is strictly greater than the last number we encountered (if any). If it isn't strictly greater, the function returns `false`. At the end of the iterations, if no condition is met, it returns `true`, indicating all numbers in the sentence are in strictly increasing order.\n    ",
        "python": "\n    ```python\ndef are_numbers_increasing(s: str) -> bool:\n    tokens = s.split()\n    numbers = []\n    \n    for token in tokens:\n        if token.isdigit():\n            num = int(token)\n            if numbers and numbers[-1] >= num:\n                return False\n            numbers.append(num)\n    \n    return True\n```\n    \n    This algorithm iterates through the tokens of the input sentence (s). It checks each token to see if it is a number, using language-specific functions like isdigit for C++/Python, Scanner for Java, or isNaN for JavaScript. If the token is a number, the algorithm checks if it is strictly greater than the last number we encountered (if any). If it isn't strictly greater, the function returns `false`. At the end of the iterations, if no condition is met, it returns `true`, indicating all numbers in the sentence are in strictly increasing order.\n    ",
        "c++": "\n    ```cpp\n#include <sstream>\n#include <string>\n#include <vector>\n\nbool areNumbersIncreasing(std::string s) {\n    std::istringstream iss(s);\n    std::string token;\n    std::vector<int> numbers;\n    \n    while (iss >> token) {\n        if (isdigit(token[0])) {\n            int num = std::stoi(token);\n            if (!numbers.empty() && numbers.back() >= num) {\n                return false;\n            }\n            numbers.push_back(num);\n        }\n    }\n    \n    return true;\n}\n```\n    \n    This algorithm iterates through the tokens of the input sentence (s). It checks each token to see if it is a number, using language-specific functions like isdigit for C++/Python, Scanner for Java, or isNaN for JavaScript. If the token is a number, the algorithm checks if it is strictly greater than the last number we encountered (if any). If it isn't strictly greater, the function returns `false`. At the end of the iterations, if no condition is met, it returns `true`, indicating all numbers in the sentence are in strictly increasing order.\n    ",
        "js": "\n    ```javascript\nfunction areNumbersIncreasing(s) {\n    const tokens = s.split(\" \");\n    const numbers = [];\n    \n    for (const token of tokens) {\n        if (!isNaN(token)) {\n            const num = parseInt(token);\n            if (numbers.length && numbers[numbers.length - 1] >= num) {\n                return false;\n            }\n            numbers.push(num);\n        }\n    }\n\n    return true;\n}\n```\n    \n    This algorithm iterates through the tokens of the input sentence (s). It checks each token to see if it is a number, using language-specific functions like isdigit for C++/Python, Scanner for Java, or isNaN for JavaScript. If the token is a number, the algorithm checks if it is strictly greater than the last number we encountered (if any). If it isn't strictly greater, the function returns `false`. At the end of the iterations, if no condition is met, it returns `true`, indicating all numbers in the sentence are in strictly increasing order.\n    "
    },
    {
        "id": 328,
        "title": "Remove All Ones With Row and Column Flips II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** `m x n` **binary** matrix `grid`.\n\nIn one operation, you can choose any `i` and `j` that meet the following conditions:\n\n*   `0 <= i < m`\n*   `0 <= j < n`\n*   `grid[i][j] == 1`\n\nand change the values of **all** cells in row `i` and column `j` to zero.\n\nReturn _the **minimum** number of operations needed to remove all_ `1`_'s from_ `grid`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[0,1,0\\]\\]\n**Output:** 2\n**Explanation:**\nIn the first operation, change all cell values of row 1 and column 1 to zero.\nIn the second operation, change all cell values of row 0 and column 0 to zero.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,1,0\\],\\[1,0,1\\],\\[0,1,0\\]\\]\n**Output:** 2\n**Explanation:**\nIn the first operation, change all cell values of row 1 and column 0 to zero.\nIn the second operation, change all cell values of row 2 and column 1 to zero.\nNote that we cannot perform an operation using row 1 and column 1 because grid\\[1\\]\\[1\\] != 1.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[0,0\\],\\[0,0\\]\\]\n**Output:** 0\n**Explanation:**\nThere are no 1's to remove so return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 15`\n*   `1 <= m * n <= 15`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[1,1,1],[1,1,1],[0,1,0]]",
                "output": "2"
            },
            {
                "input": "[[0,1,0],[1,0,1],[0,1,0]]",
                "output": "2"
            },
            {
                "input": "[[0,0],[0,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint nextBalanced(int n) {\n    while (true) {\n        n++;\n        Map<Integer, Integer> digitCount = new HashMap<>();\n        int temp = n;\n        while (temp != 0) {\n            digitCount.put(temp % 10, digitCount.getOrDefault(temp % 10, 0) + 1);\n            temp /= 10;\n        }\n        boolean balanced = true;\n        for (Map.Entry<Integer, Integer> entry : digitCount.entrySet()) {\n            if (!entry.getKey().equals(entry.getValue())) {\n                balanced = false;\n                break;\n            }\n        }\n        if (balanced) return n;\n    }\n}\n```\n    \n    The algorithm iterates through each number greater than the given number `n`, analyzes the count of each digit in the number, and checks its balance status. \n\nIn each iteration, we do the following steps:\n\n1. Increment the number `n` by 1.\n2. Count the occurrences of each digit using a map or dictionary to store the count.\n3. Iterate through each key-value pair in the map, and if the key is equal to the value, it indicates that the digit count is balanced. If all pairs have this property, return the number as the result.\n\nThis algorithm will continue until it finds a numerically balanced integer, which it will return as a result. Note that it uses integer division, dictionaries or maps, and iteration over key-value pairs, which have small language-specific differences.\n    ",
        "python": "\n    ```python\ndef next_balanced(n):\n    while True:\n        n += 1\n        digit_count = {}\n        temp = n\n        while temp:\n            digit = temp % 10\n            digit_count[digit] = digit_count.get(digit, 0) + 1\n            temp //= 10\n        balanced = all(k == v for k, v in digit_count.items())\n        if balanced:\n            return n\n```\n    \n    The algorithm iterates through each number greater than the given number `n`, analyzes the count of each digit in the number, and checks its balance status. \n\nIn each iteration, we do the following steps:\n\n1. Increment the number `n` by 1.\n2. Count the occurrences of each digit using a map or dictionary to store the count.\n3. Iterate through each key-value pair in the map, and if the key is equal to the value, it indicates that the digit count is balanced. If all pairs have this property, return the number as the result.\n\nThis algorithm will continue until it finds a numerically balanced integer, which it will return as a result. Note that it uses integer division, dictionaries or maps, and iteration over key-value pairs, which have small language-specific differences.\n    ",
        "c++": "\n    ```cpp\nint nextBalanced(int n) {\n    while (true) {\n        n++;\n        std::map<int, int> digitCount;\n        int temp = n;\n        while (temp) {\n            digitCount[temp % 10]++;\n            temp /= 10;\n        }\n        bool balanced = true;\n        for (const auto& p : digitCount) {\n            if (p.first != p.second) {\n                balanced = false;\n                break;\n            }\n        }\n        if (balanced) return n;\n    }\n}\n```\n    \n    The algorithm iterates through each number greater than the given number `n`, analyzes the count of each digit in the number, and checks its balance status. \n\nIn each iteration, we do the following steps:\n\n1. Increment the number `n` by 1.\n2. Count the occurrences of each digit using a map or dictionary to store the count.\n3. Iterate through each key-value pair in the map, and if the key is equal to the value, it indicates that the digit count is balanced. If all pairs have this property, return the number as the result.\n\nThis algorithm will continue until it finds a numerically balanced integer, which it will return as a result. Note that it uses integer division, dictionaries or maps, and iteration over key-value pairs, which have small language-specific differences.\n    ",
        "js": "\n    ```javascript\nfunction nextBalanced(n) {\n    while (true) {\n        n++;\n        const digitCount = new Map();\n        let temp = n;\n        while (temp !== 0) {\n            const digit = temp % 10;\n            digitCount.set(digit, (digitCount.get(digit) || 0) + 1);\n            temp = Math.floor(temp / 10);\n        }\n        const balanced = [...digitCount.entries()].every(([k, v]) => k === v );\n        if (balanced) return n;\n    }\n}\n```\n    \n    The algorithm iterates through each number greater than the given number `n`, analyzes the count of each digit in the number, and checks its balance status. \n\nIn each iteration, we do the following steps:\n\n1. Increment the number `n` by 1.\n2. Count the occurrences of each digit using a map or dictionary to store the count.\n3. Iterate through each key-value pair in the map, and if the key is equal to the value, it indicates that the digit count is balanced. If all pairs have this property, return the number as the result.\n\nThis algorithm will continue until it finds a numerically balanced integer, which it will return as a result. Note that it uses integer division, dictionaries or maps, and iteration over key-value pairs, which have small language-specific differences.\n    "
    },
    {
        "id": 329,
        "title": "Number of Ways to Build Sturdy Brick Wall",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given integers `height` and `width` which specify the dimensions of a brick wall you are building. You are also given a **0-indexed** array of **unique** integers `bricks`, where the `ith` brick has a height of `1` and a width of `bricks[i]`. You have an **infinite** supply of each type of brick and bricks may **not** be rotated.\n\nEach row in the wall must be exactly `width` units long. For the wall to be **sturdy**, adjacent rows in the wall should **not** join bricks at the same location, except at the ends of the wall.\n\nReturn _the number of ways to build a **sturdy** wall._ Since the answer may be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = 2, width = 3, bricks = \\[1,2\\]\n**Output:** 2\n**Explanation:**\nThe first two walls in the diagram show the only two ways to build a sturdy brick wall.\nNote that the third wall in the diagram is not sturdy because adjacent rows join bricks 2 units from the left.\n\n",
                "**Example 2:**\n\n**Input:** height = 1, width = 1, bricks = \\[5\\]\n**Output:** 0\n**Explanation:**\nThere are no ways to build a sturdy wall because the only type of brick we have is longer than the width of the wall."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= height <= 100`\n*   `1 <= width <= 10`\n*   `1 <= bricks.length <= 10`\n*   `1 <= bricks[i] <= 10`\n*   All the values of `bricks` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2,3,[1,2]",
                "output": "2"
            },
            {
                "input": "1,1,[5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic boolean areEncodedStringsEqual(String s1, String s2) {\n    StringBuilder decoded1 = new StringBuilder(), decoded2 = new StringBuilder();\n\n    for(int i = 0; i < s1.length(); ++i) {\n        if(Character.isDigit(s1.charAt(i))) {\n            int count = s1.charAt(i) - '0';\n            while(count-- > 0) decoded1.append(s1.charAt(i - 1));\n        } else decoded1.append(s1.charAt(i));\n    }\n\n    for(int i = 0; i < s2.length(); ++i) {\n        if(Character.isDigit(s2.charAt(i))) {\n            int count = s2.charAt(i) - '0';\n            while(count-- > 0) decoded2.append(s2.charAt(i - 1));\n        } else decoded2.append(s2.charAt(i));\n    }\n\n    return decoded1.toString().equals(decoded2.toString());\n}\n```\n\n    \n    We initialize two strings called `decoded1` and `decoded2` to store the decoded representations of `s1` and `s2`. For each input string, we iterate through the characters. If the character is a digit, we take the previous character and repeat it that digit number of times, adding it to the relevant decoded string. If the character is not a digit, we simply add it to the decoded string. After decoding both strings, we compare them for equality and return the result.\n    ",
        "python": "\n    ```python\ndef are_encoded_strings_equal(s1: str, s2: str) -> bool:\n    decoded1, decoded2 = \"\", \"\"\n\n    for i, c in enumerate(s1):\n        if c.isdigit():\n            count = int(c)\n            decoded1 += s1[i - 1] * count\n        else:\n            decoded1 += c\n\n    for i, c in enumerate(s2):\n        if c.isdigit():\n            count = int(c)\n            decoded2 += s2[i - 1] * count\n        else:\n            decoded2 += c\n\n    return decoded1 == decoded2\n```\n\n    \n    We initialize two strings called `decoded1` and `decoded2` to store the decoded representations of `s1` and `s2`. For each input string, we iterate through the characters. If the character is a digit, we take the previous character and repeat it that digit number of times, adding it to the relevant decoded string. If the character is not a digit, we simply add it to the decoded string. After decoding both strings, we compare them for equality and return the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nbool areEncodedStringsEqual(string s1, string s2) {\n    string decoded1 = \"\", decoded2 = \"\";\n\n    for(int i = 0; i < s1.size(); ++i) {\n        if(isdigit(s1[i])) {\n            int count = s1[i] - '0';\n            while(count--) decoded1 += s1[i - 1];\n        } else decoded1 += s1[i];\n    }\n\n    for(int i = 0; i < s2.size(); ++i) {\n        if(isdigit(s2[i])) {\n            int count = s2[i] - '0';\n            while(count--) decoded2 += s2[i - 1];\n        } else decoded2 += s2[i];\n    }\n\n    return decoded1 == decoded2;\n}\n```\n\n    \n    We initialize two strings called `decoded1` and `decoded2` to store the decoded representations of `s1` and `s2`. For each input string, we iterate through the characters. If the character is a digit, we take the previous character and repeat it that digit number of times, adding it to the relevant decoded string. If the character is not a digit, we simply add it to the decoded string. After decoding both strings, we compare them for equality and return the result.\n    ",
        "js": "\n    ```javascript\nfunction areEncodedStringsEqual(s1, s2) {\n    let decoded1 = \"\", decoded2 = \"\";\n\n    for(let i = 0; i < s1.length; ++i) {\n        if(!isNaN(s1[i])) {\n            let count = Number(s1[i]);\n            while(count--) decoded1 += s1[i - 1];\n        } else decoded1 += s1[i];\n    }\n\n    for(let i = 0; i < s2.length; ++i) {\n        if(!isNaN(s2[i])) {\n            let count = Number(s2[i]);\n            while(count--) decoded2 += s2[i - 1];\n        } else decoded2 += s2[i];\n    }\n\n    return decoded1 === decoded2;\n}\n```\n\n    \n    We initialize two strings called `decoded1` and `decoded2` to store the decoded representations of `s1` and `s2`. For each input string, we iterate through the characters. If the character is a digit, we take the previous character and repeat it that digit number of times, adding it to the relevant decoded string. If the character is not a digit, we simply add it to the decoded string. After decoding both strings, we compare them for equality and return the result.\n    "
    },
    {
        "id": 330,
        "title": "Number of Ways to Build House of Cards",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `n` representing the number of playing cards you have. A **house of cards** meets the following conditions:\n\n*   A **house of cards** consists of one or more rows of **triangles** and horizontal cards.\n*   **Triangles** are created by leaning two cards against each other.\n*   One card must be placed horizontally between **all adjacent** triangles in a row.\n*   Any triangle on a row higher than the first must be placed on a horizontal card from the previous row.\n*   Each triangle is placed in the **leftmost** available spot in the row.\n\nReturn _the number of **distinct** **house of cards** you can build using **all**_ `n` _cards._ Two houses of cards are considered distinct if there exists a row where the two houses contain a different number of cards.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 16\n**Output:** 2\n**Explanation:** The two valid houses of cards are shown.\nThe third house of cards in the diagram is not valid because the rightmost triangle on the top row is not placed on top of a horizontal card.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** The one valid house of cards is shown.\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** 0\n**Explanation:** The three houses of cards in the diagram are not valid.\nThe first house of cards needs a horizontal card placed between the two triangles.\nThe second house of cards uses 5 cards.\nThe third house of cards uses 2 cards."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 500`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "16",
                "output": "2"
            },
            {
                "input": "2",
                "output": "1"
            },
            {
                "input": "4",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxQualityRec(int[][] adjMatrix, int[] values, int node, int timeLeft, Set<Integer> visited) {\n    if (timeLeft < 0) {\n        return Integer.MIN_VALUE;\n    }\n\n    int maxQuality = 0;\n    visited.add(node);\n    for (int i = 0; i < adjMatrix[node].length; ++i) {\n        if (adjMatrix[node][i] != -1) {\n            int time = adjMatrix[node][i];\n            int oldValue = adjMatrix[node][i];\n            adjMatrix[node][i] = adjMatrix[i][node] = -1;\n            maxQuality = Math.max(maxQuality, maxQualityRec(adjMatrix, values, i, timeLeft - time, visited));\n            adjMatrix[node][i] = adjMatrix[i][node] = oldValue;\n        }\n    }\n    visited.remove(node);\n    return maxQuality + (visited.contains(node + 1) ? 0 : values[node]);\n}\n\npublic int maxQuality(int n, int[] values, int[][] edges, int maxTime) {\n    int[][] adjMatrix = new int[n][n];\n    for (int[] row : adjMatrix) {\n        Arrays.fill(row, -1);\n    }\n\n    for (int[] edge : edges) {\n        adjMatrix[edge[0]][edge[1]] = adjMatrix[edge[1]][edge[0]] = edge[2];\n    }\n\n    Set<Integer> visited = new HashSet<>();\n    return maxQualityRec(adjMatrix, values, 0, maxTime, visited);\n}\n```\n\n    \n    The algorithm uses a backtracking approach with depth-first search. It starts from node `0` and recursively traverses through the graph while keeping track of visited nodes in a hash set. For each neighboring node, it updates the adjacency matrix (or adjacency dictionary in Python) to account for the travel time between the two nodes. After exploring the path, the algorithm backtracks by resetting the changes made to the adjacency matrix (or adjacency dictionary) and removing the current node from the visited nodes set.\n\nThe base case is when the timeLeft is less than zero, which indicates that the path exceeds the maxTime, so it returns INT_MIN (or float('-inf') in Python) to discard this path. After exploring all possible paths, the function returns the maximum quality found in valid paths. The quality of a path is calculated as the sum of values of the unique nodes visited in the path.\n\nNote that the maximum number of edges connected to each node is 4. The time complexity of this algorithm can be up to O(n^n) but will be much lower in practice due to the constraints. The space complexity is O(n).\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef maxQualityRec(adjDict, values, node, timeLeft, visited):\n    if timeLeft < 0:\n        return float('-inf')\n\n    maxQuality = 0\n    visited.add(node)\n    for neighbor, time in adjDict[node]:\n        adjDict[neighbor].remove((node, time))\n        maxQuality = max(maxQuality, maxQualityRec(adjDict, values, neighbor, timeLeft - time, visited))\n        adjDict[neighbor].append((node, time))\n    \n    visited.remove(node)\n    return maxQuality + (values[node] if node not in visited else 0)\n\ndef maxQuality(n, values, edges, maxTime):\n    adjDict = defaultdict(list)\n    for u, v, time in edges:\n        adjDict[u].append((v, time))\n        adjDict[v].append((u, time))\n\n    visited = set()\n    return maxQualityRec(adjDict, values, 0, maxTime, visited)\n```\n\n    \n    The algorithm uses a backtracking approach with depth-first search. It starts from node `0` and recursively traverses through the graph while keeping track of visited nodes in a hash set. For each neighboring node, it updates the adjacency matrix (or adjacency dictionary in Python) to account for the travel time between the two nodes. After exploring the path, the algorithm backtracks by resetting the changes made to the adjacency matrix (or adjacency dictionary) and removing the current node from the visited nodes set.\n\nThe base case is when the timeLeft is less than zero, which indicates that the path exceeds the maxTime, so it returns INT_MIN (or float('-inf') in Python) to discard this path. After exploring all possible paths, the function returns the maximum quality found in valid paths. The quality of a path is calculated as the sum of values of the unique nodes visited in the path.\n\nNote that the maximum number of edges connected to each node is 4. The time complexity of this algorithm can be up to O(n^n) but will be much lower in practice due to the constraints. The space complexity is O(n).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint maxQualityRec(const vector<vector<int>>& adjMatrix, const vector<int>& values, int node, int timeLeft, unordered_set<int>& visited) {\n    if (timeLeft < 0) {\n        return INT_MIN;\n    }\n\n    int maxQuality = 0;\n    visited.insert(node);\n    for (int i = 0; i < adjMatrix[node].size(); ++i) {\n        if (adjMatrix[node][i] != -1) {\n            int time = adjMatrix[node][i];\n            int oldValue = adjMatrix[node][i];\n            adjMatrix[node][i] = adjMatrix[i][node] = -1;\n            maxQuality = max(maxQuality, maxQualityRec(adjMatrix, values, i, timeLeft - time, visited));\n            adjMatrix[node][i] = adjMatrix[i][node] = oldValue;\n        }\n    }\n    visited.erase(node);\n    return maxQuality + (visited.count(node + 1) == 0 ? values[node] : 0);\n}\n\nint maxQuality(int n, const vector<int>& values, const vector<vector<int>>& edges, int maxTime) {\n    vector<vector<int>> adjMatrix(n, vector<int>(n, -1));\n    for (const auto& edge : edges) {\n        adjMatrix[edge[0]][edge[1]] = adjMatrix[edge[1]][edge[0]] = edge[2];\n    }\n\n    unordered_set<int> visited;\n    return maxQualityRec(adjMatrix, values, 0, maxTime, visited);\n}\n```\n\n    \n    The algorithm uses a backtracking approach with depth-first search. It starts from node `0` and recursively traverses through the graph while keeping track of visited nodes in a hash set. For each neighboring node, it updates the adjacency matrix (or adjacency dictionary in Python) to account for the travel time between the two nodes. After exploring the path, the algorithm backtracks by resetting the changes made to the adjacency matrix (or adjacency dictionary) and removing the current node from the visited nodes set.\n\nThe base case is when the timeLeft is less than zero, which indicates that the path exceeds the maxTime, so it returns INT_MIN (or float('-inf') in Python) to discard this path. After exploring all possible paths, the function returns the maximum quality found in valid paths. The quality of a path is calculated as the sum of values of the unique nodes visited in the path.\n\nNote that the maximum number of edges connected to each node is 4. The time complexity of this algorithm can be up to O(n^n) but will be much lower in practice due to the constraints. The space complexity is O(n).\n    ",
        "js": "\n    ```javascript\nfunction maxQualityRec(adjMatrix, values, node, timeLeft, visited) {\n    if (timeLeft < 0) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n\n    let maxQuality = 0;\n    visited.add(node);\n    for (let i = 0; i < adjMatrix[node].length; ++i) {\n        if (adjMatrix[node][i] !== -1) {\n            let time = adjMatrix[node][i];\n            let oldValue = adjMatrix[node][i];\n            adjMatrix[node][i] = adjMatrix[i][node] = -1;\n            maxQuality = Math.max(maxQuality, maxQualityRec(adjMatrix, values, i, timeLeft - time, visited));\n            adjMatrix[node][i] = adjMatrix[i][node] = oldValue;\n        }\n    }\n    visited.delete(node);\n    return maxQuality + (visited.has(node + 1) ? 0 : values[node]);\n}\n\nfunction maxQuality(n, values, edges, maxTime) {\n    let adjMatrix = new Array(n).fill(null).map(() => new Array(n).fill(-1));\n\n    for (let edge of edges) {\n        adjMatrix[edge[0]][edge[1]] = adjMatrix[edge[1]][edge[0]] = edge[2];\n    }\n\n    let visited = new Set();\n    return maxQualityRec(adjMatrix, values, 0, maxTime, visited);\n}\n```\n\n    \n    The algorithm uses a backtracking approach with depth-first search. It starts from node `0` and recursively traverses through the graph while keeping track of visited nodes in a hash set. For each neighboring node, it updates the adjacency matrix (or adjacency dictionary in Python) to account for the travel time between the two nodes. After exploring the path, the algorithm backtracks by resetting the changes made to the adjacency matrix (or adjacency dictionary) and removing the current node from the visited nodes set.\n\nThe base case is when the timeLeft is less than zero, which indicates that the path exceeds the maxTime, so it returns INT_MIN (or float('-inf') in Python) to discard this path. After exploring all possible paths, the function returns the maximum quality found in valid paths. The quality of a path is calculated as the sum of values of the unique nodes visited in the path.\n\nNote that the maximum number of edges connected to each node is 4. The time complexity of this algorithm can be up to O(n^n) but will be much lower in practice due to the constraints. The space complexity is O(n).\n    "
    },
    {
        "id": 331,
        "title": "Number of Single Divisor Triplets",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** array of positive integers `nums`. A triplet of three **distinct** indices `(i, j, k)` is called a **single divisor triplet** of `nums` if `nums[i] + nums[j] + nums[k]` is divisible by **exactly one** of `nums[i]`, `nums[j]`, or `nums[k]`.\n\nReturn _the number of **single divisor triplets** of_ `nums`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,6,7,3,2\\]\n**Output:** 12\n**Explanation:**\nThe triplets (0, 3, 4), (0, 4, 3), (3, 0, 4), (3, 4, 0), (4, 0, 3), and (4, 3, 0) have the values of \\[4, 3, 2\\] (or a permutation of \\[4, 3, 2\\]).\n4 + 3 + 2 = 9 which is only divisible by 3, so all such triplets are single divisor triplets.\nThe triplets (0, 2, 3), (0, 3, 2), (2, 0, 3), (2, 3, 0), (3, 0, 2), and (3, 2, 0) have the values of \\[4, 7, 3\\] (or a permutation of \\[4, 7, 3\\]).\n4 + 7 + 3 = 14 which is only divisible by 7, so all such triplets are single divisor triplets.\nThere are 12 single divisor triplets in total.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,2\\]\n**Output:** 6\n**Explanation:**\nThe triplets (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), and (2, 1, 0) have the values of \\[1, 2, 2\\] (or a permutation of \\[1, 2, 2\\]).\n1 + 2 + 2 = 5 which is only divisible by 1, so all such triplets are single divisor triplets.\nThere are 6 single divisor triplets in total.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 0\n**Explanation:**\nThere are no single divisor triplets.\nNote that (0, 1, 2) is not a single divisor triplet because nums\\[0\\] + nums\\[1\\] + nums\\[2\\] = 3 and 3 is divisible by nums\\[0\\], nums\\[1\\], and nums\\[2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `1 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,6,7,3,2]",
                "output": "12"
            },
            {
                "input": "[1,2,2]",
                "output": "6"
            },
            {
                "input": "[1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Main {\n    public boolean[] checkFriends(int n, int[][] restrictions, int[][] requests) {\n        List<Set<Integer>> friends = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            friends.add(new HashSet<>());\n        }\n        for (int[] restriction : restrictions) {\n            friends.get(restriction[0]).add(restriction[1]);\n            friends.get(restriction[1]).add(restriction[0]);\n        }\n\n        boolean[] result = new boolean[requests.length];\n        for (int i = 0; i < requests.length; i++) {\n            int a = requests[i][0];\n            int b = requests[i][1];\n            if (!friends.get(a).contains(b) && !friends.get(b).contains(a)) {\n                friends.get(a).add(b);\n                friends.get(b).add(a);\n                result[i] = true;\n            } else {\n                result[i] = false;\n            }\n        }\n        return result;\n    }\n}\n```\n    \n    First, we create a `friends` list (array or collection depending on the language) to store friendship restrictions for each person in the network. Then, we iterate through the `restrictions` array, adding each restriction to both the xi and yi person's restricted friends.\n\nNext, we create a `result` array to store the boolean outcomes of the friend requests. We iterate through the `requests` array and check if the friendship request violates any of the restrictions. If it doesn't, we add the requested friendship to the friend lists of both persons and set the request outcome to `true`. If it does violate a restriction, we set the request outcome to `false`.\n\nFinally, we return the `result` array.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef check_friends(n, restrictions, requests):\n    friends = defaultdict(set)\n    for a, b in restrictions:\n        friends[a].add(b)\n        friends[b].add(a)\n\n    result = []\n    for a, b in requests:\n        if b not in friends[a] and a not in friends[b]:\n            friends[a].add(b)\n            friends[b].add(a)\n            result.append(True)\n        else:\n            result.append(False)\n    return result\n```\n    \n    First, we create a `friends` list (array or collection depending on the language) to store friendship restrictions for each person in the network. Then, we iterate through the `restrictions` array, adding each restriction to both the xi and yi person's restricted friends.\n\nNext, we create a `result` array to store the boolean outcomes of the friend requests. We iterate through the `requests` array and check if the friendship request violates any of the restrictions. If it doesn't, we add the requested friendship to the friend lists of both persons and set the request outcome to `true`. If it does violate a restriction, we set the request outcome to `false`.\n\nFinally, we return the `result` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<bool> checkFriends(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\n    vector<unordered_set<int>> friends(n);\n    for (auto& restriction : restrictions) {\n        friends[restriction[0]].insert(restriction[1]);\n        friends[restriction[1]].insert(restriction[0]);\n    }\n\n    vector<bool> result(requests.size());\n    for (int i = 0; i < requests.size(); i++) {\n        int a = requests[i][0];\n        int b = requests[i][1];\n        if (friends[a].count(b) == 0 && friends[b].count(a) == 0) {\n            friends[a].insert(b);\n            friends[b].insert(a);\n            result[i] = true;\n        } else {\n            result[i] = false;\n        }\n    }\n    return result;\n}\n```\n    \n    First, we create a `friends` list (array or collection depending on the language) to store friendship restrictions for each person in the network. Then, we iterate through the `restrictions` array, adding each restriction to both the xi and yi person's restricted friends.\n\nNext, we create a `result` array to store the boolean outcomes of the friend requests. We iterate through the `requests` array and check if the friendship request violates any of the restrictions. If it doesn't, we add the requested friendship to the friend lists of both persons and set the request outcome to `true`. If it does violate a restriction, we set the request outcome to `false`.\n\nFinally, we return the `result` array.\n    ",
        "js": "\n    ```javascript\nfunction checkFriends(n, restrictions, requests) {\n    const friends = new Array(n).fill(null).map(() => new Set());\n    for (const restriction of restrictions) {\n        friends[restriction[0]].add(restriction[1]);\n        friends[restriction[1]].add(restriction[0]);\n    }\n\n    const result = [];\n    for (const request of requests) {\n        const a = request[0];\n        const b = request[1];\n        if (!friends[a].has(b) && !friends[b].has(a)) {\n            friends[a].add(b);\n            friends[b].add(a);\n            result.push(true);\n        } else {\n            result.push(false);\n        }\n    }\n    return result;\n}\n```\n    \n    First, we create a `friends` list (array or collection depending on the language) to store friendship restrictions for each person in the network. Then, we iterate through the `restrictions` array, adding each restriction to both the xi and yi person's restricted friends.\n\nNext, we create a `result` array to store the boolean outcomes of the friend requests. We iterate through the `requests` array and check if the friendship request violates any of the restrictions. If it doesn't, we add the requested friendship to the friend lists of both persons and set the request outcome to `true`. If it does violate a restriction, we set the request outcome to `false`.\n\nFinally, we return the `result` array.\n    "
    },
    {
        "id": 332,
        "title": "Distance to a Cycle in Undirected Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a positive integer `n` representing the number of nodes in a **connected undirected graph** containing **exactly one** cycle. The nodes are numbered from `0` to `n - 1` (**inclusive**).\n\nYou are also given a 2D integer array `edges`, where `edges[i] = [node1i, node2i]` denotes that there is a **bidirectional** edge connecting `node1i` and `node2i` in the graph.\n\nThe distance between two nodes `a` and `b` is defined to be the **minimum** number of edges that are needed to go from `a` to `b`.\n\nReturn _an integer array `answer`_ _of size_ `n`_, where_ `answer[i]` _is the **minimum** distance between the_ `ith` _node and **any** node in the cycle._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[1,2\\],\\[2,4\\],\\[4,3\\],\\[3,1\\],\\[0,1\\],\\[5,2\\],\\[6,5\\]\\]\n**Output:** \\[1,0,0,0,0,1,2\\]\n**Explanation:**\nThe nodes 1, 2, 3, and 4 form the cycle.\nThe distance from 0 to 1 is 1.\nThe distance from 1 to 1 is 0.\nThe distance from 2 to 2 is 0.\nThe distance from 3 to 3 is 0.\nThe distance from 4 to 4 is 0.\nThe distance from 5 to 2 is 1.\nThe distance from 6 to 2 is 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 9, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\],\\[2,6\\],\\[6,7\\],\\[6,8\\],\\[0,3\\],\\[3,4\\],\\[3,5\\]\\]\n**Output:** \\[0,0,0,1,2,2,1,2,2\\]\n**Explanation:**\nThe nodes 0, 1, and 2 form the cycle.\nThe distance from 0 to 0 is 0.\nThe distance from 1 to 1 is 0.\nThe distance from 2 to 2 is 0.\nThe distance from 3 to 1 is 1.\nThe distance from 4 to 1 is 2.\nThe distance from 5 to 1 is 2.\nThe distance from 6 to 2 is 1.\nThe distance from 7 to 2 is 2.\nThe distance from 8 to 2 is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= n <= 105`\n*   `edges.length == n`\n*   `edges[i].length == 2`\n*   `0 <= node1i, node2i <= n - 1`\n*   `node1i != node2i`\n*   The graph is connected.\n*   The graph has exactly one cycle.\n*   There is at most one edge between any pair of vertices.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "7,[[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]",
                "output": "[1,0,0,0,0,1,2]"
            },
            {
                "input": "9,[[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]",
                "output": "[0,0,0,1,2,2,1,2,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int[] largestSumSequence(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);\n    \n    for (int num : nums) {\n        minHeap.offer(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n    \n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = minHeap.poll();\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses a min-heap of size `k` to keep track of the largest `k` elements in the input array. It iterates through the array, pushing each element to the heap. If the heap has more than `k` elements, it pops the smallest element. After processing all elements, the min-heap contains the desired subsequence having the largest sum, and we just need to transform the heap back to an array with the same order of elements.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef largest_sum_sequence(nums, k):\n    min_heap = []\n    \n    for num in nums:\n        heapq.heappush(min_heap, num)\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    \n    result = [0] * k\n    for i in range(k-1, -1, -1):\n        result[i] = heapq.heappop(min_heap)\n    \n    return result\n```\n    \n    The algorithm uses a min-heap of size `k` to keep track of the largest `k` elements in the input array. It iterates through the array, pushing each element to the heap. If the heap has more than `k` elements, it pops the smallest element. After processing all elements, the min-heap contains the desired subsequence having the largest sum, and we just need to transform the heap back to an array with the same order of elements.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nstd::vector<int> largestSumSequence(std::vector<int>& nums, int k) {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    \n    for (int num : nums) {\n        min_heap.push(num);\n        if (min_heap.size() > k) {\n            min_heap.pop();\n        }\n    }\n    \n    std::vector<int> result(min_heap.size());\n    while (!min_heap.empty()) {\n        result[min_heap.size() - 1] = min_heap.top();\n        min_heap.pop();\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses a min-heap of size `k` to keep track of the largest `k` elements in the input array. It iterates through the array, pushing each element to the heap. If the heap has more than `k` elements, it pops the smallest element. After processing all elements, the min-heap contains the desired subsequence having the largest sum, and we just need to transform the heap back to an array with the same order of elements.\n    ",
        "js": "\n    ```javascript\nfunction largestSumSequence(nums, k) {\n    const minHeap = new MinHeap();\n\n    for (const num of nums) {\n        minHeap.push(num);\n        if (minHeap.getSize() > k) {\n            minHeap.pop();\n        }\n    }\n\n    const result = new Array(k);\n    for (let i = k - 1; i >= 0; i--) {\n        result[i] = minHeap.pop();\n    }\n\n    return result;\n}\n\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    push(num) {\n        this.heap.push(num);\n        this.bubbleUp(this.heap.length - 1);\n    }\n\n    pop() {\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return min;\n    }\n\n    getSize() {\n        return this.heap.length;\n    }\n\n    bubbleUp(index) {\n        while (index > 0 && this.heap[index] < this.heap[Math.floor((index - 1) / 2)]) {\n            this.swap(index, Math.floor((index - 1) / 2));\n            index = Math.floor((index - 1) / 2);\n        }\n    }\n\n    bubbleDown(index) {\n        while (2 * index + 1 < this.heap.length) {\n            let minIndex = 2 * index + 1;\n            if (2 * index + 2 < this.heap.length && this.heap[minIndex] > this.heap[2 * index + 2]) {\n                minIndex = 2 * index + 2;\n            }\n            if (this.heap[index] > this.heap[minIndex]) {\n                this.swap(index, minIndex);\n                index = minIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    swap(i, j) {\n        const tmp = this.heap[i];\n        this.heap[i] = this.heap[j];\n        this.heap[j] = tmp;\n    }\n}\n```\n    \n    The algorithm uses a min-heap of size `k` to keep track of the largest `k` elements in the input array. It iterates through the array, pushing each element to the heap. If the heap has more than `k` elements, it pops the smallest element. After processing all elements, the min-heap contains the desired subsequence having the largest sum, and we just need to transform the heap back to an array with the same order of elements.\n    "
    },
    {
        "id": 333,
        "title": "Minimum Health to Beat Game",
        "difficulty": "Medium",
        "content": {
            "problem": "You are playing a game that has `n` levels numbered from `0` to `n - 1`. You are given a **0-indexed** integer array `damage` where `damage[i]` is the amount of health you will lose to complete the `ith` level.\n\nYou are also given an integer `armor`. You may use your armor ability **at most once** during the game on **any** level which will protect you from **at most** `armor` damage.\n\nYou must complete the levels in order and your health must be **greater than** `0` at all times to beat the game.\n\nReturn _the **minimum** health you need to start with to beat the game._",
            "examples": [
                "**Example 1:**\n\n**Input:** damage = \\[2,7,4,3\\], armor = 4\n**Output:** 13\n**Explanation:** One optimal way to beat the game starting at 13 health is:\nOn round 1, take 2 damage. You have 13 - 2 = 11 health.\nOn round 2, take 7 damage. You have 11 - 7 = 4 health.\nOn round 3, use your armor to protect you from 4 damage. You have 4 - 0 = 4 health.\nOn round 4, take 3 damage. You have 4 - 3 = 1 health.\nNote that 13 is the minimum health you need to start with to beat the game.\n\n",
                "**Example 2:**\n\n**Input:** damage = \\[2,5,3,4\\], armor = 7\n**Output:** 10\n**Explanation:** One optimal way to beat the game starting at 10 health is:\nOn round 1, take 2 damage. You have 10 - 2 = 8 health.\nOn round 2, use your armor to protect you from 5 damage. You have 8 - 0 = 8 health.\nOn round 3, take 3 damage. You have 8 - 3 = 5 health.\nOn round 4, take 4 damage. You have 5 - 4 = 1 health.\nNote that 10 is the minimum health you need to start with to beat the game.\n\n",
                "**Example 3:**\n\n**Input:** damage = \\[3,3,3\\], armor = 0\n**Output:** 10\n**Explanation:** One optimal way to beat the game starting at 10 health is:\nOn round 1, take 3 damage. You have 10 - 3 = 7 health.\nOn round 2, take 3 damage. You have 7 - 3 = 4 health.\nOn round 3, take 3 damage. You have 4 - 3 = 1 health.\nNote that you did not use your armor ability."
            ],
            "constraints": "**Constraints:**\n\n*   `n == damage.length`\n*   `1 <= n <= 105`\n*   `0 <= damage[i] <= 105`\n*   `0 <= armor <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,7,4,3],4",
                "output": "13"
            },
            {
                "input": "[2,5,3,4],7",
                "output": "10"
            },
            {
                "input": "[3,3,3],0",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int minHealth(int[] damage, int armor) {\n    int health = 0;\n    for (int i = damage.length - 1; i >= 0; --i) {\n        health += damage[i];\n        if (health > armor) {\n            health -= armor;\n            armor = 0;\n        }\n    }\n    return health + 1;\n}\n```\n    \n    We will iterate through the damage array in reverse, starting from the last element (i.e., the last level) to compute the minimum health required to complete the game.\n\nIn each step, we will add the damage[i] to the health. If the current health is greater than the value of armor, we subtract the armor value from the health and set the armor value to 0 since it can be used only once.\n\nAfter iterating through all the damage array elements, we add 1 to the health value and return it as the minimum health required to beat the game.\n    ",
        "python": "\n    ```python\ndef min_health(damage, armor):\n    health = 0\n    for dmg in reversed(damage):\n        health += dmg\n        if health > armor:\n            health -= armor\n            armor = 0\n    return health + 1\n```\n    \n    We will iterate through the damage array in reverse, starting from the last element (i.e., the last level) to compute the minimum health required to complete the game.\n\nIn each step, we will add the damage[i] to the health. If the current health is greater than the value of armor, we subtract the armor value from the health and set the armor value to 0 since it can be used only once.\n\nAfter iterating through all the damage array elements, we add 1 to the health value and return it as the minimum health required to beat the game.\n    ",
        "c++": "\n    ```cpp\nint min_health(int damage[], int n, int armor) {\n    int health = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        health += damage[i];\n        if (health > armor) {\n            health -= armor;\n            armor = 0;\n        }\n    }\n    return health + 1;\n}\n```\n    \n    We will iterate through the damage array in reverse, starting from the last element (i.e., the last level) to compute the minimum health required to complete the game.\n\nIn each step, we will add the damage[i] to the health. If the current health is greater than the value of armor, we subtract the armor value from the health and set the armor value to 0 since it can be used only once.\n\nAfter iterating through all the damage array elements, we add 1 to the health value and return it as the minimum health required to beat the game.\n    ",
        "js": "\n    ```javascript\nfunction minHealth(damage, armor) {\n    let health = 0;\n    for (let i = damage.length - 1; i >= 0; --i) {\n        health += damage[i];\n        if (health > armor) {\n            health -= armor;\n            armor = 0;\n        }\n    }\n    return health + 1;\n}\n```\n    \n    We will iterate through the damage array in reverse, starting from the last element (i.e., the last level) to compute the minimum health required to complete the game.\n\nIn each step, we will add the damage[i] to the health. If the current health is greater than the value of armor, we subtract the armor value from the health and set the armor value to 0 since it can be used only once.\n\nAfter iterating through all the damage array elements, we add 1 to the health value and return it as the minimum health required to beat the game.\n    "
    },
    {
        "id": 334,
        "title": "Maximum Sum Score of Array",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` of length `n`.\n\nThe **sum** **score** of `nums` at an index `i` where `0 <= i < n` is the **maximum** of:\n\n*   The sum of the **first** `i + 1` elements of `nums`.\n*   The sum of the **last** `n - i` elements of `nums`.\n\nReturn _the **maximum** **sum** **score** of_ `nums` _at any index._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,-2,5\\]\n**Output:** 10\n**Explanation:**\nThe sum score at index 0 is max(4, 4 + 3 + -2 + 5) = max(4, 10) = 10.\nThe sum score at index 1 is max(4 + 3, 3 + -2 + 5) = max(7, 6) = 7.\nThe sum score at index 2 is max(4 + 3 + -2, -2 + 5) = max(5, 3) = 5.\nThe sum score at index 3 is max(4 + 3 + -2 + 5, 5) = max(10, 5) = 10.\nThe maximum sum score of nums is 10.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-3,-5\\]\n**Output:** -3\n**Explanation:**\nThe sum score at index 0 is max(-3, -3 + -5) = max(-3, -8) = -3.\nThe sum score at index 1 is max(-3 + -5, -5) = max(-8, -5) = -5.\nThe maximum sum score of nums is -3."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,3,-2,5]",
                "output": "10"
            },
            {
                "input": "[-3,-5]",
                "output": "-3"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int maxWordsInSentence(ArrayList<String> sentences) {\n    int maxWords = 0;\n    for (String sentence : sentences) {\n        String[] words = sentence.split(\" \");\n        maxWords = Math.max(maxWords, words.length);\n    }\n    return maxWords;\n}\n```\n    \n    The algorithm is simple and common across all languages.\n\n1. Initialize a variable `maxWords` to store the maximum number of words found so far, initially set to 0.\n2. Loop through the given sentences in the list/array:\n   a. For each sentence, split it into words using space as a delimiter.\n   b. Count the number of words (`words`) in the sentence.\n   c. Update `maxWords` by taking the maximum of `maxWords` and `words` count of the current sentence.\n3. Return `maxWords` after iterating through all sentences.\n\nThe algorithm has a time complexity of O(N * M), where N is the number of sentences and M is the average number of words per sentence (because string split or stream operations take O(M) time).\n    ",
        "python": "\n    ```python\ndef max_words_in_sentence(sentences):\n    max_words = 0\n    for sentence in sentences:\n        words = len(sentence.split())\n        max_words = max(max_words, words)\n    return max_words\n```\n    \n    The algorithm is simple and common across all languages.\n\n1. Initialize a variable `maxWords` to store the maximum number of words found so far, initially set to 0.\n2. Loop through the given sentences in the list/array:\n   a. For each sentence, split it into words using space as a delimiter.\n   b. Count the number of words (`words`) in the sentence.\n   c. Update `maxWords` by taking the maximum of `maxWords` and `words` count of the current sentence.\n3. Return `maxWords` after iterating through all sentences.\n\nThe algorithm has a time complexity of O(N * M), where N is the number of sentences and M is the average number of words per sentence (because string split or stream operations take O(M) time).\n    ",
        "c++": "\n    ```cpp\n#include<string>\n#include<vector>\n#include<sstream>\nint maxWordsInSentence(std::vector<std::string>& sentences) {\n    int maxWords = 0;\n    for (const std::string& sentence : sentences) {\n        std::istringstream iss(sentence);\n        int words = 0;\n        std::string word;\n        while (iss >> word) {\n            words++;\n        }\n        maxWords = std::max(maxWords, words);\n    }\n    return maxWords;\n}\n```\n    \n    The algorithm is simple and common across all languages.\n\n1. Initialize a variable `maxWords` to store the maximum number of words found so far, initially set to 0.\n2. Loop through the given sentences in the list/array:\n   a. For each sentence, split it into words using space as a delimiter.\n   b. Count the number of words (`words`) in the sentence.\n   c. Update `maxWords` by taking the maximum of `maxWords` and `words` count of the current sentence.\n3. Return `maxWords` after iterating through all sentences.\n\nThe algorithm has a time complexity of O(N * M), where N is the number of sentences and M is the average number of words per sentence (because string split or stream operations take O(M) time).\n    ",
        "js": "\n    ```javascript\nfunction maxWordsInSentence(sentences) {\n    let maxWords = 0;\n    for (let sentence of sentences) {\n        let words = sentence.split(\" \");\n        maxWords = Math.max(maxWords, words.length);\n    }\n    return maxWords;\n}\n```\n    \n    The algorithm is simple and common across all languages.\n\n1. Initialize a variable `maxWords` to store the maximum number of words found so far, initially set to 0.\n2. Loop through the given sentences in the list/array:\n   a. For each sentence, split it into words using space as a delimiter.\n   b. Count the number of words (`words`) in the sentence.\n   c. Update `maxWords` by taking the maximum of `maxWords` and `words` count of the current sentence.\n3. Return `maxWords` after iterating through all sentences.\n\nThe algorithm has a time complexity of O(N * M), where N is the number of sentences and M is the average number of words per sentence (because string split or stream operations take O(M) time).\n    "
    },
    {
        "id": 335,
        "title": "Check if an Array Is Consecutive",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `true` _if_ `nums` _is **consecutive**, otherwise return_ `false`_._\n\nAn array is **consecutive** if it contains every number in the range `[x, x + n - 1]` (**inclusive**), where `x` is the minimum number in the array and `n` is the length of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,4,2\\]\n**Output:** true\n**Explanation:**\nThe minimum value is 1 and the length of nums is 4.\nAll of the values in the range \\[x, x + n - 1\\] = \\[1, 1 + 4 - 1\\] = \\[1, 4\\] = (1, 2, 3, 4) occur in nums.\nTherefore, nums is consecutive.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3\\]\n**Output:** false\n**Explanation:**\nThe minimum value is 1 and the length of nums is 2.\nThe value 2 in the range \\[x, x + n - 1\\] = \\[1, 1 + 2 - 1\\], = \\[1, 2\\] = (1, 2) does not occur in nums.\nTherefore, nums is not consecutive.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,5,4\\]\n**Output:** true\n**Explanation:**\nThe minimum value is 3 and the length of nums is 3.\nAll of the values in the range \\[x, x + n - 1\\] = \\[3, 3 + 3 - 1\\] = \\[3, 5\\] = (3, 4, 5) occur in nums.\nTherefore, nums is consecutive."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,3,4,2]",
                "output": "true"
            },
            {
                "input": "[1,3]",
                "output": "false"
            },
            {
                "input": "[3,5,4]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxFruits(int[][] fruits, int startPos, int k) {\n    int n = fruits.length;\n    int[] left = new int[n + 1], right = new int[n + 1];\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        while (j < n && fruits[j][0] - fruits[i][0] <= k) {\n            right[i + 1] += fruits[j][1];\n            j++;\n        }\n        right[i + 1] += right[i];\n        if (j < n && fruits[j][0] - startPos <= k) {\n            right[0] += fruits[j][1];\n            j++;\n        }\n    }\n\n    j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n        while (j >= 0 && fruits[j][0] - fruits[i][0] <= k) {\n            left[i] += fruits[j][1];\n            j--;\n        }\n        left[i] += left[i + 1];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int rest = Math.max(0, k - Math.abs(fruits[i][0] - startPos));\n        int idx = Arrays.binarySearch(fruits, i, n, new int[]{fruits[i][0] + rest, Integer.MIN_VALUE}, (a, b) -> a[0] - b[0]);\n        if (idx < 0) idx = ~idx;\n        ans = Math.max(ans, left[i] + right[idx]);\n    }\n    return ans;\n}\n```\n\n    \n    1. Create left and right arrays of size n+1 filled with zeros, to store the cumulative fruits at each position.\n2. Initialize a cursor j with value 0.\n3. Iterate the fruits array and populate the right array with total fruits in the range of k units.\n4. Then populate the left array with the remaining fruits by iterating the array in reverse order.\n5. Initialize an answer variable, ans, to 0.\n6. Iterate the fruits array again, calculating the remaining steps after reaching a position and using a binary search technique (in each language) to find the index of the next fruit that can be reached. Update ans with the maximum sum of fruit harvest.\n7. Finally, return ans as the solution.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef maxFruits(fruits, startPos, k):\n    n = len(fruits)\n    left, right = [0] * (n + 1), [0] * (n + 1)\n    j = 0\n\n    for i in range(n):\n        while j < n and fruits[j][0] - fruits[i][0] <= k:\n            right[i + 1] += fruits[j][1]\n            j += 1\n        right[i + 1] += right[i]\n        if j < n and fruits[j][0] - startPos <= k:\n            right[0] += fruits[j][1]\n            j += 1\n\n    j = n - 1\n    for i in range(n - 1, -1, -1):\n        while j >= 0 and fruits[j][0] - fruits[i][0] <= k:\n            left[i] += fruits[j][1]\n            j -= 1\n        left[i] += left[i + 1]\n\n    ans = 0\n    for i in range(n):\n        rest = max(0, k - abs(fruits[i][0] - startPos))\n        idx = bisect_left(fruits, [fruits[i][0] + rest, 0])\n        ans = max(ans, left[i] + right[idx])\n\n    return ans\n```\n\n    \n    1. Create left and right arrays of size n+1 filled with zeros, to store the cumulative fruits at each position.\n2. Initialize a cursor j with value 0.\n3. Iterate the fruits array and populate the right array with total fruits in the range of k units.\n4. Then populate the left array with the remaining fruits by iterating the array in reverse order.\n5. Initialize an answer variable, ans, to 0.\n6. Iterate the fruits array again, calculating the remaining steps after reaching a position and using a binary search technique (in each language) to find the index of the next fruit that can be reached. Update ans with the maximum sum of fruit harvest.\n7. Finally, return ans as the solution.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxFruits(vector<vector<int>>& fruits, int startPos, int k) {\n    int n = fruits.size();\n    vector<int> left(n + 1, 0), right(n + 1, 0);\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        while (j < n && fruits[j][0] - fruits[i][0] <= k) {\n            right[i + 1] += fruits[j][1];\n            j++;\n        }\n        right[i + 1] += right[i];\n        if (j < n && fruits[j][0] - startPos <= k) {\n            right[0] += fruits[j][1];\n            j++;\n        }\n    }\n\n    j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n        while (j >= 0 && fruits[j][0] - fruits[i][0] <= k) {\n            left[i] += fruits[j][1];\n            j--;\n        }\n        left[i] += left[i + 1];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int rest = max(0, k - abs(fruits[i][0] - startPos));\n        int idx = upper_bound(fruits.begin(), fruits.end(), vector<int>{fruits[i][0] + rest, 0}) - fruits.begin();\n        ans = max(ans, left[i] + right[idx]);\n    }\n    return ans;\n}\n```\n\n    \n    1. Create left and right arrays of size n+1 filled with zeros, to store the cumulative fruits at each position.\n2. Initialize a cursor j with value 0.\n3. Iterate the fruits array and populate the right array with total fruits in the range of k units.\n4. Then populate the left array with the remaining fruits by iterating the array in reverse order.\n5. Initialize an answer variable, ans, to 0.\n6. Iterate the fruits array again, calculating the remaining steps after reaching a position and using a binary search technique (in each language) to find the index of the next fruit that can be reached. Update ans with the maximum sum of fruit harvest.\n7. Finally, return ans as the solution.\n    ",
        "js": "\n    ```javascript\nfunction maxFruits(fruits, startPos, k) {\n    const n = fruits.length;\n    const left = new Array(n + 1).fill(0);\n    const right = new Array(n + 1).fill(0);\n    let j = 0;\n\n    for (let i = 0; i < n; i++) {\n        while (j < n && fruits[j][0] - fruits[i][0] <= k) {\n            right[i + 1] += fruits[j][1];\n            j++;\n        }\n        right[i + 1] += right[i];\n        if (j < n && fruits[j][0] - startPos <= k) {\n            right[0] += fruits[j][1];\n            j++;\n        }\n    }\n\n    j = n - 1;\n    for (let i = n - 1; i >= 0; i--) {\n        while (j >= 0 && fruits[j][0] - fruits[i][0] <= k) {\n            left[i] += fruits[j][1];\n            j--;\n        }\n        left[i] += left[i + 1];\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        const rest = Math.max(0, k - Math.abs(fruits[i][0] - startPos));\n        const idx = fruits.findIndex((a) => a[0] >= fruits[i][0] + rest);\n        ans = Math.max(ans, left[i] + right[(idx === -1) ? n : idx]);\n    }\n\n    return ans;\n}\n```\n\n    \n    1. Create left and right arrays of size n+1 filled with zeros, to store the cumulative fruits at each position.\n2. Initialize a cursor j with value 0.\n3. Iterate the fruits array and populate the right array with total fruits in the range of k units.\n4. Then populate the left array with the remaining fruits by iterating the array in reverse order.\n5. Initialize an answer variable, ans, to 0.\n6. Iterate the fruits array again, calculating the remaining steps after reaching a position and using a binary search technique (in each language) to find the index of the next fruit that can be reached. Update ans with the maximum sum of fruit harvest.\n7. Finally, return ans as the solution.\n    "
    },
    {
        "id": 336,
        "title": "Count Positions on Street With Required Brightness",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `n`. A perfectly straight street is represented by a number line ranging from `0` to `n - 1`. You are given a 2D integer array `lights` representing the street lamp(s) on the street. Each `lights[i] = [positioni, rangei]` indicates that there is a street lamp at position `positioni` that lights up the area from `[max(0, positioni - rangei), min(n - 1, positioni + rangei)]` (**inclusive**).\n\nThe **brightness** of a position `p` is defined as the number of street lamps that light up the position `p`. You are given a **0-indexed** integer array `requirement` of size `n` where `requirement[i]` is the minimum **brightness** of the `ith` position on the street.\n\nReturn _the number of positions_ `i` _on the street between_ `0` _and_ `n - 1` _that have a **brightness**_ _of **at least**_ `requirement[i]`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, lights = \\[\\[0,1\\],\\[2,1\\],\\[3,2\\]\\], requirement = \\[0,2,1,4,1\\]\n**Output:** 4\n**Explanation:**\n- The first street lamp lights up the area from \\[max(0, 0 - 1), min(n - 1, 0 + 1)\\] = \\[0, 1\\] (inclusive).\n- The second street lamp lights up the area from \\[max(0, 2 - 1), min(n - 1, 2 + 1)\\] = \\[1, 3\\] (inclusive).\n- The third street lamp lights up the area from \\[max(0, 3 - 2), min(n - 1, 3 + 2)\\] = \\[1, 4\\] (inclusive).\n\n- Position 0 is covered by the first street lamp. It is covered by 1 street lamp which is greater than requirement\\[0\\].\n- Position 1 is covered by the first, second, and third street lamps. It is covered by 3 street lamps which is greater than requirement\\[1\\].\n- Position 2 is covered by the second and third street lamps. It is covered by 2 street lamps which is greater than requirement\\[2\\].\n- Position 3 is covered by the second and third street lamps. It is covered by 2 street lamps which is less than requirement\\[3\\].\n- Position 4 is covered by the third street lamp. It is covered by 1 street lamp which is equal to requirement\\[4\\].\n\nPositions 0, 1, 2, and 4 meet the requirement so we return 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, lights = \\[\\[0,1\\]\\], requirement = \\[2\\]\n**Output:** 0\n**Explanation:**\n- The first street lamp lights up the area from \\[max(0, 0 - 1), min(n - 1, 0 + 1)\\] = \\[0, 0\\] (inclusive).\n- Position 0 is covered by the first street lamp. It is covered by 1 street lamp which is less than requirement\\[0\\].\n- We return 0 because no position meets their brightness requirement."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= lights.length <= 105`\n*   `0 <= positioni < n`\n*   `0 <= rangei <= 105`\n*   `requirement.length == n`\n*   `0 <= requirement[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,1],[2,1],[3,2]],[0,2,1,4,1]",
                "output": "4"
            },
            {
                "input": "1,[[0,1]],[2]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int longestPalindrome(String[] words) {\n    HashMap<Character, Integer> dict = new HashMap<>();\n    int result = 0;\n    boolean hasOdd = false;\n\n    for (String word : words) {\n        dict.put(word.charAt(0), dict.getOrDefault(word.charAt(0), 0) + 1);\n        dict.put(word.charAt(1), dict.getOrDefault(word.charAt(1), 0) + 1);\n    }\n\n    for (Map.Entry<Character, Integer> entry : dict.entrySet()) {\n        result += entry.getValue() / 2 * 2;\n        hasOdd |= entry.getValue() % 2 == 1;\n    }\n\n    return result + (hasOdd ? 1 : 0);\n}\n```\n    \n    1. Create an empty dictionary `dict` to store counts of characters.\n2. Initialize `result` to 0 and set `has_odd` to false.\n3. Iterate through the input `words` and count the occurrences of characters by updating the `dict`.\n4. Iterate through the values of the `dict`. For each value, add the largest even number less than or equal to the value to `result`. If the current value is odd, set `has_odd` to true.\n5. If `has_odd` is true, increment `result` by 1.\n6. Return `result` as the length of the longest palindrome.\n    ",
        "python": "\n    ```python\ndef longest_palindrome(words):\n    from collections import defaultdict\n    dict = defaultdict(int)\n    result = 0\n    has_odd = False\n\n    for word in words:\n        dict[word[0]] += 1\n        dict[word[1]] += 1\n\n    for count in dict.values():\n        result += count // 2 * 2\n        has_odd |= count % 2\n\n    return result + has_odd\n```\n    \n    1. Create an empty dictionary `dict` to store counts of characters.\n2. Initialize `result` to 0 and set `has_odd` to false.\n3. Iterate through the input `words` and count the occurrences of characters by updating the `dict`.\n4. Iterate through the values of the `dict`. For each value, add the largest even number less than or equal to the value to `result`. If the current value is odd, set `has_odd` to true.\n5. If `has_odd` is true, increment `result` by 1.\n6. Return `result` as the length of the longest palindrome.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint longest_palindrome(std::vector<std::string>& words) {\n    std::unordered_map<char, int> dict;\n    int result = 0;\n    bool has_odd = false;\n\n    for (const auto& word : words) {\n        dict[word[0]]++;\n        dict[word[1]]++;\n    }\n\n    for (const auto& pair : dict) {\n        result += pair.second / 2 * 2;\n        has_odd |= pair.second % 2;\n    }\n\n    return result + has_odd;\n}\n```\n    \n    1. Create an empty dictionary `dict` to store counts of characters.\n2. Initialize `result` to 0 and set `has_odd` to false.\n3. Iterate through the input `words` and count the occurrences of characters by updating the `dict`.\n4. Iterate through the values of the `dict`. For each value, add the largest even number less than or equal to the value to `result`. If the current value is odd, set `has_odd` to true.\n5. If `has_odd` is true, increment `result` by 1.\n6. Return `result` as the length of the longest palindrome.\n    ",
        "js": "\n    ```javascript\nfunction longestPalindrome(words) {\n    let dict = {};\n    let result = 0;\n    let hasOdd = false;\n\n    for (let word of words) {\n        dict[word[0]] = (dict[word[0]] || 0) + 1;\n        dict[word[1]] = (dict[word[1]] || 0) + 1;\n    }\n\n    for (let count of Object.values(dict)) {\n        result += Math.floor(count / 2) * 2;\n        hasOdd |= count % 2;\n    }\n\n    return result + (hasOdd ? 1 : 0);\n}\n```\n\n    \n    1. Create an empty dictionary `dict` to store counts of characters.\n2. Initialize `result` to 0 and set `has_odd` to false.\n3. Iterate through the input `words` and count the occurrences of characters by updating the `dict`.\n4. Iterate through the values of the `dict`. For each value, add the largest even number less than or equal to the value to `result`. If the current value is odd, set `has_odd` to true.\n5. If `has_odd` is true, increment `result` by 1.\n6. Return `result` as the length of the longest palindrome.\n    "
    },
    {
        "id": 337,
        "title": "Maximum Cost of Trip With K Highways",
        "difficulty": "Hard",
        "content": {
            "problem": "A series of highways connect `n` cities numbered from `0` to `n - 1`. You are given a 2D integer array `highways` where `highways[i] = [city1i, city2i, tolli]` indicates that there is a highway that connects `city1i` and `city2i`, allowing a car to go from `city1i` to `city2i` and **vice versa** for a cost of `tolli`.\n\nYou are also given an integer `k`. You are going on a trip that crosses **exactly** `k` highways. You may start at any city, but you may only visit each city **at most** once during your trip.\n\nReturn _the **maximum** cost of your trip. If there is no trip that meets the requirements, return_ `-1`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, highways = \\[\\[0,1,4\\],\\[2,1,3\\],\\[1,4,11\\],\\[3,2,3\\],\\[3,4,2\\]\\], k = 3\n**Output:** 17\n**Explanation:**\nOne possible trip is to go from 0 -> 1 -> 4 -> 3. The cost of this trip is 4 + 11 + 2 = 17.\nAnother possible trip is to go from 4 -> 1 -> 2 -> 3. The cost of this trip is 11 + 3 + 3 = 17.\nIt can be proven that 17 is the maximum possible cost of any valid trip.\n\nNote that the trip 4 -> 1 -> 0 -> 1 is not allowed because you visit the city 1 twice.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, highways = \\[\\[0,1,3\\],\\[2,3,2\\]\\], k = 2\n**Output:** -1\n**Explanation:** There are no valid trips of length 2, so return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 15`\n*   `1 <= highways.length <= 50`\n*   `highways[i].length == 3`\n*   `0 <= city1i, city2i <= n - 1`\n*   `city1i != city2i`\n*   `0 <= tolli <= 100`\n*   `1 <= k <= 50`\n*   There are no duplicate highways.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]],3",
                "output": "17"
            },
            {
                "input": "4,[[0,1,3],[2,3,2]],2",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int dfs(int currCity, int remainingHighways, int costSoFar, List<List<Integer>> highways, boolean[] visited) {\n    if (remainingHighways == 0) {\n        return costSoFar;\n    }\n\n    visited[currCity] = true;\n    int maxCost = -1;\n\n    for (List<Integer> highway : highways) {\n        int nextCity = -1;\n        if (highway.get(0) == currCity && !visited[highway.get(1)]) {\n            nextCity = highway.get(1);\n        } else if (highway.get(1) == currCity && !visited[highway.get(0)]) {\n            nextCity = highway.get(0);\n        }\n\n        if (nextCity != -1) {\n            int cost = dfs(nextCity, remainingHighways - 1, costSoFar + highway.get(2), highways, visited);\n            maxCost = Math.max(maxCost, cost);\n        }\n    }\n\n    visited[currCity] = false;\n    return maxCost;\n}\n\npublic int maxCost(int n, List<List<Integer>> highways, int k) {\n    boolean[] visited = new boolean[n];\n    int maxCost = -1;\n\n    for (int i = 0; i < n; i++) {\n        int cost = dfs(i, k, 0, highways, visited);\n        maxCost = Math.max(maxCost, cost);\n    }\n\n    return maxCost;\n}\n```\n    \n    The problem can be solved using a depth-first search (DFS) algorithm. First, create a helper function called `dfs` to traverse the graph formed by the cities and highways. This function takes the current city number, remaining number of highways, cost so far, highways data, and visited cities as its parameters.\n\nIn the DFS function, if the remaining number of highways is 0, return the cost accumulated so far. Iterate through each highway, find the next city, and ensure that it has not been visited already. If a valid next city is found, recursively call the DFS function with the updated cost and remaining highways. Keep track of the maximum cost obtained during each iteration, and return the maximum cost after completing the loop.\n\nFinally, in the main function `maxCost`, initially set the maximum cost to -1. Iterate over each city, and for each city, perform a DFS traversal and find the cost for the trip starting at that city. Update the maximum cost if the calculated cost for the current city is higher than the present maximum cost. Return the maximum cost after iterating through all cities.\n    ",
        "python": "\n    ```python\ndef dfs(curr_city, remaining_highways, cost_so_far, highways, visited):\n    if remaining_highways == 0:\n        return cost_so_far\n\n    visited[curr_city] = True\n    max_cost = -1\n\n    for highway in highways:\n        next_city = -1\n        if highway[0] == curr_city and not visited[highway[1]]:\n            next_city = highway[1]\n        elif highway[1] == curr_city and not visited[highway[0]]:\n            next_city = highway[0]\n\n        if next_city != -1:\n            cost = dfs(next_city, remaining_highways - 1, cost_so_far + highway[2], highways, visited)\n            max_cost = max(max_cost, cost)\n\n    visited[curr_city] = False\n    return max_cost\n\ndef max_cost(n, highways, k):\n    visited = [False] * n\n    max_cost = -1\n\n    for i in range(n):\n        cost = dfs(i, k, 0, highways, visited)\n        max_cost = max(max_cost, cost)\n\n    return max_cost\n```\n    \n    The problem can be solved using a depth-first search (DFS) algorithm. First, create a helper function called `dfs` to traverse the graph formed by the cities and highways. This function takes the current city number, remaining number of highways, cost so far, highways data, and visited cities as its parameters.\n\nIn the DFS function, if the remaining number of highways is 0, return the cost accumulated so far. Iterate through each highway, find the next city, and ensure that it has not been visited already. If a valid next city is found, recursively call the DFS function with the updated cost and remaining highways. Keep track of the maximum cost obtained during each iteration, and return the maximum cost after completing the loop.\n\nFinally, in the main function `maxCost`, initially set the maximum cost to -1. Iterate over each city, and for each city, perform a DFS traversal and find the cost for the trip starting at that city. Update the maximum cost if the calculated cost for the current city is higher than the present maximum cost. Return the maximum cost after iterating through all cities.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint dfs(int curr_city, int remaining_highways, int cost_so_far, vector<vector<int>>& highways, vector<bool>& visited) {\n    if (remaining_highways == 0) {\n        return cost_so_far;\n    }\n\n    visited[curr_city] = true;\n    int max_cost = -1;\n\n    for (vector<int>& highway : highways) {\n        int next_city = -1;\n        if (highway[0] == curr_city && !visited[highway[1]]) {\n            next_city = highway[1];\n        } else if (highway[1] == curr_city && !visited[highway[0]]) {\n            next_city = highway[0];\n        }\n\n        if (next_city != -1) {\n            int cost = dfs(next_city, remaining_highways - 1, cost_so_far + highway[2], highways, visited);\n            max_cost = max(max_cost, cost);\n        }\n    }\n\n    visited[curr_city] = false;\n    return max_cost;\n}\n\nint maxCost(int n, vector<vector<int>>& highways, int k) {\n    vector<bool> visited(n, false);\n    int max_cost = -1;\n\n    for (int i = 0; i < n; i++) {\n        int cost = dfs(i, k, 0, highways, visited);\n        max_cost = max(max_cost, cost);\n    }\n\n    return max_cost;\n}\n```\n    \n    The problem can be solved using a depth-first search (DFS) algorithm. First, create a helper function called `dfs` to traverse the graph formed by the cities and highways. This function takes the current city number, remaining number of highways, cost so far, highways data, and visited cities as its parameters.\n\nIn the DFS function, if the remaining number of highways is 0, return the cost accumulated so far. Iterate through each highway, find the next city, and ensure that it has not been visited already. If a valid next city is found, recursively call the DFS function with the updated cost and remaining highways. Keep track of the maximum cost obtained during each iteration, and return the maximum cost after completing the loop.\n\nFinally, in the main function `maxCost`, initially set the maximum cost to -1. Iterate over each city, and for each city, perform a DFS traversal and find the cost for the trip starting at that city. Update the maximum cost if the calculated cost for the current city is higher than the present maximum cost. Return the maximum cost after iterating through all cities.\n    ",
        "js": "\n    ```javascript\nfunction dfs(currCity, remainingHighways, costSoFar, highways, visited) {\n    if (remainingHighways === 0) {\n        return costSoFar;\n    }\n\n    visited[currCity] = true;\n    let maxCost = -1;\n\n    for (let highway of highways) {\n        let nextCity = -1;\n        if (highway[0] === currCity && !visited[highway[1]]) {\n            nextCity = highway[1];\n        } else if (highway[1] === currCity && !visited[highway[0]]) {\n            nextCity = highway[0];\n        }\n\n        if (nextCity !== -1) {\n            const cost = dfs(nextCity, remainingHighways - 1, costSoFar + highway[2], highways, visited);\n            maxCost = Math.max(maxCost, cost);\n        }\n    }\n\n    visited[currCity] = false;\n    return maxCost;\n}\n\nfunction maxCost(n, highways, k) {\n    const visited = Array(n).fill(false);\n    let maxCost = -1;\n\n    for (let i = 0; i < n; i++) {\n        const cost = dfs(i, k, 0, highways, visited);\n        maxCost = Math.max(maxCost, cost);\n    }\n\n    return maxCost;\n}\n```\n    \n    The problem can be solved using a depth-first search (DFS) algorithm. First, create a helper function called `dfs` to traverse the graph formed by the cities and highways. This function takes the current city number, remaining number of highways, cost so far, highways data, and visited cities as its parameters.\n\nIn the DFS function, if the remaining number of highways is 0, return the cost accumulated so far. Iterate through each highway, find the next city, and ensure that it has not been visited already. If a valid next city is found, recursively call the DFS function with the updated cost and remaining highways. Keep track of the maximum cost obtained during each iteration, and return the maximum cost after completing the loop.\n\nFinally, in the main function `maxCost`, initially set the maximum cost to -1. Iterate over each city, and for each city, perform a DFS traversal and find the cost for the trip starting at that city. Update the maximum cost if the calculated cost for the current city is higher than the present maximum cost. Return the maximum cost after iterating through all cities.\n    "
    },
    {
        "id": 338,
        "title": "Design Video Sharing Platform",
        "difficulty": "Hard",
        "content": {
            "problem": "You have a video sharing platform where users can upload and delete videos. Each `video` is a **string** of digits, where the `ith` digit of the string represents the content of the video at minute `i`. For example, the first digit represents the content at minute `0` in the video, the second digit represents the content at minute `1` in the video, and so on. Viewers of videos can also like and dislike videos. Internally, the platform keeps track of the **number of views, likes, and dislikes** on each video.\n\nWhen a video is uploaded, it is associated with the smallest available integer `videoId` starting from `0`. Once a video is deleted, the `videoId` associated with that video can be reused for another video.\n\nImplement the `VideoSharingPlatform` class:\n\n*   `VideoSharingPlatform()` Initializes the object.\n*   `int upload(String video)` The user uploads a `video`. Return the `videoId` associated with the video.\n*   `void remove(int videoId)` If there is a video associated with `videoId`, remove the video.\n*   `String watch(int videoId, int startMinute, int endMinute)` If there is a video associated with `videoId`, increase the number of views on the video by `1` and return the substring of the video string starting at `startMinute` and ending at `min(endMinute, video.length - 1``)` (**inclusive**). Otherwise, return `\"-1 \"`.\n*   `void like(int videoId)` Increases the number of likes on the video associated with `videoId` by `1` if there is a video associated with `videoId`.\n*   `void dislike(int videoId)` Increases the number of dislikes on the video associated with `videoId` by `1` if there is a video associated with `videoId`.\n*   `int[] getLikesAndDislikes(int videoId)` Return a **0-indexed** integer array `values` of length `2` where `values[0]` is the number of likes and `values[1]` is the number of dislikes on the video associated with `videoId`. If there is no video associated with `videoId`, return `[-1]`.\n*   `int getViews(int videoId)` Return the number of views on the video associated with `videoId`, if there is no video associated with `videoId`, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"VideoSharingPlatform \",  \"upload \",  \"upload \",  \"remove \",  \"remove \",  \"upload \",  \"watch \",  \"watch \",  \"like \",  \"dislike \",  \"dislike \",  \"getLikesAndDislikes \",  \"getViews \"\\]\n\\[\\[\\], \\[ \"123 \"\\], \\[ \"456 \"\\], \\[4\\], \\[0\\], \\[ \"789 \"\\], \\[1, 0, 5\\], \\[1, 0, 1\\], \\[1\\], \\[1\\], \\[1\\], \\[1\\], \\[1\\]\\]\n**Output**\n\\[null, 0, 1, null, null, 0,  \"456 \",  \"45 \", null, null, null, \\[1, 2\\], 2\\]\n\n**Explanation**\nVideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();\nvideoSharingPlatform.upload( \"123 \");          // The smallest available videoId is 0, so return 0.\nvideoSharingPlatform.upload( \"456 \");          // The smallest available `videoId` is 1, so return 1.\nvideoSharingPlatform.remove(4);              // There is no video associated with videoId 4, so do nothing.\nvideoSharingPlatform.remove(0);              // Remove the video associated with videoId 0.\nvideoSharingPlatform.upload( \"789 \");          // Since the video associated with videoId 0 was deleted,\n                                             // 0 is the smallest available `videoId`, so return 0.\nvideoSharingPlatform.watch(1, 0, 5);         // The video associated with videoId 1 is  \"456 \".\n                                             // The video from minute 0 to min(5, 3 - 1) = 2 is  \"456 \", so return  \"453 \".\nvideoSharingPlatform.watch(1, 0, 1);         // The video associated with videoId 1 is  \"456 \".\n                                             // The video from minute 0 to min(1, 3 - 1) = 1 is  \"45 \", so return  \"45 \".\nvideoSharingPlatform.like(1);                // Increase the number of likes on the video associated with videoId 1.\nvideoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.\nvideoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.\nvideoSharingPlatform.getLikesAndDislikes(1); // There is 1 like and 2 dislikes on the video associated with videoId 1, so return \\[1, 2\\].\nvideoSharingPlatform.getViews(1);            // The video associated with videoId 1 has 2 views, so return 2.\n\n",
                "**Example 2:**\n\n**Input**\n\\[ \"VideoSharingPlatform \",  \"remove \",  \"watch \",  \"like \",  \"dislike \",  \"getLikesAndDislikes \",  \"getViews \"\\]\n\\[\\[\\], \\[0\\], \\[0, 0, 1\\], \\[0\\], \\[0\\], \\[0\\], \\[0\\]\\]\n**Output**\n\\[null, null,  \"-1 \", null, null, \\[-1\\], -1\\]\n\n**Explanation**\nVideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();\nvideoSharingPlatform.remove(0);              // There is no video associated with videoId 0, so do nothing.\nvideoSharingPlatform.watch(0, 0, 1);         // There is no video associated with videoId 0, so return  \"-1 \".\nvideoSharingPlatform.like(0);                // There is no video associated with videoId 0, so do nothing.\nvideoSharingPlatform.dislike(0);             // There is no video associated with videoId 0, so do nothing.\nvideoSharingPlatform.getLikesAndDislikes(0); // There is no video associated with videoId 0, so return \\[-1\\].\nvideoSharingPlatform.getViews(0);            // There is no video associated with videoId 0, so return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= video.length <= 105`\n*   The sum of `video.length` over all calls to `upload` does not exceed `105`\n*   `video` consists of digits.\n*   `0 <= videoId <= 105`\n*   `0 <= startMinute < endMinute < 105`\n*   `startMinute < video.length`\n*   The sum of `endMinute - startMinute` over all calls to `watch` does not exceed `105`.\n*   At most `105` calls **in total** will be made to all functions.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],],],],],],],],],],],],]]",
                "output": "**Output**\n[null,0,1,null,null,0,\"456\",\"45\",null,null,null,[1,2],2]"
            },
            {
                "input": "]\n],],],],],],]]",
                "output": "**Output**\n[null,null,\"-1\",null,null,[-1],-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\n\npublic boolean isValidMatrix(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n; ++i) {\n        HashSet<Integer> row = new HashSet<>(), col = new HashSet<>();\n        for (int j = 0; j < n; ++j) {\n            row.add(matrix[i][j]);\n            col.add(matrix[j][i]);\n        }\n        if (row.size() != n || col.size() != n)\n            return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through each row and column of the matrix. For each row and column, we use a set to store the unique elements. Then, we check if the sizes of the row and column sets are equal to the matrix size `n`. If they are not equal, this means that the row or column does not contain all integers from 1 to n (inclusive), and we return false. If the loop completes successfully and all row and column sets have size `n`, the matrix is valid, and we return true.\n    ",
        "python": "\n    ```python\ndef isValidMatrix(matrix):\n    n = len(matrix)\n    for i in range(n):\n        row = set(matrix[i])\n        col = set(matrix[j][i] for j in range(n))\n        if len(row) != n or len(col) != n:\n            return False\n    return True\n```\n    \n    The algorithm iterates through each row and column of the matrix. For each row and column, we use a set to store the unique elements. Then, we check if the sizes of the row and column sets are equal to the matrix size `n`. If they are not equal, this means that the row or column does not contain all integers from 1 to n (inclusive), and we return false. If the loop completes successfully and all row and column sets have size `n`, the matrix is valid, and we return true.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nbool isValidMatrix(std::vector<std::vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n; ++i) {\n        std::unordered_set<int> row, col;\n        for (int j = 0; j < n; ++j) {\n            row.insert(matrix[i][j]);\n            col.insert(matrix[j][i]);\n        }\n        if (row.size() != n || col.size() != n)\n            return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through each row and column of the matrix. For each row and column, we use a set to store the unique elements. Then, we check if the sizes of the row and column sets are equal to the matrix size `n`. If they are not equal, this means that the row or column does not contain all integers from 1 to n (inclusive), and we return false. If the loop completes successfully and all row and column sets have size `n`, the matrix is valid, and we return true.\n    ",
        "js": "\n    ```javascript\nfunction isValidMatrix(matrix) {\n    const n = matrix.length;\n    for (let i = 0; i < n; ++i) {\n        const row = new Set(), col = new Set();\n        for (let j = 0; j < n; ++j) {\n            row.add(matrix[i][j]);\n            col.add(matrix[j][i]);\n        }\n        if (row.size !== n || col.size !== n)\n            return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through each row and column of the matrix. For each row and column, we use a set to store the unique elements. Then, we check if the sizes of the row and column sets are equal to the matrix size `n`. If they are not equal, this means that the row or column does not contain all integers from 1 to n (inclusive), and we return false. If the loop completes successfully and all row and column sets have size `n`, the matrix is valid, and we return true.\n    "
    },
    {
        "id": 339,
        "title": "Make Array Non-decreasing or Non-increasing",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. In one operation, you can:\n\n*   Choose an index `i` in the range `0 <= i < nums.length`\n*   Set `nums[i]` to `nums[i] + 1` **or** `nums[i] - 1`\n\nReturn _the **minimum** number of operations to make_ `nums` _**non-decreasing** or **non-increasing**._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,4,5,0\\]\n**Output:** 4\n**Explanation:**\nOne possible way to turn nums into non-increasing order is to:\n- Add 1 to nums\\[1\\] once so that it becomes 3.\n- Subtract 1 from nums\\[2\\] once so it becomes 3.\n- Subtract 1 from nums\\[3\\] twice so it becomes 3.\nAfter doing the 4 operations, nums becomes \\[3,3,3,3,0\\] which is in non-increasing order.\nNote that it is also possible to turn nums into \\[4,4,4,4,0\\] in 4 operations.\nIt can be proven that 4 is the minimum number of operations needed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,3,4\\]\n**Output:** 0\n**Explanation:** nums is already in non-decreasing order, so no operations are needed and we return 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0\\]\n**Output:** 0\n**Explanation:** nums is already in non-decreasing order, so no operations are needed and we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n\n**",
            "follow_up": "Follow up:** Can you solve it in `O(n*log(n))` time complexity?"
        },
        "tag": [],
        "example": [
            {
                "input": "[3,2,4,5,0]",
                "output": "4"
            },
            {
                "input": "[2,2,3,4]",
                "output": "0"
            },
            {
                "input": "[0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxRunningTime(int n, int[] batteries) {\n    Arrays.sort(batteries);\n    int total_time = 0;\n    for (int i = batteries.length - 1; i >= batteries.length - n; --i) {\n        total_time += batteries[i];\n    }\n    return total_time / n;\n}\n```\n    \n    1. Sort the batteries array in descending order, so that the largest batteries are at the beginning of the array.\n2. Calculate the total time by summing up the values of the first n elements in the sorted batteries array. This works because we pick the largest batteries to use first, thereby maximizing the amount of time the computers can run simultaneously.\n3. Divide the total time by n to get the maximum number of minutes that all the computers can run simultaneously.\n    ",
        "python": "\n    ```python\ndef max_running_time(n, batteries):\n    batteries.sort(reverse=True)\n    total_time = sum(batteries[:n])\n    return total_time // n\n```\n    \n    1. Sort the batteries array in descending order, so that the largest batteries are at the beginning of the array.\n2. Calculate the total time by summing up the values of the first n elements in the sorted batteries array. This works because we pick the largest batteries to use first, thereby maximizing the amount of time the computers can run simultaneously.\n3. Divide the total time by n to get the maximum number of minutes that all the computers can run simultaneously.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint maxRunningTime(int n, vector<int>& batteries) {\n    sort(batteries.begin(), batteries.end(), greater<int>());\n    int total_time = 0;\n    for (int i = 0; i < n; ++i) {\n        total_time += batteries[i];\n    }\n    return total_time / n;\n}\n```\n    \n    1. Sort the batteries array in descending order, so that the largest batteries are at the beginning of the array.\n2. Calculate the total time by summing up the values of the first n elements in the sorted batteries array. This works because we pick the largest batteries to use first, thereby maximizing the amount of time the computers can run simultaneously.\n3. Divide the total time by n to get the maximum number of minutes that all the computers can run simultaneously.\n    ",
        "js": "\n    ```javascript\nfunction maxRunningTime(n, batteries) {\n    batteries.sort((a, b) => b - a);\n    let total_time = 0;\n    for (let i = 0; i < n; i++) {\n        total_time += batteries[i];\n    }\n    return Math.floor(total_time / n);\n}\n```\n    \n    1. Sort the batteries array in descending order, so that the largest batteries are at the beginning of the array.\n2. Calculate the total time by summing up the values of the first n elements in the sorted batteries array. This works because we pick the largest batteries to use first, thereby maximizing the amount of time the computers can run simultaneously.\n3. Divide the total time by n to get the maximum number of minutes that all the computers can run simultaneously.\n    "
    },
    {
        "id": 340,
        "title": "Minimum Number of Keypresses",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a keypad with `9` buttons, numbered from `1` to `9`, each mapped to lowercase English letters. You can choose which characters each button is matched to as long as:\n\n*   All 26 lowercase English letters are mapped to.\n*   Each character is mapped to by **exactly** `1` button.\n*   Each button maps to **at most** `3` characters.\n\nTo type the first character matched to a button, you press the button once. To type the second character, you press the button twice, and so on.\n\nGiven a string `s`, return _the **minimum** number of keypresses needed to type_ `s` _using your keypad._\n\n**Note** that the characters mapped to by each button, and the order they are mapped in cannot be changed.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"apple \"\n**Output:** 5\n**Explanation:** One optimal way to setup your keypad is shown above.\nType 'a' by pressing button 1 once.\nType 'p' by pressing button 6 once.\nType 'p' by pressing button 6 once.\nType 'l' by pressing button 5 once.\nType 'e' by pressing button 3 once.\nA total of 5 button presses are needed, so return 5.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdefghijkl \"\n**Output:** 15\n**Explanation:** One optimal way to setup your keypad is shown above.\nThe letters 'a' to 'i' can each be typed by pressing a button once.\nType 'j' by pressing button 1 twice.\nType 'k' by pressing button 2 twice.\nType 'l' by pressing button 3 twice.\nA total of 15 button presses are needed, so return 15."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"apple\"",
                "output": "5"
            },
            {
                "input": "\"abcdefghijkl\"",
                "output": "15"
            }
        ],
        "java": "\n    ```java\npublic int minKeypresses(String s) {\n    int[] keypresses = new int[26];\n    for (int i = 0; i < 26; ++i) {\n        keypresses[i] = (i % 9) + 1;\n    }\n    int result = 0;\n    for (char c : s.toCharArray()) {\n        result += keypresses[c - 'a'];\n    }\n    return result;\n}\n```\n    \n    We first create an array `keypresses` of length 26 to represent all lowercase English letters, where each element maps the number of keypresses needed to type the corresponding character. Then, we iterate through the input string `s` and for each character `c`, we increment the `result` counter with the number of keypresses needed to type the `c`. In the end, we return the result counter.\n    ",
        "python": "\n    ```python\ndef min_keypresses(s: str) -> int:\n    keypresses = [(i % 9) + 1 for i in range(26)]\n    result = 0\n    for c in s:\n        result += keypresses[ord(c) - ord('a')]\n    return result\n```\n    \n    We first create an array `keypresses` of length 26 to represent all lowercase English letters, where each element maps the number of keypresses needed to type the corresponding character. Then, we iterate through the input string `s` and for each character `c`, we increment the `result` counter with the number of keypresses needed to type the `c`. In the end, we return the result counter.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint min_keypresses(const std::string& s) {\n    std::vector<int> keypresses(26);\n    for (int i = 0; i < 26; ++i) {\n        keypresses[i] = (i % 9) + 1;\n    }\n    int result = 0;\n    for (char c : s) {\n        result += keypresses[c - 'a'];\n    }\n    return result;\n}\n```\n    \n    We first create an array `keypresses` of length 26 to represent all lowercase English letters, where each element maps the number of keypresses needed to type the corresponding character. Then, we iterate through the input string `s` and for each character `c`, we increment the `result` counter with the number of keypresses needed to type the `c`. In the end, we return the result counter.\n    ",
        "js": "\n    ```javascript\nfunction minKeypresses(s) {\n    const keypresses = Array.from({length: 26}, (_, i) => (i % 9) + 1);\n    let result = 0;\n    for (const c of s) {\n        result += keypresses[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n    }\n    return result;\n}\n```\n    \n    We first create an array `keypresses` of length 26 to represent all lowercase English letters, where each element maps the number of keypresses needed to type the corresponding character. Then, we iterate through the input string `s` and for each character `c`, we increment the `result` counter with the number of keypresses needed to type the `c`. In the end, we return the result counter.\n    "
    },
    {
        "id": 341,
        "title": "Closest Node to Path in Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a positive integer `n` representing the number of nodes in a tree, numbered from `0` to `n - 1` (**inclusive**). You are also given a 2D integer array `edges` of length `n - 1`, where `edges[i] = [node1i, node2i]` denotes that there is a **bidirectional** edge connecting `node1i` and `node2i` in the tree.\n\nYou are given a **0-indexed** integer array `query` of length `m` where `query[i] = [starti, endi, nodei]` means that for the `ith` query, you are tasked with finding the node on the path from `starti` to `endi` that is **closest** to `nodei`.\n\nReturn _an integer array_ `answer` _of length_ `m`_, where_ `answer[i]` _is the answer to the_ `ith` _query_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[1,4\\],\\[2,5\\],\\[2,6\\]\\], query = \\[\\[5,3,4\\],\\[5,3,6\\]\\]\n**Output:** \\[0,2\\]\n**Explanation:**\nThe path from node 5 to node 3 consists of the nodes 5, 2, 0, and 3.\nThe distance between node 4 and node 0 is 2.\nNode 0 is the node on the path closest to node 4, so the answer to the first query is 0.\nThe distance between node 6 and node 2 is 1.\nNode 2 is the node on the path closest to node 6, so the answer to the second query is 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\]\\], query = \\[\\[0,1,2\\]\\]\n**Output:** \\[1\\]\n**Explanation:**\nThe path from node 0 to node 1 consists of the nodes 0, 1.\nThe distance between node 2 and node 1 is 1.\nNode 1 is the node on the path closest to node 2, so the answer to the first query is 1.\n\n",
                "**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\]\\], query = \\[\\[0,0,0\\]\\]\n**Output:** \\[0\\]\n**Explanation:**\nThe path from node 0 to node 0 consists of the node 0.\nSince 0 is the only node on the path, the answer to the first query is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= node1i, node2i <= n - 1`\n*   `node1i != node2i`\n*   `1 <= query.length <= 1000`\n*   `query[i].length == 3`\n*   `0 <= starti, endi, nodei <= n - 1`\n*   The graph is a tree.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "7,[[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]],[[5,3,4],[5,3,6]]",
                "output": "[0,2]"
            },
            {
                "input": "3,[[0,1],[1,2]],[[0,1,2]]",
                "output": "[1]"
            },
            {
                "input": "3,[[0,1],[1,2]],[[0,0,0]]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> closestNodes(int n, List<List<Integer>> edges, List<List<Integer>> query) {\n    List<Integer> answer = new ArrayList<>();\n    List<List<Integer>> tree = new ArrayList<>();\n\n    for (int i = 0; i < n; i++) {\n        tree.add(new ArrayList<>());\n    }\n\n    for (List<Integer> edge : edges) {\n        tree.get(edge.get(0)).add(edge.get(1));\n        tree.get(edge.get(1)).add(edge.get(0));\n    }\n\n    for (List<Integer> q : query) {\n        int lca = bfs(q.get(0), q.get(1), tree);\n        int node1 = bfs(lca, q.get(0), tree);\n        int node2 = bfs(lca, q.get(1), tree);\n        answer.add(node1 == q.get(2) ? q.get(0) : q.get(1));\n    }\n\n    return answer;\n}\n\nprivate int bfs(int start, int end, List<List<Integer>> tree) {\n    Queue<Integer> queue = new LinkedList<>();\n    Set<Integer> visited = new HashSet<>();\n    queue.add(start);\n    visited.add(start);\n\n    while (!queue.isEmpty()) {\n        int current = queue.poll();\n\n        if (current == end) {\n            return current;\n        }\n\n        for (int neighbor : tree.get(current)) {\n            if (!visited.contains(neighbor)) {\n                queue.add(neighbor);\n                visited.add(neighbor);\n            }\n        }\n    }\n\n    return -1;\n}\n```\n    \n    1. Create an adjacency list `tree` using the given `edges`.\n2. Define a `bfs` function that performs a breadth-first search of the tree and returns the target node when it's found. The `bfs` function takes two arguments: the starting node and the target node.\n3. Initialize an empty list called `answer`.\n4. Iterate through the `query` list, and for each query, find the least common ancestor (LCA) of the `start` and `end` nodes using the `bfs` function.\n5. Based on the result of the LCA, find which of the `start` or `end` nodes is closest to the given `node` using the `bfs` function again.\n6. Add the result to the `answer` list.\n7. Once all queries have been iterated, return the `answer` list.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef closest_nodes(n, edges, query):\n    answer = []\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    def bfs(start, end):\n        queue = deque([start])\n        visited = {start}\n        \n        while queue:\n            current = queue.popleft()\n            \n            if current == end:\n                return current\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n    \n    for q in query:\n        lca = bfs(q[0], q[1])\n        node1 = bfs(lca, q[0])\n        node2 = bfs(lca, q[1])\n        answer.append(q[0] if node1 == q[2] else q[1])\n    \n    return answer\n```\n    \n    1. Create an adjacency list `tree` using the given `edges`.\n2. Define a `bfs` function that performs a breadth-first search of the tree and returns the target node when it's found. The `bfs` function takes two arguments: the starting node and the target node.\n3. Initialize an empty list called `answer`.\n4. Iterate through the `query` list, and for each query, find the least common ancestor (LCA) of the `start` and `end` nodes using the `bfs` function.\n5. Based on the result of the LCA, find which of the `start` or `end` nodes is closest to the given `node` using the `bfs` function again.\n6. Add the result to the `answer` list.\n7. Once all queries have been iterated, return the `answer` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nstd::vector<int> closestNodes(int n, std::vector<std::vector<int>>& edges, std::vector<std::vector<int>>& query) {\n    std::vector<int> answer;\n    \n    std::vector<std::vector<int>> tree(n);\n    for (auto& edge : edges) {\n        tree[edge[0]].push_back(edge[1]);\n        tree[edge[1]].push_back(edge[0]);\n    }\n    \n    auto bfs = [&](int start, int end) {\n        std::queue<int> q;\n        std::vector<bool> visited(n, false);\n        q.push(start);\n        visited[start] = true;\n        \n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            if (current == end) {\n                return current;\n            }\n            \n            for (int neighbor : tree[current]) {\n                if (!visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n        return -1;\n    };\n    \n    for (auto& q : query) {\n        int lca = bfs(q[0], q[1]);\n        int node1 = bfs(lca, q[0]);\n        int node2 = bfs(lca, q[1]);\n        answer.push_back(node1 == q[2] ? q[0] : q[1]);\n    }\n    \n    return answer;\n}\n```\n    \n    1. Create an adjacency list `tree` using the given `edges`.\n2. Define a `bfs` function that performs a breadth-first search of the tree and returns the target node when it's found. The `bfs` function takes two arguments: the starting node and the target node.\n3. Initialize an empty list called `answer`.\n4. Iterate through the `query` list, and for each query, find the least common ancestor (LCA) of the `start` and `end` nodes using the `bfs` function.\n5. Based on the result of the LCA, find which of the `start` or `end` nodes is closest to the given `node` using the `bfs` function again.\n6. Add the result to the `answer` list.\n7. Once all queries have been iterated, return the `answer` list.\n    ",
        "js": "\n    ```javascript\nfunction closestNodes(n, edges, query) {\n    const answer = [];\n    const tree = Array.from({ length: n }, () => []);\n    \n    for (const edge of edges) {\n        tree[edge[0]].push(edge[1]);\n        tree[edge[1]].push(edge[0]);\n    }\n    \n    function bfs(start, end) {\n        const queue = [start];\n        const visited = new Set([start]);\n        \n        while (queue.length > 0) {\n            const current = queue.shift();\n            \n            if (current === end) {\n                return current;\n            }\n            \n            for (const neighbor of tree[current]) {\n                if (!visited.has(neighbor)) {\n                    queue.push(neighbor);\n                    visited.add(neighbor);\n                }\n            }\n        }\n    }\n    \n    for (const q of query) {\n        const lca = bfs(q[0], q[1]);\n        const node1 = bfs(lca, q[0]);\n        const node2 = bfs(lca, q[1]);\n        answer.push(node1 === q[2] ? q[0] : q[1]);\n    }\n    \n    return answer;\n}\n```\n    \n    1. Create an adjacency list `tree` using the given `edges`.\n2. Define a `bfs` function that performs a breadth-first search of the tree and returns the target node when it's found. The `bfs` function takes two arguments: the starting node and the target node.\n3. Initialize an empty list called `answer`.\n4. Iterate through the `query` list, and for each query, find the least common ancestor (LCA) of the `start` and `end` nodes using the `bfs` function.\n5. Based on the result of the LCA, find which of the `start` or `end` nodes is closest to the given `node` using the `bfs` function again.\n6. Add the result to the `answer` list.\n7. Once all queries have been iterated, return the `answer` list.\n    "
    },
    {
        "id": 342,
        "title": "Number of People That Can Be Seen in a Grid",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` **0-indexed** 2D array of positive integers `heights` where `heights[i][j]` is the height of the person standing at position `(i, j)`.\n\nA person standing at position `(row1, col1)` can see a person standing at position `(row2, col2)` if:\n\n*   The person at `(row2, col2)` is to the right **or** below the person at `(row1, col1)`. More formally, this means that either `row1 == row2` and `col1 < col2` **or** `row1 < row2` and `col1 == col2`.\n*   Everyone in between them is shorter than **both** of them.\n\nReturn _an_ `m x n` _2D array of integers_ `answer` _where_ `answer[i][j]` _is the number of people that the person at position_ `(i, j)` _can see._",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[\\[3,1,4,2,5\\]\\]\n**Output:** \\[\\[2,1,2,1,0\\]\\]\n**Explanation:**\n- The person at (0, 0) can see the people at (0, 1) and (0, 2).\n  Note that he cannot see the person at (0, 4) because the person at (0, 2) is taller than him.\n- The person at (0, 1) can see the person at (0, 2).\n- The person at (0, 2) can see the people at (0, 3) and (0, 4).\n- The person at (0, 3) can see the person at (0, 4).\n- The person at (0, 4) cannot see anybody.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[\\[5,1\\],\\[3,1\\],\\[4,1\\]\\]\n**Output:** \\[\\[3,1\\],\\[2,1\\],\\[1,0\\]\\]\n**Explanation:**\n- The person at (0, 0) can see the people at (0, 1), (1, 0) and (2, 0).\n- The person at (0, 1) can see the person at (1, 1).\n- The person at (1, 0) can see the people at (1, 1) and (2, 0).\n- The person at (1, 1) can see the person at (2, 1).\n- The person at (2, 0) can see the person at (2, 1).\n- The person at (2, 1) cannot see anybody."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 400`\n*   `1 <= heights[i].length <= 400`\n*   `1 <= heights[i][j] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[3,1,4,2,5]]",
                "output": "[[2,1,2,1,0]]"
            },
            {
                "input": "[[5,1],[3,1],[4,1]]",
                "output": "[[3,1],[2,1],[1,0]]"
            }
        ],
        "java": "\n    ```java\npublic int[][] visiblePeople(int[][] heights) {\n    int m = heights.length, n = heights[0].length;\n    int[][] answer = new int[m][n];\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = j+1; k < n && heights[i][j] >= heights[i][k]; k++) {\n                if (heights[i][j] > heights[i][k]) answer[i][j]++;\n            }\n            for (int k = i+1; k < m && heights[i][j] >= heights[k][j]; k++) {\n                if (heights[i][j] > heights[k][j]) answer[i][j]++;\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    1. Create an `answer` matrix of the same dimensions as `heights`, initializing all values to 0.\n2. Use nested loops to iterate over each person in the `heights` matrix.\n3. For each person, look to the right and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n4. For each person, look downwards and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n5. Return the `answer` matrix.\n    ",
        "python": "\n    ```python\ndef visible_people(heights):\n    m, n = len(heights), len(heights[0])\n    answer = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            for k in range(j+1, n):\n                if heights[i][j] >= heights[i][k]:\n                    if heights[i][j] > heights[i][k]:\n                        answer[i][j] += 1\n                else:\n                    break\n            for k in range(i+1, m):\n                if heights[i][j] >= heights[k][j]:\n                    if heights[i][j] > heights[k][j]:\n                        answer[i][j] += 1\n                else:\n                    break\n\n    return answer\n```\n    \n    1. Create an `answer` matrix of the same dimensions as `heights`, initializing all values to 0.\n2. Use nested loops to iterate over each person in the `heights` matrix.\n3. For each person, look to the right and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n4. For each person, look downwards and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n5. Return the `answer` matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> visiblePeople(vector<vector<int>>& heights) {\n    int m = heights.size(), n = heights[0].size();\n    vector<vector<int>> answer(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = j+1; k < n && heights[i][j] >= heights[i][k]; k++) {\n                if (heights[i][j] > heights[i][k]) answer[i][j]++;\n            }\n            for (int k = i+1; k < m && heights[i][j] >= heights[k][j]; k++) {\n                if (heights[i][j] > heights[k][j]) answer[i][j]++;\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    1. Create an `answer` matrix of the same dimensions as `heights`, initializing all values to 0.\n2. Use nested loops to iterate over each person in the `heights` matrix.\n3. For each person, look to the right and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n4. For each person, look downwards and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n5. Return the `answer` matrix.\n    ",
        "js": "\n    ```javascript\nfunction visiblePeople(heights) {\n    let m = heights.length, n = heights[0].length;\n    let answer = Array.from({length:m}, () => Array(n).fill(0));\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            for (let k = j+1; k < n && heights[i][j] >= heights[i][k]; k++) {\n                if (heights[i][j] > heights[i][k]) answer[i][j]++;\n            }\n            for (let k = i+1; k < m && heights[i][j] >= heights[k][j]; k++) {\n                if (heights[i][j] > heights[k][j]) answer[i][j]++;\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    1. Create an `answer` matrix of the same dimensions as `heights`, initializing all values to 0.\n2. Use nested loops to iterate over each person in the `heights` matrix.\n3. For each person, look to the right and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n4. For each person, look downwards and count the number of people with shorter height until a person with greater/equal height is encountered. Increment the count in the respective cell in the `answer` matrix.\n5. Return the `answer` matrix.\n    "
    },
    {
        "id": 343,
        "title": "Maximum Profit From Trading Stocks",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays of the same length `present` and `future` where `present[i]` is the current price of the `ith` stock and `future[i]` is the price of the `ith` stock a year in the future. You may buy each stock at most **once**. You are also given an integer `budget` representing the amount of money you currently have.\n\nReturn _the maximum amount of profit you can make._",
            "examples": [
                "**Example 1:**\n\n**Input:** present = \\[5,4,6,2,3\\], future = \\[8,5,4,3,5\\], budget = 10\n**Output:** 6\n**Explanation:** One possible way to maximize your profit is to:\nBuy the 0th, 3rd, and 4th stocks for a total of 5 + 2 + 3 = 10.\nNext year, sell all three stocks for a total of 8 + 3 + 5 = 16.\nThe profit you made is 16 - 10 = 6.\nIt can be shown that the maximum profit you can make is 6.\n\n",
                "**Example 2:**\n\n**Input:** present = \\[2,2,5\\], future = \\[3,4,10\\], budget = 6\n**Output:** 5\n**Explanation:** The only possible way to maximize your profit is to:\nBuy the 2nd stock, and make a profit of 10 - 5 = 5.\nIt can be shown that the maximum profit you can make is 5.\n\n",
                "**Example 3:**\n\n**Input:** present = \\[3,3,12\\], future = \\[0,3,15\\], budget = 10\n**Output:** 0\n**Explanation:** One possible way to maximize your profit is to:\nBuy the 1st stock, and make a profit of 3 - 3 = 0.\nIt can be shown that the maximum profit you can make is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == present.length == future.length`\n*   `1 <= n <= 1000`\n*   `0 <= present[i], future[i] <= 100`\n*   `0 <= budget <= 1000`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,4,6,2,3],[8,5,4,3,5],10",
                "output": "6"
            },
            {
                "input": "[2,2,5],[3,4,10],6",
                "output": "5"
            },
            {
                "input": "[3,3,12],[0,3,15],10",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxANDSum(int[] nums, int numSlots) {\n    int[] slot = new int[numSlots + 1];\n    for (int num : nums) {\n        for (int j = numSlots; j > 0; j--) {\n            int newVal = num & j;\n            if (newVal > slot[j]) slot[j] = newVal;\n        }\n    }\n\n    int sum = 0;\n    for (int s : slot) {\n        sum += s;\n    }\n    return sum;\n}\n```\n    \n    1. Create an array `slot` of size numSlots + 1, to store the maximum AND value for each slot. Initialized with all 0s.\n2. For each number in `nums`, iterate through the slot numbers from `numSlots` to 1.\n   - Calculate the AND value (`new_val`) of the current number with the slot number `j`.\n   - If the `new_val` is greater than the current value in `slot[j]`, then update `slot[j]` to `new_val`. This is to ensure that we store the maximum AND value for each slot.\n3. Sum all the values in the `slot` array and return the result. This is the maximum possible AND sum of `nums` given `numSlots` slots.\n\nNote: All the code snippets provided above implement the same algorithm in four different programming languages.\n    ",
        "python": "\n    ```python\ndef max_and_sum(nums, num_slots):\n    slot = [0] * (num_slots + 1)\n    for num in nums:\n        for j in range(num_slots, 0, -1):\n            new_val = num & j\n            if new_val > slot[j]:\n                slot[j] = new_val\n\n    return sum(slot)\n```\n    \n    1. Create an array `slot` of size numSlots + 1, to store the maximum AND value for each slot. Initialized with all 0s.\n2. For each number in `nums`, iterate through the slot numbers from `numSlots` to 1.\n   - Calculate the AND value (`new_val`) of the current number with the slot number `j`.\n   - If the `new_val` is greater than the current value in `slot[j]`, then update `slot[j]` to `new_val`. This is to ensure that we store the maximum AND value for each slot.\n3. Sum all the values in the `slot` array and return the result. This is the maximum possible AND sum of `nums` given `numSlots` slots.\n\nNote: All the code snippets provided above implement the same algorithm in four different programming languages.\n    ",
        "c++": "\n    ```cpp\nint maxANDSum(vector<int>& nums, int numSlots) {\n    vector<int> slot(numSlots + 1, 0);\n    for (int num : nums) {\n        for (int j = numSlots; j > 0; j--) {\n            int new_val = num & j;\n            if (new_val > slot[j]) slot[j] = new_val;\n        }\n    }\n\n    return accumulate(slot.begin(), slot.end(), 0);\n}\n```\n    \n    1. Create an array `slot` of size numSlots + 1, to store the maximum AND value for each slot. Initialized with all 0s.\n2. For each number in `nums`, iterate through the slot numbers from `numSlots` to 1.\n   - Calculate the AND value (`new_val`) of the current number with the slot number `j`.\n   - If the `new_val` is greater than the current value in `slot[j]`, then update `slot[j]` to `new_val`. This is to ensure that we store the maximum AND value for each slot.\n3. Sum all the values in the `slot` array and return the result. This is the maximum possible AND sum of `nums` given `numSlots` slots.\n\nNote: All the code snippets provided above implement the same algorithm in four different programming languages.\n    ",
        "js": "\n    ```javascript\nfunction maxANDSum(nums, numSlots) {\n    let slot = new Array(numSlots + 1).fill(0);\n    for (let num of nums) {\n        for (let j = numSlots; j > 0; j--) {\n            let newVal = num & j;\n            if (newVal > slot[j]) slot[j] = newVal;\n        }\n    }\n\n    return slot.reduce((acc, val) => acc + val, 0);\n}\n```\n    \n    1. Create an array `slot` of size numSlots + 1, to store the maximum AND value for each slot. Initialized with all 0s.\n2. For each number in `nums`, iterate through the slot numbers from `numSlots` to 1.\n   - Calculate the AND value (`new_val`) of the current number with the slot number `j`.\n   - If the `new_val` is greater than the current value in `slot[j]`, then update `slot[j]` to `new_val`. This is to ensure that we store the maximum AND value for each slot.\n3. Sum all the values in the `slot` array and return the result. This is the maximum possible AND sum of `nums` given `numSlots` slots.\n\nNote: All the code snippets provided above implement the same algorithm in four different programming languages.\n    "
    },
    {
        "id": 344,
        "title": "Jump Game VIII",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` of length `n`. You are initially standing at index `0`. You can jump from index `i` to index `j` where `i < j` if:\n\n*   `nums[i] <= nums[j]` and `nums[k] < nums[i]` for all indexes `k` in the range `i < k < j`, or\n*   `nums[i] > nums[j]` and `nums[k] >= nums[i]` for all indexes `k` in the range `i < k < j`.\n\nYou are also given an integer array `costs` of length `n` where `costs[i]` denotes the cost of jumping **to** index `i`.\n\nReturn _the **minimum** cost to jump to the index_ `n - 1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,4,4,1\\], costs = \\[3,7,6,4,2\\]\n**Output:** 8\n**Explanation:** You start at index 0.\n- Jump to index 2 with a cost of costs\\[2\\] = 6.\n- Jump to index 4 with a cost of costs\\[4\\] = 2.\nThe total cost is 8. It can be proven that 8 is the minimum cost needed.\nTwo other possible paths are from index 0 -> 1 -> 4 and index 0 -> 2 -> 3 -> 4.\nThese have a total cost of 9 and 12, respectively.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,2\\], costs = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** Start at index 0.\n- Jump to index 1 with a cost of costs\\[1\\] = 1.\n- Jump to index 2 with a cost of costs\\[2\\] = 1.\nThe total cost is 2. Note that you cannot jump directly from index 0 to index 2 because nums\\[0\\] <= nums\\[1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length == costs.length`\n*   `1 <= n <= 105`\n*   `0 <= nums[i], costs[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,2,4,4,1],[3,7,6,4,2]",
                "output": "8"
            },
            {
                "input": "[0,1,2],[1,1,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minHeightJump(int[] nums, int[] costs) {\n    int n = nums.length;\n    int[] dp = new int[n];\n\n    dp[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        dp[i] = Integer.MAX_VALUE;\n        for (int j = i - 1; j >= 0; --j) {\n            if ((nums[j] <= nums[i] && (j == 0 || nums[j - 1] < nums[i])) || (nums[j] > nums[i] && (j == 0 || nums[j - 1] >= nums[i]))) {\n                dp[i] = Math.min(dp[i], dp[j] + costs[i]);\n            }\n        }\n    }\n    return dp[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost to reach index `n-1`. We create a `dp` array of length `n` that stores the minimum cost to reach each index. We initialize the first element of `dp` to `0`, as we're already at index `0` and it has no cost. For each `i` from `1` to `n-1`, we iterate from `j = i-1` to `0`. If either of the given conditions are true `(nums[j] <= nums[i] && (j == 0 || nums[j - 1] < nums[i]))` or `(nums[j] > nums[i] && (j == 0 || nums[j - 1] >= nums[i]))`, update `dp[i]` with the minimum of its current value and `dp[j] + costs[i]`. After iterating through all elements, the last element `dp[n - 1]` contains the minimum cost to reach index `n-1`.\n    ",
        "python": "\n    ```python\ndef minHeightJump(nums, costs):\n    n = len(nums)\n    dp = [float('inf')] * n\n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i - 1, -1, -1):\n            if ((nums[j] <= nums[i] and (j == 0 or nums[j - 1] < nums[i])) or (nums[j] > nums[i] and (j == 0 or nums[j - 1] >= nums[i]))):\n                dp[i] = min(dp[i], dp[j] + costs[i])\n\n    return dp[n - 1]\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost to reach index `n-1`. We create a `dp` array of length `n` that stores the minimum cost to reach each index. We initialize the first element of `dp` to `0`, as we're already at index `0` and it has no cost. For each `i` from `1` to `n-1`, we iterate from `j = i-1` to `0`. If either of the given conditions are true `(nums[j] <= nums[i] && (j == 0 || nums[j - 1] < nums[i]))` or `(nums[j] > nums[i] && (j == 0 || nums[j - 1] >= nums[i]))`, update `dp[i]` with the minimum of its current value and `dp[j] + costs[i]`. After iterating through all elements, the last element `dp[n - 1]` contains the minimum cost to reach index `n-1`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint minHeightJump(const std::vector<int>& nums, const std::vector<int>& costs) {\n    int n = nums.size();\n    std::vector<int> dp(n, 1e9);\n\n    dp[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        int j = i - 1;\n        while (j >= 0) {\n            if ((nums[j] <= nums[i] && (j == 0 || nums[j - 1] < nums[i])) || (nums[j] > nums[i] && (j == 0 || nums[j - 1] >= nums[i]))) {\n                dp[i] = std::min(dp[i], dp[j] + costs[i]);\n            }\n            --j;\n        }\n    }\n    return dp[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost to reach index `n-1`. We create a `dp` array of length `n` that stores the minimum cost to reach each index. We initialize the first element of `dp` to `0`, as we're already at index `0` and it has no cost. For each `i` from `1` to `n-1`, we iterate from `j = i-1` to `0`. If either of the given conditions are true `(nums[j] <= nums[i] && (j == 0 || nums[j - 1] < nums[i]))` or `(nums[j] > nums[i] && (j == 0 || nums[j - 1] >= nums[i]))`, update `dp[i]` with the minimum of its current value and `dp[j] + costs[i]`. After iterating through all elements, the last element `dp[n - 1]` contains the minimum cost to reach index `n-1`.\n    ",
        "js": "\n    ```javascript\nfunction minHeightJump(nums, costs) {\n    const n = nums.length;\n    const dp = new Array(n).fill(Infinity);\n\n    dp[0] = 0;\n    for (let i = 1; i < n; ++i) {\n        for (let j = i - 1; j >= 0; --j) {\n            if ((nums[j] <= nums[i] && (j === 0 || nums[j - 1] < nums[i])) || (nums[j] > nums[i] && (j === 0 || nums[j - 1] >= nums[i]))) {\n                dp[i] = Math.min(dp[i], dp[j] + costs[i]);\n            }\n        }\n    }\n    return dp[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost to reach index `n-1`. We create a `dp` array of length `n` that stores the minimum cost to reach each index. We initialize the first element of `dp` to `0`, as we're already at index `0` and it has no cost. For each `i` from `1` to `n-1`, we iterate from `j = i-1` to `0`. If either of the given conditions are true `(nums[j] <= nums[i] && (j == 0 || nums[j - 1] < nums[i]))` or `(nums[j] > nums[i] && (j == 0 || nums[j - 1] >= nums[i]))`, update `dp[i]` with the minimum of its current value and `dp[j] + costs[i]`. After iterating through all elements, the last element `dp[n - 1]` contains the minimum cost to reach index `n-1`.\n    "
    },
    {
        "id": 345,
        "title": "Check for Contradictions in Equations",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D array of strings `equations` and an array of real numbers `values`, where `equations[i] = [Ai, Bi]` and `values[i]` means that `Ai / Bi = values[i]`.\n\nDetermine if there exists a contradiction in the equations. Return `true` _if there is a contradiction, or_ `false` _otherwise_.\n\n**Note**:\n\n*   When checking if two numbers are equal, check that their **absolute difference** is less than `10-5`.\n*   The testcases are generated such that there are no cases targeting precision, i.e. using `double` is enough to solve the problem.",
            "examples": [
                "**Example 1:**\n\n**Input:** equations = \\[\\[ \"a \", \"b \"\\],\\[ \"b \", \"c \"\\],\\[ \"a \", \"c \"\\]\\], values = \\[3,0.5,1.5\\]\n**Output:** false\n**Explanation:**\nThe given equations are: a / b = 3, b / c = 0.5, a / c = 1.5\nThere are no contradictions in the equations. One possible assignment to satisfy all equations is:\na = 3, b = 1 and c = 2.\n\n",
                "**Example 2:**\n\n**Input:** equations = \\[\\[ \"le \", \"et \"\\],\\[ \"le \", \"code \"\\],\\[ \"code \", \"et \"\\]\\], values = \\[2,5,0.5\\]\n**Output:** true\n**Explanation:**\nThe given equations are: le / et = 2, le / code = 5, code / et = 0.5\nBased on the first two equations, we get code / et = 0.4.\nSince the third equation is code / et = 0.5, we get a contradiction."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= equations.length <= 100`\n*   `equations[i].length == 2`\n*   `1 <= Ai.length, Bi.length <= 5`\n*   `Ai`, `Bi` consist of lowercase English letters.\n*   `equations.length == values.length`\n*   `0.0 < values[i] <= 10.0`\n*   `values[i]` has a maximum of 2 decimal places.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]],[3,0.5,1.5]",
                "output": "false"
            },
            {
                "input": "[[\"le\",\"et\"],[\"le\",\"code\"],[\"code\",\"et\"]],[2,5,0.5]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> modifyArray(List<Integer> nums) {\n    int n = nums.size();\n    for (int i = 1; i < n; ++i) {\n        if (gcd(nums.get(i - 1), nums.get(i)) > 1) {\n            nums.add(i, 1);\n            ++n;\n            ++i;\n        }\n    }\n    return nums;\n}\n\nprivate int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n```\n    \n    1. Loop through the input array starting from the second element.\n2. For each element, check if it has a GCD greater than 1 with the previous element.\n3. If they have a GCD greater than 1, insert the value 1 into the array between these two elements.\n4. Move to the next element.\n5. Repeat steps 2-4 until the end of the array is reached.\n6. Return the modified array.\n\nBoth Python and JavaScript use 0-based indexing, so the index value is incremented when a new element is inserted. In C++ and Java, the element is inserted in the beginning of the vector and the index values are adjusted accordingly. This ensures that the algorithm works correctly for all languages. The `gcd` function is implemented using the Euclidean algorithm for calculating the greatest common divisor of two numbers.\n    ",
        "python": "\n    ```python\nfrom math import gcd\n\ndef modify_array(nums):\n    i = 1\n    while i < len(nums):\n        if gcd(nums[i-1], nums[i]) > 1:\n            nums.insert(i, 1)\n            i += 1\n        i += 1\n    return nums\n```\n    \n    1. Loop through the input array starting from the second element.\n2. For each element, check if it has a GCD greater than 1 with the previous element.\n3. If they have a GCD greater than 1, insert the value 1 into the array between these two elements.\n4. Move to the next element.\n5. Repeat steps 2-4 until the end of the array is reached.\n6. Return the modified array.\n\nBoth Python and JavaScript use 0-based indexing, so the index value is incremented when a new element is inserted. In C++ and Java, the element is inserted in the beginning of the vector and the index values are adjusted accordingly. This ensures that the algorithm works correctly for all languages. The `gcd` function is implemented using the Euclidean algorithm for calculating the greatest common divisor of two numbers.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nstd::vector<int> modifyArray(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 1; i < n; ++i) {\n        if (gcd(nums[i - 1], nums[i]) > 1) {\n            nums.insert(nums.begin() + i, 1);\n            ++n;\n            ++i;\n        }\n    }\n    return nums;\n}\n```\n    \n    1. Loop through the input array starting from the second element.\n2. For each element, check if it has a GCD greater than 1 with the previous element.\n3. If they have a GCD greater than 1, insert the value 1 into the array between these two elements.\n4. Move to the next element.\n5. Repeat steps 2-4 until the end of the array is reached.\n6. Return the modified array.\n\nBoth Python and JavaScript use 0-based indexing, so the index value is incremented when a new element is inserted. In C++ and Java, the element is inserted in the beginning of the vector and the index values are adjusted accordingly. This ensures that the algorithm works correctly for all languages. The `gcd` function is implemented using the Euclidean algorithm for calculating the greatest common divisor of two numbers.\n    ",
        "js": "\n    ```javascript\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\n\nfunction modifyArray(nums) {\n    let n = nums.length;\n    for (let i = 1; i < n; ++i) {\n        if (gcd(nums[i - 1], nums[i]) > 1) {\n            nums.splice(i, 0, 1);\n            ++n;\n            ++i;\n        }\n    }\n    return nums;\n}\n```\n    \n    1. Loop through the input array starting from the second element.\n2. For each element, check if it has a GCD greater than 1 with the previous element.\n3. If they have a GCD greater than 1, insert the value 1 into the array between these two elements.\n4. Move to the next element.\n5. Repeat steps 2-4 until the end of the array is reached.\n6. Return the modified array.\n\nBoth Python and JavaScript use 0-based indexing, so the index value is incremented when a new element is inserted. In C++ and Java, the element is inserted in the beginning of the vector and the index values are adjusted accordingly. This ensures that the algorithm works correctly for all languages. The `gcd` function is implemented using the Euclidean algorithm for calculating the greatest common divisor of two numbers.\n    "
    },
    {
        "id": 346,
        "title": "Minimum Flips in Binary Tree to Get Result",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given the `root` of a **binary tree** with the following properties:\n\n*   **Leaf nodes** have either the value `0` or `1`, representing `false` and `true` respectively.\n*   **Non-leaf nodes** have either the value `2`, `3`, `4`, or `5`, representing the boolean operations `OR`, `AND`, `XOR`, and `NOT`, respectively.\n\nYou are also given a boolean `result`, which is the desired result of the **evaluation** of the `root` node.\n\nThe evaluation of a node is as follows:\n\n*   If the node is a leaf node, the evaluation is the **value** of the node, i.e. `true` or `false`.\n*   Otherwise, **evaluate** the node's children and **apply** the boolean operation of its value with the children's evaluations.\n\nIn one operation, you can **flip** a leaf node, which causes a `false` node to become `true`, and a `true` node to become `false`.\n\nReturn _the minimum number of operations that need to be performed such that the evaluation of_ `root` _yields_ `result`. It can be shown that there is always a way to achieve `result`.\n\nA **leaf node** is a node that has zero children.\n\nNote: `NOT` nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,5,4,2,null,1,1,1,0\\], result = true\n**Output:** 2\n**Explanation:**\nIt can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree\nevaluate to true. One way to achieve this is shown in the diagram above.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0\\], result = false\n**Output:** 0\n**Explanation:**\nThe root of the tree already evaluates to false, so 0 nodes have to be flipped."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 105]`.\n*   `0 <= Node.val <= 5`\n*   `OR`, `AND`, and `XOR` nodes have `2` children.\n*   `NOT` nodes have `1` child.\n*   Leaf nodes have a value of `0` or `1`.\n*   Non-leaf nodes have a value of `2`, `3`, `4`, or `5`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,5,4,2,null,1,1,1,0],true",
                "output": "2"
            },
            {
                "input": "[0],false",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic class Node {\n    int val;\n    Node left;\n    Node right;\n}\n\npublic int minOperations(Node root, int result) {\n    if (root == null) {\n        return 0;\n    }\n    if (root.val <= 1) {\n        return (root.val == result) ? 0 : 1;\n    } else {\n        int leftOperations = minOperations(root.left, root.val == 4 ? result ^ 1 : result);\n        int rightOperations = minOperations(root.right, root.val == 4 ? result ^ 1 : result);\n        if (root.val == 3) {\n            return Math.min(leftOperations, rightOperations);\n        } else if (root.val == 2) {\n            return Math.max(leftOperations, rightOperations);\n        } else {\n            return leftOperations + rightOperations;\n        }\n    }\n}\n```\n    \n    For each node, we check its value.\n- If the node is a leaf node, return 0 if its value matches `result`, else return 1 (which means one flip operation is needed).\n- If the node is a non-leaf node, recursively calculate the minimum operations needed to make its left and right children evaluate to the desired result based on the given boolean operation, and return the total minimum operations needed. For AND operation, return the minimum of left and right operations. For OR operation, return the maximum of left and right operations. For XOR operation, return the summation of left and right operations with exclusive OR applied on the result.\n    ",
        "python": "\n    ```python\nclass Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef min_operations(root, result):\n    if root is None:\n        return 0\n    if root.val <= 1:\n        return 0 if root.val == result else 1\n    else:\n        left_operations = min_operations(root.left, result ^ 1 if root.val == 4 else result)\n        right_operations = min_operations(root.right, result ^ 1 if root.val == 4 else result)\n        if root.val == 3:\n            return min(left_operations, right_operations)\n        elif root.val == 2:\n            return max(left_operations, right_operations)\n        else:\n            return left_operations + right_operations\n```\n    \n    For each node, we check its value.\n- If the node is a leaf node, return 0 if its value matches `result`, else return 1 (which means one flip operation is needed).\n- If the node is a non-leaf node, recursively calculate the minimum operations needed to make its left and right children evaluate to the desired result based on the given boolean operation, and return the total minimum operations needed. For AND operation, return the minimum of left and right operations. For OR operation, return the maximum of left and right operations. For XOR operation, return the summation of left and right operations with exclusive OR applied on the result.\n    ",
        "c++": "\n    ```cpp\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n};\n\nint minOperations(Node* root, int result) {\n    if (root == nullptr) {\n        return 0;\n    }\n    if (root->val <= 1) {\n        return (root->val == result) ? 0 : 1;\n    } else {\n        int leftOperations = minOperations(root->left, root->val == 4 ? result ^ 1 : result);\n        int rightOperations = minOperations(root->right, root->val == 4 ? result ^ 1 : result);\n        if (root->val == 3) {\n            return min(leftOperations, rightOperations);\n        } else if (root->val == 2) {\n            return max(leftOperations, rightOperations);\n        } else {\n            return leftOperations + rightOperations;\n        }\n    }\n}\n```\n    \n    For each node, we check its value.\n- If the node is a leaf node, return 0 if its value matches `result`, else return 1 (which means one flip operation is needed).\n- If the node is a non-leaf node, recursively calculate the minimum operations needed to make its left and right children evaluate to the desired result based on the given boolean operation, and return the total minimum operations needed. For AND operation, return the minimum of left and right operations. For OR operation, return the maximum of left and right operations. For XOR operation, return the summation of left and right operations with exclusive OR applied on the result.\n    ",
        "js": "\n    ```javascript\nclass Node {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val\n        this.left = left\n        this.right = right\n    }\n}\n\nfunction minOperations(root, result) {\n    if (!root) {\n        return 0;\n    }\n    if (root.val <= 1) {\n        return (root.val === result) ? 0 : 1;\n    } else {\n        let leftOperations = minOperations(root.left, root.val === 4 ? result ^ 1 : result);\n        let rightOperations = minOperations(root.right, root.val === 4 ? result ^ 1 : result);\n        if (root.val === 3) {\n            return Math.min(leftOperations, rightOperations);\n        } else if (root.val === 2) {\n            return Math.max(leftOperations, rightOperations);\n        } else {\n            return leftOperations + rightOperations;\n        }\n    }\n}\n```\n    \n    For each node, we check its value.\n- If the node is a leaf node, return 0 if its value matches `result`, else return 1 (which means one flip operation is needed).\n- If the node is a non-leaf node, recursively calculate the minimum operations needed to make its left and right children evaluate to the desired result based on the given boolean operation, and return the total minimum operations needed. For AND operation, return the minimum of left and right operations. For OR operation, return the maximum of left and right operations. For XOR operation, return the summation of left and right operations with exclusive OR applied on the result.\n    "
    },
    {
        "id": 347,
        "title": "Maximum XOR After Operations ",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. In one operation, select **any** non-negative integer `x` and an index `i`, then **update** `nums[i]` to be equal to `nums[i] AND (nums[i] XOR x)`.\n\nNote that `AND` is the bitwise AND operation and `XOR` is the bitwise XOR operation.\n\nReturn _the **maximum** possible bitwise XOR of all elements of_ `nums` _after applying the operation **any number** of times_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,4,6\\]\n**Output:** 7\n**Explanation:** Apply the operation with x = 4 and i = 3, num\\[3\\] = 6 AND (6 XOR 4) = 6 AND 2 = 2.\nNow, nums = \\[3, 2, 4, 2\\] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.\nIt can be shown that 7 is the maximum possible bitwise XOR.\nNote that other operations may be used to achieve a bitwise XOR of 7.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,9,2\\]\n**Output:** 11\n**Explanation:** Apply the operation zero times.\nThe bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.\nIt can be shown that 11 is the maximum possible bitwise XOR."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 108`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,2,4,6]",
                "output": "7"
            },
            {
                "input": "[1,2,3,9,2]",
                "output": "11"
            }
        ],
        "java": "\n    ```java\nint countCollisions(String directions) {\n    int collisionCount = 0, leftCount = 0;\n\n    for (char direction : directions.toCharArray()) {\n        if (direction == 'L') {\n            leftCount++;\n        } else if (direction == 'R') {\n            collisionCount += leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n```\n    \n    The algorithm iterates through the `directions` string, counting the number of 'L' characters (left moving cars) as `leftCount`. When a 'R' character (right moving car) is encountered, the number of collisions for that right moving car is equal to the current value of `leftCount` (as all those left moving cars will collide with the current right moving car). This value is added to `collisionCount`. The final value of `collisionCount` after iterating through the string is the total number of collisions that will happen on the road.\n    ",
        "python": "\n    ```python\ndef count_collisions(directions: str) -> int:\n    collision_count = 0\n    left_count = 0\n\n    for direction in directions:\n        if direction == 'L':\n            left_count += 1\n        elif direction == 'R':\n            collision_count += left_count\n\n    return collision_count\n```\n    \n    The algorithm iterates through the `directions` string, counting the number of 'L' characters (left moving cars) as `leftCount`. When a 'R' character (right moving car) is encountered, the number of collisions for that right moving car is equal to the current value of `leftCount` (as all those left moving cars will collide with the current right moving car). This value is added to `collisionCount`. The final value of `collisionCount` after iterating through the string is the total number of collisions that will happen on the road.\n    ",
        "c++": "\n    ```cpp\nint countCollisions(string directions) {\n    int collisionCount = 0, leftCount = 0;\n\n    for (char direction : directions) {\n        if (direction == 'L') {\n            leftCount++;\n        } else if (direction == 'R') {\n            collisionCount += leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n```\n    \n    The algorithm iterates through the `directions` string, counting the number of 'L' characters (left moving cars) as `leftCount`. When a 'R' character (right moving car) is encountered, the number of collisions for that right moving car is equal to the current value of `leftCount` (as all those left moving cars will collide with the current right moving car). This value is added to `collisionCount`. The final value of `collisionCount` after iterating through the string is the total number of collisions that will happen on the road.\n    ",
        "js": "\n    ```javascript\nfunction countCollisions(directions) {\n    let collisionCount = 0;\n    let leftCount = 0;\n\n    for (let direction of directions) {\n        if (direction === 'L') {\n            leftCount++;\n        } else if (direction === 'R') {\n            collisionCount += leftCount;\n        }\n    }\n\n    return collisionCount;\n}\n```\n    \n    The algorithm iterates through the `directions` string, counting the number of 'L' characters (left moving cars) as `leftCount`. When a 'R' character (right moving car) is encountered, the number of collisions for that right moving car is equal to the current value of `leftCount` (as all those left moving cars will collide with the current right moving car). This value is added to `collisionCount`. The final value of `collisionCount` after iterating through the string is the total number of collisions that will happen on the road.\n    "
    },
    {
        "id": 348,
        "title": "Find Minimum Time to Finish All Jobs II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `jobs` and `workers` of **equal** length, where `jobs[i]` is the amount of time needed to complete the `ith` job, and `workers[j]` is the amount of time the `jth` worker can work each day.\n\nEach job should be assigned to **exactly** one worker, such that each worker completes **exactly** one job.\n\nReturn _the **minimum** number of days needed to complete all the jobs after assignment._",
            "examples": [
                "**Example 1:**\n\n**Input:** jobs = \\[5,2,4\\], workers = \\[1,7,5\\]\n**Output:** 2\n**Explanation:**\n- Assign the 2nd worker to the 0th job. It takes them 1 day to finish the job.\n- Assign the 0th worker to the 1st job. It takes them 2 days to finish the job.\n- Assign the 1st worker to the 2nd job. It takes them 1 day to finish the job.\nIt takes 2 days for all the jobs to be completed, so return 2.\nIt can be proven that 2 days is the minimum number of days needed.\n\n",
                "**Example 2:**\n\n**Input:** jobs = \\[3,18,15,9\\], workers = \\[6,5,1,3\\]\n**Output:** 3\n**Explanation:**\n- Assign the 2nd worker to the 0th job. It takes them 3 days to finish the job.\n- Assign the 0th worker to the 1st job. It takes them 3 days to finish the job.\n- Assign the 1st worker to the 2nd job. It takes them 3 days to finish the job.\n- Assign the 3rd worker to the 3rd job. It takes them 3 days to finish the job.\nIt takes 3 days for all the jobs to be completed, so return 3.\nIt can be proven that 3 days is the minimum number of days needed."
            ],
            "constraints": "**Constraints:**\n\n*   `n == jobs.length == workers.length`\n*   `1 <= n <= 105`\n*   `1 <= jobs[i], workers[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[5,2,4],[1,7,5]",
                "output": "2"
            },
            {
                "input": "[3,18,15,9],[6,5,1,3]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minBitFlips(int start, int goal) {\n    int xorValue = start ^ goal;\n    int flips = 0;\n    while (xorValue != 0) {\n        flips += xorValue & 1;\n        xorValue >>= 1;\n    }\n    return flips;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n\n1. Use bitwise XOR (^) to get a binary value representing the differing bits between 'start' and 'goal'.\n2. Iterate through the binary XOR value counting the number of 1's, which represent the required bit flips.\n3. End when all the bits have been parsed and return the number of flips required.\n\nThis approach has a time complexity of O(log n), where n is the larger of the two input integers.\n    ",
        "python": "\n    ```python\ndef min_bit_flips(start, goal):\n    xor_value = start ^ goal\n    flips = 0\n    while xor_value:\n        flips += xor_value & 1\n        xor_value >>= 1\n    return flips\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n\n1. Use bitwise XOR (^) to get a binary value representing the differing bits between 'start' and 'goal'.\n2. Iterate through the binary XOR value counting the number of 1's, which represent the required bit flips.\n3. End when all the bits have been parsed and return the number of flips required.\n\nThis approach has a time complexity of O(log n), where n is the larger of the two input integers.\n    ",
        "c++": "\n    ```cpp\nint minBitFlips(int start, int goal) {\n    int xorValue = start ^ goal;\n    int flips = 0;\n    while (xorValue) {\n        flips += xorValue & 1;\n        xorValue >>= 1;\n    }\n    return flips;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n\n1. Use bitwise XOR (^) to get a binary value representing the differing bits between 'start' and 'goal'.\n2. Iterate through the binary XOR value counting the number of 1's, which represent the required bit flips.\n3. End when all the bits have been parsed and return the number of flips required.\n\nThis approach has a time complexity of O(log n), where n is the larger of the two input integers.\n    ",
        "js": "\n    ```javascript\nfunction minBitFlips(start, goal) {\n    let xorValue = start ^ goal;\n    let flips = 0;\n    while (xorValue) {\n        flips += xorValue & 1;\n        xorValue >>= 1;\n    }\n    return flips;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n\n1. Use bitwise XOR (^) to get a binary value representing the differing bits between 'start' and 'goal'.\n2. Iterate through the binary XOR value counting the number of 1's, which represent the required bit flips.\n3. End when all the bits have been parsed and return the number of flips required.\n\nThis approach has a time complexity of O(log n), where n is the larger of the two input integers.\n    "
    },
    {
        "id": 349,
        "title": "Valid Palindrome IV",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** string `s` consisting of only lowercase English letters. In one operation, you can change **any** character of `s` to any **other** character.\n\nReturn `true` _if you can make_ `s` _a palindrome after performing **exactly** one or two operations, or return_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcdba \"\n**Output:** true\n**Explanation:** One way to make s a palindrome using 1 operation is:\n- Change s\\[2\\] to 'd'. Now, s =  \"abddba \".\nOne operation could be performed to make s a palindrome so return true.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \"\n**Output:** true\n**Explanation:** One way to make s a palindrome using 2 operations is:\n- Change s\\[0\\] to 'b'. Now, s =  \"ba \".\n- Change s\\[1\\] to 'b'. Now, s =  \"bb \".\nTwo operations could be performed to make s a palindrome so return true.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abcdef \"\n**Output:** false\n**Explanation:** It is not possible to make s a palindrome using one or two operations so return false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"abcdba\"",
                "output": "true"
            },
            {
                "input": "\"aa\"",
                "output": "true"
            },
            {
                "input": "\"abcdef\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxBeauty(int[] flowers, int newFlowers, int target, int full, int partial) {\n    int beauty = 0;\n    for (int f : flowers)\n        beauty += (f >= target) ? full : partial * f;\n\n    Arrays.sort(flowers);\n\n    for (int i = 0; i < flowers.length && newFlowers > 0; ++i) {\n        int needed = target - flowers[i];\n        if (needed <= newFlowers) {\n            beauty += full - partial * flowers[i];\n            flowers[i] = target;\n            newFlowers -= needed;\n        }\n    }\n\n    return beauty;\n}\n```\n    \n    1. Calculate the initial beauty of the gardens using the number of flowers already planted.\n2. Sort the gardens by the number of flowers in non-descending order.\n3. For each garden (in non-descending order):\n   a. Calculate the number of flowers needed to reach the target.\n   b. If the number of needed flowers is less than or equal to the maximum number of new flowers Alice can plant, then update the beauty of the gardens, set this particular garden's number of flowers to the target, and subtract the number of needed flowers from newFlowers.\n4. Return the maximum total beauty after planting newFlowers.\n    ",
        "python": "\n    ```python\ndef max_beauty(flowers, new_flowers, target, full, partial):\n    beauty = sum(full if f >= target else partial * f for f in flowers)\n    flowers.sort()\n\n    for i in range(len(flowers)):\n        needed = target - flowers[i]\n        if needed <= new_flowers:\n            beauty += full - partial * flowers[i]\n            flowers[i] = target\n            new_flowers -= needed\n\n    return beauty\n```\n    \n    1. Calculate the initial beauty of the gardens using the number of flowers already planted.\n2. Sort the gardens by the number of flowers in non-descending order.\n3. For each garden (in non-descending order):\n   a. Calculate the number of flowers needed to reach the target.\n   b. If the number of needed flowers is less than or equal to the maximum number of new flowers Alice can plant, then update the beauty of the gardens, set this particular garden's number of flowers to the target, and subtract the number of needed flowers from newFlowers.\n4. Return the maximum total beauty after planting newFlowers.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxBeauty(std::vector<int>& flowers, int newFlowers, int target, int full, int partial) {\n    int beauty = 0;\n    for (int f : flowers)\n        beauty += (f >= target) ? full : partial * f;\n\n    std::sort(flowers.begin(), flowers.end());\n\n    for (int i = 0; i < flowers.size() && newFlowers > 0; ++i) {\n        int needed = target - flowers[i];\n        if (needed <= newFlowers) {\n            beauty += full - partial * flowers[i];\n            flowers[i] = target;\n            newFlowers -= needed;\n        }\n    }\n\n    return beauty;\n}\n```\n    \n    1. Calculate the initial beauty of the gardens using the number of flowers already planted.\n2. Sort the gardens by the number of flowers in non-descending order.\n3. For each garden (in non-descending order):\n   a. Calculate the number of flowers needed to reach the target.\n   b. If the number of needed flowers is less than or equal to the maximum number of new flowers Alice can plant, then update the beauty of the gardens, set this particular garden's number of flowers to the target, and subtract the number of needed flowers from newFlowers.\n4. Return the maximum total beauty after planting newFlowers.\n    ",
        "js": "\n    ```javascript\nfunction maxBeauty(flowers, newFlowers, target, full, partial) {\n    let beauty = flowers.reduce((acc, f) => acc + (f >= target ? full : partial * f), 0);\n    flowers.sort((a, b) => a - b);\n\n    for (let i = 0; i < flowers.length && newFlowers > 0; ++i) {\n        let needed = target - flowers[i];\n        if (needed <= newFlowers) {\n            beauty += full - partial * flowers[i];\n            flowers[i] = target;\n            newFlowers -= needed;\n        }\n    }\n\n    return beauty;\n}\n```\n    \n    1. Calculate the initial beauty of the gardens using the number of flowers already planted.\n2. Sort the gardens by the number of flowers in non-descending order.\n3. For each garden (in non-descending order):\n   a. Calculate the number of flowers needed to reach the target.\n   b. If the number of needed flowers is less than or equal to the maximum number of new flowers Alice can plant, then update the beauty of the gardens, set this particular garden's number of flowers to the target, and subtract the number of needed flowers from newFlowers.\n4. Return the maximum total beauty after planting newFlowers.\n    "
    },
    {
        "id": 350,
        "title": "Minimum Adjacent Swaps to Make a Valid Array",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`.\n\n**Swaps** of **adjacent** elements are able to be performed on `nums`.\n\nA **valid** array meets the following conditions:\n\n*   The largest element (any of the largest elements if there are multiple) is at the rightmost position in the array.\n*   The smallest element (any of the smallest elements if there are multiple) is at the leftmost position in the array.\n\nReturn _the **minimum** swaps required to make_ `nums` _a valid array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,4,5,5,3,1\\]\n**Output:** 6\n**Explanation:** Perform the following swaps:\n- Swap 1: Swap the 3rd and 4th elements, nums is then \\[3,4,5,**3**,**5**,1\\].\n- Swap 2: Swap the 4th and 5th elements, nums is then \\[3,4,5,3,**1**,**5**\\].\n- Swap 3: Swap the 3rd and 4th elements, nums is then \\[3,4,5,**1**,**3**,5\\].\n- Swap 4: Swap the 2nd and 3rd elements, nums is then \\[3,4,**1**,**5**,3,5\\].\n- Swap 5: Swap the 1st and 2nd elements, nums is then \\[3,**1**,**4**,5,3,5\\].\n- Swap 6: Swap the 0th and 1st elements, nums is then \\[**1**,**3**,4,5,3,5\\].\nIt can be shown that 6 swaps is the minimum swaps required to make a valid array.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9\\]\n**Output:** 0\n**Explanation:** The array is already valid, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,4,5,5,3,1]",
                "output": "6"
            },
            {
                "input": "[9]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minSwaps(int[] nums) {\n    int n = nums.length;\n    int minPos = 0, maxPos = 0, swaps = 0;\n\n    for (int i = 1; i < n; i++) {\n        if (nums[i] <= nums[minPos])\n            minPos = i;\n        if (nums[i] >= nums[maxPos])\n            maxPos = i;\n    }\n\n    swaps = minPos + (n - 1 - maxPos);\n    if (minPos < maxPos) swaps--;\n\n    return swaps;\n}\n```\n    \n    The algorithm first initializes the minimum and maximum element positions (`minPos` and `maxPos`) as 0.\nThen, it iterates through each element of the array, updating the positions if it's smaller or equal to the current minimum or larger or equal to the current maximum.\n\nAfter calculating the positions of the minimum and maximum elements, the algorithm calculates the number of swaps needed to place the minimum element at the leftmost position and the maximum element at the rightmost position, which is given by `minPos + (n - 1 - maxPos)`. At last, if `minPos` is smaller than `maxPos`, we decrement the swaps counter by 1 because we need one less swap to move both minimum and maximum elements to their designated positions.\n\nLastly, the algorithm returns the calculated `swaps` count.\n    ",
        "python": "\n    ```python\ndef minSwaps(nums):\n    n = len(nums)\n    minPos = 0\n    maxPos = 0\n    swaps = 0\n\n    for i in range(1, n):\n        if nums[i] <= nums[minPos]:\n            minPos = i\n        if nums[i] >= nums[maxPos]:\n            maxPos = i\n\n    swaps = minPos + (n - 1 - maxPos)\n    if minPos < maxPos:\n        swaps -= 1\n\n    return swaps\n```\n    \n    The algorithm first initializes the minimum and maximum element positions (`minPos` and `maxPos`) as 0.\nThen, it iterates through each element of the array, updating the positions if it's smaller or equal to the current minimum or larger or equal to the current maximum.\n\nAfter calculating the positions of the minimum and maximum elements, the algorithm calculates the number of swaps needed to place the minimum element at the leftmost position and the maximum element at the rightmost position, which is given by `minPos + (n - 1 - maxPos)`. At last, if `minPos` is smaller than `maxPos`, we decrement the swaps counter by 1 because we need one less swap to move both minimum and maximum elements to their designated positions.\n\nLastly, the algorithm returns the calculated `swaps` count.\n    ",
        "c++": "\n    ```cpp\nint minSwaps(vector<int>& nums) {\n    int n = nums.size();\n    int minPos = 0, maxPos = 0, swaps = 0;\n\n    for (int i = 1; i < n; i++) {\n        if (nums[i] <= nums[minPos])\n            minPos = i;\n        if (nums[i] >= nums[maxPos])\n            maxPos = i;\n    }\n\n    swaps = minPos + (n - 1 - maxPos);\n    if (minPos < maxPos) swaps--;\n\n    return swaps;\n}\n```\n    \n    The algorithm first initializes the minimum and maximum element positions (`minPos` and `maxPos`) as 0.\nThen, it iterates through each element of the array, updating the positions if it's smaller or equal to the current minimum or larger or equal to the current maximum.\n\nAfter calculating the positions of the minimum and maximum elements, the algorithm calculates the number of swaps needed to place the minimum element at the leftmost position and the maximum element at the rightmost position, which is given by `minPos + (n - 1 - maxPos)`. At last, if `minPos` is smaller than `maxPos`, we decrement the swaps counter by 1 because we need one less swap to move both minimum and maximum elements to their designated positions.\n\nLastly, the algorithm returns the calculated `swaps` count.\n    ",
        "js": "\n    ```javascript\nfunction minSwaps(nums) {\n    let n = nums.length;\n    let minPos = 0, maxPos = 0, swaps = 0;\n\n    for (let i = 1; i < n; i++) {\n        if (nums[i] <= nums[minPos])\n            minPos = i;\n        if (nums[i] >= nums[maxPos])\n            maxPos = i;\n    }\n\n    swaps = minPos + (n - 1 - maxPos);\n    if (minPos < maxPos) swaps--;\n\n    return swaps;\n}\n```\n    \n    The algorithm first initializes the minimum and maximum element positions (`minPos` and `maxPos`) as 0.\nThen, it iterates through each element of the array, updating the positions if it's smaller or equal to the current minimum or larger or equal to the current maximum.\n\nAfter calculating the positions of the minimum and maximum elements, the algorithm calculates the number of swaps needed to place the minimum element at the leftmost position and the maximum element at the rightmost position, which is given by `minPos + (n - 1 - maxPos)`. At last, if `minPos` is smaller than `maxPos`, we decrement the swaps counter by 1 because we need one less swap to move both minimum and maximum elements to their designated positions.\n\nLastly, the algorithm returns the calculated `swaps` count.\n    "
    },
    {
        "id": 351,
        "title": "Finding the Number of Visible Mountains",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `peaks` where `peaks[i] = [xi, yi]` states that mountain `i` has a peak at coordinates `(xi, yi)`. A mountain can be described as a right-angled isosceles triangle, with its base along the `x`\\-axis and a right angle at its peak. More formally, the **gradients** of ascending and descending the mountain are `1` and `-1` respectively.\n\nA mountain is considered **visible** if its peak does not lie within another mountain (including the border of other mountains).\n\nReturn _the number of visible mountains_.",
            "examples": [
                "**Example 1:**\n\n**Input:** peaks = \\[\\[2,2\\],\\[6,3\\],\\[5,4\\]\\]\n**Output:** 2\n**Explanation:** The diagram above shows the mountains.\n- Mountain 0 is visible since its peak does not lie within another mountain or its sides.\n- Mountain 1 is not visible since its peak lies within the side of mountain 2.\n- Mountain 2 is visible since its peak does not lie within another mountain or its sides.\nThere are 2 mountains that are visible.\n\n",
                "**Example 2:**\n\n**Input:** peaks = \\[\\[1,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows the mountains (they completely overlap).\nBoth mountains are not visible since their peaks lie within each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= peaks.length <= 105`\n*   `peaks[i].length == 2`\n*   `1 <= xi, yi <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[2,2],[6,3],[5,4]]",
                "output": "2"
            },
            {
                "input": "[[1,3],[1,3]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(String current, String correct) {\n    int currentMins = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3, 5));\n    int correctMins = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3, 5));\n    if(currentMins > correctMins) correctMins += 24 * 60;\n    \n    int diff = correctMins - currentMins;\n    int count = diff / 60 + (diff % 60) / 15 + ((diff % 60) % 15) / 5 + (((diff % 60) % 15) % 5);\n\n    return count;\n}\n```\n    \n    1. Convert both `current` and `correct` strings into minutes (HH * 60 + MM).\n2. If `currentMins` is greater than `correctMins`, increment `correctMins` by the number of minutes in a day (24 * 60) to account for potential timezone crossing.\n3. Calculate the difference between `correctMins` and `currentMins`.\n4. Count the minimum operations needed to cover the difference by dividing it by the largest possible operation (60) and updating the remaining difference for smaller operations such as 15, 5, and 1. Add the result of each calculation to `count`.\n5. Return the minimum number of operations as `count`.\n    ",
        "python": "\n    ```python\ndef min_operations(current, correct):\n    current_mins = int(current[:2]) * 60 + int(current[3:])\n    correct_mins = int(correct[:2]) * 60 + int(correct[3:])\n    if current_mins > correct_mins:\n        correct_mins += 24 * 60\n\n    diff = correct_mins - current_mins\n    count = diff // 60 + (diff % 60) // 15 + ((diff % 60) % 15) // 5 + (((diff % 60) % 15) % 5)\n\n    return count\n```\n    \n    1. Convert both `current` and `correct` strings into minutes (HH * 60 + MM).\n2. If `currentMins` is greater than `correctMins`, increment `correctMins` by the number of minutes in a day (24 * 60) to account for potential timezone crossing.\n3. Calculate the difference between `correctMins` and `currentMins`.\n4. Count the minimum operations needed to cover the difference by dividing it by the largest possible operation (60) and updating the remaining difference for smaller operations such as 15, 5, and 1. Add the result of each calculation to `count`.\n5. Return the minimum number of operations as `count`.\n    ",
        "c++": "\n    ```cpp\nint minOperations(std::string current, std::string correct) {\n    int currentMins = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2));\n    int correctMins = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2));\n    if (currentMins > correctMins) correctMins += 24 * 60;\n\n    int diff = correctMins - currentMins;\n    int count = diff / 60 + (diff % 60) / 15 + ((diff % 60) % 15) / 5 + (((diff % 60) % 15) % 5);\n\n    return count;\n}\n```\n    \n    1. Convert both `current` and `correct` strings into minutes (HH * 60 + MM).\n2. If `currentMins` is greater than `correctMins`, increment `correctMins` by the number of minutes in a day (24 * 60) to account for potential timezone crossing.\n3. Calculate the difference between `correctMins` and `currentMins`.\n4. Count the minimum operations needed to cover the difference by dividing it by the largest possible operation (60) and updating the remaining difference for smaller operations such as 15, 5, and 1. Add the result of each calculation to `count`.\n5. Return the minimum number of operations as `count`.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(current, correct) {\n    let currentMins = parseInt(current.substring(0, 2)) * 60 + parseInt(current.substring(3, 5));\n    let correctMins = parseInt(correct.substring(0, 2)) * 60 + parseInt(correct.substring(3, 5));\n    if (currentMins > correctMins) correctMins += 24 * 60;\n\n    let diff = correctMins - currentMins;\n    let count = Math.floor(diff / 60) + Math.floor((diff % 60) / 15) + Math.floor(((diff % 60) % 15) / 5) + Math.floor((((diff % 60) % 15) % 5));\n\n    return count;\n}\n```\n    \n    1. Convert both `current` and `correct` strings into minutes (HH * 60 + MM).\n2. If `currentMins` is greater than `correctMins`, increment `correctMins` by the number of minutes in a day (24 * 60) to account for potential timezone crossing.\n3. Calculate the difference between `correctMins` and `currentMins`.\n4. Count the minimum operations needed to cover the difference by dividing it by the largest possible operation (60) and updating the remaining difference for smaller operations such as 15, 5, and 1. Add the result of each calculation to `count`.\n5. Return the minimum number of operations as `count`.\n    "
    },
    {
        "id": 352,
        "title": "Maximum Number of Books You Can Take",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `books` of length `n` where `books[i]` denotes the number of books on the `ith` shelf of a bookshelf.\n\nYou are going to take books from a **contiguous** section of the bookshelf spanning from `l` to `r` where `0 <= l <= r < n`. For each index `i` in the range `l <= i < r`, you must take **strictly fewer** books from shelf `i` than shelf `i + 1`.\n\nReturn _the **maximum** number of books you can take from the bookshelf._",
            "examples": [
                "**Example 1:**\n\n**Input:** books = \\[8,5,2,7,9\\]\n**Output:** 19\n**Explanation:**\n- Take 1 book from shelf 1.\n- Take 2 books from shelf 2.\n- Take 7 books from shelf 3.\n- Take 9 books from shelf 4.\nYou have taken 19 books, so return 19.\nIt can be proven that 19 is the maximum number of books you can take.\n\n",
                "**Example 2:**\n\n**Input:** books = \\[7,0,3,4,5\\]\n**Output:** 12\n**Explanation:**\n- Take 3 books from shelf 2.\n- Take 4 books from shelf 3.\n- Take 5 books from shelf 4.\nYou have taken 12 books so return 12.\nIt can be proven that 12 is the maximum number of books you can take.\n\n",
                "**Example 3:**\n\n**Input:** books = \\[8,2,3,7,3,4,0,1,4,3\\]\n**Output:** 13\n**Explanation:**\n- Take 1 book from shelf 0.\n- Take 2 books from shelf 1.\n- Take 3 books from shelf 2.\n- Take 7 books from shelf 3.\nYou have taken 13 books so return 13.\nIt can be proven that 13 is the maximum number of books you can take."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= books.length <= 105`\n*   `0 <= books[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[8,5,2,7,9]",
                "output": "19"
            },
            {
                "input": "[7,0,3,4,5]",
                "output": "12"
            },
            {
                "input": "[8,2,3,7,3,4,0,1,4,3]",
                "output": "13"
            }
        ],
        "java": "\n    ```java\nint maxBooks(int[] books) {\n    int n = books.length;\n    int max_books = 0;\n    \n    for (int l = 0; l < n; ++l) {\n        int r = l + 1, books_taken = books[l], min_taken = books[l];\n        max_books = Math.max(max_books, books_taken);\n        \n        while (r < n) {\n            min_taken = Math.min(min_taken, books[r]);\n            books_taken += min_taken;\n            max_books = Math.max(max_books, books_taken);\n            \n            if (min_taken <= 1) break; // Can't decrease further\n            ++r;\n        }\n    }\n    \n    return max_books;\n}\n```\n    \n    The algorithm starts with a loop that iterates through the books array from the first index to the last index (0 to n-1). For each index `l` (left), it initializes the variables `books_taken` & `min_taken` to the value of books[l]. Then, it iterates from index `l+1` (right) to the last index of the books array. In the inner loop, updates `min_taken` with the minimum value between `min_taken` and books[r] and add the value of `min_taken` to `books_taken`. It updates the value of `max_books` with the maximum value between `max_books` and `books_taken`. These steps are repeated for every pair of l and r such that 0 <= l <= r < n.\n\nThe algorithm aims to find the maximum number of books taken from a contiguous section of the bookshelf, following the constraint \"strictly fewer books from shelf i than shelf i+1\". The loop will identify the optimal segments in every iteration/update `max_books`.\n\nThe breaks condition (`if min_taken <= 1`) is checked, and if it's `True`, the loop exits since the number of books can't decrease further, according to the constraints.\n\nFinally, the maximum number of books taken is returned as the answer.\n    ",
        "python": "\n    ```python\ndef max_books(books):\n    n = len(books)\n    max_books = 0\n    \n    for l in range(n):\n        r = l + 1\n        books_taken = books[l]\n        min_taken = books[l]\n        max_books = max(max_books, books_taken)\n        \n        while r < n:\n            min_taken = min(min_taken, books[r])\n            books_taken += min_taken\n            max_books = max(max_books, books_taken)\n            \n            if min_taken <= 1:\n                break  # Can't decrease further\n            r += 1\n            \n    return max_books\n```\n    \n    The algorithm starts with a loop that iterates through the books array from the first index to the last index (0 to n-1). For each index `l` (left), it initializes the variables `books_taken` & `min_taken` to the value of books[l]. Then, it iterates from index `l+1` (right) to the last index of the books array. In the inner loop, updates `min_taken` with the minimum value between `min_taken` and books[r] and add the value of `min_taken` to `books_taken`. It updates the value of `max_books` with the maximum value between `max_books` and `books_taken`. These steps are repeated for every pair of l and r such that 0 <= l <= r < n.\n\nThe algorithm aims to find the maximum number of books taken from a contiguous section of the bookshelf, following the constraint \"strictly fewer books from shelf i than shelf i+1\". The loop will identify the optimal segments in every iteration/update `max_books`.\n\nThe breaks condition (`if min_taken <= 1`) is checked, and if it's `True`, the loop exits since the number of books can't decrease further, according to the constraints.\n\nFinally, the maximum number of books taken is returned as the answer.\n    ",
        "c++": "\n    ```cpp\nint maxBooks(vector<int>& books) {\n    int n = books.size();\n    int max_books = 0;\n    \n    for (int l = 0; l < n; ++l) {\n        int r = l + 1, books_taken = books[l], min_taken = books[l];\n        max_books = max(max_books, books_taken);\n        \n        while (r < n) {\n            min_taken = min(min_taken, books[r]);\n            books_taken += min_taken;\n            max_books = max(max_books, books_taken);\n            \n            if (min_taken <= 1) break; // Can't decrease further\n            ++r;\n        }\n    }\n    \n    return max_books;\n}\n```\n    \n    The algorithm starts with a loop that iterates through the books array from the first index to the last index (0 to n-1). For each index `l` (left), it initializes the variables `books_taken` & `min_taken` to the value of books[l]. Then, it iterates from index `l+1` (right) to the last index of the books array. In the inner loop, updates `min_taken` with the minimum value between `min_taken` and books[r] and add the value of `min_taken` to `books_taken`. It updates the value of `max_books` with the maximum value between `max_books` and `books_taken`. These steps are repeated for every pair of l and r such that 0 <= l <= r < n.\n\nThe algorithm aims to find the maximum number of books taken from a contiguous section of the bookshelf, following the constraint \"strictly fewer books from shelf i than shelf i+1\". The loop will identify the optimal segments in every iteration/update `max_books`.\n\nThe breaks condition (`if min_taken <= 1`) is checked, and if it's `True`, the loop exits since the number of books can't decrease further, according to the constraints.\n\nFinally, the maximum number of books taken is returned as the answer.\n    ",
        "js": "\n    ```javascript\nfunction maxBooks(books) {\n    const n = books.length;\n    let max_books = 0;\n    \n    for (let l = 0; l < n; ++l) {\n        let r = l + 1;\n        let books_taken = books[l];\n        let min_taken = books[l];\n        max_books = Math.max(max_books, books_taken);\n        \n        while (r < n) {\n            min_taken = Math.min(min_taken, books[r]);\n            books_taken += min_taken;\n            max_books = Math.max(max_books, books_taken);\n            \n            if (min_taken <= 1) break; // Can't decrease further\n            ++r;\n        }\n    }\n    \n    return max_books;\n}\n```\n    \n    The algorithm starts with a loop that iterates through the books array from the first index to the last index (0 to n-1). For each index `l` (left), it initializes the variables `books_taken` & `min_taken` to the value of books[l]. Then, it iterates from index `l+1` (right) to the last index of the books array. In the inner loop, updates `min_taken` with the minimum value between `min_taken` and books[r] and add the value of `min_taken` to `books_taken`. It updates the value of `max_books` with the maximum value between `max_books` and `books_taken`. These steps are repeated for every pair of l and r such that 0 <= l <= r < n.\n\nThe algorithm aims to find the maximum number of books taken from a contiguous section of the bookshelf, following the constraint \"strictly fewer books from shelf i than shelf i+1\". The loop will identify the optimal segments in every iteration/update `max_books`.\n\nThe breaks condition (`if min_taken <= 1`) is checked, and if it's `True`, the loop exits since the number of books can't decrease further, according to the constraints.\n\nFinally, the maximum number of books taken is returned as the answer.\n    "
    },
    {
        "id": 353,
        "title": "Minimum Costs Using the Train Line",
        "difficulty": "Hard",
        "content": {
            "problem": "A train line going through a city has two routes, the regular route and the express route. Both routes go through the **same** `n + 1` stops labeled from `0` to `n`. Initially, you start on the regular route at stop `0`.\n\nYou are given two **1-indexed** integer arrays `regular` and `express`, both of length `n`. `regular[i]` describes the cost it takes to go from stop `i - 1` to stop `i` using the regular route, and `express[i]` describes the cost it takes to go from stop `i - 1` to stop `i` using the express route.\n\nYou are also given an integer `expressCost` which represents the cost to transfer from the regular route to the express route.\n\nNote that:\n\n*   There is no cost to transfer from the express route back to the regular route.\n*   You pay `expressCost` **every** time you transfer from the regular route to the express route.\n*   There is no extra cost to stay on the express route.\n\nReturn _a **1-indexed** array_ `costs` _of length_ `n`_, where_ `costs[i]` _is the **minimum** cost to reach stop_ `i` _from stop_ `0`.\n\nNote that a stop can be counted as **reached** from either route.",
            "examples": [
                "**Example 1:**\n\n**Input:** regular = \\[1,6,9,5\\], express = \\[5,2,3,10\\], expressCost = 8\n**Output:** \\[1,7,14,19\\]\n**Explanation:** The diagram above shows how to reach stop 4 from stop 0 with minimum cost.\n- Take the regular route from stop 0 to stop 1, costing 1.\n- Take the express route from stop 1 to stop 2, costing 8 + 2 = 10.\n- Take the express route from stop 2 to stop 3, costing 3.\n- Take the regular route from stop 3 to stop 4, costing 5.\nThe total cost is 1 + 10 + 3 + 5 = 19.\nNote that a different route could be taken to reach the other stops with minimum cost.\n\n",
                "**Example 2:**\n\n**Input:** regular = \\[11,5,13\\], express = \\[7,10,6\\], expressCost = 3\n**Output:** \\[10,15,24\\]\n**Explanation:** The diagram above shows how to reach stop 3 from stop 0 with minimum cost.\n- Take the express route from stop 0 to stop 1, costing 3 + 7 = 10.\n- Take the regular route from stop 1 to stop 2, costing 5.\n- Take the express route from stop 2 to stop 3, costing 3 + 6 = 9.\nThe total cost is 10 + 5 + 9 = 24.\nNote that the expressCost is paid again to transfer back to the express route."
            ],
            "constraints": "**Constraints:**\n\n*   `n == regular.length == express.length`\n*   `1 <= n <= 105`\n*   `1 <= regular[i], express[i], expressCost <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,6,9,5],[5,2,3,10],8",
                "output": "[1,7,14,19]"
            },
            {
                "input": "[11,5,13],[7,10,6],3",
                "output": "[10,15,24]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] minStopCosts(int[] regular, int[] express, int expressCost) {\n    int n = regular.length;\n    int[] costs = new int[n];\n    int regular_sum = 0, express_sum = expressCost;\n\n    for (int i = 0; i < n; ++i) {\n        regular_sum += regular[i];\n        express_sum += express[i];\n        costs[i] = Math.min(regular_sum, express_sum + expressCost);\n    }\n\n    return costs;\n}\n```\n    \n    The algorithm computes the minimum cost for reaching each stop `i` from the start `0`. We maintain two sums, `regular_sum` and `express_sum`, representing the costs spent on both routes.\n\n1. Initialize `regular_sum` to `0` and `express_sum` to `expressCost`, because we always begin from the regular route and have to pay the cost to transfer to the express route.\n2. Iterate over stops from `0` to `n-1`.\n3. In each iteration, update `regular_sum` by adding the cost to move to the next stop using the regular route, and update `express_sum` by adding the cost to move to the next stop using the express route.\n4. For each stop `i`, the minimum cost is the minimum of either staying on the regular route or transferring to the express route and moving to the next stop. So, `costs[i] = min(regular_sum, express_sum + expressCost)`.\n5. After the loop, return the array `costs`.\n\nThe time complexity is O(n) and the space complexity is O(n).\n    ",
        "python": "\n    ```python\ndef min_stop_costs(regular, express, express_cost):\n    n = len(regular)\n    costs = [0] * n\n    regular_sum, express_sum = 0, express_cost\n\n    for i in range(n):\n        regular_sum += regular[i]\n        express_sum += express[i]\n        costs[i] = min(regular_sum, express_sum + express_cost)\n\n    return costs\n```\n    \n    The algorithm computes the minimum cost for reaching each stop `i` from the start `0`. We maintain two sums, `regular_sum` and `express_sum`, representing the costs spent on both routes.\n\n1. Initialize `regular_sum` to `0` and `express_sum` to `expressCost`, because we always begin from the regular route and have to pay the cost to transfer to the express route.\n2. Iterate over stops from `0` to `n-1`.\n3. In each iteration, update `regular_sum` by adding the cost to move to the next stop using the regular route, and update `express_sum` by adding the cost to move to the next stop using the express route.\n4. For each stop `i`, the minimum cost is the minimum of either staying on the regular route or transferring to the express route and moving to the next stop. So, `costs[i] = min(regular_sum, express_sum + expressCost)`.\n5. After the loop, return the array `costs`.\n\nThe time complexity is O(n) and the space complexity is O(n).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> minStopCosts(vector<int>& regular, vector<int>& express, int expressCost) {\n    int n = regular.size();\n    vector<int> costs(n);\n    int regular_sum = 0, express_sum = expressCost;\n\n    for (int i = 0; i < n; ++i) {\n        regular_sum += regular[i];\n        express_sum += express[i];\n        costs[i] = min(regular_sum, express_sum + expressCost);\n    }\n\n    return costs;\n}\n```\n    \n    The algorithm computes the minimum cost for reaching each stop `i` from the start `0`. We maintain two sums, `regular_sum` and `express_sum`, representing the costs spent on both routes.\n\n1. Initialize `regular_sum` to `0` and `express_sum` to `expressCost`, because we always begin from the regular route and have to pay the cost to transfer to the express route.\n2. Iterate over stops from `0` to `n-1`.\n3. In each iteration, update `regular_sum` by adding the cost to move to the next stop using the regular route, and update `express_sum` by adding the cost to move to the next stop using the express route.\n4. For each stop `i`, the minimum cost is the minimum of either staying on the regular route or transferring to the express route and moving to the next stop. So, `costs[i] = min(regular_sum, express_sum + expressCost)`.\n5. After the loop, return the array `costs`.\n\nThe time complexity is O(n) and the space complexity is O(n).\n    ",
        "js": "\n    ```javascript\nfunction minStopCosts(regular, express, expressCost) {\n    const n = regular.length;\n    const costs = new Array(n);\n    let regular_sum = 0, express_sum = expressCost;\n\n    for (let i = 0; i < n; ++i) {\n        regular_sum += regular[i];\n        express_sum += express[i];\n        costs[i] = Math.min(regular_sum, express_sum + expressCost);\n    }\n\n    return costs;\n}\n```\n    \n    The algorithm computes the minimum cost for reaching each stop `i` from the start `0`. We maintain two sums, `regular_sum` and `express_sum`, representing the costs spent on both routes.\n\n1. Initialize `regular_sum` to `0` and `express_sum` to `expressCost`, because we always begin from the regular route and have to pay the cost to transfer to the express route.\n2. Iterate over stops from `0` to `n-1`.\n3. In each iteration, update `regular_sum` by adding the cost to move to the next stop using the regular route, and update `express_sum` by adding the cost to move to the next stop using the express route.\n4. For each stop `i`, the minimum cost is the minimum of either staying on the regular route or transferring to the express route and moving to the next stop. So, `costs[i] = min(regular_sum, express_sum + expressCost)`.\n5. After the loop, return the array `costs`.\n\nThe time complexity is O(n) and the space complexity is O(n).\n    "
    },
    {
        "id": 354,
        "title": "Minimize Maximum Value in a Grid",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` integer matrix `grid` containing **distinct** positive integers.\n\nYou have to replace each integer in the matrix with a positive integer satisfying the following conditions:\n\n*   The **relative** order of every two elements that are in the same row or column should stay the **same** after the replacements.\n*   The **maximum** number in the matrix after the replacements should be as **small** as possible.\n\nThe relative order stays the same if for all pairs of elements in the original matrix such that `grid[r1][c1] > grid[r2][c2]` where either `r1 == r2` or `c1 == c2`, then it must be true that `grid[r1][c1] > grid[r2][c2]` after the replacements.\n\nFor example, if `grid = [[2, 4, 5], [7, 3, 9]]` then a good replacement could be either `grid = [[1, 2, 3], [2, 1, 4]]` or `grid = [[1, 2, 3], [3, 1, 4]]`.\n\nReturn _the **resulting** matrix._ If there are multiple answers, return **any** of them.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[3,1\\],\\[2,5\\]\\]\n**Output:** \\[\\[2,1\\],\\[1,2\\]\\]\n**Explanation:** The above diagram shows a valid replacement.\nThe maximum number in the matrix is 2. It can be shown that no smaller value can be obtained.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[10\\]\\]\n**Output:** \\[\\[1\\]\\]\n**Explanation:** We replace the only number in the matrix with 1."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 109`\n*   `grid` consists of distinct integers.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[3,1],[2,5]]",
                "output": "[[2,1],[1,2]]"
            },
            {
                "input": "[[10]]",
                "output": "[[1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[][] smallestMaxNumberGrid(int[][] grid) {\n    int[] rows = new int[grid.length];\n    int[] cols = new int[grid[0].length];\n    \n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            rows[i] = Math.max(rows[i], grid[i][j]);\n            cols[j] = Math.max(cols[j], grid[i][j]);\n        }\n    }\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            grid[i][j] = Math.min(rows[i], cols[j]);\n        }\n    }\n\n    return grid;\n}\n```\n\n    \n    First, we create two arrays of length `m` and `n` to represent the rows and columns of the input grid. We then iterate through each row and column of the grid, updating the row and column arrays with the maximum values found in each. Finally, we iterate through the input grid again and update each value to be the minimum of its corresponding row and column maximum value.\n    ",
        "python": "\n    ```python\ndef smallest_max_number_grid(grid):\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            rows[i] = max(rows[i], grid[i][j])\n            cols[j] = max(cols[j], grid[i][j])\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            grid[i][j] = min(rows[i], cols[j])\n\n    return grid\n```\n\n    \n    First, we create two arrays of length `m` and `n` to represent the rows and columns of the input grid. We then iterate through each row and column of the grid, updating the row and column arrays with the maximum values found in each. Finally, we iterate through the input grid again and update each value to be the minimum of its corresponding row and column maximum value.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> smallestMaxNumberGrid(std::vector<std::vector<int>>& grid) {\n    std::vector<int> rows(grid.size()), cols(grid[0].size());\n    \n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            rows[i] = std::max(rows[i], grid[i][j]);\n            cols[j] = std::max(cols[j], grid[i][j]);\n        }\n    }\n\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[i].size(); j++) {\n            grid[i][j] = std::min(rows[i], cols[j]);\n        }\n    }\n    \n    return grid;\n}\n```\n\n    \n    First, we create two arrays of length `m` and `n` to represent the rows and columns of the input grid. We then iterate through each row and column of the grid, updating the row and column arrays with the maximum values found in each. Finally, we iterate through the input grid again and update each value to be the minimum of its corresponding row and column maximum value.\n    ",
        "js": "\n    ```javascript\nfunction smallestMaxNumberGrid(grid) {\n    let rows = new Array(grid.length).fill(0);\n    let cols = new Array(grid[0].length).fill(0);\n\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            rows[i] = Math.max(rows[i], grid[i][j]);\n            cols[j] = Math.max(cols[j], grid[i][j]);\n        }\n    }\n\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            grid[i][j] = Math.min(rows[i], cols[j]);\n        }\n    }\n\n    return grid;\n}\n```\n\n    \n    First, we create two arrays of length `m` and `n` to represent the rows and columns of the input grid. We then iterate through each row and column of the grid, updating the row and column arrays with the maximum values found in each. Finally, we iterate through the input grid again and update each value to be the minimum of its corresponding row and column maximum value.\n    "
    },
    {
        "id": 355,
        "title": "Choose Edges to Maximize Score in a Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **weighted** tree consisting of `n` nodes numbered from `0` to `n - 1`.\n\nThe tree is **rooted** at node `0` and represented with a **2D** array `edges` of size `n` where `edges[i] = [pari, weighti]` indicates that node `pari` is the **parent** of node `i`, and the edge between them has a weight equal to `weighti`. Since the root does **not** have a parent, you have `edges[0] = [-1, -1]`.\n\nChoose some edges from the tree such that no two chosen edges are **adjacent** and the **sum** of the weights of the chosen edges is maximized.\n\nReturn _the **maximum** sum of the chosen edges_.\n\n**Note**:\n\n*   You are allowed to **not** choose any edges in the tree, the sum of weights in this case will be `0`.\n*   Two edges `Edge1` and `Edge2` in the tree are **adjacent** if they have a **common** node.\n    *   In other words, they are adjacent if `Edge1` connects nodes `a` and `b` and `Edge2` connects nodes `b` and `c`.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[-1,-1\\],\\[0,5\\],\\[0,10\\],\\[2,6\\],\\[2,4\\]\\]\n**Output:** 11\n**Explanation:** The above diagram shows the edges that we have to choose colored in red.\nThe total score is 5 + 6 = 11.\nIt can be shown that no better score can be obtained.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[-1,-1\\],\\[0,5\\],\\[0,-6\\],\\[0,7\\]\\]\n**Output:** 7\n**Explanation:** We choose the edge with weight 7.\nNote that we cannot choose more than one edge because all edges are adjacent to each other."
            ],
            "constraints": "**Constraints:**\n\n*   `n == edges.length`\n*   `1 <= n <= 105`\n*   `edges[i].length == 2`\n*   `par0 == weight0 == -1`\n*   `0 <= pari <= n - 1` for all `i >= 1`.\n*   `pari != i`\n*   `-106 <= weighti <= 106` for all `i >= 1`.\n*   `edges` represents a valid tree.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[-1,-1],[0,5],[0,10],[2,6],[2,4]]",
                "output": "11"
            },
            {
                "input": "[[-1,-1],[0,5],[0,-6],[0,7]]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic int maxWeight(int[][] edges) {\n    int n = edges.length;\n    int[][] dp = new int[n][2];\n    \n    class Helper {\n        void dfs(int node) {\n            for (int i = 1; i < n; ++i) {\n                if (edges[i][0] == node) {\n                    dfs(i);\n                    dp[node][0] += Math.max(dp[i][0], dp[i][1]);\n                    dp[node][1] += dp[i][0];\n                }\n            }\n            dp[node][1] += edges[node][1];\n        }\n    }\n    Helper helper = new Helper();\n    helper.dfs(0);\n\n    return Math.max(dp[0][0], dp[0][1]);\n}\n```\n    \n    The problem can be solved using Dynamic Programming with Tree Traversal (DFS). We use an `n x 2` DP table where `dp[i][0]` stores the maximum sum without including the weight of node i and `dp[i][1]` stores the maximum sum including the weight of node i.\n\nWe start the DFS traversal from the root. For each node i in the tree, we first perform DFS on its children. We then update the DP table for the node i:\n\n- `dp[i][0]` is updated by adding the maximum of `dp[child][0]` and `dp[child][1]` for all its children. This is because if we don't include the edge weight of node i, we can choose to include or exclude the weights of its children to get the maximum sum.\n- `dp[i][1]` is updated by adding the edge weight of node i and `dp[child][0]` for all its children. This is because if we include the edge weight of node i, we cannot include the weights of its immediate children since the chosen edges cannot be adjacent.\n\nAfter the DFS traversal is completed, we return the maximum of `dp[0][0]` and `dp[0][1]` as the maximum sum of the chosen edges.\n    ",
        "python": "\n    ```python\ndef maxWeight(self, edges):\n    n = len(edges)\n    dp = [[0] * 2 for _ in range(n)]\n\n    def dfs(node):\n        for i in range(1, n):\n            if edges[i][0] == node:\n                dfs(i)\n                dp[node][0] += max(dp[i][0], dp[i][1])\n                dp[node][1] += dp[i][0]\n        dp[node][1] += edges[node][1]\n\n    dfs(0)\n    return max(dp[0][0], dp[0][1])\n```\n    \n    The problem can be solved using Dynamic Programming with Tree Traversal (DFS). We use an `n x 2` DP table where `dp[i][0]` stores the maximum sum without including the weight of node i and `dp[i][1]` stores the maximum sum including the weight of node i.\n\nWe start the DFS traversal from the root. For each node i in the tree, we first perform DFS on its children. We then update the DP table for the node i:\n\n- `dp[i][0]` is updated by adding the maximum of `dp[child][0]` and `dp[child][1]` for all its children. This is because if we don't include the edge weight of node i, we can choose to include or exclude the weights of its children to get the maximum sum.\n- `dp[i][1]` is updated by adding the edge weight of node i and `dp[child][0]` for all its children. This is because if we include the edge weight of node i, we cannot include the weights of its immediate children since the chosen edges cannot be adjacent.\n\nAfter the DFS traversal is completed, we return the maximum of `dp[0][0]` and `dp[0][1]` as the maximum sum of the chosen edges.\n    ",
        "c++": "\n    ```cpp\nint maxWeight(vector<vector<int>>& edges) {\n    int n = edges.size();\n    vector<vector<int>> dp(n, vector<int>(2));\n    \n    function<void(int)> dfs = [&](int node) {\n        for (int i = 1; i < n; ++i) {\n            if (edges[i][0] == node) {\n                dfs(i);\n                dp[node][0] += max(dp[i][0], dp[i][1]);\n                dp[node][1] += dp[i][0];\n            }\n        }\n        dp[node][1] += edges[node][1];\n    };\n    \n    dfs(0);\n    return max(dp[0][0], dp[0][1]);\n}\n```\n    \n    The problem can be solved using Dynamic Programming with Tree Traversal (DFS). We use an `n x 2` DP table where `dp[i][0]` stores the maximum sum without including the weight of node i and `dp[i][1]` stores the maximum sum including the weight of node i.\n\nWe start the DFS traversal from the root. For each node i in the tree, we first perform DFS on its children. We then update the DP table for the node i:\n\n- `dp[i][0]` is updated by adding the maximum of `dp[child][0]` and `dp[child][1]` for all its children. This is because if we don't include the edge weight of node i, we can choose to include or exclude the weights of its children to get the maximum sum.\n- `dp[i][1]` is updated by adding the edge weight of node i and `dp[child][0]` for all its children. This is because if we include the edge weight of node i, we cannot include the weights of its immediate children since the chosen edges cannot be adjacent.\n\nAfter the DFS traversal is completed, we return the maximum of `dp[0][0]` and `dp[0][1]` as the maximum sum of the chosen edges.\n    ",
        "js": "\n    ```javascript\nfunction maxWeight(edges) {\n    let n = edges.length;\n    let dp = Array.from({ length: n }, () => [0, 0]);\n\n    function dfs(node) {\n        for (let i = 1; i < n; ++i) {\n            if (edges[i][0] === node) {\n                dfs(i);\n                dp[node][0] += Math.max(dp[i][0], dp[i][1]);\n                dp[node][1] += dp[i][0];\n            }\n        }\n        dp[node][1] += edges[node][1];\n    }\n\n    dfs(0);\n    return Math.max(dp[0][0], dp[0][1]);\n}\n```\n    \n    The problem can be solved using Dynamic Programming with Tree Traversal (DFS). We use an `n x 2` DP table where `dp[i][0]` stores the maximum sum without including the weight of node i and `dp[i][1]` stores the maximum sum including the weight of node i.\n\nWe start the DFS traversal from the root. For each node i in the tree, we first perform DFS on its children. We then update the DP table for the node i:\n\n- `dp[i][0]` is updated by adding the maximum of `dp[child][0]` and `dp[child][1]` for all its children. This is because if we don't include the edge weight of node i, we can choose to include or exclude the weights of its children to get the maximum sum.\n- `dp[i][1]` is updated by adding the edge weight of node i and `dp[child][0]` for all its children. This is because if we include the edge weight of node i, we cannot include the weights of its immediate children since the chosen edges cannot be adjacent.\n\nAfter the DFS traversal is completed, we return the maximum of `dp[0][0]` and `dp[0][1]` as the maximum sum of the chosen edges.\n    "
    },
    {
        "id": 356,
        "title": "Count Strictly Increasing Subarrays",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `nums` consisting of **positive** integers.\n\nReturn _the number of **subarrays** of_ `nums` _that are in **strictly increasing** order._\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,4,6\\]\n**Output:** 10\n**Explanation:** The strictly increasing subarrays are the following:\n- Subarrays of length 1: \\[1\\], \\[3\\], \\[5\\], \\[4\\], \\[4\\], \\[6\\].\n- Subarrays of length 2: \\[1,3\\], \\[3,5\\], \\[4,6\\].\n- Subarrays of length 3: \\[1,3,5\\].\nThe total number of subarrays is 6 + 3 + 1 = 10.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** 15\n**Explanation:** Every subarray is strictly increasing. There are 15 possible subarrays that we can take."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,3,5,4,4,6]",
                "output": "10"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "15"
            }
        ],
        "java": "\n    ```java\npublic int numStrictlyIncreasingSubarrays(int[] nums) {\n    int n = nums.length;\n    int count = 0, sum = 0;\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i - 1]) {\n            count++;\n        } else {\n            count = 0;\n        }\n        sum += count;\n    }\n    return sum + n;\n}\n```\n    \n    In this solution, we iterate through the array once, whereas we maintain two variables: `count` and `sum`. `count` is the length of the current increasing subarray, and `sum` keeps the sum of all lengths.\nFor each element, starting with the second one, we check whether it is greater than the previous element. If so, we increment the `count`, otherwise we reset the `count` to zero. We add the `count` to the `sum` at each iteration.\nWhen the loop finishes, we have the total number of strictly increasing subarrays of length 2 or more. We finally add the length of the original array `n` to the result to include the length 1 subarrays, and return the final result.\n    ",
        "python": "\n    ```python\ndef num_strictly_increasing_subarrays(nums):\n    n = len(nums)\n    count = 0\n    sum = 0\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            count += 1\n        else:\n            count = 0\n        sum += count\n    return sum + n\n```\n    \n    In this solution, we iterate through the array once, whereas we maintain two variables: `count` and `sum`. `count` is the length of the current increasing subarray, and `sum` keeps the sum of all lengths.\nFor each element, starting with the second one, we check whether it is greater than the previous element. If so, we increment the `count`, otherwise we reset the `count` to zero. We add the `count` to the `sum` at each iteration.\nWhen the loop finishes, we have the total number of strictly increasing subarrays of length 2 or more. We finally add the length of the original array `n` to the result to include the length 1 subarrays, and return the final result.\n    ",
        "c++": "\n    ```cpp\nint numStrictlyIncreasingSubarrays(vector<int>& nums) {\n    int n = nums.size();\n    int count = 0, sum = 0;\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i - 1]) {\n            count++;\n        } else {\n            count = 0;\n        }\n        sum += count;\n    }\n    return sum + n;\n}\n```\n    \n    In this solution, we iterate through the array once, whereas we maintain two variables: `count` and `sum`. `count` is the length of the current increasing subarray, and `sum` keeps the sum of all lengths.\nFor each element, starting with the second one, we check whether it is greater than the previous element. If so, we increment the `count`, otherwise we reset the `count` to zero. We add the `count` to the `sum` at each iteration.\nWhen the loop finishes, we have the total number of strictly increasing subarrays of length 2 or more. We finally add the length of the original array `n` to the result to include the length 1 subarrays, and return the final result.\n    ",
        "js": "\n    ```javascript\nfunction numStrictlyIncreasingSubarrays(nums) {\n    const n = nums.length;\n    let count = 0;\n    let sum = 0;\n    for (let i = 1; i < n; ++i) {\n        if (nums[i] > nums[i - 1]) {\n            count++;\n        } else {\n            count = 0;\n        }\n        sum += count;\n    }\n    return sum + n;\n}\n```\n    \n    In this solution, we iterate through the array once, whereas we maintain two variables: `count` and `sum`. `count` is the length of the current increasing subarray, and `sum` keeps the sum of all lengths.\nFor each element, starting with the second one, we check whether it is greater than the previous element. If so, we increment the `count`, otherwise we reset the `count` to zero. We add the `count` to the `sum` at each iteration.\nWhen the loop finishes, we have the total number of strictly increasing subarrays of length 2 or more. We finally add the length of the original array `n` to the result to include the length 1 subarrays, and return the final result.\n    "
    },
    {
        "id": 357,
        "title": "Minimum Time to Kill All Monsters",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `power` where `power[i]` is the power of the `ith` monster.\n\nYou start with `0` mana points, and each day you increase your mana points by `gain` where `gain` initially is equal to `1`.\n\nEach day, after gaining `gain` mana, you can defeat a monster if your mana points are greater than or equal to the power of that monster. When you defeat a monster:\n\n*   your mana points will be reset to `0`, and\n*   the value of `gain` increases by `1`.\n\nReturn _the **minimum** number of days needed to defeat all the monsters._",
            "examples": [
                "**Example 1:**\n\n**Input:** power = \\[3,1,4\\]\n**Output:** 4\n**Explanation:** The optimal way to beat all the monsters is to:\n- Day 1: Gain 1 mana point to get a total of 1 mana point. Spend all mana points to kill the 2nd monster.\n- Day 2: Gain 2 mana points to get a total of 2 mana points.\n- Day 3: Gain 2 mana points to get a total of 4 mana points. Spend all mana points to kill the 3rd monster.\n- Day 4: Gain 3 mana points to get a total of 3 mana points. Spend all mana points to kill the 1st monster.\nIt can be proven that 4 is the minimum number of days needed. \n\n",
                "**Example 2:**\n\n**Input:** power = \\[1,1,4\\]\n**Output:** 4\n**Explanation:** The optimal way to beat all the monsters is to:\n- Day 1: Gain 1 mana point to get a total of 1 mana point. Spend all mana points to kill the 1st monster.\n- Day 2: Gain 2 mana points to get a total of 2 mana points. Spend all mana points to kill the 2nd monster.\n- Day 3: Gain 3 mana points to get a total of 3 mana points.\n- Day 4: Gain 3 mana points to get a total of 6 mana points. Spend all mana points to kill the 3rd monster.\nIt can be proven that 4 is the minimum number of days needed. \n\n",
                "**Example 3:**\n\n**Input:** power = \\[1,2,4,9\\]\n**Output:** 6\n**Explanation:** The optimal way to beat all the monsters is to:\n- Day 1: Gain 1 mana point to get a total of 1 mana point. Spend all mana points to kill the 1st monster.\n- Day 2: Gain 2 mana points to get a total of 2 mana points. Spend all mana points to kill the 2nd monster.\n- Day 3: Gain 3 mana points to get a total of 3 mana points.\n- Day 4: Gain 3 mana points to get a total of 6 mana points.\n- Day 5: Gain 3 mana points to get a total of 9 mana points. Spend all mana points to kill the 4th monster.\n- Day 6: Gain 4 mana points to get a total of 4 mana points. Spend all mana points to kill the 3rd monster.\nIt can be proven that 6 is the minimum number of days needed."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= power.length <= 17`\n*   `1 <= power[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,1,4]",
                "output": "4"
            },
            {
                "input": "[1,1,4]",
                "output": "4"
            },
            {
                "input": "[1,2,4,9]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int minDays(int[] power) {\n    int n = power.length;\n    int ans = (int)1e9;\n    int[] dp = new int[1 << n];\n    Arrays.fill(dp, (int)1e9);\n    \n    dp[0] = 0;\n    int[] sortedPower = Arrays.copyOf(power, n);\n    Arrays.sort(sortedPower);\n    \n    for (int i = 0; i < (1 << n); ++i) {\n        int powerSum = 0;\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                powerSum += sortedPower[j];\n            }\n        }\n        int gain = 1 + Integer.bitCount(i);\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) == 0 && gain > sortedPower[j]) {\n                dp[i | (1 << j)] = Math.min(dp[i | (1 << j)], dp[i] + 1);\n            }\n        }\n    }\n    return dp[(1 << n) - 1];\n}\n```\n    \n    1. Sort the given `power` array in ascending order.\n2. We will use dynamic programming. Create a `dp` array sized `2^n` and initialized with a large number (eg., `1e9`), where `n` is the length of the `power` array. `dp[i]` represents the minimum number of days needed to defeat the monsters represented by the bitmask `i`.\n3. Set `dp[0] = 0`, because no days are needed if there are no monsters.\n4. Loop through all possible subsets of the sorted `power` array by iterating through `1 << n`.\n5. Calculate the mana points gain as `1 + number of bits set in i`.\n6. Iterate through each of the monsters (0 to n-1), if the monster is not already defeated as indicated by the bitmask (`!(i & (1 << j))`), and if the mana is greater than the power of the monster (`gain > sorted_power[j]`), we find the minimum of the current `dp` value at `i | (1 << j)` and `dp[i] + 1`, and store the result back in `dp[i | (1 << j)]`.\n7. After iterating through all possible subsets, return the value of `dp[(1 << n) - 1]`, which is the minimum number of days needed to defeat all the monsters.\n    ",
        "python": "\n    ```python\ndef min_days(power):\n    n = len(power)  \n    ans = int(1e9)\n    dp = [int(1e9)] * (1 << n)\n    dp[0] = 0\n     \n    sorted_power = sorted(power)\n\n    for i in range(1 << n): \n        power_sum = sum(sorted_power[j] for j in range(n) if i & (1 << j)) \n        gain = 1 + bin(i).count('1')\n\n        for j in range(n):\n            if not i & (1 << j) and gain > sorted_power[j]:\n                dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + 1)\n\n    return dp[(1 << n) - 1]\n```\n    \n    1. Sort the given `power` array in ascending order.\n2. We will use dynamic programming. Create a `dp` array sized `2^n` and initialized with a large number (eg., `1e9`), where `n` is the length of the `power` array. `dp[i]` represents the minimum number of days needed to defeat the monsters represented by the bitmask `i`.\n3. Set `dp[0] = 0`, because no days are needed if there are no monsters.\n4. Loop through all possible subsets of the sorted `power` array by iterating through `1 << n`.\n5. Calculate the mana points gain as `1 + number of bits set in i`.\n6. Iterate through each of the monsters (0 to n-1), if the monster is not already defeated as indicated by the bitmask (`!(i & (1 << j))`), and if the mana is greater than the power of the monster (`gain > sorted_power[j]`), we find the minimum of the current `dp` value at `i | (1 << j)` and `dp[i] + 1`, and store the result back in `dp[i | (1 << j)]`.\n7. After iterating through all possible subsets, return the value of `dp[(1 << n) - 1]`, which is the minimum number of days needed to defeat all the monsters.\n    ",
        "c++": "\n    ```cpp\nint min_days(const std::vector<int>& power) {\n    int n = power.size();\n    int ans = 1e9;\n    std::vector<int> dp(1 << n, 1e9);\n\n    dp[0] = 0;\n    std::vector<int> sorted_power(power.begin(), power.end());\n    sort(sorted_power.begin(), sorted_power.end());\n\n    for (int i = 0; i < (1 << n); ++i) {\n        int power_sum = 0;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                power_sum += sorted_power[j];\n            }\n        }\n        int gain = 1 + __builtin_popcount(i);\n        for (int j = 0; j < n; ++j) {\n            if (!(i & (1 << j)) && gain > sorted_power[j]) {\n                dp[i | (1 << j)] = std::min(dp[i | (1 << j)], dp[i] + 1);\n            }\n        }\n    }\n    return dp[(1 << n) - 1];\n}\n```\n    \n    1. Sort the given `power` array in ascending order.\n2. We will use dynamic programming. Create a `dp` array sized `2^n` and initialized with a large number (eg., `1e9`), where `n` is the length of the `power` array. `dp[i]` represents the minimum number of days needed to defeat the monsters represented by the bitmask `i`.\n3. Set `dp[0] = 0`, because no days are needed if there are no monsters.\n4. Loop through all possible subsets of the sorted `power` array by iterating through `1 << n`.\n5. Calculate the mana points gain as `1 + number of bits set in i`.\n6. Iterate through each of the monsters (0 to n-1), if the monster is not already defeated as indicated by the bitmask (`!(i & (1 << j))`), and if the mana is greater than the power of the monster (`gain > sorted_power[j]`), we find the minimum of the current `dp` value at `i | (1 << j)` and `dp[i] + 1`, and store the result back in `dp[i | (1 << j)]`.\n7. After iterating through all possible subsets, return the value of `dp[(1 << n) - 1]`, which is the minimum number of days needed to defeat all the monsters.\n    ",
        "js": "\n    ```javascript\nfunction minDays(power) {\n    const n = power.length;\n    const ans = 1e9;\n    const dp = new Array(1 << n).fill(1e9);\n\n    dp[0] = 0;\n    const sortedPower = [...power].sort((a, b) => a - b);\n\n    for (let i = 0; i < (1 << n); ++i) {\n        let powerSum = 0;\n        for (let j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                powerSum += sortedPower[j];\n            }\n        }\n        const gain = 1 + countBits(i);\n        for (let j = 0; j < n; ++j) {\n            if (!(i & (1 << j)) && gain > sortedPower[j]) {\n                dp[i | (1 << j)] = Math.min(dp[i | (1 << j)], dp[i] + 1);\n            }\n        }\n    }\n    return dp[(1 << n) - 1];\n\n    function countBits(num) {\n        let count = 0;\n        while (num) {\n            num &= (num - 1);\n            ++count;\n        }\n        return count;\n    }\n}\n```\n    \n    1. Sort the given `power` array in ascending order.\n2. We will use dynamic programming. Create a `dp` array sized `2^n` and initialized with a large number (eg., `1e9`), where `n` is the length of the `power` array. `dp[i]` represents the minimum number of days needed to defeat the monsters represented by the bitmask `i`.\n3. Set `dp[0] = 0`, because no days are needed if there are no monsters.\n4. Loop through all possible subsets of the sorted `power` array by iterating through `1 << n`.\n5. Calculate the mana points gain as `1 + number of bits set in i`.\n6. Iterate through each of the monsters (0 to n-1), if the monster is not already defeated as indicated by the bitmask (`!(i & (1 << j))`), and if the mana is greater than the power of the monster (`gain > sorted_power[j]`), we find the minimum of the current `dp` value at `i | (1 << j)` and `dp[i] + 1`, and store the result back in `dp[i | (1 << j)]`.\n7. After iterating through all possible subsets, return the value of `dp[(1 << n) - 1]`, which is the minimum number of days needed to defeat all the monsters.\n    "
    },
    {
        "id": 358,
        "title": "Design SQL",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given `n` tables represented with two arrays `names` and `columns`, where `names[i]` is the name of the `ith` table and `columns[i]` is the number of columns of the `ith` table.\n\nYou should be able to perform the following **operations**:\n\n*   **Insert** a row in a specific table. Each row you insert has an id. The id is assigned using an auto-increment method where the id of the first inserted row is 1, and the id of each other row inserted into the same table is the id of the last inserted row (even if it was deleted) plus one.\n*   **Delete** a row from a specific table. **Note** that deleting a row does not affect the id of the next inserted row.\n*   **Select** a specific cell from any table and return its value.\n\nImplement the `SQL` class:\n\n*   `SQL(String[] names, int[] columns)` Creates the `n` tables.\n*   `void insertRow(String name, String[] row)` Adds a row to the table `name`. It is **guaranteed** that the table will exist, and the size of the array `row` is equal to the number of columns in the table.\n*   `void deleteRow(String name, int rowId)` Removes the row `rowId` from the table `name`. It is **guaranteed** that the table and row will **exist**.\n*   `String selectCell(String name, int rowId, int columnId)` Returns the value of the cell in the row `rowId` and the column `columnId` from the table `name`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"SQL \",  \"insertRow \",  \"selectCell \",  \"insertRow \",  \"deleteRow \",  \"selectCell \"\\]\n\\[\\[\\[ \"one \",  \"two \",  \"three \"\\], \\[2, 3, 1\\]\\], \\[ \"two \", \\[ \"first \",  \"second \",  \"third \"\\]\\], \\[ \"two \", 1, 3\\], \\[ \"two \", \\[ \"fourth \",  \"fifth \",  \"sixth \"\\]\\], \\[ \"two \", 1\\], \\[ \"two \", 2, 2\\]\\]\n**Output**\n\\[null, null,  \"third \", null, null,  \"fifth \"\\]\n\n**Explanation**\nSQL sql = new SQL(\\[ \"one \",  \"two \",  \"three \"\\], \\[2, 3, 1\\]); // creates three tables.\nsql.insertRow( \"two \", \\[ \"first \",  \"second \",  \"third \"\\]); // adds a row to the table  \"two \". Its id is 1.\nsql.selectCell( \"two \", 1, 3); // return  \"third \", finds the value of the third column in the row with id 1 of the table  \"two \".\nsql.insertRow( \"two \", \\[ \"fourth \",  \"fifth \",  \"sixth \"\\]); // adds another row to the table  \"two \". Its id is 2.\nsql.deleteRow( \"two \", 1); // deletes the first row of the table  \"two \". Note that the second row will still have the id 2.\nsql.selectCell( \"two \", 2, 2); // return  \"fifth \", finds the value of the second column in the row with id 2 of the table  \"two \"."
            ],
            "constraints": "**Constraints:**\n\n*   `n == names.length == columns.length`\n*   `1 <= n <= 104`\n*   `1 <= names[i].length, row[i].length, name.length <= 20`\n*   `names[i]`, `row[i]`, and `name` consist of lowercase English letters.\n*   `1 <= columns[i] <= 100`\n*   All the strings of `names` are **distinct**.\n*   `name` exists in the array `names`.\n*   `row.length` equals the number of columns in the chosen table.\n*   `rowId` and `columnId` will be valid.\n*   At most `250` calls will be made to `insertRow` and `deleteRow`.\n*   At most `104` calls will be made to `selectCell`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],]],[\"two\",]],[\"two\",1,3],[\"two\",]],[\"two\",1],[\"two\",2,2]]",
                "output": "**Output**\n[null,null,\"third\",null,null,\"fifth\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SQL {\n    private Map<String, Table> tables;\n\n    public SQL(String[] names, int[] columns) {\n        tables = new HashMap<>();\n        for (int i = 0; i < names.length; i++) {\n            tables.put(names[i], new Table(columns[i]));\n        }\n    }\n\n    public void insertRow(String name, String[] row) {\n        tables.get(name).insertRow(row);\n    }\n\n    public void deleteRow(String name, int rowId) {\n        tables.get(name).deleteRow(rowId);\n    }\n\n    public String selectCell(String name, int rowId, int columnId) {\n        return tables.get(name).selectCell(rowId, columnId);\n    }\n\n    private static class Table {\n        private int nextId;\n        private List<Row> rows;\n        private int numColumns;\n\n        public Table(int numColumns) {\n            this.numColumns = numColumns;\n            this.nextId = 1;\n            this.rows = new ArrayList<>();\n        }\n\n        public void insertRow(String[] row) {\n            rows.add(new Row(nextId++, row));\n        }\n\n        public void deleteRow(int rowId) {\n            rows.removeIf(r -> r.id == rowId);\n        }\n\n        public String selectCell(int rowId, int columnId) {\n            return rows.stream().filter(r -> r.id == rowId).findFirst().get().values[columnId - 1];\n        }\n    }\n\n    private static class Row {\n        private int id;\n        private String[] values;\n\n        public Row(int id, String[] values) {\n            this.id = id;\n            this.values = values;\n        }\n    }\n}\n```\n    \n    The SQL class is designed to hold tables' information, and the main logic comes from Table class internally. To perform insertRow and deleteRow operations, we maintain a unique id for each row based on the nextId variable. For insertRow, we append a new row with its unique id and its cell contents. For deleteRow, we remove the rows based on their unique id.\n\nselectCell function iterates through rows and selects the needed cell based on rowId and columnId.\n    ",
        "python": "\n    ```python\nclass SQL:\n    def __init__(self, names: List[str], columns: List[int]):\n        self.tables = {name: Table(columns[i]) for i, name in enumerate(names)}\n\n    def insertRow(self, name: str, row: List[str]) -> None:\n        self.tables[name].insertRow(row)\n\n    def deleteRow(self, name: str, rowId: int) -> None:\n        self.tables[name].deleteRow(rowId)\n\n    def selectCell(self, name: str, rowId: int, columnId: int) -> str:\n        return self.tables[name].selectCell(rowId, columnId)\n\n\nclass Table:\n    def __init__(self, columns: int):\n        self.next_id = 1\n        self.rows = []\n        self.num_columns = columns\n\n    def insertRow(self, row: List[str]) -> None:\n        self.rows.append([self.next_id, row])\n        self.next_id += 1\n\n    def deleteRow(self, rowId: int) -> None:\n        self.rows = [row for row in self.rows if row[0] != rowId]\n\n    def selectCell(self, rowId: int, columnId: int) -> str:\n        for row in self.rows:\n            if row[0] == rowId:\n                return row[1][columnId - 1]\n```\n    \n    The SQL class is designed to hold tables' information, and the main logic comes from Table class internally. To perform insertRow and deleteRow operations, we maintain a unique id for each row based on the nextId variable. For insertRow, we append a new row with its unique id and its cell contents. For deleteRow, we remove the rows based on their unique id.\n\nselectCell function iterates through rows and selects the needed cell based on rowId and columnId.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <string>\n#include <vector>\n\nclass SQL {\npublic:\n    SQL(vector<string>& names, vector<int>& columns) {\n        for (size_t i = 0; i < names.size(); ++i) {\n            tables[names[i]] = {columns[i], {}};\n        }\n    }\n\n    void insertRow(string name, vector<string>& row) {\n        tables[name].second.push_back({++tables[name].first, row});\n    }\n\n    void deleteRow(string name, int rowId) {\n        auto& rows = tables[name].second;\n        rows.erase(remove_if(rows.begin(), rows.end(),\n                             [rowId](auto&& p) { return p.first == rowId; }),\n                   rows.end());\n    }\n\n    string selectCell(string name, int rowId, int columnId) {\n        auto& rows = tables[name].second;\n        auto it = find_if(rows.begin(), rows.end(), [rowId](auto&& p) { return p.first == rowId; });\n        return it->second[columnId - 1];\n    }\n\nprivate:\n    unordered_map<string, pair<int, vector<pair<int, vector<string>>>> tables;\n};\n```\n    \n    The SQL class is designed to hold tables' information, and the main logic comes from Table class internally. To perform insertRow and deleteRow operations, we maintain a unique id for each row based on the nextId variable. For insertRow, we append a new row with its unique id and its cell contents. For deleteRow, we remove the rows based on their unique id.\n\nselectCell function iterates through rows and selects the needed cell based on rowId and columnId.\n    ",
        "js": "\n    ```javascript\nclass SQL {\n    constructor(names, columns) {\n        this.tables = {};\n        for (let i = 0; i < names.length; i++) {\n            this.tables[names[i]] = new Table(columns[i]);\n        }\n    }\n\n    insertRow(name, row) {\n        this.tables[name].insertRow(row);\n    }\n\n    deleteRow(name, rowId) {\n        this.tables[name].deleteRow(rowId);\n    }\n\n    selectCell(name, rowId, columnId) {\n        return this.tables[name].selectCell(rowId, columnId);\n    }\n}\n\nclass Table {\n    constructor(columns) {\n        this.columns = columns;\n        this.rows = [];\n        this.nextId = 1;\n    }\n\n    insertRow(row) {\n        this.rows.push({ id: this.nextId++, values: row });\n    }\n\n    deleteRow(rowId) {\n        this.rows = this.rows.filter(row => row.id !== rowId);\n    }\n\n    selectCell(rowId, columnId) {\n        const row = this.rows.find(row => row.id === rowId);\n        return row.values[columnId - 1];\n    }\n}\n```\n    \n    The SQL class is designed to hold tables' information, and the main logic comes from Table class internally. To perform insertRow and deleteRow operations, we maintain a unique id for each row based on the nextId variable. For insertRow, we append a new row with its unique id and its cell contents. For deleteRow, we remove the rows based on their unique id.\n\nselectCell function iterates through rows and selects the needed cell based on rowId and columnId.\n    "
    },
    {
        "id": 359,
        "title": "Closest Fair Integer",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **positive** integer `n`.\n\nWe call an integer `k` fair if the number of **even** digits in `k` is equal to the number of **odd** digits in it.\n\nReturn _the **smallest** fair integer that is **greater than or equal** to_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 10\n**Explanation:** The smallest fair integer that is greater than or equal to 2 is 10.\n10 is fair because it has an equal number of even and odd digits (one odd digit and one even digit).\n\n",
                "**Example 2:**\n\n**Input:** n = 403\n**Output:** 1001\n**Explanation:** The smallest fair integer that is greater than or equal to 403 is 1001.\n1001 is fair because it has an equal number of even and odd digits (two odd digits and two even digits)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2",
                "output": "10"
            },
            {
                "input": "403",
                "output": "1001"
            }
        ],
        "java": "\n    ```java\npublic int smallestFairNumber(int n) {\n    while (true) {\n        int k = n;\n        int even = 0, odd = 0;\n        while (k > 0) {\n            k % 2 == 0 ? even++ : odd++;\n            k /= 10;\n        }\n        if (even == odd) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm starts from the given number `n` and check if it is fair or not. A fair number `k` is the one where the count of even digits is equal to the count of odd digits.\n\nTo check if a number is fair, we count the even and odd digits of the number `k` using a while loop. In each iteration, we check if the last digit of `k` is even or odd, increment the respective counter, and update `k` by removing the last digit. If the count of even and odd digits is equal, return the number `n`.\n\nIf the given number `n` is not fair, we increment `n` and repeat the process until we find a fair number.\n\nThis algorithm has a linear time complexity (in the worst case) as we need to find the subsequent fair numbers one by one until we find the smallest fair number satisfying the constraints.\n    ",
        "python": "\n    ```python\ndef smallest_fair_number(n):\n    while True:\n        k = n\n        even = 0\n        odd = 0\n        while k > 0:\n            if k % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n            k //= 10\n        if even == odd:\n            return n\n        n += 1\n```\n    \n    The algorithm starts from the given number `n` and check if it is fair or not. A fair number `k` is the one where the count of even digits is equal to the count of odd digits.\n\nTo check if a number is fair, we count the even and odd digits of the number `k` using a while loop. In each iteration, we check if the last digit of `k` is even or odd, increment the respective counter, and update `k` by removing the last digit. If the count of even and odd digits is equal, return the number `n`.\n\nIf the given number `n` is not fair, we increment `n` and repeat the process until we find a fair number.\n\nThis algorithm has a linear time complexity (in the worst case) as we need to find the subsequent fair numbers one by one until we find the smallest fair number satisfying the constraints.\n    ",
        "c++": "\n    ```cpp\nint smallestFairNumber(int n) {\n    while (true) {\n        int k = n;\n        int even = 0, odd = 0;\n        while (k > 0) {\n            k % 2 == 0 ? even++ : odd++;\n            k /= 10;\n        }\n        if (even == odd) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm starts from the given number `n` and check if it is fair or not. A fair number `k` is the one where the count of even digits is equal to the count of odd digits.\n\nTo check if a number is fair, we count the even and odd digits of the number `k` using a while loop. In each iteration, we check if the last digit of `k` is even or odd, increment the respective counter, and update `k` by removing the last digit. If the count of even and odd digits is equal, return the number `n`.\n\nIf the given number `n` is not fair, we increment `n` and repeat the process until we find a fair number.\n\nThis algorithm has a linear time complexity (in the worst case) as we need to find the subsequent fair numbers one by one until we find the smallest fair number satisfying the constraints.\n    ",
        "js": "\n    ```javascript\nfunction smallestFairNumber(n) {\n    while (true) {\n        let k = n;\n        let even = 0, odd = 0;\n        while (k > 0) {\n            k % 2 === 0 ? even++ : odd++;\n            k = Math.floor(k / 10);\n        }\n        if (even === odd) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm starts from the given number `n` and check if it is fair or not. A fair number `k` is the one where the count of even digits is equal to the count of odd digits.\n\nTo check if a number is fair, we count the even and odd digits of the number `k` using a while loop. In each iteration, we check if the last digit of `k` is even or odd, increment the respective counter, and update `k` by removing the last digit. If the count of even and odd digits is equal, return the number `n`.\n\nIf the given number `n` is not fair, we increment `n` and repeat the process until we find a fair number.\n\nThis algorithm has a linear time complexity (in the worst case) as we need to find the subsequent fair numbers one by one until we find the smallest fair number satisfying the constraints.\n    "
    },
    {
        "id": 360,
        "title": "Merge Operations to Turn Array Into a Palindrome",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `nums` consisting of **positive** integers.\n\nYou can perform the following operation on the array **any** number of times:\n\n*   Choose any two **adjacent** elements and **replace** them with their **sum**.\n    *   For example, if `nums = [1,2,3,1]`, you can apply one operation to make it `[1,5,1]`.\n\nReturn _the **minimum** number of operations needed to turn the array into a **palindrome**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,1,2,3,1\\]\n**Output:** 2\n**Explanation:** We can turn the array into a palindrome in 2 operations as follows:\n- Apply the operation on the fourth and fifth element of the array, nums becomes equal to \\[4,3,2,**3**,3,1\\].\n- Apply the operation on the fifth and sixth element of the array, nums becomes equal to \\[4,3,2,3,**4**\\].\nThe array \\[4,3,2,3,4\\] is a palindrome.\nIt can be shown that 2 is the minimum number of operations needed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 3\n**Explanation:** We do the operation 3 times in any position, we obtain the array \\[10\\] at the end which is a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,3,2,1,2,3,1]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int n = nums.length;\n    int i = 0, j = n - 1;\n    int operations = 0;\n\n    while (i < j) {\n        if (nums[i] == nums[j]) {\n            i++;\n            j--;\n        } else if (nums[i] < nums[j]) {\n            nums[i + 1] += nums[i];\n            i++;\n            operations++;\n        } else {\n            nums[j - 1] += nums[j];\n            j--;\n            operations++;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "python": "\n    ```python\ndef minOperations(nums):\n    n = len(nums)\n    i, j = 0, n - 1\n    operations = 0\n\n    while i < j:\n        if nums[i] == nums[j]:\n            i += 1\n            j -= 1\n        elif nums[i] < nums[j]:\n            nums[i + 1] += nums[i]\n            i += 1\n            operations += 1\n        else:\n            nums[j - 1] += nums[j]\n            j -= 1\n            operations += 1\n\n    return operations\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums) {\n    int n = nums.size();\n    int i = 0, j = n - 1;\n    int operations = 0;\n\n    while (i < j) {\n        if (nums[i] == nums[j]) {\n            i++;\n            j--;\n        } else if (nums[i] < nums[j]) {\n            nums[i + 1] += nums[i];\n            i++;\n            operations++;\n        } else {\n            nums[j - 1] += nums[j];\n            j--;\n            operations++;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    const n = nums.length;\n    let i = 0, j = n - 1;\n    let operations = 0;\n\n    while (i < j) {\n        if (nums[i] === nums[j]) {\n            i++;\n            j--;\n        } else if (nums[i] < nums[j]) {\n            nums[i + 1] += nums[i];\n            i++;\n            operations++;\n        } else {\n            nums[j - 1] += nums[j];\n            j--;\n            operations++;\n        }\n    }\n    return operations;\n}\n```\n    \n    The algorithm uses two pointers, `i` and `j`, initializing them to the start and end of the array, respectively. It then enters a loop, moving these pointers inwards and comparing the values in the array at these indices. If the values are equal, the pointers are moved inwards without performing any operation. If the values are not equal, an operation is performed to make the smaller value equal to the larger one. The loop continues until the pointers cross each other. The number of operations performed is returned as the result.\n\nThe algorithm has a complexity of O(n) as it iterates through the input array once.\n    "
    },
    {
        "id": 361,
        "title": "Maximize Total Tastiness of Purchased Fruits",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two non-negative integer arrays `price` and `tastiness`, both arrays have the same length `n`. You are also given two non-negative integers `maxAmount` and `maxCoupons`.\n\nFor every integer `i` in range `[0, n - 1]`:\n\n*   `price[i]` describes the price of `ith` fruit.\n*   `tastiness[i]` describes the tastiness of `ith` fruit.\n\nYou want to purchase some fruits such that total tastiness is maximized and the total price does not exceed `maxAmount`.\n\nAdditionally, you can use a coupon to purchase fruit for **half of its price** (rounded down to the closest integer). You can use at most `maxCoupons` of such coupons.\n\nReturn _the maximum total tastiness that can be purchased_.\n\n**Note that:**\n\n*   You can purchase each fruit at most once.\n*   You can use coupons on some fruit at most once.",
            "examples": [
                "**Example 1:**\n\n**Input:** price = \\[10,20,20\\], tastiness = \\[5,8,8\\], maxAmount = 20, maxCoupons = 1\n**Output:** 13\n**Explanation:** It is possible to make total tastiness 13 in following way:\n- Buy first fruit without coupon, so that total price = 0 + 10 and total tastiness = 0 + 5.\n- Buy second fruit with coupon, so that total price = 10 + 10 and total tastiness = 5 + 8.\n- Do not buy third fruit, so that total price = 20 and total tastiness = 13.\nIt can be proven that 13 is the maximum total tastiness that can be obtained.\n\n",
                "**Example 2:**\n\n**Input:** price = \\[10,15,7\\], tastiness = \\[5,8,20\\], maxAmount = 10, maxCoupons = 2\n**Output:** 28\n**Explanation:** It is possible to make total tastiness 20 in following way:\n- Do not buy first fruit, so that total price = 0 and total tastiness = 0.\n- Buy second fruit with coupon, so that total price = 0 + 7 and total tastiness = 0 + 8.\n- Buy third fruit with coupon, so that total price = 7 + 3 and total tastiness = 8 + 20.\nIt can be proven that 28 is the maximum total tastiness that can be obtained."
            ],
            "constraints": "**Constraints:**\n\n*   `n == price.length == tastiness.length`\n*   `1 <= n <= 100`\n*   `0 <= price[i], tastiness[i], maxAmount <= 1000`\n*   `0 <= maxCoupons <= 5`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[10,20,20],[5,8,8],20,1",
                "output": "13"
            },
            {
                "input": "[10,15,7],[5,8,20],10,2",
                "output": "28"
            }
        ],
        "java": "\n    ```java\npublic int maxTastiness(int[] price, int[] tastiness, int maxAmount, int maxCoupons) {\n    int n = price.length;\n    int[][][] dp = new int[n + 1][maxAmount + 1][maxCoupons + 1];\n\n    for (int i = 1; i <= n; i++) {\n        int fruit_price = price[i - 1];\n        int fruit_tastiness = tastiness[i - 1];\n        int half_fruit_price = fruit_price / 2;\n\n        for (int j = 0; j <= maxAmount; j++) {\n            for (int k = 0; k <= maxCoupons; k++) {\n                dp[i][j][k] = dp[i - 1][j][k];\n                if (j >= fruit_price) {\n                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness);\n                }\n                if (k > 0 && j >= half_fruit_price) {\n                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness);\n                }\n            }\n        }\n    }\n\n    return dp[n][maxAmount][maxCoupons];\n}\n```\n\n    \n    We solve the problem using dynamic programming. Our state is represented by three dimensions:\n\n1. The index of the current fruit (0-based)\n2. The current amount spent\n3. The number of coupons used\n\nThe dp array is initialized as a 3D array filled with zeros. Then, we iterate through the fruits, updating the dp array based on whether we buy the current fruit or not, and whether we use a coupon to buy it.\n\nFor each fruit, we iterate through all possible amounts spent and all possible numbers of coupons used. We have three cases to consider when updating the dp array:\n\n1. We do not buy the current fruit: `dp[i][j][k] = dp[i - 1][j][k]`\n2. We buy the current fruit without a coupon: If `j >= fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)`\n3. We buy the current fruit with a coupon: If `k > 0 && j >= half_fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)`\n   \nAfter iterating through all the fruits, amounts, and coupons, the maximum tastiness that can be obtained is stored in `dp[n][maxAmount][maxCoupons]`.\n    ",
        "python": "\n    ```python\ndef maxTastiness(price, tastiness, maxAmount, maxCoupons):\n    n = len(price)\n    dp = [[[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        fruit_price = price[i - 1]\n        fruit_tastiness = tastiness[i - 1]\n        half_fruit_price = fruit_price // 2\n        \n        for j in range(maxAmount + 1):\n            for k in range(maxCoupons + 1):\n                dp[i][j][k] = dp[i - 1][j][k]\n                if j >= fruit_price:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)\n                if k > 0 and j >= half_fruit_price:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)\n\n    return dp[n][maxAmount][maxCoupons]\n```\n\n    \n    We solve the problem using dynamic programming. Our state is represented by three dimensions:\n\n1. The index of the current fruit (0-based)\n2. The current amount spent\n3. The number of coupons used\n\nThe dp array is initialized as a 3D array filled with zeros. Then, we iterate through the fruits, updating the dp array based on whether we buy the current fruit or not, and whether we use a coupon to buy it.\n\nFor each fruit, we iterate through all possible amounts spent and all possible numbers of coupons used. We have three cases to consider when updating the dp array:\n\n1. We do not buy the current fruit: `dp[i][j][k] = dp[i - 1][j][k]`\n2. We buy the current fruit without a coupon: If `j >= fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)`\n3. We buy the current fruit with a coupon: If `k > 0 && j >= half_fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)`\n   \nAfter iterating through all the fruits, amounts, and coupons, the maximum tastiness that can be obtained is stored in `dp[n][maxAmount][maxCoupons]`.\n    ",
        "c++": "\n    ```cpp\nint maxTastiness(vector<int>& price, vector<int>& tastiness, int maxAmount, int maxCoupons) {\n    int n = price.size();\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(maxAmount + 1, vector<int>(maxCoupons + 1, 0)));\n\n    for (int i = 1; i <= n; i++) {\n        int fruit_price = price[i - 1];\n        int fruit_tastiness = tastiness[i - 1];\n        int half_fruit_price = fruit_price / 2;\n\n        for (int j = 0; j <= maxAmount; j++) {\n            for (int k = 0; k <= maxCoupons; k++) {\n                dp[i][j][k] = dp[i - 1][j][k];\n                if (j >= fruit_price) {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness);\n                }\n                if (k > 0 && j >= half_fruit_price) {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness);\n                }\n            }\n        }\n    }\n\n    return dp[n][maxAmount][maxCoupons];\n}\n```\n\n    \n    We solve the problem using dynamic programming. Our state is represented by three dimensions:\n\n1. The index of the current fruit (0-based)\n2. The current amount spent\n3. The number of coupons used\n\nThe dp array is initialized as a 3D array filled with zeros. Then, we iterate through the fruits, updating the dp array based on whether we buy the current fruit or not, and whether we use a coupon to buy it.\n\nFor each fruit, we iterate through all possible amounts spent and all possible numbers of coupons used. We have three cases to consider when updating the dp array:\n\n1. We do not buy the current fruit: `dp[i][j][k] = dp[i - 1][j][k]`\n2. We buy the current fruit without a coupon: If `j >= fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)`\n3. We buy the current fruit with a coupon: If `k > 0 && j >= half_fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)`\n   \nAfter iterating through all the fruits, amounts, and coupons, the maximum tastiness that can be obtained is stored in `dp[n][maxAmount][maxCoupons]`.\n    ",
        "js": "\n    ```javascript\nfunction maxTastiness(price, tastiness, maxAmount, maxCoupons) {\n    const n = price.length;\n    const dp = new Array(n + 1).fill(0).map(() => new Array(maxAmount + 1).fill(0).map(() => new Array(maxCoupons + 1).fill(0)));\n\n    for (let i = 1; i <= n; i++) {\n        const fruit_price = price[i - 1];\n        const fruit_tastiness = tastiness[i - 1];\n        const half_fruit_price = Math.floor(fruit_price / 2);\n\n        for (let j = 0; j <= maxAmount; j++) {\n            for (let k = 0; k <= maxCoupons; k++) {\n                dp[i][j][k] = dp[i - 1][j][k];\n                if (j >= fruit_price) {\n                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness);\n                }\n                if (k > 0 && j >= half_fruit_price) {\n                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness);\n                }\n            }\n        }\n    }\n\n    return dp[n][maxAmount][maxCoupons];\n}\n```\n\n    \n    We solve the problem using dynamic programming. Our state is represented by three dimensions:\n\n1. The index of the current fruit (0-based)\n2. The current amount spent\n3. The number of coupons used\n\nThe dp array is initialized as a 3D array filled with zeros. Then, we iterate through the fruits, updating the dp array based on whether we buy the current fruit or not, and whether we use a coupon to buy it.\n\nFor each fruit, we iterate through all possible amounts spent and all possible numbers of coupons used. We have three cases to consider when updating the dp array:\n\n1. We do not buy the current fruit: `dp[i][j][k] = dp[i - 1][j][k]`\n2. We buy the current fruit without a coupon: If `j >= fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - fruit_price][k] + fruit_tastiness)`\n3. We buy the current fruit with a coupon: If `k > 0 && j >= half_fruit_price`, `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - half_fruit_price][k - 1] + fruit_tastiness)`\n   \nAfter iterating through all the fruits, amounts, and coupons, the maximum tastiness that can be obtained is stored in `dp[n][maxAmount][maxCoupons]`.\n    "
    },
    {
        "id": 362,
        "title": "Minimum Split Into Subarrays With GCD Greater Than One",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `nums` consisting of positive integers.\n\nSplit the array into **one or more** disjoint subarrays such that:\n\n*   Each element of the array belongs to **exactly one** subarray, and\n*   The **GCD** of the elements of each subarray is strictly greater than `1`.\n\nReturn _the minimum number of subarrays that can be obtained after the split_.\n\n**Note** that:\n\n*   The **GCD** of a subarray is the largest positive integer that evenly divides all the elements of the subarray.\n*   A **subarray** is a contiguous part of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[12,6,3,14,8\\]\n**Output:** 2\n**Explanation:** We can split the array into the subarrays: \\[12,6,3\\] and \\[14,8\\].\n- The GCD of 12, 6 and 3 is 3, which is strictly greater than 1.\n- The GCD of 14 and 8 is 2, which is strictly greater than 1.\nIt can be shown that splitting the array into one subarray will make the GCD = 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,12,6,14\\]\n**Output:** 1\n**Explanation:** We can split the array into only one subarray, which is the whole array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `2 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[12,6,3,14,8]",
                "output": "2"
            },
            {
                "input": "[4,12,6,14]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minArrays(int[] nums) {\n    int n = nums.length;\n    int totalGcd = nums[0];\n    for (int i = 1; i < n; ++i) {\n        totalGcd = gcd(totalGcd, nums[i]);\n    }\n    return (totalGcd == 1) ? 2 : 1;\n}\n\npublic int gcd(int a, int b) {\n    return (b == 0) ? a : gcd(b, a % b);\n}\n```\n    \n    The algorithm first finds the total GCD (greatest common divisor) of all the elements in the array. If the total GCD is 1, that means the array can't be split into a single subarray and satisfy the condition of having a GCD greater than 1. In this case, the minimum number of subarrays required is 2. Otherwise, if the total GCD is greater than 1, the entire array can be considered as a single subarray meeting the condition, so the answer is 1. The gcd function is a helper function that computes the GCD of two integers using the Euclidean algorithm.\n    ",
        "python": "\n    ```python\ndef min_arrays(nums):\n    def gcd(a, b):\n        return a if b == 0 else gcd(b, a % b)\n\n    total_gcd = nums[0]\n    for num in nums[1:]:\n        total_gcd = gcd(total_gcd, num)\n    \n    return 2 if total_gcd == 1 else 1\n```\n    \n    The algorithm first finds the total GCD (greatest common divisor) of all the elements in the array. If the total GCD is 1, that means the array can't be split into a single subarray and satisfy the condition of having a GCD greater than 1. In this case, the minimum number of subarrays required is 2. Otherwise, if the total GCD is greater than 1, the entire array can be considered as a single subarray meeting the condition, so the answer is 1. The gcd function is a helper function that computes the GCD of two integers using the Euclidean algorithm.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint gcd(int a, int b) {\n    return (b == 0) ? a : gcd (b, a % b);\n}\n\nint minArrays(std::vector<int>& nums) {\n    int n = nums.size();\n    int total_gcd = nums[0];\n    for (int i = 1; i < n; ++i) {\n        total_gcd = gcd(total_gcd, nums[i]);\n    }\n    return (total_gcd == 1) ? 2 : 1;\n}\n```\n    \n    The algorithm first finds the total GCD (greatest common divisor) of all the elements in the array. If the total GCD is 1, that means the array can't be split into a single subarray and satisfy the condition of having a GCD greater than 1. In this case, the minimum number of subarrays required is 2. Otherwise, if the total GCD is greater than 1, the entire array can be considered as a single subarray meeting the condition, so the answer is 1. The gcd function is a helper function that computes the GCD of two integers using the Euclidean algorithm.\n    ",
        "js": "\n    ```javascript\nfunction gcd(a, b) {\n    return (b === 0) ? a : gcd(b, a % b);\n}\n\nfunction minArrays(nums) {\n    let n = nums.length;\n    let totalGcd = nums[0];\n    for (let i = 1; i < n; ++i) {\n        totalGcd = gcd(totalGcd, nums[i]);\n    }\n    return (totalGcd === 1) ? 2 : 1;\n}\n```\n    \n    The algorithm first finds the total GCD (greatest common divisor) of all the elements in the array. If the total GCD is 1, that means the array can't be split into a single subarray and satisfy the condition of having a GCD greater than 1. In this case, the minimum number of subarrays required is 2. Otherwise, if the total GCD is greater than 1, the entire array can be considered as a single subarray meeting the condition, so the answer is 1. The gcd function is a helper function that computes the GCD of two integers using the Euclidean algorithm.\n    "
    },
    {
        "id": 363,
        "title": "Number of Nodes With Value One",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an **undirected** connected tree with `n` nodes labeled from `1` to `n` and `n - 1` edges. You are given the integer `n`. The parent node of a node with a label `v` is the node with the label `floor (v / 2)`. The root of the tree is the node with the label `1`.\n\n*   For example, if `n = 7`, then the node with the label `3` has the node with the label `floor(3 / 2) = 1` as its parent, and the node with the label `7` has the node with the label `floor(7 / 2) = 3` as its parent.\n\nYou are also given an integer array `queries`. Initially, every node has a value `0` on it. For each query `queries[i]`, you should flip all values in the subtree of the node with the label `queries[i]`.\n\nReturn _the total number of nodes with the value_ `1` _**after processing all the queries**_.\n\n**Note** that:\n\n*   Flipping the value of a node means that the node with the value `0` becomes `1` and vice versa.\n*   `floor(x)` is equivalent to rounding `x` down to the nearest integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5 , queries = \\[1,2,5\\]\n**Output:** 3\n**Explanation:** The diagram above shows the tree structure and its status after performing the queries. The blue node represents the value 0, and the red node represents the value 1.\nAfter processing the queries, there are three red nodes (nodes with value 1): 1, 3, and 5.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, queries = \\[2,3,3\\]\n**Output:** 1\n**Explanation:** The diagram above shows the tree structure and its status after performing the queries. The blue node represents the value 0, and the red node represents the value 1.\nAfter processing the queries, there are one red node (node with value 1): 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= queries.length <= 105`\n*   `1 <= queries[i] <= n`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "5,[1,2,5]",
                "output": "3"
            },
            {
                "input": "3,[2,3,3]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.List;\n\npublic int flipTrees(int n, List<Integer> queries) {\n    Map<Integer, Boolean> flippedNodes = new HashMap<>();\n    for (int query : queries) {\n        flippedNodes.put(query, !flippedNodes.getOrDefault(query, false));\n        while (query > 1) {\n            query /= 2;\n            flippedNodes.put(query, !flippedNodes.getOrDefault(query, false));\n        }\n    }\n    \n    int count = 0;\n    for (Map.Entry<Integer, Boolean> node : flippedNodes.entrySet()) {\n        if (node.getValue()) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    This algorithm uses a hash map to store the nodes that have been flipped. For each query, it toggles the flipped state of the current node and all its parent nodes up to the root (node `1`). After going through all the queries, it counts the number of nodes which are flipped (have a value of `1`) in the hash map.\n\nSince we only store the flipped nodes in the hash map, and not all the nodes, this algorithm has a space complexity lower than O(n). The time complexity is O(queries.length * log(n)), as each query corresponds to a path of length at most log(n) in the tree.\n    ",
        "python": "\n    ```python\ndef flip_trees(n, queries):\n    flipped_nodes = {}\n    for query in queries:\n        flipped_nodes[query] = not flipped_nodes.get(query, False)\n        while query > 1:\n            query //= 2\n            flipped_nodes[query] = not flipped_nodes.get(query, False)\n\n    count = 0\n    for value in flipped_nodes.values():\n        if value:\n            count += 1\n\n    return count\n```\n    \n    This algorithm uses a hash map to store the nodes that have been flipped. For each query, it toggles the flipped state of the current node and all its parent nodes up to the root (node `1`). After going through all the queries, it counts the number of nodes which are flipped (have a value of `1`) in the hash map.\n\nSince we only store the flipped nodes in the hash map, and not all the nodes, this algorithm has a space complexity lower than O(n). The time complexity is O(queries.length * log(n)), as each query corresponds to a path of length at most log(n) in the tree.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint flipTrees(int n, std::vector<int>& queries) {\n    std::unordered_map<int, bool> flipped_nodes;\n    for (int query : queries) {\n        flipped_nodes[query] = !flipped_nodes[query];\n        while (query > 1) {\n            query /= 2;\n            flipped_nodes[query] = !flipped_nodes[query];\n        }\n    }\n    \n    int count = 0;\n    for (const auto& node : flipped_nodes) {\n        if (node.second) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    This algorithm uses a hash map to store the nodes that have been flipped. For each query, it toggles the flipped state of the current node and all its parent nodes up to the root (node `1`). After going through all the queries, it counts the number of nodes which are flipped (have a value of `1`) in the hash map.\n\nSince we only store the flipped nodes in the hash map, and not all the nodes, this algorithm has a space complexity lower than O(n). The time complexity is O(queries.length * log(n)), as each query corresponds to a path of length at most log(n) in the tree.\n    ",
        "js": "\n    ```javascript\nfunction flipTrees(n, queries) {\n    const flippedNodes = new Map();\n\n    queries.forEach(query => {\n        flippedNodes.set(query, !flippedNodes.get(query));\n        while (query > 1) {\n            query = Math.floor(query / 2);\n            flippedNodes.set(query, !flippedNodes.get(query));\n        }\n    });\n\n    let count = 0;\n    flippedNodes.forEach(value => {\n        if (value) {\n            count++;\n        }\n    });\n\n    return count;\n}\n```\n    \n    This algorithm uses a hash map to store the nodes that have been flipped. For each query, it toggles the flipped state of the current node and all its parent nodes up to the root (node `1`). After going through all the queries, it counts the number of nodes which are flipped (have a value of `1`) in the hash map.\n\nSince we only store the flipped nodes in the hash map, and not all the nodes, this algorithm has a space complexity lower than O(n). The time complexity is O(queries.length * log(n)), as each query corresponds to a path of length at most log(n) in the tree.\n    "
    },
    {
        "id": 364,
        "title": "Number of Distinct Binary Strings After Applying Operations",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **binary** string `s` and a positive integer `k`.\n\nYou can apply the following operation on the string **any** number of times:\n\n*   Choose any substring of size `k` from `s` and **flip** all its characters, that is, turn all `1`'s into `0`'s, and all `0`'s into `1`'s.\n\nReturn _the number of **distinct** strings you can obtain_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Note** that:\n\n*   A binary string is a string that consists **only** of the characters `0` and `1`.\n*   A substring is a contiguous part of a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1001 \", k = 3\n**Output:** 4\n**Explanation:** We can obtain the following strings:\n- Applying no operation on the string gives s =  \"1001 \".\n- Applying one operation on the substring starting at index 0 gives s =  \"**011**1 \".\n- Applying one operation on the substring starting at index 1 gives s =  \"1**110** \".\n- Applying one operation on both the substrings starting at indices 0 and 1 gives s =  \"**0000** \".\nIt can be shown that we cannot obtain any other string, so the answer is 4.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10110 \", k = 5\n**Output:** 2\n**Explanation:** We can obtain the following strings:\n- Applying no operation on the string gives s =  \"10110 \".\n- Applying one operation on the whole string gives s =  \"01001 \".\nIt can be shown that we cannot obtain any other string, so the answer is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= s.length <= 105`\n*   `s[i]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"1001\",3",
                "output": "4"
            },
            {
                "input": "\"10110\",5",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int distinctStrings(String s, int k) {\n    int n = s.length(), cnt = 0;\n    Set<String> st = new HashSet<>();\n\n    for (int i = 0; i <= n - k; ++i) {\n        String temp = s.substring(0, i) + s.substring(i + k);\n        if (!st.contains(temp)) {\n            st.add(temp);\n            cnt = (cnt + 1) % 1000000007;\n        }\n    }\n    return cnt + 1; // Add 1 for the original string\n}\n```\n    \n    The algorithm used for this problem involves iterating through the string `s` and checking all possible substrings with a length of `k`. We use a set to store the strings we've seen so far, creating a new string by removing the substring of length `k`. After iterating through all the possible substrings, we take the length of the set and add 1 (for the original string), then return the count modulo 1000000007.\n    ",
        "python": "\n    ```python\ndef distinctStrings(s, k):\n    n = len(s)\n    cnt = 0\n    st = set()\n\n    for i in range(n - k + 1):\n        temp = s[:i] + s[i + k:]\n        if temp not in st:\n            st.add(temp)\n            cnt = (cnt + 1) % 1000000007\n\n    return cnt + 1 # Add 1 for the original string\n```\n    \n    The algorithm used for this problem involves iterating through the string `s` and checking all possible substrings with a length of `k`. We use a set to store the strings we've seen so far, creating a new string by removing the substring of length `k`. After iterating through all the possible substrings, we take the length of the set and add 1 (for the original string), then return the count modulo 1000000007.\n    ",
        "c++": "\n    ```cpp\n#include<string>\n#include<unordered_set>\n#define MOD 1000000007\nusing namespace std;\n\nint distinctStrings(string s, int k) {\n    int n = s.length(), cnt = 0;\n    unordered_set<string> st;\n\n    for (int i = 0; i <= n - k; ++i) {\n        string temp = s.substr(0, i) + s.substr(i + k);\n        if (st.count(temp) == 0) {\n            st.insert(temp);\n            cnt = (cnt + 1) % MOD;\n        }\n    }\n    return cnt + 1; // Add 1 for the original string \n}\n```\n    \n    The algorithm used for this problem involves iterating through the string `s` and checking all possible substrings with a length of `k`. We use a set to store the strings we've seen so far, creating a new string by removing the substring of length `k`. After iterating through all the possible substrings, we take the length of the set and add 1 (for the original string), then return the count modulo 1000000007.\n    ",
        "js": "\n    ```javascript\nfunction distinctStrings(s, k) {\n    const n = s.length;\n    let cnt = 0;\n    const st = new Set();\n\n    for (let i = 0; i <= n - k; ++i) {\n        const temp = s.substring(0, i) + s.substring(i + k);\n        if (!st.has(temp)) {\n            st.add(temp);\n            cnt = (cnt + 1) % 1000000007;\n        }\n    }\n    return cnt + 1; // Add 1 for the original string\n}\n```\n    \n    The algorithm used for this problem involves iterating through the string `s` and checking all possible substrings with a length of `k`. We use a set to store the strings we've seen so far, creating a new string by removing the substring of length `k`. After iterating through all the possible substrings, we take the length of the set and add 1 (for the original string), then return the count modulo 1000000007.\n    "
    },
    {
        "id": 365,
        "title": "Sort Array by Moving Items to Empty Space",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` of size `n` containing **each** element from `0` to `n - 1` (**inclusive**). Each of the elements from `1` to `n - 1` represents an item, and the element `0` represents an empty space.\n\nIn one operation, you can move **any** item to the empty space. `nums` is considered to be sorted if the numbers of all the items are in **ascending** order and the empty space is either at the beginning or at the end of the array.\n\nFor example, if `n = 4`, `nums` is sorted if:\n\n*   `nums = [0,1,2,3]` or\n*   `nums = [1,2,3,0]`\n\n...and considered to be unsorted otherwise.\n\nReturn _the **minimum** number of operations needed to sort_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,0,3,1\\]\n**Output:** 3\n**Explanation:**\n- Move item 2 to the empty space. Now, nums = \\[4,0,2,3,1\\].\n- Move item 1 to the empty space. Now, nums = \\[4,1,2,3,0\\].\n- Move item 4 to the empty space. Now, nums = \\[0,1,2,3,4\\].\nIt can be proven that 3 is the minimum number of operations needed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,0\\]\n**Output:** 0\n**Explanation:** nums is already sorted so return 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,0,2,4,3\\]\n**Output:** 2\n**Explanation:**\n- Move item 2 to the empty space. Now, nums = \\[1,2,0,4,3\\].\n- Move item 3 to the empty space. Now, nums = \\[1,2,3,4,0\\].\nIt can be proven that 2 is the minimum number of operations needed."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 105`\n*   `0 <= nums[i] < n`\n*   All the values of `nums` are **unique**.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[4,2,0,3,1]",
                "output": "3"
            },
            {
                "input": "[1,2,3,4,0]",
                "output": "0"
            },
            {
                "input": "[1,0,2,4,3]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int min_operations(int[] nums) {\n    int n = nums.length;\n    int idx0 = -1;\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] == 0) {\n            idx0 = i;\n            break;\n        }\n    }\n\n    int cnt1 = 0, cnt2 = 0;\n\n    for(int i = 1; i < n; i++) {\n        if(Math.abs(nums[i] - nums[i - 1]) != 1) {\n            cnt1 += Math.abs(nums[i] - nums[i - 1]) - 1;\n        }\n    }\n\n    for(int i = idx0 + 1; i < n; i++) {\n        if(nums[i] < nums[i - 1]) {\n            cnt2++;\n        }\n    }\n\n    return Math.min(cnt1, cnt2);\n}\n```\n    \n    1. Find the position of the empty space represented by 0, store it in `idx0`\n2. Initialize two count variables as `cnt1` and `cnt2` to store the minimum number of operations\n3. Iterate through the array and calculate the difference between adjacent elements and increment the count `cnt1` by the difference minus 1.\n4. Iterate through a subarray, starting from `idx0 + 1` to the end of the array. If the current element is less than the previous element, increment the count `cnt2`.\n5. Return the minimum of `cnt1` and `cnt2`\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    n = len(nums)\n    idx0 = -1\n\n    for i in range(n):\n        if nums[i] == 0:\n            idx0 = i\n            break\n\n    cnt1 = 0\n    cnt2 = 0\n\n    for i in range(1, n):\n        if abs(nums[i] - nums[i - 1]) != 1:\n            cnt1 += abs(nums[i] - nums[i - 1]) - 1\n\n    for i in range(idx0 + 1, n):\n        if nums[i] < nums[i - 1]:\n            cnt2 += 1\n\n    return min(cnt1, cnt2)\n```\n    \n    1. Find the position of the empty space represented by 0, store it in `idx0`\n2. Initialize two count variables as `cnt1` and `cnt2` to store the minimum number of operations\n3. Iterate through the array and calculate the difference between adjacent elements and increment the count `cnt1` by the difference minus 1.\n4. Iterate through a subarray, starting from `idx0 + 1` to the end of the array. If the current element is less than the previous element, increment the count `cnt2`.\n5. Return the minimum of `cnt1` and `cnt2`\n    ",
        "c++": "\n    ```cpp\nint min_operations(vector<int>& nums) {\n    int n = nums.size();\n    int idx0 = -1;\n    \n    for(int i = 0; i < n; i++) {\n        if(nums[i] == 0) {\n            idx0 = i;\n            break;\n        }\n    }\n    \n    int cnt1 = 0, cnt2 = 0;\n    \n    for(int i = 1; i < n; i++) {\n        if(abs(nums[i] - nums[i - 1]) != 1) {\n            cnt1 += abs(nums[i] - nums[i - 1]) - 1;\n        }\n    }\n    \n    for(int i = idx0 + 1; i < n; i++) {\n        if(nums[i] < nums[i - 1]) {\n            cnt2++;\n        }\n    }\n    \n    return min(cnt1, cnt2);\n}\n```\n    \n    1. Find the position of the empty space represented by 0, store it in `idx0`\n2. Initialize two count variables as `cnt1` and `cnt2` to store the minimum number of operations\n3. Iterate through the array and calculate the difference between adjacent elements and increment the count `cnt1` by the difference minus 1.\n4. Iterate through a subarray, starting from `idx0 + 1` to the end of the array. If the current element is less than the previous element, increment the count `cnt2`.\n5. Return the minimum of `cnt1` and `cnt2`\n    ",
        "js": "\n    ```javascript\nfunction min_operations(nums) {\n    const n = nums.length;\n    let idx0 = -1;\n\n    for (let i = 0; i < n; i++) {\n        if (nums[i] === 0) {\n            idx0 = i;\n            break;\n        }\n    }\n\n    let cnt1 = 0, cnt2 = 0;\n\n    for (let i = 1; i < n; i++) {\n        if (Math.abs(nums[i] - nums[i - 1]) !== 1) {\n            cnt1 += Math.abs(nums[i] - nums[i - 1]) - 1;\n        }\n    }\n\n    for (let i = idx0 + 1; i < n; i++) {\n        if (nums[i] < nums[i - 1]) {\n            cnt2++;\n        }\n    }\n\n    return Math.min(cnt1, cnt2);\n}\n```\n    \n    1. Find the position of the empty space represented by 0, store it in `idx0`\n2. Initialize two count variables as `cnt1` and `cnt2` to store the minimum number of operations\n3. Iterate through the array and calculate the difference between adjacent elements and increment the count `cnt1` by the difference minus 1.\n4. Iterate through a subarray, starting from `idx0 + 1` to the end of the array. If the current element is less than the previous element, increment the count `cnt2`.\n5. Return the minimum of `cnt1` and `cnt2`\n    "
    },
    {
        "id": 366,
        "title": "Minimum Subarrays in a Valid Split",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums`.\n\nSplitting of an integer array `nums` into **subarrays** is **valid** if:\n\n*   the _greatest common divisor_ of the first and last elements of each subarray is **greater** than `1`, and\n*   each element of `nums` belongs to exactly one subarray.\n\nReturn _the **minimum** number of subarrays in a **valid** subarray splitting of_ `nums`. If a valid subarray splitting is not possible, return `-1`.\n\n**Note** that:\n\n*   The **greatest common divisor** of two numbers is the largest positive integer that evenly divides both numbers.\n*   A **subarray** is a contiguous non-empty part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,6,3,4,3\\]\n**Output:** 2\n**Explanation:** We can create a valid split in the following way: \\[2,6\\] | \\[3,4,3\\].\n- The starting element of the 1st subarray is 2 and the ending is 6. Their greatest common divisor is 2, which is greater than 1.\n- The starting element of the 2nd subarray is 3 and the ending is 3. Their greatest common divisor is 3, which is greater than 1.\nIt can be proved that 2 is the minimum number of subarrays that we can obtain in a valid split.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,5\\]\n**Output:** 2\n**Explanation:** We can create a valid split in the following way: \\[3\\] | \\[5\\].\n- The starting element of the 1st subarray is 3 and the ending is 3. Their greatest common divisor is 3, which is greater than 1.\n- The starting element of the 2nd subarray is 5 and the ending is 5. Their greatest common divisor is 5, which is greater than 1.\nIt can be proved that 2 is the minimum number of subarrays that we can obtain in a valid split.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,1\\]\n**Output:** -1\n**Explanation:** It is impossible to create valid split."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,6,3,4,3]",
                "output": "2"
            },
            {
                "input": "[3,5]",
                "output": "2"
            },
            {
                "input": "[1,2,1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minValidSubarrays(int[] nums) {\n    int count = 0;\n    while(nums.length > 0) {\n        int i;\n        for (i = 0; i < nums.length; i++) {\n            if (gcd(nums[i], nums[nums.length - 1]) > 1) {\n                break;\n            }\n        }\n        if (i == nums.length) {\n            nums = Arrays.copyOf(nums, nums.length - 1);\n            count++;\n        } else {\n            break;\n        }\n    }\n    return (count > 0) ? count : -1;\n}\n\nprivate int gcd(int a, int b) {\n    while (b != 0) {\n        int temp = a % b;\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n```\n    \n    The algorithm for this problem is as follows:\n1. Initialize a counter to track the number of valid subarrays.\n2. As long as the input array is not empty, iterate through the elements of the array.\n3. For each element, check if the greatest common divisor (GCD) of the current element and the last element is greater than 1. If so, break the loop.\n4. If we reached the end of the array and the loop didn't break, that means we don't have a valid subarray yet, so increment the counter and remove the last element of the array.\n5. Repeat steps 2-4 until the array is empty or a valid subarray is found.\n6. Finally, if the counter is greater than 0, return the counter value as the minimum number of valid subarrays, otherwise return -1 if no valid subarray splitting is possible.\n    ",
        "python": "\n    ```python\nfrom math import gcd\n\ndef min_valid_subarrays(nums):\n    count = 0\n    while nums:\n        for i in range(len(nums)):\n            if gcd(nums[i], nums[-1]) > 1:\n                break\n        else:\n            count += 1\n            nums.pop()\n    return count if count > 0 else -1\n```\n    \n    The algorithm for this problem is as follows:\n1. Initialize a counter to track the number of valid subarrays.\n2. As long as the input array is not empty, iterate through the elements of the array.\n3. For each element, check if the greatest common divisor (GCD) of the current element and the last element is greater than 1. If so, break the loop.\n4. If we reached the end of the array and the loop didn't break, that means we don't have a valid subarray yet, so increment the counter and remove the last element of the array.\n5. Repeat steps 2-4 until the array is empty or a valid subarray is found.\n6. Finally, if the counter is greater than 0, return the counter value as the minimum number of valid subarrays, otherwise return -1 if no valid subarray splitting is possible.\n    ",
        "c++": "\n    ```cpp\n#include <numeric>\nint min_valid_subarrays(vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        while (i < nums.size() && std::gcd(nums[i], nums.back()) == 1) {\n            i++;\n        }\n        if (i < nums.size()) {\n            count++;\n            nums.pop_back();\n        }\n    }\n    return count > 0 ? count : -1;\n}\n```\n    \n    The algorithm for this problem is as follows:\n1. Initialize a counter to track the number of valid subarrays.\n2. As long as the input array is not empty, iterate through the elements of the array.\n3. For each element, check if the greatest common divisor (GCD) of the current element and the last element is greater than 1. If so, break the loop.\n4. If we reached the end of the array and the loop didn't break, that means we don't have a valid subarray yet, so increment the counter and remove the last element of the array.\n5. Repeat steps 2-4 until the array is empty or a valid subarray is found.\n6. Finally, if the counter is greater than 0, return the counter value as the minimum number of valid subarrays, otherwise return -1 if no valid subarray splitting is possible.\n    ",
        "js": "\n    ```javascript\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let temp = a % b;\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n\nfunction minValidSubarrays(nums) {\n    let count = 0;\n    while (nums.length > 0) {\n        let i;\n        for (i = 0; i < nums.length; i++) {\n            if (gcd(nums[i], nums[nums.length - 1]) > 1) {\n                break;\n            }\n        }\n        if (i === nums.length) {\n            nums.pop();\n            count++;\n        } else {\n            break;\n        }\n    }\n    return (count > 0) ? count : -1;\n}\n```\n    \n    The algorithm for this problem is as follows:\n1. Initialize a counter to track the number of valid subarrays.\n2. As long as the input array is not empty, iterate through the elements of the array.\n3. For each element, check if the greatest common divisor (GCD) of the current element and the last element is greater than 1. If so, break the loop.\n4. If we reached the end of the array and the loop didn't break, that means we don't have a valid subarray yet, so increment the counter and remove the last element of the array.\n5. Repeat steps 2-4 until the array is empty or a valid subarray is found.\n6. Finally, if the counter is greater than 0, return the counter value as the minimum number of valid subarrays, otherwise return -1 if no valid subarray splitting is possible.\n    "
    },
    {
        "id": 367,
        "title": "Minimum Cost to Buy Apples",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a positive integer `n` representing `n` cities numbered from `1` to `n`. You are also given a **2D** array `roads`, where `roads[i] = [ai, bi, costi]` indicates that there is a **bidirectional** road between cities `ai` and `bi` with a cost of traveling equal to `costi`.\n\nYou can buy apples in **any** city you want, but some cities have different costs to buy apples. You are given the array `appleCost` where `appleCost[i]` is the cost of buying one apple from city `i`.\n\nYou start at some city, traverse through various roads, and eventually buy **exactly** one apple from **any** city. After you buy that apple, you have to return back to the city you **started** at, but now the cost of all the roads will be **multiplied** by a given factor `k`.\n\nGiven the integer `k`, return _an array_ `answer` _of size_ `n` _where_ `answer[i]` _is the **minimum** total cost to buy an apple if you start at city_ `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, roads = \\[\\[1,2,4\\],\\[2,3,2\\],\\[2,4,5\\],\\[3,4,1\\],\\[1,3,4\\]\\], appleCost = \\[56,42,102,301\\], k = 2\n**Output:** \\[54,42,48,51\\]\n**Explanation:** The minimum cost for each starting city is the following:\n- Starting at city 1: You take the path 1 -> 2, buy an apple at city 2, and finally take the path 2 -> 1. The total cost is 4 + 42 + 4 \\* 2 = 54.\n- Starting at city 2: You directly buy an apple at city 2. The total cost is 42.\n- Starting at city 3: You take the path 3 -> 2, buy an apple at city 2, and finally take the path 2 -> 3. The total cost is 2 + 42 + 2 \\* 2 = 48.\n- Starting at city 4: You take the path 4 -> 3 -> 2 then you buy at city 2, and finally take the path 2 -> 3 -> 4. The total cost is 1 + 2 + 42 + 1 \\* 2 + 2 \\* 2 = 51.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, roads = \\[\\[1,2,5\\],\\[2,3,1\\],\\[3,1,2\\]\\], appleCost = \\[2,3,1\\], k = 3\n**Output:** \\[2,3,1\\]\n**Explanation:** It is always optimal to buy the apple in the starting city."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= roads.length <= 1000`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   `1 <= costi <= 105`\n*   `appleCost.length == n`\n*   `1 <= appleCost[i] <= 105`\n*   `1 <= k <= 100`\n*   There are no repeated edges.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "4,[[1,2,4],[2,3,2],[2,4,5],[3,4,1],[1,3,4]],[56,42,102,301],2",
                "output": "[54,42,48,51]"
            },
            {
                "input": "3,[[1,2,5],[2,3,1],[3,1,2]],[2,3,1],3",
                "output": "[2,3,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public static int[] minTotalCost(int n, int[][] roads, int[] appleCost, int k) {\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] road : roads) {\n            graph.get(road[0]).add(new int[]{road[1], road[2]});\n            graph.get(road[1]).add(new int[]{road[0], road[2]});\n        }\n\n        int[] answer = new int[n];\n        for (int start = 1; start <= n; start++) {\n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n            int[] dist = new int[n + 1];\n            Arrays.fill(dist, 1_000_000_007);\n            dist[start] = 0;\n            pq.add(new int[]{0, start});\n            while (!pq.isEmpty()) {\n                int u = pq.peek()[1];\n                int d = pq.peek()[0];\n                pq.poll();\n\n                if (d > dist[u]) continue;\n\n                for (int[] edge : graph.get(u)) {\n                    int v = edge[0];\n                    int c = d + edge[1] + (u != start ? edge[1] * k : 0) + appleCost[v - 1];\n                    if (c < dist[v]) {\n                        dist[v] = c;\n                        pq.add(new int[]{c, v});\n                    }\n                }\n            }\n\n            answer[start - 1] = dist[start];\n        }\n        return answer;\n    }\n}\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm. It is important to always choose the road with the lowest cost possible to buy apples or back to the original city. The approach is to create a graph and use a priority queue that is sorted from the lowest to the highest cost in each step. \n\n1. Create the graph from the input roads.\n2. Loop through each city as a starting point.\n3. For each start city, initialize a priority queue and the distance array.\n4. Using Dijkstra's algorithm, calculate the costs for buying apples in each city from the current start city and the costs back to the start city after buying apples. Note that the cost of the roads back to the start city will be the road cost multiplied by k.\n5. Store the calculated cost in the answer array for each start city.\n6. Return the answer array.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef minTotalCost(n, roads, appleCost, k):\n    graph = [[] for _ in range(n+1)]\n    for u, v, cost in roads:\n        graph[u].append((v, cost))\n        graph[v].append((u, cost))\n\n    answer = [0] * n\n    for start in range(1, n+1):\n        pq = [(0, start)]\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n\n        while pq:\n            d, u = heappop(pq)\n\n            if d > dist[u]:\n                continue\n\n            for v, cost in graph[u]:\n                c = d + cost + (0 if u == start else cost * k) + appleCost[v - 1]\n                if c < dist[v]:\n                    dist[v] = c\n                    heappush(pq, (c, v))\n\n        answer[start-1] = dist[start]\n    return answer\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm. It is important to always choose the road with the lowest cost possible to buy apples or back to the original city. The approach is to create a graph and use a priority queue that is sorted from the lowest to the highest cost in each step. \n\n1. Create the graph from the input roads.\n2. Loop through each city as a starting point.\n3. For each start city, initialize a priority queue and the distance array.\n4. Using Dijkstra's algorithm, calculate the costs for buying apples in each city from the current start city and the costs back to the start city after buying apples. Note that the cost of the roads back to the start city will be the road cost multiplied by k.\n5. Store the calculated cost in the answer array for each start city.\n6. Return the answer array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nvector<int> minTotalCost(int n, vector<vector<int>>& roads, vector<int>& appleCost, int k) {\n    vector<vector<pair<int, int>>> graph(n+1);\n    for (auto& road : roads) {\n        graph[road[0]].push_back({road[1], road[2]});\n        graph[road[1]].push_back({road[0], road[2]});\n    }\n\n    vector<int> answer(n);\n    for (int start = 1; start <= n; ++start) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        vector<int> dist(n + 1, 1e9);\n        dist[start] = 0;\n        pq.push({0, start});\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int d = pq.top().first;\n            pq.pop();\n\n            if (d > dist[u]) continue;\n\n            for (auto& edge : graph[u]) {\n                int v = edge.first;\n                int c = d + edge.second + (u != start ? edge.second * k : 0) + appleCost[v - 1];\n\n                if (c < dist[v]) {\n                    dist[v] = c;\n                    pq.push({c, v});\n                }\n            }\n        }\n\n        answer[start-1] = dist[start];\n    }\n    return answer;\n}\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm. It is important to always choose the road with the lowest cost possible to buy apples or back to the original city. The approach is to create a graph and use a priority queue that is sorted from the lowest to the highest cost in each step. \n\n1. Create the graph from the input roads.\n2. Loop through each city as a starting point.\n3. For each start city, initialize a priority queue and the distance array.\n4. Using Dijkstra's algorithm, calculate the costs for buying apples in each city from the current start city and the costs back to the start city after buying apples. Note that the cost of the roads back to the start city will be the road cost multiplied by k.\n5. Store the calculated cost in the answer array for each start city.\n6. Return the answer array.\n    ",
        "js": "\n    ```javascript\nfunction minTotalCost(n, roads, appleCost, k) {\n    const graph = Array.from({ length: n + 1 }, () => []);\n    for (const [u, v, cost] of roads) {\n        graph[u].push([v, cost]);\n        graph[v].push([u, cost]);\n    }\n\n    const answer = Array(n).fill(0);\n    for (let start = 1; start <= n; start++) {\n        const pq = [[0, start]];\n        const dist = Array(n + 1).fill(Infinity);\n        dist[start] = 0;\n\n        while (pq.length) {\n            const [d, u] = pq.shift();\n            if (d > dist[u]) continue;\n\n            for (const [v, cost] of graph[u]) {\n                const c = d + cost + (u !== start ? cost * k : 0) + appleCost[v - 1];\n                if (c < dist[v]) {\n                    dist[v] = c;\n                    pq.push([c, v]);\n                    pq.sort((a, b) => a[0] - b[0]);\n                }\n            }\n        }\n\n        answer[start - 1] = dist[start];\n    }\n    return answer;\n}\n```\n\n    \n    The problem can be solved using Dijkstra's algorithm. It is important to always choose the road with the lowest cost possible to buy apples or back to the original city. The approach is to create a graph and use a priority queue that is sorted from the lowest to the highest cost in each step. \n\n1. Create the graph from the input roads.\n2. Loop through each city as a starting point.\n3. For each start city, initialize a priority queue and the distance array.\n4. Using Dijkstra's algorithm, calculate the costs for buying apples in each city from the current start city and the costs back to the start city after buying apples. Note that the cost of the roads back to the start city will be the road cost multiplied by k.\n5. Store the calculated cost in the answer array for each start city.\n6. Return the answer array.\n    "
    },
    {
        "id": 368,
        "title": "Maximum XOR of Two Non-Overlapping Subtrees",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`. You are given the integer `n` and a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. The root of the tree is the node labeled `0`.\n\nEach node has an associated **value**. You are given an array `values` of length `n`, where `values[i]` is the **value** of the `ith` node.\n\nSelect any two **non-overlapping** subtrees. Your **score** is the bitwise XOR of the sum of the values within those subtrees.\n\nReturn _the_ _**maximum**_ _possible **score** you can achieve_. _If it is impossible to find two nonoverlapping subtrees_, return `0`.\n\n**Note** that:\n\n*   The **subtree** of a node is the tree consisting of that node and all of its descendants.\n*   Two subtrees are **non-overlapping** if they do not share **any common** node.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\]\\], values = \\[2,8,3,6,2,5\\]\n**Output:** 24\n**Explanation:** Node 1's subtree has sum of values 16, while node 2's subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\]\\], values = \\[4,6,1\\]\n**Output:** 0\n**Explanation:** There is no possible way to select two non-overlapping subtrees, so we just return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 5 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `values.length == n`\n*   `1 <= values[i] <= 109`\n*   It is guaranteed that `edges` represents a valid tree.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "6,[[0,1],[0,2],[1,3],[1,4],[2,5]],[2,8,3,6,2,5]",
                "output": "24"
            },
            {
                "input": "3,[[0,1],[1,2]],[4,6,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxXorSubtree(int n, int[][] edges, int[] values) {\n    List<List<Integer>> tree = new ArrayList<>();\n    \n    for (int i = 0; i < n; i++) {\n        tree.add(new ArrayList<>());\n    }\n    \n    for (int[] edge : edges) {\n        tree.get(edge[0]).add(edge[1]);\n        tree.get(edge[1]).add(edge[0]);\n    }\n    \n    int[] firstMax = new int[]{0};\n    int rootSum = dfs(0, -1, tree, values, firstMax);\n    \n    return rootSum ^ firstMax[0];\n}\n\nprivate int dfs(int node, int parent, List<List<Integer>> tree, int[] values, int[] firstMax) {\n    int currentSum = values[node];\n    \n    for (int child : tree.get(node)) {\n        if (child != parent) {\n            currentSum ^= dfs(child, node, tree, values, firstMax);\n        }\n    }\n    \n    firstMax[0] = Math.max(firstMax[0], currentSum);\n    \n    return currentSum;\n}\n```\n    \n    We first convert the given edges into an adjacency list representation of the tree. In the main `maxXorSubtree` function, we initialize the `firstMax` variable that will store the maximum XOR value of a subtree rooted in any node.\n\nThen we perform a depth-first traversal of the tree, starting at the root. In the traversal (`dfs` function), we keep track of the current node, its parent, the tree, the values array, and a reference to the `firstMax` variable.\n\nFor each node in the tree, we calculate the sum of values in its subtree (the currentSum). To do this, we first set the currentSum to the value of the node itself. Then, we iterate over its children and recursively call the `dfs` function on them. During this process, we XOR the currentSum and the sum of values in each child's subtree. After visiting all children, we update the `firstMax` variable with the maximum XOR value we've encountered so far.\n\nFinally, we return the XOR of the root's value and the `firstMax` value. Since the subtrees are non-overlapping and don't include the root, this is the maximum possible score we can achieve.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef maxXorSubtree(n, edges, values):\n    tree = defaultdict(list)\n\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n\n    first_max = [0]\n    root_sum = dfs(0, -1, tree, values, first_max)\n\n    return root_sum ^ first_max[0]\n\ndef dfs(node, parent, tree, values, first_max):\n    current_sum = values[node]\n\n    for child in tree[node]:\n        if child != parent:\n            current_sum ^= dfs(child, node, tree, values, first_max)\n\n    first_max[0] = max(first_max[0], current_sum)\n\n    return current_sum\n```\n    \n    We first convert the given edges into an adjacency list representation of the tree. In the main `maxXorSubtree` function, we initialize the `firstMax` variable that will store the maximum XOR value of a subtree rooted in any node.\n\nThen we perform a depth-first traversal of the tree, starting at the root. In the traversal (`dfs` function), we keep track of the current node, its parent, the tree, the values array, and a reference to the `firstMax` variable.\n\nFor each node in the tree, we calculate the sum of values in its subtree (the currentSum). To do this, we first set the currentSum to the value of the node itself. Then, we iterate over its children and recursively call the `dfs` function on them. During this process, we XOR the currentSum and the sum of values in each child's subtree. After visiting all children, we update the `firstMax` variable with the maximum XOR value we've encountered so far.\n\nFinally, we return the XOR of the root's value and the `firstMax` value. Since the subtrees are non-overlapping and don't include the root, this is the maximum possible score we can achieve.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint dfs(int node, int parent, vector<vector<int>>& tree, vector<int>& values, int& firstMax) {\n    int currentSum = values[node];\n    \n    for (int child : tree[node]) {\n        if (child != parent) {\n            currentSum ^= dfs(child, node, tree, values, firstMax);\n        }\n    }\n    \n    firstMax = max(firstMax, currentSum);\n    \n    return currentSum;\n}\n\nint maxXorSubtree(int n, vector<vector<int>>& edges, vector<int>& values) {\n    vector<vector<int>> tree(n);\n    \n    for (const auto& edge : edges) {\n        tree[edge[0]].emplace_back(edge[1]);\n        tree[edge[1]].emplace_back(edge[0]);\n    }\n    \n    int firstMax = 0;\n    int rootSum = dfs(0, -1, tree, values, firstMax);\n    \n    return rootSum ^ firstMax;\n}\n```\n    \n    We first convert the given edges into an adjacency list representation of the tree. In the main `maxXorSubtree` function, we initialize the `firstMax` variable that will store the maximum XOR value of a subtree rooted in any node.\n\nThen we perform a depth-first traversal of the tree, starting at the root. In the traversal (`dfs` function), we keep track of the current node, its parent, the tree, the values array, and a reference to the `firstMax` variable.\n\nFor each node in the tree, we calculate the sum of values in its subtree (the currentSum). To do this, we first set the currentSum to the value of the node itself. Then, we iterate over its children and recursively call the `dfs` function on them. During this process, we XOR the currentSum and the sum of values in each child's subtree. After visiting all children, we update the `firstMax` variable with the maximum XOR value we've encountered so far.\n\nFinally, we return the XOR of the root's value and the `firstMax` value. Since the subtrees are non-overlapping and don't include the root, this is the maximum possible score we can achieve.\n    ",
        "js": "\n    ```javascript\nfunction maxXorSubtree(n, edges, values) {\n    const tree = new Map();\n\n    for (const edge of edges) {\n        if (!tree.has(edge[0])) {\n            tree.set(edge[0], []);\n        }\n        \n        if (!tree.has(edge[1])) {\n            tree.set(edge[1], []);\n        }\n\n        tree.get(edge[0]).push(edge[1]);\n        tree.get(edge[1]).push(edge[0]);\n    }\n\n    let firstMax = 0;\n    const rootSum = dfs(0, -1, tree, values, { firstMax });\n\n    return rootSum ^ firstMax;\n}\n\nfunction dfs(node, parent, tree, values, ref) {\n    let currentSum = values[node];\n\n    for (const child of tree.get(node)) {\n        if (child !== parent) {\n            currentSum ^= dfs(child, node, tree, values, ref);\n        }\n    }\n\n    ref.firstMax = Math.max(ref.firstMax, currentSum);\n\n    return currentSum;\n}\n```\n    \n    We first convert the given edges into an adjacency list representation of the tree. In the main `maxXorSubtree` function, we initialize the `firstMax` variable that will store the maximum XOR value of a subtree rooted in any node.\n\nThen we perform a depth-first traversal of the tree, starting at the root. In the traversal (`dfs` function), we keep track of the current node, its parent, the tree, the values array, and a reference to the `firstMax` variable.\n\nFor each node in the tree, we calculate the sum of values in its subtree (the currentSum). To do this, we first set the currentSum to the value of the node itself. Then, we iterate over its children and recursively call the `dfs` function on them. During this process, we XOR the currentSum and the sum of values in each child's subtree. After visiting all children, we update the `firstMax` variable with the maximum XOR value we've encountered so far.\n\nFinally, we return the XOR of the root's value and the `firstMax` value. Since the subtrees are non-overlapping and don't include the root, this is the maximum possible score we can achieve.\n    "
    },
    {
        "id": 369,
        "title": "Number of Substrings With Fixed Ratio",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a binary string `s`, and two integers `num1` and `num2`. `num1` and `num2` are coprime numbers.\n\nA **ratio substring** is a substring of s where the ratio between the number of `0`'s and the number of `1`'s in the substring is exactly `num1 : num2`.\n\n*   For example, if `num1 = 2` and `num2 = 3`, then `\"01011 \"` and `\"1110000111 \"` are ratio substrings, while `\"11000 \"` is not.\n\nReturn _the number of **non-empty** ratio substrings of_ `s`.\n\n**Note** that:\n\n*   A **substring** is a contiguous sequence of characters within a string.\n*   Two values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the greatest common divisor of `x` and `y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"0110011 \", num1 = 1, num2 = 2\n**Output:** 4\n**Explanation:** There exist 4 non-empty ratio substrings.\n- The substring s\\[0..2\\]:  \"0110011 \". It contains one 0 and two 1's. The ratio is 1 : 2.\n- The substring s\\[1..4\\]:  \"0110011 \". It contains one 0 and two 1's. The ratio is 1 : 2.\n- The substring s\\[4..6\\]:  \"0110011 \". It contains one 0 and two 1's. The ratio is 1 : 2.\n- The substring s\\[1..6\\]:  \"0110011 \". It contains two 0's and four 1's. The ratio is 2 : 4 == 1 : 2.\nIt can be shown that there are no more ratio substrings.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10101 \", num1 = 3, num2 = 1\n**Output:** 0\n**Explanation:** There is no ratio substrings of s. We return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `1 <= num1, num2 <= s.length`\n*   `num1` and `num2` are coprime integers.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"0110011\",1,2",
                "output": "4"
            },
            {
                "input": "\"10101\",3,1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int ratioSubstringCount(String s, int num1, int num2) {\n    int count0 = 0, count1 = 0;\n    Map<Integer, Integer> frequency = new HashMap<>();\n    int result = 0;\n    \n    frequency.put(0, 1);\n    \n    for (char c : s.toCharArray()) {\n        if (c == '0') count0++;\n        else count1++;\n        \n        int curr_diff = count0 * num2 - count1 * num1;\n        result += frequency.getOrDefault(curr_diff, 0);\n        frequency.put(curr_diff, frequency.getOrDefault(curr_diff, 0) + 1);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize the counters `count0` and `count1` for counting the number of '0's and '1's, respectively, in the continuous subsequence.\n2. Initialize a hashmap `frequency` to track the difference between the number of '0's and '1's multiplied by the coefficients.\n3. For each character in the string, increment the counters based on the character being '0' or '1'.\n4. Calculate the difference between the number of '0's and '1's multiplied by the coefficients.\n5. Increment the result by the value of frequency hashmap (count of diff occurrences) at key `curr_diff`.\n6. Increment the frequency hashmap value (count of diff occurrences) at key `curr_diff`.\n7. Return the result.\n    ",
        "python": "\n    ```python\ndef ratio_substring_count(s: str, num1: int, num2: int) -> int:\n    count0, count1 = 0, 0\n    frequency = {0: 1}\n    result = 0\n\n    for c in s:\n        if c == '0':\n            count0 += 1\n        else:\n            count1 += 1\n\n        curr_diff = count0 * num2 - count1 * num1\n        result += frequency.get(curr_diff, 0)\n        frequency[curr_diff] = frequency.get(curr_diff, 0) + 1\n\n    return result\n```\n\n    \n    1. Initialize the counters `count0` and `count1` for counting the number of '0's and '1's, respectively, in the continuous subsequence.\n2. Initialize a hashmap `frequency` to track the difference between the number of '0's and '1's multiplied by the coefficients.\n3. For each character in the string, increment the counters based on the character being '0' or '1'.\n4. Calculate the difference between the number of '0's and '1's multiplied by the coefficients.\n5. Increment the result by the value of frequency hashmap (count of diff occurrences) at key `curr_diff`.\n6. Increment the frequency hashmap value (count of diff occurrences) at key `curr_diff`.\n7. Return the result.\n    ",
        "c++": "\n    ```cpp\nint ratioSubstringCount(std::string s, int num1, int num2) {\n    int count0 = 0, count1 = 0;\n    std::map<int, int> frequency;\n    int result = 0;\n    \n    frequency[0] = 1;\n    \n    for (char c : s) {\n        if (c == '0') count0++;\n        else count1++;\n        \n        int curr_diff = count0 * num2 - count1 * num1;\n        result += frequency[curr_diff];\n        frequency[curr_diff]++;\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize the counters `count0` and `count1` for counting the number of '0's and '1's, respectively, in the continuous subsequence.\n2. Initialize a hashmap `frequency` to track the difference between the number of '0's and '1's multiplied by the coefficients.\n3. For each character in the string, increment the counters based on the character being '0' or '1'.\n4. Calculate the difference between the number of '0's and '1's multiplied by the coefficients.\n5. Increment the result by the value of frequency hashmap (count of diff occurrences) at key `curr_diff`.\n6. Increment the frequency hashmap value (count of diff occurrences) at key `curr_diff`.\n7. Return the result.\n    ",
        "js": "\n    ```javascript\nfunction ratioSubstringCount(s, num1, num2) {\n    let count0 = 0, count1 = 0;\n    let frequency = new Map();\n    let result = 0;\n\n    frequency.set(0, 1);\n\n    for (let c of s) {\n        if (c === '0') count0++;\n        else count1++;\n\n        let curr_diff = count0 * num2 - count1 * num1;\n        result += (frequency.get(curr_diff) || 0);\n        frequency.set(curr_diff, (frequency.get(curr_diff) || 0) + 1);\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize the counters `count0` and `count1` for counting the number of '0's and '1's, respectively, in the continuous subsequence.\n2. Initialize a hashmap `frequency` to track the difference between the number of '0's and '1's multiplied by the coefficients.\n3. For each character in the string, increment the counters based on the character being '0' or '1'.\n4. Calculate the difference between the number of '0's and '1's multiplied by the coefficients.\n5. Increment the result by the value of frequency hashmap (count of diff occurrences) at key `curr_diff`.\n6. Increment the frequency hashmap value (count of diff occurrences) at key `curr_diff`.\n7. Return the result.\n    "
    },
    {
        "id": 370,
        "title": "Number of Subarrays Having Even Product",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums`, return _the number of subarrays of_ `nums` _having an even product_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[9,6,7,13\\]\n**Output:** 6\n**Explanation:** There are 6 subarrays with an even product:\n- nums\\[0..1\\] = 9 \\* 6 = 54.\n- nums\\[0..2\\] = 9 \\* 6 \\* 7 = 378.\n- nums\\[0..3\\] = 9 \\* 6 \\* 7 \\* 13 = 4914.\n- nums\\[1..1\\] = 6.\n- nums\\[1..2\\] = 6 \\* 7 = 42.\n- nums\\[1..3\\] = 6 \\* 7 \\* 13 = 546.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,3,5\\]\n**Output:** 0\n**Explanation:** There are no subarrays with an even product."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[9,6,7,13]",
                "output": "6"
            },
            {
                "input": "[7,3,5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numberOfEvenSubarrays(int[] nums) {\n    int n = nums.length;\n    int evenCount = 0, oddCount = 0, result = 0;\n\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            evenCount++;\n            result += evenCount;\n        } else {\n            int temp = evenCount;\n            evenCount = oddCount;\n            oddCount = temp;\n            oddCount++;\n            result += oddCount;\n        }\n    }\n\n    return result;\n}\n```\n    \n    In this algorithm, the number of subarrays with even product can be formed by keeping track of counts of even and odd products in the subarrays ending at the current index. `evenCount` and `oddCount` are used to store the number of subarrays ending at the current index with even and odd products, respectively.\n\nFor each number in the input array `nums`, we check if the current number is even or odd. If the current number is even, the number of even subarrays ending at the current index is incremented by 1 (`evenCount++`). The result is incremented by the value of `evenCount`.\n\nIf the current number is odd, we swap the values of `evenCount` and `oddCount` (as an even product multiplied by an odd number gives an odd product, and vice versa). The count of odd subarrays ending at the current index is incremented by 1 (`oddCount++`), and the result is incremented by the value of `oddCount`.\n\nWe do this for each number in the input array `nums` and return the final result.\n    ",
        "python": "\n    ```python\ndef numberOfEvenSubarrays(nums):\n    n = len(nums)\n    evenCount, oddCount, result = 0, 0, 0\n\n    for num in nums:\n        if num % 2 == 0:\n            evenCount += 1\n            result += evenCount\n        else:\n            evenCount, oddCount = oddCount, evenCount\n            oddCount += 1\n            result += oddCount\n\n    return result\n```\n    \n    In this algorithm, the number of subarrays with even product can be formed by keeping track of counts of even and odd products in the subarrays ending at the current index. `evenCount` and `oddCount` are used to store the number of subarrays ending at the current index with even and odd products, respectively.\n\nFor each number in the input array `nums`, we check if the current number is even or odd. If the current number is even, the number of even subarrays ending at the current index is incremented by 1 (`evenCount++`). The result is incremented by the value of `evenCount`.\n\nIf the current number is odd, we swap the values of `evenCount` and `oddCount` (as an even product multiplied by an odd number gives an odd product, and vice versa). The count of odd subarrays ending at the current index is incremented by 1 (`oddCount++`), and the result is incremented by the value of `oddCount`.\n\nWe do this for each number in the input array `nums` and return the final result.\n    ",
        "c++": "\n    ```cpp\nint numberOfEvenSubarrays(vector<int>& nums) {\n    int n = nums.size();\n    int evenCount = 0, oddCount = 0, result = 0;\n\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            evenCount++;\n            result += evenCount;\n        } else {\n            swap(evenCount, oddCount);\n            oddCount++;\n            result += oddCount;\n        }\n    }\n\n    return result;\n}\n```\n    \n    In this algorithm, the number of subarrays with even product can be formed by keeping track of counts of even and odd products in the subarrays ending at the current index. `evenCount` and `oddCount` are used to store the number of subarrays ending at the current index with even and odd products, respectively.\n\nFor each number in the input array `nums`, we check if the current number is even or odd. If the current number is even, the number of even subarrays ending at the current index is incremented by 1 (`evenCount++`). The result is incremented by the value of `evenCount`.\n\nIf the current number is odd, we swap the values of `evenCount` and `oddCount` (as an even product multiplied by an odd number gives an odd product, and vice versa). The count of odd subarrays ending at the current index is incremented by 1 (`oddCount++`), and the result is incremented by the value of `oddCount`.\n\nWe do this for each number in the input array `nums` and return the final result.\n    ",
        "js": "\n    ```javascript\nfunction numberOfEvenSubarrays(nums) {\n    let n = nums.length;\n    let evenCount = 0, oddCount = 0, result = 0;\n\n    for (let num of nums) {\n        if (num % 2 === 0) {\n            evenCount++;\n            result += evenCount;\n        } else {\n            [evenCount, oddCount] = [oddCount, evenCount];\n            oddCount++;\n            result += oddCount;\n        }\n    }\n\n    return result;\n}\n```\n    \n    In this algorithm, the number of subarrays with even product can be formed by keeping track of counts of even and odd products in the subarrays ending at the current index. `evenCount` and `oddCount` are used to store the number of subarrays ending at the current index with even and odd products, respectively.\n\nFor each number in the input array `nums`, we check if the current number is even or odd. If the current number is even, the number of even subarrays ending at the current index is incremented by 1 (`evenCount++`). The result is incremented by the value of `evenCount`.\n\nIf the current number is odd, we swap the values of `evenCount` and `oddCount` (as an even product multiplied by an odd number gives an odd product, and vice versa). The count of odd subarrays ending at the current index is incremented by 1 (`oddCount++`), and the result is incremented by the value of `oddCount`.\n\nWe do this for each number in the input array `nums` and return the final result.\n    "
    },
    {
        "id": 371,
        "title": "Bitwise OR of All Subsequence Sums",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _the value of the bitwise_ **OR** _of the sum of all possible **subsequences** in the array_.\n\nA **subsequence** is a sequence that can be derived from another sequence by removing zero or more elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,0,3\\]\n**Output:** 7\n**Explanation:** All possible subsequence sums that we can have are: 0, 1, 2, 3, 4, 5, 6.\nAnd we have 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** 0\n**Explanation:** 0 is the only possible subsequence sum we can have, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,1,0,3]",
                "output": "7"
            },
            {
                "input": "[0,0,0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int subsequenceORSum(int[] nums) {\n    int result = 0;\n    for (int num : nums) {\n        result |= num;\n    }\n    return result;\n}\n```\n    \n    For each integer in the array, we use the bitwise OR operation to accumulate the results, since it ensures that we don't lose any set bit while combining numbers. At the end, the result variable holds the bitwise OR sum of all subsequences in the array. This is an O(n) solution, as it iterates through the input array once.\n    ",
        "python": "\n    ```python\ndef subsequence_or_sum(nums):\n    result = 0\n    for num in nums:\n        result |= num\n    return result\n```\n    \n    For each integer in the array, we use the bitwise OR operation to accumulate the results, since it ensures that we don't lose any set bit while combining numbers. At the end, the result variable holds the bitwise OR sum of all subsequences in the array. This is an O(n) solution, as it iterates through the input array once.\n    ",
        "c++": "\n    ```cpp\nint subsequenceORSum(vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result |= num;\n    }\n    return result;\n}\n```\n    \n    For each integer in the array, we use the bitwise OR operation to accumulate the results, since it ensures that we don't lose any set bit while combining numbers. At the end, the result variable holds the bitwise OR sum of all subsequences in the array. This is an O(n) solution, as it iterates through the input array once.\n    ",
        "js": "\n    ```javascript\nfunction subsequenceORSum(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result |= num;\n    }\n    return result;\n}\n```\n    \n    For each integer in the array, we use the bitwise OR operation to accumulate the results, since it ensures that we don't lose any set bit while combining numbers. At the end, the result variable holds the bitwise OR sum of all subsequences in the array. This is an O(n) solution, as it iterates through the input array once.\n    "
    },
    {
        "id": 372,
        "title": "Check if There is a Path With Equal Number of 0's And 1's",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** `m x n` **binary** matrix `grid`. You can move from a cell `(row, col)` to any of the cells `(row + 1, col)` or `(row, col + 1)`.\n\nReturn `true` _if there is a path from_ `(0, 0)` _to_ `(m - 1, n - 1)` _that visits an **equal** number of_ `0`_'s and_ `1`_'s_. Otherwise return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[0,1,0,0\\],\\[1,0,1,0\\]\\]\n**Output:** true\n**Explanation:** The path colored in blue in the above diagram is a valid path because we have 3 cells with a value of 1 and 3 with a value of 0. Since there is a valid path, we return true.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,0\\],\\[0,0,1\\],\\[1,0,0\\]\\]\n**Output:** false\n**Explanation:** There is no path in this grid with an equal number of 0's and 1's."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 100`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[0,1,0,0],[0,1,0,0],[1,0,1,0]]",
                "output": "true"
            },
            {
                "input": "[[1,1,0],[0,0,1],[1,0,0]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isValidPath(int[][] grid, int row, int col, int zeros, int ones) {\n    if (row < 0 || col < 0 || row >= grid.length || col >= grid[0].length) {\n        return false;\n    }\n    if (grid[row][col] == 1) {\n        ones++;\n    } else {\n        zeros++;\n    }\n    if (row == grid.length - 1 && col == grid[0].length - 1) {\n        return zeros == ones;\n    }\n    return isValidPath(grid, row + 1, col, zeros, ones) || isValidPath(grid, row, col + 1, zeros, ones);\n}\n\npublic boolean equalPath(int[][] grid) {\n    return isValidPath(grid, 0, 0, 0, 0);\n}\n```\n\n    \n    The algorithm is based on a Depth First Search (DFS) approach, where the goal is to find a valid path by visiting each node in the grid exactly once. Starting at the top-left corner (0, 0), we recursively call `isValidPath` on the neighboring cells (row + 1, col) and (row, col + 1), and keep track of the number of zeros and ones visited so far. \n\nAt each recursive call of `isValidPath`, we first check if the current cell is in valid range. If it is not, we return false. We then increment the respective zeros or ones count based on the value of the current cell. If we reach the bottom-right corner (m - 1, n - 1), we check if the number of zeros and ones visited are equal, and return the result. \n\nThe algorithm continues to make recursive calls until either a valid path with equal zeros and ones is found, or all possible paths are exhausted. The final answer is returned as true or false accordingly.\n    ",
        "python": "\n    ```python\ndef isValidPath(grid, row, col, zeros, ones):\n    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\n        return False\n    if grid[row][col] == 1:\n        ones += 1\n    else:\n        zeros += 1\n    if row == len(grid) - 1 and col == len(grid[0]) - 1:\n        return zeros == ones\n    return (isValidPath(grid, row + 1, col, zeros, ones)\n            or isValidPath(grid, row, col + 1, zeros, ones))\n\ndef equalPath(grid):\n    return isValidPath(grid, 0, 0, 0, 0)\n```\n\n    \n    The algorithm is based on a Depth First Search (DFS) approach, where the goal is to find a valid path by visiting each node in the grid exactly once. Starting at the top-left corner (0, 0), we recursively call `isValidPath` on the neighboring cells (row + 1, col) and (row, col + 1), and keep track of the number of zeros and ones visited so far. \n\nAt each recursive call of `isValidPath`, we first check if the current cell is in valid range. If it is not, we return false. We then increment the respective zeros or ones count based on the value of the current cell. If we reach the bottom-right corner (m - 1, n - 1), we check if the number of zeros and ones visited are equal, and return the result. \n\nThe algorithm continues to make recursive calls until either a valid path with equal zeros and ones is found, or all possible paths are exhausted. The final answer is returned as true or false accordingly.\n    ",
        "c++": "\n    ```cpp\nbool isValidPath(vector<vector<int>>& grid, int row, int col, int zeros, int ones) {\n    if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size()) {\n        return false;\n    }\n    if (grid[row][col] == 1) {\n        ones++;\n    } else {\n        zeros++;\n    }\n    if (row == grid.size() - 1 && col == grid[0].size() - 1) {\n        return zeros == ones;\n    }\n    return isValidPath(grid, row + 1, col, zeros, ones) || isValidPath(grid, row, col + 1, zeros, ones);\n}\n\nbool equalPath(vector<vector<int>>& grid) {\n    return isValidPath(grid, 0, 0, 0, 0);\n}\n```\n\n    \n    The algorithm is based on a Depth First Search (DFS) approach, where the goal is to find a valid path by visiting each node in the grid exactly once. Starting at the top-left corner (0, 0), we recursively call `isValidPath` on the neighboring cells (row + 1, col) and (row, col + 1), and keep track of the number of zeros and ones visited so far. \n\nAt each recursive call of `isValidPath`, we first check if the current cell is in valid range. If it is not, we return false. We then increment the respective zeros or ones count based on the value of the current cell. If we reach the bottom-right corner (m - 1, n - 1), we check if the number of zeros and ones visited are equal, and return the result. \n\nThe algorithm continues to make recursive calls until either a valid path with equal zeros and ones is found, or all possible paths are exhausted. The final answer is returned as true or false accordingly.\n    ",
        "js": "\n    ```javascript\nfunction isValidPath(grid, row, col, zeros, ones) {\n    if (row < 0 || col < 0 || row >= grid.length || col >= grid[0].length) {\n        return false;\n    }\n    if (grid[row][col] === 1) {\n        ones++;\n    } else {\n        zeros++;\n    }\n    if (row === grid.length - 1 && col === grid[0].length - 1) {\n        return zeros === ones;\n    }\n    return isValidPath(grid, row + 1, col, zeros, ones) || isValidPath(grid, row, col + 1, zeros, ones);\n}\n\nfunction equalPath(grid) {\n    return isValidPath(grid, 0, 0, 0, 0);\n}\n```\n\n    \n    The algorithm is based on a Depth First Search (DFS) approach, where the goal is to find a valid path by visiting each node in the grid exactly once. Starting at the top-left corner (0, 0), we recursively call `isValidPath` on the neighboring cells (row + 1, col) and (row, col + 1), and keep track of the number of zeros and ones visited so far. \n\nAt each recursive call of `isValidPath`, we first check if the current cell is in valid range. If it is not, we return false. We then increment the respective zeros or ones count based on the value of the current cell. If we reach the bottom-right corner (m - 1, n - 1), we check if the number of zeros and ones visited are equal, and return the result. \n\nThe algorithm continues to make recursive calls until either a valid path with equal zeros and ones is found, or all possible paths are exhausted. The final answer is returned as true or false accordingly.\n    "
    },
    {
        "id": 373,
        "title": "Count the Number of K-Big Indices",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` and a positive integer `k`.\n\nWe call an index `i` **k-big** if the following conditions are satisfied:\n\n*   There exist at least `k` different indices `idx1` such that `idx1 < i` and `nums[idx1] < nums[i]`.\n*   There exist at least `k` different indices `idx2` such that `idx2 > i` and `nums[idx2] < nums[i]`.\n\nReturn _the number of k-big indices_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,6,5,2,3\\], k = 2\n**Output:** 2\n**Explanation:** There are only two 2-big indices in nums:\n- i = 2 --> There are two valid idx1: 0 and 1. There are three valid idx2: 2, 3, and 4.\n- i = 3 --> There are two valid idx1: 0 and 1. There are two valid idx2: 3 and 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\], k = 3\n**Output:** 0\n**Explanation:** There are no 3-big indices in nums."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i], k <= nums.length`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,3,6,5,2,3],2",
                "output": "2"
            },
            {
                "input": "[1,1,1],3",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int kBigIndices(int[] nums, int k) {\n    int n = nums.length;\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1])\n            left[i] = left[i - 1] + 1;\n        \n        int j = n - 1 - i;\n        if (nums[j] < nums[j + 1])\n            right[j] = right[j + 1] + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (left[i] >= k && right[i] >= k)\n            count++;\n\n    return count;\n}\n```\n    \n    The algorithm uses two extra arrays, `left` and `right`, to store the number of smaller elements from left and right sides, respectively. Iterate through the `nums` array and fill the `left` and `right` arrays according to the conditions.\n\nThen, iterate the `left` and `right` arrays simultaneously, and for each index `i`, check if both `left[i]` and `right[i]` are greater than or equal to `k`. If both conditions are satisfied, increment the `count`. Finally, return the `count`.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n    ",
        "python": "\n    ```python\ndef kBigIndices(nums, k):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            left[i] = left[i - 1] + 1\n\n        j = n - i - 1\n        if nums[j] < nums[j + 1]:\n            right[j] = right[j + 1] + 1\n\n    return sum(1 for i in range(n) if left[i] >= k and right[i] >= k)\n```\n    \n    The algorithm uses two extra arrays, `left` and `right`, to store the number of smaller elements from left and right sides, respectively. Iterate through the `nums` array and fill the `left` and `right` arrays according to the conditions.\n\nThen, iterate the `left` and `right` arrays simultaneously, and for each index `i`, check if both `left[i]` and `right[i]` are greater than or equal to `k`. If both conditions are satisfied, increment the `count`. Finally, return the `count`.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n    ",
        "c++": "\n    ```cpp\nint kBigIndices(vector<int>& nums, int k) {\n    int n = nums.size();\n    vector<int> left(n, 0), right(n, 0);\n\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i - 1])\n            left[i] = left[i - 1] + 1;\n        \n        int j = n - i - 1;\n        if (nums[j] < nums[j + 1])\n            right[j] = right[j + 1] + 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; ++i)\n        if (left[i] >= k && right[i] >= k)\n            count++;\n\n    return count;\n}\n```\n    \n    The algorithm uses two extra arrays, `left` and `right`, to store the number of smaller elements from left and right sides, respectively. Iterate through the `nums` array and fill the `left` and `right` arrays according to the conditions.\n\nThen, iterate the `left` and `right` arrays simultaneously, and for each index `i`, check if both `left[i]` and `right[i]` are greater than or equal to `k`. If both conditions are satisfied, increment the `count`. Finally, return the `count`.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n    ",
        "js": "\n    ```javascript\nfunction kBigIndices(nums, k) {\n    const n = nums.length;\n    const left = Array(n).fill(0);\n    const right = Array(n).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1])\n            left[i] = left[i - 1] + 1;\n        \n        let j = n - 1 - i;\n        if (nums[j] < nums[j + 1])\n            right[j] = right[j + 1] + 1;\n    }\n\n    let count = 0;\n    for (let i = 0; i < n; i++)\n        if (left[i] >= k && right[i] >= k)\n            count++;\n\n    return count;\n}\n```\n    \n    The algorithm uses two extra arrays, `left` and `right`, to store the number of smaller elements from left and right sides, respectively. Iterate through the `nums` array and fill the `left` and `right` arrays according to the conditions.\n\nThen, iterate the `left` and `right` arrays simultaneously, and for each index `i`, check if both `left[i]` and `right[i]` are greater than or equal to `k`. If both conditions are satisfied, increment the `count`. Finally, return the `count`.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n    "
    },
    {
        "id": 374,
        "title": "Maximum Frequency Score of a Subarray",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and a **positive** integer `k`.\n\nThe **frequency score** of an array is the sum of the **distinct** values in the array raised to the power of their **frequencies**, taking the sum **modulo** `109 + 7`.\n\n*   For example, the frequency score of the array `[5,4,5,7,4,4]` is `(43 + 52 + 71) modulo (109 + 7) = 96`.\n\nReturn _the **maximum** frequency score of a **subarray** of size_ `k` _in_ `nums`. You should maximize the value under the modulo and not the actual value.\n\nA **subarray** is a contiguous part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,1,2,1,2\\], k = 3\n**Output:** 5\n**Explanation:** The subarray \\[2,1,2\\] has a frequency score equal to 5. It can be shown that it is the maximum frequency score we can have.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1,1,1\\], k = 4\n**Output:** 1\n**Explanation:** All the subarrays of length 4 have a frequency score equal to 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,1,1,2,1,2],3",
                "output": "5"
            },
            {
                "input": "[1,1,1,1,1,1],4",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int maxFrequencyScore(int[] nums, int k) {\n    int n = nums.length;\n    int right = 0, count = 0, max_score = 0;\n    long score = 0;\n    HashMap<Integer, Integer> freqMap = new HashMap<Integer, Integer>();\n\n    for (int left = 0; left < n; ++left) {\n        while (right < n && count < k) {\n            score = (score + (long)nums[right] * freqMap.getOrDefault(nums[right], 0)) % 1000000007;\n            freqMap.put(nums[right], freqMap.getOrDefault(nums[right], 0) + 1);\n            count++;\n            right++;\n        }\n\n        max_score = Math.max(max_score, (int)score);\n\n        if (count == k) {\n            score -= nums[left] * (freqMap.get(nums[left]) - 1);\n            freqMap.put(nums[left], freqMap.get(nums[left]) - 1);\n            count--;\n        }\n    }\n\n    return max_score;\n}\n```\n    \n    1. Initialize variables `right`, `count`, `max_score`, and `score`.\n2. Use a hash map `freq_map` to store the frequency of each number in the subarray.\n3. Use a sliding window of size `k` to traverse through the array:\n   a. Move the right pointer and increment the count and update score.\n   b. When the count becomes equal to `k`:\n       - Calculate the score and compare with the current max score. If the score is greater, update the max score.\n       - Move the left pointer and decrement the count.\n4. Return `max_score`.\n\nThe time complexity is O(n) and the space complexity is also O(n), where n is the length of the nums array.\n    ",
        "python": "\n    ```python\ndef maxFrequencyScore(nums, k):\n    n = len(nums)\n    right = 0\n    count = 0\n    max_score = 0\n    score = 0\n    freq_map = {}\n\n    for left in range(n):\n        while right < n and count < k:\n            score = (score + nums[right] * freq_map.get(nums[right], 0)) % 1000000007\n            freq_map[nums[right]] = freq_map.get(nums[right], 0) + 1\n            count += 1\n            right += 1\n\n        max_score = max(max_score, score)\n\n        if count == k:\n            score -= nums[left] * (freq_map[nums[left]] - 1)\n            freq_map[nums[left]] -= 1\n            count -= 1\n\n    return max_score\n```\n    \n    1. Initialize variables `right`, `count`, `max_score`, and `score`.\n2. Use a hash map `freq_map` to store the frequency of each number in the subarray.\n3. Use a sliding window of size `k` to traverse through the array:\n   a. Move the right pointer and increment the count and update score.\n   b. When the count becomes equal to `k`:\n       - Calculate the score and compare with the current max score. If the score is greater, update the max score.\n       - Move the left pointer and decrement the count.\n4. Return `max_score`.\n\nThe time complexity is O(n) and the space complexity is also O(n), where n is the length of the nums array.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint maxFrequencyScore(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    int right = 0, count = 0, max_score = 0;\n    long long score = 0;\n    std::unordered_map<int, int> freqMap;\n\n    for (int left = 0; left < n; ++left) {\n        while (right < n && count < k) {\n            score = (score + (long long)nums[right] * freqMap[nums[right]]) % 1000000007;\n            freqMap[nums[right]]++;\n            count++;\n            right++;\n        }\n\n        max_score = std::max(max_score, (int)score);\n\n        if (count == k) {\n            score -= nums[left] * (freqMap[nums[left]] - 1);\n            freqMap[nums[left]]--;\n            count--;\n        }\n    }\n\n    return max_score;\n}\n```\n    \n    1. Initialize variables `right`, `count`, `max_score`, and `score`.\n2. Use a hash map `freq_map` to store the frequency of each number in the subarray.\n3. Use a sliding window of size `k` to traverse through the array:\n   a. Move the right pointer and increment the count and update score.\n   b. When the count becomes equal to `k`:\n       - Calculate the score and compare with the current max score. If the score is greater, update the max score.\n       - Move the left pointer and decrement the count.\n4. Return `max_score`.\n\nThe time complexity is O(n) and the space complexity is also O(n), where n is the length of the nums array.\n    ",
        "js": "\n    ```javascript\nfunction maxFrequencyScore(nums, k) {\n    const n = nums.length;\n    let right = 0, count = 0, max_score = 0;\n    let score = BigInt(0);\n    const freqMap = new Map();\n\n    for (let left = 0; left < n; ++left) {\n        while (right < n && count < k) {\n            score = (score + BigInt(nums[right]) * BigInt(freqMap.get(nums[right]) || 0)) % BigInt(1000000007);\n            freqMap.set(nums[right], (freqMap.get(nums[right]) || 0) + 1);\n            count++;\n            right++;\n        }\n\n        max_score = Math.max(max_score, Number(score));\n\n        if (count === k) {\n            score -= BigInt(nums[left]) * BigInt(freqMap.get(nums[left]) - 1);\n            freqMap.set(nums[left], freqMap.get(nums[left]) - 1);\n            count--;\n        }\n    }\n\n    return max_score;\n}\n```\n    \n    1. Initialize variables `right`, `count`, `max_score`, and `score`.\n2. Use a hash map `freq_map` to store the frequency of each number in the subarray.\n3. Use a sliding window of size `k` to traverse through the array:\n   a. Move the right pointer and increment the count and update score.\n   b. When the count becomes equal to `k`:\n       - Calculate the score and compare with the current max score. If the score is greater, update the max score.\n       - Move the left pointer and decrement the count.\n4. Return `max_score`.\n\nThe time complexity is O(n) and the space complexity is also O(n), where n is the length of the nums array.\n    "
    },
    {
        "id": 375,
        "title": "Number of Good Binary Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given four integers `minLength`, `maxLength`, `oneGroup` and `zeroGroup`.\n\nA binary string is **good** if it satisfies the following conditions:\n\n*   The length of the string is in the range `[minLength, maxLength]`.\n*   The size of each block of consecutive `1`'s is a multiple of `oneGroup`.\n    *   For example in a binary string `00110111100` sizes of each block of consecutive ones are `[2,4]`.\n*   The size of each block of consecutive `0`'s is a multiple of `zeroGroup`.\n    *   For example, in a binary string `00110111100` sizes of each block of consecutive ones are `[2,1,2]`.\n\nReturn _the number of **good** binary strings_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Note** that `0` is considered a multiple of all the numbers.",
            "examples": [
                "**Example 1:**\n\n**Input:** minLength = 2, maxLength = 3, oneGroup = 1, zeroGroup = 2\n**Output:** 5\n**Explanation:** There are 5 good binary strings in this example:  \"00 \",  \"11 \",  \"001 \",  \"100 \", and  \"111 \".\nIt can be proven that there are only 5 good strings satisfying all conditions.\n\n",
                "**Example 2:**\n\n**Input:** minLength = 4, maxLength = 4, oneGroup = 4, zeroGroup = 3\n**Output:** 1\n**Explanation:** There is only 1 good binary string in this example:  \"1111 \".\nIt can be proven that there is only 1 good string satisfying all conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= minLength <= maxLength <= 105`\n*   `1 <= oneGroup, zeroGroup <= maxLength`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "2,3,1,2",
                "output": "5"
            },
            {
                "input": "4,4,4,3",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int countGoodStrings(int minLength, int maxLength, int oneGroup, int zeroGroup) {\n    int mod = 1000000007;\n    int maxCount = maxLength / oneGroup + maxLength / zeroGroup;\n\n    long[] dp = new long[maxCount + 1];\n    dp[0] = 1;\n    \n    for (int i = 1; i <= maxCount; i++)\n        dp[i] = (dp[i - 1] * (i % oneGroup == 0 || i % zeroGroup == 0 ? 1 : 0)) % mod;\n\n    long ans = 0;\n    for (int i = 0; i <= maxCount; i++) {\n        ans = (ans + dp[minLength / oneGroup + minLength / zeroGroup - i]\n               - ((minLength - 1) / oneGroup + (minLength - 1) / zeroGroup - i < 0 ? 0\n               : dp[(minLength - 1) / oneGroup + (minLength - 1) / zeroGroup - i])) % mod;\n    }\n\n    return (int) ans;\n}\n```\n    \n    We first find the total number of digits that our maxLength will have.\nAfter that, we use dynamic programming to count the number of ways to populate each group (1s and 0s).\nWe loop through from minLength to maxLength and then through the elements count of each group, and sum up the number of ways to arrange the groups in such a way that they form a valid binary string.\nWe accumulate that sum and return it as the answer.\n    ",
        "python": "\n    ```python\ndef countGoodStrings(minLength, maxLength, oneGroup, zeroGroup):\n    mod = 1000000007\n    maxCount = maxLength // oneGroup + maxLength // zeroGroup\n\n    dp = [0] * (maxCount + 1)\n    dp[0] = 1\n\n    for i in range(1, maxCount + 1):\n        dp[i] = dp[i - 1] * (1 if i % oneGroup == 0 or i % zeroGroup == 0 else 0) % mod\n\n    ans = 0\n    for i in range(maxCount + 1):\n        ans = (ans + dp[minLength // oneGroup + minLength // zeroGroup - i]\n               - (0 if minLength - 1 // oneGroup + minLength - 1 // zeroGroup - i < 0 else\n                  dp[(minLength - 1) // oneGroup + (minLength - 1) // zeroGroup - i])) % mod\n\n    return ans\n```\n    \n    We first find the total number of digits that our maxLength will have.\nAfter that, we use dynamic programming to count the number of ways to populate each group (1s and 0s).\nWe loop through from minLength to maxLength and then through the elements count of each group, and sum up the number of ways to arrange the groups in such a way that they form a valid binary string.\nWe accumulate that sum and return it as the answer.\n    ",
        "c++": "\n    ```cpp\nint countGoodStrings(int minLength, int maxLength, int oneGroup, int zeroGroup, int mod = 1000000007) {\n    int maxCount = maxLength / oneGroup + maxLength / zeroGroup;\n\n    vector<long long> dp(maxCount + 1);\n    dp[0] = 1;\n    \n    for (int i = 1; i <= maxCount; i++)\n        dp[i] = (dp[i - 1] * (i % oneGroup == 0 || i % zeroGroup == 0)) % mod;\n\n    long long ans = 0;\n    for (int i = 0; i <= maxCount; i++) {\n        ans = (ans + dp[minLength / oneGroup + minLength / zeroGroup - i]\n               - (minLength - 1) / oneGroup - (minLength - 1) / zeroGroup + i < 0 ? 0\n               : dp[(minLength - 1) / oneGroup + (minLength - 1) / zeroGroup - i]) % mod;\n    }\n\n    return ans;\n}\n```\n    \n    We first find the total number of digits that our maxLength will have.\nAfter that, we use dynamic programming to count the number of ways to populate each group (1s and 0s).\nWe loop through from minLength to maxLength and then through the elements count of each group, and sum up the number of ways to arrange the groups in such a way that they form a valid binary string.\nWe accumulate that sum and return it as the answer.\n    ",
        "js": "\n    ```javascript\nfunction countGoodStrings(minLength, maxLength, oneGroup, zeroGroup) {\n    const mod = 1000000007;\n    const maxCount = Math.floor(maxLength / oneGroup) + Math.floor(maxLength / zeroGroup);\n\n    let dp = new Array(maxCount + 1).fill(0);\n    dp[0] = 1;\n\n    for (let i = 1; i <= maxCount; i++) {\n        dp[i] = (dp[i - 1] * (i % oneGroup === 0 || i % zeroGroup === 0 ? 1 : 0)) % mod;\n    }\n\n    let ans = 0;\n    for (let i = 0; i <= maxCount; i++) {\n        ans = (ans + dp[Math.floor(minLength / oneGroup) + Math.floor(minLength / zeroGroup) - i]\n               - (Math.floor((minLength - 1) / oneGroup) + Math.floor((minLength - 1) / zeroGroup) - i < 0 ? 0\n               : dp[Math.floor((minLength - 1) / oneGroup) + Math.floor((minLength - 1) / zeroGroup) - i])) % mod;\n    }\n\n    return ans;\n}\n```\n\n    \n    We first find the total number of digits that our maxLength will have.\nAfter that, we use dynamic programming to count the number of ways to populate each group (1s and 0s).\nWe loop through from minLength to maxLength and then through the elements count of each group, and sum up the number of ways to arrange the groups in such a way that they form a valid binary string.\nWe accumulate that sum and return it as the answer.\n    "
    },
    {
        "id": 376,
        "title": "Count the Number of Good Subsequences",
        "difficulty": "Medium",
        "content": {
            "problem": "A **subsequence** of a string is good if it is not empty and the frequency of each one of its characters is the same.\n\nGiven a string `s`, return _the number of good subsequences of_ `s`. Since the answer may be too large, return it modulo `109 + 7`.\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aabb \"\n**Output:** 11\n**Explanation:** The total number of subsequences is `24.` There are five subsequences which are not good:  \"**aab**b \",  \"a**abb** \",  \"**a**a**bb** \",  \"**aa**b**b** \", and the empty subsequence. Hence, the number of good subsequences is `24-5 = 11`.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"leet \"\n**Output:** 12\n**Explanation:** There are four subsequences which are not good:  \"**l_ee_**t \",  \"l**eet** \",  \"**leet** \", and the empty subsequence. Hence, the number of good subsequences is `24-4 = 12`.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abcd \"\n**Output:** 15\n**Explanation:** All of the non-empty subsequences are good subsequences. Hence, the number of good subsequences is `24-1 = 15`."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "\"aabb\"",
                "output": "11"
            },
            {
                "input": "\"leet\"",
                "output": "12"
            },
            {
                "input": "\"abcd\"",
                "output": "15"
            }
        ],
        "java": "\n    ```java\npublic int numberOfGoodSubsequences(String s) {\n    int[] count = new int[26];\n    long ans = 0;\n    final int MOD = 1000000007;\n    \n    for (char c : s.toCharArray()) {\n        count[c - 'a']++;\n    }\n    \n    for (int val : count) {\n        ans = (ans + (1L << val) - 1) % MOD;\n    }\n    \n    return (int)ans;\n}\n```\n\n    \n    To solve this problem, we first count the frequency of each character in the string. Then we iterate through the resulting counts and compute the number of possible combinations for each character count by raising 2 to the power of the count (this represents the possible combinations including or excluding that character in the subsequence). Since counts with value zero don't add any new subsequences, we subtract 1 (which is the count of empty subsequences) from the result of that operation. The sum of all these numbers modulo 10^9+7 is the final answer, as this takes into account the good subsequences from each character.\n    ",
        "python": "\n    ```python\ndef numberOfGoodSubsequences(s: str) -> int:\n    count = [0] * 26\n    ans = 0\n    MOD = 1000000007\n    \n    for c in s:\n        count[ord(c) - ord('a')] += 1\n        \n    for val in count:\n        ans = (ans + (1 << val) - 1) % MOD\n        \n    return ans\n```\n\n    \n    To solve this problem, we first count the frequency of each character in the string. Then we iterate through the resulting counts and compute the number of possible combinations for each character count by raising 2 to the power of the count (this represents the possible combinations including or excluding that character in the subsequence). Since counts with value zero don't add any new subsequences, we subtract 1 (which is the count of empty subsequences) from the result of that operation. The sum of all these numbers modulo 10^9+7 is the final answer, as this takes into account the good subsequences from each character.\n    ",
        "c++": "\n    ```cpp\nint numberOfGoodSubsequences(string s) {\n    vector<int> count(26, 0);\n    long ans = 0;\n    const int MOD = 1000000007;\n    \n    for (char c : s) {\n        count[c - 'a']++;\n    }\n    \n    for (int val : count) {\n        ans = (ans + (1L << val) - 1) % MOD;\n    }\n    \n    return ans;\n}\n```\n\n    \n    To solve this problem, we first count the frequency of each character in the string. Then we iterate through the resulting counts and compute the number of possible combinations for each character count by raising 2 to the power of the count (this represents the possible combinations including or excluding that character in the subsequence). Since counts with value zero don't add any new subsequences, we subtract 1 (which is the count of empty subsequences) from the result of that operation. The sum of all these numbers modulo 10^9+7 is the final answer, as this takes into account the good subsequences from each character.\n    ",
        "js": "\n    ```javascript\nfunction numberOfGoodSubsequences(s) {\n    let count = new Array(26).fill(0);\n    let ans = 0;\n    const MOD = 1000000007;\n    \n    for (let c of s) {\n        count[c.codePointAt(0) - 'a'.codePointAt(0)]++;\n    }\n    \n    for (let val of count) {\n        ans = (ans + (BigInt(1) << BigInt(val)) - BigInt(1)) % BigInt(MOD);\n    }\n    \n    return Number(ans);\n}\n```\n\n    \n    To solve this problem, we first count the frequency of each character in the string. Then we iterate through the resulting counts and compute the number of possible combinations for each character count by raising 2 to the power of the count (this represents the possible combinations including or excluding that character in the subsequence). Since counts with value zero don't add any new subsequences, we subtract 1 (which is the count of empty subsequences) from the result of that operation. The sum of all these numbers modulo 10^9+7 is the final answer, as this takes into account the good subsequences from each character.\n    "
    },
    {
        "id": 377,
        "title": "Maximum Price to Fill a Bag",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a 2D integer array `items` where `items[i] = [pricei, weighti]` denotes the price and weight of the `ith` item, respectively.\n\nYou are also given a **positive** integer `capacity`.\n\nEach item can be divided into two items with ratios `part1` and `part2`, where `part1 + part2 == 1`.\n\n*   The weight of the first item is `weighti * part1` and the price of the first item is `pricei * part1`.\n*   Similarly, the weight of the second item is `weighti * part2` and the price of the second item is `pricei * part2`.\n\nReturn _**the maximum total price** to fill a bag of capacity_ `capacity` _with given items_. If it is impossible to fill a bag return `-1`. Answers within `10-5` of the **actual answer** will be considered accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** items = \\[\\[50,1\\],\\[10,8\\]\\], capacity = 5\n**Output:** 55.00000\n**Explanation:** \nWe divide the 2nd item into two parts with part1 = 0.5 and part2 = 0.5.\nThe price and weight of the 1st item are 5, 4. And similarly, the price and the weight of the 2nd item are 5, 4.\nThe array items after operation becomes \\[\\[50,1\\],\\[5,4\\],\\[5,4\\]\\]. \nTo fill a bag with capacity 5 we take the 1st element with a price of 50 and the 2nd element with a price of 5.\nIt can be proved that 55.0 is the maximum total price that we can achieve.\n\n",
                "**Example 2:**\n\n**Input:** items = \\[\\[100,30\\]\\], capacity = 50\n**Output:** -1.00000\n**Explanation:** It is impossible to fill a bag with the given item."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= items.length <= 105`\n*   `items[i].length == 2`\n*   `1 <= pricei, weighti <= 104`\n*   `1 <= capacity <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[[50,1],[10,8]],5",
                "output": "55.00000"
            },
            {
                "input": "[[100,30]],50",
                "output": "-1.00000"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic double maxValue(int[][] items, int capacity) {\n    Arrays.sort(items, (a, b) -> Double.compare((double) b[0] / b[1], (double) a[0] / a[1]));\n\n    double maxTotalPrice = 0;\n    for (int[] item : items) {\n        if (capacity >= item[1]) {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else {\n            maxTotalPrice += (double) item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}\n```\n\n    \n    The solution starts by sorting the items in descending order based on their price-to-weight ratio. This effectively gives priority to items with a higher \"value density\". Then, it initializes `maxTotalPrice` to 0, representing the eventual result.\n\nThe algorithm iterates through the sorted items, and for each item, it checks if its weight is smaller than the remaining capacity of the bag. If so, it adds the whole item to the bag, and updates the bag capacity accordingly. In case the item's weight is larger than the remaining capacity, the algorithm divides the item into the largest possible part that fits the bag.\n\nFor each included item or item part, the algorithm updates the total price.\n\nOnce the algorithm has processed all items, it returns the `maxTotalPrice`.\n    ",
        "python": "\n    ```python\ndef maxValue(items, capacity):\n    items.sort(key=lambda x: x[0] / x[1], reverse=True)\n\n    maxTotalPrice = 0\n    for item in items:\n        if capacity >= item[1]:\n            capacity -= item[1]\n            maxTotalPrice += item[0]\n        else:\n            maxTotalPrice += item[0] * capacity / item[1]\n            break\n\n    return maxTotalPrice\n```\n\n    \n    The solution starts by sorting the items in descending order based on their price-to-weight ratio. This effectively gives priority to items with a higher \"value density\". Then, it initializes `maxTotalPrice` to 0, representing the eventual result.\n\nThe algorithm iterates through the sorted items, and for each item, it checks if its weight is smaller than the remaining capacity of the bag. If so, it adds the whole item to the bag, and updates the bag capacity accordingly. In case the item's weight is larger than the remaining capacity, the algorithm divides the item into the largest possible part that fits the bag.\n\nFor each included item or item part, the algorithm updates the total price.\n\nOnce the algorithm has processed all items, it returns the `maxTotalPrice`.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ndouble maxValue(vector<vector<int>>& items, int capacity) {\n    sort(items.begin(), items.end(), [](const vector<int>& a, const vector<int>& b) {\n        return (double)a[0] / a[1] > (double)b[0] / b[1];\n    });\n\n    double maxTotalPrice = 0;\n    for (const auto& item : items) {\n        if (capacity >= item[1]) {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else {\n            maxTotalPrice += (double)item[0] * capacity / item[1];\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}\n```\n\n    \n    The solution starts by sorting the items in descending order based on their price-to-weight ratio. This effectively gives priority to items with a higher \"value density\". Then, it initializes `maxTotalPrice` to 0, representing the eventual result.\n\nThe algorithm iterates through the sorted items, and for each item, it checks if its weight is smaller than the remaining capacity of the bag. If so, it adds the whole item to the bag, and updates the bag capacity accordingly. In case the item's weight is larger than the remaining capacity, the algorithm divides the item into the largest possible part that fits the bag.\n\nFor each included item or item part, the algorithm updates the total price.\n\nOnce the algorithm has processed all items, it returns the `maxTotalPrice`.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(items, capacity) {\n    items.sort((a, b) => (b[0] / b[1]) - (a[0] / a[1]));\n\n    let maxTotalPrice = 0;\n    for (const item of items) {\n        if (capacity >= item[1]) {\n            capacity -= item[1];\n            maxTotalPrice += item[0];\n        }\n        else {\n            maxTotalPrice += (item[0] * capacity / item[1]);\n            break;\n        }\n    }\n\n    return maxTotalPrice;\n}\n```\n\n    \n    The solution starts by sorting the items in descending order based on their price-to-weight ratio. This effectively gives priority to items with a higher \"value density\". Then, it initializes `maxTotalPrice` to 0, representing the eventual result.\n\nThe algorithm iterates through the sorted items, and for each item, it checks if its weight is smaller than the remaining capacity of the bag. If so, it adds the whole item to the bag, and updates the bag capacity accordingly. In case the item's weight is larger than the remaining capacity, the algorithm divides the item into the largest possible part that fits the bag.\n\nFor each included item or item part, the algorithm updates the total price.\n\nOnce the algorithm has processed all items, it returns the `maxTotalPrice`.\n    "
    },
    {
        "id": 378,
        "title": "Maximum Number of Integers to Choose From a Range II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `banned` and two integers `n` and `maxSum`. You are choosing some number of integers following the below rules:\n\n*   The chosen integers have to be in the range `[1, n]`.\n*   Each integer can be chosen **at most once**.\n*   The chosen integers should not be in the array `banned`.\n*   The sum of the chosen integers should not exceed `maxSum`.\n\nReturn _the **maximum** number of integers you can choose following the mentioned rules_.",
            "examples": [
                "**Example 1:**\n\n**Input:** banned = \\[1,4,6\\], n = 6, maxSum = 4\n**Output:** 1\n**Explanation:** You can choose the integer 3.\n3 is in the range \\[1, 6\\], and do not appear in banned. The sum of the chosen integers is 3, which does not exceed maxSum.\n\n",
                "**Example 2:**\n\n**Input:** banned = \\[4,3,5,6\\], n = 7, maxSum = 18\n**Output:** 3\n**Explanation:** You can choose the integers 1, 2, and 7.\nAll these integers are in the range \\[1, 7\\], all do not appear in banned, and their sum is 18, which does not exceed maxSum."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= banned.length <= 105`\n*   `1 <= banned[i] <= n <= 109`\n*   `1 <= maxSum <= 1015`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[1,4,6],6,4",
                "output": "1"
            },
            {
                "input": "[4,3,5,6],7,18",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nint maxChosenIntegers(int[] banned, int n, long maxSum) {\n    Set<Integer> bannedSet = new HashSet<>();\n    for (int num : banned) {\n        bannedSet.add(num);\n    }\n    int chosenIntegers = 0;\n    long chosenSum = 0;\n\n    for (int i = n; i > 0 && chosenSum < maxSum; i--) {\n        if (!bannedSet.contains(i)) {\n            if (chosenSum + i <= maxSum) {\n                chosenSum += i;\n                chosenIntegers++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return chosenIntegers;\n}\n```\n    \n    1. Create a set from the input banned list to have O(1) look-up time for banned numbers.\n2. Initialize two variables `chosen_integers` and `chosen_sum` to keep track of the count of chosen integers and their sum, respectively.\n3. Iterate through the range [1, n] in reverse order:\n   - Check if the current number is not in the banned set and the current `chosen_sum` is less than `maxSum`.\n   - If the current number added to the `chosen_sum` does not exceed `maxSum`, add the current number to the `chosen_sum` and increment the `chosen_integers` count.\n   - If the current number added to the `chosen_sum` would exceed `maxSum`, we break the loop as adding any more numbers will exceed the `maxSum`.\n4. Return the `chosen_integers` count.\n    ",
        "python": "\n    ```python\ndef max_chosen_integers(banned, n, max_sum):\n    banned_set = set(banned)\n    chosen_integers = 0\n    chosen_sum = 0\n\n    for i in range(n, 0, -1):\n        if i not in banned_set and chosen_sum < max_sum:\n            if chosen_sum + i <= max_sum:\n                chosen_sum += i\n                chosen_integers += 1\n            else:\n                break\n\n    return chosen_integers\n```\n    \n    1. Create a set from the input banned list to have O(1) look-up time for banned numbers.\n2. Initialize two variables `chosen_integers` and `chosen_sum` to keep track of the count of chosen integers and their sum, respectively.\n3. Iterate through the range [1, n] in reverse order:\n   - Check if the current number is not in the banned set and the current `chosen_sum` is less than `maxSum`.\n   - If the current number added to the `chosen_sum` does not exceed `maxSum`, add the current number to the `chosen_sum` and increment the `chosen_integers` count.\n   - If the current number added to the `chosen_sum` would exceed `maxSum`, we break the loop as adding any more numbers will exceed the `maxSum`.\n4. Return the `chosen_integers` count.\n    ",
        "c++": "\n    ```cpp\nint maxChosenIntegers(vector<int>& banned, int n, long long maxSum) {\n    unordered_set<int> banned_set(banned.begin(), banned.end());\n    int chosen_integers = 0;\n    long long chosen_sum = 0;\n\n    for (int i = n; i > 0 && chosen_sum < maxSum; --i) {\n        if (banned_set.find(i) == banned_set.end()) {\n            if (chosen_sum + i <= maxSum) {\n                chosen_sum += i;\n                chosen_integers++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return chosen_integers;\n}\n```\n    \n    1. Create a set from the input banned list to have O(1) look-up time for banned numbers.\n2. Initialize two variables `chosen_integers` and `chosen_sum` to keep track of the count of chosen integers and their sum, respectively.\n3. Iterate through the range [1, n] in reverse order:\n   - Check if the current number is not in the banned set and the current `chosen_sum` is less than `maxSum`.\n   - If the current number added to the `chosen_sum` does not exceed `maxSum`, add the current number to the `chosen_sum` and increment the `chosen_integers` count.\n   - If the current number added to the `chosen_sum` would exceed `maxSum`, we break the loop as adding any more numbers will exceed the `maxSum`.\n4. Return the `chosen_integers` count.\n    ",
        "js": "\n    ```javascript\nfunction maxChosenIntegers(banned, n, maxSum) {\n    const bannedSet = new Set(banned);\n    let chosenIntegers = 0;\n    let chosenSum = 0;\n\n    for (let i = n; i > 0 && chosenSum < maxSum; i--) {\n        if (!bannedSet.has(i)) {\n            if (chosenSum + i <= maxSum) {\n                chosenSum += i;\n                chosenIntegers++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return chosenIntegers;\n}\n```\n    \n    1. Create a set from the input banned list to have O(1) look-up time for banned numbers.\n2. Initialize two variables `chosen_integers` and `chosen_sum` to keep track of the count of chosen integers and their sum, respectively.\n3. Iterate through the range [1, n] in reverse order:\n   - Check if the current number is not in the banned set and the current `chosen_sum` is less than `maxSum`.\n   - If the current number added to the `chosen_sum` does not exceed `maxSum`, add the current number to the `chosen_sum` and increment the `chosen_integers` count.\n   - If the current number added to the `chosen_sum` would exceed `maxSum`, we break the loop as adding any more numbers will exceed the `maxSum`.\n4. Return the `chosen_integers` count.\n    "
    },
    {
        "id": 379,
        "title": "Design a Todo List",
        "difficulty": "Medium",
        "content": {
            "problem": "Design a Todo List Where users can add **tasks**, mark them as **complete**, or get a list of pending tasks. Users can also add **tags** to tasks and can filter the tasks by certain tags.\n\nImplement the `TodoList` class:\n\n*   `TodoList()` Initializes the object.\n*   `int addTask(int userId, String taskDescription, int dueDate, List tags)` Adds a task for the user with the ID `userId` with a due date equal to `dueDate` and a list of tags attached to the task. The return value is the ID of the task. This ID starts at `1` and is **sequentially** increasing. That is, the first task's id should be `1`, the second task's id should be `2`, and so on.\n*   `List getAllTasks(int userId)` Returns a list of all the tasks not marked as complete for the user with ID `userId`, ordered by the due date. You should return an empty list if the user has no uncompleted tasks.\n*   `List getTasksForTag(int userId, String tag)` Returns a list of all the tasks that are not marked as complete for the user with the ID `userId` and have `tag` as one of their tags, ordered by their due date. Return an empty list if no such task exists.\n*   `void completeTask(int userId, int taskId)` Marks the task with the ID `taskId` as completed only if the task exists and the user with the ID `userId` has this task, and it is uncompleted.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"TodoList \",  \"addTask \",  \"addTask \",  \"getAllTasks \",  \"getAllTasks \",  \"addTask \",  \"getTasksForTag \",  \"completeTask \",  \"completeTask \",  \"getTasksForTag \",  \"getAllTasks \"\\]\n\\[\\[\\], \\[1,  \"Task1 \", 50, \\[\\]\\], \\[1,  \"Task2 \", 100, \\[ \"P1 \"\\]\\], \\[1\\], \\[5\\], \\[1,  \"Task3 \", 30, \\[ \"P1 \"\\]\\], \\[1,  \"P1 \"\\], \\[5, 1\\], \\[1, 2\\], \\[1,  \"P1 \"\\], \\[1\\]\\]\n**Output**\n\\[null, 1, 2, \\[ \"Task1 \",  \"Task2 \"\\], \\[\\], 3, \\[ \"Task3 \",  \"Task2 \"\\], null, null, \\[ \"Task3 \"\\], \\[ \"Task3 \",  \"Task1 \"\\]\\]\n\n**Explanation**\nTodoList todoList = new TodoList();\ntodoList.addTask(1,  \"Task1 \", 50, \\[\\]); // return 1. This adds a new task for the user with id 1.\ntodoList.addTask(1,  \"Task2 \", 100, \\[ \"P1 \"\\]); // return 2. This adds another task for the user with id 1.\ntodoList.getAllTasks(1); // return \\[ \"Task1 \",  \"Task2 \"\\]. User 1 has two uncompleted tasks so far.\ntodoList.getAllTasks(5); // return \\[\\]. User 5 does not have any tasks so far.\ntodoList.addTask(1,  \"Task3 \", 30, \\[ \"P1 \"\\]); // return 3. This adds another task for the user with id 1.\ntodoList.getTasksForTag(1,  \"P1 \"); // return \\[ \"Task3 \",  \"Task2 \"\\]. This returns the uncompleted tasks that have the tag  \"P1 \" for the user with id 1.\ntodoList.completeTask(5, 1); // This does nothing, since task 1 does not belong to user 5.\ntodoList.completeTask(1, 2); // This marks task 2 as completed.\ntodoList.getTasksForTag(1,  \"P1 \"); // return \\[ \"Task3 \"\\]. This returns the uncompleted tasks that have the tag  \"P1 \" for the user with id 1.\n                                  // Notice that we did not include  \"Task2 \" because it is completed now.\ntodoList.getAllTasks(1); // return \\[ \"Task3 \",  \"Task1 \"\\]. User 1 now has 2 uncompleted tasks."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= userId, taskId, dueDate <= 100`\n*   `0 <= tags.length <= 100`\n*   `1 <= taskDescription.length <= 50`\n*   `1 <= tags[i].length, tag.length <= 20`\n*   All `dueDate` values are unique.\n*   All the strings consist of lowercase and uppercase English letters and digits.\n*   At most `100` calls will be made for each method.",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "]\n],]],[1,\"Task2\",100,]],[1],[5],[1,\"Task3\",30,]],[1,\"P1\"],[5,1],[1,2],[1,\"P1\"],[1]]",
                "output": "**Output**\n[null,1,2,[\"Task1\",\"Task2\"],[],3,[\"Task3\",\"Task2\"],null,null,[\"Task3\"],[\"Task3\",\"Task1\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass TodoList {\n    private static class Task {\n        int id;\n        String description;\n        int dueDate;\n        List<String> tags;\n        boolean completed;\n\n        public Task(int id, String description, int dueDate, List<String> tags) {\n            this.id = id;\n            this.description = description;\n            this.dueDate = dueDate;\n            this.tags = tags;\n            this.completed = false;\n        }\n    }\n\n    private int taskId;\n    private Map<Integer, List<Task>> tasks;\n\n    public TodoList() {\n        taskId = 1;\n        tasks = new HashMap<>();\n    }\n\n    public int addTask(int userId, String taskDescription, int dueDate, List<String> tags) {\n        tasks.computeIfAbsent(userId, k -> new ArrayList<>());\n        tasks.get(userId).add(new Task(taskId, taskDescription, dueDate, tags));\n        return taskId++;\n    }\n\n    public List<String> getAllTasks(int userId){\n        List<String> res = new ArrayList<>();\n        List<Task> userTasks = tasks.getOrDefault(userId, new ArrayList<>());\n\n        Collections.sort(userTasks, Comparator.comparingInt(a -> a.dueDate));\n\n        for (Task task : userTasks) {\n            if (!task.completed) {\n                res.add(task.description);\n            }\n        }\n\n        return res;\n    }\n\n    public List<String> getTasksForTag(int userId, String tag){\n        List<String> res = new ArrayList<>();\n        List<Task> userTasks = tasks.getOrDefault(userId, new ArrayList<>());\n\n        Collections.sort(userTasks, Comparator.comparingInt(a -> a.dueDate));\n\n        for (Task task : userTasks) {\n            if (!task.completed && task.tags.contains(tag)) {\n                res.add(task.description);\n            }\n        }\n\n        return res;\n    }\n\n    public void completeTask(int userId, int taskId){\n        List<Task> userTasks = tasks.getOrDefault(userId, new ArrayList<>());\n        for (Task task : userTasks) {\n            if (task.id == taskId) {\n                task.completed = true;\n                break;\n            }\n        }\n    }\n}\n```\n    \n    We define a `Task` class that keeps the task information such as `id`, `description`, `dueDate`, `tags`, and its completion status (`completed` field). \n\nThe `TodoList` class contains a map, `tasks`, that stores the tasks of each user as a list. Then, we implement the methods `addTask`, `getAllTasks`, `getTasksForTag`, and `completeTask`, using the map and Task objects.\n\n1. `addTask()` creates a new Task object with the provided `taskDescription`, `dueDate`, and `tags`, and then adds the task to the corresponding user's task list. It increments the `taskId` by 1.\n2. `getAllTasks()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions to return.\n3. `getTasksForTag()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions that have the specified tag.\n4. `completeTask()` finds the task with the given task ID for the specified user and sets the `completed` field of the task to `true`.\n\nForEach function is implemented using the standard library functions (`std::sort()` for C++, `Collections.sort()` for Java, `sorted()` for Python, and `Array.prototype.sort()` for JavaScript) and loops/iterators as required by each language.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\nclass Task:\n    def __init__(self, id: int, description: str, due_date: int, tags: List[str]):\n        self.id = id\n        self.description = description\n        self.due_date = due_date\n        self.tags = tags\n        self.completed = False\n\nclass TodoList:\n\n    def __init__(self):\n        self.task_id = 1\n        self.tasks = {}\n\n    def addTask(self, userId: int, taskDescription: str, dueDate: int, tags: List[str]) -> int:\n        if userId not in self.tasks:\n            self.tasks[userId] = []\n        self.tasks[userId].append(Task(self.task_id, taskDescription, dueDate, tags))\n        self.task_id += 1\n        return self.task_id - 1\n\n    def getAllTasks(self, userId: int) -> List[str]:\n        if userId not in self.tasks:\n            return []\n        user_tasks = sorted(self.tasks[userId], key=lambda task: task.due_date)\n        res = [task.description for task in user_tasks if not task.completed]\n        return res\n\n    def getTasksForTag(self, userId: int, tag: str) -> List[str]:\n        if userId not in self.tasks:\n            return []\n        user_tasks = sorted(self.tasks[userId], key=lambda task: task.due_date)\n        res = [task.description for task in user_tasks if not task.completed and tag in task.tags]\n        return res\n\n    def completeTask(self, userId: int, taskId: int) -> None:\n        if userId not in self.tasks:\n            return\n        for task in self.tasks[userId]:\n            if task.id == taskId:\n                task.completed = True\n                break\n```\n    \n    We define a `Task` class that keeps the task information such as `id`, `description`, `dueDate`, `tags`, and its completion status (`completed` field). \n\nThe `TodoList` class contains a map, `tasks`, that stores the tasks of each user as a list. Then, we implement the methods `addTask`, `getAllTasks`, `getTasksForTag`, and `completeTask`, using the map and Task objects.\n\n1. `addTask()` creates a new Task object with the provided `taskDescription`, `dueDate`, and `tags`, and then adds the task to the corresponding user's task list. It increments the `taskId` by 1.\n2. `getAllTasks()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions to return.\n3. `getTasksForTag()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions that have the specified tag.\n4. `completeTask()` finds the task with the given task ID for the specified user and sets the `completed` field of the task to `true`.\n\nForEach function is implemented using the standard library functions (`std::sort()` for C++, `Collections.sort()` for Java, `sorted()` for Python, and `Array.prototype.sort()` for JavaScript) and loops/iterators as required by each language.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nclass TodoList {\npublic:\n    struct Task {\n        int id;\n        std::string description;\n        int dueDate;\n        std::vector<std::string> tags;\n        bool completed;\n\n        Task(int _id, const std::string& _desc, int _dueDate, const std::vector<std::string>& _tags)\n            : id(_id), description(_desc), dueDate(_dueDate), tags(_tags), completed(false) {}\n    };\n\n    TodoList() : taskId(1) {}\n\n    int addTask(int userId, std::string taskDescription, int dueDate, std::vector<std::string> tags) {\n        tasks[userId].emplace_back(taskId, taskDescription, dueDate, tags);\n        return taskId++;\n    }\n\n    std::vector<std::string> getAllTasks(int userId) {\n\n        std::vector<std::string> res;\n        std::vector<Task>& userTasks = tasks[userId];\n\n        std::sort(userTasks.begin(), userTasks.end(), [](const Task& a, const Task& b) {\n            return a.dueDate < b.dueDate;\n        });\n\n        for (const auto& task : userTasks) {\n            if (!task.completed) {\n                res.push_back(task.description);\n            }\n        }\n\n        return res;\n    }\n\n    std::vector<std::string> getTasksForTag(int userId, std::string tag) {\n        std::vector<std::string> res;\n        std::vector<Task>& userTasks = tasks[userId];\n\n        std::sort(userTasks.begin(), userTasks.end(), [](const Task& a, const Task& b) {\n            return a.dueDate < b.dueDate;\n        });\n\n        for (const auto& task : userTasks) {\n            if (!task.completed && std::find(task.tags.begin(), task.tags.end(), tag) != task.tags.end()) {\n                res.push_back(task.description);\n            }\n        }\n\n        return res;\n    }\n\n    void completeTask(int userId, int taskId) {\n        std::vector<Task>& userTasks = tasks[userId];\n        for (auto& task : userTasks) {\n            if (task.id == taskId) {\n                task.completed = true;\n                break;\n            }\n        }\n    }\n\nprivate:\n    int taskId;\n    std::map<int, std::vector<Task>> tasks;\n};\n```\n    \n    We define a `Task` class that keeps the task information such as `id`, `description`, `dueDate`, `tags`, and its completion status (`completed` field). \n\nThe `TodoList` class contains a map, `tasks`, that stores the tasks of each user as a list. Then, we implement the methods `addTask`, `getAllTasks`, `getTasksForTag`, and `completeTask`, using the map and Task objects.\n\n1. `addTask()` creates a new Task object with the provided `taskDescription`, `dueDate`, and `tags`, and then adds the task to the corresponding user's task list. It increments the `taskId` by 1.\n2. `getAllTasks()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions to return.\n3. `getTasksForTag()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions that have the specified tag.\n4. `completeTask()` finds the task with the given task ID for the specified user and sets the `completed` field of the task to `true`.\n\nForEach function is implemented using the standard library functions (`std::sort()` for C++, `Collections.sort()` for Java, `sorted()` for Python, and `Array.prototype.sort()` for JavaScript) and loops/iterators as required by each language.\n    ",
        "js": "\n    ```javascript\nclass Task {\n    constructor(id, description, dueDate, tags, completed) {\n        this.id = id;\n        this.description = description;\n        this.dueDate = dueDate;\n        this.tags = tags;\n        this.completed = completed;\n    }\n}\n\nclass TodoList {\n    constructor() {\n        this.taskId = 1;\n        this.tasks = {};\n    }\n\n    addTask(userId, taskDescription, dueDate, tags) {\n        if (!this.tasks[userId]) {\n            this.tasks[userId] = [];\n        }\n        const task = new Task(this.taskId, taskDescription, dueDate, tags, false);\n        this.tasks[userId].push(task);\n        this.taskId++;\n        return this.taskId - 1;\n    }\n\n    getAllTasks(userId) {\n        if (!this.tasks[userId]) {\n            return [];\n        }\n        const userTasks = this.tasks[userId].slice().sort((a, b) => a.dueDate - b.dueDate);\n        const res = userTasks.filter(task => !task.completed).map(task => task.description);\n        return res;\n    }\n\n    getTasksForTag(userId, tag) {\n        if (!this.tasks[userId]) {\n            return [];\n        }\n        const userTasks = this.tasks[userId].slice().sort((a, b) => a.dueDate - b.dueDate);\n        const res = userTasks.filter(task => !task.completed && task.tags.includes(tag)).map(task => task.description);\n        return res;\n    }\n\n    completeTask(userId, taskId) {\n        if (!this.tasks[userId]) {\n            return;\n        }\n        for (let task of this.tasks[userId]) {\n            if (task.id === taskId) {\n                task.completed = true;\n                break;\n            }\n        }\n    }\n}\n```\n    \n    We define a `Task` class that keeps the task information such as `id`, `description`, `dueDate`, `tags`, and its completion status (`completed` field). \n\nThe `TodoList` class contains a map, `tasks`, that stores the tasks of each user as a list. Then, we implement the methods `addTask`, `getAllTasks`, `getTasksForTag`, and `completeTask`, using the map and Task objects.\n\n1. `addTask()` creates a new Task object with the provided `taskDescription`, `dueDate`, and `tags`, and then adds the task to the corresponding user's task list. It increments the `taskId` by 1.\n2. `getAllTasks()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions to return.\n3. `getTasksForTag()` retrieves the user's task list, sorts the tasks by the due date, and creates a list of uncompleted task descriptions that have the specified tag.\n4. `completeTask()` finds the task with the given task ID for the specified user and sets the `completed` field of the task to `true`.\n\nForEach function is implemented using the standard library functions (`std::sort()` for C++, `Collections.sort()` for Java, `sorted()` for Python, and `Array.prototype.sort()` for JavaScript) and loops/iterators as required by each language.\n    "
    },
    {
        "id": 380,
        "title": "Make the Prefix Sum Non-negative",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. You can apply the following operation any number of times:\n\n*   Pick any element from `nums` and put it at the end of `nums`.\n\nThe prefix sum array of `nums` is an array `prefix` of the same length as `nums` such that `prefix[i]` is the sum of all the integers `nums[j]` where `j` is in the inclusive range `[0, i]`.\n\nReturn _the minimum number of operations such that the prefix sum array does not contain negative integers_. The test cases are generated such that it is always possible to make the prefix sum array non-negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,-5,4\\]\n**Output:** 0\n**Explanation:** we do not need to do any operations.\nThe array is \\[2,3,-5,4\\]. The prefix sum array is \\[2, 5, 0, 4\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,-5,-2,6\\]\n**Output:** 1\n**Explanation:** we can do one operation on index 1.\nThe array after the operation is \\[3,-2,6,-5\\]. The prefix sum array is \\[3, 1, 7, 2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[2,3,-5,4]",
                "output": "0"
            },
            {
                "input": "[3,-5,-2,6]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int minPrefix = 0;\n    int prefix = 0;\n    for (int num : nums) {\n        prefix += num;\n        minPrefix = Math.min(minPrefix, prefix);\n    }\n    return minPrefix < 0 ? -minPrefix : 0;\n}\n```\n    \n    We initialize two variables `min_prefix` and `prefix` both set to 0. We iterate over the elements in the `nums` array, adding each element to the `prefix`. At each iteration, we compare and store the minimum value between `min_prefix` and `prefix`.\n\nAfter the loop, we check if `min_prefix` is less than 0. If it is, return the negation of `min_prefix`. Otherwise, return 0.\n\nThe logic behind this algorithm is to find the minimum prefix sum that appears in the array. If this minimum prefix sum is negative, we need to perform operations to \"shift\" the array values so that the minimum prefix sum becomes non-negative. The minimum number of operations required to do this is equal to the absolute value of the minimum prefix sum found. If the minimum prefix sum is non-negative, there is no need to perform any operations.\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    min_prefix = 0\n    prefix = 0\n    for num in nums:\n        prefix += num\n        min_prefix = min(min_prefix, prefix)\n    return -min_prefix if min_prefix < 0 else 0\n```\n    \n    We initialize two variables `min_prefix` and `prefix` both set to 0. We iterate over the elements in the `nums` array, adding each element to the `prefix`. At each iteration, we compare and store the minimum value between `min_prefix` and `prefix`.\n\nAfter the loop, we check if `min_prefix` is less than 0. If it is, return the negation of `min_prefix`. Otherwise, return 0.\n\nThe logic behind this algorithm is to find the minimum prefix sum that appears in the array. If this minimum prefix sum is negative, we need to perform operations to \"shift\" the array values so that the minimum prefix sum becomes non-negative. The minimum number of operations required to do this is equal to the absolute value of the minimum prefix sum found. If the minimum prefix sum is non-negative, there is no need to perform any operations.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums) {\n    int min_prefix = 0;\n    int prefix = 0;\n    for (int num : nums) {\n        prefix += num;\n        min_prefix = min(min_prefix, prefix);\n    }\n    return min_prefix < 0 ? -min_prefix : 0;\n}\n```\n    \n    We initialize two variables `min_prefix` and `prefix` both set to 0. We iterate over the elements in the `nums` array, adding each element to the `prefix`. At each iteration, we compare and store the minimum value between `min_prefix` and `prefix`.\n\nAfter the loop, we check if `min_prefix` is less than 0. If it is, return the negation of `min_prefix`. Otherwise, return 0.\n\nThe logic behind this algorithm is to find the minimum prefix sum that appears in the array. If this minimum prefix sum is negative, we need to perform operations to \"shift\" the array values so that the minimum prefix sum becomes non-negative. The minimum number of operations required to do this is equal to the absolute value of the minimum prefix sum found. If the minimum prefix sum is non-negative, there is no need to perform any operations.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    let minPrefix = 0;\n    let prefix = 0;\n    for (let num of nums) {\n        prefix += num;\n        minPrefix = Math.min(minPrefix, prefix);\n    }\n    return minPrefix < 0 ? -minPrefix : 0;\n}\n```\n    \n    We initialize two variables `min_prefix` and `prefix` both set to 0. We iterate over the elements in the `nums` array, adding each element to the `prefix`. At each iteration, we compare and store the minimum value between `min_prefix` and `prefix`.\n\nAfter the loop, we check if `min_prefix` is less than 0. If it is, return the negation of `min_prefix`. Otherwise, return 0.\n\nThe logic behind this algorithm is to find the minimum prefix sum that appears in the array. If this minimum prefix sum is negative, we need to perform operations to \"shift\" the array values so that the minimum prefix sum becomes non-negative. The minimum number of operations required to do this is equal to the absolute value of the minimum prefix sum found. If the minimum prefix sum is non-negative, there is no need to perform any operations.\n    "
    },
    {
        "id": 381,
        "title": "Minimum Time to Eat All Grains",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` hens and `m` grains on a line. You are given the initial positions of the hens and the grains in two integer arrays `hens` and `grains` of size `n` and `m` respectively.\n\nAny hen can eat a grain if they are on the same position. The time taken for this is negligible. One hen can also eat multiple grains.\n\nIn `1` second, a hen can move right or left by `1` unit. The hens can move simultaneously and independently of each other.\n\nReturn _the **minimum** time to eat all grains if the hens act optimally._",
            "examples": [
                "**Example 1:**\n\n**Input:** hens = \\[3,6,7\\], grains = \\[2,4,7,9\\]\n**Output:** 2\n**Explanation:** \nOne of the ways hens eat all grains in 2 seconds is described below:\n- The first hen eats the grain at position 2 in 1 second. \n- The second hen eats the grain at position 4 in 2 seconds. \n- The third hen eats the grains at positions 7 and 9 in 2 seconds. \nSo, the maximum time needed is 2.\nIt can be proven that the hens cannot eat all grains before 2 seconds.\n\n",
                "**Example 2:**\n\n**Input:** hens = \\[4,6,109,111,213,215\\], grains = \\[5,110,214\\]\n**Output:** 1\n**Explanation:** \nOne of the ways hens eat all grains in 1 second is described below:\n- The first hen eats the grain at position 5 in 1 second. \n- The fourth hen eats the grain at position 110 in 1 second.\n- The sixth hen eats the grain at position 214 in 1 second. \n- The other hens do not move. \nSo, the maximum time needed is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= hens.length, grains.length <= 2*104`\n*   `0 <= hens[i], grains[j] <= 109`",
            "follow_up": null
        },
        "tag": [],
        "example": [
            {
                "input": "[3,6,7],[2,4,7,9]",
                "output": "2"
            },
            {
                "input": "[4,6,109,111,213,215],[5,110,214]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minTimeToEatGrains(int[] hens, int[] grains) {\n    Arrays.sort(hens);\n    Arrays.sort(grains);\n    int left = 0, right = 1_000_000_000;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        boolean can_eat = true;\n        int i = 0;\n\n        for (int grain : grains) {\n            if (i >= hens.length) {\n                can_eat = false;\n                break;\n            }\n\n            while (i < hens.length && hens[i] < grain - mid) {\n                ++i;\n            }\n\n            if (i >= hens.length || hens[i] > grain + mid) {\n                can_eat = false;\n                break;\n            }\n\n            ++i;\n        }\n\n        if (can_eat) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm uses a binary search between the minimum time (0) and the maximum possible time (10^9) to determine the minimum time required for the hens to eat all the grains. We first sort both the hens and the grains arrays to make it convenient for comparison. Inside the while loop, we simulate if all the grains can be eaten within the given mid value (current time). If true, then we can reduce the time; else, we increase the time. We iterate through the grains and hens and increment the counter by checking if the ith hen can eat the current grain within the mid seconds. If not, we move to the next hen. If none of the hens can eat the grain within mid seconds or there are not enough hens left, then can_eat is set to false, which indicates that the current mid value is not enough.\n\nFinally, we return the left value, which represents the minimum time required for hens to eat all the grains.\n    ",
        "python": "\n    ```python\ndef min_time_to_eat_grains(hens, grains):\n    hens.sort()\n    grains.sort()\n    left, right = 0, 10**9\n\n    while left < right:\n        mid = left + (right - left) // 2\n        can_eat = True\n        i = 0\n\n        for grain in grains:\n            if i >= len(hens):\n                can_eat = False\n                break\n\n            while i < len(hens) and hens[i] < grain - mid:\n                i += 1\n\n            if i >= len(hens) or hens[i] > grain + mid:\n                can_eat = False\n                break\n\n            i += 1\n\n        if can_eat:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n```\n    \n    The algorithm uses a binary search between the minimum time (0) and the maximum possible time (10^9) to determine the minimum time required for the hens to eat all the grains. We first sort both the hens and the grains arrays to make it convenient for comparison. Inside the while loop, we simulate if all the grains can be eaten within the given mid value (current time). If true, then we can reduce the time; else, we increase the time. We iterate through the grains and hens and increment the counter by checking if the ith hen can eat the current grain within the mid seconds. If not, we move to the next hen. If none of the hens can eat the grain within mid seconds or there are not enough hens left, then can_eat is set to false, which indicates that the current mid value is not enough.\n\nFinally, we return the left value, which represents the minimum time required for hens to eat all the grains.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minTimeToEatGrains(std::vector<int>& hens, std::vector<int>& grains) {\n    std::sort(hens.begin(), hens.end());\n    std::sort(grains.begin(), grains.end());\n    int left = 0, right = 1e9;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        bool can_eat = true;\n        int i = 0;\n\n        for (int grain : grains) {\n            if (i >= hens.size()) {\n                can_eat = false;\n                break;\n            }\n\n            while (i < hens.size() && hens[i] < grain - mid) {\n                ++i;\n            }\n\n            if (i >= hens.size() || hens[i] > grain + mid) {\n                can_eat = false;\n                break;\n            }\n\n            ++i;\n        }\n\n        if (can_eat) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm uses a binary search between the minimum time (0) and the maximum possible time (10^9) to determine the minimum time required for the hens to eat all the grains. We first sort both the hens and the grains arrays to make it convenient for comparison. Inside the while loop, we simulate if all the grains can be eaten within the given mid value (current time). If true, then we can reduce the time; else, we increase the time. We iterate through the grains and hens and increment the counter by checking if the ith hen can eat the current grain within the mid seconds. If not, we move to the next hen. If none of the hens can eat the grain within mid seconds or there are not enough hens left, then can_eat is set to false, which indicates that the current mid value is not enough.\n\nFinally, we return the left value, which represents the minimum time required for hens to eat all the grains.\n    ",
        "js": "\n    ```javascript\nfunction minTimeToEatGrains(hens, grains) {\n    hens.sort((a, b) => a - b);\n    grains.sort((a, b) => a - b);\n\n    let left = 0, right = 1000000000;\n\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        let can_eat = true;\n        let i = 0;\n\n        for (let grain of grains) {\n            if (i >= hens.length) {\n                can_eat = false;\n                break;\n            }\n\n            while (i < hens.length && hens[i] < grain - mid) {\n                ++i;\n            }\n\n            if (i >= hens.length || hens[i] > grain + mid) {\n                can_eat = false;\n                break;\n            }\n\n            ++i;\n        }\n\n        if (can_eat) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm uses a binary search between the minimum time (0) and the maximum possible time (10^9) to determine the minimum time required for the hens to eat all the grains. We first sort both the hens and the grains arrays to make it convenient for comparison. Inside the while loop, we simulate if all the grains can be eaten within the given mid value (current time). If true, then we can reduce the time; else, we increase the time. We iterate through the grains and hens and increment the counter by checking if the ith hen can eat the current grain within the mid seconds. If not, we move to the next hen. If none of the hens can eat the grain within mid seconds or there are not enough hens left, then can_eat is set to false, which indicates that the current mid value is not enough.\n\nFinally, we return the left value, which represents the minimum time required for hens to eat all the grains.\n    "
    }
]
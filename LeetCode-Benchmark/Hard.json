[
    {
        "id": 1,
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,3\\], nums2 = \\[2\\]\n**Output:** 2.00000\n**Explanation:** merged array = \\[1,2,3\\] and median is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[3,4\\]\n**Output:** 2.50000\n**Explanation:** merged array = \\[1,2,3,4\\] and median is (2 + 3) / 2 = 2.5."
            ],
            "constraints": "**Constraints:**\n\n*   `nums1.length == m`\n*   `nums2.length == n`\n*   `0 <= m <= 1000`\n*   `0 <= n <= 1000`\n*   `1 <= m + n <= 2000`\n*   `-106 <= nums1[i], nums2[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer"
        ],
        "example": [
            {
                "input": "[1,3],[2]",
                "output": "2.00000"
            },
            {
                "input": "[1,2],[3,4]",
                "output": "2.50000"
            }
        ],
        "java": "\n    ```java\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "python": "\n    ```python\ndef findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "c++": "\n    ```cpp\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "js": "\n    ```javascript\nfunction findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    "
    },
    {
        "id": 2,
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.​​​​\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"a\\* \"\n**Output:** true\n**Explanation:** '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"ab \", p =  \".\\* \"\n**Output:** true\n**Explanation:**  \".\\* \" means  \"zero or more (\\*) of any character (.) \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= p.length <= 20`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'.'`, and `'*'`.\n*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"aa\",\"a\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"a*\"",
                "output": "true"
            },
            {
                "input": "\"ab\",\".*\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "c++": "\n    ```cpp\nbool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "js": "\n    ```javascript\nfunction isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    "
    },
    {
        "id": 3,
        "title": "Container With Most Water",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = \\[1,8,6,2,5,4,8,3,7\\]\n**Output:** 49\n**Explanation:** The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49.\n\n",
                "**Example 2:**\n\n**Input:** height = \\[1,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,8,6,2,5,4,8,3,7]",
                "output": "49"
            },
            {
                "input": "[1,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "python": "\n    ```python\ndef max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "c++": "\n    ```cpp\nint maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "js": "\n    ```javascript\nfunction maxArea(height) {\n    let max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    "
    },
    {
        "id": 4,
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\n_Merge all the linked-lists into one sorted linked-list and return it._",
            "examples": [
                "**Example 1:**\n\n**Input:** lists = \\[\\[1,4,5\\],\\[1,3,4\\],\\[2,6\\]\\]\n**Output:** \\[1,1,2,3,4,4,5,6\\]\n**Explanation:** The linked-lists are:\n\\[\n  1->4->5,\n  1->3->4,\n  2->6\n\\]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\n",
                "**Example 2:**\n\n**Input:** lists = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** lists = \\[\\[\\]\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `k == lists.length`\n*   `0 <= k <= 104`\n*   `0 <= lists[i].length <= 500`\n*   `-104 <= lists[i][j] <= 104`\n*   `lists[i]` is sorted in **ascending order**.\n*   The sum of `lists[i].length` will not exceed `104`.",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Divide and Conquer",
            "Heap (Priority Queue)",
            "Merge Sort"
        ],
        "example": [
            {
                "input": "[[1,4,5],[1,3,4],[2,6]]",
                "output": "[1,1,2,3,4,4,5,6]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[[]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        while(lists.length > 1){\n            List<ListNode> tempList = new ArrayList<>();\n            tempList.add(mergeTwoLists(lists[0],lists[1]));\n            tempList.addAll(Arrays.asList(lists).subList(2, lists.length));\n            lists = tempList.toArray(new ListNode[tempList.size()]);\n        }\n        return lists[0];\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        if(l1.val <= l2.val){\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists: return None\n        while len(lists) > 1:\n            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))\n        return lists[0]\n        \n    def merge2Lists(self, l1, l2):\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val <= l2.val:\n            l1.next = self.merge2Lists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.merge2Lists(l1, l2.next)\n            return l2\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.empty()) return nullptr;\n        while(lists.size()>1){\n            lists.push_back(merge2Lists(lists[0],lists[1]));\n            lists.erase(lists.begin());\n            lists.erase(lists.begin());\n        }\n        return lists[0];\n    }\n    \n     ListNode* merge2Lists(ListNode* l1, ListNode* l2){\n        if(!l1) return l2;\n        if(!l2) return l1;\n        if(l1->val <= l2->val){\n            l1->next = merge2Lists(l1->next, l2);\n            return l1;\n        }\n        else{\n            l2->next = merge2Lists(l1, l2->next);\n            return l2;\n        }\n    }\n};\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val=0, next=null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction mergeKLists(lists) {\n    if(lists.length === 0) return null;\n    while(lists.length > 1){\n        lists.push(merge2Lists(lists.shift(), lists.shift()));\n    }\n    return lists[0];\n}\n\nfunction merge2Lists(l1, l2){\n    if(!l1) return l2;\n    if(!l2) return l1;\n    if(l1.val <= l2.val){\n        l1.next = merge2Lists(l1.next, l2);\n        return l1;\n    }\n    else{\n        l2.next = merge2Lists(l1, l2.next);\n        return l2;\n    }\n}\n```\n\n    \n    The algorithm follows a divide and conquer approach to merge all linked lists into one sorted linked-list. \n\n1. If the given array of linked-lists is empty, we return a null pointer.\n2. The main function `mergeKLists` merges the first two lists in the array of linked-lists and appends the results (merged list) at the end of the array. It will then remove the merged lists from the beginning of the array. This process is repeated until only one linked-list remains in the array.\n3. The function `merge2Lists` is used for merging two sorted linked-lists. The smallest element of the two lists is chosen as the head node and recursively merged with the rest of the lists.\n\nThis algorithm has a time complexity of O(kN) and a space complexity of O(1), where k is the number of linked-lists, and N is the total number of nodes across all linked-lists.\n    "
    },
    {
        "id": 5,
        "title": "Reverse Nodes in k-Group",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[2,1,4,3,5\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 3\n**Output:** \\[3,2,1,4,5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= k <= n <= 5000`\n*   `0 <= Node.val <= 1000`\n\n**",
            "follow_up": "Follow-up:** Can you solve the problem in `O(1)` extra memory space?"
        },
        "tag": [
            "Linked List",
            "Recursion"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5],2",
                "output": "[2,1,4,3,5]"
            },
            {
                "input": "[1,2,3,4,5],3",
                "output": "[3,2,1,4,5]"
            }
        ],
        "java": "\n    ```java\npublic class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode reverseKGroup(ListNode head, int k) {\n    if (head == null || k == 1) return head;\n    \n    int len = 0;\n    ListNode cur = head;\n    while (cur != null) {\n        len++;\n        cur = cur.next;\n    }\n    \n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    ",
        "python": "\n    ```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n        \n    cur = head\n    length = 0\n    while cur:\n        length += 1\n        cur = cur.next\n        \n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n    \n    while length >= k:\n        for _ in range(1, k):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        prev = cur\n        cur = cur.next\n        length -= k\n        \n    return dummy.next\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    ",
        "c++": "\n    ```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* reverseKGroup(ListNode* head, int k) {\n    if (head == nullptr || k == 1) return head;\n    \n    int len = 0;\n    ListNode *cur = head;\n    while (cur != nullptr) {\n        len++;\n        cur = cur->next;\n    }\n    \n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode *prev = &dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode *temp = cur->next;\n            cur->next = temp->next;\n            temp->next = prev->next;\n            prev->next = temp;\n        }\n        prev = cur;\n        cur = cur->next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    ",
        "js": "\n    ```javascript\nclass ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseKGroup(head, k) {\n    if (!head || k === 1) return head;\n    \n    let len = 0;\n    let cur = head;\n    while (cur) {\n        len++;\n        cur = cur.next;\n    }\n    \n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (let i = 1; i < k; i++) {\n            let temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}\n```\n\n    \n    1. First, we count the length of the linked list.\n2. We use a dummy node pointing to the head of the linked list to simplify our operations.\n3. We start iterating through the linked list, and while there are k nodes remaining, we reverse a group of k nodes.\n4. To reverse a group of k nodes, we perform the following operation for k - 1 times:\n    1. Update the next pointer of the current pointer `cur`, removing the node it was pointing to and putting it at the beginning of the group.\n    2. Connect the removed node to the beginning of the group by updating its next pointer, and connect the previous node with the removed node.\n5. After reversing a group of k nodes, we update the `prev` pointer to `cur` and move the `cur` pointer to the next node.\n6. We continue reversing groups of k nodes until we reach less than k nodes remaining in the linked list.\n7. Finally, we return the next pointer of the dummy node as our new head node.\n    "
    },
    {
        "id": 6,
        "title": "Substring with Concatenation of All Words",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of **the same length**.\n\nA **concatenated substring** in `s` is a substring that contains all the strings of any permutation of `words` concatenated.\n\n*   For example, if `words = [ \"ab \", \"cd \", \"ef \"]`, then `\"abcdef \"`, `\"abefcd \"`, `\"cdabef \"`, `\"cdefab \"`, `\"efabcd \"`, and `\"efcdab \"` are all concatenated strings. `\"acdbef \"` is not a concatenated substring because it is not the concatenation of any permutation of `words`.\n\nReturn _the starting indices of all the concatenated substrings in_ `s`. You can return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"barfoothefoobarman \", words = \\[ \"foo \", \"bar \"\\]\n**Output:** \\[0,9\\]\n**Explanation:** Since words.length == 2 and words\\[i\\].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is  \"barfoo \". It is the concatenation of \\[ \"bar \", \"foo \"\\] which is a permutation of words.\nThe substring starting at 9 is  \"foobar \". It is the concatenation of \\[ \"foo \", \"bar \"\\] which is a permutation of words.\nThe output order does not matter. Returning \\[9,0\\] is fine too.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"wordgoodgoodgoodbestword \", words = \\[ \"word \", \"good \", \"best \", \"word \"\\]\n**Output:** \\[\\]\n**Explanation:** Since words.length == 4 and words\\[i\\].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"barfoofoobarthefoobarman \", words = \\[ \"bar \", \"foo \", \"the \"\\]\n**Output:** \\[6,9,12\\]\n**Explanation:** Since words.length == 3 and words\\[i\\].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is  \"foobarthe \". It is the concatenation of \\[ \"foo \", \"bar \", \"the \"\\] which is a permutation of words.\nThe substring starting at 9 is  \"barthefoo \". It is the concatenation of \\[ \"bar \", \"the \", \"foo \"\\] which is a permutation of words.\nThe substring starting at 12 is  \"thefoobar \". It is the concatenation of \\[ \"the \", \"foo \", \"bar \"\\] which is a permutation of words."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `1 <= words.length <= 5000`\n*   `1 <= words[i].length <= 30`\n*   `s` and `words[i]` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"barfoothefoobarman\",[\"foo\",\"bar\"]",
                "output": "[0,9]"
            },
            {
                "input": "\"wordgoodgoodgoodbestword\",[\"word\",\"good\",\"best\",\"word\"]",
                "output": "[]"
            },
            {
                "input": "\"barfoofoobarthefoobarman\",[\"bar\",\"foo\",\"the\"]",
                "output": "[6,9,12]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {\n    if (s.empty() || words.empty()) return {};\n    \n    std::unordered_map<std::string, int> word_count;\n    for (const auto& word : words) {\n        ++word_count[word];\n    }\n    \n    int word_length = words[0].size();\n    int total_words = words.size();\n    int total_length = word_length * total_words;\n    std::vector<int> result;\n    \n    for (int i = 0; i <= (int)s.size() - total_length; ++i) {\n        std::unordered_map<std::string, int> temp_word_count;\n        for (int j = 0; j < total_words; ++j) {\n            std::string current_word = s.substr(i + j * word_length, word_length);\n            if (word_count.find(current_word) == word_count.end()) break;\n            ++temp_word_count[current_word];\n            if (temp_word_count[current_word] > word_count[current_word]) break;\n            if (j + 1 == total_words) result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    ",
        "js": "\n    ```javascript\nfunction findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const word_count = new Map();\n    for (const word of words) {\n        word_count.set(word, (word_count.get(word) || 0) + 1);\n    }\n\n    const word_length = words[0].length;\n    const total_words = words.length;\n    const total_length = word_length * total_words;\n    const result = [];\n\n    for (let i = 0; i <= s.length - total_length; i++) {\n        const temp_word_count = new Map();\n        for (let j = 0; j < total_words; j++) {\n            const current_word = s.substr(i + j * word_length, word_length);\n            if (!word_count.has(current_word)) break;\n            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 === total_words) result.push(i);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices.\n    "
    },
    {
        "id": 7,
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Stack"
        ],
        "example": [
            {
                "input": "\"(()\"",
                "output": "2"
            },
            {
                "input": "\")()())\"",
                "output": "4"
            },
            {
                "input": "\"\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int longestValidParentheses(String s) {\n    int n = s.length();\n    int result = 0;\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; ++i) {\n        if (s.charAt(i) == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s.charAt(st.peek()) == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "python": "\n    ```python\ndef longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <stack>\n\nint longestValidParentheses(string s) {\n    int n = s.length();\n    int result = 0;\n    std::stack<int> st;\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s[st.top()] == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.top();\n            st.pop();\n            result = std::max(result, right - left - 1);\n            right = left;\n        }\n        result = std::max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "js": "\n    ```javascript\nfunction longestValidParentheses(s) {\n    const n = s.length;\n    let result = 0;\n    const st = [];\n\n    for (let i = 0; i < n; ++i) {\n        if (s[i] === '(') {\n            st.push(i);\n        } else {\n            if (st.length > 0 && s[st[st.length - 1]] === '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.length === 0) {\n        result = n;\n    } else {\n        let right = n, left = 0;\n        while (st.length > 0) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    "
    },
    {
        "id": 8,
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "content": {
            "problem": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules**:\n\n1.  Each of the digits `1-9` must occur exactly once in each row.\n2.  Each of the digits `1-9` must occur exactly once in each column.\n3.  Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\],\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\],\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\],\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\],\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\],\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\],\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\],\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\],\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** \\[\\[ \"5 \", \"3 \", \"4 \", \"6 \", \"7 \", \"8 \", \"9 \", \"1 \", \"2 \"\\],\\[ \"6 \", \"7 \", \"2 \", \"1 \", \"9 \", \"5 \", \"3 \", \"4 \", \"8 \"\\],\\[ \"1 \", \"9 \", \"8 \", \"3 \", \"4 \", \"2 \", \"5 \", \"6 \", \"7 \"\\],\\[ \"8 \", \"5 \", \"9 \", \"7 \", \"6 \", \"1 \", \"4 \", \"2 \", \"3 \"\\],\\[ \"4 \", \"2 \", \"6 \", \"8 \", \"5 \", \"3 \", \"7 \", \"9 \", \"1 \"\\],\\[ \"7 \", \"1 \", \"3 \", \"9 \", \"2 \", \"4 \", \"8 \", \"5 \", \"6 \"\\],\\[ \"9 \", \"6 \", \"1 \", \"5 \", \"3 \", \"7 \", \"2 \", \"8 \", \"4 \"\\],\\[ \"2 \", \"8 \", \"7 \", \"4 \", \"1 \", \"9 \", \"6 \", \"3 \", \"5 \"\\],\\[ \"3 \", \"4 \", \"5 \", \"2 \", \"8 \", \"6 \", \"1 \", \"7 \", \"9 \"\\]\\]\n**Explanation:** The input board is shown above and the only valid solution is shown below:"
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 9`\n*   `board[i].length == 9`\n*   `board[i][j]` is a digit or `'.'`.\n*   It is **guaranteed** that the input board has only one solution.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Backtracking",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n\n    public boolean solveSudokuHelper(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n\n                            if (solveSudokuHelper(board)) {\n                                return true;\n                            }\n\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void solveSudoku(char[][] board) {\n        solveSudokuHelper(board);\n    }\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "python": "\n    ```python\ndef isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "js": "\n    ```javascript\nfunction isValid(board, row, col, c) {\n    for (let i = 0; i < 9; i++) {\n        if (board[i][col] === c) return false;\n        if (board[row][i] === c) return false;\n        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;\n    }\n    return true;\n}\n\nfunction solveSudokuHelper(board) {\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            if (board[i][j] === '.') {\n                for (let c = 1; c <= 9; c++) {\n                    if (isValid(board, i, j, c.toString())) {\n                        board[i][j] = c.toString();\n\n                        if (solveSudokuHelper(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction solveSudoku(board) {\n    solveSudokuHelper(board);\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    "
    },
    {
        "id": 9,
        "title": "First Missing Positive",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in `O(n)` time and uses constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,0\\]\n**Output:** 3\n**Explanation:** The numbers in the range \\[1,2\\] are all in the array.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,4,-1,1\\]\n**Output:** 2\n**Explanation:** 1 is in the array but 2 is missing.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,8,9,11,12\\]\n**Output:** 1\n**Explanation:** The smallest positive integer 1 is missing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[1,2,0]",
                "output": "3"
            },
            {
                "input": "[3,4,-1,1]",
                "output": "2"
            },
            {
                "input": "[7,8,9,11,12]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "python": "\n    ```python\ndef firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "c++": "\n    ```cpp\nint firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "js": "\n    ```javascript\nfunction firstMissingPositive(nums) {\n    let n = nums.length;\n    for(let i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            let temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        if(nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    "
    },
    {
        "id": 10,
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "content": {
            "problem": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n",
                "**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
                "output": "6"
            },
            {
                "input": "[4,2,0,3,2,5]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "python": "\n    ```python\ndef trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "js": "\n    ```javascript\nfunction trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    "
    },
    {
        "id": 11,
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Greedy",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"aa\",\"a\"",
                "output": "false"
            },
            {
                "input": "\"aa\",\"*\"",
                "output": "true"
            },
            {
                "input": "\"cb\",\"?a\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "c++": "\n    ```cpp\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "js": "\n    ```javascript\nfunction isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    "
    },
    {
        "id": 12,
        "title": "N-Queens",
        "difficulty": "Hard",
        "content": {
            "problem": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** \\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[ \"Q \"\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking"
        ],
        "example": [
            {
                "input": "4",
                "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"
            },
            {
                "input": "1",
                "output": "[[\"Q\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "python": "\n    ```python\ndef solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) {\n    for (int i = 0; i < col; ++i) {\n        if (board[row][i] == 'Q') return false;\n    }\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    for (int i = row, j = col; i < n && j >= 0; ++i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    return true;\n}\n\nvoid solve(std::vector<std::vector<std::string>>& result, std::vector<std::string>& board, int n, int col) {\n    if (col == n) {\n        result.push_back(board);\n        return;\n    }\n    for (int row = 0; row < n; ++row) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solve(result, board, n, col + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "js": "\n    ```javascript\nfunction solveNQueens(n) {\n  function isSafe(board, row, col) {\n    for (let i = 0; i < col; i++)\n      if (board[row][i] == 'Q') return false;\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)\n      if (board[i][j] == 'Q') return false;\n    for (let i = row, j = col; i < n && j >= 0; i++, j--)\n      if (board[i][j] == 'Q') return false;\n    return true;\n  }\n\n  function solve(result, board, n, col) {\n    if (col == n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let row = 0; row < n; row++) {\n      if (isSafe(board, row, col)) {\n        board[row][col] = 'Q';\n        solve(result, board, n, col + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  const result = [];\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n  solve(result, board, n, 0);\n  return result;\n}\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    "
    },
    {
        "id": 13,
        "title": "N-Queens II",
        "difficulty": "Hard",
        "content": {
            "problem": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`",
            "follow_up": null
        },
        "tag": [
            "Backtracking"
        ],
        "example": [
            {
                "input": "4",
                "output": "2"
            },
            {
                "input": "1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int totalNQueens(int n) {\n    ArrayList<Integer> cols = new ArrayList<>();\n    return backtrack(n, cols);\n}\n\npublic int backtrack(int n, ArrayList<Integer> cols) {\n    if (cols.size() == n) {\n        return 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.add(i);\n            count += backtrack(n, cols);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    return count;\n}\n\npublic boolean isSafe(ArrayList<Integer> cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "python": "\n    ```python\ndef is_safe(cols, row):\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)\n```\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool isSafe(vector<int> &cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols[i] == row || abs(i - col) == abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, vector<int> &cols, int &count) {\n    if (cols.size() == n) {\n        count++;\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push_back(i);\n            backtrack(n, cols, count);\n            cols.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int n) {\n    vector<int> cols;\n    int count = 0;\n    backtrack(n, cols, count);\n    return count;\n}\n```\n\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "js": "\n    ```javascript\nfunction isSafe(cols, row) {\n    let col = cols.length;\n    for (let i = 0; i < cols.length; i++) {\n        if (cols[i] === row || Math.abs(i - col) === Math.abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction backtrack(n, cols) {\n    if (cols.length === n) {\n        return 1;\n    }\n\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push(i);\n            count += backtrack(n, cols);\n            cols.pop();\n        }\n    }\n    return count;\n}\n\nfunction totalNQueens(n) {\n    let cols = [];\n    return backtrack(n, cols);\n}\n```\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    "
    },
    {
        "id": 14,
        "title": "Permutation Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1.  `\"123 \"`\n2.  `\"132 \"`\n3.  `\"213 \"`\n4.  `\"231 \"`\n5.  `\"312 \"`\n6.  `\"321 \"`\n\nGiven `n` and `k`, return the `kth` permutation sequence.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 3\n**Output:** \"213\"\n\n",
                "**Example 2:**\n\n**Input:** n = 4, k = 9\n**Output:** \"2314\"\n\n",
                "**Example 3:**\n\n**Input:** n = 3, k = 1\n**Output:** \"123\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`\n*   `1 <= k <= n!`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Recursion"
        ],
        "example": [
            {
                "input": "3,3",
                "output": "\"213\""
            },
            {
                "input": "4,9",
                "output": "\"2314\""
            },
            {
                "input": "3,1",
                "output": "\"123\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "python": "\n    ```python\ndef getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) {\n    std::vector<int> factorials(n, 1);\n    std::vector<char> nums(n, '1');\n    std::string result;\n    int index;\n\n    for (int i = 1; i <= n; ++i) {\n        nums[i - 1] += i - 1;\n        factorials[i - 1] *= i;\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        result.push_back(nums[index]);\n        nums.erase(nums.begin() + index);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "js": "\n    ```javascript\nfunction getPermutation(n, k) {\n    const factorials = [1];\n    const nums = [...Array(n)].map((_, i) => i + 1);\n    let result = '';\n\n    for (let i = 1; i < n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    k--;\n\n    for (let i = n; i >= 1; i--) {\n        const index = Math.floor(k / factorials[i - 1]);\n        k %= factorials[i - 1];\n        result += nums[index];\n        nums.splice(index, 1);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    "
    },
    {
        "id": 15,
        "title": "Valid Number",
        "difficulty": "Hard",
        "content": {
            "problem": "A **valid number** can be split up into these components (in order):\n\n1.  A **decimal number** or an **integer**.\n2.  (Optional) An `'e'` or `'E'`, followed by an **integer**.\n\nA **decimal number** can be split up into these components (in order):\n\n1.  (Optional) A sign character (either `'+'` or `'-'`).\n2.  One of the following formats:\n    1.  One or more digits, followed by a dot `'.'`.\n    2.  One or more digits, followed by a dot `'.'`, followed by one or more digits.\n    3.  A dot `'.'`, followed by one or more digits.\n\nAn **integer** can be split up into these components (in order):\n\n1.  (Optional) A sign character (either `'+'` or `'-'`).\n2.  One or more digits.\n\nFor example, all the following are valid numbers: `[ \"2 \", \"0089 \", \"-0.1 \", \"+3.14 \", \"4. \", \"-.9 \", \"2e10 \", \"-90E3 \", \"3e+7 \", \"+6e-1 \", \"53.5e93 \", \"-123.456e789 \"]`, while the following are not valid numbers: `[ \"abc \", \"1a \", \"1e \", \"e3 \", \"99e2.5 \", \"--6 \", \"-+3 \", \"95a54e53 \"]`.\n\nGiven a string `s`, return `true` _if_ `s` _is a **valid number**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"0 \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"e \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s =  \". \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `s` consists of only English letters (both uppercase and lowercase), digits (`0-9`), plus `'+'`, minus `'-'`, or dot `'.'`.",
            "follow_up": null
        },
        "tag": [
            "String"
        ],
        "example": [
            {
                "input": "\"0\"",
                "output": "true"
            },
            {
                "input": "\"e\"",
                "output": "false"
            },
            {
                "input": "\".\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Solution {\n    public boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }\n}\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    ",
        "python": "\n    ```python\nimport re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    ",
        "c++": "\n    ```cpp\n#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    std::regex pattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(s, pattern);\n}\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    ",
        "js": "\n    ```javascript\nfunction isNumber(s) {\n    const pattern = /^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$/;\n    return pattern.test(s);\n}\n```\n\n    \n    The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise.\n    "
    },
    {
        "id": 16,
        "title": "Text Justification",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n**Note:**\n\n*   A word is defined as a character sequence consisting of non-space characters only.\n*   Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.\n*   The input array `words` contains at least one word.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"This \",  \"is \",  \"an \",  \"example \",  \"of \",  \"text \",  \"justification. \"\\], maxWidth = 16\n**Output:**\n\\[\n    \"This    is    an \",\n    \"example  of text \",\n    \"justification.   \"\n\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"What \", \"must \", \"be \", \"acknowledgment \", \"shall \", \"be \"\\], maxWidth = 16\n**Output:**\n\\[\n   \"What   must   be \",\n   \"acknowledgment   \",\n   \"shall be         \"\n\\]\n**Explanation:** Note that the last line is  \"shall be     \" instead of  \"shall     be \", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"Science \", \"is \", \"what \", \"we \", \"understand \", \"well \", \"enough \", \"to \", \"explain \", \"to \", \"a \", \"computer. \", \"Art \", \"is \", \"everything \", \"else \", \"we \", \"do \"\\], maxWidth = 20\n**Output:**\n\\[\n   \"Science  is  what we \",\n   \"understand      well \",\n   \"enough to explain to \",\n   \"a  computer.  Art is \",\n   \"everything  else  we \",\n   \"do                   \"\n\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 300`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of only English letters and symbols.\n*   `1 <= maxWidth <= 100`\n*   `words[i].length <= maxWidth`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Simulation"
        ],
        "example": [
            {
                "input": "[\"This\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"],16",
                "output": "\n[\n\"Thisisan\",\n\"exampleoftext\",\n\"justification.\"\n]"
            },
            {
                "input": "[\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"],16",
                "output": "\n[\n\"Whatmustbe\",\n\"acknowledgment\",\n\"shallbe\"\n]"
            },
            {
                "input": "[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"],20",
                "output": "\n[\n\"Scienceiswhatwe\",\n\"understandwell\",\n\"enoughtoexplainto\",\n\"acomputer.Artis\",\n\"everythingelsewe\",\n\"do\"\n]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> result = new ArrayList<>();\n    int idx = 0;\n    while (idx < words.length) {\n        int totalChars = words[idx].length();\n        int last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        StringBuilder line = new StringBuilder();\n        if (last == words.length || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) line.append(\" \");\n            }\n            while (line.length() < maxWidth) line.append(\" \");\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) {\n                    line.append(\" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));\n                }\n            }\n        }\n        idx = last;\n        result.add(line.toString());\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "python": "\n    ```python\ndef fullJustify(words, maxWidth):\n    result = []\n    idx = 0\n    while idx < len(words):\n        total_chars = len(words[idx])\n        last = idx + 1\n        while last < len(words):\n            if total_chars + 1 + len(words[last]) > maxWidth:\n                break\n            total_chars += 1 + len(words[last])\n            last += 1\n        gaps = last - idx - 1\n        line = []\n        if last == len(words) or gaps == 0:\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \")\n            while sum(len(w) for w in line) < maxWidth:\n                line.append(\" \")\n        else:\n            even_spaces = (maxWidth - total_chars) // gaps\n            extra_spaces = (maxWidth - total_chars) % gaps\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \" * (even_spaces + (1 if i - idx < extra_spaces else 0)))\n        idx = last\n        result.append(\"\".join(line))\n    return result\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int idx = 0;\n    while (idx < words.size()) {\n        int totalChars = words[idx].size();\n        int last = idx + 1;\n        while (last < words.size()) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        stringstream line;\n        if (last == words.size() || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) line << \" \";\n            }\n            line << string(maxWidth - line.str().size(), ' ');\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) {\n                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        idx = last;\n        result.push_back(line.str());\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "js": "\n    ```javascript\nfunction fullJustify(words, maxWidth) {\n    const result = [];\n    let idx = 0;\n    while (idx < words.length) {\n        let totalChars = words[idx].length;\n        let last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length > maxWidth) break;\n            totalChars += 1 + words[last].length;\n            last++;\n        }\n        const gaps = last - idx - 1;\n        let line = \"\";\n        if (last === words.length || gaps === 0) {\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) line += \" \";\n            }\n            while (line.length < maxWidth) line += \" \";\n        } else {\n            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);\n            const extraSpaces = (maxWidth - totalChars) % gaps;\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) {\n                    line += \" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));\n                }\n            }\n        }\n        idx = last;\n        result.push(line);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    "
    },
    {
        "id": 17,
        "title": "Edit Distance",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:** \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:** \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"horse\",\"ros\"",
                "output": "3"
            },
            {
                "input": "\"intention\",\"execution\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "python": "\n    ```python\ndef minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "c++": "\n    ```cpp\nint minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "js": "\n    ```javascript\nfunction minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    "
    },
    {
        "id": 18,
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window**_ **_substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `\" \"`.\n\nThe testcases will be generated such that the answer is **unique**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ADOBECODEBANC \", t =  \"ABC \"\n**Output:**  \"BANC \"\n**Explanation:** The minimum window substring  \"BANC \" includes 'A', 'B', and 'C' from string t.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \", t =  \"a \"\n**Output:**  \"a \"\n**Explanation:** The entire string s is the minimum window.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a \", t =  \"aa \"\n**Output:**  \" \"\n**Explanation:** Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string."
            ],
            "constraints": "**Constraints:**\n\n*   `m == s.length`\n*   `n == t.length`\n*   `1 <= m, n <= 105`\n*   `s` and `t` consist of uppercase and lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Could you find an algorithm that runs in `O(m + n)` time?"
        },
        "tag": [
            "Hash Table",
            "String",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "\"ADOBECODEBANC\",\"ABC\"",
                "output": "\"BANC\""
            },
            {
                "input": "\"a\",\"a\"",
                "output": "\"a\""
            },
            {
                "input": "\"a\",\"aa\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t) {\n    std::unordered_map<char, int> need, window;\n    for (char c : t) need[c]++;\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = INT_MAX;\n\n    while (right < s.length()) {\n        char c = s[right];\n        right++;\n        if (need.count(c)) {\n            window[c]++;\n            if (window[c] <= need[c]) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s[left];\n            left++;\n            if (need.count(d)) {\n                if (window[d] <= need[d]) valid--;\n                window[d]--;\n            }\n        }\n    }\n    return length == INT_MAX ? \"\" : s.substr(start, length);\n}\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    ",
        "js": "\n    ```javascript\nfunction minWindow(s, t) {\n    const need = new Map();\n    const window = new Map();\n\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    let left = 0, right = 0;\n    let valid = 0;\n    let start = 0, length = Infinity;\n\n    while (right < s.length) {\n        const c = s[right];\n        right++;\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid === t.length) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            const d = s[left];\n            left++;\n            if (need.has(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length === Infinity ? \"\" : s.substring(start, start + length);\n}\n```\n\n    \n    The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found.\n    "
    },
    {
        "id": 19,
        "title": "Largest Rectangle in Histogram",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[2,1,5,6,2,3\\]\n**Output:** 10\n**Explanation:** The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[2,4\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `0 <= heights[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[2,1,5,6,2,3]",
                "output": "10"
            },
            {
                "input": "[2,4]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int max_area = 0;\n    for (int i = 0; i <= heights.length; i++) {\n        int height = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && heights[stack.peek()] > height) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n            max_area = Math.max(max_area, h * w);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "python": "\n    ```python\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "c++": "\n    ```cpp\nint largestRectangleArea(vector<int>& heights) {\n    heights.push_back(0);\n    stack<int> s;\n    int max_area = 0;\n    for (int i = 0; i < heights.size(); i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            max_area = max(max_area, height * width);\n        }\n        s.push(i);\n    }\n    return max_area;\n}\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "js": "\n    ```javascript\nfunction largestRectangleArea(heights) {\n    let stack = [];\n    let max_area = 0;\n    heights.push(0);\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            let height = heights[stack.pop()];\n            let width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max_area = Math.max(max_area, height * width);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    "
    },
    {
        "id": 20,
        "title": "Maximal Rectangle",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Stack",
            "Matrix",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                "output": "6"
            },
            {
                "input": "[[\"0\"]]",
                "output": "0"
            },
            {
                "input": "[[\"1\"]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[] height = new int[n + 1];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        Stack<Integer> s = new Stack<>();\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.peek()]) {\n                int h = height[s.pop()];\n                int w = s.empty() ? j : j - s.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "python": "\n    ```python\ndef maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty()) return 0;\n\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<int> height(n + 1, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        stack<int> s;\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.top()]) {\n                int h = height[s.top()];\n                s.pop();\n                int w = s.empty() ? j : j - s.top() - 1;\n                maxArea = max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "js": "\n    ```javascript\nfunction maximalRectangle(matrix) {\n    if (!matrix.length) return 0;\n\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let height = Array(n + 1).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < m; i++) {\n        let s = [];\n        for (let j = 0; j <= n; j++) {\n            if (j < n) {\n                height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;\n            }\n            while (s.length && height[j] < height[s[s.length - 1]]) {\n                let h = height[s.pop()];\n                let w = !s.length ? j : j - s[s.length - 1] - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    "
    },
    {
        "id": 21,
        "title": "Scramble String",
        "difficulty": "Hard",
        "content": {
            "problem": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"great \", s2 =  \"rgeat \"\n**Output:** true\n**Explanation:** One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"abcde \", s2 =  \"caebd \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s1 =  \"a \", s2 =  \"a \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `s1.length == s2.length`\n*   `1 <= s1.length <= 30`\n*   `s1` and `s2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"great\",\"rgeat\"",
                "output": "true"
            },
            {
                "input": "\"abcde\",\"caebd\"",
                "output": "false"
            },
            {
                "input": "\"a\",\"a\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "python": "\n    ```python\ndef isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "c++": "\n    ```cpp\nbool isScramble(string s1, string s2) {\n    if (s1 == s2) return true;\n    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;\n\n    for (int i = 1; i < s1.size(); i++) {\n        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\n            return true;\n        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))\n            return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "js": "\n    ```javascript\nfunction isScramble(s1, s2) {\n    if (s1 === s2) return true;\n    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;\n\n    for (let i = 1; i < s1.length; i++) {\n        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || \n            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))\n            return true;\n    }\n    return false;\n}\n\nfunction sorted(s) {\n    return s.split('').sort().join('');\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    "
    },
    {
        "id": 22,
        "title": "Distinct Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"rabbbit \", t =  \"rabbit \"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`\n\n",
                "**Example 2:**\n\n**Input:** s =  \"babgbag \", t =  \"bag \"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 1000`\n*   `s` and `t` consist of English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"rabbbit\",\"rabbit\"",
                "output": "3"
            },
            {
                "input": "\"babgbag\",\"bag\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "python": "\n    ```python\ndef numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "c++": "\n    ```cpp\nint numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "js": "\n    ```javascript\nfunction numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    "
    },
    {
        "id": 23,
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n",
                "**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[3,3,5,0,0,3,1,4]",
                "output": "6"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "4"
            },
            {
                "input": "[7,6,4,3,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int buy1 = INT_MAX, buy2 = INT_MAX;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = min(buy1, price);\n        profit1 = max(profit1, price - buy1);\n        buy2 = min(buy2, price - profit1);\n        profit2 = max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(prices) {\n    let buy1 = Infinity, buy2 = Infinity;\n    let profit1 = 0, profit2 = 0;\n\n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    "
    },
    {
        "id": 24,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3]",
                "output": "6"
            },
            {
                "input": "[-10,9,20,null,null,15,7]",
                "output": "42"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int maxPathSum(TreeNode root) {\n    int[] maxSum = new int[]{Integer.MIN_VALUE};\n    helper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int helper(TreeNode root, int[] maxSum) {\n    if (root == null) return 0;\n\n    int left = Math.max(0, helper(root.left, maxSum));\n    int right = Math.max(0, helper(root.right, maxSum));\n\n    maxSum[0] = Math.max(maxSum[0], left + right + root.val);\n\n    return Math.max(left, right) + root.val;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint helper(TreeNode* root, int& maxSum) {\n    if(!root) return 0;\n\n    int left = max(0, helper(root->left, maxSum));\n    int right = max(0, helper(root->right, maxSum));\n\n    maxSum = max(maxSum, left + right + root->val);\n\n    return max(left, right) + root->val;\n}\n\nint maxPathSum(TreeNode* root) {\n    int maxSum = INT_MIN;\n    helper(root, maxSum);\n    return maxSum;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction maxPathSum(root) {\n    let maxSum = Number.MIN_SAFE_INTEGER;\n    \n    function helper(node) {\n        if (node === null) return 0;\n        \n        const left = Math.max(0, helper(node.left));\n        const right = Math.max(0, helper(node.right));\n        \n        maxSum = Math.max(maxSum, left + right + node.val);\n        \n        return Math.max(left, right) + node.val;\n    }\n    \n    helper(root);\n    return maxSum;\n}\n```\n    \n    The algorithm is based on Depth First Search (DFS) traversal of the binary tree.\n\n1. Create a helper function that takes the root and maximum path sum reference as the input parameters.\n2. If the current node (root) is null, return 0.\n3. Call the helper function recursively for the left and right child nodes:\n   - Set `left` as the maximum of 0 and the helper function call for the left child.\n   - Set `right` as the maximum of 0 and the helper function call for the right child.\n4. Update the maximum path sum using the current maximum, the sum of the current node's value, and the left and right children's values.\n5. Return the sum of the current node's value and the maximum of the left and right subtrees.\n\nCall the helper function with the given binary tree root and return the maximum path sum.\n    "
    },
    {
        "id": 25,
        "title": "Word Ladder II",
        "difficulty": "Hard",
        "content": {
            "problem": "A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n*   Every adjacent pair of words differs by a single letter.\n*   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n*   `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _all the **shortest transformation sequences** from_ `beginWord` _to_ `endWord`_, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words_ `[beginWord, s1, s2, ..., sk]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \", \"cog \"\\]\n**Output:** \\[\\[ \"hit \", \"hot \", \"dot \", \"dog \", \"cog \"\\],\\[ \"hit \", \"hot \", \"lot \", \"log \", \"cog \"\\]\\]\n**Explanation:** There are 2 shortest transformation sequences:\n \"hit \" ->  \"hot \" ->  \"dot \" ->  \"dog \" ->  \"cog \"\n \"hit \" ->  \"hot \" ->  \"lot \" ->  \"log \" ->  \"cog \"\n\n",
                "**Example 2:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \"\\]\n**Output:** \\[\\]\n**Explanation:** The endWord  \"cog \" is not in wordList, therefore there is no valid transformation sequence."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= beginWord.length <= 5`\n*   `endWord.length == beginWord.length`\n*   `1 <= wordList.length <= 500`\n*   `wordList[i].length == beginWord.length`\n*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n*   `beginWord != endWord`\n*   All the words in `wordList` are **unique**.\n*   The **sum** of all shortest transformation sequences does not exceed `105`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]"
            },
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef findLadders(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return []\n\n    adjacent = defaultdict(list)\n    distance = defaultdict(int)\n    queue = deque([beginWord])\n    distance[beginWord] = 0\n    \n    def neighbors(word):\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z') + 1):\n                yield word[:i] + chr(j) + word[i + 1:]\n                \n    while queue:\n        current = queue.popleft()\n        if current == endWord:\n            break\n        for neighbor in neighbors(current):\n            if neighbor not in wordList:\n                continue\n            if neighbor not in distance:\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n            if distance[neighbor] == distance[current] + 1:\n                adjacent[current].append(neighbor)\n\n    result = []\n    path = [beginWord]\n\n    def backtrack(word):\n        if word == endWord:\n            result.append(path[:])\n        else:\n            for next_word in adjacent[word]:\n                path.append(next_word)\n                backtrack(next_word)\n                path.pop()\n                \n    backtrack(beginWord)\n    return result\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    ",
        "js": "\n    ```javascript\nfunction findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}\n```\n\n    \n    1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations.\n    "
    },
    {
        "id": 26,
        "title": "Word Ladder",
        "difficulty": "Hard",
        "content": {
            "problem": "A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n*   Every adjacent pair of words differs by a single letter.\n*   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n*   `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _the **number of words** in the **shortest transformation sequence** from_ `beginWord` _to_ `endWord`_, or_ `0` _if no such sequence exists._",
            "examples": [
                "**Example 1:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \", \"cog \"\\]\n**Output:** 5\n**Explanation:** One shortest transformation sequence is  \"hit \" ->  \"hot \" ->  \"dot \" ->  \"dog \" -> cog \", which is 5 words long.\n\n",
                "**Example 2:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \"\\]\n**Output:** 0\n**Explanation:** The endWord  \"cog \" is not in wordList, therefore there is no valid transformation sequence."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= beginWord.length <= 10`\n*   `endWord.length == beginWord.length`\n*   `1 <= wordList.length <= 5000`\n*   `wordList[i].length == beginWord.length`\n*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n*   `beginWord != endWord`\n*   All the words in `wordList` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "5"
            },
            {
                "input": "\"hit\",\"cog\",[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        size = len(q)\n        current_level = set()\n        \n        for _ in range(size):\n            current_word = q.popleft()\n            if current_word == endWord:\n                return steps\n\n            word_chars = list(current_word)\n            for i in range(len(word_chars)):\n                original_char = word_chars[i]\n                for j in range(26):\n                    word_chars[i] = chr(ord('a') + j)\n                    new_word = ''.join(word_chars)\n                    if new_word in word_set:\n                        q.append(new_word)\n                        current_level.add(new_word)\n                        \n                word_chars[i] = original_char\n        \n        word_set -= current_level\n        steps += 1\n        \n    return 0\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (!dict.count(endWord)) return 0;\n\n    std::queue<std::string> q;\n    q.push(beginWord);\n    int steps = 1;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            std::string currentWord = q.front();\n            q.pop();\n            if (currentWord == endWord) return steps;\n\n            for (char& c : currentWord) {\n                char originalChar = c;\n                for (int j = 0; j < 26; ++j) {\n                    c = 'a' + j;\n                    if (dict.count(currentWord)) {\n                        q.push(currentWord);\n                        dict.erase(currentWord);\n                    }\n                }\n                c = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    ",
        "js": "\n    ```javascript\nfunction ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}\n```\n    \n    In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0.\n    "
    },
    {
        "id": 27,
        "title": "Palindrome Partitioning II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn _the **minimum** cuts needed for a palindrome partitioning of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aab \"\n**Output:** 1\n**Explanation:** The palindrome partitioning \\[ \"aa \", \"b \"\\] could be produced using 1 cut.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** s =  \"ab \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"aab\"",
                "output": "1"
            },
            {
                "input": "\"a\"",
                "output": "0"
            },
            {
                "input": "\"ab\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int minCut(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    boolean[][] isPalindrome = new boolean[n][n];\n    \n    for (int i=0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j=1; j < n; j++) {\n        for (int i=j; i >= 0; i--) {\n            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "python": "\n    ```python\ndef minCut(s):\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for j in range(1, n):\n        for i in range(j, -1, -1):\n            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):\n                is_palindrome[i][j] = True\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n                \n    return dp[n]\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint minCut(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    std::vector<std::vector<bool>> isPalindrome(n, std::vector<bool>(n, false));\n    \n    for (int i = 0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j = 1; j < n; j++) {\n        for (int i = j; i >= 0; i--) {\n            if (s[i] == s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = std::min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "js": "\n    ```javascript\nfunction minCut(s) {\n    const n = s.length;\n    const dp = Array.from({ length: n + 1 }, (_, i) => i - 1);\n    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));\n    \n    for (let j = 1; j < n; j++) {\n        for (let i = j; i >= 0; i--) {\n            if (s[i] === s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    "
    },
    {
        "id": 28,
        "title": "Candy",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_.",
            "examples": [
                "**Example 1:**\n\n**Input:** ratings = \\[1,0,2\\]\n**Output:** 5\n**Explanation:** You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n",
                "**Example 2:**\n\n**Input:** ratings = \\[1,2,2\\]\n**Output:** 4\n**Explanation:** You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `n == ratings.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= ratings[i] <= 2 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,0,2]",
                "output": "5"
            },
            {
                "input": "[1,2,2]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "python": "\n    ```python\ndef min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "js": "\n    ```javascript\nfunction minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    "
    },
    {
        "id": 29,
        "title": "Word Break II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"catsanddog \", wordDict = \\[ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"\\]\n**Output:** \\[ \"cats and dog \", \"cat sand dog \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"pineapplepenapple \", wordDict = \\[ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"\\]\n**Output:** \\[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"\\]\n**Explanation:** Note that you are allowed to reuse a dictionary word.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 10`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\n*   Input is generated in a way that the length of the answer doesn't exceed 105.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Dynamic Programming",
            "Backtracking",
            "Trie",
            "Memoization"
        ],
        "example": [
            {
                "input": "\"catsanddog\",[\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
                "output": "[\"catsanddog\",\"catsanddog\"]"
            },
            {
                "input": "\"pineapplepenapple\",[\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
                "output": "[\"pineapplepenapple\",\"pineapplepenapple\",\"pineapplepenapple\"]"
            },
            {
                "input": "\"catsandog\",[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "python": "\n    ```python\ndef word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {\n    if (memo.count(s)) return memo[s];\n\n    std::vector<std::string> res;\n    if (dict.count(s)) res.push_back(s);\n\n    for (int i = 1; i < s.size(); ++i) {\n        std::string prefix = s.substr(0, i);\n        if (!dict.count(prefix)) continue;\n        std::string suffix = s.substr(i);\n        auto temp = helper(suffix, dict, memo);\n        for (const auto& t : temp) {\n            res.push_back(prefix + \" \" + t);\n        }\n    }\n    memo[s] = res;\n    return res;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::unordered_map<std::string, std::vector<std::string>> memo;\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "js": "\n    ```javascript\nfunction wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const memo = {};\n\n    function helper(s, dict, memo) {\n        if (s in memo) {\n            return memo[s];\n        }\n        \n        const res = [];\n        if (dict.has(s)) {\n            res.push(s);\n        }\n        \n        for (let i = 1; i < s.length; ++i) {\n            const prefix = s.slice(0, i);\n            if (!dict.has(prefix)) continue;\n            const suffix = s.slice(i);\n            const temp = helper(suffix, dict, memo);\n            for (const t of temp) {\n                res.push(prefix + \" \" + t);\n            }\n        }\n\n        memo[s] = res;\n        return res;\n    }\n\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    "
    },
    {
        "id": 30,
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,2\\],\\[5,3\\],\\[4,1\\],\\[2,3\\],\\[1,4\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 300`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `points` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,1],[2,2],[3,3]]",
                "output": "3"
            },
            {
                "input": "[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nprivate int gcd(int a, int b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    ",
        "python": "\n    ```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    ",
        "js": "\n    ```javascript\nfunction maxPoints(points) {\n    const n = points.length;\n    if (n <= 2) return n;\n\n    let maxCount = 0;\n\n    for (let i = 0; i < n; i++) {\n        const slopeMap = new Map();\n        let duplicates = 0, localMax = 0;\n\n        for (let j = i + 1; j < n; j++) {\n            let deltaX = points[j][0] - points[i][0];\n            let deltaY = points[j][1] - points[i][1];\n\n            if (deltaX === 0 && deltaY === 0) {\n                duplicates++;\n                continue;\n            }\n\n            const gcdVal = gcd(deltaX, deltaY);\n            deltaX /= gcdVal;\n            deltaY /= gcdVal;\n\n            const key = `${deltaX}_${deltaY}`;\n            slopeMap.set(key, (slopeMap.get(key) || 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\n```\n\n    \n    - Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer.\n    "
    },
    {
        "id": 31,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": "Hard",
        "content": {
            "problem": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,4]` if it was rotated `4` times.\n*   `[0,1,4,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` that may contain **duplicates**, return _the minimum element of this array_.\n\nYou must decrease the overall operation steps as much as possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,0,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   `nums` is sorted and rotated between `1` and `n` times.\n\n**",
            "follow_up": "Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?"
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[1,3,5]",
                "output": "1"
            },
            {
                "input": "[2,2,2,0,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int findMin(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "python": "\n    ```python\ndef findMin(nums):\n    low, high = 0, len(nums) - 1\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        if nums[mid] > nums[high]:\n            low = mid + 1\n        elif nums[mid] < nums[high]:\n            high = mid\n        else:\n            high -= 1\n            \n    return nums[low]\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "c++": "\n    ```cpp\nint findMin(vector<int>& nums) {\n    int low = 0, high = nums.size() - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "js": "\n    ```javascript\nfunction findMin(nums) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    "
    },
    {
        "id": 32,
        "title": "Maximum Gap",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the maximum difference between two successive elements in its sorted form_. If the array contains less than two elements, return `0`.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,6,9,1\\]\n**Output:** 3\n**Explanation:** The sorted form of the array is \\[1,3,6,9\\], either (3,6) or (6,9) has the maximum difference 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10\\]\n**Output:** 0\n**Explanation:** The array contains less than 2 elements, therefore return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Bucket Sort",
            "Radix Sort"
        ],
        "example": [
            {
                "input": "[3,6,9,1]",
                "output": "3"
            },
            {
                "input": "[10]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "python": "\n    ```python\ndef maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "js": "\n    ```javascript\nfunction maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    "
    },
    {
        "id": 33,
        "title": "Dungeon Game",
        "difficulty": "Hard",
        "content": {
            "problem": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",
            "examples": [
                "**Example 1:**\n\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n",
                "**Example 2:**\n\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[-2,-3,3],[-5,-10,1],[10,30,-5]]",
                "output": "7"
            },
            {
                "input": "[[0]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "python": "\n    ```python\ndef calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "js": "\n    ```javascript\nfunction calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    "
    },
    {
        "id": 34,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n",
                "**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "2,[2,4,1]",
                "output": "2"
            },
            {
                "input": "2,[3,2,6,5,0,3]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "python": "\n    ```python\ndef maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    "
    },
    {
        "id": 35,
        "title": "Word Search II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.\n\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"o \", \"a \", \"a \", \"n \"\\],\\[ \"e \", \"t \", \"a \", \"e \"\\],\\[ \"i \", \"h \", \"k \", \"r \"\\],\\[ \"i \", \"f \", \"l \", \"v \"\\]\\], words = \\[ \"oath \", \"pea \", \"eat \", \"rain \"\\]\n**Output:** \\[ \"eat \", \"oath \"\\]\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \"a \", \"b \"\\],\\[ \"c \", \"d \"\\]\\], words = \\[ \"abcb \"\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 12`\n*   `board[i][j]` is a lowercase English letter.\n*   `1 <= words.length <= 3 * 104`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are unique.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Backtracking",
            "Trie",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]],[\"oath\",\"pea\",\"eat\",\"rain\"]",
                "output": "[\"eat\",\"oath\"]"
            },
            {
                "input": "[[\"a\",\"b\"],[\"c\",\"d\"]],[\"abcb\"]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}\n\nprivate boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, 0, i, j, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean found =\n            dfs(board, word, index + 1, i - 1, j, visited) ||\n            dfs(board, word, index + 1, i + 1, j, visited) ||\n            dfs(board, word, index + 1, i, j - 1, visited) ||\n            dfs(board, word, index + 1, i, j + 1, visited);\n    visited[i][j] = false;\n    return found;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "python": "\n    ```python\ndef findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){\n    if (index == word.length()) {\n        found = true;\n        return;\n    }\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){\n        return;\n    }\n    visited[i][j] = true;\n    dfs(board, word, index + 1, i - 1, j, visited, found);\n    dfs(board, word, index + 1, i + 1, j, visited, found);\n    dfs(board, word, index + 1, i, j - 1, visited, found);\n    dfs(board, word, index + 1, i, j + 1, visited, found);\n    visited[i][j] = false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "js": "\n    ```javascript\nfunction findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    "
    },
    {
        "id": 36,
        "title": "Shortest Palindrome",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s`. You can convert `s` to a palindrome by adding characters in front of it.\n\nReturn _the shortest palindrome you can find by performing this transformation_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"aacecaaa\"\n**Output:** \"aaacecaaa\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\"\n**Output:** \"dcbabcd\""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of lowercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Rolling Hash",
            "String Matching",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"aacecaaa\"",
                "output": "\"aaacecaaa\""
            },
            {
                "input": "\"abcd\"",
                "output": "\"dcbabcd\""
            }
        ],
        "java": "\n    ```java\npublic String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "python": "\n    ```python\ndef shortest_palindrome(s: str) -> str:\n    n = len(s)\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        if s[:n - i] == rev_s[i:]:\n            return rev_s[:i] + s\n    return \"\"\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string shortestPalindrome(std::string s) {\n    int n = s.size();\n    std::string rev_s = s;\n    std::reverse(rev_s.begin(), rev_s.end());\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substr(0, n - i) == rev_s.substr(i))\n            return rev_s.substr(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "js": "\n    ```javascript\nfunction shortestPalindrome(s) {\n    let n = s.length;\n    let rev_s = s.split('').reverse().join('');\n    \n    for (let i = 0; i < n; ++i) {\n        if (s.slice(0, n - i) === rev_s.slice(i))\n            return rev_s.slice(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    "
    },
    {
        "id": 37,
        "title": "The Skyline Problem",
        "difficulty": "Hard",
        "content": {
            "problem": "A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return _the **skyline** formed by these buildings collectively_.\n\nThe geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n\n*   `lefti` is the x coordinate of the left edge of the `ith` building.\n*   `righti` is the x coordinate of the right edge of the `ith` building.\n*   `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n\nThe **skyline** should be represented as a list of \"key points \" **sorted by their x-coordinate** in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n**Note:** There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`",
            "examples": [
                "**Example 1:**\n\n**Input:** buildings = \\[\\[2,9,10\\],\\[3,7,15\\],\\[5,12,12\\],\\[15,20,10\\],\\[19,24,8\\]\\]\n**Output:** \\[\\[2,10\\],\\[3,15\\],\\[7,12\\],\\[12,0\\],\\[15,10\\],\\[20,8\\],\\[24,0\\]\\]\n**Explanation:**\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n",
                "**Example 2:**\n\n**Input:** buildings = \\[\\[0,2,3\\],\\[2,5,3\\]\\]\n**Output:** \\[\\[0,3\\],\\[5,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= buildings.length <= 104`\n*   `0 <= lefti < righti <= 231 - 1`\n*   `1 <= heighti <= 231 - 1`\n*   `buildings` is sorted by `lefti` in non-decreasing order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Line Sweep",
            "Heap (Priority Queue)",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]",
                "output": "[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]"
            },
            {
                "input": "[[0,2,3],[2,5,3]]",
                "output": "[[0,3],[5,0]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<int[]> points = new ArrayList<>();\n        for (int[] b : buildings) {\n            points.add(new int[]{b[0], -b[2]});\n            points.add(new int[]{b[1], b[2]});\n        }\n        Collections.sort(points, (a, b) -> a[0] - b[0]);\n        TreeSet<Integer> heights = new TreeSet<>(Collections.reverseOrder());\n        heights.add(0);\n        int prev = 0;\n        List<List<Integer>> skyline = new ArrayList<>();\n        for (int[] point : points) {\n            int x = point[0], h = point[1];\n            if (h < 0)\n                heights.add(-h);\n            else\n                heights.remove(h);\n            int cur = heights.first();\n            if (cur != prev) {\n                skyline.add(Arrays.asList(x, cur));\n                prev = cur;\n            }\n        }\n        return skyline;\n    }\n}\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef getSkyline(buildings):\n    points = []\n    for l, r, h in buildings:\n        points.append((l, -h))\n        points.append((r, h))\n    points.sort()\n    heights = SortedList([0])\n    prev = 0\n    skyline = []\n    for x, h in points:\n        if h < 0:\n            heights.add(-h)\n        else:\n            heights.remove(h)\n        cur = heights[-1]\n        if cur != prev:\n            skyline.append([x, cur])\n            prev = cur\n    return skyline\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n    vector<pair<int, int>> points;\n    for (const auto &b : buildings) {\n        points.emplace_back(b[0], -b[2]);\n        points.emplace_back(b[1], b[2]);\n    }\n    sort(points.begin(), points.end());\n    multiset<int> heights = {0};\n    int prev = 0;\n    vector<vector<int>> skyline;\n    for (const auto &[x, h] : points) {\n        if (h < 0)\n            heights.insert(-h);\n        else\n            heights.erase(heights.find(h));\n        int cur = *heights.rbegin();\n        if (cur != prev) {\n            skyline.push_back({x, cur});\n            prev = cur;\n        }\n    }\n    return skyline;\n}\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    ",
        "js": "\n    ```javascript\nfunction getSkyline(buildings) {\n    const points = [];\n    for (const [l, r, h] of buildings) {\n        points.push([l, -h]);\n        points.push([r, h]);\n    }\n    points.sort((a, b) => a[0] - b[0]);\n    const heights = new SortedSet([0]);\n    let prev = 0;\n    const skyline = [];\n    for (const [x, h] of points) {\n        if (h < 0) {\n            heights.add(-h);\n        } else {\n            heights.delete(h);\n        }\n        const cur = heights.last();\n        if (cur !== prev) {\n            skyline.push([x, cur]);\n            prev = cur;\n        }\n    }\n    return skyline;\n}\n```\n    \n    The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height.\n    "
    },
    {
        "id": 38,
        "title": "Contains Duplicate III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and two integers `indexDiff` and `valueDiff`.\n\nFind a pair of indices `(i, j)` such that:\n\n*   `i != j`,\n*   `abs(i - j) <= indexDiff`.\n*   `abs(nums[i] - nums[j]) <= valueDiff`, and\n\nReturn `true` _if such pair exists or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], indexDiff = 3, valueDiff = 0\n**Output:** true\n**Explanation:** We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums\\[i\\] - nums\\[j\\]) <= valueDiff --> abs(1 - 1) <= 0\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,9,1,5,9\\], indexDiff = 2, valueDiff = 3\n**Output:** false\n**Explanation:** After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `1 <= indexDiff <= nums.length`\n*   `0 <= valueDiff <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sliding Window",
            "Sorting",
            "Bucket Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[1,2,3,1],3,0",
                "output": "true"
            },
            {
                "input": "[1,5,9,1,5,9],2,3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Long> window = new TreeSet<>();\n    for(int i = 0; i < nums.length; i++) {\n        if(i > k) {\n            window.remove((long)nums[i - k - 1]);\n        }\n        Long ceil = window.ceiling((long)nums[i] - t);\n        if(ceil != null && ceil - nums[i] <= t) {\n            return true;\n        }\n        window.add((long)nums[i]);\n    }\n    return false;\n}\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    window = SortedList()\n    for i in range(len(nums)):\n        if i > k:\n            window.remove(nums[i - k - 1])\n        pos = window.bisect_left(nums[i] - t)\n        if pos != len(window) and window[pos] - nums[i] <= t:\n            return True\n        window.add(nums[i])\n    return False\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    set<long> window;\n    for (int i = 0; i < nums.size(); i++) {\n        if (i > k) {\n            window.erase(nums[i - k - 1]);\n        }\n        auto pos = window.lower_bound((long)nums[i] - t);\n        if (pos != window.end() && *pos - nums[i] <= t) {\n            return true;\n        }\n        window.insert(nums[i]);\n    }\n    return false;\n}\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    ",
        "js": "\n    ```javascript\nfunction containsNearbyAlmostDuplicate(nums, k, t) {\n    let window = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        if (i > k) {\n            window.delete(nums[i - k - 1]);\n        }\n        for (const num of window) {\n            if (Math.abs(num - nums[i]) <= t) {\n                return true;\n            }\n        }\n        window.add(nums[i]);\n    }\n    return false;\n}\n```\n    \n    In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available.\n    "
    },
    {
        "id": 39,
        "title": "Basic Calculator",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return _the result of the evaluation_.\n\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1 + 1 \"\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** s =  \" 2-1 + 2  \"\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** s =  \"(1+(4+5+2)-3)+(6+8) \"\n**Output:** 23"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n*   `s` represents a valid expression.\n*   `'+'` is **not** used as a unary operation (i.e., `\"+1 \"` and `\"+(2 + 3) \"` is invalid).\n*   `'-'` could be used as a unary operation (i.e., `\"-1 \"` and `\"-(2 + 3) \"` is valid).\n*   There will be no two consecutive operators in the input.\n*   Every number and running calculation will fit in a signed 32-bit integer.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"1+1\"",
                "output": "2"
            },
            {
                "input": "\"2-1+2\"",
                "output": "3"
            },
            {
                "input": "\"(1+(4+5+2)-3)+(6+8)\"",
                "output": "23"
            }
        ],
        "java": "\n    ```java\npublic int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "python": "\n    ```python\ndef calculate(s: str) -> int:\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "c++": "\n    ```cpp\nint calculate(string s) {\n    int result = 0, sign = 1, num = 0;\n    stack<int> st;\n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.top();\n                st.pop();\n                int prev_result = st.top();\n                st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "js": "\n    ```javascript\nfunction calculate(s) {\n    let result = 0, sign = 1, num = 0;\n    let st = [];\n    for (let c of s) {\n        if (/\\d/.test(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c === '+') {\n                sign = 1;\n            } else if (c === '-') {\n                sign = -1;\n            } else if (c === '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c === ')') {\n                let prev_sign = st.pop();\n                let prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    "
    },
    {
        "id": 40,
        "title": "Number of Digit One",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Recursion"
        ],
        "example": [
            {
                "input": "13",
                "output": "6"
            },
            {
                "input": "0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "python": "\n    ```python\ndef countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "c++": "\n    ```cpp\nint countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "js": "\n    ```javascript\nfunction countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    "
    },
    {
        "id": 41,
        "title": "Sliding Window Maximum",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn _the max sliding window_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,-1,-3,5,3,6,7\\], k = 3\n**Output:** \\[3,3,5,5,6,7\\]\n**Explanation:** \nWindow position                Max\n---------------               -----\n\\[1  3  -1\\] -3  5  3  6  7       **3**\n 1 \\[3  -1  -3\\] 5  3  6  7       **3**\n 1  3 \\[-1  -3  5\\] 3  6  7      ** 5**\n 1  3  -1 \\[-3  5  3\\] 6  7       **5**\n 1  3  -1  -3 \\[5  3  6\\] 7       **6**\n 1  3  -1  -3  5 \\[3  6  7\\]      **7**\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[1,3,-1,-3,5,3,6,7],3",
                "output": "[3,3,5,5,6,7]"
            },
            {
                "input": "[1],1",
                "output": "[1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Deque;\n\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    if (nums == null || nums.length == 0) return new int[0];\n    int[] result = new int[nums.length - k + 1];\n    int idx = 0;\n    Deque<Integer> deque = new LinkedList<Integer>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        if (!deque.isEmpty() && deque.peekFirst() == i - k) deque.poll();\n            \n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.removeLast();\n        }    \n            \n        deque.offer(i);\n        if (i >= k - 1) {\n            result[idx++] = nums[deque.peek()];\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n\n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n\n        dq.append(i)\n\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <deque>\n\nstd::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n    std::vector<int> result;\n    std::deque<int> dq;\n\n    for (int i = 0; i < nums.size(); i++) {\n        while (!dq.empty() && dq.front() < i - k + 1) {\n            dq.pop_front();\n        }\n\n        while (!dq.empty() && nums[dq.back()] < nums[i]) {\n            dq.pop_back();\n        }\n\n        dq.push_back(i);\n\n        if (i >= k - 1) {\n            result.push_back(nums[dq.front()]);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    ",
        "js": "\n    ```javascript\nfunction maxSlidingWindow(nums, k) {\n  let result = [];\n  let dq = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    while (dq.length && dq[0] < i - k + 1) {\n      dq.shift();\n    }\n\n    while (dq.length && nums[dq[dq.length - 1]] < nums[i]) {\n      dq.pop();\n    }\n\n    dq.push(i);\n\n    if (i >= k - 1) {\n      result.push(nums[dq[0]]);\n    }\n  }\n\n  return result;\n}\n```\n\n    \n    1. Create an empty deque (double-ended queue) and an empty results list.\n2. Iterate through the given array.\n3. Remove the elements that are out of the current window from the front of the deque.\n4. Remove the elements that are smaller than the current element from the back of the deque.\n5. Push the current index into the deque.\n6. If the current index is greater than or equal to k-1 (window size), add the front element of deque into the results list.\n7. Return the results list after iterating through the entire array. \n\nThe deque will keep track of the indices of the maximum elements in the current window. At each step, the first element in the deque will be the index of the maximum element in the current window.\n    "
    },
    {
        "id": 42,
        "title": "Alien Dictionary",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language.\n\nReturn _a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules._ If there is no solution, return `\" \"`_._ If there are multiple solutions, return _**any of them**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"wrt \", \"wrf \", \"er \", \"ett \", \"rftt \"\\]\n**Output:**  \"wertf \"\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"z \", \"x \"\\]\n**Output:**  \"zx \"\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"z \", \"x \", \"z \"\\]\n**Output:**  \" \"\n**Explanation:** The order is invalid, so return ` \" \"`."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String"
        ],
        "example": [
            {
                "input": "[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
                "output": "\"wertf\""
            },
            {
                "input": "[\"z\",\"x\"]",
                "output": "\"zx\""
            },
            {
                "input": "[\"z\",\"x\",\"z\"]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String alienOrder(String[] words) {\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    Map<Character, Integer> inDegree = new HashMap<>();\n    \n    for (String word : words) {\n        for (char c : word.toCharArray())\n            inDegree.put(c, 0);\n    }\n    \n    for (int i = 0; i < words.length - 1; i++) {\n        String word1 = words[i], word2 = words[i + 1];\n        \n        boolean found = false;\n        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n            char c1 = word1.charAt(j), c2 = word2.charAt(j);\n            if (c1 != c2) {\n                graph.putIfAbsent(c1, new HashSet<>());\n                if (!graph.get(c1).contains(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.put(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length() > word2.length())\n            return \"\";\n    }\n\n    Queue<Character> q = new LinkedList<>();\n    for (Map.Entry<Character, Integer> entry : inDegree.entrySet())\n        if (entry.getValue() == 0)\n            q.offer(entry.getKey());\n    \n    StringBuilder result = new StringBuilder();\n    while (!q.isEmpty()) {\n        char c = q.poll();\n        result.append(c);\n        \n        if (graph.containsKey(c)) {\n            for (char neigh : graph.get(c)) {\n                inDegree.put(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) == 0)\n                    q.offer(neigh);\n            }\n        }\n    }\n    \n    if (result.length() < inDegree.size())\n        return \"\";\n    \n    return result.toString();\n}\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    ",
        "python": "\n    ```python\nfrom collections import deque, defaultdict, Counter\n\ndef alienOrder(words):\n    graph = defaultdict(set)\n    in_degree = Counter({c: 0 for word in words for c in word})\n    \n    for word1, word2 in zip(words, words[1:]):\n        found = False\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    in_degree[c2] += 1\n                found = True\n                break\n        if not found and len(word1) > len(word2):\n            return \"\"\n    \n    q = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    while q:\n        c = q.popleft()\n        result.append(c)\n        \n        for neigh in graph[c]:\n            in_degree[neigh] -= 1\n            if in_degree[neigh] == 0:\n                q.append(neigh)\n                 \n    if len(result) < len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nstd::string alienOrder(std::vector<std::string> &words) {\n    std::unordered_map<char, std::unordered_set<char>> graph;\n    std::unordered_map<char, int> inDegree;\n    \n    for (const std::string &word : words)\n        for (char c : word)\n            inDegree[c] = 0;\n    \n    for (int i = 0; i < words.size() - 1; i++) {\n        std::string word1 = words[i], word2 = words[i + 1];\n        \n        bool found = false;\n        for (int j = 0; j < std::min(word1.size(), word2.size()); j++) {\n            char c1 = word1[j], c2 = word2[j];\n            if (c1 != c2) {\n                if (!graph[c1].count(c2)) {\n                    graph[c1].insert(c2);\n                    inDegree[c2]++;\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.size() > word2.size())\n            return \"\";\n    }\n\n    std::queue<char> q;\n    for (auto &[c, deg] : inDegree)\n        if (deg == 0)\n            q.push(c);\n    \n    std::string result;\n    while (!q.empty()) {\n        char c = q.front();\n        q.pop();\n        result += c;\n        \n        for (char neigh : graph[c]) {\n            inDegree[neigh]--;\n            if (inDegree[neigh] == 0)\n                q.push(neigh);\n        }\n    }\n    \n    if (result.size() < inDegree.size())\n        return \"\";\n    \n    return result;\n}\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    ",
        "js": "\n    ```javascript\nfunction alienOrder(words) {\n    const graph = new Map();\n    const inDegree = new Map();\n    \n    for (const word of words)\n        for (const c of word)\n            inDegree.set(c, 0);\n    \n    for (let i = 0; i < words.length - 1; i++) {\n        const word1 = words[i], word2 = words[i + 1];\n        \n        let found = false;\n        for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n            const c1 = word1[j], c2 = word2[j];\n            if (c1 !== c2) {\n                if (!graph.has(c1)) graph.set(c1, new Set());\n                if (!graph.get(c1).has(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.set(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length > word2.length)\n            return \"\";\n    }\n\n    const q = [];\n    for (const [c, deg] of inDegree.entries())\n        if (deg === 0)\n            q.push(c);\n    \n    let result = \"\";\n    while (q.length) {\n        const c = q.shift();\n        result += c;\n        \n        if (graph.has(c)) {\n            for (const neigh of graph.get(c)) {\n                inDegree.set(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) === 0)\n                    q.push(neigh);\n            }\n        }\n    }\n    \n    if (result.length < inDegree.size)\n        return \"\";\n    \n    return result;\n}\n```\n    \n    The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string.\n    "
    },
    {
        "id": 43,
        "title": "Integer to English Words",
        "difficulty": "Hard",
        "content": {
            "problem": "Convert a non-negative integer `num` to its English words representation.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 123\n**Output:**  \"One Hundred Twenty Three \"\n\n",
                "**Example 2:**\n\n**Input:** num = 12345\n**Output:**  \"Twelve Thousand Three Hundred Forty Five \"\n\n",
                "**Example 3:**\n\n**Input:** num = 1234567\n**Output:**  \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Recursion"
        ],
        "example": [
            {
                "input": "123",
                "output": "\"OneHundredTwentyThree\""
            },
            {
                "input": "12345",
                "output": "\"TwelveThousandThreeHundredFortyFive\""
            },
            {
                "input": "1234567",
                "output": "\"OneMillionTwoHundredThirtyFourThousandFiveHundredSixtySeven\""
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    private final String[] LESS_THAN_20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    private final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    private final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        StringBuilder result = new StringBuilder();\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result.insert(0, helper(num % 1000) + THOUSANDS[i] + \" \");\n            }\n            num /= 1000;\n            i++;\n        }\n        return result.toString().trim();\n    }\n\n    private String helper(int num) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return LESS_THAN_20[num] + \" \";\n        } else if (num < 100) {\n            return TENS[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n}\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return LESS_THAN_20[num] + \" \"\n            elif num < 100:\n                return TENS[num // 10] + \" \" + helper(num % 10)\n            else:\n                return LESS_THAN_20[num // 100] + \" Hundred \" + helper(num % 100)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    std::string numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        std::string result;\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result;\n            }\n            num /= 1000;\n            i++;\n        }\n        return trim(result);\n    }\n\nprivate:\n    std::vector<std::string> LESS_THAN_20 = {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\n    };\n    std::vector<std::string> TENS = {\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\n    };\n    std::vector<std::string> THOUSANDS = {\n        \"\", \"Thousand\", \"Million\", \"Billion\"\n    };\n\n    std::string helper(int num) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return LESS_THAN_20[num] + \" \";\n        } else if (num < 100) {\n            return TENS[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n\n    std::string trim(const std::string& str) {\n        return str.substr(0, str.find_last_not_of(' ') + 1);\n    }\n};\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    numberToWords(num) {\n        if (num === 0) return \"Zero\";\n\n        const LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\n        const TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\n        const THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"];\n\n        function helper(num) {\n            if (num === 0) {\n                return \"\";\n            } else if (num < 20) {\n                return LESS_THAN_20[num] + \" \";\n            } else if (num < 100) {\n                return TENS[Math.floor(num / 10)] + \" \" + helper(num % 10);\n            } else {\n                return LESS_THAN_20[Math.floor(num / 100)] + \" Hundred \" + helper(num % 100);\n            }\n        }\n\n        let result = \"\";\n        let i = 0;\n        while (num > 0) {\n            if (num % 1000 !== 0) {\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result;\n            }\n            num = Math.floor(num / 1000);\n            i++;\n        }\n        return result.trim();\n    }\n}\n```\n    \n    The algorithm uses a divide-and-conquer approach, where the given integer is broken down into smaller chunks, based on the powers of thousand (thousands, millions, and billions). By using the integer division and modulo, it determines how many times each chunk occurs in the number. Then, for each chunk, it constructs a word representation using the lookup tables for LESS_THAN_20, TENS, and THOUSANDS, and combines these words into the final string. Finally, it trims any extra spaces from the result.\n\nThis algorithm uses an iterative approach to go through each step of the powers of thousand.\n    "
    },
    {
        "id": 44,
        "title": "Expression Add Operators",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `num` that contains only digits and an integer `target`, return _**all possibilities** to insert the binary operators_ `'+'`_,_ `'-'`_, and/or_ `'*'` _between the digits of_ `num` _so that the resultant expression evaluates to the_ `target` _value_.\n\nNote that operands in the returned expressions **should not** contain leading zeros.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"123 \", target = 6\n**Output:** \\[ \"1\\*2\\*3 \", \"1+2+3 \"\\]\n**Explanation:** Both  \"1\\*2\\*3 \" and  \"1+2+3 \" evaluate to 6.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"232 \", target = 8\n**Output:** \\[ \"2\\*3+2 \", \"2+3\\*2 \"\\]\n**Explanation:** Both  \"2\\*3+2 \" and  \"2+3\\*2 \" evaluate to 8.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"3456237490 \", target = 9191\n**Output:** \\[\\]\n**Explanation:** There are no expressions that can be created from  \"3456237490 \" to evaluate to 9191."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 10`\n*   `num` consists of only digits.\n*   `-231 <= target <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Backtracking"
        ],
        "example": [
            {
                "input": "\"123\",6",
                "output": "[\"1*2*3\",\"1+2+3\"]"
            },
            {
                "input": "\"232\",8",
                "output": "[\"2*3+2\",\"2+3*2\"]"
            },
            {
                "input": "\"3456237490\",9191",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> addOperators(String num, int target) {\n    List<String> res = new ArrayList<>();\n    helper(num, target, 0, 0, 0, \"\", res);\n    return res;\n}\n\nprivate void helper(String num, int target, int pos, long currVal, long prevVal, String currExpr, List<String> res) {\n    if (pos == num.length()) {\n        if (currVal == target) {\n            res.add(currExpr);\n        }\n        return;\n    }\n\n    for (int i = pos; i < num.length(); ++i) {\n        if (i != pos && num.charAt(pos) == '0') break;\n        long val = Long.parseLong(num.substring(pos, i + 1));\n        if (pos == 0) {\n            helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1), res);\n        } else {\n            helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substring(pos, i + 1), res);\n            helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substring(pos, i + 1), res);\n            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substring(pos, i + 1), res);\n        }\n    }\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef addOperators(num: str, target: int) -> List[str]:\n    def helper(num, target, pos, currVal, prevVal, currExpr):\n        if pos == len(num):\n            if currVal == target:\n                res.append(currExpr)\n            return\n\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':\n                break\n\n            val = int(num[pos:i + 1])\n            if pos == 0:\n                helper(num, target, i + 1, val, val, currExpr + num[pos:i + 1])\n            else:\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num[pos:i + 1])\n\n    res = []\n    helper(num, target, 0, 0, 0, \"\")\n    return res\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nvoid helper(const std::string &num, int target, int pos, long long currVal, long long prevVal, std::string currExpr, std::vector<std::string> &res) {\n    if (pos == num.size()) {\n        if (currVal == target) {\n            res.push_back(currExpr);\n        }\n        return;\n    }\n\n    for (int i = pos; i < num.size(); ++i) {\n        if (i != pos && num[pos] == '0') break;\n        long long val = std::stoll(num.substr(pos, i - pos + 1));\n        if (pos == 0) {\n            helper(num, target, i + 1, val, val, currExpr + num.substr(pos, i - pos + 1), res);\n        } else {\n            helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substr(pos, i - pos + 1), res);\n            helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substr(pos, i - pos + 1), res);\n            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substr(pos, i - pos + 1), res);\n        }\n    }\n}\n\nstd::vector<std::string> addOperators(std::string num, int target) {\n    std::vector<std::string> res;\n    helper(num, target, 0, 0, 0, \"\", res);\n    return res;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    ",
        "js": "\n    ```javascript\nvar addOperators = function(num, target) {\n    const res = [];\n    const helper = (num, target, pos, currVal, prevVal, currExpr) => {\n        if (pos === num.length) {\n            if (currVal === target) {\n                res.push(currExpr);\n            }\n            return;\n        }\n\n        for (let i = pos; i < num.length; ++i) {\n            if (i !== pos && num[pos] === '0') break;\n\n            const val = parseInt(num.substring(pos, i + 1));\n            if (pos === 0) {\n                helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1));\n            } else {\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substring(pos, i + 1));\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substring(pos, i + 1));\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substring(pos, i + 1));\n            }\n        }\n    }\n\n    helper(num, target, 0, 0, 0, \"\");\n    return res;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We initialize a helper function with the initial parameters, such as the starting position, expression, and running sum. The helper function is then called recursively for each possible operator insertion. When the position reaches the end of the input string, we check if the running sum equals the target. If it does, we add the current expression to the result.\n\nWe use these parameters in the helper function:\n\n- `pos`: The current position in the input string\n- `currVal`: The current value of the expression up until this point\n- `prevVal`: The value before the last operator we inserted\n- `currExpr`: The expression string that we are building up\n\nTo avoid leading zeros in operands, we use a check to terminate the loop if we encounter a zero at the start.\n\nInside the helper function, we iterate over the possible next positions ('i') in the input string and decide which operation to perform at the current position:\n\n1. Base case: When the current position is 0, we simply update the current value and expression with no operator.\n2. Addition: We update the current value by adding the parsed value, and append \"+\" followed by the substring to the expression.\n3. Subtraction: We update the current value by subtracting the parsed value, and append \"-\" followed by the substring to the expression.\n4. Multiplication: We update the current value by first subtracting the previous value, then adding the product of the previous value and the parsed value, and append \"*\" followed by the substring to the expression.\n\nAfter the helper function iterates through all possibilities, we return the result as a list of expressions that evaluate to the target value.\n    "
    },
    {
        "id": 45,
        "title": "Find Median from Data Stream",
        "difficulty": "Hard",
        "content": {
            "problem": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n*   For example, for `arr = [2,3,4]`, the median is `3`.\n*   For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n\n*   `MedianFinder()` initializes the `MedianFinder` object.\n*   `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n*   `double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MedianFinder \",  \"addNum \",  \"addNum \",  \"findMedian \",  \"addNum \",  \"findMedian \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[3\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 1.5, null, 2.0\\]\n\n**Explanation**\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = \\[1\\]\nmedianFinder.addNum(2);    // arr = \\[1, 2\\]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr\\[1, 2, 3\\]\nmedianFinder.findMedian(); // return 2.0"
            ],
            "constraints": "**Constraints:**\n\n*   `-105 <= num <= 105`\n*   There will be at least one element in the data structure before calling `findMedian`.\n*   At most `5 * 104` calls will be made to `addNum` and `findMedian`.\n\n**",
            "follow_up": "Follow up:**\n\n*   If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?\n*   If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?"
        },
        "tag": [
            "Two Pointers",
            "Design",
            "Sorting",
            "Heap (Priority Queue)",
            "Data Stream"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,1.5,null,2.0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass MedianFinder {\n    PriorityQueue<Integer> left;\n    PriorityQueue<Integer> right;\n\n    public MedianFinder() {\n        left = new PriorityQueue<>((a, b) -> b.compareTo(a));\n        right = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        if (left.isEmpty() || num <= left.peek()) {\n            left.offer(num);\n        } else {\n            right.offer(num);\n        }\n        \n        if (left.size() < right.size()) {\n            left.offer(right.poll());\n        } else if (left.size() > right.size() + 1) {\n            right.offer(left.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (left.size() == right.size()) {\n            return (left.peek() + right.peek()) / 2.0;\n        } else {\n            return left.peek();\n        }\n    }\n}\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    ",
        "python": "\n    ```python\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.left = []  # max heap\n        self.right = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        if not self.left or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n        else:\n            heapq.heappush(self.right, num)\n        \n        if len(self.left) < len(self.right):\n            heapq.heappush(self.left, -heapq.heappop(self.right))\n        elif len(self.left) > len(self.right) + 1:\n            heapq.heappush(self.right, -heapq.heappop(self.left))\n\n    def findMedian(self) -> float:\n        if len(self.left) == len(self.right):\n            return (-self.left[0] + self.right[0]) / 2\n        else:\n            return -self.left[0]\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\nusing namespace std;\n\nclass MedianFinder {\npublic:\n    /** initialize your data structure here. */\n    priority_queue<int> left;\n    priority_queue<int, vector<int>, greater<int> > right;\n    \n    MedianFinder() {}\n    \n    void addNum(int num) {\n        if (left.empty() || num <= left.top()) {\n            left.push(num);\n        } else {\n            right.push(num);\n        }\n        \n        if (left.size() < right.size()) {\n            left.push(right.top());\n            right.pop();\n        } else if (left.size() > right.size() + 1) {\n            right.push(left.top());\n            left.pop();\n        }\n    }\n    \n    double findMedian() {\n        if(left.size() == right.size()){\n            return ((double)left.top() + (double)right.top()) / 2;\n        }\n        else{\n            return left.top();\n        }\n    }\n};\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    ",
        "js": "\n    ```javascript\nclass MedianFinder {\n    constructor() {\n        this.left = new MaxPriorityQueue();\n        this.right = new MinPriorityQueue();\n    }\n    \n    addNum(num) {\n        if (this.left.isEmpty() || num <= this.left.peek().element) {\n            this.left.enqueue(num);\n        } else {\n            this.right.enqueue(num);\n        }\n        \n        if (this.left.size() < this.right.size()) {\n            this.left.enqueue(this.right.dequeue().element);\n        } else if (this.left.size() > this.right.size() + 1) {\n            this.right.enqueue(this.left.dequeue().element);\n        }\n    }\n    \n    findMedian() {\n        if (this.left.size() === this.right.size()) {\n            return (this.left.peek().element + this.right.peek().element) / 2.0;\n        } else {\n            return this.left.peek().element;\n        }\n    }\n}\n```\n\n    \n    The algorithm for solving the median in a list of integers works by maintaining two heaps, a max-heap for the left half and a min-heap for the right half. When a new number is added, it is compared to the max value of the left max-heap. If the number is smaller or equal, it is added to the left heap. If the number is larger, it is added to the right min-heap. Then, we balance the two heaps by ensuring that their sizes never differ by more than one. This ensures that the median is always easily accessible as either the largest value in the left heap or the average of the largest value in the left heap and the smallest value in the right heap. The algorithm has an O(log N) time complexity, where N is the number of elements in the list.\n    "
    },
    {
        "id": 46,
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,null,null,4,5\\]\n**Output:** \\[1,2,3,null,null,4,5\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Design",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,null,null,4,5]",
                "output": "[1,2,3,null,null,4,5]"
            },
            {
                "input": "[]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Arrays;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic String serialize(TreeNode root) {\n    if (root == null) return \"null,\";\n    return root.val + \",\" + serialize(root.left) + serialize(root.right);\n}\n\npublic TreeNode deserialize(String data) {\n    Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n    return deserializeHelper(queue);\n}\n\nprivate TreeNode deserializeHelper(Queue<String> queue) {\n    String val = queue.poll();\n    if (val.equals(\"null\")) return null;\n    TreeNode root = new TreeNode(Integer.parseInt(val));\n    root.left = deserializeHelper(queue);\n    root.right = deserializeHelper(queue);\n    return root;\n}\n```\n\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root: return \"null,\"\n    return str(root.val) + \",\" + serialize(root.left) + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = values.pop(0)\n        if val == 'null': return None\n        root = TreeNode(int(val))\n        root.left = deserialize_helper(values)\n        root.right = deserialize_helper(values)\n        return root\n\n    values = data.split(\",\")\n    return deserialize_helper(values[:-1])  # Excluding the last empty element\n```\n\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    ",
        "c++": "\n    ```cpp\n#include <sstream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstring serialize(TreeNode* root) {\n    if (!root) return \"null,\";\n    return to_string(root->val) + \",\" + serialize(root->left) + serialize(root->right);\n}\n\nTreeNode* deserialize(string data) {\n    istringstream is(data);\n    return deserializeHelper(is);\n}\n\nTreeNode* deserializeHelper(istringstream& is) {\n    string val;\n    if (!getline(is, val, ',')) return nullptr;\n    if (val == \"null\") return nullptr;\n    TreeNode* root = new TreeNode(stoi(val));\n    root->left = deserializeHelper(is);\n    root->right = deserializeHelper(is);\n    return root;\n}\n```\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction serialize(root) {\n    if (!root) return \"null,\";\n    return root.val + \",\" + serialize(root.left) + serialize(root.right);\n}\n\nfunction deserialize(data) {\n    const values = data.split(\",\");\n\n    function deserializeHelper() {\n        const val = values.shift();\n        if (val === \"null\") return null;\n        const root = new TreeNode(parseInt(val));\n        root.left = deserializeHelper();\n        root.right = deserializeHelper();\n        return root;\n    }\n\n    return deserializeHelper();\n}\n```\n\n    \n    The algorithm uses a Depth-First Search traversal (specifically, pre-order) to serialize the binary tree into a comma-separated string. Each empty node is represented by a \"null\" string.\n\nTo deserialize the data string back into a tree structure, the algorithm processes the comma-separated string and interprets each item it encounters. If the item is \"null\", it sets the node to null. Otherwise, it creates a TreeNode with the value and recursively sets left and right children. The deserialization also uses a pre-order traversal, which corresponds to the serialized string format. This approach ensures that the deserialized tree retains the same structure as the original tree.\n    "
    },
    {
        "id": 47,
        "title": "Remove Invalid Parentheses",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\nReturn _a list of **unique strings** that are valid with the minimum number of removals_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"()())() \"\n**Output:** \\[ \"(())() \", \"()()() \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"(a)())() \"\n**Output:** \\[ \"(a())() \", \"(a)()() \"\\]\n\n",
                "**Example 3:**\n\n**Input:** s =  \")( \"\n**Output:** \\[ \" \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 25`\n*   `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n*   There will be at most `20` parentheses in `s`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"()())()\"",
                "output": "[\"(())()\",\"()()()\"]"
            },
            {
                "input": "\"(a)())()\"",
                "output": "[\"(a())()\",\"(a)()()\"]"
            },
            {
                "input": "\")(\"",
                "output": "[\"\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        List<String> result = new ArrayList<>();\n        boolean found = false;\n\n        visited.add(s);\n        queue.offer(s);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n\n            if (isValid(current)) {\n                found = true;\n                result.add(current);\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < current.length(); i++) {\n                if (current.charAt(i) == '(' || current.charAt(i) == ')') {\n                    String next = current.substring(0, i) + current.substring(i + 1);\n                    if (!visited.contains(next)) {\n                        visited.add(next);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isValid(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        visited = set()\n        queue = deque([s])\n        result = []\n        found = False\n\n        while queue:\n            cur = queue.popleft()\n\n            if self.is_valid(cur):\n                found = True\n                result.append(cur)\n\n            if found: continue\n\n            for i in range(len(cur)):\n                if cur[i] == '(' or cur[i] == ')':\n                    next_str = cur[:i] + cur[i+1:]\n                    if next_str not in visited:\n                        visited.add(next_str)\n                        queue.append(next_str)\n\n        return result\n\n    def is_valid(self, s: str) -> bool:\n        count = 0\n        for c in s:\n            if c == '(': count += 1\n            if c == ')':\n                count -= 1\n                if count < 0: return False\n        return count == 0\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        set<string> visited;\n        queue<string> q;\n        vector<string> result;\n        bool found = false;\n\n        visited.insert(s);\n        q.push(s);\n\n        while (!q.empty()) {\n            string cur = q.front();\n            q.pop();\n\n            if (isValid(cur)) {\n                found = true;\n                result.push_back(cur);\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < cur.length(); ++i) {\n                if (cur[i] == '(' || cur[i] == ')') {\n                    string next = cur.substr(0, i) + cur.substr(i+1);\n                    if (visited.find(next) == visited.end()) {\n                        visited.insert(next);\n                        q.push(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    bool isValid(const string &s) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n};\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    removeInvalidParentheses(s) {\n        let visited = new Set();\n        let queue = [s];\n        let result = [];\n        let found = false;\n\n        while (queue.length > 0) {\n            let cur = queue.shift();\n\n            if (this.isValid(cur)) {\n                found = true;\n                result.push(cur);\n            }\n\n            if (found) continue;\n\n            for (let i = 0; i < cur.length; i++) {\n                if (cur[i] === '(' || cur[i] === ')') {\n                    let next = cur.slice(0, i) + cur.slice(i + 1);\n                    if (!visited.has(next)) {\n                        visited.add(next);\n                        queue.push(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    isValid(s) {\n        let count = 0;\n        for (let c of s) {\n            if (c === '(') count++;\n            if (c === ')') count--;\n            if (count < 0) return false;\n        }\n        return count === 0;\n    }\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search to find potential valid substrings. It first checks whether the current string is valid. If it finds a valid string, it continues to process any remaining strings in the queue, but it does not generate any more subsequences. If it has not found a valid string, it creates new substrings by removing one parentheses from the current string, adds them to the queue, and marks them as visited to avoid duplicity. This process repeats until the queue is empty or a valid string has been found. A count of open parentheses is maintained to check for string validity. The answer is returned as a list of valid strings.\n    "
    },
    {
        "id": 48,
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,5,8\\]\n**Output:** 167\n**Explanation:**\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 10"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `0 <= nums[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[3,1,5,8]",
                "output": "167"
            },
            {
                "input": "[1,5]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "python": "\n    ```python\ndef maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "c++": "\n    ```cpp\nint maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "js": "\n    ```javascript\nfunction maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    "
    },
    {
        "id": 49,
        "title": "Count of Smaller Numbers After Self",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _an integer array_ `counts` _where_ `counts[i]` _is the number of smaller elements to the right of_ `nums[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,2,6,1\\]\n**Output:** \\[2,1,1,0\\]\n**Explanation:**\nTo the right of 5 there are **2** smaller elements (2 and 1).\nTo the right of 2 there is only **1** smaller element (1).\nTo the right of 6 there is **1** smaller element (1).\nTo the right of 1 there is **0** smaller element.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1\\]\n**Output:** \\[0\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,-1\\]\n**Output:** \\[0,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[5,2,6,1]",
                "output": "[2,1,1,0]"
            },
            {
                "input": "[-1]",
                "output": "[0]"
            },
            {
                "input": "[-1,-1]",
                "output": "[0,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> countSmaller(int[] nums) {\n    int n = nums.length;\n    int[] indices = new int[n];\n    int[] counts = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    \n    mergeSort(nums, indices, counts, 0, n - 1);\n    List<Integer> result = new ArrayList<>();\n    for (int count : counts) {\n        result.add(count);\n    }\n    return result;\n}\n\nprivate void mergeSort(int[] nums, int[] indices, int[] counts, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n    \n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indices, counts, left, mid);\n    mergeSort(nums, indices, counts, mid + 1, right);\n    \n    int[] temp = new int[right - left + 1];\n    int i = left, j = mid + 1, k = 0;\n    while (i <= mid && j <= right) {\n        if (nums[indices[i]] <= nums[indices[j]]) {\n            counts[indices[i]] += j - mid - 1;\n            temp[k++] = indices[i++];\n        } else {\n            temp[k++] = indices[j++];\n        }\n    }\n    \n    while (i <= mid) {\n        counts[indices[i]] += j - mid - 1;\n        temp[k++] = indices[i++];\n    }\n    \n    while (j <= right) {\n        temp[k++] = indices[j++];\n    }\n    \n    System.arraycopy(temp, 0, indices, left, right - left + 1);\n}\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "python": "\n    ```python\ndef countSmaller(nums):\n    def merge_sort(indices):\n        if len(indices) <= 1:\n            return indices\n        mid = len(indices) // 2\n        left = merge_sort(indices[:mid])\n        right = merge_sort(indices[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged, count = [], 0\n        while left and right:\n            if nums[left[0]] <= nums[right[0]]:\n                counts[left[0]] += count\n                merged.append(left.pop(0))\n            else:\n                count += len(left)\n                merged.append(right.pop(0))\n        for i in left:\n            counts[i] += count\n        return merged + left + right\n\n    counts = [0] * len(nums)\n    merge_sort(list(range(len(nums))))\n    return counts\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> countSmaller(vector<int>& nums) {\n    vector<int> result(nums.size(), 0);\n    vector<int> indices(nums.size(), 0);\n\n    for (int i = 0; i < nums.size(); ++i) {\n        indices[i] = i;\n    }\n\n    mergeSort(nums, indices, result, 0, nums.size() - 1);\n    return result;\n}\n\nvoid mergeSort(vector<int>& nums, vector<int>& indices, vector<int>& result, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indices, result, left, mid);\n    mergeSort(nums, indices, result, mid + 1, right);\n\n\n    int I = left;\n    int J = mid + 1;\n    int K = 0;\n    vector<int> temp(right - left + 1);\n    while (I <= mid && J <= right) {\n        if (nums[indices[I]] <= nums[indices[J]]) {\n            result[indices[I]] += (J - mid - 1);\n            temp[K++] = indices[I++];\n        } else {\n            temp[K++] = indices[J++];\n        }\n    }\n\n    while (I <= mid) {\n        result[indices[I]] += (J - mid - 1);\n        temp[K++] = indices[I++];\n    }\n\n    while (J <= right) {\n        temp[K++] = indices[J++];\n    }\n\n    for (int i = left, k = 0; i <= right; ++i, ++k) {\n        indices[i] = temp[k];\n    }\n}\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "js": "\n    ```javascript\nfunction countSmaller(nums) {\n    function mergeSort(indices, start, end) {\n        if (start >= end) {\n            return;\n        }\n\n        let mid = start + ((end - start) >> 1);\n        mergeSort(indices, start, mid);\n        mergeSort(indices, mid + 1, end);\n\n        let i = start, j = mid + 1, k = 0, cnt = 0;\n        let temp = [];\n        while (i <= mid || j <= end) {\n            if (j > end || (i <= mid && nums[indices[i]] <= nums[indices[j]])) {\n                cnt += j - mid - 1;\n                counts[indices[i]] = cnt;\n                temp[k++] = indices[i++];\n            } else {\n                temp[k++] = indices[j++];\n            }\n        }\n\n        for (let i = 0; i < k; i++) {\n            indices[start + i] = temp[i];\n        }\n    }\n    \n    let counts = Array(nums.length).fill(0);\n    let indices = Array.from({length: nums.length}, (_, i) => i);\n    mergeSort(indices, 0, nums.length - 1);\n    return counts;\n}\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    "
    },
    {
        "id": 50,
        "title": "Create Maximum Number",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n\nCreate the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the `k` digits representing the answer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[3,4,6,5\\], nums2 = \\[9,1,2,5,8,3\\], k = 5\n**Output:** \\[9,8,6,5,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[6,7\\], nums2 = \\[6,0,4\\], k = 5\n**Output:** \\[6,7,6,0,4\\]\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[3,9\\], nums2 = \\[8,9\\], k = 3\n**Output:** \\[9,8,9\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == nums1.length`\n*   `n == nums2.length`\n*   `1 <= m, n <= 500`\n*   `0 <= nums1[i], nums2[i] <= 9`\n*   `1 <= k <= m + n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[3,4,6,5],[9,1,2,5,8,3],5",
                "output": "[9,8,6,5,3]"
            },
            {
                "input": "[6,7],[6,0,4],5",
                "output": "[6,7,6,0,4]"
            },
            {
                "input": "[3,9],[8,9],3",
                "output": "[9,8,9]"
            }
        ],
        "java": "\n    \n```java\npublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\n    int[] ans = new int[k];\n    int m = nums1.length, n = nums2.length;\n    \n    for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\n        int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\n    }\n    return ans;\n}\n\nprivate int[] maxArray(int[] nums, int k) {\n    int n = nums.length;\n    int[] ans = new int[k];\n    for (int i = 0, j = 0; i < n; i++) {\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\n        if (j < k) ans[j++] = nums[i];\n    }\n    return ans;\n}\n\nprivate int[] merge(int[] nums1, int[] nums2, int k) {\n    int[] ans = new int[k];\n    for (int i = 0, j = 0, r = 0; r < k; r++)\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n    return ans;\n}\n\nprivate boolean greater(int[] nums1, int i, int[] nums2, int j) {\n    while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n        i++;\n        j++;\n    }\n    return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n}\n```\n\n    \n    \nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \n    ",
        "js": "\n    \n```javascript\nfunction maxNumber(nums1, nums2, k) {\n    function maxArray(nums, k) {\n        let ans = [];\n        for (let i = 0; i < nums.length; i++) {\n            while (nums.length - i > k - ans.length && ans.length && ans[ans.length - 1] < nums[i])\n                ans.pop();\n            if (ans.length < k) ans.push(nums[i]);\n        }\n        return ans;\n    }\n\n    function merge(nums1, nums2) {\n        let ans = [], i = 0, j = 0;\n        while (i < nums1.length || j < nums2.length)\n            ans.push((nums1.slice(i).join('') >= nums2.slice(j).join('') ? nums1[i++] : nums2[j++]));\n        return ans;\n    }\n\n    let result = [];\n    for (let i = Math.max(0, k - nums2.length); i <= k && i <= nums1.length; i++) {\n        const candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i));\n        if (candidate.join('') > result.join('')) result = candidate;\n    }\n    return result;\n}\n```\n\n    \n    \nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \n    ",
        "c++": "\n    \n```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\n    int m = nums1.size(), n = nums2.size();\n    std::vector<int> ans(k, 0);\n    for (int i = std::max(0, k - n); i <= k && i <= m; ++i) {\n        std::vector<int> candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\n    }\n    return ans;\n}\n\nstd::vector<int> maxArray(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    std::vector<int> ans(k, 0);\n    for (int i = 0, j = 0; i < n; ++i) {\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\n        if (j < k) ans[j++] = nums[i];\n    }\n    return ans;\n}\n\nstd::vector<int> merge(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\n    std::vector<int> ans(k, 0);\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n    return ans;\n}\n\nbool greater(std::vector<int>& nums1, int i, std::vector<int>& nums2, int j) {\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\n        i++;\n        j++;\n    }\n    return j == nums2.size() || (i < nums1.size() && nums1[i] > nums2[j]);\n}\n```\n\n    \n    \nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \n    ",
        "python": "\n    \n```python\ndef maxNumber(nums1, nums2, k):\n    def maxArray(nums, k):\n        ans = []\n        for i, num in enumerate(nums):\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\n                ans.pop()\n            if len(ans) < k:\n                ans.append(num)\n        return ans\n\n    def merge(nums1, nums2):\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))\n```\n\n    \n    \nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \n    "
    },
    {
        "id": 51,
        "title": "Count of Range Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and two integers `lower` and `upper`, return _the number of range sums that lie in_ `[lower, upper]` _inclusive_.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,5,-1\\], lower = -2, upper = 2\n**Output:** 3\n**Explanation:** The three ranges are: \\[0,0\\], \\[2,2\\], and \\[0,2\\] and their respective sums are: -2, -1, 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\], lower = 0, upper = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `-105 <= lower <= upper <= 105`\n*   The answer is **guaranteed** to fit in a **32-bit** integer.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[-2,5,-1],-2,2",
                "output": "3"
            },
            {
                "input": "[0],0,0",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int countRangeSum(int[] nums, int lower, int upper) {\n    long[] sums = new long[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    return countWhileMergeSort(sums, lower, upper, 0, nums.length);\n}\n\nprivate int countWhileMergeSort(long[] sums, int lower, int upper, int start, int end) {\n    if (start >= end)\n        return 0;\n\n    int mid = start + (end - start) / 2;\n    int count = countWhileMergeSort(sums, lower, upper, start, mid) + countWhileMergeSort(sums, lower, upper, mid + 1, end);\n\n    int j = mid + 1, k = mid + 1;\n    for (int i = start; i <= mid; ++i) {\n        while (j <= end && sums[j] - sums[i] < lower) ++j;\n        while (k <= end && sums[k] - sums[i] <= upper) ++k;\n        count += k - j;\n    }\n\n    Arrays.sort(sums, start, end + 1);\n    return count;\n}\n```\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "python": "\n    ```python\ndef countRangeSum(nums, lower, upper):\n    sums = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        sums[i + 1] = sums[i] + nums[i]\n\n    def mergeSort(start, end):\n        if start == end:\n            return 0\n        mid = start + (end - start) // 2\n        count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n\n        j, k = mid + 1, mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and sums[j] - sums[i] < lower: j += 1\n            while k <= end and sums[k] - sums[i] <= upper: k += 1\n            count += k - j\n\n        sums[start:end + 1] = sorted(sums[start:end + 1])\n        return count\n\n    return mergeSort(0, len(nums))\n```\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "c++": "\n    ```cpp\nint countRangeSum(vector<int>& nums, int lower, int upper) {\n    int n = nums.size();\n    vector<long> sums(n + 1, 0);\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function<int(int, int)> mergeSort = [&](int start, int end) {\n        if (start == end)\n            return 0;\n        int mid = start + (end - start) / 2;\n        int count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int j = mid + 1, k = mid + 1;\n        for (int i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        inplace_merge(sums.begin() + start, sums.begin() + mid + 1, sums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, n);\n}\n```\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "js": "\n    ```javascript\nfunction countRangeSum(nums, lower, upper) {\n    let sums = new Array(nums.length + 1).fill(0);\n    for (let i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function mergeSort(start, end) {\n        if (start === end)\n            return 0;\n        let mid = start + Math.floor((end - start) / 2);\n        let count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        let j = mid + 1, k = mid + 1;\n        for (let i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        let sortedPart = sums.slice(start, end + 1).sort((a, b) => a - b);\n        for (let i = start; i <= end; ++i) {\n            sums[i] = sortedPart[i - start];\n        }\n\n        return count;\n    };\n\n    return mergeSort(0, nums.length);\n}\n```\n\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    "
    },
    {
        "id": 52,
        "title": "Longest Increasing Path in a Matrix",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[9,9,4],[6,6,8],[2,1,1]]",
                "output": "4"
            },
            {
                "input": "[[3,4,5],[3,2,6],[2,2,1]]",
                "output": "4"
            },
            {
                "input": "[[1]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nint[] dx = {0, 0, 1, -1};\nint[] dy = {1, -1, 0, 0};\n\npublic int dfs(int[][] matrix, int[][] memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\npublic int longestIncreasingPath(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    \n    int[][] memo = new int[m][n];\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    ",
        "python": "\n    ```python\ndx = (0, 0, 1, -1)\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    ",
        "c++": "\n    ```cpp\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(vector<vector<int>>& matrix, vector<vector<int>>& memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.size() && nj >= 0 && nj < matrix[0].size() && matrix[ni][nj] > matrix[i][j]) {\n            max_len = max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nint longestIncreasingPath(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    \n    vector<vector<int>> memo(m, vector<int>(n, 0));\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    ",
        "js": "\n    ```javascript\nconst dx = [0, 0, 1, -1];\nconst dy = [1, -1, 0, 0];\n\nfunction dfs(matrix, memo, i, j) {\n    if (memo[i][j] !== 0) return memo[i][j];\n    \n    let max_len = 0;\n    for (let k = 0; k < 4; ++k) {\n        const ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nfunction longestIncreasingPath(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    \n    const memo = Array.from({length: m}, () => Array.from({length: n}, () => 0));\n    \n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix.\n    "
    },
    {
        "id": 53,
        "title": "Patching Array",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.\n\nReturn _the minimum number of patches required_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3\\], n = 6\n**Output:** 1\nExplanation:\nCombinations of nums are \\[1\\], \\[3\\], \\[1,3\\], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: \\[1\\], \\[2\\], \\[3\\], \\[1,3\\], \\[2,3\\], \\[1,2,3\\].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range \\[1, 6\\].\nSo we only need 1 patch.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,10\\], n = 20\n**Output:** 2\nExplanation: The two patches can be \\[2, 4\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,2\\], n = 5\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n*   `nums` is sorted in **ascending order**.\n*   `1 <= n <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,3],6",
                "output": "1\nExplanation:\nCombinationsofnumsare[1],[3],[1,3],whichformpossiblesumsof:1,3,4.\nNowifweadd/patch2tonums,thecombinationsare:[1],[2],[3],[1,3],[2,3],[1,2,3].\nPossiblesumsare1,2,3,4,5,6,whichnowcoverstherange[1,6].\nSoweonlyneed1patch."
            },
            {
                "input": "[1,5,10],20",
                "output": "2\nExplanation:Thetwopatchescanbe[2,4]."
            },
            {
                "input": "[1,2,2],5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minPatches(int[] nums, int n) {\n    long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "python": "\n    ```python\ndef minPatches(nums, n):\n    max_sum = 0\n    patches = 0\n    i = 0\n\n    while max_sum < n:\n        if i < len(nums) and nums[i] <= max_sum + 1:\n            max_sum += nums[i]\n            i += 1\n        else:\n            max_sum += max_sum + 1\n            patches += 1\n\n    return patches\n```\n\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "c++": "\n    ```cpp\nint minPatches(vector<int>& nums, int n) {\n    long long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.size() && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "js": "\n    ```javascript\nfunction minPatches(nums, n) {\n    let maxSum = 0;\n    let patches = 0;\n    let i = 0;\n\n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    "
    },
    {
        "id": 54,
        "title": "Reconstruct Itinerary",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll of the tickets belong to a man who departs from `\"JFK \"`, thus, the itinerary must begin with `\"JFK \"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n*   For example, the itinerary `[ \"JFK \", \"LGA \"]` has a smaller lexical order than `[ \"JFK \", \"LGB \"]`.\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
            "examples": [
                "**Example 1:**\n\n**Input:** tickets = \\[\\[ \"MUC \", \"LHR \"\\],\\[ \"JFK \", \"MUC \"\\],\\[ \"SFO \", \"SJC \"\\],\\[ \"LHR \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"MUC \", \"LHR \", \"SFO \", \"SJC \"\\]\n\n",
                "**Example 2:**\n\n**Input:** tickets = \\[\\[ \"JFK \", \"SFO \"\\],\\[ \"JFK \", \"ATL \"\\],\\[ \"SFO \", \"ATL \"\\],\\[ \"ATL \", \"JFK \"\\],\\[ \"ATL \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"ATL \", \"JFK \", \"SFO \", \"ATL \", \"SFO \"\\]\n**Explanation:** Another possible reconstruction is \\[ \"JFK \", \"SFO \", \"ATL \", \"JFK \", \"ATL \", \"SFO \"\\] but it is larger in lexical order."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= tickets.length <= 300`\n*   `tickets[i].length == 2`\n*   `fromi.length == 3`\n*   `toi.length == 3`\n*   `fromi` and `toi` consist of uppercase English letters.\n*   `fromi != toi`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Eulerian Circuit"
        ],
        "example": [
            {
                "input": "[[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
                "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]"
            },
            {
                "input": "[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
                "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        HashMap<String, PriorityQueue<String>> flights = new HashMap<>();\n        LinkedList<String> itinerary = new LinkedList<>();\n        \n        for (List<String> ticket : tickets) {\n            flights.putIfAbsent(ticket.get(0), new PriorityQueue<>());\n            flights.get(ticket.get(0)).offer(ticket.get(1));\n        }\n        \n        Stack<String> dfs = new Stack<>();\n        dfs.push(\"JFK\");\n        \n        while (!dfs.isEmpty()) {\n            String nextAirport = dfs.peek();\n            if (flights.get(nextAirport) == null || flights.get(nextAirport).isEmpty()) {\n                itinerary.addFirst(dfs.pop());\n            } else {\n                dfs.push(flights.get(nextAirport).poll());\n            }\n        }\n        \n        return itinerary;\n    }\n}\n```\n    \n    1. Create a data structure to store our itinerary as well as the flights to be taken.\n2. Iterate over the given list of airline tickets and create a mapping of departure airports to possible arrival airports in sorted order.\n3. Implement a depth-first search (DFS) helper function to traverse through the airports following the mentioned constraints.\n4. Start the DFS traversal with the departure airport \"JFK.\"\n5. After the traversal is complete, reverse the reconstructed itinerary and return it as the result.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef findItinerary(tickets):\n    flights = defaultdict(list)\n    itinerary = []\n\n    for ticket in tickets:\n        flights[ticket[0]].append(ticket[1])\n        flights[ticket[0]].sort(reverse=True)\n\n    def dfs(airport):\n        while flights[airport]:\n            dfs(flights[airport].pop())\n        itinerary.append(airport)\n\n    dfs(\"JFK\")\n    \n    return itinerary[::-1]\n```\n    \n    1. Create a data structure to store our itinerary as well as the flights to be taken.\n2. Iterate over the given list of airline tickets and create a mapping of departure airports to possible arrival airports in sorted order.\n3. Implement a depth-first search (DFS) helper function to traverse through the airports following the mentioned constraints.\n4. Start the DFS traversal with the departure airport \"JFK.\"\n5. After the traversal is complete, reverse the reconstructed itinerary and return it as the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nvector<string> findItinerary(vector<vector<string>>& tickets) {\n    unordered_map<string, multiset<string>> flights;\n    vector<string> itinerary;\n    \n    for (const auto& ticket : tickets)\n        flights[ticket[0]].insert(ticket[1]);\n    \n    stack<string> dfs;\n    dfs.push(\"JFK\");\n    \n    while (!dfs.empty()) {\n        string next_airport = dfs.top();\n        if (flights[next_airport].empty()) {\n            itinerary.push_back(next_airport);\n            dfs.pop();\n        } else {\n            dfs.push(*flights[next_airport].begin());\n            flights[next_airport].erase(flights[next_airport].begin());\n        }\n    }\n    \n    reverse(itinerary.begin(), itinerary.end());\n    return itinerary;\n}\n```\n    \n    1. Create a data structure to store our itinerary as well as the flights to be taken.\n2. Iterate over the given list of airline tickets and create a mapping of departure airports to possible arrival airports in sorted order.\n3. Implement a depth-first search (DFS) helper function to traverse through the airports following the mentioned constraints.\n4. Start the DFS traversal with the departure airport \"JFK.\"\n5. After the traversal is complete, reverse the reconstructed itinerary and return it as the result.\n    ",
        "js": "\n    ```javascript\nfunction findItinerary(tickets) {\n    const flights = {};\n    const itinerary = [];\n\n    for (const ticket of tickets) {\n        if (!flights[ticket[0]]) {\n            flights[ticket[0]] = [];\n        }\n        flights[ticket[0]].push(ticket[1]);\n        flights[ticket[0]].sort((a, b) => b.localeCompare(a));\n    }\n\n    function dfs(airport) {\n        while (flights[airport] && flights[airport].length > 0) {\n            dfs(flights[airport].pop());\n        }\n        itinerary.push(airport);\n    }\n\n    dfs(\"JFK\");\n    \n    return itinerary.reverse();\n}\n```\n    \n    1. Create a data structure to store our itinerary as well as the flights to be taken.\n2. Iterate over the given list of airline tickets and create a mapping of departure airports to possible arrival airports in sorted order.\n3. Implement a depth-first search (DFS) helper function to traverse through the airports following the mentioned constraints.\n4. Start the DFS traversal with the departure airport \"JFK.\"\n5. After the traversal is complete, reverse the reconstructed itinerary and return it as the result.\n    "
    },
    {
        "id": 55,
        "title": "Self Crossing",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an **X-Y plane,** and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\nReturn `true` _if your path crosses itself or_ `false` _if it does not_.",
            "examples": [
                "**Example 1:**\n\n**Input:** distance = \\[2,1,1,2\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 1).\n\n",
                "**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** The path does not cross itself at any point.\n\n",
                "**Example 3:**\n\n**Input:** distance = \\[1,1,1,2,1\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 0)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= distance.length <= 105`\n*   `1 <= distance[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[2,1,1,2]",
                "output": "true"
            },
            {
                "input": "[1,2,3,4]",
                "output": "false"
            },
            {
                "input": "[1,1,1,2,1]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean isPathCrossing(int[] distance) {\n    Set<Pair<Integer, Integer>> visited = new HashSet<>();\n    int x = 0, y = 0;\n    visited.add(new Pair<>(x, y));\n    int[] dx = {0, -1, 0, 1};\n    int[] dy = {1, 0, -1, 0};\n    \n    for (int i = 0; i < distance.length; i++) {\n        int direction = i % 4;\n        for (int j = 0; j < distance[i]; j++) {\n            x += dx[direction];\n            y += dy[direction];\n            Pair<Integer, Integer> point = new Pair<>(x, y);\n            if (!visited.add(point)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "python": "\n    ```python\ndef is_path_crossing(distance):\n    visited = set([(0, 0)])\n    x, y = 0, 0\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    \n    for i, d in enumerate(distance):\n        dx, dy = directions[i % 4]\n        for _ in range(d):\n            x += dx\n            y += dy\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n    return False\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "c++": "\n    ```cpp\nbool isPathCrossing(const std::vector<int>& distance) {\n    std::unordered_set<std::pair<int, int>, pair_hash> visited;\n    int x = 0, y = 0;\n    visited.insert({x, y});\n    int dx[] = {0, -1, 0, 1};\n    int dy[] = {1, 0, -1, 0};\n    \n    for (int i = 0; i < distance.size(); ++i) {\n        int direction = i % 4;\n        for (int j = 0; j < distance[i]; ++j) {\n            x += dx[direction];\n            y += dy[direction];\n            if (!visited.insert({x, y}).second) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "js": "\n    ```javascript\nfunction isPathCrossing(distance) {\n    let visited = new Set([\"0,0\"]);\n    let x = 0, y = 0;\n    const dx = [0, -1, 0, 1];\n    const dy = [1, 0, -1, 0];\n    \n    for (let i = 0; i < distance.length; i++) {\n        let direction = i % 4;\n        for (let j = 0; j < distance[i]; j++) {\n            x += dx[direction];\n            y += dy[direction];\n            let point = `${x},${y}`; \n            if (visited.has(point)) {\n                return true;\n            }\n            visited.add(point);\n        }\n    }\n    return false;\n}\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    "
    },
    {
        "id": 56,
        "title": "Palindrome Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** array of **unique** strings `words`.\n\nA **palindrome pair** is a pair of integers `(i, j)` such that:\n\n*   `0 <= i, j < words.length`,\n*   `i != j`, and\n*   `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.\n\nReturn _an array of all the **palindrome pairs** of_ `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abcd \", \"dcba \", \"lls \", \"s \", \"sssll \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\],\\[3,2\\],\\[2,4\\]\\]\n**Explanation:** The palindromes are \\[ \"abcddcba \", \"dcbaabcd \", \"slls \", \"llssssll \"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"bat \", \"tab \", \"cat \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n**Explanation:** The palindromes are \\[ \"battab \", \"tabbat \"\\]\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"a \", \" \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n**Explanation:** The palindromes are \\[ \"a \", \"a \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 5000`\n*   `0 <= words[i].length <= 300`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Trie"
        ],
        "example": [
            {
                "input": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
                "output": "[[0,1],[1,0],[3,2],[2,4]]"
            },
            {
                "input": "[\"bat\",\"tab\",\"cat\"]",
                "output": "[[0,1],[1,0]]"
            },
            {
                "input": "[\"a\",\"\"]",
                "output": "[[0,1],[1,0]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> palindromePairs(String[] words) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < words.length; i++) {\n        for (int j = 0; j < words.length; j++) {\n            if (i == j) continue;\n            String concat = words[i] + words[j];\n\n            boolean isPalindrome = true;\n            for (int left = 0, right = concat.length() - 1; left < right; left++, right--) {\n                if (concat.charAt(left) != concat.charAt(right)) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n\n            if (isPalindrome) {\n                List<Integer> pair = new ArrayList<>();\n                pair.add(i);\n                pair.add(j);\n                result.add(pair);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "python": "\n    ```python\ndef palindrome_pairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    result = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i == j:\n                continue\n            concat = words[i] + words[j]\n            if is_palindrome(concat):\n                result.append([i, j])\n    return result\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) {\n    std::vector<std::pair<int, int>> result;\n\n    for (size_t i = 0; i < words.size(); i++) {\n        for (size_t j = 0; j < words.size(); j++) {\n            if (i == j) continue;\n            std::string concat = words[i] + words[j];\n\n            bool is_palindrome = true;\n            for (size_t left = 0, right = concat.size() - 1; left < right; left++, right--) {\n                if (concat[left] != concat[right]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n\n            if (is_palindrome) {\n                result.push_back(std::make_pair(i, j));\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "js": "\n    ```javascript\nfunction palindromePairs(words) {\n    function isPalindrome(s) {\n        return s === s.split('').reverse().join('');\n    }\n\n    const result = [];\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n            if (i === j) continue;\n            const concat = words[i] + words[j];\n            if (isPalindrome(concat)) {\n                result.push([i, j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    "
    },
    {
        "id": 57,
        "title": "Data Stream as Disjoint Intervals",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a data stream input of non-negative integers `a1, a2, ..., an`, summarize the numbers seen so far as a list of disjoint intervals.\n\nImplement the `SummaryRanges` class:\n\n*   `SummaryRanges()` Initializes the object with an empty stream.\n*   `void addNum(int value)` Adds the integer `value` to the stream.\n*   `int[][] getIntervals()` Returns a summary of the integers in the stream currently as a list of disjoint intervals `[starti, endi]`. The answer should be sorted by `starti`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"SummaryRanges \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \"\\]\n\\[\\[\\], \\[1\\], \\[\\], \\[3\\], \\[\\], \\[7\\], \\[\\], \\[2\\], \\[\\], \\[6\\], \\[\\]\\]\n**Output**\n\\[null, null, \\[\\[1, 1\\]\\], null, \\[\\[1, 1\\], \\[3, 3\\]\\], null, \\[\\[1, 1\\], \\[3, 3\\], \\[7, 7\\]\\], null, \\[\\[1, 3\\], \\[7, 7\\]\\], null, \\[\\[1, 3\\], \\[6, 7\\]\\]\\]\n\n**Explanation**\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = \\[1\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 1\\]\\]\nsummaryRanges.addNum(3);      // arr = \\[1, 3\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 1\\], \\[3, 3\\]\\]\nsummaryRanges.addNum(7);      // arr = \\[1, 3, 7\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 1\\], \\[3, 3\\], \\[7, 7\\]\\]\nsummaryRanges.addNum(2);      // arr = \\[1, 2, 3, 7\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 3\\], \\[7, 7\\]\\]\nsummaryRanges.addNum(6);      // arr = \\[1, 2, 3, 6, 7\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 3\\], \\[6, 7\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= value <= 104`\n*   At most `3 * 104` calls will be made to `addNum` and `getIntervals`.\n*   At most `102` calls will be made to `getIntervals`.\n\n**",
            "follow_up": "Follow up:** What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?"
        },
        "tag": [
            "Binary Search",
            "Design",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],],]]",
                "output": "**Output**\n[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.TreeMap;\n\npublic class SummaryRanges {\n\n    private TreeMap<Integer, Integer> intervals = new TreeMap<>();\n\n    public void addNum(int val) {\n        if (intervals.isEmpty() || intervals.firstKey() > val + 1) {\n            intervals.put(val, val);\n            return;\n        }\n        Integer lower = intervals.lowerKey(val);\n        Integer upper = intervals.higherKey(val);\n        if (lower != null && intervals.get(lower) + 1 == val) {\n            intervals.put(lower, intervals.get(lower) + 1);\n\n            if (upper != null && val + 1 == upper) {\n                intervals.put(lower, intervals.get(upper));\n                intervals.remove(upper);\n            }\n        } else if (upper != null && val + 1 == upper) {\n            intervals.put(val, intervals.get(upper));\n            intervals.remove(upper);\n        } else {\n            intervals.put(val, val);\n        }\n    }\n\n    public List<List<Integer>> getIntervals() {\n        List<List<Integer>> result = new ArrayList<>();\n        for (Integer key : intervals.keySet()) {\n            List<Integer> range = new ArrayList<>();\n            range.add(key);\n            range.add(intervals.get(key));\n            result.add(range);\n        }\n        return result;\n    }\n}\n```\n\n    \n    We will maintain a map (a TreeMap in Java, an OrderedDict in Python, and a Map in JavaScript) to store start and end points of disjoint intervals. The keys of the map represent the start of an interval, and their corresponding values are the end of the interval.\n\n1. If the map is empty, or there is no previous interval that can be merged with the current number, we will create a new disjoint interval starting and ending at the current number and store it in the map.\n2. Otherwise, we try to merge the number with existing intervals. We find the exact location where the number would fit in the map. If the number lies between any pre-existing interval, we ignore it. If the number is to the left of any existing interval and can be merged, we update the end value of the interval. If the number is to the right of any existing interval, we create a new entry in the map with start and end as the current number.\n\nTo output the intervals, we just convert the key-value pairs of the map to a list of lists representing the intervals.\n    ",
        "python": "\n    ```python\nfrom collections import OrderedDict\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = OrderedDict()\n\n    def addNum(self, val: int) -> None:\n        if not self.intervals or next(iter(self.intervals)) > val + 1:\n            self.intervals[val] = val\n        else:\n            keys = list(self.intervals.keys())\n            idx = bisect_left(keys, val)\n            if idx > 0 and keys[idx - 1] <= val <= self.intervals[keys[idx - 1]]:\n                pass\n            elif idx < len(keys) and val + 1 == keys[idx]:\n                self.intervals[val] = self.intervals[keys[idx]]\n                del self.intervals[keys[idx]]\n            else:\n                self.intervals[val] = val\n\n    def getIntervals(self):\n        return list(self.intervals.items())\n```\n\n    \n    We will maintain a map (a TreeMap in Java, an OrderedDict in Python, and a Map in JavaScript) to store start and end points of disjoint intervals. The keys of the map represent the start of an interval, and their corresponding values are the end of the interval.\n\n1. If the map is empty, or there is no previous interval that can be merged with the current number, we will create a new disjoint interval starting and ending at the current number and store it in the map.\n2. Otherwise, we try to merge the number with existing intervals. We find the exact location where the number would fit in the map. If the number lies between any pre-existing interval, we ignore it. If the number is to the left of any existing interval and can be merged, we update the end value of the interval. If the number is to the right of any existing interval, we create a new entry in the map with start and end as the current number.\n\nTo output the intervals, we just convert the key-value pairs of the map to a list of lists representing the intervals.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n\nclass SummaryRanges {\npublic:\n    void addNum(int val) {\n        if (intervals.empty() || intervals.begin()->first > val + 1) {\n            intervals[val] = val;\n        } else {\n            auto it = intervals.lower_bound(val);\n            auto left = prev(it), right = it;\n            \n            if (left != intervals.end() && left->second + 1 == val) {\n                left->second++;\n                if (right != intervals.end() && val + 1 == right->first) {\n                    left->second = right->second;\n                    intervals.erase(right);\n                }\n            } else if (right != intervals.end() && val + 1 == right->first) {\n                intervals[val] = right->second;\n                intervals.erase(right);\n            } else {\n                intervals[val] = val;\n            }\n        }\n    }\n\n    vector<vector<int>> getIntervals() {\n        vector<vector<int>> result;\n        for (const auto& interval : intervals) {\n            result.push_back({interval.first, interval.second});\n        }\n        return result;\n    }\n\nprivate:\n    map<int, int> intervals;\n};\n```\n\n    \n    We will maintain a map (a TreeMap in Java, an OrderedDict in Python, and a Map in JavaScript) to store start and end points of disjoint intervals. The keys of the map represent the start of an interval, and their corresponding values are the end of the interval.\n\n1. If the map is empty, or there is no previous interval that can be merged with the current number, we will create a new disjoint interval starting and ending at the current number and store it in the map.\n2. Otherwise, we try to merge the number with existing intervals. We find the exact location where the number would fit in the map. If the number lies between any pre-existing interval, we ignore it. If the number is to the left of any existing interval and can be merged, we update the end value of the interval. If the number is to the right of any existing interval, we create a new entry in the map with start and end as the current number.\n\nTo output the intervals, we just convert the key-value pairs of the map to a list of lists representing the intervals.\n    ",
        "js": "\n    ```javascript\nclass SummaryRanges {\n    constructor() {\n        this.intervals = new Map();\n    }\n\n    addNum(val) {\n        if (!this.intervals.size || [...this.intervals.keys()][0] > val + 1) {\n            this.intervals.set(val, val);\n        } else {\n            let keys = [...this.intervals.keys()];\n            let index = keys.findIndex(key => key > val);\n\n            if (index > 0 && keys[index - 1] <= val && val <= this.intervals.get(keys[index - 1])) {\n                return;\n            } else if (index !== -1 && val + 1 === keys[index]) {\n                this.intervals.set(val, this.intervals.get(keys[index]));\n                this.intervals.delete(keys[index]);\n            } else {\n                this.intervals.set(val, val);\n            }\n        }\n    }\n\n    getIntervals() {\n        return [...this.intervals.entries()].map(([start, end]) => [start, end]);\n    }\n}\n```\n\n    \n    We will maintain a map (a TreeMap in Java, an OrderedDict in Python, and a Map in JavaScript) to store start and end points of disjoint intervals. The keys of the map represent the start of an interval, and their corresponding values are the end of the interval.\n\n1. If the map is empty, or there is no previous interval that can be merged with the current number, we will create a new disjoint interval starting and ending at the current number and store it in the map.\n2. Otherwise, we try to merge the number with existing intervals. We find the exact location where the number would fit in the map. If the number lies between any pre-existing interval, we ignore it. If the number is to the left of any existing interval and can be merged, we update the end value of the interval. If the number is to the right of any existing interval, we create a new entry in the map with start and end as the current number.\n\nTo output the intervals, we just convert the key-value pairs of the map to a list of lists representing the intervals.\n    "
    },
    {
        "id": 58,
        "title": "Russian Doll Envelopes",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.",
            "examples": [
                "**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n",
                "**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[5,4],[6,4],[6,7],[2,3]]",
                "output": "3"
            },
            {
                "input": "[[1,1],[1,1],[1,1]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes, new Comparator<int[]>() {\n        public int compare(int[] a, int[] b) {\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n        }\n    });\n\n    int[] dp = new int[envelopes.length];\n    int len = 0;\n    for (int[] envelope : envelopes) {\n        int idx = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if (idx < 0) {\n            idx = -(idx + 1);\n        }\n        dp[idx] = envelope[1];\n        if (idx == len) {\n            len++;\n        }\n    }\n\n    return len;\n}\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes) {\n    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n    \n    std::vector<int> dp;\n    for (const auto& envelope : envelopes) {\n        auto it = std::lower_bound(dp.begin(), dp.end(), envelope[1]);\n        if (it == dp.end()) {\n            dp.push_back(envelope[1]);\n        } else {\n            *it = envelope[1];\n        }\n    }\n    \n    return dp.size();\n}\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    ",
        "js": "\n    ```javascript\nfunction maxEnvelopes(envelopes) {\n    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\n    const dp = [];\n\n    for (const envelope of envelopes) {\n        const idx = lowerBound(dp, envelope[1]);\n        if (idx === dp.length) {\n            dp.push(envelope[1]);\n        } else {\n            dp[idx] = envelope[1];\n        }\n    }\n\n    return dp.length;\n\n    function lowerBound(arr, target) {\n        let low = 0, high = arr.length;\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\n```\n    \n    1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other.\n    "
    },
    {
        "id": 59,
        "title": "Max Sum of Rectangle No Larger Than K",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` matrix `matrix` and an integer `k`, return _the max sum of a rectangle in the matrix such that its sum is no larger than_ `k`.\n\nIt is **guaranteed** that there will be a rectangle with a sum no larger than `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,0,1\\],\\[0,-2,3\\]\\], k = 2\n**Output:** 2\n**Explanation:** Because the sum of the blue rectangle \\[\\[0, 1\\], \\[-2, 3\\]\\] is 2, and 2 is the max number no larger than k (k = 2).\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[2,2,-1\\]\\], k = 3\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= matrix[i][j] <= 100`\n*   `-105 <= k <= 105`\n\n**",
            "follow_up": "Follow up:** What if the number of rows is much larger than the number of columns?"
        },
        "tag": [
            "Array",
            "Binary Search",
            "Matrix",
            "Prefix Sum",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[1,0,1],[0,-2,3]],2",
                "output": "2"
            },
            {
                "input": "[[2,2,-1]],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic int maxSumSubmatrix(int[][] matrix, int k) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    int maxSum = Integer.MIN_VALUE;\n\n    for (int l = 0; l < cols; ++l) {\n        int[] sums = new int[rows];\n        for (int r = l; r < cols; ++r) {\n            for (int i = 0; i < rows; ++i) {\n                sums[i] += matrix[i][r];\n            }\n\n            TreeSet<Integer> sortedSums = new TreeSet<>();\n            sortedSums.add(0);\n            int currSum = 0;\n            for (int sum : sums) {\n                currSum += sum;\n                Integer it = sortedSums.ceiling(currSum - k);\n                if (it != null)\n                    maxSum = Math.max(maxSum, currSum - it);\n                sortedSums.add(currSum);\n            }\n        }\n    }\n\n    return maxSum;\n}\n```\n\n    \n    1. Initialize variables to iterate over all possible column pairs (left and right).\n2. For each column pair, calculate the cumulative sum of elements within the column range for each row.\n3. Initialize a sorted set (e.g., `set` in C++, `TreeSet` in Java, `SortedList` in Python, and an array in JavaScript) to store the prefix sums.\n4. Iterate through the cumulative sums, updating the current sum and finding the lower bound of (currSum - k) in the sorted set.\n5. If the iterator is not pointing to the end, update the maxSum using the current sum minus the value pointed by the iterator.\n6. Insert the current sum into the sorted set.\n7. After all iterations are done, return the maxSum.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef maxSumSubmatrix(matrix, k):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for l in range(cols):\n        sums = [0] * rows\n        for r in range(l, cols):\n            for i in range(rows):\n                sums[i] += matrix[i][r]\n\n            sorted_sums = SortedList()\n            sorted_sums.add(0)\n            curr_sum = 0\n            for sum in sums:\n                curr_sum += sum\n                it = sorted_sums.bisect_left(curr_sum - k)\n                if it != len(sorted_sums):\n                    max_sum = max(max_sum, curr_sum - sorted_sums[it])\n                sorted_sums.add(curr_sum)\n\n    return max_sum\n```\n\n    \n    1. Initialize variables to iterate over all possible column pairs (left and right).\n2. For each column pair, calculate the cumulative sum of elements within the column range for each row.\n3. Initialize a sorted set (e.g., `set` in C++, `TreeSet` in Java, `SortedList` in Python, and an array in JavaScript) to store the prefix sums.\n4. Iterate through the cumulative sums, updating the current sum and finding the lower bound of (currSum - k) in the sorted set.\n5. If the iterator is not pointing to the end, update the maxSum using the current sum minus the value pointed by the iterator.\n6. Insert the current sum into the sorted set.\n7. After all iterations are done, return the maxSum.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nint maxSumSubmatrix(std::vector<std::vector<int>>& matrix, int k) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    int maxSum = INT_MIN;\n\n    for (int l = 0; l < cols; ++l) {\n        std::vector<int> sums(rows, 0);\n        for (int r = l; r < cols; ++r) {\n            for (int i = 0; i < rows; ++i) {\n                sums[i] += matrix[i][r];\n            }\n\n            std::set<int> sortedSums;\n            sortedSums.insert(0);\n            int currSum = 0;\n            for (int sum : sums) {\n                currSum += sum;\n                auto it = sortedSums.lower_bound(currSum - k);\n                if (it != sortedSums.end())\n                    maxSum = std::max(maxSum, currSum - *it);\n                sortedSums.insert(currSum);\n            }\n        }\n    }\n\n    return maxSum;\n}\n```\n\n    \n    1. Initialize variables to iterate over all possible column pairs (left and right).\n2. For each column pair, calculate the cumulative sum of elements within the column range for each row.\n3. Initialize a sorted set (e.g., `set` in C++, `TreeSet` in Java, `SortedList` in Python, and an array in JavaScript) to store the prefix sums.\n4. Iterate through the cumulative sums, updating the current sum and finding the lower bound of (currSum - k) in the sorted set.\n5. If the iterator is not pointing to the end, update the maxSum using the current sum minus the value pointed by the iterator.\n6. Insert the current sum into the sorted set.\n7. After all iterations are done, return the maxSum.\n    ",
        "js": "\n    ```javascript\nfunction maxSumSubmatrix(matrix, k) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    let maxSum = -Infinity;\n\n    function lowerBound(arr, target) {\n        let l = 0;\n        let r = arr.length;\n        while (l < r) {\n            const mid = Math.floor((l + r) / 2);\n            if (arr[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n\n    for (let l = 0; l < cols; ++l) {\n        const sums = Array(rows).fill(0);\n        for (let r = l; r < cols; ++r) {\n            for (let i = 0; i < rows; ++i) {\n                sums[i] += matrix[i][r];\n            }\n\n            const sortedSums = [0];\n            let currSum = 0;\n            for (const sum of sums) {\n                currSum += sum;\n                const it = lowerBound(sortedSums, currSum - k);\n                if (it < sortedSums.length)\n                    maxSum = Math.max(maxSum, currSum - sortedSums[it]);\n                const insertPosition = lowerBound(sortedSums, currSum);\n                sortedSums.splice(insertPosition, 0, currSum);\n            }\n        }\n    }\n\n    return maxSum;\n}\n```\n\n    \n    1. Initialize variables to iterate over all possible column pairs (left and right).\n2. For each column pair, calculate the cumulative sum of elements within the column range for each row.\n3. Initialize a sorted set (e.g., `set` in C++, `TreeSet` in Java, `SortedList` in Python, and an array in JavaScript) to store the prefix sums.\n4. Iterate through the cumulative sums, updating the current sum and finding the lower bound of (currSum - k) in the sorted set.\n5. If the iterator is not pointing to the end, update the maxSum using the current sum minus the value pointed by the iterator.\n6. Insert the current sum into the sorted set.\n7. After all iterations are done, return the maxSum.\n    "
    },
    {
        "id": 60,
        "title": "Perfect Rectangle",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]` represents an axis-aligned rectangle. The bottom-left point of the rectangle is `(xi, yi)` and the top-right point of it is `(ai, bi)`.\n\nReturn `true` _if all the rectangles together form an exact cover of a rectangular region_.",
            "examples": [
                "**Example 1:**\n\n**Input:** rectangles = \\[\\[1,1,3,3\\],\\[3,1,4,2\\],\\[3,2,4,4\\],\\[1,3,2,4\\],\\[2,3,3,4\\]\\]\n**Output:** true\n**Explanation:** All 5 rectangles together form an exact cover of a rectangular region.\n\n",
                "**Example 2:**\n\n**Input:** rectangles = \\[\\[1,1,2,3\\],\\[1,3,2,4\\],\\[3,1,4,2\\],\\[3,2,4,4\\]\\]\n**Output:** false\n**Explanation:** Because there is a gap between the two rectangular regions.\n\n",
                "**Example 3:**\n\n**Input:** rectangles = \\[\\[1,1,3,3\\],\\[3,1,4,2\\],\\[1,3,2,4\\],\\[2,2,4,4\\]\\]\n**Output:** false\n**Explanation:** Because two of the rectangles overlap with each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rectangles.length <= 2 * 104`\n*   `rectangles[i].length == 4`\n*   `-105 <= xi, yi, ai, bi <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Line Sweep"
        ],
        "example": [
            {
                "input": "[[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]",
                "output": "true"
            },
            {
                "input": "[[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]",
                "output": "false"
            },
            {
                "input": "[[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.awt.Point;\n\npublic class RectCover {\n    public boolean isRectangleCover(int[][] rectangles) {\n        int area = 0;\n        Set<Point> points = new HashSet<>();\n        int lx = Integer.MAX_VALUE, ly = Integer.MAX_VALUE, rx = Integer.MIN_VALUE, ry = Integer.MIN_VALUE;\n\n        for (int[] rect : rectangles) {\n            lx = Math.min(lx, rect[0]);\n            ly = Math.min(ly, rect[1]);\n            rx = Math.max(rx, rect[2]);\n            ry = Math.max(ry, rect[3]);\n\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n            Point p1 = new Point(rect[0], rect[1]);\n            Point p2 = new Point(rect[0], rect[3]);\n            Point p3 = new Point(rect[2], rect[1]);\n            Point p4 = new Point(rect[2], rect[3]);\n\n            if (!points.remove(p1)) points.add(p1);\n            if (!points.remove(p2)) points.add(p2);\n            if (!points.remove(p3)) points.add(p3);\n            if (!points.remove(p4)) points.add(p4);\n        }\n\n        if (points.contains(new Point(lx, ly)) && points.contains(new Point(lx, ry)) &&\n            points.contains(new Point(rx, ly)) && points.contains(new Point(rx, ry)) &&\n            points.size() == 4)\n            return area == (rx - lx) * (ry - ly);\n\n        return false;\n    }\n}\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "python": "\n    ```python\ndef isRectangleCover(rectangles):\n    area = 0\n    points = set()\n    lx, ly, rx, ry = float('inf'), float('inf'), float('-inf'), float('-inf')\n\n    for rect in rectangles:\n        lx, ly = min(lx, rect[0]), min(ly, rect[1])\n        rx, ry = max(rx, rect[2]), max(ry, rect[3])\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n        p1, p2, p3, p4 = (rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[1]), (rect[2], rect[3])\n\n        points ^= {p1, p2, p3, p4}\n\n    return len(points) == 4 and area == (rx - lx) * (ry - ly) and (lx, ly) in points and \\\n           (lx, ry) in points and (rx, ly) in points and (rx, ry) in points\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nbool isRectangleCover(std::vector<std::vector<int>>& rectangles) {\n    int area = 0;\n    std::set<std::pair<int, int>> points;\n    int lx = INT_MAX, ly = INT_MAX, rx = INT_MIN, ry = INT_MIN;\n\n    for (auto& rect : rectangles) {\n        lx = std::min(lx, rect[0]);\n        ly = std::min(ly, rect[1]);\n        rx = std::max(rx, rect[2]);\n        ry = std::max(ry, rect[3]);\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n        std::pair<int, int> p1(rect[0], rect[1]);\n        std::pair<int, int> p2(rect[0], rect[3]);\n        std::pair<int, int> p3(rect[2], rect[1]);\n        std::pair<int, int> p4(rect[2], rect[3]);\n\n        if (!points.erase(p1)) points.insert(p1);\n        if (!points.erase(p2)) points.insert(p2);\n        if (!points.erase(p3)) points.insert(p3);\n        if (!points.erase(p4)) points.insert(p4);\n    }\n\n    if (points.count({lx, ly}) && points.count({lx, ry}) &&\n        points.count({rx, ly}) && points.count({rx, ry}) &&\n        points.size() == 4)\n        return area == (rx - lx) * (ry - ly);\n\n    return false;\n}\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "js": "\n    ```javascript\nfunction isRectangleCover(rectangles) {\n    let area = 0;\n    let points = new Set();\n    let lx = Infinity, ly = Infinity, rx = -Infinity, ry = -Infinity;\n\n    for (let rect of rectangles) {\n        lx = Math.min(lx, rect[0]);\n        ly = Math.min(ly, rect[1]);\n        rx = Math.max(rx, rect[2]);\n        ry = Math.max(ry, rect[3]);\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n        let p1 = rect[0] + \",\" + rect[1];\n        let p2 = rect[0] + \",\" + rect[3];\n        let p3 = rect[2] + \",\" + rect[1];\n        let p4 = rect[2] + \",\" + rect[3];\n\n        if (points.has(p1)) points.delete(p1);\n        else points.add(p1);\n        if (points.has(p2)) points.delete(p2);\n        else points.add(p2);\n        if (points.has(p3)) points.delete(p3);\n        else points.add(p3);\n        if (points.has(p4)) points.delete(p4);\n        else points.add(p4);\n    }\n\n    return points.size === 4 &&\n           points.has(lx + \",\" + ly) && points.has(lx + \",\" + ry) &&\n           points.has(rx + \",\" + ly) && points.has(rx + \",\" + ry) &&\n           area === (rx - lx) * (ry - ly);\n}\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    "
    },
    {
        "id": 61,
        "title": "Frog Jump",
        "difficulty": "Hard",
        "content": {
            "problem": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.",
            "examples": [
                "**Example 1:**\n\n**Input:** stones = \\[0,1,3,5,6,8,12,17\\]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n",
                "**Example 2:**\n\n**Input:** stones = \\[0,1,2,3,4,8,9,11\\]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= stones.length <= 2000`\n*   `0 <= stones[i] <= 231 - 1`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[0,1,3,5,6,8,12,17]",
                "output": "true"
            },
            {
                "input": "[0,1,2,3,4,8,9,11]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean canCross(int[] stones) {\n    Map<Integer, Set<Integer>> dp = new HashMap<>();\n    for (int stone : stones)\n        dp.put(stone, new HashSet<>());\n    dp.get(0).add(0);\n\n    for (int stone : stones) {\n        for (int k : dp.get(stone)) {\n            for (int jump : new int[]{k - 1, k, k + 1}) {\n                if (jump > 0 && dp.containsKey(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return !dp.get(stones[stones.length - 1]).isEmpty();\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "python": "\n    ```python\ndef can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones) {\n    unordered_map<int, unordered_set<int>> dp;\n    int n = stones.size();\n    for (int stone : stones)\n        dp[stone] = unordered_set<int>();\n    dp[0].insert(0);\n\n    for (int stone : stones) {\n        for (int k : dp[stone]) {\n            for (int jump : {k - 1, k, k + 1}) {\n                if (jump > 0 && dp.count(stone + jump))\n                    dp[stone + jump].insert(jump);\n            }\n        }\n    }\n    return !dp[stones.back()].empty();\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "js": "\n    ```javascript\nfunction canCross(stones) {\n    const dp = new Map();\n    stones.forEach(stone => dp.set(stone, new Set()));\n    dp.get(0).add(0);\n\n    for (const stone of stones) {\n        for (const k of dp.get(stone)) {\n            for (const jump of [k - 1, k, k + 1]) {\n                if (jump > 0 && dp.has(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return dp.get(stones[stones.length - 1]).size > 0;\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    "
    },
    {
        "id": 62,
        "title": "Trapping Rain Water II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return _the volume of water it can trap after raining_.",
            "examples": [
                "**Example 1:**\n\n**Input:** heightMap = \\[\\[1,4,3,1,3,2\\],\\[3,2,1,3,2,4\\],\\[2,3,3,2,3,1\\]\\]\n**Output:** 4\n**Explanation:** After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n\n",
                "**Example 2:**\n\n**Input:** heightMap = \\[\\[3,3,3,3,3\\],\\[3,2,2,2,3\\],\\[3,2,1,2,3\\],\\[3,2,2,2,3\\],\\[3,3,3,3,3\\]\\]\n**Output:** 10"
            ],
            "constraints": "**Constraints:**\n\n*   `m == heightMap.length`\n*   `n == heightMap[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= heightMap[i][j] <= 2 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]",
                "output": "4"
            },
            {
                "input": "[[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int trapRainWater(int[][] heightMap) {\n    int m = heightMap.length, n = heightMap[0].length;\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        pq.offer(new int[]{heightMap[i][0], i, 0});\n        pq.offer(new int[]{heightMap[i][n - 1], i, n - 1});\n        visited[i][0] = visited[i][n - 1] = true;\n    }\n\n    for (int i = 1; i < n - 1; i++) {\n        pq.offer(new int[]{heightMap[0][i], 0, i});\n        pq.offer(new int[]{heightMap[m - 1][i], m - 1, i});\n        visited[0][i] = visited[m - 1][i] = true;\n    }\n\n    int water = 0, maxHeight = 0;\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!pq.isEmpty()) {\n        int[] t = pq.poll();\n        int h = t[0], r = t[1], c = t[2];\n        maxHeight = Math.max(maxHeight, h);\n        for (int[] dir : dirs) {\n            int x = r + dir[0], y = c + dir[1];\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];\n            pq.offer(new int[]{heightMap[x][y], x, y});\n            visited[x][y] = true;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a priority queue (min-heap) to store the lowest-height cell on the perimeter of the unvisited area. It processes the minimum height cell from the perimeter, and for each neighbor cell, it calculates the trapped water and updates the neighbor's height if necessary. It then adds the neighbor to the priority queue if it hasn't been visited before.\n\nThe algorithm visits each cell once, and the complexity of adding each cell to the priority queue is O(log(M*N)) where M and N are dimensions of the heightMap, so the overall time complexity is O(M * N * log(M * N)). The space complexity is O(M * N) as a result of the visited array and priority queue.\n\n1. Create a priority queue to store `(height, row, col)` tuples and initialize it with the heightMap boundary cells.\n2. Create a visited matrix of the same dimensions as the heightMap and mark the boundary cells as visited.\n3. Process the cells in the priority queue in increasing order of height.\n4. For each cell, compare its height with the current maxHeight. Calculate the trapped water by subtracting the cell's height from maxHeight if it is smaller.\n5. For each neighbor cell that has not been visited, add the neighbor cell with its height to the priority queue and mark it as visited.\n6. Return the total volume of trapped water.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef trapRainWater(heightMap):\n    m, n = len(heightMap), len(heightMap[0])\n    pq = []\n    visited = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n        heapq.heappush(pq, (heightMap[i][0], i, 0))\n        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))\n        visited[i][0] = visited[i][n - 1] = True\n\n    for i in range(1, n - 1):\n        heapq.heappush(pq, (heightMap[0][i], 0, i))\n        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))\n        visited[0][i] = visited[m - 1][i] = True\n\n    water, maxHeight = 0, 0\n    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while pq:\n        h, r, c = heapq.heappop(pq)\n        maxHeight = max(maxHeight, h)\n        for dx, dy in dirs:\n            x, y = r + dx, c + dy\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:\n                continue\n            if heightMap[x][y] < maxHeight:\n                water += maxHeight - heightMap[x][y]\n            heapq.heappush(pq, (heightMap[x][y], x, y))\n            visited[x][y] = True\n\n    return water\n```\n    \n    The algorithm uses a priority queue (min-heap) to store the lowest-height cell on the perimeter of the unvisited area. It processes the minimum height cell from the perimeter, and for each neighbor cell, it calculates the trapped water and updates the neighbor's height if necessary. It then adds the neighbor to the priority queue if it hasn't been visited before.\n\nThe algorithm visits each cell once, and the complexity of adding each cell to the priority queue is O(log(M*N)) where M and N are dimensions of the heightMap, so the overall time complexity is O(M * N * log(M * N)). The space complexity is O(M * N) as a result of the visited array and priority queue.\n\n1. Create a priority queue to store `(height, row, col)` tuples and initialize it with the heightMap boundary cells.\n2. Create a visited matrix of the same dimensions as the heightMap and mark the boundary cells as visited.\n3. Process the cells in the priority queue in increasing order of height.\n4. For each cell, compare its height with the current maxHeight. Calculate the trapped water by subtracting the cell's height from maxHeight if it is smaller.\n5. For each neighbor cell that has not been visited, add the neighbor cell with its height to the priority queue and mark it as visited.\n6. Return the total volume of trapped water.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint trapRainWater(vector<vector<int>>& heightMap) {\n    int m = heightMap.size(), n = heightMap[0].size();\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    vector<vector<int>> visited(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        pq.push({heightMap[i][0], i * n});\n        pq.push({heightMap[i][n - 1], i * n + n - 1});\n        visited[i][0] = visited[i][n - 1] = 1;\n    }\n\n    for (int i = 1; i < n - 1; i++) {\n        pq.push({heightMap[0][i], i});\n        pq.push({heightMap[m - 1][i], (m - 1) * n + i});\n        visited[0][i] = visited[m - 1][i] = 1;\n    }\n\n    int water = 0, maxHeight = 0;\n    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!pq.empty()) {\n        auto t = pq.top(); pq.pop();\n        int h = t.first, r = t.second / n, c = t.second % n;\n        maxHeight = max(maxHeight, h);\n        for (auto dir : dirs) {\n            int x = r + dir[0], y = c + dir[1];\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];\n            pq.push({heightMap[x][y], x * n + y});\n            visited[x][y] = 1;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a priority queue (min-heap) to store the lowest-height cell on the perimeter of the unvisited area. It processes the minimum height cell from the perimeter, and for each neighbor cell, it calculates the trapped water and updates the neighbor's height if necessary. It then adds the neighbor to the priority queue if it hasn't been visited before.\n\nThe algorithm visits each cell once, and the complexity of adding each cell to the priority queue is O(log(M*N)) where M and N are dimensions of the heightMap, so the overall time complexity is O(M * N * log(M * N)). The space complexity is O(M * N) as a result of the visited array and priority queue.\n\n1. Create a priority queue to store `(height, row, col)` tuples and initialize it with the heightMap boundary cells.\n2. Create a visited matrix of the same dimensions as the heightMap and mark the boundary cells as visited.\n3. Process the cells in the priority queue in increasing order of height.\n4. For each cell, compare its height with the current maxHeight. Calculate the trapped water by subtracting the cell's height from maxHeight if it is smaller.\n5. For each neighbor cell that has not been visited, add the neighbor cell with its height to the priority queue and mark it as visited.\n6. Return the total volume of trapped water.\n    ",
        "js": "\n    ```javascript\nfunction trapRainWater(heightMap) {\n    const m = heightMap.length;\n    const n = heightMap[0].length;\n    const pq = [];\n    const visited = Array.from({ length: m }, () => Array(n).fill(false));\n\n    const comparator = (a, b) => a[0] - b[0];\n\n    for (let i = 0; i < m; i++) {\n        pq.push([heightMap[i][0], i, 0], [heightMap[i][n - 1], i, n - 1]);\n        visited[i][0] = visited[i][n - 1] = true;\n    }\n\n    for (let i = 1; i < n - 1; i++) {\n        pq.push([heightMap[0][i], 0, i], [heightMap[m - 1][i], m - 1, i]);\n        visited[0][i] = visited[m - 1][i] = true;\n    }\n\n    pq.sort(comparator);\n\n    let water = 0;\n    let maxHeight = 0;\n    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n\n    while (pq.length) {\n        const [h, r, c] = pq.shift();\n        maxHeight = Math.max(maxHeight, h);\n        for (const [dx, dy] of dirs) {\n            const x = r + dx;\n            const y = c + dy;\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];\n            pq.push([heightMap[x][y], x, y]);\n            pq.sort(comparator);\n            visited[x][y] = true;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a priority queue (min-heap) to store the lowest-height cell on the perimeter of the unvisited area. It processes the minimum height cell from the perimeter, and for each neighbor cell, it calculates the trapped water and updates the neighbor's height if necessary. It then adds the neighbor to the priority queue if it hasn't been visited before.\n\nThe algorithm visits each cell once, and the complexity of adding each cell to the priority queue is O(log(M*N)) where M and N are dimensions of the heightMap, so the overall time complexity is O(M * N * log(M * N)). The space complexity is O(M * N) as a result of the visited array and priority queue.\n\n1. Create a priority queue to store `(height, row, col)` tuples and initialize it with the heightMap boundary cells.\n2. Create a visited matrix of the same dimensions as the heightMap and mark the boundary cells as visited.\n3. Process the cells in the priority queue in increasing order of height.\n4. For each cell, compare its height with the current maxHeight. Calculate the trapped water by subtracting the cell's height from maxHeight if it is smaller.\n5. For each neighbor cell that has not been visited, add the neighbor cell with its height to the priority queue and mark it as visited.\n6. Return the total volume of trapped water.\n    "
    },
    {
        "id": 63,
        "title": "Split Array Largest Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[7,2,5,10,8],2",
                "output": "18"
            },
            {
                "input": "[1,2,3,4,5],2",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic int splitArray(int[] nums, int m) {\n    long left = 0, right = 0;\n    for (int num : nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        long mid = (left + right) / 2;\n        int count = 1;\n        long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "python": "\n    ```python\ndef splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "c++": "\n    ```cpp\nint splitArray(vector<int>& nums, int m) {\n    long long left = 0, right = 0;\n    for (int num : nums) {\n        left = max(left, (long long)num);\n        right += num;\n    }\n\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        int count = 1;\n        long long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "js": "\n    ```javascript\nfunction splitArray(nums, m) {\n    let left = 0, right = 0;\n    for (let num of nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curSum = 0;\n        for (let num of nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    "
    },
    {
        "id": 64,
        "title": "Strong Password Checker",
        "difficulty": "Hard",
        "content": {
            "problem": "A password is considered strong if the below conditions are all met:\n\n*   It has at least `6` characters and at most `20` characters.\n*   It contains at least **one lowercase** letter, at least **one uppercase** letter, and at least **one digit**.\n*   It does not contain three repeating characters in a row (i.e., `\"B**aaa**bb0 \"` is weak, but `\"B**aa**b**a**0 \"` is strong).\n\nGiven a string `password`, return _the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`._\n\nIn one step, you can:\n\n*   Insert one character to `password`,\n*   Delete one character from `password`, or\n*   Replace one character of `password` with another character.",
            "examples": [
                "**Example 1:**\n\n**Input:** password = \"a\"\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** password = \"aA1\"\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** password = \"1337C0d3\"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= password.length <= 50`\n*   `password` consists of letters, digits, dot `'.'` or exclamation mark `'!'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "\"a\"",
                "output": "5"
            },
            {
                "input": "\"aA1\"",
                "output": "3"
            },
            {
                "input": "\"1337C0d3\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nint strongPassword(String password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = password.length();\n    for (char c : password.toCharArray()) {\n        if (Character.isLowerCase(c)) missingLower = 0;\n        if (Character.isUpperCase(c)) missingUpper = 0;\n        if (Character.isDigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "python": "\n    ```python\ndef strong_password(password):\n    missing_lower = 1\n    missing_upper = 1\n    missing_digit = 1\n    total = len(password)\n    \n    for c in password:\n        if c.islower(): missing_lower = 0\n        if c.isupper(): missing_upper = 0\n        if c.isdigit(): missing_digit = 0\n    \n    missing = missing_lower + missing_upper + missing_digit\n    if total < 6: return max(missing, 6 - total)\n    if total > 20: return missing + total - 20\n\n    return missing\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\nint strongPassword(string password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = (int)password.size();\n    for (char c : password) {\n        if (islower(c)) missingLower = 0;\n        if (isupper(c)) missingUpper = 0;\n        if (isdigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "js": "\n    ```javascript\nfunction strongPassword(password) {\n    let missingLower = 1, missingUpper = 1, missingDigit = 1;\n    let total = password.length;\n    for (const c of password) {\n        if (c.match(/[a-z]/)) missingLower = 0;\n        if (c.match(/[A-Z]/)) missingUpper = 0;\n        if (c.match(/[0-9]/)) missingDigit = 0;\n    }\n    let missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    "
    },
    {
        "id": 65,
        "title": "K-th Smallest in Lexicographical Order",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two integers `n` and `k`, return _the_ `kth` _lexicographically smallest integer in the range_ `[1, n]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13, k = 2\n**Output:** 10\n**Explanation:** The lexicographical order is \\[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9\\], so the second smallest number is 10.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Trie"
        ],
        "example": [
            {
                "input": "13,2",
                "output": "10"
            },
            {
                "input": "1,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\npublic class Solution {\n    public int findKthNumber(int n, int k) {\n        List<Integer> nums = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            nums.add(i);\n        }\n        nums.sort((a, b) -> String.valueOf(a).compareTo(String.valueOf(b)));\n        return nums.get(k - 1);\n    }\n}\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "python": "\n    ```python\ndef find_kth_number(n, k):\n    nums = [i for i in range(1, n + 1)]\n    nums.sort(key=lambda x: str(x))\n    return nums[k - 1]\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint findKthNumber(int n, int k) {\n    vector<int> nums;\n    for (int i = 1; i <= n; ++i) {\n        nums.push_back(i);\n    }\n    sort(nums.begin(), nums.end(), [](int a, int b) {\n        return to_string(a) < to_string(b);\n    });\n    return nums[k - 1];\n}\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "js": "\n    ```javascript\nfunction findKthNumber(n, k) {\n    const nums = [];\n    for (let i = 1; i <= n; i++) {\n        nums.push(i);\n    }\n    nums.sort((a, b) => String(a).localeCompare(String(b)));\n    return nums[k - 1];\n}\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    "
    },
    {
        "id": 66,
        "title": "Poor Pigs",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1.  Choose some live pigs to feed.\n2.  For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3.  Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4.  After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5.  Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return _the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time_.",
            "examples": [
                "**Example 1:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 15\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n\n",
                "**Example 2:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 30\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= buckets <= 1000`\n*   `1 <= minutesToDie <= minutesToTest <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "4,15,15",
                "output": "2"
            },
            {
                "input": "4,15,30",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "python": "\n    ```python\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "c++": "\n    ```cpp\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "js": "\n    ```javascript\nfunction poorPigs(buckets, minutesToDie, minutesToTest) {\n    let pigs = 0;\n    while (Math.pow(Math.floor(minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    "
    },
    {
        "id": 67,
        "title": "LFU Cache",
        "difficulty": "Hard",
        "content": {
            "problem": "Design and implement a data structure for a [Least Frequently Used (LFU)](https://en.wikipedia.org/wiki/Least_frequently_used) cache.\n\nImplement the `LFUCache` class:\n\n*   `LFUCache(int capacity)` Initializes the object with the `capacity` of the data structure.\n*   `int get(int key)` Gets the value of the `key` if the `key` exists in the cache. Otherwise, returns `-1`.\n*   `void put(int key, int value)` Update the value of the `key` if present, or inserts the `key` if not already present. When the cache reaches its `capacity`, it should invalidate and remove the **least frequently used** key before inserting a new item. For this problem, when there is a **tie** (i.e., two or more keys with the same frequency), the **least recently used** `key` would be invalidated.\n\nTo determine the least frequently used key, a **use counter** is maintained for each key in the cache. The key with the smallest **use counter** is the least frequently used key.\n\nWhen a key is first inserted into the cache, its **use counter** is set to `1` (due to the `put` operation). The **use counter** for a key in the cache is incremented either a `get` or `put` operation is called on it.\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"LFUCache \",  \"put \",  \"put \",  \"get \",  \"put \",  \"get \",  \"get \",  \"put \",  \"get \",  \"get \",  \"get \"\\]\n\\[\\[2\\], \\[1, 1\\], \\[2, 2\\], \\[1\\], \\[3, 3\\], \\[2\\], \\[3\\], \\[4, 4\\], \\[1\\], \\[3\\], \\[4\\]\\]\n**Output**\n\\[null, null, null, 1, null, -1, 3, null, -1, 3, 4\\]\n\n**Explanation**\n// cnt(x) = the use counter for key x\n// cache=\\[\\] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=\\[1,\\_\\], cnt(1)=1\nlfu.put(2, 2);   // cache=\\[2,1\\], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=\\[1,2\\], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                 // cache=\\[3,1\\], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=\\[3,1\\], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=\\[4,3\\], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=\\[3,4\\], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=\\[4,3\\], cnt(4)=2, cnt(3)=3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= capacity <= 104`\n*   `0 <= key <= 105`\n*   `0 <= value <= 109`\n*   At most `2 * 105` calls will be made to `get` and `put`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Linked List",
            "Design",
            "Doubly-Linked List"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,1,null,-1,3,null,-1,3,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\n\nclass LFUCache {\n    private int minFreq;\n    private int capacity;\n    private Map<Integer, Integer> keyValue;\n    private Map<Integer, Integer> keyFreq;\n    private Map<Integer, LinkedHashSet<Integer>> freqList;\n\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.minFreq = 0;\n        this.keyValue = new HashMap<>();\n        this.keyFreq = new HashMap<>();\n        this.freqList = new HashMap<>();\n        freqList.put(1, new LinkedHashSet<>());\n    }\n    \n    public int get(int key) {\n        if (!keyValue.containsKey(key)) return -1;\n        int count = keyFreq.get(key);\n        keyFreq.put(key, count + 1);\n        freqList.get(count).remove(key);\n        \n        if (count == minFreq && freqList.get(count).size() == 0) minFreq++;\n        \n        freqList.computeIfAbsent(count + 1, k -> new LinkedHashSet<>());\n        freqList.get(count + 1).add(key);\n        \n        return keyValue.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (capacity <= 0) return;\n        if (keyValue.containsKey(key)) {\n            keyValue.put(key, value);\n            get(key);\n            return;\n        }\n        if (keyValue.size() >= capacity) {\n            int evict = freqList.get(minFreq).iterator().next();\n            freqList.get(minFreq).remove(evict);\n            keyValue.remove(evict);\n        }\n        keyValue.put(key, value);\n        keyFreq.put(key, 1);\n        minFreq = 1;\n        freqList.get(1).add(key);\n    }\n}\n```\n\n    \n    The implemented LFUCache is a combined data structure using a hash map and linked lists. We maintain 3 key-value mappings: the first is the cache `keyValue` which stores `<key, value>` pairs; the second is `keyFreq`, which keeps track of each key's frequency; the last is `freqList` which keeps the mapping of frequency to a list/set of keys that are at that frequency.\n\nBoth get() and put() operations take constant O(1) average time complexity:\n\n1. get():\n  - With the help of hashmaps, retrieve the value for the key in constant time.\n  - Increment the key’s frequency in `keyFreq` by 1.\n  - Update the corresponding list/set of the `freqList`.\n  - Update the minFreq if necessary.\n\n2. put():\n  - Check if the key is already present in the cache. If it is, update the value, and perform get() operation, thus maintaining frequency count.\n  - If the key is not present, add the key-value pair and set its frequency to 1.\n  - Evict the LFU (least frequently used) key if necessary, by removing a key from the list/set of `freqList[minFreq]`.\n\nNote that in Java and JavaScript, we use LinkedHashSet / Set, while in Python we use list within the `freqList`. This is due to language-specific details.\n    ",
        "python": "\n    ```python\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_value = {}\n        self.key_freq = {}\n        self.freq_list = {1: []}\n\n    def get(self, key: int) -> int:\n        if key not in self.key_value:\n            return -1\n        count = self.key_freq[key]\n        self.key_freq[key] += 1\n        self.freq_list[count].remove(key)\n\n        if count == self.min_freq and not self.freq_list[count]:\n            self.min_freq += 1\n\n        if count + 1 not in self.freq_list:\n            self.freq_list[count + 1] = []\n        self.freq_list[count + 1].append(key)\n\n        return self.key_value[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n        if key in self.key_value:\n            self.key_value[key] = value\n            self.get(key)\n            return\n        \n        if len(self.key_value) >= self.capacity:\n            evict = self.freq_list[self.min_freq][0]\n            self.freq_list[self.min_freq].pop(0)\n            del self.key_value[evict]\n\n        self.key_value[key] = value\n        self.key_freq[key] = 1\n        self.min_freq = 1\n        self.freq_list[1].append(key)\n```\n\n    \n    The implemented LFUCache is a combined data structure using a hash map and linked lists. We maintain 3 key-value mappings: the first is the cache `keyValue` which stores `<key, value>` pairs; the second is `keyFreq`, which keeps track of each key's frequency; the last is `freqList` which keeps the mapping of frequency to a list/set of keys that are at that frequency.\n\nBoth get() and put() operations take constant O(1) average time complexity:\n\n1. get():\n  - With the help of hashmaps, retrieve the value for the key in constant time.\n  - Increment the key’s frequency in `keyFreq` by 1.\n  - Update the corresponding list/set of the `freqList`.\n  - Update the minFreq if necessary.\n\n2. put():\n  - Check if the key is already present in the cache. If it is, update the value, and perform get() operation, thus maintaining frequency count.\n  - If the key is not present, add the key-value pair and set its frequency to 1.\n  - Evict the LFU (least frequently used) key if necessary, by removing a key from the list/set of `freqList[minFreq]`.\n\nNote that in Java and JavaScript, we use LinkedHashSet / Set, while in Python we use list within the `freqList`. This is due to language-specific details.\n    ",
        "c++": "\n    ```cpp\n#include <list>\n#include <unordered_map>\n\nclass LFUCache {\npublic:\n    LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\n    \n    int get(int key) {\n        if (cache.count(key) == 0) return -1;\n        auto& node = cache[key];\n        freqList[node.freq].erase(node.iter);\n        if (freqList[minFreq].size() == 0) minFreq++;\n        node.freq++;\n        freqList[node.freq].push_back(key);\n        node.iter = prev(freqList[node.freq].end());\n        return node.value;\n    }\n    \n    void put(int key, int value) {\n        if (capacity == 0) return;\n        if (get(key) != -1) {\n            cache[key].value = value;\n            return;\n        }\n        if (cache.size() >= capacity) {\n            int toRemove = freqList[minFreq].front();\n            freqList[minFreq].pop_front();\n            cache.erase(toRemove);\n        }\n        minFreq = 1;\n        freqList[minFreq].push_back(key);\n        cache[key] = {1, value, prev(freqList[minFreq].end())};\n    }\n\nprivate:\n    struct Node {\n        int freq, value;\n        std::list<int>::iterator iter;\n    };\n    \n    int capacity;\n    int minFreq;\n    std::unordered_map<int, Node> cache;\n    std::unordered_map<int, std::list<int>> freqList;\n};\n```\n\n    \n    The implemented LFUCache is a combined data structure using a hash map and linked lists. We maintain 3 key-value mappings: the first is the cache `keyValue` which stores `<key, value>` pairs; the second is `keyFreq`, which keeps track of each key's frequency; the last is `freqList` which keeps the mapping of frequency to a list/set of keys that are at that frequency.\n\nBoth get() and put() operations take constant O(1) average time complexity:\n\n1. get():\n  - With the help of hashmaps, retrieve the value for the key in constant time.\n  - Increment the key’s frequency in `keyFreq` by 1.\n  - Update the corresponding list/set of the `freqList`.\n  - Update the minFreq if necessary.\n\n2. put():\n  - Check if the key is already present in the cache. If it is, update the value, and perform get() operation, thus maintaining frequency count.\n  - If the key is not present, add the key-value pair and set its frequency to 1.\n  - Evict the LFU (least frequently used) key if necessary, by removing a key from the list/set of `freqList[minFreq]`.\n\nNote that in Java and JavaScript, we use LinkedHashSet / Set, while in Python we use list within the `freqList`. This is due to language-specific details.\n    ",
        "js": "\n    ```javascript\nclass LFUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.minFreq = 0;\n        this.keyValue = new Map();\n        this.keyFreq = new Map();\n        this.freqList = new Map();\n        this.freqList.set(1, new Set());\n    }\n\n    get(key) {\n        if (!this.keyValue.has(key)) return -1;\n        let count = this.keyFreq.get(key);\n        this.keyFreq.set(key, count + 1);\n        this.freqList.get(count).delete(key);\n        \n        if (count === this.minFreq && this.freqList.get(count).size === 0) this.minFreq++;\n        \n        if (!this.freqList.has(count + 1)) this.freqList.set(count + 1, new Set());\n        this.freqList.get(count + 1).add(key);\n        \n        return this.keyValue.get(key);\n    }\n\n    put(key, value) {\n        if (this.capacity <= 0) return;\n        if (this.keyValue.has(key)) {\n            this.keyValue.set(key, value);\n            this.get(key);\n            return;\n        }\n        if (this.keyValue.size >= this.capacity) {\n            const evict = this.freqList.get(this.minFreq).values().next().value;\n            this.freqList.get(this.minFreq).delete(evict);\n            this.keyValue.delete(evict);\n        }\n        this.keyValue.set(key, value);\n        this.keyFreq.set(key, 1);\n        this.minFreq = 1;\n        this.freqList.get(1).add(key);\n    }\n}\n```\n\n    \n    The implemented LFUCache is a combined data structure using a hash map and linked lists. We maintain 3 key-value mappings: the first is the cache `keyValue` which stores `<key, value>` pairs; the second is `keyFreq`, which keeps track of each key's frequency; the last is `freqList` which keeps the mapping of frequency to a list/set of keys that are at that frequency.\n\nBoth get() and put() operations take constant O(1) average time complexity:\n\n1. get():\n  - With the help of hashmaps, retrieve the value for the key in constant time.\n  - Increment the key’s frequency in `keyFreq` by 1.\n  - Update the corresponding list/set of the `freqList`.\n  - Update the minFreq if necessary.\n\n2. put():\n  - Check if the key is already present in the cache. If it is, update the value, and perform get() operation, thus maintaining frequency count.\n  - If the key is not present, add the key-value pair and set its frequency to 1.\n  - Evict the LFU (least frequently used) key if necessary, by removing a key from the list/set of `freqList[minFreq]`.\n\nNote that in Java and JavaScript, we use LinkedHashSet / Set, while in Python we use list within the `freqList`. This is due to language-specific details.\n    "
    },
    {
        "id": 68,
        "title": "Count The Repetitions",
        "difficulty": "Hard",
        "content": {
            "problem": "We define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times.\n\n*   For example, `str == [ \"abc \", 3] == \"abcabcabc \"`.\n\nWe define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`.\n\n*   For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded underlined characters.\n\nYou are given two strings `s1` and `s2` and two integers `n1` and `n2`. You have the two strings `str1 = [s1, n1]` and `str2 = [s2, n2]`.\n\nReturn _the maximum integer_ `m` _such that_ `str = [str2, m]` _can be obtained from_ `str1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.\n*   `1 <= n1, n2 <= 106`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"acb\",4,\"ab\",2",
                "output": "2"
            },
            {
                "input": "\"acb\",1,\"acb\",1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "python": "\n    ```python\ndef getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "c++": "\n    ```cpp\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "js": "\n    ```javascript\nfunction getMaxRepetitions(s1, n1, s2, n2) {\n    let count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) === s2.charAt(j)) {\n            j++;\n            if (j === s2.length) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i === s1.length) {\n            i = 0;\n            count1++;\n        }\n    }\n    return Math.floor(count2 / n2);\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    "
    },
    {
        "id": 69,
        "title": "Concatenated Words",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.\n\nA **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"cats \", \"catsdogcats \", \"dog \", \"dogcatsdog \", \"hippopotamuses \", \"rat \", \"ratcatdogcat \"\\]\n**Output:** \\[ \"catsdogcats \", \"dogcatsdog \", \"ratcatdogcat \"\\]\n**Explanation:**  \"catsdogcats \" can be concatenated by  \"cats \",  \"dog \" and  \"cats \"; \n \"dogcatsdog \" can be concatenated by  \"dog \",  \"cats \" and  \"dog \"; \n \"ratcatdogcat \" can be concatenated by  \"rat \",  \"cat \",  \"dog \" and  \"cat \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"cat \", \"dog \", \"catdog \"\\]\n**Output:** \\[ \"catdog \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= words[i].length <= 30`\n*   `words[i]` consists of only lowercase English letters.\n*   All the strings of `words` are **unique**.\n*   `1 <= sum(words[i].length) <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Depth-First Search",
            "Trie"
        ],
        "example": [
            {
                "input": "[\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
                "output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]"
            },
            {
                "input": "[\"cat\",\"dog\",\"catdog\"]",
                "output": "[\"catdog\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Solution {\n    public boolean isConcatenated(String word, Set<String> wordDict) {\n        int n = word.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && wordDict.contains(word.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n\n    public List<String> findAllConcatenatedWords(String[] words) {\n        Set<String> wordDict = new HashSet<>();\n        for (String word : words) {\n            wordDict.add(word);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (isConcatenated(word, wordDict)) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "python": "\n    ```python\ndef is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool isConcatenated(const string& word, unordered_set<string>& wordDict) {\n    int n = word.size();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.count(word.substr(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nvector<string> findAllConcatenatedWords(vector<string>& words) {\n    unordered_set<string> wordDict(words.begin(), words.end());\n    vector<string> result;\n\n    for (const string& word : words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "js": "\n    ```javascript\nfunction isConcatenated(word, wordDict) {\n    const n = word.length;\n    const dp = Array(n + 1).fill(false);\n    dp[0] = true;\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.has(word.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nfunction findAllConcatenatedWords(words) {\n    const wordDict = new Set(words);\n    const result = [];\n\n    for (const word of words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    "
    },
    {
        "id": 70,
        "title": "Largest Palindrome Product",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer n, return _the **largest palindromic integer** that can be represented as the product of two `n`\\-digits integers_. Since the answer can be very large, return it **modulo** `1337`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 8`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration"
        ],
        "example": [
            {
                "input": "2",
                "output": "987\nExplanation:99x91=9009,9009%1337=987"
            },
            {
                "input": "1",
                "output": "9"
            }
        ],
        "java": "\n    ```java\nint largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = (int) Math.pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long temp = i;\n        long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long palindrome = i * (long) Math.pow(10, n) + reverse;\n        for (long j = upper_limit; j > lower_limit; --j) {\n            long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return (int) (palindrome % 1337);\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "python": "\n    ```python\ndef largestPalindrome(n):\n    if n == 1: \n        return 9\n    upper_limit = 10**n - 1\n    lower_limit = upper_limit // 10\n    for i in range(upper_limit, lower_limit, -1):\n        temp = i\n        reverse = 0\n        while temp != 0:\n            reverse = reverse * 10 + temp % 10\n            temp //= 10\n        palindrome = i * (10**n) + reverse\n        for j in range(upper_limit, lower_limit, -1):\n            product = palindrome // j\n            if palindrome % j == 0 and product <= upper_limit:\n                return palindrome % 1337\n    return -1\n```\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long long temp = i;\n        long long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long long palindrome = i * pow(10, n) + reverse;\n        for (long long j = upper_limit; j > lower_limit; --j) {\n            long long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction largestPalindrome(n) {\n    if (n === 1) return 9; // Handle 1-digit numbers\n    let upper_limit = Math.pow(10, n) - 1;\n    let lower_limit = Math.floor(upper_limit / 10);\n    for (let i = upper_limit; i > lower_limit; i--) {\n        let temp = i;\n        let reverse = 0;\n        while (temp !== 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp = Math.floor(temp / 10);\n        }\n        let palindrome = i * Math.pow(10, n) + reverse;\n        for (let j = upper_limit; j > lower_limit; j--) {\n            let product = Math.floor(palindrome / j);\n            if (palindrome % j === 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n```\n\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    "
    },
    {
        "id": 71,
        "title": "Sliding Window Median",
        "difficulty": "Hard",
        "content": {
            "problem": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\n*   For examples, if `arr = [2,3,4]`, the median is `3`.\n*   For examples, if `arr = [1,2,3,4]`, the median is `(2 + 3) / 2 = 2.5`.\n\nYou are given an integer array `nums` and an integer `k`. There is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn _the median array for each window in the original array_. Answers within `10-5` of the actual value will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,-1,-3,5,3,6,7\\], k = 3\n**Output:** \\[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000\\]\n**Explanation:** \nWindow position                Median\n---------------                -----\n\\[**1  3  -1**\\] -3  5  3  6  7        1\n 1 \\[**3  -1  -3**\\] 5  3  6  7       -1\n 1  3 \\[**\\-1  -3  5**\\] 3  6  7       -1\n 1  3  -1 \\[**\\-3  5  3**\\] 6  7        3\n 1  3  -1  -3 \\[**5  3  6**\\] 7        5\n 1  3  -1  -3  5 \\[**3  6  7**\\]       6\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,2,3,1,4,2\\], k = 3\n**Output:** \\[2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[1,3,-1,-3,5,3,6,7],3",
                "output": "[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]"
            },
            {
                "input": "[1,2,3,4,2,3,1,4,2],3",
                "output": "[2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeMap;\n\npublic double[] medianSlidingWindow(int[] nums, int k) {\n    TreeMap<Integer, Integer> window = new TreeMap<>();\n    int n = nums.length;\n    double[] result = new double[n - k + 1];\n\n    for (int i = 0; i < k; i++) {\n        window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n    }\n\n    for (int i = k; i <= n; i++) {\n        int cnt = 0, mid1 = 0, mid2 = 0;\n        for (Integer num : window.keySet()) {\n            cnt += window.get(num);\n            if (cnt >= (k + 1) / 2 && mid1 == 0) {\n                mid1 = num;\n            }\n            if (cnt >= (k + 2) / 2) {\n                mid2 = num;\n                break;\n            }\n        }\n\n        result[i - k] = ((double) mid1 + mid2) / 2;\n\n        if (i < n) {\n            window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n            window.put(nums[i - k], window.get(nums[i - k]) - 1);\n            if (window.get(nums[i - k]) == 0) {\n                window.remove(nums[i - k]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm initializes a sliding window of size `k`. The sliding window is used as a data structure that keeps track of the current `k` elements and maintains the ordering of the values, which can be a multiset or sorted list.\n\nLoop through the array from position `k` until the end. For each iteration, calculate the median of the current sliding window. If `k` is even, the median is the mean of the two middle values; if `k` is odd, the median is the middle value. Push the median value into a result array.\n\nRemove the leftmost element of the sliding window (the one that is out of the window now), and insert the next element in the array into the sliding window. Continue this process until the end of the array, and return the result array containing the median values. \n\nThis algorithm takes advantage of the ordered data structure to achieve an efficient median retrieval for each sliding window.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedList\n\ndef medianSlidingWindow(nums, k):\n    window = SortedList(nums[:k])\n    medians = []\n    \n    for i in range(k, len(nums) + 1):\n        medians.append((window[k // 2 - 1] + window[k // 2]) / 2 if k % 2 == 0 else float(window[k // 2]))\n        \n        if i < len(nums):\n            window.remove(nums[i - k])\n            window.add(nums[i])\n\n    return medians\n```\n\n    \n    The algorithm initializes a sliding window of size `k`. The sliding window is used as a data structure that keeps track of the current `k` elements and maintains the ordering of the values, which can be a multiset or sorted list.\n\nLoop through the array from position `k` until the end. For each iteration, calculate the median of the current sliding window. If `k` is even, the median is the mean of the two middle values; if `k` is odd, the median is the middle value. Push the median value into a result array.\n\nRemove the leftmost element of the sliding window (the one that is out of the window now), and insert the next element in the array into the sliding window. Continue this process until the end of the array, and return the result array containing the median values. \n\nThis algorithm takes advantage of the ordered data structure to achieve an efficient median retrieval for each sliding window.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<double> medianSlidingWindow(std::vector<int>& nums, int k) {\n    std::multiset<int> window(nums.begin(), nums.begin() + k);\n    auto mid = std::next(window.begin(), k / 2);\n    std::vector<double> medians;\n\n    for (int i = k;; i++) {\n        medians.push_back((double(*mid) + *std::prev(mid, 1 - k % 2)) / 2);\n        \n        if (i == nums.size()) {\n            return medians;\n        }\n        window.insert(nums[i]);\n        if (nums[i] < *mid) {\n            mid--;\n        }\n        if (nums[i - k] <= *mid) {\n            mid++;\n        }\n        window.erase(window.lower_bound(nums[i - k]));\n    }\n}\n```\n\n    \n    The algorithm initializes a sliding window of size `k`. The sliding window is used as a data structure that keeps track of the current `k` elements and maintains the ordering of the values, which can be a multiset or sorted list.\n\nLoop through the array from position `k` until the end. For each iteration, calculate the median of the current sliding window. If `k` is even, the median is the mean of the two middle values; if `k` is odd, the median is the middle value. Push the median value into a result array.\n\nRemove the leftmost element of the sliding window (the one that is out of the window now), and insert the next element in the array into the sliding window. Continue this process until the end of the array, and return the result array containing the median values. \n\nThis algorithm takes advantage of the ordered data structure to achieve an efficient median retrieval for each sliding window.\n    ",
        "js": "\n    ```javascript\nfunction medianSlidingWindow(nums, k) {\n    const window = new SortedSet();\n    const medians = [];\n\n    for (let i = 0; i < k; i++) {\n        window.add(nums[i]);\n    }\n\n    for (let i = k; i <= nums.length; i++) {\n        const mid1 = window.at(Math.floor((k - 1) / 2));\n        const mid2 = window.at(Math.floor(k / 2));\n\n        medians.push((mid1 + mid2) / 2);\n\n        if (i < nums.length) {\n            window.delete(nums[i - k]);\n            window.add(nums[i]);\n        }\n    }\n\n    return medians;\n}\n```\n\n    \n    The algorithm initializes a sliding window of size `k`. The sliding window is used as a data structure that keeps track of the current `k` elements and maintains the ordering of the values, which can be a multiset or sorted list.\n\nLoop through the array from position `k` until the end. For each iteration, calculate the median of the current sliding window. If `k` is even, the median is the mean of the two middle values; if `k` is odd, the median is the middle value. Push the median value into a result array.\n\nRemove the leftmost element of the sliding window (the one that is out of the window now), and insert the next element in the array into the sliding window. Continue this process until the end of the array, and return the result array containing the median values. \n\nThis algorithm takes advantage of the ordered data structure to achieve an efficient median retrieval for each sliding window.\n    "
    },
    {
        "id": 72,
        "title": "Smallest Good Base",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n` represented as a string, return _the smallest **good base** of_ `n`.\n\nWe call `k >= 2` a **good base** of `n`, if all digits of `n` base `k` are `1`'s.",
            "examples": [
                "**Example 1:**\n\n**Input:** n =  \"13 \"\n**Output:**  \"3 \"\n**Explanation:** 13 base 3 is 111.\n\n",
                "**Example 2:**\n\n**Input:** n =  \"4681 \"\n**Output:**  \"8 \"\n**Explanation:** 4681 base 8 is 11111.\n\n",
                "**Example 3:**\n\n**Input:** n =  \"1000000000000000000 \"\n**Output:**  \"999999999999999999 \"\n**Explanation:** 1000000000000000000 base 999999999999999999 is 11."
            ],
            "constraints": "**Constraints:**\n\n*   `n` is an integer in the range `[3, 1018]`.\n*   `n` does not contain any leading zeros.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "\"13\"",
                "output": "\"3\""
            },
            {
                "input": "\"4681\"",
                "output": "\"8\""
            },
            {
                "input": "\"1000000000000000000\"",
                "output": "\"999999999999999999\""
            }
        ],
        "java": "\n    ```java\npublic class SmallestGoodBase {\n    public String smallestGoodBase(String n) {\n        long num_n = Long.parseLong(n);\n        \n        for(int m = (int)(Math.log(num_n)/Math.log(2)) + 1; m >= 1; m--) {\n            long k = (long)Math.pow((double)num_n, 1.0 / m);\n            long sum = 0;\n            for(int i=0; i <= m; i++) {\n                sum = sum * k + 1;\n            }\n            if(sum == num_n) {\n                return String.valueOf(k);\n            }\n        }\n        \n        return \"-1\";\n    }\n}\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "python": "\n    ```python\ndef smallest_good_base(n: str) -> str:\n    num_n = int(n)\n\n    for m in range(int(num_n.bit_length()), 0, -1):\n        k = int(num_n ** (1.0 / m))\n        if sum(k**i for i in range(m+1)) == num_n:\n            return str(k)\n\n    return \"-1\"\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "c++": "\n    ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll smallestGoodBase(string n) {\n    ll num_n = stoll(n);\n    \n    for(int m = log2(num_n) + 1; m >= 1; m--) {\n        ll k = pow(num_n, 1.0 / m);\n        ll sum = 0;\n        for(int i=0; i <= m; i++) {\n            sum = sum * k + 1;\n        }\n        if(sum == num_n) {\n            return k;\n        }\n    }\n    \n    return -1;\n}\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "js": "\n    ```javascript\nfunction smallestGoodBase(n) {\n    const num_n = BigInt(n);\n    \n    for(let m = BigInt(Math.floor(Math.log2(Number(n))) + 1); m >= 1; m--) {\n        const k = BigInt(Math.floor(num_n ** (1n / m)));\n        let sum = 0n;\n        for(let i=0n; i <= m; i++) {\n            sum = sum * k + 1n;\n        }\n        if(sum === num_n) {\n            return String(k);\n        }\n    }\n    \n    return \"-1\";\n}\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    "
    },
    {
        "id": 73,
        "title": "Zuma Game",
        "difficulty": "Hard",
        "content": {
            "problem": "You are playing a variation of the game Zuma.\n\nIn this variation of Zuma, there is a **single row** of colored balls on a board, where each ball can be colored red `'R'`, yellow `'Y'`, blue `'B'`, green `'G'`, or white `'W'`. You also have several colored balls in your hand.\n\nYour goal is to **clear all** of the balls from the board. On each turn:\n\n*   Pick **any** ball from your hand and insert it in between two balls in the row or on either end of the row.\n*   If there is a group of **three or more consecutive balls** of the **same color**, remove the group of balls from the board.\n    *   If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n*   If there are no more balls on the board, then you win the game.\n*   Repeat this process until you either win or do not have any more balls in your hand.\n\nGiven a string `board`, representing the row of balls on the board, and a string `hand`, representing the balls in your hand, return _the **minimum** number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return_ `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** board =  \"WRRBBW \", hand =  \"RB \"\n**Output:** -1\n**Explanation:** It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\n\n",
                "**Example 2:**\n\n**Input:** board =  \"WWRRBBWW \", hand =  \"WRBRW \"\n**Output:** 2\n**Explanation:** To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\n\n",
                "**Example 3:**\n\n**Input:** board =  \"G \", hand =  \"GGGGG \"\n**Output:** 2\n**Explanation:** To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= board.length <= 16`\n*   `1 <= hand.length <= 5`\n*   `board` and `hand` consist of the characters `'R'`, `'Y'`, `'B'`, `'G'`, and `'W'`.\n*   The initial row of balls on the board will **not** have any groups of three or more consecutive balls of the same color.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Stack",
            "Breadth-First Search",
            "Memoization"
        ],
        "example": [
            {
                "input": "\"WRRBBW\",\"RB\"",
                "output": "-1"
            },
            {
                "input": "\"WWRRBBWW\",\"WRBRW\"",
                "output": "2"
            },
            {
                "input": "\"G\",\"GGGGG\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int findMinStep(String board, String hand) {\n        HashMap<Character, Integer> handMap = new HashMap<>();\n        for (char c : hand.toCharArray()) handMap.put(c, handMap.getOrDefault(c, 0) + 1);\n\n        return findMinStepHelper(board, new HashMap<String, Integer>(), handMap);\n    }\n\n    private int findMinStepHelper(String board, HashMap<String, Integer> memo, HashMap<Character, Integer> hand) {\n        if (board.isEmpty()) return 0;\n        if (memo.containsKey(board)) return memo.get(board);\n\n        int result = Integer.MAX_VALUE;\n        for (int i = 0, j = 0; i < board.length(); i = j) {\n            while (j < board.length() && board.charAt(i) == board.charAt(j)) ++j;\n            char color = board.charAt(i);\n            int required = 3 - (j - i);\n            if (hand.getOrDefault(color, 0) >= required) {\n                hand.put(color, hand.get(color) - required);\n                String nextBoard = board.substring(0, i) + board.substring(j);\n                int tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp != -1) result = Math.min(result, tmp + required);\n                hand.put(color, hand.get(color) + required);\n            }\n        }\n\n        int res = (result == Integer.MAX_VALUE) ? -1 : result;\n        memo.put(board, res);\n        return res;\n    }\n}\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef find_min_step(board: str, hand: str) -> int:\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1            \n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    return find_min_step_helper(board, memo, hand_count)\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) {\n    if (board.empty()) return 0;\n    if (memo.count(board)) return memo[board];\n\n    int result = INT_MAX;\n    for (int i = 0, j = 0; i < board.size(); i = j) {\n        while (j < board.size() and board[i] == board[j]) ++j;\n        char color = board[i];\n        int required = 3 - (j - i);\n        if (hand[color] >= required) {\n            hand[color] -= required;\n            string next_board = board.substr(0, i) + board.substr(j);\n            int tmp = find_min_step_helper(next_board, memo, hand);\n            if (tmp != -1) result = min(result, tmp + required);\n            hand[color] += required;\n        }\n    }\n\n    memo[board] = result == INT_MAX ? -1 : result;\n    return memo[board];\n}\n\nint find_min_step(string board, string hand) {\n    unordered_map<char, int> hand_map;\n    for (char c : hand) ++hand_map[c];\n    unordered_map<string, int> memo;\n    return find_min_step_helper(board, memo, hand_map);\n}\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    ",
        "js": "\n    ```javascript\nfunction findMinStep(board, hand) {\n    function findMinStepHelper(board, memo, hand) {\n        if (board.length === 0) return 0;\n        if (memo.has(board)) return memo.get(board);\n\n        let result = Infinity;\n        let i = 0;\n        while (i < board.length) {\n            let j = i;\n            while (j < board.length && board[i] === board[j]) j++;\n\n            let color = board[i];\n            let required = 3 - (j - i);\n            if (hand[color] >= required) {\n                hand[color] -= required;\n                let nextBoard = board.slice(0, i) + board.slice(j);\n                let tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp !== -1) result = Math.min(result, tmp + required);\n                hand[color] += required;\n            }\n            i = j;\n        }\n\n        let res = (result === Infinity) ? -1 : result;\n        memo.set(board, res);\n        return res;\n    }\n\n    let handMap = {};\n    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;\n\n    return findMinStepHelper(board, new Map(), handMap);\n}\n```\n\n    \n    The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned.\n    "
    },
    {
        "id": 74,
        "title": "Reverse Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of **reverse pairs** in the array_.\n\nA **reverse pair** is a pair `(i, j)` where:\n\n*   `0 <= i < j < nums.length` and\n*   `nums[i] > 2 * nums[j]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,3,1\\]\n**Output:** 2\n**Explanation:** The reverse pairs are:\n(1, 4) --> nums\\[1\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n(3, 4) --> nums\\[3\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,4,3,5,1\\]\n**Output:** 3\n**Explanation:** The reverse pairs are:\n(1, 4) --> nums\\[1\\] = 4, nums\\[4\\] = 1, 4 > 2 \\* 1\n(2, 4) --> nums\\[2\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n(3, 4) --> nums\\[3\\] = 5, nums\\[4\\] = 1, 5 > 2 \\* 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[1,3,2,3,1]",
                "output": "2"
            },
            {
                "input": "[2,4,3,5,1]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int reversePairs(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n}\n\nprivate int mergeSort(int[] nums, int left, int right, int[] temp) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    count += merge(nums, left, mid, right, temp);\n    \n    return count;\n}\n\nprivate int merge(int[] nums, int left, int mid, int right, int[] temp) {\n    int count = 0;\n    System.arraycopy(nums, left, temp, left, right - left + 1);\n    int j = mid + 1;\n    for (int i = left; i <= mid; i++) {\n        while (j <= right && (long) nums[i] > 2L * nums[j]) {\n            j++;\n        }\n        count += j - (mid + 1);\n    }\n    int i = left;\n    j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            nums[k++] = temp[i++];\n        } else {\n            nums[k++] = temp[j++];\n        }\n    }\n    while (i <= mid) {\n        nums[k++] = temp[i++];\n    }\n    while (j <= right) {\n        nums[k++] = temp[j++];\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "python": "\n    ```python\ndef reversePairs(nums):\n    def mergeSort(l, r):\n        if l >= r:\n            return 0\n        \n        mid = (l + r) // 2\n        count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n        j = mid + 1\n        for i in range(l, mid + 1):\n            while j <= r and nums[i] > 2 * nums[j]:\n                j += 1\n            count += j - (mid + 1)\n        \n        nums[l:r + 1] = sorted(nums[l:r + 1])\n        \n        return count\n    \n    return mergeSort(0, len(nums) - 1)\n```\n\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {\n    int count = 0;\n    int j = mid;\n    for (int i = left; i < mid; i++) {\n        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {\n            j++;\n        }\n        count += j - mid;\n    }\n    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);\n    \n    return count;\n}\n\nint countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);\n    count += merge(nums, temp, left, mid + 1, right);\n    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);\n    \n    return count;\n}\n\nint reversePairs(std::vector<int>& nums) {\n    std::vector<int> temp(nums.size());\n    return countReversePairs(nums, temp, 0, nums.size() - 1);\n}\n```\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "js": "\n    ```javascript\nfunction reversePairs(nums) {\n    function mergeSort(l, r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);\n        let j = mid + 1;\n        for (let i = l; i <= mid; i++) {\n            while (j <= r && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);\n        nums.splice(l, merged.length, ...merged);\n\n        return count;\n    }\n\n    return mergeSort(0, nums.length - 1);\n}\n```\n\n\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    "
    },
    {
        "id": 75,
        "title": "IPO",
        "difficulty": "Hard",
        "content": {
            "problem": "Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n",
                "**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "2,0,[1,2,3],[0,1,1]",
                "output": "4"
            },
            {
                "input": "3,0,[1,2,3],[0,1,2]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        int[][] project_pool = new int[profits.length][2];\n        \n        for (int i = 0; i < profits.length; i++) {\n            project_pool[i] = new int[] {capital[i], profits[i]};\n        }\n        \n        Arrays.sort(project_pool, (a, b) -> a[0] - b[0]);\n        \n        PriorityQueue<Integer> profit_pool = new PriorityQueue<>((a, b) -> b - a);\n        int index = 0;\n        \n        for (int i = 0; i < k; i++) {\n            while (index < project_pool.length &&\n                   project_pool[index][0] <= w) {\n                profit_pool.add(project_pool[index++][1]);\n            }\n            \n            if (!profit_pool.isEmpty()) {\n                w += profit_pool.poll();\n            } else {\n                break;\n            }\n        }\n        \n        return w;\n    }\n}\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n    vector<pair<int, int>> project_pool;\n    \n    for (size_t i = 0; i < profits.size(); i++) {\n        project_pool.emplace_back(capital[i], profits[i]);\n    }\n    \n    sort(project_pool.begin(), project_pool.end());\n    \n    priority_queue<int> profit_pool;\n    int index = 0;\n    \n    for (int i = 0; i < k; i++) {\n        while (index < project_pool.size() &&\n               project_pool[index].first <= w) {\n            profit_pool.push(project_pool[index++].second);\n        }\n        \n        if (!profit_pool.empty()) {\n            w += profit_pool.top();\n            profit_pool.pop();\n        } else {\n            break;\n        }\n    }\n    \n    return w;\n}\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    ",
        "js": "\n    ```javascript\nfunction findMaximizedCapital(k, w, profits, capital) {\n    const project_pool = profits.map((p, i) => [capital[i], p]).sort((a, b) => a[0] - b[0]);\n    const profit_pool = new MaxPriorityQueue();\n    let index = 0;\n\n    for (let i = 0; i < k; i++) {\n        while (index < project_pool.length && project_pool[index][0] <= w) {\n            profit_pool.insert(project_pool[index++][1]);\n        }\n\n        if (!profit_pool.isEmpty()) {\n            w += profit_pool.removeMax();\n        } else {\n            break;\n        }\n    }\n\n    return w;\n}\n\nclass MaxPriorityQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    insert(value) {\n        this.queue.push(value);\n        this.siftUp(this.queue.length - 1);\n    }\n    \n    removeMax() {\n        const maxValue = this.queue[0];\n        const lastValue = this.queue.pop();\n        \n        if (this.queue.length) {\n            this.queue[0] = lastValue;\n            this.siftDown(0);\n        }\n        \n        return maxValue;\n    }\n    \n    siftUp(index) {\n        while (index) {\n            const parentIndex = (index - 1) >> 1;\n            if (this.queue[parentIndex] >= this.queue[index]) break;\n            [this.queue[parentIndex], this.queue[index]] = [this.queue[index], this.queue[parentIndex]];\n            index = parentIndex;\n        }\n    }\n    \n    siftDown(index) {\n        while (true) {\n            const leftIndex = (index << 1) + 1;\n            const rightIndex = leftIndex + 1;\n            let maxIndex = index;\n            if (leftIndex < this.queue.length && this.queue[leftIndex] > this.queue[maxIndex]) maxIndex = leftIndex;\n            if (rightIndex < this.queue.length && this.queue[rightIndex] > this.queue[maxIndex]) maxIndex = rightIndex;\n            if (maxIndex === index) break;\n            [this.queue[index], this.queue[maxIndex]] = [this.queue[maxIndex], this.queue[index]];\n            index = maxIndex;\n        }\n    }\n    \n    isEmpty() {\n        return this.queue.length === 0;\n    }\n}\n```\n    \n    1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects.\n    "
    },
    {
        "id": 76,
        "title": "Freedom Trail",
        "difficulty": "Hard",
        "content": {
            "problem": "In the video game Fallout 4, the quest **\"Road to Freedom \"** requires players to reach a metal dial called the **\"Freedom Trail Ring \"** and use the dial to spell a specific keyword to open the door.\n\nGiven a string `ring` that represents the code engraved on the outer ring and another string `key` that represents the keyword that needs to be spelled, return _the minimum number of steps to spell all the characters in the keyword_.\n\nInitially, the first character of the ring is aligned at the `\"12:00 \"` direction. You should spell all the characters in `key` one by one by rotating `ring` clockwise or anticlockwise to make each character of the string key aligned at the `\"12:00 \"` direction and then by pressing the center button.\n\nAt the stage of rotating the ring to spell the key character `key[i]`:\n\n1.  You can rotate the ring clockwise or anticlockwise by one place, which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `\"12:00 \"` direction, where this character must equal `key[i]`.\n2.  If the character `key[i]` has been aligned at the `\"12:00 \"` direction, press the center button to spell, which also counts as **one step**. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.",
            "examples": [
                "**Example 1:**\n\n**Input:** ring =  \"godding \", key =  \"gd \"\n**Output:** 4\n**Explanation:**\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring  \"godding \" anticlockwise by two steps to make it become  \"ddinggo \".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\n",
                "**Example 2:**\n\n**Input:** ring =  \"godding \", key =  \"godding \"\n**Output:** 13"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= ring.length, key.length <= 100`\n*   `ring` and `key` consist of only lower case English letters.\n*   It is guaranteed that `key` could always be spelled by rotating `ring`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"godding\",\"gd\"",
                "output": "4"
            },
            {
                "input": "\"godding\",\"godding\"",
                "output": "13"
            }
        ],
        "java": "\n    ```java\npublic int findRotateSteps(String ring, String key) {\n    int n = ring.length(), m = key.length();\n    int[][] dp = new int[m + 1][n];\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = 0; k < n; ++k) {\n                if (ring.charAt(k) == key.charAt(i)) {\n                    int diff = Math.abs(j - k);\n                    int step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "python": "\n    ```python\ndef find_rotate_steps(ring: str, key: str) -> int:\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    return dp[0][0] + m\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint findRotateSteps(std::string ring, std::string key) {\n    int n = ring.size(), m = key.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n, 0));\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = INT_MAX;\n            for (int k = 0; k < n; ++k) {\n                if (ring[k] == key[i]) {\n                    int diff = abs(j - k);\n                    int step = std::min(diff, n - diff);\n                    dp[i][j] = std::min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "js": "\n    ```javascript\nfunction findRotateSteps(ring, key) {\n    const n = ring.length, m = key.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; --i) {\n        for (let j = 0; j < n; ++j) {\n            dp[i][j] = Infinity;\n            for (let k = 0; k < n; ++k) {\n                if (ring[k] === key[i]) {\n                    const diff = Math.abs(j - k);\n                    const step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    "
    },
    {
        "id": 77,
        "title": "Super Washing Machines",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** machines = \\[1,0,5\\]\n**Output:** 3\n**Explanation:**\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\n",
                "**Example 2:**\n\n**Input:** machines = \\[0,3,0\\]\n**Output:** 2\n**Explanation:**\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\n",
                "**Example 3:**\n\n**Input:** machines = \\[0,2,0\\]\n**Output:** -1\n**Explanation:**\nIt's impossible to make all three washing machines have the same number of dresses."
            ],
            "constraints": "**Constraints:**\n\n*   `n == machines.length`\n*   `1 <= n <= 104`\n*   `0 <= machines[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,0,5]",
                "output": "3"
            },
            {
                "input": "[0,3,0]",
                "output": "2"
            },
            {
                "input": "[0,2,0]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findMinMoves(int[] machines) {\n    int n = machines.length;\n    int totalDresses = 0;\n    for (int m : machines) totalDresses += m;\n    if (totalDresses % n != 0) return -1;\n    int average = totalDresses / n;\n    int moves = 0, imbalance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "python": "\n    ```python\ndef find_min_moves(machines):\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\nint findMinMoves(std::vector<int>& machines) {\n    int n = machines.size();\n    int totalDresses = std::accumulate(machines.begin(), machines.end(), 0);\n    if (totalDresses % n != 0) return -1;\n    int average = totalDresses / n;\n    int moves = 0, imbalance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = std::max(moves, std::max(abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "js": "\n    ```javascript\nfunction findMinMoves(machines) {\n    let n = machines.length;\n    let totalDresses = machines.reduce((a, b) => a + b, 0);\n    if (totalDresses % n !== 0) return -1;\n    let average = totalDresses / n;\n    let moves = 0, imbalance = 0;\n    \n    for (let i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    "
    },
    {
        "id": 78,
        "title": "Remove Boxes",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given several `boxes` with different colors represented by different positive numbers.\n\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.\n\nReturn _the maximum points you can get_.",
            "examples": [
                "**Example 1:**\n\n**Input:** boxes = \\[1,3,2,2,2,3,4,3,1\\]\n**Output:** 23\n**Explanation:**\n\\[1, 3, 2, 2, 2, 3, 4, 3, 1\\] \n----> \\[1, 3, 3, 4, 3, 1\\] (3\\*3=9 points) \n----> \\[1, 3, 3, 3, 1\\] (1\\*1=1 points) \n----> \\[1, 1\\] (3\\*3=9 points) \n----> \\[\\] (2\\*2=4 points)\n\n",
                "**Example 2:**\n\n**Input:** boxes = \\[1,1,1\\]\n**Output:** 9\n\n",
                "**Example 3:**\n\n**Input:** boxes = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= boxes.length <= 100`\n*   `1 <= boxes[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "[1,3,2,2,2,3,4,3,1]",
                "output": "23"
            },
            {
                "input": "[1,1,1]",
                "output": "9"
            },
            {
                "input": "[1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int removeBoxes(int[] boxes) {\n    int[][][] dp = new int[100][100][100];\n    return dfs(boxes, dp, 0, boxes.length - 1, 0);\n}\n\nprivate int dfs(int[] boxes, int[][][] dp, int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "python": "\n    ```python\ndef removeBoxes(boxes):\n    def dfs(l, r, k):\n        if l > r: return 0\n        if dp[l][r][k] != 0: return dp[l][r][k]\n\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n            \n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)\n\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))\n                \n        return dp[l][r][k]\n\n    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]\n    return dfs(0, len(boxes) - 1, 0)\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "c++": "\n    ```cpp\nint removeBoxes(vector<int>& boxes) {\n    int dp[100][100][100] = {0};\n    return dfs(boxes, dp, 0, boxes.size() - 1, 0);\n}\n\nint dfs(vector<int>& boxes, int dp[100][100][100], int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "js": "\n    ```javascript\nfunction removeBoxes(boxes) {\n    const dfs = (l, r, k) => {\n        if (l > r) return 0;\n        if (dp[l][r][k] !== 0) return dp[l][r][k];\n\n        while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0);\n\n        for (let i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));\n            }\n        }\n\n        return dp[l][r][k];\n    };\n\n    let dp = Array.from({ length: 100 }, () => Array.from({ length: 100 }, () => Array(100).fill(0)));\n    return dfs(0, boxes.length - 1, 0);\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    "
    },
    {
        "id": 79,
        "title": "Student Attendance Record II",
        "difficulty": "Hard",
        "content": {
            "problem": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n`, return _the **number** of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it **modulo**_ `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 8\n**Explanation:** There are 8 records with length 2 that are eligible for an award:\n \"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2).\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** n = 10101\n**Output:** 183236316"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "2",
                "output": "8"
            },
            {
                "input": "1",
                "output": "3"
            },
            {
                "input": "10101",
                "output": "183236316"
            }
        ],
        "java": "\n    ```java\npublic int checkRecord(int n) {\n    int M = 1000000007;\n    long[] dp = new long[6];  // {latent state 0, latent state 1, ..., latent state 5}\n    Arrays.fill(dp, 1);\n    while (n-- > 0) {\n        long[] next_dp = new long[6];\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (int) ((dp[0] + dp[1] + dp[2] +\n                   dp[3] + dp[4] + dp[5]) % M);\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "python": "\n    ```python\ndef checkRecord(n: int) -> int:\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "c++": "\n    ```cpp\nint checkRecord(int n) {\n    int M = 1000000007;\n    vector<long long> dp(6, 1);  // {latent state 0, latent state 1, ..., latent state 5}\n    while (n--) {\n        vector<long long> next_dp(6, 0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % M;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "js": "\n    ```javascript\nfunction checkRecord(n) {\n    let M = 1000000007;\n    let dp = Array(6).fill(1);  // [latent state 0, latent state 1, ..., latent state 5]\n    while (n--) {\n        let next_dp = Array(6).fill(0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return dp.reduce((sum, val) => (sum + val) % M, 0);\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    "
    },
    {
        "id": 80,
        "title": "Find the Closest Palindrome",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `n` representing an integer, return _the closest integer (not including itself), which is a palindrome_. If there is a tie, return _**the smaller one**_.\n\nThe closest is defined as the absolute difference minimized between two integers.",
            "examples": [
                "**Example 1:**\n\n**Input:** n =  \"123 \"\n**Output:**  \"121 \"\n\n",
                "**Example 2:**\n\n**Input:** n =  \"1 \"\n**Output:**  \"0 \"\n**Explanation:** 0 and 2 are the closest palindromes but we return the smallest which is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n.length <= 18`\n*   `n` consists of only digits.\n*   `n` does not have leading zeros.\n*   `n` is representing an integer in the range `[1, 1018 - 1]`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"123\"",
                "output": "\"121\""
            },
            {
                "input": "\"1\"",
                "output": "\"0\""
            }
        ],
        "java": "\n    ```java\npublic class ClosestPalindrome {\n    public static boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static int closestPalindrome(String n) {\n        int num = Integer.parseInt(n);\n        int left = num - 1;\n        int right = num + 1;\n\n        while (true) {\n            if (isPalindrome(Integer.toString(left))) {\n                return left;\n            }\n            if (isPalindrome(Integer.toString(right))) {\n                return right;\n            }\n            left--;\n            right++;\n        }\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "python": "\n    ```python\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef closest_palindrome(n: str) -> int:\n    num = int(n)\n    left = num - 1\n    right = num + 1\n\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <cmath>\n#include <limits>\n\nbool isPalindrome(std::string str) {\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint closestPalindrome(std::string n) {\n    int num = std::stoi(n);\n    int left = num - 1;\n    int right = num + 1;\n\n    while (true) {\n        if (isPalindrome(std::to_string(left))) {\n            return left;\n        } \n        if (isPalindrome(std::to_string(right))) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(str) {\n    let left = 0;\n    let right = str.length - 1;\n\n    while (left < right) {\n        if (str[left] !== str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nfunction closestPalindrome(n) {\n    const num = parseInt(n);\n    let left = num - 1;\n    let right = num + 1;\n\n    while (true) {\n        if (isPalindrome(left.toString())) {\n            return left;\n        }\n        if (isPalindrome(right.toString())) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    "
    },
    {
        "id": 81,
        "title": "Erect the Fence",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `trees` where `trees[i] = [xi, yi]` represents the location of a tree in the garden.\n\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if **all the trees are enclosed**.\n\nReturn _the coordinates of trees that are exactly located on the fence perimeter_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** trees = \\[\\[1,1\\],\\[2,2\\],\\[2,0\\],\\[2,4\\],\\[3,3\\],\\[4,2\\]\\]\n**Output:** \\[\\[1,1\\],\\[2,0\\],\\[4,2\\],\\[3,3\\],\\[2,4\\]\\]\n**Explanation:** All the trees will be on the perimeter of the fence except the tree at \\[2, 2\\], which will be inside the fence.\n\n",
                "**Example 2:**\n\n**Input:** trees = \\[\\[1,2\\],\\[2,2\\],\\[4,2\\]\\]\n**Output:** \\[\\[4,2\\],\\[2,2\\],\\[1,2\\]\\]\n**Explanation:** The fence forms a line that passes through all the trees."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= trees.length <= 3000`\n*   `trees[i].length == 2`\n*   `0 <= xi, yi <= 100`\n*   All the given positions are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]",
                "output": "[[1,1],[2,0],[4,2],[3,3],[2,4]]"
            },
            {
                "input": "[[1,2],[2,2],[4,2]]",
                "output": "[[4,2],[2,2],[1,2]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    private static int[][] fence(int[][] trees) {\n        Arrays.sort(trees, (p, q) -> p[0] == q[0] ? p[1] - q[1] : p[0] - q[0]);\n        List<int[]> hull = new ArrayList<>();\n        for (int[] p : trees) {\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        for (int i = trees.length - 1; i >= 0; i--) {\n            int[] p = trees[i];\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        return hull.toArray(new int[hull.size()][]);\n    }\n\n    private static int crossProduct(int[] p, int[] q, int[] r) {\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    }\n}\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "python": "\n    ```python\ndef cross_product(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef fence(trees):\n    trees.sort(key=lambda p: (p[0], p[1]))\n    hull = []\n    for p in trees:\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n\n    for p in reversed(trees):\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    \n    return hull\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool compare(const vector<int>& p, const vector<int>& q) {\n    return p[0] < q[0] || (p[0] == q[0] && p[1] < q[1]);\n}\n\nint cross_product(const vector<int>& p, const vector<int>& q, const vector<int>& r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nvector<vector<int>> fence(vector<vector<int>>& trees) {\n    sort(trees.begin(), trees.end(), compare);\n    vector<vector<int>> hull;\n    for (const auto& p : trees) {\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    for (int i = trees.size() - 1; i >= 0; --i) {\n        const auto& p = trees[i];\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    return hull;\n}\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "js": "\n    ```javascript\nfunction crossProduct(p, q, r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nfunction fence(trees) {\n    trees.sort((p, q) => p[0] === q[0] ? p[1] - q[1] : p[0] - q[0]);\n    const hull = [];\n    for (const p of trees) {\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    for (let i = trees.length - 1; i >= 0; i--) {\n        const p = trees[i];\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    return hull;\n}\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    "
    },
    {
        "id": 82,
        "title": "Tag Validator",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\n\nA code snippet is valid if all the following rules hold:\n\n1.  The code must be wrapped in a **valid closed tag**. Otherwise, the code is invalid.\n2.  A **closed tag** (not necessarily valid) has exactly the following format : `TAG_CONTENT`. Among them, is the start tag, and is the end tag. The TAG\\_NAME in start and end tags should be the same. A closed tag is **valid** if and only if the TAG\\_NAME and TAG\\_CONTENT are valid.\n3.  A **valid** `TAG_NAME` only contain **upper-case letters**, and has length in range \\[1,9\\]. Otherwise, the `TAG_NAME` is **invalid**.\n4.  A **valid** `TAG_CONTENT` may contain other **valid closed tags**, **cdata** and any characters (see note1) **EXCEPT** unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG\\_NAME. Otherwise, the `TAG_CONTENT` is **invalid**.\n5.  A start tag is unmatched if no end tag exists with the same TAG\\_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n6.  A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or ``, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).``\n``` *   The cdata has the following format : . The range of `CDATA_CONTENT` is defined as the characters between ``and the **first subsequent** `]]>`.`` ``*   `CDATA_CONTENT` may contain **any characters**. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as **regular characters**.`` ```\n\n``` ``",
            "examples": [
                "**Example 1:**  **Input:** code =  \"  This is the first line ]]>   \" **Output:** true **Explanation:**  The code is wrapped in a closed tag :    and   .  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  ",
                "**Example 2:**  **Input:** code =  \"  >>  ![cdata[]] ]>]]>]]>>]   \" **Output:** true **Explanation:** We first separate the code into : start_tag|tag_content|end_tag. start_tag -> ** \"**   **\"** end_tag -> ** \"**   **\"** tag_content could also be separated into : text1|cdata|text2. text1 -> ** \">>  ![cdata[]]  \"** cdata -> ** \"]>]]> \"**, where the CDATA_CONTENT is ** \"**  **]> \"** text2 -> ** \"]]>>] \"** The reason why start_tag is NOT ** \"**  **>> \"** is because of the rule 6. The reason why cdata is NOT ** \"]>]]>]]> \"** is because of the rule 7.  ",
                "**Example 3:**  **Input:** code =  \"    \" **Output:** false **Explanation:** Unbalanced. If  \" \" is closed, then  \" **\" must be unmatched, and vice versa.**  **"
            ],
            "constraints": "**Constraints:**  *   `1 <= code.length <= 500` *   `code` consists of English letters, digits, `'<'`, `'>'`, `'/'`, `'!'`, `'['`, `']'`, `'.'`, and `' '`.  **`` ```",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack"
        ],
        "example": [
            {
                "input": "\"Thisisthefirstline]>\"",
                "output": "true"
            },
            {
                "input": "\">>![cdata[]]]]>]]>>]\"",
                "output": "true"
            },
            {
                "input": "\"\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nprivate static boolean isValid(String code, int[] i) {\n    if (i[0] >= code.length()) return false;\n    if (code.charAt(i[0]) != '<') return false;\n    int nameLength = 0;\n    for (++i[0]; i[0] < code.length() && nameLength < 9 && Character.isUpperCase(code.charAt(i[0])); ++i[0]) ++nameLength;\n    if (nameLength < 1 || nameLength > 9 || code.charAt(i[0]++) != '>') return false;\n\n    while (i[0] < code.length() && code.charAt(i[0]) != '<') ++i[0];\n    if (i[0] >= code.length()) return false;\n\n    if (!code.substring(i[0], i[0] + nameLength + 3).equals(\"</\" + code.substring(i[0] - nameLength - 1, i[0] - 1) + \">\"))\n        return false;\n    i[0] += nameLength + 3;\n    return true;\n}\n\npublic static boolean validateCodeSnippet(String code) {\n    int[] i = {0};\n    return isValid(code, i) && i[0] == code.length();\n}\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "python": "\n    ```python\ndef is_valid(code, i):\n    if i >= len(code) or code[i] != '<':\n        return False, i\n    i += 1\n    name_start = i\n    while i < len(code) and code[i].isupper():\n        i += 1\n    name_len = i - name_start\n    if name_len < 1 or name_len > 9 or code[i] != '>':\n        return False, i\n    i += 1\n\n    while i < len(code) and code[i] != '<':\n        i += 1\n    if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != '</' + code[name_start:i] + '>':\n        return False, i\n    return True, i + 2 + name_len\n\ndef validate_code_snippet(code):\n    is_valid_code, i = is_valid(code, 0)\n    return is_valid_code and i == len(code)\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "c++": "\n    ```cpp\nbool is_valid(const std::string& code, size_t &i) {\n    if (i >= code.size()) return false;\n    if (code[i] != '<') return false;\n    int name_len = 0;\n    for (++i; i < code.size() && name_len < 9 && isupper(code[i]); ++i) ++name_len;\n    if (name_len < 1 || name_len > 9 || code[i++] != '>') return false;\n\n    while (i < code.size() && code[i] != '<') ++i;\n    if (i >= code.size()) return false;\n\n    if (code.substr(i, name_len + 3) != \"</\" + code.substr(i - name_len - 1, name_len) + \">\") \n        return false;\n    i += name_len + 3;\n    return true;\n}\n\nbool validateCodeSnippet(const std::string &code) {\n    size_t i = 0;\n    return is_valid(code, i) && i == code.size();\n}\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "js": "\n    ```javascript\nfunction isValid(code, i) {\n    if (!code || i.value >= code.length) return false;\n    if (code[i.value] != '<') return false;\n    let nameLength = 0;\n    for (++i.value; i.value < code.length && nameLength < 9 && /^[A-Z]$/.test(code[i.value]); ++i.value) ++nameLength;\n    if (nameLength < 1 || nameLength > 9 || code[i.value++] != '>') return false;\n\n    while (i.value < code.length && code[i.value] != '<') ++i.value;\n    if (i.value >= code.length) return false;\n\n    if (code.substring(i.value, i.value + nameLength + 3) != \"</\" + code.substring(i.value - nameLength - 1, i.value-1) + \">\")\n        return false;\n    i.value += nameLength + 3;\n    return true;\n}\n\nfunction validateCodeSnippet(code) {\n    let i = {value: 0};\n    return isValid(code, i) && i.value == code.length;\n}\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    "
    },
    {
        "id": 83,
        "title": "Non-negative Integers without Consecutive Ones",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 5\n**Explanation:**\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "5",
                "output": "5"
            },
            {
                "input": "1",
                "output": "2"
            },
            {
                "input": "2",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int findIntegers(int n) {\n    int[][] dp = new int[32][2];\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if ((n & (1 << i)) != 0) {\n            ans += dp[i][0];\n            if (prev_bit == 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "python": "\n    ```python\ndef findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "c++": "\n    ```cpp\nint findIntegers(int n) {\n    int dp[32][2] = {0};\n    dp[0][0] = dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "js": "\n    ```javascript\nfunction findIntegers(n) {\n    let dp = new Array(32).fill(0).map(() => Array(2).fill(0));\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (let i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    let ans = 0, prev_bit = 0;\n    for (let i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit === 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    "
    },
    {
        "id": 84,
        "title": "K Inverse Pairs Array",
        "difficulty": "Hard",
        "content": {
            "problem": "For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 0\n**Output:** 1\n**Explanation:** Only the array \\[1,2,3\\] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 2\n**Explanation:** The array \\[1,3,2\\] and \\[2,1,3\\] have exactly 1 inverse pair."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= k <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "3,0",
                "output": "1"
            },
            {
                "input": "3,1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int kInversePairs(int n, int k) {\n    int mod = 1000000007;\n    int[][] dp = new int[n + 1][k + 1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "python": "\n    ```python\ndef kInversePairs(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n            if j - i >= 0:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n    return dp[n][k]\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "c++": "\n    ```cpp\nint kInversePairs(int n, int k) {\n    int mod = 1e9 + 7;\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "js": "\n    ```javascript\nfunction kInversePairs(n, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (let j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    "
    },
    {
        "id": 85,
        "title": "Course Schedule III",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.\n\nYou will start on the `1st` day and you cannot take two or more courses simultaneously.\n\nReturn _the maximum number of courses that you can take_.",
            "examples": [
                "**Example 1:**\n\n**Input:** courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\n**Output:** 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n\n",
                "**Example 2:**\n\n**Input:** courses = \\[\\[1,2\\]\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** courses = \\[\\[3,2\\],\\[4,3\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= courses.length <= 104`\n*   `1 <= durationi, lastDayi <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[[100,200],[200,1300],[1000,1250],[2000,3200]]",
                "output": "3\nExplanation:\nTherearetotally4courses,butyoucantake3coursesatmost:\nFirst,takethe1stcourse,itcosts100dayssoyouwillfinishitonthe100thday,andreadytotakethenextcourseonthe101stday.\nSecond,takethe3rdcourse,itcosts1000dayssoyouwillfinishitonthe1100thday,andreadytotakethenextcourseonthe1101stday.\nThird,takethe2ndcourse,itcosts200dayssoyouwillfinishitonthe1300thday.\nThe4thcoursecannotbetakennow,sinceyouwillfinishitonthe3300thday,whichexceedsthecloseddate."
            },
            {
                "input": "[[1,2]]",
                "output": "1"
            },
            {
                "input": "[[3,2],[4,3]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int scheduleCourse(int[][] courses) {\n    Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    int time = 0;\n\n    for (int[] course : courses) {\n        time += course[0];\n        pq.offer(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.poll();\n        }\n    }\n\n    return pq.size();\n}\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nint scheduleCourse(std::vector<std::vector<int>>& courses) {\n    std::sort(courses.begin(), courses.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    std::priority_queue<int> pq;\n    int time = 0;\n\n    for (const auto& course : courses) {\n        time += course[0];\n        pq.push(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.top();\n            pq.pop();\n        }\n    }\n\n    return pq.size();\n}\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    ",
        "js": "\n    ```javascript\nfunction scheduleCourse(courses) {\n    courses.sort((a, b) => a[1] - b[1]);\n\n    const pq = new PriorityQueue((a, b) => b - a);\n    let time = 0;\n\n    for (const course of courses) {\n        time += course[0];\n        pq.push(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.pop();\n        }\n    }\n\n    return pq.size();\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.data = [];\n        this.comparator = comparator;\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.data.sort(this.comparator);\n    }\n\n    pop() {\n        return this.data.shift();\n    }\n\n    size() {\n        return this.data.length;\n    }\n}\n```\n    \n    1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course.\n    "
    },
    {
        "id": 86,
        "title": "Smallest Range Covering Elements from K Lists",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `k` lists of sorted integers in **non-decreasing order**. Find the **smallest** range that includes at least one number from each of the `k` lists.\n\nWe define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` **or** `a < c` if `b - a == d - c`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[\\[4,10,15,24,26\\],\\[0,9,12,20\\],\\[5,18,22,30\\]\\]\n**Output:** \\[20,24\\]\n**Explanation:** \nList 1: \\[4, 10, 15, 24,26\\], 24 is in range \\[20,24\\].\nList 2: \\[0, 9, 12, 20\\], 20 is in range \\[20,24\\].\nList 3: \\[5, 18, 22, 30\\], 22 is in range \\[20,24\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[\\[1,2,3\\],\\[1,2,3\\],\\[1,2,3\\]\\]\n**Output:** \\[1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `nums.length == k`\n*   `1 <= k <= 3500`\n*   `1 <= nums[i].length <= 50`\n*   `-105 <= nums[i][j] <= 105`\n*   `nums[i]` is sorted in **non-decreasing** order.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sliding Window",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
                "output": "[20,24]"
            },
            {
                "input": "[[1,2,3],[1,2,3],[1,2,3]]",
                "output": "[1,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n\n    int maxVal = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.offer(new int[] {nums.get(i).get(0), i});\n        maxVal = Math.max(maxVal, nums.get(i).get(0));\n    }\n\n    List<Integer> listIndices = new ArrayList<>();\n    for (int i = 0; i < nums.size(); i++) {\n        listIndices.add(0);\n    }\n    int minRange = Integer.MAX_VALUE;\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        int[] entry = minHeap.poll();\n        int val = entry[0];\n        int listIdx = entry[1];\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices.set(listIdx, listIndices.get(listIdx) + 1);\n        if (listIndices.get(listIdx) < nums.get(listIdx).size()) {\n            int newVal = nums.get(listIdx).get(listIndices.get(listIdx));\n            minHeap.offer(new int[] {newVal, listIdx});\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return new int[] {start, end};\n}\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    ",
        "python": "\n    ```python\nimport heapq\n\ndef smallestRange(nums):\n    minHeap = []\n    maxVal = -1e9\n    \n    for i, lst in enumerate(nums):\n        heapq.heappush(minHeap, (lst[0], i))\n        maxVal = max(maxVal, lst[0])\n        \n    listIndices = [0] * len(nums)\n    minRange = 1e9\n    start, end = -1, -1\n    \n    while len(minHeap) == len(nums):\n        val, listIdx = heapq.heappop(minHeap)\n        range_ = maxVal - val\n        \n        if range_ < minRange:\n            minRange = range_\n            start, end = val, maxVal\n            \n        listIndices[listIdx] += 1\n        if listIndices[listIdx] < len(nums[listIdx]):\n            newVal = nums[listIdx][listIndices[listIdx]]\n            heapq.heappush(minHeap, (newVal, listIdx))\n            maxVal = max(maxVal, newVal)\n            \n    return [start, end]\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <limits>\n#include <utility>\n\nstd::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) {\n    auto listComparator = [](const auto& a, const auto& b) {\n        return a.first > b.first;\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(listComparator)> minHeap(listComparator);\n\n    int maxVal = std::numeric_limits<int>::min();\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.push({nums[i][0], i});\n        maxVal = std::max(maxVal, nums[i][0]);\n    }\n\n    std::vector<int> listIndices(nums.size(), 0);\n    int minRange = std::numeric_limits<int>::max();\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        auto entry = minHeap.top();\n        minHeap.pop();\n        int val = entry.first;\n        int listIdx = entry.second;\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].size()) {\n            int newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push({newVal, listIdx});\n            maxVal = std::max(maxVal, newVal);\n        }\n    }\n\n    return {start, end};\n}\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    ",
        "js": "\n    ```javascript\nfunction smallestRange(nums) {\n    const minHeap = [],\n          listIndices = Array(nums.length).fill(0);\n          \n    let maxVal = -Infinity;\n    \n    for (let i = 0; i < nums.length; i++) {\n        minHeap.push([nums[i][0], i]);\n        maxVal = Math.max(maxVal, nums[i][0]);\n    }\n    minHeap.sort(([a], [b]) => a - b);\n\n    let minRange = Infinity,\n        start = -1,\n        end = -1;\n    \n    while (minHeap.length === nums.length) {\n        const [val, listIdx] = minHeap.shift();\n        const range = maxVal - val;\n        \n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].length) {\n            const newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push([newVal, listIdx]);\n            minHeap.sort(([a], [b]) => a - b);\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return [start, end];\n}\n```\n    \n    1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n \n    "
    },
    {
        "id": 87,
        "title": "Decode Ways II",
        "difficulty": "Hard",
        "content": {
            "problem": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\n**In addition** to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1* \"` may represent any of the encoded messages `\"11 \"`, `\"12 \"`, `\"13 \"`, `\"14 \"`, `\"15 \"`, `\"16 \"`, `\"17 \"`, `\"18 \"`, or `\"19 \"`. Decoding `\"1* \"` is equivalent to decoding **any** of the encoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters, return _the **number** of ways to **decode** it_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"\\* \"\n**Output:** 9\n**Explanation:** The encoded message can represent any of the encoded messages  \"1 \",  \"2 \",  \"3 \",  \"4 \",  \"5 \",  \"6 \",  \"7 \",  \"8 \", or  \"9 \".\nEach of these can be decoded to the strings  \"A \",  \"B \",  \"C \",  \"D \",  \"E \",  \"F \",  \"G \",  \"H \", and  \"I \" respectively.\nHence, there are a total of 9 ways to decode  \"\\* \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"1\\* \"\n**Output:** 18\n**Explanation:** The encoded message can represent any of the encoded messages  \"11 \",  \"12 \",  \"13 \",  \"14 \",  \"15 \",  \"16 \",  \"17 \",  \"18 \", or  \"19 \".\nEach of these encoded messages have 2 ways to be decoded (e.g.  \"11 \" can be decoded to  \"AA \" or  \"K \").\nHence, there are a total of 9 \\* 2 = 18 ways to decode  \"1\\* \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"2\\* \"\n**Output:** 15\n**Explanation:** The encoded message can represent any of the encoded messages  \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \",  \"26 \",  \"27 \",  \"28 \", or  \"29 \".\n \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \", and  \"26 \" have 2 ways of being decoded, but  \"27 \",  \"28 \", and  \"29 \" only have 1 way.\nHence, there are a total of (6 \\* 2) + (3 \\* 1) = 12 + 3 = 15 ways to decode  \"2\\* \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a digit or `'*'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"*\"",
                "output": "9"
            },
            {
                "input": "\"1*\"",
                "output": "18"
            },
            {
                "input": "\"2*\"",
                "output": "15"
            }
        ],
        "java": "\n    ```java\npublic int numDecodings(String s) {\n    final int MOD = 1_000_000_007;\n    int n = s.length();\n    long[] dp = new long[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) == '*' ? 9 : (s.charAt(0) == '0' ? 0 : 1);\n\n    for (int i = 2; i <= n; ++i) {\n        char c = s.charAt(i - 1);\n        char prevC = s.charAt(i - 2);\n\n        if (c == '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (prevC == '1') dp[i] += 9 * dp[i - 2];\n            else if (prevC == '2') dp[i] += 6 * dp[i - 2];\n            else if (prevC == '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (c != '0') ? dp[i - 1] : 0;\n            int num = Integer.parseInt(s.substring(i - 2, i));\n            if (prevC == '1' || (prevC == '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (prevC == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return (int) dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "python": "\n    ```python\ndef num_decodings(s: str) -> int:\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)\n\n    for i in range(2, n + 1):\n        c, prev_c = s[i - 1], s[i - 2]\n        \n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n            if prev_c == '1': dp[i] += 9 * dp[i - 2]\n            elif prev_c == '2': dp[i] += 6 * dp[i - 2]\n            elif prev_c == '*': dp[i] += 15 * dp[i - 2]\n        else:\n            dp[i] = dp[i - 1] if c != '0' else 0\n            num = int(s[i - 2 : i])\n            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]\n            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]\n\n        dp[i] %= MOD\n    return dp[n]\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "c++": "\n    ```cpp\nint numDecodings(const std::string& s) {\n    const int MOD = 1e9 + 7;\n    int n = s.size();\n    std::vector<long long> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] == '*' ? 9 : (s[0] == '0' ? 0 : 1);\n\n    for (int i = 2; i <= n; ++i) {\n        if (s[i - 1] == '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (s[i - 2] == '1') dp[i] += 9 * dp[i - 2];\n            else if (s[i - 2] == '2') dp[i] += 6 * dp[i - 2];\n            else if (s[i - 2] == '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (s[i - 1] != '0') ? dp[i - 1] : 0;\n            int num = std::stoi(s.substr(i - 2, 2));\n            if (s[i - 2] == '1' || (s[i - 2] == '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (s[i - 2] == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "js": "\n    ```javascript\nfunction numDecodings(s) {\n    const MOD = 1_000_000_007;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] === '*' ? 9 : (s[0] === '0' ? 0 : 1);\n\n    for (let i = 2; i <= n; ++i) {\n        let c = s[i - 1];\n        let prevC = s[i - 2];\n\n        if (c === '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (prevC === '1') dp[i] += 9 * dp[i - 2];\n            else if (prevC === '2') dp[i] += 6 * dp[i - 2];\n            else if (prevC === '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (c !== '0') ? dp[i - 1] : 0;\n            let num = parseInt(s.slice(i - 2, i));\n            if (prevC === '1' || (prevC === '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (prevC === '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    "
    },
    {
        "id": 88,
        "title": "Strange Printer",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a strange printer with the following two special properties:\n\n*   The printer can only print a sequence of **the same character** each time.\n*   At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return _the minimum number of turns the printer needed to print it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaabbb \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"bbb \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"b \" from the second place of the string, which will cover the existing character 'a'."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"aaabbb\"",
                "output": "2"
            },
            {
                "input": "\"aba\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nint strangePrinter(String s) {\n    int n = s.length();\n    if(n == 0) return 0;\n    int[][] dp = new int[n][n];\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s.charAt(i) == s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "python": "\n    ```python\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "c++": "\n    ```cpp\nint strangePrinter(string s) {\n    int n = s.size();\n    if(n == 0) return 0;\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s[i] == s[k]) {\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "js": "\n    ```javascript\nfunction strangePrinter(s) {\n    let n = s.length;\n    if(n === 0) return 0;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for(let i = 0; i < n; i++) dp[i][i] = 1;\n    for(let len = 1; len < n; len++) {\n        for(let i = 0; i < n - len; i++) {\n            let j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(let k = i + 1; k <= j; k++) {\n                if(s.charAt(i) === s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    "
    },
    {
        "id": 89,
        "title": "Kth Smallest Number in Multiplication Table",
        "difficulty": "Hard",
        "content": {
            "problem": "Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).\n\nGiven three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, k = 5\n**Output:** 3\n**Explanation:** The 5th smallest number is 3.\n\n",
                "**Example 2:**\n\n**Input:** m = 2, n = 3, k = 6\n**Output:** 6\n**Explanation:** The 6th smallest number is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= k <= m * n`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "3,3,5",
                "output": "3"
            },
            {
                "input": "2,3,6",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "python": "\n    ```python\ndef findKthNumber(m, n, k):\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "c++": "\n    ```cpp\nint findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += std::min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "js": "\n    ```javascript\nfunction findKthNumber(m, n, k) {\n    let low = 1, high = m * n;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        let count = 0;\n        for (let i = 1; i <= m; i++) {\n            count += Math.min(Math.floor(mid / i), n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    "
    },
    {
        "id": 90,
        "title": "Cut Off Trees for Golf Event",
        "difficulty": "Hard",
        "content": {
            "problem": "You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n\n*   `0` means the cell cannot be walked through.\n*   `1` represents an empty cell that can be walked through.\n*   A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return _the minimum steps you need to walk to cut off all the trees_. If you cannot cut off all the trees, return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.",
            "examples": [
                "**Example 1:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,4\\],\\[7,6,5\\]\\]\n**Output:** 6\n**Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n",
                "**Example 2:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,0\\],\\[7,6,5\\]\\]\n**Output:** -1\n**Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n",
                "**Example 3:**\n\n**Input:** forest = \\[\\[2,3,4\\],\\[0,0,5\\],\\[8,7,6\\]\\]\n**Output:** 6\n**Explanation:** You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps."
            ],
            "constraints": "**Constraints:**\n\n*   `m == forest.length`\n*   `n == forest[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= forest[i][j] <= 109`\n*   Heights of all trees are **distinct**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[0,0,4],[7,6,5]]",
                "output": "6"
            },
            {
                "input": "[[1,2,3],[0,0,0],[7,6,5]]",
                "output": "-1"
            },
            {
                "input": "[[2,3,4],[0,0,5],[8,7,6]]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int cutOffTree(List<List<Integer>> forest) {\n    if(forest.isEmpty() || forest.get(0).isEmpty()) return 0;\n    int m = forest.size(), n = forest.get(0).size();\n    List<int[]> trees = new ArrayList<>();\n    \n    for(int i = 0; i < m; i++)\n        for(int j = 0; j < n; j++)\n            if(forest.get(i).get(j) > 1)\n                trees.add(new int[]{i, j});\n    \n    trees.sort((a, b) -> forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]));\n\n    int startX = 0, startY = 0;\n    int totalSteps = 0;\n    for(int[] tree : trees){\n        int x = tree[0], y = tree[1];\n        int steps = bfs(forest, startX, startY, x, y);\n        if(steps == -1) return -1;\n        totalSteps += steps;\n        startX = x;\n        startY = y;\n    }\n    \n    return totalSteps;\n}\n\nprivate int bfs(List<List<Integer>> forest, int startX, int startY, int endX, int endY) {\n    int m = forest.size(), n = forest.get(0).size();\n    int[][] visited = new int[m][n];\n    Queue<int[]> q = new LinkedList<>();\n    q.offer(new int[]{startX, startY});\n    visited[startX][startY] = 1;\n    int steps = 0;\n    int[] dirs = {-1, 0, 1, 0, -1};\n    \n    while(!q.isEmpty()) {\n        int size = q.size();\n        for(int i = 0; i < size; i++) {\n            int[] cur = q.poll();\n            int x = cur[0], y = cur[1];\n\n            if(x == endX && y == endY) return steps;\n            \n            for(int k = 0; k < 4; k++) {\n                int newX = x + dirs[k];\n                int newY = y + dirs[k+1];\n                if(newX >= 0 && newX < m && newY >= 0 && newY < n && visited[newX][newY] == 0 && forest.get(newX).get(newY) != 0) {\n                    q.offer(new int[]{ newX, newY });\n                    visited[newX][newY] = 1;\n                }\n            }\n        }\n        steps++;\n    }\n    \n    return -1;\n}\n```\n    \n    1. Traverse the matrix, adding the tree positions to a trees list.\n2. Sort the trees list by tree height.\n3. For each tree in the list, apply Breadth-First Search (BFS) to find the minimum steps to cut the tree from the previous tree or the starting point.\n4. If any BFS returns -1, return -1, otherwise, return the sum of all steps taken in BFS.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1\n```\n    \n    1. Traverse the matrix, adding the tree positions to a trees list.\n2. Sort the trees list by tree height.\n3. For each tree in the list, apply Breadth-First Search (BFS) to find the minimum steps to cut the tree from the previous tree or the starting point.\n4. If any BFS returns -1, return -1, otherwise, return the sum of all steps taken in BFS.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nint cutOffTree(std::vector<std::vector<int>>& forest) {\n    if(forest.empty() || forest[0].empty()) return 0;\n    int m = forest.size(), n = forest[0].size();\n    std::vector<std::pair<int, int>> trees;\n    \n    for(int i = 0; i < m; i++)\n        for(int j = 0; j < n; j++)\n            if(forest[i][j] > 1)\n                trees.push_back({i, j});\n    \n    std::sort(trees.begin(), trees.end(), [&forest](std::pair<int, int>& a, std::pair<int, int>& b) {\n        return forest[a.first][a.second] < forest[b.first][b.second];\n    });\n\n    int startX = 0, startY = 0;\n    int totalSteps = 0;\n    for(std::pair<int, int>& tree : trees){\n        int x = tree.first, y = tree.second;\n        int steps = bfs(forest, startX, startY, x, y);\n        if(steps == -1) return -1;\n        totalSteps += steps;\n        startX = x;\n        startY = y;\n    }\n    \n    return totalSteps;\n}\n\nint bfs(std::vector<std::vector<int>>& forest, int startX, int startY, int endX, int endY) {\n    int m = forest.size(), n = forest[0].size();\n    std::vector<std::vector<int>> visited(m, std::vector<int>(n, 0));\n    std::queue<std::pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startX][startY] = 1;\n    int steps = 0;\n    std::vector<int> dirs{-1, 0, 1, 0, -1};\n    \n    while(!q.empty()) {\n        int size = q.size();\n        for(int i = 0; i < size; i++) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            \n            if(x == endX && y == endY) return steps;\n            \n            for(int k = 0; k < 4; k++) {\n                int newX = x + dirs[k];\n                int newY = y + dirs[k+1];\n                if(newX >= 0 && newX < m && newY >= 0 && newY < n && !visited[newX][newY] && forest[newX][newY] != 0) {\n                    q.push({newX, newY});\n                    visited[newX][newY] = 1;\n                }\n            }\n        }\n        steps++;\n    }\n    \n    return -1;\n}\n```\n    \n    1. Traverse the matrix, adding the tree positions to a trees list.\n2. Sort the trees list by tree height.\n3. For each tree in the list, apply Breadth-First Search (BFS) to find the minimum steps to cut the tree from the previous tree or the starting point.\n4. If any BFS returns -1, return -1, otherwise, return the sum of all steps taken in BFS.\n    ",
        "js": "\n    ```javascript\nfunction cutOffTree(forest) {\n    if(!forest || !forest[0]) return 0;\n    let m = forest.length, n = forest[0].length;\n    let trees = [];\n    \n    for(let i = 0; i < m; i++)\n        for(let j = 0; j < n; j++)\n            if(forest[i][j] > 1)\n                trees.push([forest[i][j], i, j]);\n    \n    trees.sort((a, b) => a[0] - b[0]);\n\n    let startX = 0, startY = 0;\n    let totalSteps = 0;\n    for(let tree of trees){\n        let [, x, y] = tree;\n        let steps = bfs(forest, startX, startY, x, y);\n        if(steps === -1) return -1;\n        totalSteps += steps;\n        startX = x;\n        startY = y;\n    }\n    \n    return totalSteps;\n}\n\nfunction bfs(forest, startX, startY, endX, endY) {\n    let m = forest.length, n = forest[0].length;\n    let visited = Array.from({ length: m }, () => Array(n).fill(false));\n    let q = [[startX, startY, 0]];\n    visited[startX][startY] = true;\n    let dirs = [-1, 0, 1, 0, -1];\n    \n    while(q.length !== 0) {\n        let [x, y, steps] = q.shift();\n        for(let k = 0; k < 4; k++) {\n            let newX = x + dirs[k], newY = y + dirs[k+1];\n            if(0 <= newX && newX < m && 0 <= newY && newY < n && !visited[newX][newY] && forest[newX][newY] !== 0) {\n                if(newX === endX && newY === endY)\n                    return steps + 1;\n                q.push([newX, newY, steps + 1]);\n                visited[newX][newY] = true;\n            }\n        }\n    }\n    \n    return -1;\n}\n```\n    \n    1. Traverse the matrix, adding the tree positions to a trees list.\n2. Sort the trees list by tree height.\n3. For each tree in the list, apply Breadth-First Search (BFS) to find the minimum steps to cut the tree from the previous tree or the starting point.\n4. If any BFS returns -1, return -1, otherwise, return the sum of all steps taken in BFS.\n    "
    },
    {
        "id": 91,
        "title": "24 Game",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `cards` of length `4`. You have four cards, each containing a number in the range `[1, 9]`. You should arrange the numbers on these cards in a mathematical expression using the operators `['+', '-', '*', '/']` and the parentheses `'('` and `')'` to get the value 24.\n\nYou are restricted with the following rules:\n\n*   The division operator `'/'` represents real division, not integer division.\n    *   For example, `4 / (1 - 2 / 3) = 4 / (1 / 3) = 12`.\n*   Every operation done is between two numbers. In particular, we cannot use `'-'` as a unary operator.\n    *   For example, if `cards = [1, 1, 1, 1]`, the expression `\"-1 - 1 - 1 - 1 \"` is **not allowed**.\n*   You cannot concatenate numbers together\n    *   For example, if `cards = [1, 2, 1, 2]`, the expression `\"12 + 12 \"` is not valid.\n\nReturn `true` if you can get such expression that evaluates to `24`, and `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input:** cards = \\[4,1,8,7\\]\n**Output:** true\n**Explanation:** (8-4) \\* (7-1) = 24\n\n",
                "**Example 2:**\n\n**Input:** cards = \\[1,2,1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `cards.length == 4`\n*   `1 <= cards[i] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Backtracking"
        ],
        "example": [
            {
                "input": "[4,1,8,7]",
                "output": "true"
            },
            {
                "input": "[1,2,1,2]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic boolean helper(List<Double> cards) {\n    if (cards.size() == 1) {\n        return Math.abs(cards.get(0) - 24) < 1e-6;\n    }\n\n    for (int i = 0; i < cards.size(); ++i) {\n        for (int j = i + 1; j < cards.size(); ++j) {\n            double a = cards.get(i), b = cards.get(j);\n            List<Double> next = Arrays.asList(a + b, a - b, a * b, a / b);\n\n            cards.remove(j);\n            cards.remove(i);\n\n            for (Double e : next) {\n                cards.add(e);\n                if (helper(cards)) {\n                    return true;\n                }\n                cards.remove(cards.size() - 1);\n            }\n\n            cards.add(i, a);\n            cards.add(j, b);\n        }\n    }\n    return false;\n}\n\npublic boolean canGet24(int[] cards) {\n    List<Double> doubleCards = new ArrayList<>();\n    for (int card : cards) {\n        doubleCards.add((double) card);\n    }\n    return helper(doubleCards);\n}\n```\n\n    \n    The algorithm uses a recursive approach to generate all possible combinations of operations between the operands. For every possible pair of cards, we apply all the operations and call the helper function with the result and the cards left.\n\nIn the base case when there is only one card left, we check if the remaining value is almost equal to the target value (24). If it is, we return true.\n\nIf all possible combinations have been checked and none of them returns true, we return false.\n    ",
        "python": "\n    ```python\nfrom itertools import permutations\n\ndef helper(cards, target=24):\n    if len(cards) == 1:\n        return abs(cards[0] - target) < 1e-6\n\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            a, b = cards[i], cards[j]\n            rest = [cards[k] for k in range(len(cards)) if k != i and k != j]\n            for e in a + b, a - b, a * b, a / b:\n                if helper(rest + [e]):\n                    return True\n    return False\n\ndef canGet24(cards):\n    return helper(cards)\n```\n\n    \n    The algorithm uses a recursive approach to generate all possible combinations of operations between the operands. For every possible pair of cards, we apply all the operations and call the helper function with the result and the cards left.\n\nIn the base case when there is only one card left, we check if the remaining value is almost equal to the target value (24). If it is, we return true.\n\nIf all possible combinations have been checked and none of them returns true, we return false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nbool helper(std::vector<double>& cards) {\n    if (cards.size() == 1) {\n        return std::abs(cards[0] - 24) < 1e-6;\n    }\n\n    for (int i = 0; i < cards.size(); ++i) {\n        for (int j = i + 1; j < cards.size(); ++j) {\n            double a = cards[i], b = cards[j];\n            std::vector<double> next = {a + b, a - b, a * b, a / b};\n\n            cards.erase(cards.begin() + j);\n            cards.erase(cards.begin() + i);\n\n            for (auto& e : next) {\n                cards.push_back(e);\n                if (helper(cards)) {\n                    return true;\n                }\n                cards.pop_back();\n            }\n\n            cards.insert(cards.begin() + i, a);\n            cards.insert(cards.begin() + j, b);\n        }\n    }\n    return false;\n}\n\nbool canGet24(std::vector<int>& cards) {\n    std::vector<double> doubleCards(cards.begin(), cards.end());\n    return helper(doubleCards);\n}\n```\n\n    \n    The algorithm uses a recursive approach to generate all possible combinations of operations between the operands. For every possible pair of cards, we apply all the operations and call the helper function with the result and the cards left.\n\nIn the base case when there is only one card left, we check if the remaining value is almost equal to the target value (24). If it is, we return true.\n\nIf all possible combinations have been checked and none of them returns true, we return false.\n    ",
        "js": "\n    ```javascript\nfunction helper(cards) {\n  if (cards.length === 1) {\n    return Math.abs(cards[0] - 24) < 1e-6;\n  }\n\n  for (let i = 0; i < cards.length; ++i) {\n    for (let j = i + 1; j < cards.length; ++j) {\n      const a = cards[i], b = cards[j];\n      const next = [a + b, a - b, a * b, a / b];\n\n      cards.splice(j, 1);\n      cards.splice(i, 1);\n\n      for (const e of next) {\n        cards.push(e);\n        if (helper(cards)) {\n          return true;\n        }\n        cards.pop();\n      }\n\n      cards.splice(i, 0, a);\n      cards.splice(j, 0, b);\n    }\n  }\n  return false;\n}\n\nfunction canGet24(cards) {\n  return helper(cards);\n}\n```\n\n    \n    The algorithm uses a recursive approach to generate all possible combinations of operations between the operands. For every possible pair of cards, we apply all the operations and call the helper function with the result and the cards left.\n\nIn the base case when there is only one card left, we check if the remaining value is almost equal to the target value (24). If it is, we return true.\n\nIf all possible combinations have been checked and none of them returns true, we return false.\n    "
    },
    {
        "id": 92,
        "title": "Redundant Connection II",
        "difficulty": "Hard",
        "content": {
            "problem": "In this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.\n\nReturn _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,1\\],\\[1,5\\]\\]\n**Output:** \\[4,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "[[1,2],[1,3],[2,3]]",
                "output": "[2,3]"
            },
            {
                "input": "[[1,2],[2,3],[3,4],[4,1],[1,5]]",
                "output": "[4,1]"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int[] parent = new int[edges.length + 1];\n        int[] candidateA = null, candidateB = null;\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (parent[v] > 0) {\n                candidateA = new int[] {parent[v], v};\n                candidateB = edge;\n            } else {\n                parent[v] = u;\n            }\n        }\n        \n        for (int i = 1; i <= edges.length; ++i) {\n            int cycle = i, steps = edges.length;\n            while (parent[cycle] != 0 && steps-- > 0) {\n                cycle = parent[cycle];\n            }\n            if (steps == -1) {\n                if (candidateA == null) return new int[] {parent[i], i};\n                else return candidateA;\n            }\n        }\n        \n        return candidateB;\n    }\n}\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "python": "\n    ```python\ndef findRedundantDirectedConnection(edges):\n    parent = [0] * (len(edges) + 1)\n    candidateA = candidateB = None\n\n    for u, v in edges:\n        if parent[v] > 0:\n            candidateA = [parent[v], v]\n            candidateB = [u, v]\n        else:\n            parent[v] = u\n\n    for i in range(1, len(edges) + 1):\n        cycle = i\n        steps = len(edges)\n        while parent[cycle] != 0 and steps > 0:\n            cycle = parent[cycle]\n            steps -= 1\n        if steps == 0:\n            if not candidateA:\n                return [parent[i], i]\n            else:\n                return candidateA\n\n    return candidateB\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n    vector<int> parent(edges.size() + 1, 0);\n    vector<int> candidateA, candidateB;\n    \n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1];\n        if (parent[v] > 0) {\n            candidateA = {parent[v], v};\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n    \n    for (int i = 1; i <= edges.size(); ++i) {\n        int cycle = i, steps = edges.size();\n        while (parent[cycle] != 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps == -1) {\n            if (candidateA.empty()) return {parent[i], i};\n            else return candidateA;\n        }\n    }\n    \n    return candidateB;\n}\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "js": "\n    ```javascript\nfunction findRedundantDirectedConnection(edges) {\n    const parent = Array(edges.length + 1).fill(0);\n    let candidateA = null, candidateB = null;\n\n    for (const edge of edges) {\n        const [u, v] = edge;\n        if (parent[v] > 0) {\n            candidateA = [parent[v], v];\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n\n    for (let i = 1; i <= edges.length; ++i) {\n        let cycle = i, steps = edges.length;\n        while (parent[cycle] !== 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps === -1) {\n            if (candidateA === null) return [parent[i], i];\n            else return candidateA;\n        }\n    }\n\n    return candidateB;\n}\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    "
    },
    {
        "id": 93,
        "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (**0-indexed**). If there are multiple answers, return the lexicographically smallest one.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,6,7,5,1\\], k = 2\n**Output:** \\[0,3,5\\]\n**Explanation:** Subarrays \\[1, 2\\], \\[2, 6\\], \\[7, 5\\] correspond to the starting indices \\[0, 3, 5\\].\nWe could have also taken \\[2, 1\\], but an answer of \\[1, 3, 5\\] would be lexicographically larger.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1,2,1\\], k = 2\n**Output:** \\[0,2,4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] < 216`\n*   `1 <= k <= floor(nums.length / 3)`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,2,1,2,6,7,5,1],2",
                "output": "[0,3,5]"
            },
            {
                "input": "[1,2,1,2,1,2,1,2,1],2",
                "output": "[0,2,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] max_sum_of_three_subarrays(int[] nums, int k) {\n    int n = nums.length;\n    int[] sums = new int[n - k + 1];\n    int[] left = new int[n], right = new int[n], ans = new int[3];\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = new int[] {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "python": "\n    ```python\ndef max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) {\n    int n = nums.size();\n    std::vector<int> sums(n - k + 1);\n    std::vector<int> left(n), right(n), ans(3);\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "js": "\n    ```javascript\nfunction max_sum_of_three_subarrays(nums, k) {\n    const n = nums.length;\n    const sums = new Array(n - k + 1);\n    const left = new Array(n), right = new Array(n);\n    let acc_sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (let i = 1; i < n - k + 1; i++) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (let i = n - k - 1; i >= 0; i--) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    let max_sum = 0;\n    const ans = [0, 0, 0];\n\n    for (let i = k; i < n - 2 * k + 1; i++) {\n        const left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans[0] = left_idx;\n            ans[1] = i;\n            ans[2] = right_idx;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    "
    },
    {
        "id": 94,
        "title": "Stickers to Spell Word",
        "difficulty": "Hard",
        "content": {
            "problem": "We are given `n` different types of `stickers`. Each sticker has a lowercase English word on it.\n\nYou would like to spell out the given string `target` by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n\nReturn _the minimum number of stickers that you need to spell out_ `target`. If the task is impossible, return `-1`.\n\n**Note:** In all test cases, all words were chosen randomly from the `1000` most common US English words, and `target` was chosen as a concatenation of two random words.",
            "examples": [
                "**Example 1:**\n\n**Input:** stickers = \\[ \"with \", \"example \", \"science \"\\], target =  \"thehat \"\n**Output:** 3\n**Explanation:**\nWe can use 2  \"with \" stickers, and 1  \"example \" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target  \"thehat \".\nAlso, this is the minimum number of stickers necessary to form the target string.\n\n",
                "**Example 2:**\n\n**Input:** stickers = \\[ \"notice \", \"possible \"\\], target =  \"basicbasic \"\n**Output:** -1\nExplanation:\nWe cannot form the target  \"basicbasic \" from cutting letters from the given stickers."
            ],
            "constraints": "**Constraints:**\n\n*   `n == stickers.length`\n*   `1 <= n <= 50`\n*   `1 <= stickers[i].length <= 10`\n*   `1 <= target.length <= 15`\n*   `stickers[i]` and `target` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[\"with\",\"example\",\"science\"],\"thehat\"",
                "output": "3"
            },
            {
                "input": "[\"notice\",\"possible\"],\"basicbasic\"",
                "output": "-1\nExplanation:\nWecannotformthetarget\"basicbasic\"fromcuttinglettersfromthegivenstickers."
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int minStickers(String[] stickers, String target) {\n        Map<String, Integer> memo = new HashMap<>();\n        int[] targetCount = new int[26];\n        for (char c : target.toCharArray()) targetCount[c - 'a']++;\n        \n        for (String s : stickers) {\n            int[] stickerCount = new int[26];\n            StringBuilder sb = new StringBuilder();\n            for (char c : s.toCharArray()) {\n                if (targetCount[c - 'a'] == 0) continue;\n                stickerCount[c - 'a']++;\n            }\n            for (int i = 0; i < 26; ++i) {\n                sb.append(String.valueOf((char) ('a' + i)).repeat(stickerCount[i]));\n            }\n            memo.put(sb.toString(), 1);\n        }\n        \n        return dp(memo, targetCount, target);\n    }\n    \n    private int dp(Map<String, Integer> memo, int[] targetCount, String target) {\n        if (memo.containsKey(target)) return memo.get(target);\n        int[] counts = new int[26];\n        for (char c : target.toCharArray()) counts[c - 'a']++;\n        int ans = Integer.MAX_VALUE;\n        for (Map.Entry<String, Integer> kv : memo.entrySet()) {\n            boolean ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.getKey().charAt(i) - 'a';\n            if (!ok) continue;\n            ans = Math.min(ans, dp(memo, targetCount, target.substring(kv.getKey().length())) + kv.getValue());\n        }\n        memo.put(target, ans == Integer.MAX_VALUE ? -1 : ans);\n        return memo.get(target);\n    }\n}\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\nfrom functools import lru_cache\n\ndef minStickers(stickers, target):\n    target_count = Counter(target)\n    memo = {}\n    \n    for s in stickers:\n        sticker_count = Counter(s)\n        state = ''.join(sticker_count & target_count)\n        memo[state] = 1\n    \n    @lru_cache(None)\n    def dp(state):\n        counts = Counter(state)\n        ans = float('inf')\n        for key, value in memo.items():\n            if any(counts[ch] < key.count(ch) for ch in state): continue\n            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)\n        return -1 if ans == float('inf') else ans\n    \n    return dp(target)\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minStickers(vector<string>& stickers, string target) {\n    unordered_map<string, int> memo;\n    vector<int> target_count(26, 0);\n    for (char c : target) target_count[c - 'a']++;\n    \n    for (string& s : stickers) {\n        vector<int> sticker_count(26, 0);\n        int connection = 0;\n        for (char c : s) {\n            if (!target_count[c - 'a']) continue;\n            connection = 1;\n            sticker_count[c - 'a']++;\n        }\n        if (!connection) continue;\n        \n        string state = \"\";\n        for (int i = 0; i < 26; ++i)\n            state += string(sticker_count[i], 'a' + i);\n        memo[state] = 1;\n    }\n    \n    function<int(const string&)> dp = [&](const string& state) {\n        if (memo.count(state)) return memo[state];\n        vector<int> counts(26, 0);\n        for (char c : state) counts[c - 'a']++;\n        int ans = INT_MAX;\n        for (const auto& kv : memo) {\n            bool ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.first[i] - 'a';\n            if (!ok) continue;\n            ans = min(ans, dp(state.substr(kv.first.size())) + kv.second);\n        }\n        memo[state] = ans == INT_MAX ? -1 : ans;\n        return memo[state];\n    };\n    \n    string start = \"\";\n    for (int i = 0; i < 26; ++i)\n        start += string(target_count[i], 'a' + i);\n    return dp(start);\n}\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    ",
        "js": "\n    ```javascript\nfunction minStickers(stickers, target) {\n    let targetCount = new Array(26).fill(0);\n    let memo = new Map();\n    for (let c of target) targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    for (let s of stickers) {\n        let stickerCount = new Array(26).fill(0);\n        let state = \"\";\n        for (let c of s) {\n            if (!targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]) continue;\n            stickerCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n        for (let i = 0; i < 26; ++i) {\n            state += String.fromCharCode('a'.charCodeAt(0) + i).repeat(stickerCount[i]);\n        }\n        memo.set(state, 1);\n    }\n    \n    return dp(memo, target);\n}\n\nfunction dp(memo, target) {\n    if (memo.has(target)) return memo.get(target);\n    let counts = new Array(26).fill(0);\n    for (let c of target) counts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    let ans = Infinity;\n    for (let [key, value] of memo) {\n        let ok = true;\n        for (let i = 0; i < 26 && ok; ++i)\n            ok = counts[i] >= (key.match(new RegExp(String.fromCharCode('a'.charCodeAt(0) + i), 'g')) || []).length;\n        if (!ok) continue;\n        ans = Math.min(ans, dp(memo, target.substring(key.length)) + value);\n    }\n    memo.set(target, ans == Infinity ? -1 : ans);\n    return memo.get(target);\n}\n```\n    \n    The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems.\n    "
    },
    {
        "id": 95,
        "title": "Falling Squares",
        "difficulty": "Hard",
        "content": {
            "problem": "There are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the X-axis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\nAfter each square is dropped, you must record the **height of the current tallest stack of squares**.\n\nReturn _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.",
            "examples": [
                "**Example 1:**\n\n**Input:** positions = \\[\\[1,2\\],\\[2,3\\],\\[6,1\\]\\]\n**Output:** \\[2,5,5\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of \\[2, 5, 5\\].\n\n",
                "**Example 2:**\n\n**Input:** positions = \\[\\[100,100\\],\\[200,100\\]\\]\n**Output:** \\[100,100\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of \\[100, 100\\].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= positions.length <= 1000`\n*   `1 <= lefti <= 108`\n*   `1 <= sideLengthi <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Segment Tree",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3],[6,1]]",
                "output": "[2,5,5]"
            },
            {
                "input": "[[100,100],[200,100]]",
                "output": "[100,100]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int[] fallingSquares(int[][] positions) {\n    int[] ans = new int[positions.length];\n    List<int[]> intervals = new ArrayList<>();\n\n    for (int i = 0; i < positions.length; i++) {\n        int L = positions[i][0];\n        int R = positions[i][0] + positions[i][1];\n        int h = positions[i][1];\n        for (int[] interval : intervals) {\n            if (interval[1] > L && R > interval[1]) {\n                h = Math.max(h, positions[i][1] + interval[0]);\n            }\n        }\n\n        int maxHeight = h;\n        for (int[] interval : intervals) {\n            maxHeight = Math.max(maxHeight, interval[0]);\n        }\n\n        ans[i] = maxHeight;\n        intervals.add(new int[]{h, R});\n    }\n    \n    return ans;\n}\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "python": "\n    ```python\ndef fallingSquares(positions):\n    ans = []\n    intervals = []\n\n    for p in positions:\n        L, size = p\n        R = L + size\n        h = size\n        for h2, R2 in intervals:\n            if R2 > L and R > R2:\n                h = max(h, size + h2)\n\n        maxHeight = max((h2 for h2, R2 in intervals), default=0)\n        ans.append(max(maxHeight, h))\n        intervals.append((h, R))\n\n    return ans\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvector<int> fallingSquares(vector<vector<int>>& positions) {\n    vector<int> ans;\n    vector<pair<int, int>> intervals;\n\n    for (auto p : positions) {\n        int L = p[0];\n        int R = p[0] + p[1];\n        int h = p[1];\n        for (auto it : intervals) {\n            if (it.first < R && L < it.second) {\n                h = max(h, p[1] + it.first);\n            }\n        }\n\n        int maxHeight = h;\n        for (auto it : intervals) {\n            maxHeight = max(maxHeight, it.first);\n        }\n\n        ans.push_back(maxHeight);\n        intervals.push_back(make_pair(h, R));\n    }\n    \n    return ans;\n}\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "js": "\n    ```javascript\nfunction fallingSquares(positions) {\n    let ans = [];\n    let intervals = [];\n\n    for (let p of positions) {\n        let L = p[0];\n        let R = p[0] + p[1];\n        let h = p[1];\n        for (let it of intervals) {\n            if (it[1] > L && R > it[1]) {\n                h = Math.max(h, p[1] + it[0]);\n            }\n        }\n\n        let maxHeight = h;\n        for (let it of intervals) {\n            maxHeight = Math.max(maxHeight, it[0]);\n        }\n\n        ans.push(maxHeight);\n        intervals.push([h, R]);\n    }\n    \n    return ans;\n}\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    "
    },
    {
        "id": 96,
        "title": "Random Pick with Blacklist",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n` and an array of **unique** integers `blacklist`. Design an algorithm to pick a random integer in the range `[0, n - 1]` that is **not** in `blacklist`. Any integer that is in the mentioned range and not in `blacklist` should be **equally likely** to be returned.\n\nOptimize your algorithm such that it minimizes the number of calls to the **built-in** random function of your language.\n\nImplement the `Solution` class:\n\n*   `Solution(int n, int[] blacklist)` Initializes the object with the integer `n` and the blacklisted integers `blacklist`.\n*   `int pick()` Returns a random integer in the range `[0, n - 1]` and not in `blacklist`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Solution \",  \"pick \",  \"pick \",  \"pick \",  \"pick \",  \"pick \",  \"pick \",  \"pick \"\\]\n\\[\\[7, \\[2, 3, 5\\]\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, 0, 4, 1, 6, 1, 0, 4\\]\n\n**Explanation**\nSolution solution = new Solution(7, \\[2, 3, 5\\]);\nsolution.pick(); // return 0, any integer from \\[0,1,4,6\\] should be ok. Note that for every call of pick,\n                 // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).\nsolution.pick(); // return 4\nsolution.pick(); // return 1\nsolution.pick(); // return 6\nsolution.pick(); // return 1\nsolution.pick(); // return 0\nsolution.pick(); // return 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`\n*   `0 <= blacklist.length <= min(105, n - 1)`\n*   `0 <= blacklist[i] < n`\n*   All the values of `blacklist` are **unique**.\n*   At most `2 * 104` calls will be made to `pick`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Binary Search",
            "Sorting",
            "Randomized"
        ],
        "example": [
            {
                "input": "]\n]],[],[],[],[],[],[],[]]",
                "output": "**Output**\n[null,0,4,1,6,1,0,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Random;\n\nclass Solution {\n    private HashMap<Integer, Integer> mapping;\n    private int last;\n    private Random random;\n\n    public Solution(int n, int[] blacklist) {\n        Arrays.sort(blacklist);\n        mapping = new HashMap<>();\n        int idx = 0;\n        for (int i = 0; i < blacklist.length; ++i) {\n            int black = blacklist[i];\n            while (idx < black) {\n                mapping.put(idx++, --n);\n            }\n            idx++;\n            n--;\n        }\n        last = n;\n        random = new Random();\n    }\n\n    public int pick() {\n        int num = random.nextInt(last);\n        return mapping.getOrDefault(num, num);\n    }\n}\n```\n    \n    We create a mapping from the non-blacklisted range `[0, n - blacklist.size())` to the full available range `[0, n)`. For each non-blacklisted number `num`, the mapping contains the non-blacklisted number that corresponds to its position `num - blacklist[i]` in the full available range. We initialize the mapping by iterating over the sorted `blacklist`, and we pick a random integer in the non-blacklisted range and use the mapping to get the corresponding available number. To minimize the number of calls to the random function, we only call it once per `pick()` call. This ensures that any integer in the non-blacklisted range is equally likely to be returned.\n    ",
        "python": "\n    ```python\nimport random\n\nclass Solution:\n    def __init__(self, n: int, blacklist: List[int]):\n        blacklist.sort()\n        self.mapping = dict()\n        idx = 0\n        for black in blacklist:\n            while idx < black:\n                self.mapping[idx] = n - 1\n                idx += 1\n                n -= 1\n            idx += 1\n            n -= 1\n        self.last = n\n\n    def pick(self) -> int:\n        num = random.randrange(self.last)\n        return self.mapping.get(num, num)\n```\n    \n    We create a mapping from the non-blacklisted range `[0, n - blacklist.size())` to the full available range `[0, n)`. For each non-blacklisted number `num`, the mapping contains the non-blacklisted number that corresponds to its position `num - blacklist[i]` in the full available range. We initialize the mapping by iterating over the sorted `blacklist`, and we pick a random integer in the non-blacklisted range and use the mapping to get the corresponding available number. To minimize the number of calls to the random function, we only call it once per `pick()` call. This ensures that any integer in the non-blacklisted range is equally likely to be returned.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nclass Solution {\npublic:\n    Solution(int n, std::vector<int>& blacklist) {\n        std::sort(blacklist.begin(), blacklist.end());\n        auto it = blacklist.begin();\n        int idx = 0;\n        for (int i = 0; i < blacklist.size(); ++i) {\n            int black = *it++;\n            while (idx < black) {\n                mapping[idx++] = n - 1;\n                --n;\n            }\n            ++idx;\n            --n;\n        }\n        last = n;\n    }\n    \n    int pick() {\n        int num = rand() % last;\n        auto res = mapping.find(num);\n        return res == mapping.end() ? num : res->second;\n    }\n\nprivate:\n    std::unordered_map<int, int> mapping;\n    int last;\n};\n```\n    \n    We create a mapping from the non-blacklisted range `[0, n - blacklist.size())` to the full available range `[0, n)`. For each non-blacklisted number `num`, the mapping contains the non-blacklisted number that corresponds to its position `num - blacklist[i]` in the full available range. We initialize the mapping by iterating over the sorted `blacklist`, and we pick a random integer in the non-blacklisted range and use the mapping to get the corresponding available number. To minimize the number of calls to the random function, we only call it once per `pick()` call. This ensures that any integer in the non-blacklisted range is equally likely to be returned.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    constructor(n, blacklist) {\n        blacklist.sort((a, b) => a - b);\n        this.mapping = new Map();\n        let idx = 0;\n        for (let i = 0; i < blacklist.length; ++i) {\n            let black = blacklist[i];\n            while (idx < black) {\n                this.mapping.set(idx++, n - 1);\n                n--;\n            }\n            idx++;\n            n--;\n        }\n        this.last = n;\n    }\n\n    pick() {\n        const num = Math.floor(Math.random() * this.last);\n        return this.mapping.has(num) ? this.mapping.get(num) : num;\n    }\n}\n```\n    \n    We create a mapping from the non-blacklisted range `[0, n - blacklist.size())` to the full available range `[0, n)`. For each non-blacklisted number `num`, the mapping contains the non-blacklisted number that corresponds to its position `num - blacklist[i]` in the full available range. We initialize the mapping by iterating over the sorted `blacklist`, and we pick a random integer in the non-blacklisted range and use the mapping to get the corresponding available number. To minimize the number of calls to the random function, we only call it once per `pick()` call. This ensures that any integer in the non-blacklisted range is equally likely to be returned.\n    "
    },
    {
        "id": 97,
        "title": "Find K-th Smallest Pair Distance",
        "difficulty": "Hard",
        "content": {
            "problem": "The **distance of a pair** of integers `a` and `b` is defined as the absolute difference between `a` and `b`.\n\nGiven an integer array `nums` and an integer `k`, return _the_ `kth` _smallest **distance among all the pairs**_ `nums[i]` _and_ `nums[j]` _where_ `0 <= i < j < nums.length`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,1\\], k = 1\n**Output:** 0\n**Explanation:** Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\], k = 2\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,6,1\\], k = 3\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 104`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= n * (n - 1) / 2`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,3,1],1",
                "output": "0"
            },
            {
                "input": "[1,1,1],2",
                "output": "0"
            },
            {
                "input": "[1,6,1],3",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int smallestDistancePair(int[] nums, int k) {\n    Arrays.sort(nums);\n    int low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "python": "\n    ```python\ndef smallestDistancePair(nums, k):\n    nums.sort()\n    low, high = 0, nums[-1] - nums[0]\n    \n    while low < high:\n        mid = (low + high) // 2\n        count, left = 0, 0\n\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > mid:\n                left += 1\n            count += (right - left)\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint smallestDistancePair(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    int low = 0, high = nums.back() - nums.front();\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.size(); ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "js": "\n    ```javascript\nfunction smallestDistancePair(nums, k) {\n    nums.sort((a, b) => a - b);\n    let low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        let mid = Math.floor((low + high) / 2);\n        let count = 0, left = 0;\n\n        for (let right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    "
    },
    {
        "id": 98,
        "title": "Number of Atoms",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `formula` representing a chemical formula, return _the count of each atom_.\n\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n\nOne or more digits representing that element's count may follow if the count is greater than `1`. If the count is `1`, no digits will follow.\n\n*   For example, `\"H2O \"` and `\"H2O2 \"` are possible, but `\"H1O2 \"` is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\n*   For example, `\"H2O2He3Mg4 \"` is also a formula.\n\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\n*   For example, `\"(H2O2) \"` and `\"(H2O2)3 \"` are formulas.\n\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than `1`), followed by the second name (in sorted order), followed by its count (if that count is more than `1`), and so on.\n\nThe test cases are generated so that all the values in the output fit in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** formula =  \"H2O \"\n**Output:**  \"H2O \"\n**Explanation:** The count of elements are {'H': 2, 'O': 1}.\n\n",
                "**Example 2:**\n\n**Input:** formula =  \"Mg(OH)2 \"\n**Output:**  \"H2MgO2 \"\n**Explanation:** The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n\n",
                "**Example 3:**\n\n**Input:** formula =  \"K4(ON(SO3)2)2 \"\n**Output:**  \"K4N2O14S4 \"\n**Explanation:** The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= formula.length <= 1000`\n*   `formula` consists of English letters, digits, `'('`, and `')'`.\n*   `formula` is always valid.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Stack",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"H2O\"",
                "output": "\"H2O\""
            },
            {
                "input": "\"Mg(OH)2\"",
                "output": "\"H2MgO2\""
            },
            {
                "input": "\"K4(ON(SO3)2)2\"",
                "output": "\"K4N2O14S4\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic String countOfAtoms(String formula) {\n    int[] i = {0};\n    Map<String, Integer> counts = parse(formula, i);\n    StringBuilder ans = new StringBuilder();\n    for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n        ans.append(entry.getKey());\n        if (entry.getValue() > 1) ans.append(entry.getValue());\n    }\n    return ans.toString();\n}\n\nprivate Map<String, Integer> parse(String formula, int[] i) {\n    Map<String, Integer> counts = new TreeMap<>();\n    while (i[0] < formula.length()) {\n        if (formula.charAt(i[0]) == '(') {\n            Map<String, Integer> temp = parse(formula, new int[]{++i[0]});\n            int count = 0;\n            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                count = count * 10 + (formula.charAt(i[0]++) - '0');\n            }\n            if (count == 0) count = 1;\n            for (Map.Entry<String, Integer> entry : temp.entrySet()) {\n                counts.put(entry.getKey(), counts.getOrDefault(entry.getKey(), 0) + entry.getValue() * count);\n            }\n        } else if (formula.charAt(i[0]) == ')') {\n            ++i[0];\n            return counts;\n        } else {\n            StringBuilder name = new StringBuilder().append(formula.charAt(i[0]++));\n            while (i[0] < formula.length() && Character.isLowerCase(formula.charAt(i[0]))) {\n                name.append(formula.charAt(i[0]++));\n            }\n            int count = 0;\n            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                count = count * 10 + (formula.charAt(i[0]++) - '0');\n            }\n            if (count == 0) count = 1;\n            counts.put(name.toString(), counts.getOrDefault(name.toString(), 0) + count);\n        }\n    }\n    return counts;\n}\n```\n\n    \n    The algorithm is based on a recursive descent parser. The idea is to parse the formula progressively, recognizing the atoms and the opening and closing parentheses. When an opening parenthesis is found, it calls itself to parse the inner formula, then when a closing parenthesis is found, it exits the function and accumulates the counts of the atoms, considering any eventual multiplier following the parentheses. If the formula contains no more parentheses, it will simply read the atoms and their counts.\n\nThe resulting atom counts are stored in a map or dictionary, depending on the language. In the end, the algorithm formats the output, concatenating the atom names and their counts (if greater than 1). The elements in the output are ordered based on the requirements (sorted), and no additional formatting is required.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef parse(formula, i):\n    counts = Counter()\n    while i[0] < len(formula):\n        if formula[i[0]] == '(':\n            i[0] += 1\n            temp = parse(formula, i)\n            count = 0\n            while i[0] < len(formula) and formula[i[0]].isdigit():\n                count = count * 10 + int(formula[i[0]])\n                i[0] += 1\n            if count == 0: count = 1\n            for name, c in temp.items():\n                counts[name] += c * count\n        elif formula[i[0]] == ')':\n            i[0] += 1\n            return counts\n        else:\n            name = formula[i[0]]\n            i[0] += 1\n            while i[0] < len(formula) and formula[i[0]].islower():\n                name += formula[i[0]]\n                i[0] += 1\n            count = 0\n            while i[0] < len(formula) and formula[i[0]].isdigit():\n                count = count * 10 + int(formula[i[0]])\n                i[0] += 1\n            if count == 0: count = 1\n            counts[name] += count\n    return counts\n\ndef countOfAtoms(formula):\n    i = [0]\n    counts = parse(formula, i)\n    ans = []\n    for name, count in counts.items():\n        ans.append(name)\n        if count > 1: ans.append(str(count))\n    return ''.join(ans)\n```\n\n    \n    The algorithm is based on a recursive descent parser. The idea is to parse the formula progressively, recognizing the atoms and the opening and closing parentheses. When an opening parenthesis is found, it calls itself to parse the inner formula, then when a closing parenthesis is found, it exits the function and accumulates the counts of the atoms, considering any eventual multiplier following the parentheses. If the formula contains no more parentheses, it will simply read the atoms and their counts.\n\nThe resulting atom counts are stored in a map or dictionary, depending on the language. In the end, the algorithm formats the output, concatenating the atom names and their counts (if greater than 1). The elements in the output are ordered based on the requirements (sorted), and no additional formatting is required.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, int> parse(const string &formula, int &i) {\n    map<string, int> counts;\n    while (i < formula.size()) {\n        if (formula[i] == '(') {\n            map<string, int> temp = parse(formula, ++i);\n            int count = 0;\n            while (isdigit(formula[i])) {\n                count = count * 10 + (formula[i++] - '0');\n            }\n            if (count == 0) count = 1;\n            for (const auto &e : temp) {\n                counts[e.first] += e.second * count;\n            }\n        } else if (formula[i] == ')') {\n            ++i;\n            return counts;\n        } else {\n            string name;\n            name += formula[i++];\n            while (islower(formula[i])) {\n                name += formula[i++];\n            }\n            int count = 0;\n            while (isdigit(formula[i])) {\n                count = count * 10 + (formula[i++] - '0');\n            }\n            if (count == 0) count = 1;\n            counts[name] += count;\n        }\n    }\n    return counts;\n}\n\nstring countOfAtoms(string formula) {\n    int i = 0;\n    map<string, int> counts = parse(formula, i);\n    string ans;\n    for (const auto &e : counts) {\n        ans += e.first;\n        if (e.second > 1) ans += to_string(e.second);\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm is based on a recursive descent parser. The idea is to parse the formula progressively, recognizing the atoms and the opening and closing parentheses. When an opening parenthesis is found, it calls itself to parse the inner formula, then when a closing parenthesis is found, it exits the function and accumulates the counts of the atoms, considering any eventual multiplier following the parentheses. If the formula contains no more parentheses, it will simply read the atoms and their counts.\n\nThe resulting atom counts are stored in a map or dictionary, depending on the language. In the end, the algorithm formats the output, concatenating the atom names and their counts (if greater than 1). The elements in the output are ordered based on the requirements (sorted), and no additional formatting is required.\n    ",
        "js": "\n    ```javascript\nfunction parse(formula, i) {\n    let counts = {};\n    while (i[0] < formula.length) {\n        if (formula[i[0]] == '(') {\n            i[0] += 1;\n            let temp = parse(formula, i);\n            let count = 0;\n            while (i[0] < formula.length && !isNaN(formula[i[0]])) {\n                count = count * 10 + parseInt(formula[i[0]]);\n                i[0] += 1;\n            }\n            if (count == 0) count = 1;\n            for (let [name, c] of Object.entries(temp)) {\n                counts[name] = (counts[name] || 0) + c * count;\n            }\n        } else if (formula[i[0]] == ')') {\n            i[0] += 1;\n            return counts;\n        } else {\n            let name = formula[i[0]];\n            i[0] += 1;\n            while (i[0] < formula.length && formula[i[0]] >= 'a' && formula[i[0]] <= 'z') {\n                name += formula[i[0]];\n                i[0] += 1;\n            }\n            let count = 0;\n            while (i[0] < formula.length && !isNaN(formula[i[0]])) {\n                count = count * 10 + parseInt(formula[i[0]]);\n                i[0] += 1;\n            }\n            if (count == 0) count = 1;\n            counts[name] = (counts[name] || 0) + count;\n        }\n    }\n    return counts;\n}\n\nfunction countOfAtoms(formula) {\n    let i = [0];\n    let counts = parse(formula, i);\n    let ans = [];\n    for (let name of Object.keys(counts).sort()) {\n        ans.push(name);\n        if (counts[name] > 1) ans.push(counts[name]);\n    }\n    return ans.join('');\n}\n```\n\n    \n    The algorithm is based on a recursive descent parser. The idea is to parse the formula progressively, recognizing the atoms and the opening and closing parentheses. When an opening parenthesis is found, it calls itself to parse the inner formula, then when a closing parenthesis is found, it exits the function and accumulates the counts of the atoms, considering any eventual multiplier following the parentheses. If the formula contains no more parentheses, it will simply read the atoms and their counts.\n\nThe resulting atom counts are stored in a map or dictionary, depending on the language. In the end, the algorithm formats the output, concatenating the atom names and their counts (if greater than 1). The elements in the output are ordered based on the requirements (sorted), and no additional formatting is required.\n    "
    },
    {
        "id": 99,
        "title": "Count Different Palindromic Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string s, return _the number of different non-empty palindromic subsequences in_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from the string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some `i` for which `ai != bi`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"bccb \"\n**Output:** 6\n**Explanation:** The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba \"\n**Output:** 104860361\n**Explanation:** There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'a'`, `'b'`, `'c'`, or `'d'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"bccb\"",
                "output": "6"
            },
            {
                "input": "\"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
                "output": "104860361"
            }
        ],
        "java": "\n    ```java\npublic int countPalindromicSubsequences(String S) {\n    int n = S.length();\n    int mod = 1000000007;\n    int[][] dp = new int[4][n + 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = S.charAt(i) - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            if (dp[c][j] < 0) dp[c][j] += mod;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % mod;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "python": "\n    ```python\ndef countPalindromicSubsequences(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(4)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            c = ord(s[i]) - ord('a')\n            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2\n            dp[c][j] = (dp[c][j] + MOD) % MOD\n\n    return sum(dp[c][n] for c in range(4)) % MOD\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint countPalindromicSubsequences(string s) {\n    int n = s.length();\n    int MOD = 1000000007;\n    vector<vector<int>> dp(4, vector<int>(n + 1, 0));\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = s[i] - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "js": "\n    ```javascript\nfunction countPalindromicSubsequences(s) {\n    const n = s.length;\n    const MOD = 1000000007;\n    const dp = Array.from({ length: 4 }, () => Array(n + 1).fill(0));\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            const c = s.charCodeAt(i) - 97;\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    "
    },
    {
        "id": 100,
        "title": "My Calendar III",
        "difficulty": "Hard",
        "content": {
            "problem": "A `k`\\-booking happens when `k` events have some non-empty intersection (i.e., there is some time that is common to all `k` events.)\n\nYou are given some events `[startTime, endTime)`, after each given event, return an integer `k` representing the maximum `k`\\-booking between all the previous events.\n\nImplement the `MyCalendarThree` class:\n\n*   `MyCalendarThree()` Initializes the object.\n*   `int book(int startTime, int endTime)` Returns an integer `k` representing the largest integer such that there exists a `k`\\-booking in the calendar.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MyCalendarThree \",  \"book \",  \"book \",  \"book \",  \"book \",  \"book \",  \"book \"\\]\n\\[\\[\\], \\[10, 20\\], \\[50, 60\\], \\[10, 40\\], \\[5, 15\\], \\[5, 10\\], \\[25, 55\\]\\]\n**Output**\n\\[null, 1, 1, 2, 3, 3, 3\\]\n\n**Explanation**\nMyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // return 1\nmyCalendarThree.book(50, 60); // return 1\nmyCalendarThree.book(10, 40); // return 2\nmyCalendarThree.book(5, 15); // return 3\nmyCalendarThree.book(5, 10); // return 3\nmyCalendarThree.book(25, 55); // return 3"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= startTime < endTime <= 109`\n*   At most `400` calls will be made to `book`.",
            "follow_up": null
        },
        "tag": [
            "Binary Search",
            "Design",
            "Segment Tree",
            "Prefix Sum",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],],]]",
                "output": "**Output**\n[null,1,1,2,3,3,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.TreeMap;\n\nclass MyCalendarThree {\n    private TreeMap<Integer, Integer> timeline = new TreeMap<>();\n\n    public int book(int start, int end) {\n        timeline.put(start, timeline.getOrDefault(start, 0) + 1);\n        timeline.put(end, timeline.getOrDefault(end, 0) - 1);\n        int ongoing = 0, k = 0;\n        for (int value : timeline.values()) {\n            k = Math.max(k, ongoing += value);\n        }\n        return k;\n    }\n}\n```\n\n    \n    The algorithm maintains a timeline, which is a data structure that stores events with their start and end times. For each booking, we increase the value at the start time by 1 and decrease the value at the end time by 1 in the timeline.\n\nAfter updating the timeline, we iterate over its values and keep track of the ongoing events count. By getting the maximum value of the ongoing events count, we can determine the maximum k-booking.\n\nIn C++, we use a `std::map<int, int>` to store the timeline events, while in Java, we use `TreeMap<Integer, Integer>`. In Python, we use a `collections.defaultdict(int)` to store the timeline events, and in JavaScript, we use a `Map()`.\n\nThe time complexity of the algorithm is O(N * log N) due to sorting for time (start and end) in the timeline data structure. The space complexity is O(N) to store the timeline events where N is the number of events.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\nimport heapq\n\nclass MyCalendarThree:\n\n    def __init__(self):\n        self.timeline = defaultdict(int)\n\n    def book(self, start: int, end: int) -> int:\n        self.timeline[start] += 1\n        self.timeline[end] -= 1\n        ongoing, k = 0, 0\n        for value in self.timeline.values():\n            k = max(k, ongoing + value)\n            ongoing += value\n        return k\n```\n\n    \n    The algorithm maintains a timeline, which is a data structure that stores events with their start and end times. For each booking, we increase the value at the start time by 1 and decrease the value at the end time by 1 in the timeline.\n\nAfter updating the timeline, we iterate over its values and keep track of the ongoing events count. By getting the maximum value of the ongoing events count, we can determine the maximum k-booking.\n\nIn C++, we use a `std::map<int, int>` to store the timeline events, while in Java, we use `TreeMap<Integer, Integer>`. In Python, we use a `collections.defaultdict(int)` to store the timeline events, and in JavaScript, we use a `Map()`.\n\nThe time complexity of the algorithm is O(N * log N) due to sorting for time (start and end) in the timeline data structure. The space complexity is O(N) to store the timeline events where N is the number of events.\n    ",
        "c++": "\n    ```cpp\n#include <map>\n\nclass MyCalendarThree {\npublic:\n    std::map<int, int> timeline;\n\n    int book(int start, int end) {\n        timeline[start]++;\n        timeline[end]--;\n        int ongoing = 0, k = 0;\n        for (auto& t : timeline) {\n            k = std::max(k, ongoing += t.second);\n        }\n        return k;\n    }\n};\n```\n\n    \n    The algorithm maintains a timeline, which is a data structure that stores events with their start and end times. For each booking, we increase the value at the start time by 1 and decrease the value at the end time by 1 in the timeline.\n\nAfter updating the timeline, we iterate over its values and keep track of the ongoing events count. By getting the maximum value of the ongoing events count, we can determine the maximum k-booking.\n\nIn C++, we use a `std::map<int, int>` to store the timeline events, while in Java, we use `TreeMap<Integer, Integer>`. In Python, we use a `collections.defaultdict(int)` to store the timeline events, and in JavaScript, we use a `Map()`.\n\nThe time complexity of the algorithm is O(N * log N) due to sorting for time (start and end) in the timeline data structure. The space complexity is O(N) to store the timeline events where N is the number of events.\n    ",
        "js": "\n    ```javascript\nclass MyCalendarThree {\n    constructor() {\n        this.timeline = new Map();\n    }\n\n    book(start, end) {\n        this.timeline.set(start, (this.timeline.get(start) || 0) + 1);\n        this.timeline.set(end, (this.timeline.get(end) || 0) - 1);\n        let ongoing = 0, k = 0;\n        for (const value of this.timeline.values()) {\n            k = Math.max(k, ongoing += value);\n        }\n        return k;\n    }\n}\n```\n\n    \n    The algorithm maintains a timeline, which is a data structure that stores events with their start and end times. For each booking, we increase the value at the start time by 1 and decrease the value at the end time by 1 in the timeline.\n\nAfter updating the timeline, we iterate over its values and keep track of the ongoing events count. By getting the maximum value of the ongoing events count, we can determine the maximum k-booking.\n\nIn C++, we use a `std::map<int, int>` to store the timeline events, while in Java, we use `TreeMap<Integer, Integer>`. In Python, we use a `collections.defaultdict(int)` to store the timeline events, and in JavaScript, we use a `Map()`.\n\nThe time complexity of the algorithm is O(N * log N) due to sorting for time (start and end) in the timeline data structure. The space complexity is O(N) to store the timeline events where N is the number of events.\n    "
    },
    {
        "id": 101,
        "title": "Parse Lisp Expression",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string expression representing a Lisp-like expression to return the integer value of.\n\nThe syntax for these expressions is given as follows.\n\n*   An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.\n*   (An integer could be positive or negative.)\n*   A let expression takes the form `\"(let v1 e1 v2 e2 ... vn en expr) \"`, where let is always the string `\"let \"`, then there are one or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let expression is the value of the expression `expr`.\n*   An add expression takes the form `\"(add e1 e2) \"` where add is always the string `\"add \"`, there are always two expressions `e1`, `e2` and the result is the addition of the evaluation of `e1` and the evaluation of `e2`.\n*   A mult expression takes the form `\"(mult e1 e2) \"` where mult is always the string `\"mult \"`, there are always two expressions `e1`, `e2` and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\n*   For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names `\"add \"`, `\"let \"`, and `\"mult \"` are protected and will never be used as variable names.\n*   Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"(let x 2 (mult x (let x 3 y 4 (add x y)))) \"\n**Output:** 14\n**Explanation:** In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"(let x 3 x 2 x) \"\n**Output:** 2\n**Explanation:** Assignment in let statements is processed sequentially.\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"(let x 1 y 2 x (add x y) (add x y)) \"\n**Output:** 5\n**Explanation:** The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 2000`\n*   There are no leading or trailing spaces in `expression`.\n*   All tokens are separated by a single space in `expression`.\n*   The answer and all intermediate calculations of that answer are guaranteed to fit in a **32-bit** integer.\n*   The expression is guaranteed to be legal and evaluate to an integer.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"(letx2(multx(letx3y4(addxy))))\"",
                "output": "14"
            },
            {
                "input": "\"(letx3x2x)\"",
                "output": "2"
            },
            {
                "input": "\"(letx1y2x(addxy)(addxy))\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic class Solution {\n    public int evaluate(String expression) {\n        return calculate(expression, 0, expression.length(), new HashMap<>());\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables) {\n        if (expression.charAt(start) == '(') {\n            if (expression.startsWith(\"add\", start + 1)) {\n                int first = start + 5;\n                int[] second = new int[]{first};\n                int value1 = calculate(expression, first, end, variables, second);\n                int value2 = calculate(expression, second[0] + 1, end, variables, null);\n                return value1 + value2;\n            } else if (expression.startsWith(\"mult\", start + 1)) {\n                int first = start + 6;\n                int[] second = new int[]{first};\n                int value1 = calculate(expression, first, end, variables, second);\n                int value2 = calculate(expression, second[0] + 1, end, variables, null);\n                return value1 * value2;\n            } else {\n                HashMap<String, Integer> inner = variables;\n                for (int idx = start + 5; idx < end - 1 && expression.charAt(idx) != '('; ) {\n                    int temp = idx;\n                    idx = expression.indexOf(' ', idx + 1);\n                    String var = expression.substring(temp, idx);\n                    temp = idx + 1;\n                    if (expression.charAt(temp) == '(') {\n                        idx++;\n                    } else {\n                        idx = expression.indexOf(' ', idx + 1);\n                    }\n                    int result = calculate(expression, temp, idx, variables, null);\n                    inner = new HashMap<>(variables);\n                    inner.put(var, result);\n                }\n                return calculate(expression, end - 1, end, inner, null);\n            }\n        } else {\n            if (Character.isDigit(expression.charAt(start)) || expression.charAt(start) == '-') {\n                end = expression.indexOf(' ', start);\n                if (end == -1) {\n                    end = expression.length();\n                }\n                return Integer.parseInt(expression.substring(start, end));\n            } else {\n                end = expression.indexOf(' ', start);\n                if (end == -1) {\n                    end = expression.length();\n                }\n                return variables.get(expression.substring(start, end));\n            }\n        }\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables, int[] nextStart) {\n        int temp = end;\n        int result = calculate(expression, start, end, variables);\n        if (nextStart != null) {\n            nextStart[0] = temp;\n        }\n        return result;\n    }\n}\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "python": "\n    ```python\ndef evaluate(expression: str) -> int:\n    def calculate(s, start, end, variables):\n        if s[start] == '(':\n            if s[start + 1:start + 4] == \"add\":\n                first = start + 5\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 + value2\n            elif s[start + 1:start + 5] == \"mult\":\n                first = start + 6\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 * value2\n            else:\n                inner = variables.copy()\n                idx = start + 5\n                while idx < end - 1 and s[idx] != '(':\n                    temp = idx\n                    idx = s.index(' ', idx + 1)\n                    var = s[temp:idx]\n                    temp = idx + 1\n                    if s[temp] == '(':\n                        idx += 1\n                    else:\n                        idx = s.index(' ', idx + 1)\n                    result = calculate(s, temp, idx, variables)\n                    inner[var] = result\n                    variables = inner\n                return calculate(s, end - 1, end, variables)\n        else:\n            if s[start].isdigit() or s[start] == '-':\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return int(s[start:end])\n            else:\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return variables[s[start:end]]\n\n    return calculate(expression, 0, len(expression), {})\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables) {\n    if (expression[start] == '(') {\n        if (expression.substr(start + 1, 3) == \"add\") {\n            int first = start + 5;\n            int second = first;\n            calculate(expression, first, second, variables);\n            int value1 = variables[\" \"];\n            calculate(expression, second + 1, end, variables);\n            int value2 = variables[\" \"];\n            end++;\n            return value1 + value2;\n        } else if (expression.substr(start + 1, 4) == \"mult\") {\n            int first = start + 6;\n            int second = first;\n            calculate(expression, first, second, variables);\n            int value1 = variables[\" \"];\n            calculate(expression, second + 1, end, variables);\n            int value2 = variables[\" \"];\n            end++;\n            return value1 * value2;\n        } else {\n            unordered_map<string, int> inner = unordered_map<string, int>(variables);\n            int idx = start + 5;\n            while (idx < end - 1 && expression[idx] != '(') {\n                int temp = idx;\n                idx = expression.find(' ', idx + 1);\n                string var = expression.substr(temp, idx - temp);\n                temp = idx + 1;\n                if (expression[temp] == '(') {\n                    idx++;\n                } else {\n                    idx = expression.find(' ', idx + 1);\n                }\n                int result = calculate(expression, temp, idx, variables);\n                inner[var] = result;\n                variables = inner;\n            }\n            return calculate(expression, idx, end, variables);\n        }\n    } else {\n        if (isdigit(expression[start]) || expression[start] == '-') {\n            end = expression.find(' ', start);\n            return stoi(expression.substr(start, end - start));\n        } else {\n            int idx = expression.find(' ', start);\n            end = (idx == -1) ? end : idx;\n            return variables[expression.substr(start, end - start)];\n        }\n    }\n}\n\nint evaluate(string expression) {\n    int end = expression.size();\n    unordered_map<string, int> variables;\n    int result = calculate(expression, 0, end, variables);\n    return result;\n}\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "js": "\n    ```javascript\nfunction evaluate(expression) {\n    function calculate(s, start, end, variables) {\n        if (s[start] === '(') {\n            if (s.substr(start + 1, 3) === \"add\") {\n                let first = start + 5;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 + value2;\n            } else if (s.substr(start + 1, 4) === \"mult\") {\n                let first = start + 6;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 * value2;\n            } else {\n                let inner = new Map(variables);\n                let idx = start + 5;\n                while (idx < end - 1 && s[idx] !== '(') {\n                    let temp = idx;\n                    idx = s.indexOf(' ', idx + 1);\n                    let varName = s.substring(temp, idx);\n                    temp = idx + 1;\n                    if (s[temp] === '(') {\n                        idx++;\n                    } else {\n                        idx = s.indexOf(' ', idx + 1);\n                    }\n                    let result = calculate(s, temp, idx, variables);\n                    inner.set(varName, result);\n                    variables = inner;\n                }\n                return calculate(s, end - 1, end, variables);\n            }\n        } else {\n            if (s[start] === '-' || !isNaN(s[start])) {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return parseInt(s.substring(start, end));\n            } else {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return variables.get(s.substring(start, end));\n            }\n        }\n    }\n\n    return calculate(expression, 0, expression.length, new Map());\n}\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    "
    },
    {
        "id": 102,
        "title": "Cherry Pickup",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,1,-1],[1,0,-1],[1,1,1]]",
                "output": "5"
            },
            {
                "input": "[[1,1,-1],[1,-1,1],[-1,1,1]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int cherryPickup(int[][] grid) {\n    int N = grid.length;\n    int[][][] dp = new int[N][N][N];\n    for (int[][] layer: dp)\n        for (int[] row: layer)\n            Arrays.fill(row, Integer.MIN_VALUE);\n\n    return Math.max(0, dp(0, 0, 0, grid, dp));\n}\n\npublic int dp(int r1, int c1, int c2, int[][] grid, int[][][] memo) {\n    int r2 = r1 + c1 - c2;\n    if (r1 == grid.length || r2 == grid.length || c1 == grid.length || c2 == grid.length ||\n            grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n        return Integer.MIN_VALUE;\n    } else if (r1 == grid.length - 1 && c1 == grid.length - 1) {\n        return grid[r1][c1];\n    } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {\n        return memo[r1][c1][c2];\n    } else {\n        memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);\n        int tempMax = Math.max(Math.max(dp(r1+1, c1, c2+1, grid, memo), dp(r1, c1+1, c2+1, grid, memo)),\n                        Math.max(dp(r1+1, c1, c2, grid, memo), dp(r1, c1+1, c2, grid, memo)));\n        memo[r1][c1][c2] += tempMax;\n    }\n    return memo[r1][c1][c2];\n}\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "python": "\n    ```python\ndef cherryPickup(self, grid: List[List[int]]) -> int:\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "c++": "\n    ```cpp\nint helper(vector<vector<int>>& grid, vector<vector<vector<int>>>& memo, int r1, int c1, int r2) {\n    int c2 = r1 + c1 - r2;\n    if (r1 == grid.size() || r2 == grid.size() || c1 == grid.size() || c2 == grid.size() ||\n        grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n        return INT_MIN;\n    } else if (r1 == grid.size() - 1 && c1 == grid.size() - 1) {\n        return grid[r1][c1];\n    } else if (memo[r1][c1][r2] != INT_MIN) {\n        return memo[r1][c1][r2];\n    } else {\n        memo[r1][c1][r2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);\n        int max_cherries = max(max(helper(grid, memo, r1 + 1, c1, r2 + 1), helper(grid, memo, r1, c1 + 1, r2 + 1)),\n                               max(helper(grid, memo, r1 + 1, c1, r2), helper(grid, memo, r1, c1 + 1, r2)));\n        memo[r1][c1][r2] += max_cherries;\n    }\n    return memo[r1][c1][r2];\n}\n\nint cherryPickup(vector<vector<int>>& grid) {\n    int n = grid.size();\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(n, INT_MIN)));\n    return max(0, helper(grid, memo, 0, 0, 0));\n}\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "js": "\n    ```javascript\nvar cherryPickup = function(grid) {\n    const N = grid.length;\n    const memo = new Array(N).fill(0).map(() => new Array(N).fill(0).map(() => new Array(N).fill(Number.MIN_SAFE_INTEGER)));\n\n    function dp(r1, c1, c2) {\n        const r2 = r1 + c1 - c2;\n        if (r1 === N || r2 === N || c1 === N || c2 === N || grid[r1][c1] === -1 || grid[r2][c2] === -1) {\n            return Number.MIN_SAFE_INTEGER;\n        } else if (r1 === N - 1 && c1 === N - 1) {\n            return grid[r1][c1];\n        } else if (memo[r1][c1][c2] !== Number.MIN_SAFE_INTEGER) {\n            return memo[r1][c1][c2];\n        } else {\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 !== r2 ? grid[r2][c2] : 0);\n            const tempMax = Math.max(Math.max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1)),\n                            Math.max(dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2)));\n            memo[r1][c1][c2] += tempMax;\n        }\n        return memo[r1][c1][c2];\n    }\n\n    return Math.max(0, dp(0, 0, 0));\n};\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    "
    },
    {
        "id": 103,
        "title": "Prefix and Suffix Search",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the `WordFilter` class:\n\n*   `WordFilter(string[] words)` Initializes the object with the `words` in the dictionary.\n*   `f(string pref, string suff)` Returns _the index of the word in the dictionary,_ which has the prefix `pref` and the suffix `suff`. If there is more than one valid index, return **the largest** of them. If there is no such word in the dictionary, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"WordFilter \",  \"f \"\\]\n\\[\\[\\[ \"apple \"\\]\\], \\[ \"a \",  \"e \"\\]\\]\n**Output**\n\\[null, 0\\]\n**Explanation**\nWordFilter wordFilter = new WordFilter(\\[ \"apple \"\\]);\nwordFilter.f( \"a \",  \"e \"); // return 0, because the word at index 0 has prefix =  \"a \" and suffix =  \"e \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= words[i].length <= 7`\n*   `1 <= pref.length, suff.length <= 7`\n*   `words[i]`, `pref` and `suff` consist of lowercase English letters only.\n*   At most `104` calls will be made to the function `f`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Design",
            "Trie"
        ],
        "example": [
            {
                "input": "]\n]],[\"a\",\"e\"]]",
                "output": "**Output**\n[null,0]"
            }
        ],
        "java": "\n    ```java\npublic char nextGreatestLetter(char[] letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "python": "\n    ```python\ndef next_greatest_letter(letters, target):\n    for letter in letters:\n        if letter > target:\n            return letter\n    return letters[0]\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "c++": "\n    ```cpp\nchar nextGreatestLetter(vector<char>& letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "js": "\n    ```javascript\nfunction nextGreatestLetter(letters, target) {\n    for (let letter of letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    "
    },
    {
        "id": 104,
        "title": "Contain Virus",
        "difficulty": "Hard",
        "content": {
            "problem": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used.",
            "examples": [
                "**Example 1:**\n\n**Input:** isInfected = \\[\\[0,1,0,0,0,0,0,1\\],\\[0,1,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 10\n**Explanation:** There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n \n\n",
                "**Example 2:**\n\n**Input:** isInfected = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 4\n**Explanation:** Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n",
                "**Example 3:**\n\n**Input:** isInfected = \\[\\[1,1,1,0,0,0,0,0,0\\],\\[1,0,1,0,1,1,1,1,1\\],\\[1,1,1,0,0,0,0,0,0\\]\\]\n**Output:** 13\n**Explanation:** The region on the left only builds two new walls."
            ],
            "constraints": "**Constraints:**\n\n*   `m == isInfected.length`\n*   `n == isInfected[i].length`\n*   `1 <= m, n <= 50`\n*   `isInfected[i][j]` is either `0` or `1`.\n*   There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix",
            "Simulation"
        ],
        "example": [
            {
                "input": "[[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]",
                "output": "10"
            },
            {
                "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                "output": "4"
            },
            {
                "input": "[[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]",
                "output": "13"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String shortestCompletingWord(String licensePlate, String[] words) {\n    HashMap<Character, Integer> target = new HashMap<>();\n    for (char c : licensePlate.toCharArray()) {\n        if (Character.isLetter(c)) {\n            char lower_c = Character.toLowerCase(c);\n            target.put(lower_c, target.getOrDefault(lower_c, 0) + 1);\n        }\n    }\n\n    String result = null;\n    for (String word : words) {\n        HashMap<Character, Integer> current = new HashMap<>();\n        for (char c : word.toCharArray())\n            if (Character.isLetter(c)) {\n                char lower_c = Character.toLowerCase(c);\n                current.put(lower_c, current.getOrDefault(lower_c, 0) + 1);\n            }\n\n        boolean valid = true;\n        for (char c : target.keySet()) {\n            if (current.getOrDefault(c, 0) < target.get(c)) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid && (result == null || word.length() < result.length())) result = word;\n    }\n\n    return result;\n}\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "python": "\n    ```python\ndef shortest_completing_word(license_plate, words):\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nstd::string shortestCompletingWord(std::string licensePlate, std::vector<std::string> words) {\n    std::vector<int> target(26, 0);\n    for (char c : licensePlate)\n        if (isalpha(c)) target[tolower(c) - 'a']++;\n\n    std::string result;\n    for (const std::string& word : words) {\n        std::vector<int> current(26, 0);\n        for (char c : word)\n            if (isalpha(c)) current[tolower(c) - 'a']++;\n\n        if (std::equal(target.begin(), target.end(), current.begin(), [](int a, int b){ return a <= b; }))\n            if (result.empty() || word.size() < result.size()) result = word;\n    }\n\n    return result;\n}\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "js": "\n    ```javascript\nfunction shortestCompletingWord(licensePlate, words) {\n    let target = Array(26).fill(0);\n    for (let c of licensePlate)\n        if (c.toLowerCase() != c.toUpperCase()) target[c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    let result = \"\";\n    for (let word of words) {\n        let current = Array(26).fill(0);\n        for (let c of word)\n            if (c.toLowerCase() != c.toUpperCase()) current[c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n        if (target.every((a, i) => a <= current[i]) && (result === \"\" || word.length < result.length)) result = word;\n    }\n\n    return result;\n}\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    "
    },
    {
        "id": 105,
        "title": "Cracking the Safe",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a safe protected by a password. The password is a sequence of `n` digits where each digit can be in the range `[0, k - 1]`.\n\nThe safe has a peculiar way of checking the password. When you enter in a sequence, it checks the **most recent** `n` **digits** that were entered each time you type a digit.\n\n*   For example, the correct password is `\"345 \"` and you enter in `\"012345 \"`:\n    *   After typing `0`, the most recent `3` digits is `\"0 \"`, which is incorrect.\n    *   After typing `1`, the most recent `3` digits is `\"01 \"`, which is incorrect.\n    *   After typing `2`, the most recent `3` digits is `\"012 \"`, which is incorrect.\n    *   After typing `3`, the most recent `3` digits is `\"123 \"`, which is incorrect.\n    *   After typing `4`, the most recent `3` digits is `\"234 \"`, which is incorrect.\n    *   After typing `5`, the most recent `3` digits is `\"345 \"`, which is correct and the safe unlocks.\n\nReturn _any string of **minimum length** that will unlock the safe **at some point** of entering it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1, k = 2\n**Output:**  \"10 \"\n**Explanation:** The password is a single digit, so enter each digit.  \"01 \" would also unlock the safe.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, k = 2\n**Output:**  \"01100 \"\n**Explanation:** For each possible password:\n-  \"00 \" is typed in starting from the 4th digit.\n-  \"01 \" is typed in starting from the 1st digit.\n-  \"10 \" is typed in starting from the 3rd digit.\n-  \"11 \" is typed in starting from the 2nd digit.\nThus  \"01100 \" will unlock the safe.  \"10011 \", and  \"11001 \" would also unlock the safe."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 4`\n*   `1 <= k <= 10`\n*   `1 <= kn <= 4096`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Eulerian Circuit"
        ],
        "example": [
            {
                "input": "1,2",
                "output": "\"10\""
            },
            {
                "input": "2,2",
                "output": "\"01100\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int openLock(String[] deadends, String target) {\n    Set<String> dead = new HashSet<>(Arrays.asList(deadends));\n    Set<String> visited = new HashSet<>();\n    Queue<String[]> wheelStates = new LinkedList<>();\n\n    if (dead.contains(\"0000\")) return -1;\n    wheelStates.add(new String[]{\"0000\", \"0\"});\n    visited.add(\"0000\");\n\n    while (!wheelStates.isEmpty()) {\n        String[] currentStateTurn = wheelStates.poll();\n        String currentState = currentStateTurn[0];\n        int turns = Integer.parseInt(currentStateTurn[1]);\n\n        if (currentState.equals(target)) return turns;\n\n        for (int i = 0; i < 4; ++i) {\n            char[] upStateArr = currentState.toCharArray();\n            char[] downStateArr = currentState.toCharArray();\n            upStateArr[i] = (char)(((upStateArr[i] - '0' + 1) % 10) + '0');\n            downStateArr[i] = (char)(((downStateArr[i] - '0' + 9) % 10) + '0');\n            String upState = new String(upStateArr);\n            String downState = new String(downStateArr);\n\n            if (!visited.contains(upState) && !dead.contains(upState)) {\n                wheelStates.add(new String[]{upState, String.valueOf(turns + 1)});\n                visited.add(upState);\n            }\n\n            if (!visited.contains(downState) && !dead.contains(downState)) {\n                wheelStates.add(new String[]{downState, String.valueOf(turns + 1)});\n                visited.add(downState);\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is based on a breadth-first search. We create sets for deadends and visited states, and a queue of wheel states with the number of turns for each state. If the starting state \"0000\" is in deadends, we return -1, as there is no solution. \n\nWe iterate while wheelStates is not empty. On each iteration, we check if the current state is equal to the target state, and return the number of turns if they are equal. Then, for each wheel of the state, we calculate the up state and down state by adding 1 or subtracting 1 from its position respectively (modulo 10). After that, if up_state or down_state are not visited and not in deadends, we add them to wheelStates with turns + 1. Finally, we add up_state and down_state in visited states.\n\nIf there is no solution, return -1 when the wheelStates queue becomes empty.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef openLock(deadends, target):\n    dead = set(deadends)\n    visited = set()\n    wheel_states = deque([(\"0000\", 0)])\n\n    if \"0000\" in dead:\n        return -1\n\n    while wheel_states:\n        current_state, turns = wheel_states.popleft()\n\n        if current_state == target:\n            return turns\n\n        for i in range(4):\n            up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:]\n            down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:]\n\n            if up_state not in visited and up_state not in dead:\n                wheel_states.append((up_state, turns + 1))\n                visited.add(up_state)\n\n            if down_state not in visited and down_state not in dead:\n                wheel_states.append((down_state, turns + 1))\n                visited.add(down_state)\n\n    return -1\n```\n    \n    The algorithm is based on a breadth-first search. We create sets for deadends and visited states, and a queue of wheel states with the number of turns for each state. If the starting state \"0000\" is in deadends, we return -1, as there is no solution. \n\nWe iterate while wheelStates is not empty. On each iteration, we check if the current state is equal to the target state, and return the number of turns if they are equal. Then, for each wheel of the state, we calculate the up state and down state by adding 1 or subtracting 1 from its position respectively (modulo 10). After that, if up_state or down_state are not visited and not in deadends, we add them to wheelStates with turns + 1. Finally, we add up_state and down_state in visited states.\n\nIf there is no solution, return -1 when the wheelStates queue becomes empty.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n\nint openLock(std::vector<std::string> &deadends, std::string target) {\n    std::unordered_set<std::string> dead(deadends.begin(), deadends.end());\n    std::unordered_set<std::string> visited;\n    std::queue<std::pair<std::string, int>> wheel_states;\n\n    if (dead.find(\"0000\") != dead.end()) return -1;\n    wheel_states.push({\"0000\", 0});\n    visited.insert(\"0000\");\n\n    while (!wheel_states.empty()) {\n        auto [current_state, turns] = wheel_states.front(); wheel_states.pop();\n\n        if (current_state == target) return turns;\n\n        for (int i = 0; i < 4; ++i) {\n            std::string up_state = current_state;\n            std::string down_state = current_state;\n            up_state[i] = (up_state[i] - '0' + 1) % 10 + '0';\n            down_state[i] = (down_state[i] - '0' + 9) % 10 + '0';\n\n            if (!visited.count(up_state) && !dead.count(up_state)) {\n                wheel_states.push({up_state, turns + 1});\n                visited.insert(up_state);\n            }\n\n            if (!visited.count(down_state) && !dead.count(down_state)) {\n                wheel_states.push({down_state, turns + 1});\n                visited.insert(down_state);\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is based on a breadth-first search. We create sets for deadends and visited states, and a queue of wheel states with the number of turns for each state. If the starting state \"0000\" is in deadends, we return -1, as there is no solution. \n\nWe iterate while wheelStates is not empty. On each iteration, we check if the current state is equal to the target state, and return the number of turns if they are equal. Then, for each wheel of the state, we calculate the up state and down state by adding 1 or subtracting 1 from its position respectively (modulo 10). After that, if up_state or down_state are not visited and not in deadends, we add them to wheelStates with turns + 1. Finally, we add up_state and down_state in visited states.\n\nIf there is no solution, return -1 when the wheelStates queue becomes empty.\n    ",
        "js": "\n    ```javascript\nfunction openLock(deadends, target) {\n    const dead = new Set(deadends);\n    const visited = new Set();\n    const wheelStates = [[\"0000\", 0]];\n\n    if (dead.has(\"0000\")) return -1;\n\n    while (wheelStates.length > 0) {\n        const [currentState, turns] = wheelStates.shift();\n\n        if (currentState === target) return turns;\n\n        for (let i = 0; i < 4; ++i) {\n            const upState = currentState.slice(0, i) + ((parseInt(currentState[i]) + 1) % 10).toString() + currentState.slice(i + 1);\n            const downState = currentState.slice(0, i) + ((parseInt(currentState[i]) - 1 + 10) % 10).toString() + currentState.slice(i + 1);\n\n            if (!visited.has(upState) && !dead.has(upState)) {\n                wheelStates.push([upState, turns + 1]);\n                visited.add(upState);\n            }\n\n            if (!visited.has(downState) && !dead.has(downState)) {\n                wheelStates.push([downState, turns + 1]);\n                visited.add(downState);\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is based on a breadth-first search. We create sets for deadends and visited states, and a queue of wheel states with the number of turns for each state. If the starting state \"0000\" is in deadends, we return -1, as there is no solution. \n\nWe iterate while wheelStates is not empty. On each iteration, we check if the current state is equal to the target state, and return the number of turns if they are equal. Then, for each wheel of the state, we calculate the up state and down state by adding 1 or subtracting 1 from its position respectively (modulo 10). After that, if up_state or down_state are not visited and not in deadends, we add them to wheelStates with turns + 1. Finally, we add up_state and down_state in visited states.\n\nIf there is no solution, return -1 when the wheelStates queue becomes empty.\n    "
    },
    {
        "id": 106,
        "title": "Set Intersection Size At Least Two",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents all the integers from `starti` to `endi` inclusively.\n\nA **containing set** is an array `nums` where each interval from `intervals` has **at least two** integers in `nums`.\n\n*   For example, if `intervals = [[1,3], [3,7], [8,9]]`, then `[1,2,4,7,8,9]` and `[2,3,4,8,9]` are **containing sets**.\n\nReturn _the minimum possible size of a containing set_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[3,7\\],\\[8,9\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[2, 3, 4, 8, 9\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[3,5\\]\\]\n**Output:** 3\n**Explanation:** let nums = \\[2, 3, 4\\].\nIt can be shown that there cannot be any containing array of size 2.\n\n",
                "**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[4,5\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[1, 2, 3, 4, 5\\].\nIt can be shown that there cannot be any containing array of size 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 3000`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 108`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,3],[3,7],[8,9]]",
                "output": "5"
            },
            {
                "input": "[[1,3],[1,4],[2,5],[3,5]]",
                "output": "3"
            },
            {
                "input": "[[1,2],[2,3],[2,4],[4,5]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\n    Map<String, List<Character>> mapping = new HashMap<>();\n    for (String s : allowed) {\n        String key = s.substring(0, 2);\n        if (!mapping.containsKey(key)) {\n            mapping.put(key, new ArrayList<>());\n        }\n        mapping.get(key).add(s.charAt(2));\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\npublic boolean dfs(String curr, String bottom, Map<String, List<Character>> mapping) {\n    if (bottom.length() == 1) return true;\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        if (!mapping.containsKey(bottom.substring(i, i + 2))) return false;\n    }\n    curr = \"\";\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        curr += mapping.get(bottom.substring(i, i + 2)).get(0);\n    }\n    return dfs(curr, curr, mapping);\n}\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef pyramidTransition(bottom, allowed):\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\ndef dfs(curr, bottom, mapping):\n    if len(bottom) == 1:\n        return True\n    for i in range(len(bottom) - 1):\n        if bottom[i:i+2] not in mapping:\n            return False\n    curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n    return dfs(curr, curr, mapping)\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nbool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) {\n    if (bottom.size() == 1) return true;\n\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        std::string s = bottom.substr(i, 2);\n        if (mapping.count(s) == 0) return false;\n    }\n\n    curr = \"\";\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        curr += mapping[bottom.substr(i, 2)][0];\n    }\n\n    return dfs(curr, curr, mapping);\n}\n\nbool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for (std::string& s : allowed) {\n        mapping[s.substr(0, 2)].emplace_back(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    ",
        "js": "\n    ```javascript\nfunction pyramidTransition(bottom, allowed) {\n    const mapping = {};\n    for (const s of allowed) {\n        const key = s.slice(0, 2);\n        if (!(key in mapping)) {\n            mapping[key] = [];\n        }\n        mapping[key].push(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\nfunction dfs(curr, bottom, mapping) {\n    if (bottom.length === 1) {\n        return true;\n    }\n    for (let i = 0; i < bottom.length - 1; ++i) {\n        if (!(bottom.slice(i, i + 2) in mapping)) {\n            return false;\n        }\n    }\n    curr = \"\";\n    for (let i = 0; i < bottom.length - 1; ++i) {\n        curr += mapping[bottom.slice(i, i + 2)][0];\n    }\n    return dfs(curr, curr, mapping);\n}\n```\n\n    \n    1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result.\n    "
    },
    {
        "id": 107,
        "title": "Special Binary String",
        "difficulty": "Hard",
        "content": {
            "problem": "**Special binary strings** are binary strings with the following two properties:\n\n*   The number of `0`'s is equal to the number of `1`'s.\n*   Every prefix of the binary string has at least as many `1`'s as `0`'s.\n\nYou are given a **special binary** string `s`.\n\nA move consists of choosing two consecutive, non-empty, special substrings of `s`, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\n\nReturn _the lexicographically largest resulting string possible after applying the mentioned operations on the string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"11011000 \"\n**Output:**  \"11100100 \"\n**Explanation:** The strings  \"10 \" \\[occuring at s\\[1\\]\\] and  \"1100 \" \\[at s\\[3\\]\\] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10 \"\n**Output:**  \"10 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 50`\n*   `s[i]` is either `'0'` or `'1'`.\n*   `s` is a special binary string.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"11011000\"",
                "output": "\"11100100\""
            },
            {
                "input": "\"10\"",
                "output": "\"10\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String makeLargestSpecial(String s) {\n    int count = 0;\n    int i = 0;\n    List<String> subs = new ArrayList<>();\n\n    for (int j = 0; j < s.length(); j++) {\n        if (s.charAt(j) == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.add(\"1\" + makeLargestSpecial(s.substring(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    Collections.sort(subs, Collections.reverseOrder());\n    StringBuilder res = new StringBuilder();\n    for (String sub : subs) {\n        res.append(sub);\n    }\n    return res.toString();\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "python": "\n    ```python\ndef makeLargestSpecial(s: str) -> str:\n    count, i = 0, 0\n    subs = []\n\n    for j in range(len(s)):\n        if s[j] == '1':\n            count += 1\n        else:\n            count -= 1\n\n        if count == 0:\n            subs.append(\"1\" + makeLargestSpecial(s[i+1:j]) + \"0\")\n            i = j + 1\n\n    subs.sort(reverse=True)\n    return \"\".join(subs)\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string makeLargestSpecial(std::string s) {\n    int count = 0, i = 0;\n    std::vector<std::string> subs;\n\n    for (int j = 0; j < s.size(); j++) {\n        if (s[j] == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.push_back('1' + makeLargestSpecial(s.substr(i+1, j-i-1)) + '0');\n            i = j + 1;\n        }\n    }\n\n    std::sort(subs.rbegin(), subs.rend());\n    std::string res;\n    for (const auto& sub : subs) {\n        res += sub;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "js": "\n    ```javascript\nfunction makeLargestSpecial(s) {\n    let count = 0, i = 0;\n    let subs = [];\n\n    for (let j = 0; j < s.length; j++) {\n        if (s[j] === '1') count++;\n        else count--;\n\n        if (count === 0) {\n            subs.push(\"1\" + makeLargestSpecial(s.slice(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    subs.sort((a, b) => b.localeCompare(a));\n    return subs.join('');\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    "
    },
    {
        "id": 108,
        "title": "Couples Holding Hands",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.",
            "examples": [
                "**Example 1:**\n\n**Input:** row = \\[0,2,1,3\\]\n**Output:** 1\n**Explanation:** We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person.\n\n",
                "**Example 2:**\n\n**Input:** row = \\[3,2,0,1\\]\n**Output:** 0\n**Explanation:** All couples are already seated side by side."
            ],
            "constraints": "**Constraints:**\n\n*   `2n == row.length`\n*   `2 <= n <= 30`\n*   `n` is even.\n*   `0 <= row[i] < 2n`\n*   All the elements of `row` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Greedy",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "[0,2,1,3]",
                "output": "1"
            },
            {
                "input": "[3,2,0,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minSwapsCouples(int[] row) {\n    int n = row.length;\n    int[] position = new int[n];\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            int temp = row[position[partner]];\n            row[position[partner]] = row[i + 1];\n            row[i + 1] = temp;\n            \n            temp = position[row[i + 1]];\n            position[row[i + 1]] = position[partner];\n            position[partner] = temp;\n            \n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "python": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "c++": "\n    ```cpp\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size();\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            swap(row[position[partner]], row[i + 1]);\n            swap(position[row[i + 1]], position[partner]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "js": "\n    ```javascript\nfunction minSwapsCouples(row) {\n    const n = row.length;\n    const position = new Array(n);\n    for (let i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    let swaps = 0;\n    for (let i = 0; i < n; i += 2) {\n        const partner = row[i] % 2 === 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== partner) {\n            [row[position[partner]], row[i + 1]] = [row[i + 1], row[position[partner]]];\n            [position[row[i + 1]], position[partner]] = [position[partner], position[row[i + 1]]];\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    "
    },
    {
        "id": 109,
        "title": "Max Chunks To Make Sorted II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `arr`.\n\nWe split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[5,4,3,2,1\\]\n**Output:** 1\n**Explanation:**\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into \\[5, 4\\], \\[3, 2, 1\\] will result in \\[4, 5, 1, 2, 3\\], which isn't sorted.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[2,1,3,4,4\\]\n**Output:** 4\n**Explanation:**\nWe can split into two chunks, such as \\[2, 1\\], \\[3, 4, 4\\].\nHowever, splitting into \\[2, 1\\], \\[3\\], \\[4\\], \\[4\\] is the highest number of chunks possible."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 2000`\n*   `0 <= arr[i] <= 108`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Greedy",
            "Sorting",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[5,4,3,2,1]",
                "output": "1"
            },
            {
                "input": "[2,1,3,4,4]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> partitionLabels(String s) {\n    HashMap<Character, Integer> lastPos = new HashMap<>();\n    for (int i = 0; i < s.length(); i++) {\n        lastPos.put(s.charAt(i), i);\n    }\n\n    List<Integer> partitions = new ArrayList<>();\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        end = Math.max(end, lastPos.get(s.charAt(i)));\n        if (i == end) {\n            partitions.add(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "python": "\n    ```python\ndef partition_labels(s: str) -> list[int]:\n    last_pos = {}\n    for i, c in enumerate(s):\n        last_pos[c] = i\n\n    partitions = []\n    start, end = 0, 0\n    for i, c in enumerate(s):\n        end = max(end, last_pos[c])\n        if i == end:\n            partitions.append(end - start + 1)\n            start = i + 1\n    return partitions\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> partitionLabels(const std::string& s) {\n    std::unordered_map<char, int> lastPos;\n    for (int i = 0; i < s.size(); i++) {\n        lastPos[s[i]] = i;\n    }\n\n    std::vector<int> partitions;\n    int start = 0, end = 0;\n    for (int i = 0; i < s.size(); i++) {\n        end = std::max(end, lastPos[s[i]]);\n        if (i == end) {\n            partitions.push_back(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "js": "\n    ```javascript\nfunction partitionLabels(s) {\n    const lastPos = {};\n    for (let i = 0; i < s.length; i++) {\n        lastPos[s[i]] = i;\n    }\n\n    const partitions = [];\n    let start = 0, end = 0;\n    for (let i = 0; i < s.length; i++) {\n        end = Math.max(end, lastPos[s[i]]);\n        if (i === end) {\n            partitions.push(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    "
    },
    {
        "id": 110,
        "title": "Basic Calculator IV",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an expression such as `expression = \"e + 8 - a + 5 \"` and an evaluation map such as `{ \"e \": 1}` (given in terms of `evalvars = [ \"e \"]` and `evalints = [1]`), return a list of tokens representing the simplified expression, such as `[ \"-1*a \", \"14 \"]`\n\n*   An expression alternates chunks and symbols, with a space separating each chunk and symbol.\n*   A chunk is either an expression in parentheses, a variable, or a non-negative integer.\n*   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `\"2x \"` or `\"-x \"`.\n\nExpressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.\n\n*   For example, `expression = \"1 + 2 * 3 \"` has an answer of `[ \"7 \"]`.\n\nThe format of the output is as follows:\n\n*   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.\n    *   For example, we would never write a term like `\"b*a*c \"`, only `\"a*b*c \"`.\n*   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\n    *   For example, `\"a*a*b*c \"` has degree `4`.\n*   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n*   An example of a well-formatted answer is `[ \"-2*a*a*a \", \"3*a*a*b \", \"3*b*b \", \"4*a \", \"5*c \", \"-6 \"]`.\n*   Terms (including constant terms) with coefficient `0` are not included.\n    *   For example, an expression of `\"0 \"` has an output of `[]`.\n\n**Note:** You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"e + 8 - a + 5 \", evalvars = \\[ \"e \"\\], evalints = \\[1\\]\n**Output:** \\[ \"-1\\*a \", \"14 \"\\]\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"e - 8 + temperature - pressure \", evalvars = \\[ \"e \",  \"temperature \"\\], evalints = \\[1, 12\\]\n**Output:** \\[ \"-1\\*pressure \", \"5 \"\\]\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"(e + 8) \\* (e - 8) \", evalvars = \\[\\], evalints = \\[\\]\n**Output:** \\[ \"1\\*e\\*e \", \"-64 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 250`\n*   `expression` consists of lowercase English letters, digits, `'+'`, `'-'`, `'*'`, `'('`, `')'`, `' '`.\n*   `expression` does not contain any leading or trailing spaces.\n*   All the tokens in `expression` are separated by a single space.\n*   `0 <= evalvars.length <= 100`\n*   `1 <= evalvars[i].length <= 20`\n*   `evalvars[i]` consists of lowercase English letters.\n*   `evalints.length == evalvars.length`\n*   `-100 <= evalints[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Math",
            "String",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"e+8-a+5\",[\"e\"],[1]",
                "output": "[\"-1*a\",\"14\"]"
            },
            {
                "input": "\"e-8+temperature-pressure\",[\"e\",\"temperature\"],[1,12]",
                "output": "[\"-1*pressure\",\"5\"]"
            },
            {
                "input": "\"(e+8)*(e-8)\",[],[]",
                "output": "[\"1*e*e\",\"-64\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int minSwapsCouples(int[] row) {\n    int n = row.length / 2;\n    int swaps = 0;\n    Map<Integer, Integer> position = new HashMap<>();\n\n    for (int i = 0; i < row.length; i++) {\n        position.put(row[i], i);\n    }\n\n    for (int i = 0; i < row.length; i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            int temp = row[i + 1];\n            row[i + 1] = row[position.get(couple)];\n            row[position.get(couple)] = temp;\n            position.put(temp, position.get(couple));\n            position.put(couple, i + 1);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "python": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row) // 2\n    swaps = 0\n    position = {num: i for i, num in enumerate(row)}\n\n    for i in range(0, len(row), 2):\n        couple = row[i] - 1 if row[i] % 2 else row[i] + 1\n        if row[i + 1] != couple:\n            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]\n            position[row[i + 1]], position[couple] = position[couple], i + 1\n            swaps += 1\n\n    return swaps\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size() / 2;\n    int swaps = 0;\n    unordered_map<int, int> position;\n\n    for (int i = 0; i < row.size(); i++) {\n        position[row[i]] = i;\n    }\n\n    for (int i = 0; i < row.size(); i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            swap(row[i + 1], row[position[couple]]);\n            swap(position[row[i + 1]], position[couple]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "js": "\n    ```javascript\nfunction minSwapsCouples(row) {\n    const n = row.length / 2;\n    let swaps = 0;\n    const position = {};\n\n    for (let i = 0; i < row.length; i++) {\n        position[row[i]] = i;\n    }\n\n    for (let i = 0; i < row.length; i += 2) {\n        const couple = (row[i] % 2 === 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== couple) {\n            [row[i + 1], row[position[couple]]] = [row[position[couple]], row[i + 1]];\n            [position[row[i + 1]], position[couple]] = [position[couple], i + 1];\n            swaps++;\n        }\n    }\n\n    return swaps;\n}\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    "
    },
    {
        "id": 111,
        "title": "Sliding Puzzle",
        "difficulty": "Hard",
        "content": {
            "problem": "On an `2 x 3` board, there are five tiles labeled from `1` to `5`, and an empty square represented by `0`. A **move** consists of choosing `0` and a 4-directionally adjacent number and swapping it.\n\nThe state of the board is solved if and only if the board is `[[1,2,3],[4,5,0]]`.\n\nGiven the puzzle board `board`, return _the least number of moves required so that the state of the board is solved_. If it is impossible for the state of the board to be solved, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[1,2,3\\],\\[4,0,5\\]\\]\n**Output:** 1\n**Explanation:** Swap the 0 and the 5 in one move.\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[1,2,3\\],\\[5,4,0\\]\\]\n**Output:** -1\n**Explanation:** No number of moves will make the board solved.\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\\[4,1,2\\],\\[5,0,3\\]\\]\n**Output:** 5\n**Explanation:** 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: \\[\\[4,1,2\\],\\[5,0,3\\]\\]\nAfter move 1: \\[\\[4,1,2\\],\\[0,5,3\\]\\]\nAfter move 2: \\[\\[0,1,2\\],\\[4,5,3\\]\\]\nAfter move 3: \\[\\[1,0,2\\],\\[4,5,3\\]\\]\nAfter move 4: \\[\\[1,2,0\\],\\[4,5,3\\]\\]\nAfter move 5: \\[\\[1,2,3\\],\\[4,5,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 2`\n*   `board[i].length == 3`\n*   `0 <= board[i][j] <= 5`\n*   Each value `board[i][j]` is **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Breadth-First Search",
            "Memoization",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[4,0,5]]",
                "output": "1"
            },
            {
                "input": "[[1,2,3],[5,4,0]]",
                "output": "-1"
            },
            {
                "input": "[[4,1,2],[5,0,3]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    boolean isLeaf;\n    boolean val;\n    TreeNode topLeft;\n    TreeNode topRight;\n    TreeNode bottomLeft;\n    TreeNode bottomRight;\n}\n\npublic TreeNode intersect(TreeNode quadTree1, TreeNode quadTree2) {\n    if (quadTree1.isLeaf) {\n        return quadTree1.val ? quadTree1 : quadTree2;\n    }\n    if (quadTree2.isLeaf) {\n        return quadTree2.val ? quadTree2 : quadTree1;\n    }\n\n    quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\n    quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\n    quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n    quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n\n    if (quadTree1.topLeft.isLeaf && quadTree1.topRight.isLeaf && quadTree1.bottomLeft.isLeaf && quadTree1.bottomRight.isLeaf && quadTree1.topLeft.val == quadTree1.topRight.val && quadTree1.topRight.val == quadTree1.bottomLeft.val && quadTree1.bottomLeft.val == quadTree1.bottomRight.val) {\n        quadTree1.isLeaf = true;\n        quadTree1.val = quadTree1.topLeft.val;\n    }\n\n    return quadTree1;\n}\n```\n\n    \n    The algorithm for this problem can be solved using a tree traversal approach. The base cases are when either of the quadTrees (quadTree1 or quadTree2) are leaf nodes. If either one is a leaf and has a value of 1 (true), we return that leaf. Otherwise, we return the other leaf.\n\nNext, we recursively compute the OR operation on the child nodes:\n- topLeft: quadTree1.topLeft and quadTree2.topLeft\n- topRight: quadTree1.topRight and quadTree2.topRight\n- bottomLeft: quadTree1.bottomLeft and quadTree2.bottomLeft\n- bottomRight: quadTree1.bottomRight and quadTree2.bottomRight\n\nAfter the recursion, we check if all the children are leaf nodes and have the same value. If so, we can collapse the tree into a single leaf node with that value, effectively compressing the quadtree.\n\nFinally, we return the resulting quadTree.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, isLeaf, val, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):\n        self.isLeaf = isLeaf\n        self.val = val\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\ndef intersect(quadTree1, quadTree2):    \n    if quadTree1.isLeaf:\n        return quadTree1 if quadTree1.val else quadTree2\n    if quadTree2.isLeaf:\n        return quadTree2 if quadTree2.val else quadTree1\n\n    quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft)\n    quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight)\n    quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\n    quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight)\n\n    if quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and quadTree1.topLeft.val == quadTree1.topRight.val == quadTree1.bottomLeft.val == quadTree1.bottomRight.val:\n        quadTree1.isLeaf = True\n        quadTree1.val = quadTree1.topLeft.val\n\n    return quadTree1\n```\n\n    \n    The algorithm for this problem can be solved using a tree traversal approach. The base cases are when either of the quadTrees (quadTree1 or quadTree2) are leaf nodes. If either one is a leaf and has a value of 1 (true), we return that leaf. Otherwise, we return the other leaf.\n\nNext, we recursively compute the OR operation on the child nodes:\n- topLeft: quadTree1.topLeft and quadTree2.topLeft\n- topRight: quadTree1.topRight and quadTree2.topRight\n- bottomLeft: quadTree1.bottomLeft and quadTree2.bottomLeft\n- bottomRight: quadTree1.bottomRight and quadTree2.bottomRight\n\nAfter the recursion, we check if all the children are leaf nodes and have the same value. If so, we can collapse the tree into a single leaf node with that value, effectively compressing the quadtree.\n\nFinally, we return the resulting quadTree.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    bool isLeaf;\n    bool val;\n    TreeNode* topLeft;\n    TreeNode* topRight;\n    TreeNode* bottomLeft;\n    TreeNode* bottomRight;\n};\n\nTreeNode* intersect(TreeNode* quadTree1, TreeNode* quadTree2) {\n    if (quadTree1->isLeaf) {\n        return quadTree1->val ? quadTree1 : quadTree2;\n    }\n    if (quadTree2->isLeaf) {\n        return quadTree2->val ? quadTree2 : quadTree1;\n    }\n\n    quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\n    quadTree1->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\n    quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\n    quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n\n    if (quadTree1->topLeft->isLeaf && quadTree1->topRight->isLeaf && quadTree1->bottomLeft->isLeaf && quadTree1->bottomRight->isLeaf && quadTree1->topLeft->val == quadTree1->topRight->val && quadTree1->topRight->val == quadTree1->bottomLeft->val && quadTree1->bottomLeft->val == quadTree1->bottomRight->val) {\n        quadTree1->isLeaf = true;\n        quadTree1->val = quadTree1->topLeft->val;\n        delete quadTree1->topLeft;\n        delete quadTree1->topRight;\n        delete quadTree1->bottomLeft;\n        delete quadTree1->bottomRight;\n    }\n\n    return quadTree1;\n}\n```\n\n    \n    The algorithm for this problem can be solved using a tree traversal approach. The base cases are when either of the quadTrees (quadTree1 or quadTree2) are leaf nodes. If either one is a leaf and has a value of 1 (true), we return that leaf. Otherwise, we return the other leaf.\n\nNext, we recursively compute the OR operation on the child nodes:\n- topLeft: quadTree1.topLeft and quadTree2.topLeft\n- topRight: quadTree1.topRight and quadTree2.topRight\n- bottomLeft: quadTree1.bottomLeft and quadTree2.bottomLeft\n- bottomRight: quadTree1.bottomRight and quadTree2.bottomRight\n\nAfter the recursion, we check if all the children are leaf nodes and have the same value. If so, we can collapse the tree into a single leaf node with that value, effectively compressing the quadtree.\n\nFinally, we return the resulting quadTree.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(isLeaf, val, topLeft = null, topRight = null, bottomLeft = null, bottomRight = null) {\n        this.isLeaf = isLeaf;\n        this.val = val;\n        this.topLeft = topLeft;\n        this.topRight = topRight;\n        this.bottomLeft = bottomLeft;\n        this.bottomRight = bottomRight;\n    }\n}\n\nfunction intersect(quadTree1, quadTree2) {\n    if (quadTree1.isLeaf) {\n        return quadTree1.val ? quadTree1 : quadTree2;\n    }\n    if (quadTree2.isLeaf) {\n        return quadTree2.val ? quadTree2 : quadTree1;\n    }\n\n    quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\n    quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\n    quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n    quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n\n    if (quadTree1.topLeft.isLeaf && quadTree1.topRight.isLeaf && quadTree1.bottomLeft.isLeaf && quadTree1.bottomRight.isLeaf && quadTree1.topLeft.val == quadTree1.topRight.val && quadTree1.topRight.val == quadTree1.bottomLeft.val && quadTree1.bottomLeft.val == quadTree1.bottomRight.val) {\n        quadTree1.isLeaf = true;\n        quadTree1.val = quadTree1.topLeft.val;\n    }\n\n    return quadTree1;\n}\n```\n\n    \n    The algorithm for this problem can be solved using a tree traversal approach. The base cases are when either of the quadTrees (quadTree1 or quadTree2) are leaf nodes. If either one is a leaf and has a value of 1 (true), we return that leaf. Otherwise, we return the other leaf.\n\nNext, we recursively compute the OR operation on the child nodes:\n- topLeft: quadTree1.topLeft and quadTree2.topLeft\n- topRight: quadTree1.topRight and quadTree2.topRight\n- bottomLeft: quadTree1.bottomLeft and quadTree2.bottomLeft\n- bottomRight: quadTree1.bottomRight and quadTree2.bottomRight\n\nAfter the recursion, we check if all the children are leaf nodes and have the same value. If so, we can collapse the tree into a single leaf node with that value, effectively compressing the quadtree.\n\nFinally, we return the resulting quadTree.\n    "
    },
    {
        "id": 112,
        "title": "Swim in Rising Water",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,2\\],\\[1,3\\]\\]\n**Output:** 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,1,2,3,4\\],\\[24,23,22,21,5\\],\\[12,13,14,15,16\\],\\[11,17,18,19,20\\],\\[10,9,8,7,6\\]\\]\n**Output:** 16\n**Explanation:** The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected."
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] < n2`\n*   Each value `grid[i][j]` is **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,2],[1,3]]",
                "output": "3\nExplanation:\nAttime0,youareingridlocation(0,0).\nYoucannotgoanywhereelsebecause4-directionallyadjacentneighborshaveahigherelevationthant=0.\nYoucannotreachpoint(1,1)untiltime3.\nWhenthedepthofwateris3,wecanswimanywhereinsidethegrid."
            },
            {
                "input": "[[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
                "output": "16"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.HashMap;\n\npublic String rearrangeString(String s) {\n    HashMap<Character, Integer> counts = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        counts.put(c, counts.getOrDefault(c, 0) + 1);\n    }\n    \n    PriorityQueue<Character> pq = new PriorityQueue<>((a, b) -> counts.get(b) - counts.get(a));\n    pq.addAll(counts.keySet());\n    \n    StringBuilder result = new StringBuilder();\n    Character previous = null;\n    \n    while (!pq.isEmpty()) {\n        char current = pq.remove();\n        result.append(current);\n        \n        if (previous != null && counts.get(previous) > 0) {\n            pq.add(previous);\n        }\n        \n        counts.put(current, counts.get(current) - 1);\n        previous = current;\n    }\n    \n    return result.length() == s.length() ? result.toString() : \"\";\n}\n```\n\n    \n    The algorithm uses a priority queue to store characters and their counts in descending order based on the counts. Then, it iterates over the priority queue, adding the character with the highest count to the result string. After adding a character to the result, its count is decremented. If the previously added character's count is still positive, it is added back to the priority queue.\n\nThe priority queue is used to ensure that the characters with the highest counts are placed as far apart as possible in the resultant string. If it is possible to rearrange the string, the length of the result will be equal to the length of the input string. If not, we return an empty string, as it is not possible to form a valid rearrangement.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef rearrange_string(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    \n    pq = [(-count, char) for char, count in counts.items()]\n    heapq.heapify(pq)\n    \n    result = []\n    previous = (0, '')\n    \n    while pq:\n        count, char = heapq.heappop(pq)\n        result.append(char)\n        \n        if previous[0] < 0:\n            heapq.heappush(pq, previous)\n        \n        count += 1\n        previous = (count, char)\n    \n    result_str = ''.join(result)\n    return result_str if len(result_str) == len(s) else \"\"\n```\n\n    \n    The algorithm uses a priority queue to store characters and their counts in descending order based on the counts. Then, it iterates over the priority queue, adding the character with the highest count to the result string. After adding a character to the result, its count is decremented. If the previously added character's count is still positive, it is added back to the priority queue.\n\nThe priority queue is used to ensure that the characters with the highest counts are placed as far apart as possible in the resultant string. If it is possible to rearrange the string, the length of the result will be equal to the length of the input string. If not, we return an empty string, as it is not possible to form a valid rearrangement.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n\nstd::string rearrangeString(std::string s) {\n    std::unordered_map<char, int> counts;\n    for (char c : s) {\n        counts[c]++;\n    }\n    \n    auto cmp = [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    };\n    \n    std::priority_queue<std::pair<char, int>, std::vector<std::pair<char, int>>, decltype(cmp)> pq(cmp);\n    \n    for (auto& count : counts) {\n        pq.push(count);\n    }\n    \n    std::string result;\n    std::pair<char, int> previous = {-1, 0};\n    \n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        result += current.first;\n        \n        if (previous.second > 0) {\n            pq.push(previous);\n        }\n        \n        current.second--;\n        previous = current;\n    }\n    \n    return result.size() == s.size() ? result : \"\";\n}\n```\n\n    \n    The algorithm uses a priority queue to store characters and their counts in descending order based on the counts. Then, it iterates over the priority queue, adding the character with the highest count to the result string. After adding a character to the result, its count is decremented. If the previously added character's count is still positive, it is added back to the priority queue.\n\nThe priority queue is used to ensure that the characters with the highest counts are placed as far apart as possible in the resultant string. If it is possible to rearrange the string, the length of the result will be equal to the length of the input string. If not, we return an empty string, as it is not possible to form a valid rearrangement.\n    ",
        "js": "\n    ```javascript\nfunction rearrangeString(s) {\n    const counts = new Map();\n    for (const c of s) {\n        counts.set(c, (counts.get(c) || 0) + 1);\n    }\n    \n    const pq = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);\n    \n    const result = [];\n    let previous = [-1, null];\n    \n    while (pq.length) {\n        const current = pq.shift();\n        result.push(current[0]);\n        \n        if (previous[0] > 0) {\n            pq.push(previous);\n        }\n        \n        current[1]--;\n        previous = current;\n        pq.sort((a, b) => b[1] - a[1]);\n    }\n    \n    const resultStr = result.join('');\n    return resultStr.length === s.length ? resultStr : \"\";\n}\n```\n\n    \n    The algorithm uses a priority queue to store characters and their counts in descending order based on the counts. Then, it iterates over the priority queue, adding the character with the highest count to the result string. After adding a character to the result, its count is decremented. If the previously added character's count is still positive, it is added back to the priority queue.\n\nThe priority queue is used to ensure that the characters with the highest counts are placed as far apart as possible in the resultant string. If it is possible to rearrange the string, the length of the result will be equal to the length of the input string. If not, we return an empty string, as it is not possible to form a valid rearrangement.\n    "
    },
    {
        "id": 113,
        "title": "Reaching Points",
        "difficulty": "Hard",
        "content": {
            "problem": "Given four integers `sx`, `sy`, `tx`, and `ty`, return `true` _if it is possible to convert the point_ `(sx, sy)` _to the point_ `(tx, ty)` _through some operations__, or_ `false` _otherwise_.\n\nThe allowed operation on some point `(x, y)` is to convert it to either `(x, x + y)` or `(x + y, y)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** sx = 1, sy = 1, tx = 3, ty = 5\n**Output:** true\n**Explanation:**\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\n",
                "**Example 2:**\n\n**Input:** sx = 1, sy = 1, tx = 2, ty = 2\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** sx = 1, sy = 1, tx = 1, ty = 1\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sx, sy, tx, ty <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "1,1,3,5",
                "output": "true"
            },
            {
                "input": "1,1,2,2",
                "output": "false"
            },
            {
                "input": "1,1,1,1",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic int maxChunksToSorted(int[] arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "python": "\n    ```python\ndef max_chunks_to_sorted(arr):\n    max_so_far, count = 0, 0\n    for i, val in enumerate(arr):\n        max_so_far = max(max_so_far, val)\n        if max_so_far == i:\n            count += 1\n    return count\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "c++": "\n    ```cpp\nint maxChunksToSorted(vector<int>& arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "js": "\n    ```javascript\nfunction maxChunksToSorted(arr) {\n    let max_so_far = 0, count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far === i) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    "
    },
    {
        "id": 114,
        "title": "Transform to Chessboard",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other.\n\nReturn _the minimum number of moves to transform the board into a **chessboard board**_. If the task is impossible, return `-1`.\n\nA **chessboard board** is a board where no `0`'s and no `1`'s are 4-directionally adjacent.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[1,0,0,1\\],\\[1,0,0,1\\]\\]\n**Output:** 2\n**Explanation:** One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 0\n**Explanation:** Also note that the board with 0 in the top left corner, is also a valid chessboard.\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\\[1,0\\],\\[1,0\\]\\]\n**Output:** -1\n**Explanation:** No matter what sequence of moves you make, you cannot end with a valid chessboard."
            ],
            "constraints": "**Constraints:**\n\n*   `n == board.length`\n*   `n == board[i].length`\n*   `2 <= n <= 30`\n*   `board[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Bit Manipulation",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]",
                "output": "2"
            },
            {
                "input": "[[0,1],[1,0]]",
                "output": "0"
            },
            {
                "input": "[[1,0],[1,0]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char s : stones.toCharArray()) {\n        if (jewels.indexOf(s) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "python": "\n    ```python\ndef numJewelsInStones(jewels, stones):\n    count = 0\n    for s in stones:\n        if s in jewels:\n            count += 1\n    return count\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "c++": "\n    ```cpp\nint numJewelsInStones(string jewels, string stones) {\n    int count = 0;\n    for (char s : stones) {\n        if (jewels.find(s) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "js": "\n    ```javascript\nfunction numJewelsInStones(jewels, stones) {\n    let count = 0;\n    for (let s of stones) {\n        if (jewels.includes(s)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    "
    },
    {
        "id": 115,
        "title": "Preimage Size of Factorial Zeroes Function",
        "difficulty": "Hard",
        "content": {
            "problem": "Let `f(x)` be the number of zeroes at the end of `x!`. Recall that `x! = 1 * 2 * 3 * ... * x` and by convention, `0! = 1`.\n\n*   For example, `f(3) = 0` because `3! = 6` has no zeroes at the end, while `f(11) = 2` because `11! = 39916800` has two zeroes at the end.\n\nGiven an integer `k`, return the number of non-negative integers `x` have the property that `f(x) = k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 0\n**Output:** 5\n**Explanation:** 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.\n\n",
                "**Example 2:**\n\n**Input:** k = 5\n**Output:** 0\n**Explanation:** There is no x such that x! ends in k = 5 zeroes.\n\n",
                "**Example 3:**\n\n**Input:** k = 3\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= k <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "0",
                "output": "5"
            },
            {
                "input": "5",
                "output": "0"
            },
            {
                "input": "3",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic boolean canTransform(String start, String end) {\n    if (start.length() != end.length()) return false;\n\n    int i = 0, j = 0;\n    int n = start.length();\n    while (i < n && j < n) {\n        while (i < n && start.charAt(i) == 'X') i++;\n        while (j < n && end.charAt(j) == 'X') j++;\n\n        if (start.charAt(i) != end.charAt(j)) return false;\n\n        if ((start.charAt(i) == 'R' && i > j) || (start.charAt(i) == 'L' && i < j)) return false;\n\n        i++; j++;\n    }\n    return true;\n}\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "python": "\n    ```python\ndef canTransform(start: str, end: str) -> bool:\n    if len(start) != len(end): return False\n\n    i, j = 0, 0\n    n = len(start)\n    while i < n and j < n:\n        while i < n and start[i] == 'X': i += 1\n        while j < n and end[j] == 'X': j += 1\n\n        if start[i] != end[j]: return False\n\n        if (start[i] == 'R' and i > j) or (start[i] == 'L' and i < j): return False\n\n        i += 1; j += 1\n    return True\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "c++": "\n    ```cpp\nbool canTransform(string start, string end) {\n    if (start.size() != end.size()) return false;\n\n    int i = 0, j = 0;\n    int n = start.size();\n    while (i < n && j < n) {\n        while (i < n && start[i] == 'X') i++;\n        while (j < n && end[j] == 'X') j++;\n\n        if (start[i] != end[j]) return false;\n\n        if ((start[i] == 'R' && i > j) || (start[i] == 'L' && i < j)) return false;\n\n        i++; j++;\n    }\n    return true;\n}\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "js": "\n    ```javascript\nfunction canTransform(start, end) {\n    if (start.length !== end.length) return false;\n\n    let i = 0, j = 0;\n    const n = start.length;\n    while (i < n && j < n) {\n        while (i < n && start[i] === 'X') i++;\n        while (j < n && end[j] === 'X') j++;\n\n        if (start[i] !== end[j]) return false;\n\n        if ((start[i] === 'R' && i > j) || (start[i] === 'L' && i < j)) return false;\n\n        i++; j++;\n    }\n    return true;\n}\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    "
    },
    {
        "id": 116,
        "title": "Smallest Rotation with Highest Score",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums`. You can rotate it by a non-negative integer `k` so that the array becomes `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]`. Afterward, any entries that are less than or equal to their index are worth one point.\n\n*   For example, if we have `nums = [2,4,1,3,0]`, and we rotate by `k = 2`, it becomes `[1,3,0,2,4]`. This is worth `3` points because `1 > 0` \\[no points\\], `3 > 1` \\[no points\\], `0 <= 2` \\[one point\\], `2 <= 3` \\[one point\\], `4 <= 4` \\[one point\\].\n\nReturn _the rotation index_ `k` _that corresponds to the highest score we can achieve if we rotated_ `nums` _by it_. If there are multiple answers, return the smallest such index `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,1,4,0\\]\n**Output:** 3\n**Explanation:** Scores for each k are listed below: \nk = 0,  nums = \\[2,3,1,4,0\\],    score 2\nk = 1,  nums = \\[3,1,4,0,2\\],    score 3\nk = 2,  nums = \\[1,4,0,2,3\\],    score 3\nk = 3,  nums = \\[4,0,2,3,1\\],    score 4\nk = 4,  nums = \\[0,2,3,1,4\\],    score 3\nSo we should choose k = 3, which has the highest score.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,0,2,4\\]\n**Output:** 0\n**Explanation:** nums will always have 3 points no matter how it shifts.\nSo we will choose the smallest k, which is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] < nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,3,1,4,0]",
                "output": "3"
            },
            {
                "input": "[1,3,0,2,4]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int movesToChessboard(int[][] board) {\n    int N = board.length;\n    int row = 0, col = 0, rowCount = 0, colCount = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (((board[0][0] ^ board[i][0] ^ board[0][j]) ^ board[i][j]) != 0) return -1;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        row ^= board[0][i];\n        col ^= board[i][0];\n        rowCount += board[0][i] == 1 ? 1 : 0;\n        colCount += board[i][0] == 1 ? 1 : 0;\n    }\n\n    if (row != 0 && rowCount * 2 != N) return -1;\n    if (col != 0 && colCount * 2 != N) return -1;\n\n    if (N % 2 == 1) {\n        if (rowCount % 2 == 1) rowCount = N - rowCount;\n        if (colCount % 2 == 1) colCount = N - colCount;\n    } else {\n        rowCount = Math.min(rowCount, N - rowCount);\n        colCount = Math.min(colCount, N - colCount);\n    }\n\n    return (rowCount + colCount) / 2;\n}\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "python": "\n    ```python\ndef moves_to_chessboard(board):\n    N = len(board)\n    row, col = 0, 0\n    row_count, col_count = 0, 0\n\n    for i in range(N):\n        for j in range(N):\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0:\n                return -1\n\n    for i in range(N):\n        row ^= board[0][i]\n        col ^= board[i][0]\n        row_count += 1 if board[0][i] == 1 else 0\n        col_count += 1 if board[i][0] == 1 else 0\n\n    if row != 0 and row_count * 2 != N:\n        return -1\n    if col != 0 and col_count * 2 != N:\n        return -1\n\n    if N % 2 == 1:\n        if row_count % 2 == 1:\n            row_count = N - row_count\n        if col_count % 2 == 1:\n            col_count = N - col_count\n    else:\n        row_count = min(row_count, N - row_count)\n        col_count = min(col_count, N - col_count)\n\n    return (row_count + col_count) // 2\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "c++": "\n    ```cpp\n#include <bitset>\n#include <vector>\n\nint movesToChessboard(std::vector<std::vector<int>>& board) {\n  int N = board.size();\n  std::bitset<30> row, col;\n\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < N; ++j)\n      if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j])\n        return -1;\n\n  for (int i = 0; i < N; ++i) {\n    row.flip(i);\n    col.flip(i);\n  }\n\n  int c = board[0] & col;\n  int d = row.count() - row.count() & col;\n  int max_count = max(c, d);\n\n  if (max_count == N) return 0;\n\n  if (N & 1) return max_count & 1 ? max_count / 2 : max_count / 2 + 1;\n  else return max_count / 2;\n}\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "js": "\n    ```javascript\nfunction movesToChessboard(board) {\n  const N = board.length;\n  let row = 0, col = 0, rowCount = 0, colCount = 0;\n\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      if (((board[0][0] ^ board[i][0] ^ board[0][j]) ^ board[i][j]) !== 0) return -1;\n    }\n  }\n\n  for (let i = 0; i < N; i++) {\n    row ^= board[0][i];\n    col ^= board[i][0];\n    rowCount += board[0][i] === 1 ? 1 : 0;\n    colCount += board[i][0] === 1 ? 1 : 0;\n  }\n\n  if (row !== 0 && rowCount * 2 !== N) return -1;\n  if (col !== 0 && colCount * 2 !== N) return -1;\n\n  if (N % 2 === 1) {\n    if (rowCount % 2 === 1) rowCount = N - rowCount;\n    if (colCount % 2 === 1) colCount = N - colCount;\n  } else {\n    rowCount = Math.min(rowCount, N - rowCount);\n    colCount = Math.min(colCount, N - colCount);\n  }\n\n  return (rowCount + colCount) / 2;\n}\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    "
    },
    {
        "id": 117,
        "title": "Minimum Swaps To Make Sequences Increasing",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integer arrays of the same length `nums1` and `nums2`. In one operation, you are allowed to swap `nums1[i]` with `nums2[i]`.\n\n*   For example, if `nums1 = [1,2,3,8]`, and `nums2 = [5,6,7,4]`, you can swap the element at `i = 3` to obtain `nums1 = [1,2,3,4]` and `nums2 = [5,6,7,8]`.\n\nReturn _the minimum number of needed operations to make_ `nums1` _and_ `nums2` _**strictly increasing**_. The test cases are generated so that the given input always makes it possible.\n\nAn array `arr` is **strictly increasing** if and only if `arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,3,5,4\\], nums2 = \\[1,2,3,7\\]\n**Output:** 1\n**Explanation:** \nSwap nums1\\[3\\] and nums2\\[3\\]. Then the sequences are:\nnums1 = \\[1, 3, 5, 7\\] and nums2 = \\[1, 2, 3, 4\\]\nwhich are both strictly increasing.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[0,3,5,8,9\\], nums2 = \\[2,1,4,6,9\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums1.length <= 105`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 2 * 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,3,5,4],[1,2,3,7]",
                "output": "1"
            },
            {
                "input": "[0,3,5,8,9],[2,1,4,6,9]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic boolean isBipartite(int[][] graph) {\n    int[] colors = new int[graph.length];\n    for(int i = 0; i < graph.length; i++){\n        if(colors[i] != 0) continue;\n        colors[i] = 1;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(i);\n        while(!queue.isEmpty()){\n            int node = queue.poll();\n            for(int neighbor : graph[node]){\n                if(colors[neighbor] == 0){\n                    colors[neighbor] = -colors[node];\n                    queue.offer(neighbor);\n                } else if(colors[neighbor] == colors[node]){\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef isBipartite(graph):\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n    return True\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nbool isBipartite(std::vector<std::vector<int>>& graph) {\n    std::vector<int> colors(graph.size(), 0);\n    for(int i = 0; i < graph.size(); i++){\n        if(colors[i] != 0) continue;\n        colors[i] = 1;\n        std::queue<int> q;\n        q.push(i);\n        while(!q.empty()){\n            int node = q.front(); q.pop();\n            for(int neighbor : graph[node]){\n                if(colors[neighbor] == 0){\n                    colors[neighbor] = -colors[node];\n                    q.push(neighbor);\n                } else if(colors[neighbor] == colors[node]){\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    ",
        "js": "\n    ```javascript\nfunction isBipartite(graph) {\n    const colors = new Array(graph.length).fill(0);\n    for(let i = 0; i < graph.length; i++){\n        if(colors[i] !== 0) continue;\n        colors[i] = 1;\n        const queue = [i];\n        while(queue.length){\n            const node = queue.shift();\n            for(const neighbor of graph[node]){\n                if(colors[neighbor] === 0){\n                    colors[neighbor] = -colors[node];\n                    queue.push(neighbor);\n                } else if(colors[neighbor] === colors[node]){\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    We can approach this problem as graph traversal. First, we initialize a colors array of size n, filling it with 0. We can think of 0 as \"not visited\" and use 1 and -1 as the two different colors for the nodes.\n\nFor each uncolored node, we assign color 1 to it and put it into a queue. Then, we use Breadth First Search (BFS) by dequeuing a node, checking its neighbors, and performing the following - if a neighbor is uncolored (0), assign it the opposite color of the current node and enqueue it. If the neighbor's color is the same as the current node, return false, as the graph is not bipartite. Repeat this process until the queue is empty. If the loop ends without finding conflict, return true, since the graph is bipartite.\n\nThis algorithm works because a bipartite graph can be colored in such a way that no adjacent nodes have the same color. Using BFS ensures that we check all connected components of the graph (as there can be several disjoint subsets in the graph).\n    "
    },
    {
        "id": 118,
        "title": "Bricks Falling When Hit",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` binary `grid`, where each `1` represents a brick and `0` represents an empty space. A brick is **stable** if:\n\n*   It is directly connected to the top of the grid, or\n*   At least one other brick in its four adjacent cells is **stable**.\n\nYou are also given an array `hits`, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location `hits[i] = (rowi, coli)`. The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will **fall**. Once a brick falls, it is **immediately** erased from the `grid` (i.e., it does not land on other stable bricks).\n\nReturn _an array_ `result`_, where each_ `result[i]` _is the number of bricks that will **fall** after the_ `ith` _erasure is applied._\n\n**Note** that an erasure may refer to a location with no brick, and if it does, no bricks drop.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[1,1,1,0\\]\\], hits = \\[\\[1,0\\]\\]\n**Output:** \\[2\\]\n**Explanation:** Starting with the grid:\n\\[\\[1,0,0,0\\],\n \\[1,1,1,0\\]\\]\nWe erase the underlined brick at (1,0), resulting in the grid:\n\\[\\[1,0,0,0\\],\n \\[0,1,1,0\\]\\]\nThe two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n\\[\\[1,0,0,0\\],\n \\[0,0,0,0\\]\\]\nHence the result is \\[2\\].\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[1,1,0,0\\]\\], hits = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** \\[0,0\\]\n**Explanation:** Starting with the grid:\n\\[\\[1,0,0,0\\],\n \\[1,1,0,0\\]\\]\nWe erase the underlined brick at (1,1), resulting in the grid:\n\\[\\[1,0,0,0\\],\n \\[1,0,0,0\\]\\]\nAll remaining bricks are still stable, so no bricks fall. The grid remains the same:\n\\[\\[1,0,0,0\\],\n \\[1,0,0,0\\]\\]\nNext, we erase the underlined brick at (1,0), resulting in the grid:\n\\[\\[1,0,0,0\\],\n \\[0,0,0,0\\]\\]\nOnce again, all remaining bricks are still stable, so no bricks fall.\nHence the result is \\[0,0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is `0` or `1`.\n*   `1 <= hits.length <= 4 * 104`\n*   `hits[i].length == 2`\n*   `0 <= xi <= m - 1`\n*   `0 <= yi <= n - 1`\n*   All `(xi, yi)` are unique.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Union Find",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,0,0,0],[1,1,1,0]],[[1,0]]",
                "output": "[2]"
            },
            {
                "input": "[[1,0,0,0],[1,1,0,0]],[[1,1],[1,0]]",
                "output": "[0,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n    List<List<int[]>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++)\n        graph.add(new ArrayList<>());\n    for (int[] flight : flights)\n        graph.get(flight[0]).add(new int[]{ flight[1], flight[2] });\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    pq.offer(new int[]{0, src, k + 1});\n    \n    while (!pq.isEmpty()) {\n        int[] info = pq.poll();\n        int price = info[0], city = info[1], stops = info[2];\n        \n        if (city == dst)\n            return price;\n        \n        if (stops > 0) {\n            for (int[] neighbor : graph.get(city))\n                pq.offer(new int[]{ price + neighbor[1], neighbor[0], stops - 1 });\n        }\n    }\n\n    return -1;\n}\n```\n\n    \n    1. Create an adjacency list called `graph` to represent the flights’ connections.\n2. Create a min-heap(priority queue) `pq`, and add the starting city `src` with a price of 0, and stops equal to `k+1`.\n3. While the priority queue is not empty, do the following:\n   - Pop the next item(price, city, stops) from `pq`.\n   - If the city is the destination `dst`, return the price.\n   - If there are stops remaining, iterate through neighbors, push the neighbor city with an updated price and decreased stops to the priority queue.\n4. If the loop finishes and no valid route was found, return -1.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef findCheapestPrice(n, flights, src, dst, k):\n    graph = [[] for _ in range(n)]\n    for flight in flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n\n    pq = [(0, src, k + 1)]\n    while pq:\n        price, city, stops = heapq.heappop(pq)\n\n        if city == dst:\n            return price\n\n        if stops > 0:\n            for nei, prc in graph[city]:\n                heapq.heappush(pq, (price + prc, nei, stops - 1))\n\n    return -1\n```\n\n    \n    1. Create an adjacency list called `graph` to represent the flights’ connections.\n2. Create a min-heap(priority queue) `pq`, and add the starting city `src` with a price of 0, and stops equal to `k+1`.\n3. While the priority queue is not empty, do the following:\n   - Pop the next item(price, city, stops) from `pq`.\n   - If the city is the destination `dst`, return the price.\n   - If there are stops remaining, iterate through neighbors, push the neighbor city with an updated price and decreased stops to the priority queue.\n4. If the loop finishes and no valid route was found, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n    vector<vector<pair<int, int>>> graph(n);\n    for (auto& flight : flights)\n        graph[flight[0]].push_back({flight[1], flight[2]});\n        \n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\n    pq.push({0, src, k + 1});\n    \n    while (!pq.empty()) {\n        auto info = pq.top(); pq.pop();\n        int price = info[0], city = info[1], stops = info[2];\n        \n        if (city == dst)\n            return price;\n        \n        if (stops > 0) {\n            for (auto& p : graph[city])\n                pq.push({price + p.second, p.first, stops - 1});\n        }\n    }\n    \n    return -1;\n}\n```\n\n    \n    1. Create an adjacency list called `graph` to represent the flights’ connections.\n2. Create a min-heap(priority queue) `pq`, and add the starting city `src` with a price of 0, and stops equal to `k+1`.\n3. While the priority queue is not empty, do the following:\n   - Pop the next item(price, city, stops) from `pq`.\n   - If the city is the destination `dst`, return the price.\n   - If there are stops remaining, iterate through neighbors, push the neighbor city with an updated price and decreased stops to the priority queue.\n4. If the loop finishes and no valid route was found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findCheapestPrice(n, flights, src, dst, k) {\n    const graph = Array.from({ length: n }, () => []);\n    for (const flight of flights) {\n        graph[flight[0]].push([flight[1], flight[2]]);\n    }\n\n    const pq = [[0, src, k + 1]];\n    while (pq.length) {\n        pq.sort((a, b) => a[0] - b[0]);\n        const [price, city, stops] = pq.shift();\n\n        if (city === dst) {\n            return price;\n        }\n\n        if (stops > 0) {\n            for (const [nei, prc] of graph[city]) {\n                pq.push([price + prc, nei, stops - 1]);\n            }\n        }\n    }\n\n    return -1;\n}\n```\n\n    \n    1. Create an adjacency list called `graph` to represent the flights’ connections.\n2. Create a min-heap(priority queue) `pq`, and add the starting city `src` with a price of 0, and stops equal to `k+1`.\n3. While the priority queue is not empty, do the following:\n   - Pop the next item(price, city, stops) from `pq`.\n   - If the city is the destination `dst`, return the price.\n   - If there are stops remaining, iterate through neighbors, push the neighbor city with an updated price and decreased stops to the priority queue.\n4. If the loop finishes and no valid route was found, return -1.\n    "
    },
    {
        "id": 119,
        "title": "Split Array With Same Average",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\n**Note** that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8\\]\n**Output:** true\n**Explanation:** We can split the array into \\[1,4,5,8\\] and \\[2,3,6,7\\], and both of them have an average of 4.5.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,1\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 30`\n*   `0 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5,6,7,8]",
                "output": "true"
            },
            {
                "input": "[3,1]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Solution {\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\n        int maxDist = Math.abs(target[0]) + Math.abs(target[1]);\n        for (int[] ghost : ghosts) {\n            int ghostDist = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);\n            if (ghostDist <= maxDist) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:\n    max_dist = abs(target[0]) + abs(target[1])\n    for ghost in ghosts:\n        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])\n        if ghost_dist <= max_dist:\n            return False\n    return True\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool escapeGhosts(std::vector<std::vector<int>>& ghosts, std::vector<int>& target) {\n    int max_dist = std::abs(target[0]) + std::abs(target[1]);\n    for (const auto& ghost : ghosts) {\n        int ghost_dist = std::abs(ghost[0] - target[0]) + std::abs(ghost[1] - target[1]);\n        if (ghost_dist <= max_dist) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    ",
        "js": "\n    ```javascript\nfunction escapeGhosts(ghosts, target) {\n    let maxDist = Math.abs(target[0]) + Math.abs(target[1]);\n    for (let ghost of ghosts) {\n        let ghostDist = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);\n        if (ghostDist <= maxDist) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The PAC-MAN's shortest path to the target is moving diagonally, so it takes |xtarget| + |ytarget| steps to reach the target. The algorithm calculates this optimal distance to the target and checks whether it is smaller than the distance from every ghost to the target. If the PAC-MAN can reach the target with fewer moves than any ghost, it is possible to escape. Otherwise, if any ghost is closer to the target than PAC-MAN, it is impossible to reach the target before being caught.\n\nThe algorithm is based on the Manhattan distance, which calculates the sum of the absolute differences of the coordinates. Using Manhattan distance ensures that we are only considering the minimum number of moves required to reach the target, disregarding any possible extra moves taken during the game.\n    "
    },
    {
        "id": 120,
        "title": "Chalkboard XOR Game",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `nums` represents the numbers written on a chalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become `0`, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is `0`.\n\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to `0`, then that player wins.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** false\n**Explanation:** \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes \\[1, 2\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums become \\[1, 1\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < 216`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Bit Manipulation",
            "Brainteaser",
            "Game Theory"
        ],
        "example": [
            {
                "input": "[1,1,2]",
                "output": "false"
            },
            {
                "input": "[0,1]",
                "output": "true"
            },
            {
                "input": "[1,2,3]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean validTicTacToe(String[] board) {\n    int xCount = 0, oCount = 0;\n    for (String row : board) {\n        for (char c : row.toCharArray()) {\n            if (c == 'X') xCount++;\n            else if (c == 'O') oCount++;\n        }\n    }\n    if (xCount != oCount && xCount != oCount + 1) return false;\n\n    boolean xWin = false, oWin = false;\n    for (int i = 0; i < 3; ++i) {\n        if (board[i].charAt(0) == board[i].charAt(1) && board[i].charAt(1) == board[i].charAt(2))\n            xWin = board[i].charAt(0) == 'X' ? true : (board[i].charAt(0) == 'O' ? oWin = true : oWin);\n        if (board[0].charAt(i) == board[1].charAt(i) && board[1].charAt(i) == board[2].charAt(i))\n            xWin = board[0].charAt(i) == 'X' ? true : (board[0].charAt(i) == 'O' ? oWin = true : oWin);\n    }\n    if (board[0].charAt(0) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(2))\n        xWin = board[0].charAt(0) == 'X' ? true : (board[0].charAt(0) == 'O' ? oWin = true : oWin);\n    if (board[0].charAt(2) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(0))\n        xWin = board[0].charAt(2) == 'X' ? true : (board[0].charAt(2) == 'O' ? oWin = true : oWin);\n\n    if (xWin && oWin) return false;\n    if (xWin && xCount == oCount) return false;\n    if (oWin && xCount > oCount) return false;\n\n    return true;\n}\n```\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "python": "\n    ```python\ndef valid_tic_tac_toe(board: List[str]) -> bool:\n    x_count = sum(row.count('X') for row in board)\n    o_count = sum(row.count('O') for row in board)\n    if x_count != o_count and x_count != o_count + 1: return False\n\n    x_win, o_win = False, False\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] != ' ':\n            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)\n        if board[0][i] == board[1][i] == board[2][i] != ' ':\n            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)\n    if board[0][0] == board[1][1] == board[2][2] != ' ':\n        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)\n    if board[0][2] == board[1][1] == board[2][0] != ' ':\n        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)\n\n    if x_win and o_win: return False\n    if x_win and x_count == o_count: return False\n    if o_win and x_count > o_count: return False\n\n    return True\n```\n\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "c++": "\n    ```cpp\nbool validTicTacToe(std::vector<std::string> &board) {\n    int xCount = 0, oCount = 0;\n    for (const std::string& row : board) {\n        for (char c : row) {\n            if (c == 'X') xCount++;\n            else if (c == 'O') oCount++;\n        }\n    }\n    if (xCount != oCount && xCount != oCount + 1) return false;\n\n    bool xWin = false, oWin = false;\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            board[i][0] == 'X' ? xWin = true : (board[i][0] == 'O' ? oWin = true : 0);\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            board[0][i] == 'X' ? xWin = true : (board[0][i] == 'O' ? oWin = true : 0);\n    }\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        board[0][0] == 'X' ? xWin = true : (board[0][0] == 'O' ? oWin = true : 0);\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0])\n        board[0][2] == 'X' ? xWin = true : (board[0][2] == 'O' ? oWin = true : 0);\n    \n    if (xWin && oWin) return false;\n    if (xWin && xCount == oCount) return false;\n    if (oWin && xCount > oCount) return false;\n\n    return true;\n}\n```\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "js": "\n    ```javascript\nfunction validTicTacToe(board) {\n    let xCount = 0, oCount = 0;\n    for (const row of board) {\n        for (const c of row) {\n            if (c === 'X') xCount++;\n            else if (c === 'O') oCount++;\n        }\n    }\n    if (xCount !== oCount && xCount !== oCount + 1) return false;\n\n    let xWin = false, oWin = false;\n    for (let i = 0; i < 3; ++i) {\n        if (board[i][0] === board[i][1] && board[i][1] === board[i][2])\n            board[i][0] === 'X' ? xWin = true : (board[i][0] === 'O' ? oWin = true : 0);\n        if (board[0][i] === board[1][i] && board[1][i] === board[2][i])\n            board[0][i] === 'X' ? xWin = true : (board[0][i] === 'O' ? oWin = true : 0);\n    }\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2])\n        board[0][0] === 'X' ? xWin = true : (board[0][0] === 'O' ? oWin = true : 0);\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0])\n        board[0][2] === 'X' ? xWin = true : (board[0][2] === 'O' ? oWin = true : 0);\n\n    if (xWin && oWin) return false;\n    if (xWin && xCount === oCount) return false;\n    if (oWin && xCount > oCount) return false;\n\n    return true;\n}\n```\n\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    "
    },
    {
        "id": 121,
        "title": "Bus Routes",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.\n\n*   For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n\nYou will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.\n\nReturn _the least number of buses you must take to travel from_ `source` _to_ `target`. Return `-1` if it is not possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** routes = \\[\\[1,2,7\\],\\[3,6,7\\]\\], source = 1, target = 6\n**Output:** 2\n**Explanation:** The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n\n",
                "**Example 2:**\n\n**Input:** routes = \\[\\[7,12\\],\\[4,5,15\\],\\[6\\],\\[15,19\\],\\[9,12,13\\]\\], source = 15, target = 12\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= routes.length <= 500`.\n*   `1 <= routes[i].length <= 105`\n*   All the values of `routes[i]` are **unique**.\n*   `sum(routes[i].length) <= 105`\n*   `0 <= routes[i][j] < 106`\n*   `0 <= source, target < 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "[[1,2,7],[3,6,7]],1,6",
                "output": "2"
            },
            {
                "input": "[[7,12],[4,5,15],[6],[15,19],[9,12,13]],15,12",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int numBusesToDestination(int[][] routes, int source, int target) {\n    if (source == target) return 0;\n\n    Map<Integer, Set<Integer>> stopRouteMap = new HashMap<>();\n    for (int i = 0; i < routes.length; i++) {\n        for (int stop : routes[i]) {\n            stopRouteMap.computeIfAbsent(stop, x -> new HashSet<>()).add(i);\n        }\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    Set<Integer> visitedSources = new HashSet<>();\n\n    queue.offer(source);\n    visitedSources.add(source);\n    int transfers = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        while (size-- > 0) {\n            int curr = queue.poll(); // Pop from the queue.\n            if (curr == target) return transfers;\n\n            for (int route : stopRouteMap.get(curr)) {\n                for (int stop : routes[route]) {\n                    if (!visitedSources.contains(stop)) {\n                        queue.offer(stop);\n                        visitedSources.add(stop);\n                    }\n                }\n                // Remove the route from the stop.\n                stopRouteMap.get(curr).remove(route);\n            }\n        }\n        transfers++;\n    }\n    return -1;\n}\n```\n    \n    The algorithm begins by recording the bus routes in which each bus stop (source or target) is connected. A Breadth First Search (BFS) algorithm is then employed to identify the shortest path by exploring the bus routes that pass through source and target sequentially. The bfs algorithm captures the number of buses traversed and keeps track of visited stops to prevent revisiting. Upon reaching the destination or exhausting all possible routes without reaching the destination, the algorithm returns the minimum number of buses traversed or -1, respectively.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef numBusesToDestination(routes, source, target):\n    if source == target:\n        return 0\n\n    stop_route_map = defaultdict(set)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_route_map[stop].add(i)\n\n    queue = deque([source])\n    visited_sources = {source}\n\n    transfers = 0\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            curr = queue.popleft()\n            if curr == target:\n                return transfers\n\n            for route in stop_route_map[curr]:\n                for stop in routes[route]:\n                    if stop not in visited_sources:\n                        queue.append(stop)\n                        visited_sources.add(stop)\n                stop_route_map[curr].remove(route)\n        transfers += 1\n    return -1\n```\n    \n    The algorithm begins by recording the bus routes in which each bus stop (source or target) is connected. A Breadth First Search (BFS) algorithm is then employed to identify the shortest path by exploring the bus routes that pass through source and target sequentially. The bfs algorithm captures the number of buses traversed and keeps track of visited stops to prevent revisiting. Upon reaching the destination or exhausting all possible routes without reaching the destination, the algorithm returns the minimum number of buses traversed or -1, respectively.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <queue>\n\nint numBusesToDestination(std::vector<std::vector<int>>& routes, int source, int target) {\n    if (source == target) return 0;\n\n    std::unordered_map<int, std::unordered_set<int>> stop_route_map;\n    for (int i = 0; i < routes.size(); ++i) {\n        for (int stop : routes[i]) {\n            stop_route_map[stop].insert(i);\n        }\n    }\n\n    std::queue<int> q;\n    std::unordered_set<int> visited_sources;\n\n    q.push(source);\n    visited_sources.insert(source);\n    int transfers = 0;\n\n    while (!q.empty()) {\n        int size = q.size();\n        while (size--) {\n            int curr = q.front();\n            q.pop();\n            if (curr == target) return transfers;\n\n            for (int route : stop_route_map[curr]) {\n                for (int stop : routes[route]) {\n                    if (visited_sources.count(stop) == 0) {\n                        q.push(stop);\n                        visited_sources.insert(stop);\n                    }\n                }\n                stop_route_map[curr].erase(route);\n            }\n        }\n        transfers++;\n    }\n    return -1;\n}\n```\n    \n    The algorithm begins by recording the bus routes in which each bus stop (source or target) is connected. A Breadth First Search (BFS) algorithm is then employed to identify the shortest path by exploring the bus routes that pass through source and target sequentially. The bfs algorithm captures the number of buses traversed and keeps track of visited stops to prevent revisiting. Upon reaching the destination or exhausting all possible routes without reaching the destination, the algorithm returns the minimum number of buses traversed or -1, respectively.\n    ",
        "js": "\n    ```javascript\nfunction numBusesToDestination(routes, source, target) {\n    if (source === target) return 0;\n\n    const stopRouteMap = new Map();\n    for (let i = 0; i < routes.length; i++) {\n        for (const stop of routes[i]) {\n            if (!stopRouteMap.has(stop)) {\n                stopRouteMap.set(stop, new Set());\n            }\n            stopRouteMap.get(stop).add(i);\n        }\n    }\n\n    const queue = [source];\n    const visitedSources = new Set([source]);\n    let transfers = 0;\n\n    while (queue.length) {\n        const size = queue.length;\n        for (let i = 0; i < size; i++) {\n            const curr = queue.shift();\n            if (curr === target) return transfers;\n\n            for (const route of stopRouteMap.get(curr)) {\n                for (const stop of routes[route]) {\n                    if (!visitedSources.has(stop)) {\n                        queue.push(stop);\n                        visitedSources.add(stop);\n                    }\n                }\n                stopRouteMap.get(curr).delete(route);\n            }\n        }\n        transfers++;\n    }\n    return -1;\n}\n```\n    \n    The algorithm begins by recording the bus routes in which each bus stop (source or target) is connected. A Breadth First Search (BFS) algorithm is then employed to identify the shortest path by exploring the bus routes that pass through source and target sequentially. The bfs algorithm captures the number of buses traversed and keeps track of visited stops to prevent revisiting. Upon reaching the destination or exhausting all possible routes without reaching the destination, the algorithm returns the minimum number of buses traversed or -1, respectively.\n    "
    },
    {
        "id": 122,
        "title": "Race Car",
        "difficulty": "Hard",
        "content": {
            "problem": "Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'` (reverse):\n\n*   When you get an instruction `'A'`, your car does the following:\n    *   `position += speed`\n    *   `speed *= 2`\n*   When you get an instruction `'R'`, your car does the following:\n    *   If your speed is positive then `speed = -1`\n    *   otherwise `speed = 1`Your position stays the same.\n\nFor example, after commands `\"AAR \"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target`, return _the length of the shortest sequence of instructions to get there_.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:** \nThe shortest instruction sequence is  \"AA \".\nYour position goes from 0 --> 1 --> 3.\n\n",
                "**Example 2:**\n\n**Input:** target = 6\n**Output:** 5\n**Explanation:** \nThe shortest instruction sequence is  \"AAARA \".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target <= 104`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "3",
                "output": "2"
            },
            {
                "input": "6",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int racecar(int target) {\n    return dp(0, 1, target, new HashMap<>());\n}\n\nprivate int dp(int position, int speed, int target, Map<String, Integer> memo) {\n    if (Math.abs(position) > 2 * target) {\n        return target + 1;\n    }\n    if (position == target) {\n        return speed == 1 ? 0 : 1;\n    }\n    String key = position + \",\" + speed;\n    if (memo.containsKey(key)) {\n        return memo.get(key);\n    }\n    int result = (speed > 0 ? dp(position + speed / 2, -speed / 2, target, memo) : dp(position - speed / 2, -speed / 2, target, memo)) + 1;\n    result = Math.min(result, dp(position + speed, speed * 2, target, memo) + 1);\n    memo.put(key, result);\n    return result;\n}\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "python": "\n    ```python\ndef racecar(target: int) -> int:\n    memo = {}\n    def dp(position, speed):\n        if abs(position) > 2 * target:\n            return target + 1\n        if position == target:\n            return 0 if speed == 1 else 1\n        if (position, speed) in memo:\n            return memo[(position, speed)]\n        \n        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1\n        ans = min(ans, dp(position + speed, speed * 2) + 1)\n        memo[(position, speed)] = ans\n        return ans\n    \n    return dp(0, 1)\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "c++": "\n    ```cpp\nint racecar(int target) {\n    unordered_map<int, unordered_map<int, int>> memo;\n    function<int(int, int)> dp = [&](int pos, int speed) {\n        if (abs(pos) > 2 * target) return target + 1;\n        if (pos == target) return speed == 1 ? 0 : 1;\n        if (memo[pos][speed]) return memo[pos][speed];\n        int ans = (speed > 0 ? dp(pos + speed / 2, -speed / 2) : dp(pos - speed / 2, -speed / 2)) + 1;\n        ans = min(ans, dp(pos + speed, speed * 2) + 1);\n        return memo[pos][speed] = ans;\n    };\n    return dp(0, 1);\n}\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "js": "\n    ```javascript\nfunction racecar(target) {\n    const memo = new Map();\n    \n    function dp(pos, speed) {\n        if (Math.abs(pos) > 2 * target) {\n            return target + 1;\n        }\n        if (pos === target) {\n            return speed === 1 ? 0 : 1;\n        }\n        const key = pos + \",\" + speed;\n        if (memo.has(key)) {\n            return memo.get(key);\n        }\n        \n        let result = ((speed > 0)\n            ? dp(pos + Math.floor(speed / 2), -Math.floor(speed / 2))\n            : dp(pos - Math.floor(speed / 2), -Math.floor(speed / 2))) + 1;\n        \n        result = Math.min(result, dp(pos + speed, speed * 2) + 1);\n        memo.set(key, result);\n        return result;\n    }\n    \n    return dp(0, 1);\n}\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    "
    },
    {
        "id": 123,
        "title": "Making A Large Island",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.\n\nReturn _the size of the largest **island** in_ `grid` _after applying this operation_.\n\nAn **island** is a 4-directionally connected group of `1`s.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** 4\n**Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** 4\n**Explanation:** Can't change any 0 to 1, only one island with area = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 500`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,0],[0,1]]",
                "output": "3"
            },
            {
                "input": "[[1,1],[1,0]]",
                "output": "4"
            },
            {
                "input": "[[1,1],[1,1]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxAreaOfIsland(int[][] grid) {\n    int ans = 0;\n    for (int i = 0; i < grid.length; ++i)\n        for (int j = 0; j < grid[i].length; ++j)\n            if (grid[i][j] == 0) {\n                grid[i][j] = 1;\n                ans = Math.max(ans, dfs(grid, i, j));\n                grid[i][j] = 0;\n            }\n    return ans;\n}\n\nprivate int dfs(int[][] grid, int x, int y) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {\n        return 0;\n    }\n    grid[x][y] = 0;\n    return dfs(grid, x - 1, y) + dfs(grid, x + 1, y) + dfs(grid, x, y - 1) + dfs(grid, x, y + 1) + 1;\n}\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "python": "\n    ```python\ndef maxAreaOfIsland(grid):\n    def dfs(x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n            return 0\n        grid[x][y] = 0\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1\n\n    ans = 0\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                grid[i][j] = 1\n                ans = max(ans, dfs(i, j))\n                grid[i][j] = 0\n    return ans\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "c++": "\n    ```cpp\nint maxAreaOfIsland(vector<vector<int>>& grid)\n{\n    function<int(int, int)> dfs = [&](int x, int y) {\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0) {\n            return 0;\n        }\n        grid[x][y] = 0;\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;\n    };\n\n    int ans = 0;\n    for (int i = 0; i < grid.size(); ++i)\n        for (int j = 0; j < grid[i].size(); ++j)\n            if (grid[i][j] == 0) {\n                grid[i][j] = 1;\n                ans = max(ans, dfs(i, j));\n                grid[i][j] = 0;\n            }\n    return ans;\n}\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "js": "\n    ```javascript\nfunction maxAreaOfIsland(grid) {\n    function dfs(x, y) {\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === 0) {\n            return 0;\n        }\n        grid[x][y] = 0;\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;\n    }\n    \n    let ans = 0;\n    for (let i = 0; i < grid.length; ++i)\n        for (let j = 0; j < grid[i].length; ++j)\n            if (grid[i][j] === 0) {\n                grid[i][j] = 1;\n                ans = Math.max(ans, dfs(i, j));\n                grid[i][j] = 0;\n            }\n    return ans;\n}\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    "
    },
    {
        "id": 124,
        "title": "Count Unique Characters of All Substrings of a Given String",
        "difficulty": "Hard",
        "content": {
            "problem": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\n*   For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ABC \"\n**Output:** 10\n**Explanation:** All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ABA \"\n**Output:** 8\n**Explanation:** The same as example 1, except `countUniqueChars`( \"ABA \") = 1.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LEETCODE \"\n**Output:** 92"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of uppercase English letters only.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"ABC\"",
                "output": "10"
            },
            {
                "input": "\"ABA\"",
                "output": "8"
            },
            {
                "input": "\"LEETCODE\"",
                "output": "92"
            }
        ],
        "java": "\n    ```java\npublic boolean xorGame(int[] nums) {\n    int xorSum = 0;\n    for (int num : nums) {\n        xorSum ^= num;\n    }\n    return xorSum == 0 || nums.length % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "python": "\n    ```python\ndef xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "c++": "\n    ```cpp\nbool xorGame(const std::vector<int>& nums) {\n    int xorSum = 0;\n    for (int num : nums) {\n        xorSum ^= num;\n    }\n    return xorSum == 0 || nums.size() % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "js": "\n    ```javascript\nfunction xorGame(nums) {\n    let xorSum = 0;\n    for (let num of nums) {\n        xorSum ^= num;\n    }\n    return xorSum === 0 || nums.length % 2 === 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    "
    },
    {
        "id": 125,
        "title": "Consecutive Numbers Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, return _the number of ways you can write_ `n` _as the sum of consecutive positive integers._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 = 2 + 3\n\n",
                "**Example 2:**\n\n**Input:** n = 9\n**Output:** 3\n**Explanation:** 9 = 4 + 5 = 2 + 3 + 4\n\n",
                "**Example 3:**\n\n**Input:** n = 15\n**Output:** 4\n**Explanation:** 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration"
        ],
        "example": [
            {
                "input": "5",
                "output": "2"
            },
            {
                "input": "9",
                "output": "3"
            },
            {
                "input": "15",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> subdomainVisits(String[] cpdomains) {\n    Map<String, Integer> counts = new HashMap<>();\n    List<String> result = new ArrayList<>();\n\n    for (String cpdomain : cpdomains) {\n        String[] info = cpdomain.split(\" \");\n        int count = Integer.valueOf(info[0]);\n        String domain = info[1];\n\n        for (int i = 0; i < domain.length(); ++i) {\n            if (domain.charAt(i) == '.') {\n                counts.put(domain.substring(i + 1), counts.getOrDefault(domain.substring(i + 1), 0) + count);\n            }\n        }\n        counts.put(domain, counts.getOrDefault(domain, 0) + count);\n    }\n\n    for (String sub : counts.keySet()) {\n        result.add(\"\" + counts.get(sub) + \" \" + sub);\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm iterates through the input array, splitting each string into count and domain. Then, for each domain, it looks for the period (.) character and for each period (.) found, it updates the count of the subdomain in a hash table/data structure (unordered_map/HashMap/defaultdict/object). Finally, the algorithm iterates through the counts of subdomains and formats an array in the required format to return.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef subdomainVisits(cpdomains):\n    counts = defaultdict(int)\n    result = []\n\n    for cpdomain in cpdomains:\n        count, domain = cpdomain.split()\n        count = int(count)\n\n        for i in range(len(domain)):\n            if domain[i] == '.':\n                counts[domain[i + 1:]] += count\n        counts[domain] += count\n\n    for sub, cnt in counts.items():\n        result.append(f\"{cnt} {sub}\")\n        \n    return result\n```\n\n    \n    The algorithm iterates through the input array, splitting each string into count and domain. Then, for each domain, it looks for the period (.) character and for each period (.) found, it updates the count of the subdomain in a hash table/data structure (unordered_map/HashMap/defaultdict/object). Finally, the algorithm iterates through the counts of subdomains and formats an array in the required format to return.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<string> subdomainVisits(vector<string>& cpdomains) {\n    unordered_map<string, int> counts;\n    vector<string> result;\n\n    for (const string& cpdomain : cpdomains) {\n        int index = cpdomain.find(' ');\n        int count = stoi(cpdomain.substr(0, index));\n        string domain = cpdomain.substr(index + 1);\n\n        for (int i = 0; i < domain.size(); ++i) {\n            if (domain[i] == '.') {\n                counts[domain.substr(i + 1)] += count;\n            }\n        }\n        counts[domain] += count;\n    }\n\n    for (const auto& pair : counts) {\n        result.push_back(to_string(pair.second) + ' ' + pair.first);\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm iterates through the input array, splitting each string into count and domain. Then, for each domain, it looks for the period (.) character and for each period (.) found, it updates the count of the subdomain in a hash table/data structure (unordered_map/HashMap/defaultdict/object). Finally, the algorithm iterates through the counts of subdomains and formats an array in the required format to return.\n    ",
        "js": "\n    ```javascript\nfunction subdomainVisits(cpdomains) {\n    const counts = {};\n    const result = [];\n\n    for (let cpdomain of cpdomains) {\n        let [count, domain] = cpdomain.split(' ');\n        count = parseInt(count);\n\n        for (let i = 0; i < domain.length; ++i) {\n            if (domain[i] === '.') {\n                const sub = domain.slice(i + 1);\n                counts[sub] = (counts[sub] || 0) + count;\n            }\n        }\n        counts[domain] = (counts[domain] || 0) + count;\n    }\n\n    for (let sub in counts) {\n        result.push(`${counts[sub]} ${sub}`);\n    }\n    \n    return result;\n}\n```\n\n    \n    The algorithm iterates through the input array, splitting each string into count and domain. Then, for each domain, it looks for the period (.) character and for each period (.) found, it updates the count of the subdomain in a hash table/data structure (unordered_map/HashMap/defaultdict/object). Finally, the algorithm iterates through the counts of subdomains and formats an array in the required format to return.\n    "
    },
    {
        "id": 126,
        "title": "Sum of Distances in Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Graph"
        ],
        "example": [
            {
                "input": "6,[[0,1],[0,2],[2,3],[2,4],[2,5]]",
                "output": "[8,12,6,10,10,10]"
            },
            {
                "input": "1,[]",
                "output": "[0]"
            },
            {
                "input": "2,[[1,0]]",
                "output": "[1,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> ambiguousCoordinates(String s) {\n    int n = s.length();\n    List<String> res = new ArrayList<>();\n    \n    for (int i = 2; i < n - 1; i++) {\n        List<String> first = generateNumber(s.substring(1, i));\n        List<String> second = generateNumber(s.substring(i, n - 1));\n        \n        for (String f : first) {\n            for (String sec : second) {\n                res.add(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n\nprivate List<String> generateNumber(String s) {\n    int n = s.length();\n    List<String> res = new ArrayList<>();\n    \n    if (n == 0 || (n > 1 && s.charAt(0) == '0' && s.charAt(n - 1) == '0')) return res;\n    if (n > 1 && s.charAt(0) == '0') {\n        res.add(\"0.\" + s.substring(1));\n        return res;\n    }\n    res.add(s);\n    if (n == 1 || s.charAt(n - 1) == '0') return res;\n    \n    for (int i = 1; i < n; i++) {\n        res.add(s.substring(0, i) + \".\" + s.substring(i));\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "python": "\n    ```python\ndef ambiguousCoordinates(s):\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> ambiguousCoordinates(std::string s) {\n    int n = s.size();\n    std::vector<std::string> res;\n    \n    for (int i = 2; i < n - 1; ++i) {\n        auto first = generateNumber(s.substr(1, i - 1));\n        auto second = generateNumber(s.substr(i, n - 1 - i));\n        \n        for (const auto& f : first) {\n            for (const auto& sec : second) {\n                res.push_back(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n\nstd::vector<std::string> generateNumber(const std::string& s) {\n    int n = s.size();\n    std::vector<std::string> res;\n    \n    if (n == 0 || (n > 1 && s[0] == '0' && s[n - 1] == '0')) return res;\n    if (n > 1 && s[0] == '0') {\n        res.push_back(\"0.\" + s.substr(1));\n        return res;\n    }\n    res.push_back(s);\n    if (n == 1 || s[n - 1] == '0') return res;\n    \n    for (int i = 1; i < n; ++i) {\n        res.push_back(s.substr(0, i) + \".\" + s.substr(i));\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "js": "\n    ```javascript\nfunction ambiguousCoordinates(s) {\n    function generateNumber(s) {\n        if (s.length === 0 || (s.length > 1 && s[0] === '0' && s[s.length - 1] === '0')) {\n            return [];\n        }\n        if (s.length > 1 && s[0] === '0') {\n            return [\"0.\" + s.slice(1)];\n        }\n        let res = [s];\n        if (s.length === 1 || s[s.length - 1] === '0') {\n            return res;\n        }\n        for (let i = 1; i < s.length; i++) {\n            res.push(s.slice(0, i) + \".\" + s.slice(i));\n        }\n        return res;\n    }\n    \n    let n = s.length;\n    let res = [];\n    \n    for (let i = 2; i < n - 1; i++) {\n        let first = generateNumber(s.slice(1, i));\n        let second = generateNumber(s.slice(i, n - 1));\n        \n        for (let f of first) {\n            for (let sec of second) {\n                res.push(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    "
    },
    {
        "id": 127,
        "title": "Similar String Groups",
        "difficulty": "Hard",
        "content": {
            "problem": "Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.\n\nFor example, `\"tars \"` and `\"rats \"` are similar (swapping at positions `0` and `2`), and `\"rats \"` and `\"arts \"` are similar, but `\"star \"` is not similar to `\"tars \"`, `\"rats \"`, or `\"arts \"`.\n\nTogether, these form two connected groups by similarity: `{ \"tars \", \"rats \", \"arts \"}` and `{ \"star \"}`. Notice that `\"tars \"` and `\"arts \"` are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n\nWe are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"tars \", \"rats \", \"arts \", \"star \"\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"omv \", \"ovm \"\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 300`\n*   `1 <= strs[i].length <= 300`\n*   `strs[i]` consists of lowercase letters only.\n*   All words in `strs` have the same length and are anagrams of each other.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find"
        ],
        "example": [
            {
                "input": "[\"tars\",\"rats\",\"arts\",\"star\"]",
                "output": "2"
            },
            {
                "input": "[\"omv\",\"ovm\"]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int minimalLengthEncoding(String[] words) {\n    Set<String> wordSet = new HashSet<>();\n    for (String word : words) {\n        wordSet.add(word);\n    }\n\n    for (String word : words) {\n        for (int i = 1; i < word.length(); i++) {\n            wordSet.remove(word.substring(i));\n        }\n    }\n\n    int len = 0;\n    for (String word : wordSet) {\n        len += word.length() + 1;\n    }\n    return len;\n}\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M^2), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "python": "\n    ```python\ndef minimal_length_encoding(words):\n    word_set = set(words)\n\n    for word in words:\n        for i in range(1, len(word)):\n            word_set.discard(word[i:])\n\n    return sum(len(word) + 1 for word in word_set)\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M^2), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nint minimal_length_encoding(const std::vector<std::string>& words) {\n    std::unordered_set<std::string> word_set(words.begin(), words.end());\n\n    for (const std::string& word : words) {\n        for (int i = 1; i < word.size(); ++i) {\n            word_set.erase(word.substr(i));\n        }\n    }\n\n    int len = 0;\n    for (const std::string& word : word_set) {\n        len += word.size() + 1;\n    }\n    return len;\n}\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M^2), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "js": "\n    ```javascript\nfunction minimalLengthEncoding(words) {\n    const wordSet = new Set(words);\n\n    for (const word of words) {\n        for (let i = 1; i < word.length; i++) {\n            wordSet.delete(word.slice(i));\n        }\n    }\n\n    let len = 0;\n    for (const word of wordSet) {\n        len += word.length + 1;\n    }\n    return len;\n}\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M^2), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    "
    },
    {
        "id": 128,
        "title": "Guess the Word",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of unique strings `words` where `words[i]` is six letters long. One word of `words` was chosen as a secret word.\n\nYou are also given the helper object `Master`. You may call `Master.guess(word)` where `word` is a six-letter-long string, and it must be from `words`. `Master.guess(word)` returns:\n\n*   `-1` if `word` is not from `words`, or\n*   an integer representing the number of exact matches (value and position) of your guess to the secret word.\n\nThere is a parameter `allowedGuesses` for each test case where `allowedGuesses` is the maximum number of times you can call `Master.guess(word)`.\n\nFor each test case, you should call `Master.guess` with the secret word without exceeding the maximum number of allowed guesses. You will get:\n\n*   **`\"Either you took too many guesses, or you did not find the secret word. \"`** if you called `Master.guess` more than `allowedGuesses` times or if you did not call `Master.guess` with the secret word, or\n*   **`\"You guessed the secret word correctly. \"`** if you called `Master.guess` with the secret word with the number of calls to `Master.guess` less than or equal to `allowedGuesses`.\n\nThe test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).",
            "examples": [
                "**Example 1:**\n\n**Input:** secret =  \"acckzz \", words = \\[ \"acckzz \", \"ccbazz \", \"eiowzz \", \"abcczz \"\\], allowedGuesses = 10\n**Output:** You guessed the secret word correctly.\n**Explanation:**\nmaster.guess( \"aaaaaa \") returns -1, because  \"aaaaaa \" is not in wordlist.\nmaster.guess( \"acckzz \") returns 6, because  \"acckzz \" is secret and has all 6 matches.\nmaster.guess( \"ccbazz \") returns 3, because  \"ccbazz \" has 3 matches.\nmaster.guess( \"eiowzz \") returns 2, because  \"eiowzz \" has 2 matches.\nmaster.guess( \"abcczz \") returns 4, because  \"abcczz \" has 4 matches.\nWe made 5 calls to master.guess, and one of them was the secret, so we pass the test case.\n\n",
                "**Example 2:**\n\n**Input:** secret =  \"hamada \", words = \\[ \"hamada \", \"khaled \"\\], allowedGuesses = 10\n**Output:** You guessed the secret word correctly.\n**Explanation:** Since there are two words, you can guess both."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `words[i].length == 6`\n*   `words[i]` consist of lowercase English letters.\n*   All the strings of `wordlist` are **unique**.\n*   `secret` exists in `words`.\n*   `10 <= allowedGuesses <= 30`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "String",
            "Interactive",
            "Game Theory"
        ],
        "example": [
            {
                "input": "\"acckzz\",[\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"],10",
                "output": "Youguessedthesecretwordcorrectly."
            },
            {
                "input": "\"hamada\",[\"hamada\",\"khaled\"],10",
                "output": "Youguessedthesecretwordcorrectly."
            }
        ],
        "java": "\n    ```java\npublic int numFactoredBinaryTrees(int[] arr) {\n    int MOD = 1_000_000_007;\n    int n = arr.length;\n    Arrays.sort(arr);\n    HashMap<Integer, Long> dp = new HashMap<>();\n    for (int i = 0; i < n; ++i) {\n        dp.put(arr[i], 1L);\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] % arr[j] == 0 && dp.containsKey(arr[i] / arr[j]))\n                dp.put(arr[i], (dp.get(arr[i]) + dp.get(arr[j]) * dp.get(arr[i] / arr[j])) % MOD);\n        }\n    }\n    long ans = 0;\n    for (Long value : dp.values()) ans = (ans + value) % MOD;\n    return (int) ans;\n}\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "python": "\n    ```python\ndef numFactoredBinaryTrees(arr):\n    MOD = 10**9 + 7\n    n = len(arr)\n    arr.sort()\n    dp = {}\n    for i, x in enumerate(arr):\n        dp[x] = 1\n        for y in arr[:i]:\n            if x % y == 0 and x // y in dp:\n                dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD\n    return sum(dp.values()) % MOD\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "c++": "\n    ```cpp\nint numFactoredBinaryTrees(vector<int>& arr) {\n    long long MOD = 1e9 + 7;\n    int n = arr.size();\n    sort(arr.begin(), arr.end());\n    unordered_map<int, long long> dp;\n    for (int i = 0; i < n; ++i) {\n        dp[arr[i]] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] % arr[j] == 0 && dp.count(arr[i] / arr[j]))\n                dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % MOD;\n        }\n    }\n    long long ans = 0;\n    for (const auto& it : dp) ans = (ans + it.second) % MOD;\n    return ans;\n}\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "js": "\n    ```javascript\nfunction numFactoredBinaryTrees(arr) {\n    const MOD = 1e9 + 7;\n    const n = arr.length;\n    arr.sort((a, b) => a - b);\n    let dp = new Map();\n    for (let i = 0; i < n; ++i) {\n        dp.set(arr[i], 1);\n        for (let j = 0; j < i; ++j) {\n            if (arr[i] % arr[j] === 0 && dp.has(arr[i] / arr[j]))\n                dp.set(arr[i], (dp.get(arr[i]) + dp.get(arr[j]) * dp.get(arr[i] / arr[j])) % MOD);\n        }\n    }\n    let ans = 0;\n    for (const value of dp.values()) ans = (ans + value) % MOD;\n    return ans;\n}\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    "
    },
    {
        "id": 129,
        "title": "Shortest Path Visiting All Nodes",
        "difficulty": "Hard",
        "content": {
            "problem": "You have an undirected, connected graph of `n` nodes labeled from `0` to `n - 1`. You are given an array `graph` where `graph[i]` is a list of all the nodes connected with node `i` by an edge.\n\nReturn _the length of the shortest path that visits every node_. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[1,2,3\\],\\[0\\],\\[0\\],\\[0\\]\\]\n**Output:** 4\n**Explanation:** One possible path is \\[1,0,2,0,3\\]\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1\\],\\[0,2,4\\],\\[1,3,4\\],\\[2\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** One possible path is \\[0,1,4,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == graph.length`\n*   `1 <= n <= 12`\n*   `0 <= graph[i].length < n`\n*   `graph[i]` does not contain `i`.\n*   If `graph[a]` contains `b`, then `graph[b]` contains `a`.\n*   The input graph is always connected.",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation",
            "Breadth-First Search",
            "Graph",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[[1,2,3],[0],[0],[0]]",
                "output": "4"
            },
            {
                "input": "[[1],[0,2,4],[1,3,4],[2],[1,2]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int shortestPathLength(int[][] graph) {\n    int n = graph.length;\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[n][1 << n];\n\n    for (int i = 0; i < n; i++) {\n        queue.offer(new int[]{i, 1 << i, 0});\n        visited[i][1 << i] = true;\n    }\n\n    while (!queue.isEmpty()) {\n        int[] cur = queue.poll();\n        int node = cur[0], bitmask = cur[1], length = cur[2];\n\n        if (bitmask == (1 << n) - 1) return length;\n\n        for (int nei : graph[node]) {\n            int next_bitmask = bitmask | (1 << nei);\n            if (!visited[nei][next_bitmask]) {\n                visited[nei][next_bitmask] = true;\n                queue.offer(new int[]{nei, next_bitmask, length + 1});\n            }\n        }\n    }\n\n    return 0;\n}\n```\n    \n    The problem can be solved using BFS (breadth-first search) and bitmasks to represent the state of visited nodes. \n\n1. Initially, create a queue with each node as a starting point, and a 2D visited array to keep track of visited states.\n2. For each node, mark its corresponding bitmask as visited.\n3. Iterate through the queue until it's empty.\n   1. Dequeue the first item, which is a tuple of the current node, its bitmask, and its length.\n   2. If the bitmask represents all nodes visited (bitmask is equal to `(1 << n) - 1`), return the current length.\n   3. For each neighboring node (`nei`), create the next bitmask by bitwise OR operation with the current bitmask and neighbor node.\n   4. If the next bitmask hasn't been visited, mark it as visited and enqueue the tuple of the neighboring node, next bitmask, and incremented length.\n\nThe algorithm eventually returns the length of the shortest path that visits every node. Since we start and finish at any possible node, the running time complexity is O(n * 2^n).\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    queue = deque([(i, 1 << i, 0) for i in range(n)])\n    visited = [[False] * (1 << n) for _ in range(n)]\n\n    for i in range(n):\n        visited[i][1 << i] = True\n\n    while queue:\n        node, bitmask, length = queue.popleft()\n\n        if bitmask == (1 << n) - 1:\n            return length\n\n        for nei in graph[node]:\n            next_bitmask = bitmask | (1 << nei)\n            if not visited[nei][next_bitmask]:\n                visited[nei][next_bitmask] = True\n                queue.append((nei, next_bitmask, length + 1))\n\n    return 0\n```\n    \n    The problem can be solved using BFS (breadth-first search) and bitmasks to represent the state of visited nodes. \n\n1. Initially, create a queue with each node as a starting point, and a 2D visited array to keep track of visited states.\n2. For each node, mark its corresponding bitmask as visited.\n3. Iterate through the queue until it's empty.\n   1. Dequeue the first item, which is a tuple of the current node, its bitmask, and its length.\n   2. If the bitmask represents all nodes visited (bitmask is equal to `(1 << n) - 1`), return the current length.\n   3. For each neighboring node (`nei`), create the next bitmask by bitwise OR operation with the current bitmask and neighbor node.\n   4. If the next bitmask hasn't been visited, mark it as visited and enqueue the tuple of the neighboring node, next bitmask, and incremented length.\n\nThe algorithm eventually returns the length of the shortest path that visits every node. Since we start and finish at any possible node, the running time complexity is O(n * 2^n).\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint shortestPathLength(const std::vector<std::vector<int>>& graph) {\n    int n = graph.size();\n    std::queue<std::tuple<int, int, int>> q;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(1 << n, false));\n\n    for (int i = 0; i < n; ++i) {\n        q.push({i, 1 << i, 0});\n        visited[i][1 << i] = true;\n    }\n\n    while (!q.empty()) {\n        auto [node, bitmask, length] = q.front();\n        q.pop();\n\n        if (bitmask == (1 << n) - 1) return length;\n\n        for (int nei : graph[node]) {\n            int next_bitmask = bitmask | (1 << nei);\n            if (!visited[nei][next_bitmask]) {\n                visited[nei][next_bitmask] = true;\n                q.push({nei, next_bitmask, length + 1});\n            }\n        }\n    }\n\n    return 0;\n}\n```\n    \n    The problem can be solved using BFS (breadth-first search) and bitmasks to represent the state of visited nodes. \n\n1. Initially, create a queue with each node as a starting point, and a 2D visited array to keep track of visited states.\n2. For each node, mark its corresponding bitmask as visited.\n3. Iterate through the queue until it's empty.\n   1. Dequeue the first item, which is a tuple of the current node, its bitmask, and its length.\n   2. If the bitmask represents all nodes visited (bitmask is equal to `(1 << n) - 1`), return the current length.\n   3. For each neighboring node (`nei`), create the next bitmask by bitwise OR operation with the current bitmask and neighbor node.\n   4. If the next bitmask hasn't been visited, mark it as visited and enqueue the tuple of the neighboring node, next bitmask, and incremented length.\n\nThe algorithm eventually returns the length of the shortest path that visits every node. Since we start and finish at any possible node, the running time complexity is O(n * 2^n).\n    ",
        "js": "\n    ```javascript\nfunction shortestPathLength(graph) {\n    const n = graph.length;\n    const queue = [];\n    const visited = Array.from({length: n}, () => Array(1 << n).fill(false));\n\n    for (let i = 0; i < n; i++) {\n        queue.push([i, 1 << i, 0]);\n        visited[i][1 << i] = true;\n    }\n\n    while (queue.length) {\n        const [node, bitmask, length] = queue.shift();\n\n        if (bitmask === (1 << n) - 1) return length;\n\n        for (const nei of graph[node]) {\n            const next_bitmask = bitmask | (1 << nei);\n            if (!visited[nei][next_bitmask]) {\n                visited[nei][next_bitmask] = true;\n                queue.push([nei, next_bitmask, length + 1]);\n            }\n        }\n    }\n\n    return 0;\n}\n```\n    \n    The problem can be solved using BFS (breadth-first search) and bitmasks to represent the state of visited nodes. \n\n1. Initially, create a queue with each node as a starting point, and a 2D visited array to keep track of visited states.\n2. For each node, mark its corresponding bitmask as visited.\n3. Iterate through the queue until it's empty.\n   1. Dequeue the first item, which is a tuple of the current node, its bitmask, and its length.\n   2. If the bitmask represents all nodes visited (bitmask is equal to `(1 << n) - 1`), return the current length.\n   3. For each neighboring node (`nei`), create the next bitmask by bitwise OR operation with the current bitmask and neighbor node.\n   4. If the next bitmask hasn't been visited, mark it as visited and enqueue the tuple of the neighboring node, next bitmask, and incremented length.\n\nThe algorithm eventually returns the length of the shortest path that visits every node. Since we start and finish at any possible node, the running time complexity is O(n * 2^n).\n    "
    },
    {
        "id": 130,
        "title": "Rectangle Area II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2]` denotes the `ith` rectangle where `(xi1, yi1)` are the coordinates of the **bottom-left corner**, and `(xi2, yi2)` are the coordinates of the **top-right corner**.\n\nCalculate the **total area** covered by all `rectangles` in the plane. Any area covered by two or more rectangles should only be counted **once**.\n\nReturn _the **total area**_. Since the answer may be too large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rectangles = \\[\\[0,0,2,2\\],\\[1,0,2,3\\],\\[1,0,3,1\\]\\]\n**Output:** 6\n**Explanation:** A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap.\n\n",
                "**Example 2:**\n\n**Input:** rectangles = \\[\\[0,0,1000000000,1000000000\\]\\]\n**Output:** 49\n**Explanation:** The answer is 1018 modulo (109 + 7), which is 49."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rectangles.length <= 200`\n*   `rectanges[i].length == 4`\n*   `0 <= xi1, yi1, xi2, yi2 <= 109`\n*   `xi1 <= xi2`\n*   `yi1 <= yi2`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Segment Tree",
            "Line Sweep",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[0,0,2,2],[1,0,2,3],[1,0,3,1]]",
                "output": "6"
            },
            {
                "input": "[[0,0,1000000000,1000000000]]",
                "output": "49"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int rectangleArea(int[][] rectangles) {\n    final int mod = 1000000007;\n    int n = rectangles.length;\n    Set<Integer> X = new HashSet<>();\n    Set<Integer> Y = new HashSet<>();\n    for (int[] rect : rectangles) {\n        X.add(rect[0]);\n        X.add(rect[2]);\n        Y.add(rect[1]);\n        Y.add(rect[3]);\n    }\n    Integer[] sortedX = X.toArray(new Integer[0]);\n    Integer[] sortedY = Y.toArray(new Integer[0]);\n    Arrays.sort(sortedX);\n    Arrays.sort(sortedY);\n\n...\n```\n(Java code is similar to C++, with minor adjustments to use Java Collections)\n\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef rectangleArea(rectangles):\n    mod = 10**9 + 7\n    n = len(rectangles)\n    X, Y = set(), set()\n    for rect in rectangles:\n        X.add(rect[0])\n        X.add(rect[2])\n        Y.add(rect[1])\n        Y.add(rect[3])\n    sorted_x = sorted(X)\n    sorted_y = sorted(Y)\n    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]\n\n    for rect in rectangles:\n        x1_idx = sorted_x.index(rect[0])\n        x2_idx = sorted_x.index(rect[2]) - 1\n        y1_idx = sorted_y.index(rect[1])\n        y2_idx = sorted_y.index(rect[3]) - 1\n        for i in range(x1_idx, x2_idx + 1):\n            for j in range(y1_idx, y2_idx + 1):\n                cnt[i][j] = 1\n\n    total_area = 0\n    for i in range(len(X) - 1):\n        for j in range(len(Y) - 1):\n            if cnt[i][j]:\n                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])\n                total_area %= mod\n\n    return total_area\n```\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nint rectangleArea(vector<vector<int>>& rectangles) {\n    const int64_t mod = 1e9 + 7;\n    int n = rectangles.size();\n    vector<int> X, Y;\n    for (const auto &rect : rectangles) {\n        X.push_back(rect[0]);\n        X.push_back(rect[2]);\n        Y.push_back(rect[1]);\n        Y.push_back(rect[3]);\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    X.erase(unique(X.begin(), X.end()), X.end());\n    Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\n    vector<vector<int>> cnt(X.size() - 1, vector<int>(Y.size() - 1));\n\n    for (const auto &rect : rectangles) {\n        int x1_idx = lower_bound(X.begin(), X.end(), rect[0]) - X.begin();\n        int x2_idx = lower_bound(X.begin(), X.end(), rect[2]) - X.begin() - 1;\n        int y1_idx = lower_bound(Y.begin(), Y.end(), rect[1]) - Y.begin();\n        int y2_idx = lower_bound(Y.begin(), Y.end(), rect[3]) - Y.begin() - 1;\n        for (int i = x1_idx; i <= x2_idx; ++i) {\n            for (int j = y1_idx; j <= y2_idx; ++j) {\n                cnt[i][j] = 1;\n            }\n        }\n    }\n    int64_t total_area = 0;\n    for (int i = 0; i < X.size() - 1; ++i) {\n        for (int j = 0; j < Y.size() - 1; ++j) {\n            if (cnt[i][j]) {\n                total_area += (int64_t)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]);\n                total_area %= mod;\n            }\n        }\n    }\n    return total_area;\n}\n```\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction rectangleArea(rectangles) {\n    const mod = 1e9 + 7;\n    let n = rectangles.length;\n    let X = new Set(), Y = new Set();\n    for (const rect of rectangles) {\n        X.add(rect[0]);\n        X.add(rect[2]);\n        Y.add(rect[1]);\n        Y.add(rect[3]);\n    }\n    let sortedX = Array.from(X).sort((a, b) => a - b);\n    let sortedY = Array.from(Y).sort((a, b) => a - b);\n\n    let cnt = Array.from({ length: X.size - 1 }, () => Array.from({ length: Y.size - 1 }, () => 0));\n\n    for (const rect of rectangles) {\n        let x1_idx = sortedX.indexOf(rect[0]);\n        let x2_idx = sortedX.indexOf(rect[2]) - 1;\n        let y1_idx = sortedY.indexOf(rect[1]);\n        let y2_idx = sortedY.indexOf(rect[3]) - 1;\n        for (let i = x1_idx; i <= x2_idx; i++) {\n            for (let j = y1_idx; j <= y2_idx; j++) {\n                cnt[i][j] = 1;\n            }\n        }\n    }\n\n    let total_area = 0;\n    for (let i = 0; i < X.size - 1; i++) {\n        for (let j = 0; j < Y.size - 1; j++) {\n            if (cnt[i][j]) {\n                total_area += (sortedX[i + 1] - sortedX[i]) * (sortedY[j + 1] - sortedY[j]);\n                total_area %= mod;\n            }\n        }\n    }\n\n    return total_area;\n}\n```\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    "
    },
    {
        "id": 131,
        "title": "K-Similar Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "Strings `s1` and `s2` are `k`**\\-similar** (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`**\\-similar**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"ab \", s2 =  \"ba \"\n**Output:** 1\n**Explanation:** The two string are 1-similar because we can use one swap to change s1 to s2:  \"ab \" -->  \"ba \".\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"abc \", s2 =  \"bca \"\n**Output:** 2\n**Explanation:** The two strings are 2-similar because we can use two swaps to change s1 to s2:  \"abc \" -->  \"bac \" -->  \"bca \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length <= 20`\n*   `s2.length == s1.length`\n*   `s1` and `s2` contain only lowercase letters from the set `{'a', 'b', 'c', 'd', 'e', 'f'}`.\n*   `s2` is an anagram of `s1`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"ab\",\"ba\"",
                "output": "1"
            },
            {
                "input": "\"abc\",\"bca\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nint kSimilarity(String s1, String s2) {\n    int k = 0;\n    StringBuilder sb = new StringBuilder(s1);\n\n    for (int i = 0; i < sb.length(); i++) {\n        if (sb.charAt(i) != s2.charAt(i)) {\n            int j = i + 1;\n            while (sb.charAt(j) != s2.charAt(i) || s2.charAt(j) == sb.charAt(j)) {\n                j++;\n            }\n            sb.setCharAt(j, sb.charAt(i));\n            sb.setCharAt(i, s2.charAt(i));\n            k++;\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "python": "\n    ```python\ndef kSimilarity(s1: str, s2: str) -> int:\n    k = 0\n    temp = list(s1)\n\n    for i in range(len(temp)):\n        if temp[i] != s2[i]:\n            j = i + 1\n            while temp[j] != s2[i] or s2[j] == temp[j]:\n                j += 1\n            temp[i], temp[j] = temp[j], temp[i]\n            k += 1\n\n    return k\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "c++": "\n    ```cpp\nint kSimilarity(const std::string& s1, const std::string& s2) {\n    int k = 0;\n    std::string temp = s1;\n\n    for (int i = 0; i < temp.length(); ++i) {\n        if (temp[i] != s2[i]) {\n            int j = i + 1;\n            while (temp[j] != s2[i] || s2[j] == temp[j]) {\n                ++j;\n            }\n            std::swap(temp[i], temp[j]);\n            k++;\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "js": "\n    ```javascript\nfunction kSimilarity(s1, s2) {\n    let k = 0;\n    let temp = s1.split('');\n\n    for (let i = 0; i < temp.length; i++) {\n        if (temp[i] !== s2[i]) {\n            let j = i + 1;\n            while (temp[j] !== s2[i] || s2[j] === temp[j]) {\n                j++;\n            }\n            [temp[i], temp[j]] = [temp[j], temp[i]];\n            k++;\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    "
    },
    {
        "id": 132,
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** quality = \\[10,20,5\\], wage = \\[70,50,30\\], k = 2\n**Output:** 105.00000\n**Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n\n",
                "**Example 2:**\n\n**Input:** quality = \\[3,1,10,10,1\\], wage = \\[4,8,2,2,7\\], k = 3\n**Output:** 30.66667\n**Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately."
            ],
            "constraints": "**Constraints:**\n\n*   `n == quality.length == wage.length`\n*   `1 <= k <= n <= 104`\n*   `1 <= quality[i], wage[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[10,20,5],[70,50,30],2",
                "output": "105.00000"
            },
            {
                "input": "[3,1,10,10,1],[4,8,2,2,7],3",
                "output": "30.66667"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> largeGroupPositions(String s) {\n    List<List<Integer>> result = new ArrayList<>();\n    int start = 0;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s.charAt(i) != s.charAt(start)) {\n            if (i - start >= 3) {\n                List<Integer> interval = new ArrayList<>();\n                interval.add(start);\n                interval.add(i - 1);\n                result.add(interval);\n            }\n            start = i;\n        }\n    }\n    if (s.length() - start >= 3) {\n        List<Integer> interval = new ArrayList<>();\n        interval.add(start);\n        interval.add(s.length() - 1);\n        result.add(interval);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "python": "\n    ```python\ndef largeGroupPositions(s: str):\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n    return result\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<vector<int>> largeGroupPositions(string s) {\n    vector<vector<int>> result;\n    int start = 0;\n    for (int i = 1; i < s.size(); ++i) {\n        if (s[i] != s[start]) {\n            if (i - start >= 3) {\n                result.push_back({start, i - 1});\n            }\n            start = i;\n        }\n    }\n    if (s.size() - start >= 3) {\n        result.push_back({start, static_cast<int>(s.size()) - 1});\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "js": "\n    ```javascript\nfunction largeGroupPositions(s) {\n    const result = [];\n    let start = 0;\n    for (let i = 1; i < s.length; ++i) {\n        if (s.charAt(i) !== s.charAt(start)) {\n            if (i - start >= 3) {\n                result.push([start, i - 1]);\n            }\n            start = i;\n        }\n    }\n    if (s.length - start >= 3) {\n        result.push([start, s.length - 1]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    "
    },
    {
        "id": 133,
        "title": "Shortest Subarray with Sum at Least K",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the length of the shortest non-empty **subarray** of_ `nums` _with a sum of at least_ `k`. If there is no such **subarray**, return `-1`.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2\\], k = 4\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,-1,2\\], k = 3\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`\n*   `1 <= k <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Prefix Sum",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[1],1",
                "output": "1"
            },
            {
                "input": "[1,2],4",
                "output": "-1"
            },
            {
                "input": "[2,-1,2],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\n    List<int[]> indexMapping = new ArrayList<>();\n\n    for (int i = 0; i < indices.length; i++) {\n        if (s.startsWith(sources[i], indices[i])) {\n            indexMapping.add(new int[]{indices[i], i});\n        }\n    }\n\n    indexMapping.sort((a, b) -> a[0] - b[0]);\n    StringBuilder result = new StringBuilder();\n    int lastIdx = 0;\n\n    for (int[] p : indexMapping) {\n        result.append(s, lastIdx, p[0]);\n        result.append(targets[p[1]]);\n        lastIdx = p[0] + sources[p[1]].length();\n    }\n\n    result.append(s.substring(lastIdx));\n    return result.toString();\n}\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "python": "\n    ```python\ndef findReplaceString(s, indices, sources, targets):\n    index_mapping = sorted(\n        [(indices[i], i) for i in range(len(indices)) if s.startswith(sources[i], indices[i])]\n    )\n    result = []\n    last_idx = 0\n\n    for idx, i in index_mapping:\n        result.append(s[last_idx:idx])\n        result.append(targets[i])\n        last_idx = idx + len(sources[i])\n\n    result.append(s[last_idx:])\n    return \"\".join(result)\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string findReplaceString(std::string s, std::vector<int>& indices, std::vector<std::string>& sources, std::vector<std::string>& targets) {\n    std::vector<std::pair<int, int>> indexMapping(indices.size());\n    \n    for (int i = 0; i < indices.size(); ++i) {\n        if (s.substr(indices[i], sources[i].size()) == sources[i]) {\n            indexMapping[i] = {indices[i], i};\n        } else {\n            indexMapping[i] = {-1, i};\n        }\n    }\n\n    sort(indexMapping.begin(), indexMapping.end());\n    std::string result = \"\";\n    int lastIdx = 0;\n    \n    for (const auto& p : indexMapping) {\n        if (p.first >= 0) {\n            result += s.substr(lastIdx, p.first - lastIdx) + targets[p.second];\n            lastIdx = p.first + sources[p.second].size();\n        }\n    }\n    \n    result += s.substr(lastIdx);\n    return result;\n}\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "js": "\n    ```javascript\nfunction findReplaceString(s, indices, sources, targets) {\n    const indexMapping = indices\n        .map((idx, i) => [s.startsWith(sources[i], idx) ? idx : -1, i])\n        .sort((a, b) => a[0] - b[0]);\n    let result = \"\";\n    let lastIdx = 0;\n\n    for (const [idx, i] of indexMapping) {\n        if (idx >= 0) {\n            result += s.slice(lastIdx, idx) + targets[i];\n            lastIdx = idx + sources[i].length;\n        }\n    }\n\n    result += s.slice(lastIdx);\n    return result;\n}\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    "
    },
    {
        "id": 134,
        "title": "Shortest Path to Get All Keys",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` grid `grid` where:\n\n*   `'.'` is an empty cell.\n*   `'#'` is a wall.\n*   `'@'` is the starting point.\n*   Lowercase letters represent keys.\n*   Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\nFor some `1 <= k <= 6`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\nReturn _the lowest number of moves to acquire all keys_. If it is impossible, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[ \"@.a.. \", \"###.# \", \"b.A.B \"\\]\n**Output:** 8\n**Explanation:** Note that the goal is to obtain all the keys not to open all the locks.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[ \"@..aA \", \"..B#. \", \"....b \"\\]\n**Output:** 6\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[ \"@Aa \"\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either an English letter, `'.'`, `'#'`, or `'@'`.\n*   The number of keys in the grid is in the range `[1, 6]`.\n*   Each key in the grid is **unique**.\n*   Each key in the grid has a matching lock.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[\"@.a..\",\"###.#\",\"b.A.B\"]",
                "output": "8"
            },
            {
                "input": "[\"@..aA\",\"..B#.\",\"....b\"]",
                "output": "6"
            },
            {
                "input": "[\"@Aa\"]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int largestOverlap(int[][] img1, int[][] img2) {\n    int n = img1.length;\n    List<int[]> onesImg1 = new ArrayList<>();\n    List<int[]> onesImg2 = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (img1[i][j] == 1) onesImg1.add(new int[]{i, j});\n            if (img2[i][j] == 1) onesImg2.add(new int[]{i, j});\n        }\n    }\n\n    Map<String, Integer> overlaps = new HashMap<>();\n    for (int[] pt1 : onesImg1) {\n        for (int[] pt2 : onesImg2) {\n            int dx = pt2[0] - pt1[0];\n            int dy = pt2[1] - pt1[1];\n            String key = dx + \",\" + dy;\n            overlaps.put(key, overlaps.getOrDefault(key, 0) + 1);\n        }\n    }\n\n    int maxOverlap = 0;\n    for (Integer count : overlaps.values()) {\n        maxOverlap = Math.max(maxOverlap, count);\n    }\n    return maxOverlap;\n}\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "python": "\n    ```python\ndef largestOverlap(img1, img2):\n    n = len(img1)\n    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\n    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\n\n    overlaps = {}\n    for pt1 in onesImg1:\n        for pt2 in onesImg2:\n            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]\n            key = (dx, dy)\n            if key not in overlaps:\n                overlaps[key] = 0\n            overlaps[key] += 1\n\n    return max(overlaps.values() or [0])\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "c++": "\n    ```cpp\nint largestOverlap(vector<vector<int>>& img1, vector<vector<int>>& img2) {\n    int n = img1.size();\n    vector<pair<int, int>> onesImg1, onesImg2;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (img1[i][j]) onesImg1.emplace_back(i, j);\n            if (img2[i][j]) onesImg2.emplace_back(i, j);\n        }\n    }\n\n    unordered_map<int, int> overlaps;\n    for (const auto& pt1 : onesImg1) {\n        for (const auto& pt2 : onesImg2) {\n            int dx = pt2.first - pt1.first;\n            int dy = pt2.second - pt1.second;\n            int key = (dx << 16) + dy;\n            ++overlaps[key];\n        }\n    }\n\n    int maxOverlap = 0;\n    for (const auto& pair : overlaps) {\n        maxOverlap = max(maxOverlap, pair.second);\n    }\n    return maxOverlap;\n}\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "js": "\n    ```javascript\nfunction largestOverlap(img1, img2) {\n    const n = img1.length;\n    const onesImg1 = [];\n    const onesImg2 = [];\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (img1[i][j]) onesImg1.push([i, j]);\n            if (img2[i][j]) onesImg2.push([i, j]);\n        }\n    }\n\n    const overlaps = new Map();\n    for (const pt1 of onesImg1) {\n        for (const pt2 of onesImg2) {\n            const dx = pt2[0] - pt1[0];\n            const dy = pt2[1] - pt1[1];\n            const key = `${dx},${dy}`;\n            overlaps.set(key, (overlaps.get(key) || 0) + 1);\n        }\n    }\n\n    let maxOverlap = 0;\n    for (const count of overlaps.values()) {\n        maxOverlap = Math.max(maxOverlap, count);\n    }\n    return maxOverlap;\n}\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    "
    },
    {
        "id": 135,
        "title": "Minimum Number of Refueling Stops",
        "difficulty": "Hard",
        "content": {
            "problem": "A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 1, startFuel = 1, stations = \\[\\]\n**Output:** 0\n**Explanation:** We can reach the target without refueling.\n\n",
                "**Example 2:**\n\n**Input:** target = 100, startFuel = 1, stations = \\[\\[10,100\\]\\]\n**Output:** -1\n**Explanation:** We can not reach the target (or even the first gas station).\n\n",
                "**Example 3:**\n\n**Input:** target = 100, startFuel = 10, stations = \\[\\[10,60\\],\\[20,30\\],\\[30,30\\],\\[60,40\\]\\]\n**Output:** 2\n**Explanation:** We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target, startFuel <= 109`\n*   `0 <= stations.length <= 500`\n*   `1 <= positioni < positioni+1 < target`\n*   `1 <= fueli < 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "1,1,[]",
                "output": "0"
            },
            {
                "input": "100,1,[[10,100]]",
                "output": "-1"
            },
            {
                "input": "100,10,[[10,60],[20,30],[30,30],[60,40]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Stack;\n\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\n    HashSet<Integer> visited = new HashSet<>();\n    Stack<Integer> stack = new Stack<>();\n    stack.push(0);\n\n    while (!stack.isEmpty()) {\n        int currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (int key : rooms.get(currentRoom)) {\n            if (!visited.contains(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef can_visit_all_rooms(rooms):\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nbool canVisitAllRooms(const std::vector<std::vector<int>>& rooms) {\n    std::unordered_set<int> visited;\n    std::vector<int> stack = {0};\n\n    while (!stack.empty()) {\n        int currentRoom = stack.back();\n        stack.pop_back();\n\n        visited.insert(currentRoom);\n\n        for (int key : rooms[currentRoom]) {\n            if (!visited.count(key)) {\n                stack.push_back(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "js": "\n    ```javascript\nfunction canVisitAllRooms(rooms) {\n    const visited = new Set();\n    const stack = [0];\n\n    while (stack.length > 0) {\n        const currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (const key of rooms[currentRoom]) {\n            if (!visited.has(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size === rooms.length;\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    "
    },
    {
        "id": 136,
        "title": "Nth Magical Number",
        "difficulty": "Hard",
        "content": {
            "problem": "A positive integer is _magical_ if it is divisible by either `a` or `b`.\n\nGiven the three integers `n`, `a`, and `b`, return the `nth` magical number. Since the answer may be very large, **return it modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1, a = 2, b = 3\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 4, a = 2, b = 3\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`\n*   `2 <= a, b <= 4 * 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search"
        ],
        "example": [
            {
                "input": "1,2,3",
                "output": "2"
            },
            {
                "input": "4,2,3",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    public String shiftingLetters(String s, int[] shifts) {\n        int n = s.length();\n        for (int i = n - 2; i >= 0; i--) {\n            shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n        }\n        \n        char[] result = new char[n];\n        for (int i = 0; i < n; i++) {\n            result[i] = (char)(((s.charAt(i) - 'a') + shifts[i]) % 26 + 'a');\n        }\n        \n        return new String(result);\n    }\n}\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "python": "\n    ```python\ndef shiftingLetters(s: str, shifts: list[int]) -> str:\n    n = len(s)\n    for i in range(n - 2, -1, -1):\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26\n    \n    result = []\n    for i in range(n):\n        result.append(chr(((ord(s[i]) - ord('a')) + shifts[i]) % 26 + ord('a')))\n    \n    return \"\".join(result)\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string shiftingLetters(std::string s, std::vector<int>& shifts) {\n    int n = s.size();\n    for (int i = n - 2; i >= 0; i--) {\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        s[i] = (s[i] - 'a' + shifts[i]) % 26 + 'a';\n    }\n    \n    return s;\n}\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "js": "\n    ```javascript\nfunction shiftingLetters(s, shifts) {\n    const n = s.length;\n    for (let i = n - 2; i >= 0; i--) {\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n    }\n    \n    let result = \"\";\n    for (let i = 0; i < n; i++) {\n        result += String.fromCharCode((s.charCodeAt(i) - 'a'.charCodeAt(0) + shifts[i]) % 26 + 'a'.charCodeAt(0));\n    }\n    \n    return result;\n}\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    "
    },
    {
        "id": 137,
        "title": "Profitable Schemes",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a group of `n` members, and a list of various crimes they could commit. The `ith` crime generates a `profit[i]` and requires `group[i]` members to participate in it. If a member participates in one crime, that member can't participate in another crime.\n\nLet's call a **profitable scheme** any subset of these crimes that generates at least `minProfit` profit, and the total number of members participating in that subset of crimes is at most `n`.\n\nReturn the number of schemes that can be chosen. Since the answer may be very large, **return it modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, minProfit = 3, group = \\[2,2\\], profit = \\[2,3\\]\n**Output:** 2\n**Explanation:** To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n\n",
                "**Example 2:**\n\n**Input:** n = 10, minProfit = 5, group = \\[2,3,5\\], profit = \\[6,7,8\\]\n**Output:** 7\n**Explanation:** To make a profit of at least 5, the group could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= minProfit <= 100`\n*   `1 <= group.length <= 100`\n*   `1 <= group[i] <= 100`\n*   `profit.length == group.length`\n*   `0 <= profit[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "5,3,[2,2],[2,3]",
                "output": "2"
            },
            {
                "input": "10,5,[2,3,5],[6,7,8]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic int maxDistToClosest(int[] seats) {\n    int maxDist = 0, lastPerson = -1;\n    for (int i = 0; i < seats.length; ++i) {\n        if (seats[i] == 1) {\n            maxDist = lastPerson < 0 ? i : Math.max(maxDist, (i - lastPerson) / 2);\n            lastPerson = i;\n        }\n    }\n    return Math.max(maxDist, seats.length - 1 - lastPerson);\n}\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    ",
        "python": "\n    ```python\ndef max_dist_to_closest(seats):\n    max_dist = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)\n            last_person = i\n    return max(max_dist, len(seats) - 1 - last_person)\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    ",
        "c++": "\n    ```cpp\nint maxDistToClosest(vector<int>& seats) {\n    int max_dist = 0, last_person = -1;\n    for (int i = 0; i < seats.size(); ++i) {\n        if (seats[i] == 1) {\n            max_dist = last_person < 0 ? i : max(max_dist, (i - last_person) / 2);\n            last_person = i;\n        }\n    }\n    return max(max_dist, (int)(seats.size() - 1 - last_person));\n}\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    ",
        "js": "\n    ```javascript\nfunction maxDistToClosest(seats) {\n    let maxDist = 0, lastPerson = -1;\n    for (let i = 0; i < seats.length; ++i) {\n        if (seats[i] == 1) {\n            maxDist = lastPerson < 0 ? i : Math.max(maxDist, ((i - lastPerson) / 2) | 0);\n            lastPerson = i;\n        }\n    }\n    return Math.max(maxDist, seats.length - 1 - lastPerson);\n}\n```\n    \n    First, initialize `max_dist` to store the maximum distance encountered and `last_person` to store the index of the last person found in the array. Iterate through the array of `seats`, for each person encountered (seats[i] == 1), calculate the distance between the current index and the last person, divide it by 2, and update `max_dist` with the maximum of its current value, the distance calculated or the index (i) if it's the first person found. Update the last person index to the current index (i). Once the iteration is complete, return the maximum of `max_dist` and the distance between the last person and the end of the array.\n    "
    },
    {
        "id": 138,
        "title": "Reachable Nodes In Subdivided Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an undirected graph (the **\"original graph \"**) with `n` nodes labeled from `0` to `n - 1`. You decide to **subdivide** each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will **subdivide** the edge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo **subdivide** the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`, `[xcnti, vi]`.\n\nIn this **new graph**, you want to know how many nodes are **reachable** from the node `0`, where a node is **reachable** if the distance is `maxMoves` or less.\n\nGiven the original graph and `maxMoves`, return _the number of nodes that are **reachable** from node_ `0` _in the new graph_.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[0,1,10\\],\\[0,2,1\\],\\[1,2,2\\]\\], maxMoves = 6, n = 3\n**Output:** 13\n**Explanation:** The edge subdivisions are shown in the image above.\nThe nodes that are reachable are highlighted in yellow.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[0,1,4\\],\\[1,2,6\\],\\[0,2,8\\],\\[1,3,1\\]\\], maxMoves = 10, n = 4\n**Output:** 23\n\n",
                "**Example 3:**\n\n**Input:** edges = \\[\\[1,2,4\\],\\[1,4,5\\],\\[1,3,1\\],\\[2,3,4\\],\\[3,4,5\\]\\], maxMoves = 17, n = 5\n**Output:** 1\n**Explanation:** Node 0 is disconnected from the rest of the graph, so only node 0 is reachable."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= edges.length <= min(n * (n - 1) / 2, 104)`\n*   `edges[i].length == 3`\n*   `0 <= ui < vi < n`\n*   There are **no multiple edges** in the graph.\n*   `0 <= cnti <= 104`\n*   `0 <= maxMoves <= 109`\n*   `1 <= n <= 3000`",
            "follow_up": null
        },
        "tag": [
            "Graph",
            "Heap (Priority Queue)",
            "Shortest Path"
        ],
        "example": [
            {
                "input": "[[0,1,10],[0,2,1],[1,2,2]],6,3",
                "output": "13"
            },
            {
                "input": "[[0,1,4],[1,2,6],[0,2,8],[1,3,1]],10,4",
                "output": "23"
            },
            {
                "input": "[[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]],17,5",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int peakIndexInMountainArray(int[] arr) {\n    int low = 0, high = arr.length - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] < arr[mid + 1])\n            low = mid + 1;\n        else\n            high = mid;\n    }\n    return low;\n}\n```\n    \n    The algorithm uses a binary search approach to find the peak index in the mountain array. It starts with two pointers, `low` and `high`, initially set to the beginning and end of the array. In each iteration of the loop, it calculates the middle index as `mid = low + (high - low) / 2` (in Python, use integer division). If the middle element is smaller than the next one, we know the peak is to the right, so we update `low` to `mid + 1`. If not, the peak is to the left, and we update `high` to `mid`. The loop continues until `low` and `high` pointers meet, where the peak index is found and returned.\n    ",
        "python": "\n    ```python\ndef peakIndexInMountainArray(arr):\n    low, high = 0, len(arr) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n```\n    \n    The algorithm uses a binary search approach to find the peak index in the mountain array. It starts with two pointers, `low` and `high`, initially set to the beginning and end of the array. In each iteration of the loop, it calculates the middle index as `mid = low + (high - low) / 2` (in Python, use integer division). If the middle element is smaller than the next one, we know the peak is to the right, so we update `low` to `mid + 1`. If not, the peak is to the left, and we update `high` to `mid`. The loop continues until `low` and `high` pointers meet, where the peak index is found and returned.\n    ",
        "c++": "\n    ```cpp\nint peakIndexInMountainArray(vector<int>& arr) {\n    int low = 0, high = arr.size() - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] < arr[mid + 1])\n            low = mid + 1;\n        else\n            high = mid;\n    }\n    return low;\n}\n```\n    \n    The algorithm uses a binary search approach to find the peak index in the mountain array. It starts with two pointers, `low` and `high`, initially set to the beginning and end of the array. In each iteration of the loop, it calculates the middle index as `mid = low + (high - low) / 2` (in Python, use integer division). If the middle element is smaller than the next one, we know the peak is to the right, so we update `low` to `mid + 1`. If not, the peak is to the left, and we update `high` to `mid`. The loop continues until `low` and `high` pointers meet, where the peak index is found and returned.\n    ",
        "js": "\n    ```javascript\nfunction peakIndexInMountainArray(arr) {\n    let low = 0, high = arr.length - 1;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (arr[mid] < arr[mid + 1])\n            low = mid + 1;\n        else\n            high = mid;\n    }\n    return low;\n}\n```\n    \n    The algorithm uses a binary search approach to find the peak index in the mountain array. It starts with two pointers, `low` and `high`, initially set to the beginning and end of the array. In each iteration of the loop, it calculates the middle index as `mid = low + (high - low) / 2` (in Python, use integer division). If the middle element is smaller than the next one, we know the peak is to the right, so we update `low` to `mid + 1`. If not, the peak is to the left, and we update `high` to `mid`. The loop continues until `low` and `high` pointers meet, where the peak index is found and returned.\n    "
    },
    {
        "id": 139,
        "title": "Super Egg Drop",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nEach move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 1, n = 2\n**Output:** 2\n**Explanation:** \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n\n",
                "**Example 2:**\n\n**Input:** k = 2, n = 6\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** k = 3, n = 14\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "1,2",
                "output": "2"
            },
            {
                "input": "2,6",
                "output": "3"
            },
            {
                "input": "3,14",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n    int N = quality.length;\n    double[][] workers = new double[N][2];\n    for (int i = 0; i < N; ++i)\n        workers[i] = new double[] {(double) wage[i] / quality[i], (double) quality[i]};\n\n    Arrays.sort(workers, (a, b) -> Double.compare(a[0], b[0]));\n\n    double ans = 1e60;\n    int sumq = 0;\n    PriorityQueue<Integer> pool = new PriorityQueue<>((a, b) -> -Integer.compare(a, b));\n    for (double[] worker: workers) {\n        pool.offer((int) worker[1]);\n        sumq += worker[1];\n\n        if (pool.size() > K)\n            sumq -= pool.poll();\n\n        if (pool.size() == K)\n            ans = Math.min(ans, worker[0] * sumq);\n    }\n\n    return ans;\n}\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\ndouble mincostToHireWorkers(std::vector<int>& quality, std::vector<int>& wage, int k) {\n    std::vector<std::pair<double, int>> workers;\n    for (int i = 0; i < quality.size(); i++) {\n        workers.emplace_back((double)wage[i] / quality[i], quality[i]);\n    }\n    std::sort(workers.begin(), workers.end());\n    \n    int sum_quality = 0;\n    double result = 1e60;\n    std::priority_queue<int> pq;\n    \n    for (auto [ratio, q] : workers) {\n        sum_quality += q;\n        pq.push(q);\n        \n        if (pq.size() > k) {\n            sum_quality -= pq.top();\n            pq.pop();\n        }\n        \n        if (pq.size() == k) {\n            result = std::min(result, ratio * sum_quality);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    ",
        "js": "\n    ```javascript\nfunction mincostToHireWorkers(quality, wage, K) {\n    const workers = Array.from({length: quality.length}, (_, i) => [\n        wage[i] / quality[i], quality[i],\n    ]).sort((a, b) => a[0] - b[0]);\n\n    let sumQuality = 0;\n    const maxHeap = new MaxHeap(comparator);\n\n    let result = Infinity;\n    for (const [ratio, q] of workers) {\n        maxHeap.add(q);\n        sumQuality += q;\n\n        if (maxHeap.size() > K) {\n            sumQuality -= maxHeap.pop();\n        }\n\n        if (maxHeap.size() === K) {\n            result = Math.min(result, ratio * sumQuality);\n        }\n    }\n\n    return result;\n}\n\nclass MaxHeap {\n    constructor(comparator) {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n\n    add(value) {\n        this._heap.push(value);\n        this.bubbleUp(this.size() - 1);\n    }\n\n    pop() {\n        if (this.isEmpty()) return undefined;\n\n        this.swap(0, this.size() - 1);\n        const result = this._heap.pop();\n        this.bubbleDown(0);\n        return result;\n    }\n\n    size() {\n        return this._heap.length;\n    }\n\n    isEmpty() {\n        return this._heap.length === 0;\n    }\n\n    bubbleUp(index) {\n        const parent = this.parent(index);\n        if (parent >= 0 && this._compare(parent, index)) {\n            this.swap(parent, index);\n            this.bubbleUp(parent);\n        }\n    }\n\n    bubbleDown(index) {\n        const largest = this.maxChildIndex(index);\n        if (largest !== -1 && this._compare(index, largest)) {\n            this.swap(index, largest);\n            this.bubbleDown(largest);\n        }\n    }\n\n    parent(index) {\n        return index <= 0 ? -1 : Math.floor((index - 1) / 2);\n    }\n\n    maxChildIndex(index) {\n        const left = index * 2 + 1;\n        const right = index * 2 + 2;\n        if (left >= this.size()) return -1;\n\n        if (right >= this.size()) return left;\n\n        return this._compare(left, right) ? right : left;\n    }\n\n    swap(i, j) {\n        [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n    }\n\n    _compare(i, j) {\n        return this._comparator(this._heap[i], this._heap[j]);\n    }\n}\n\nfunction comparator(a, b) {\n    return a < b;\n}\n```\n    \n    We represent each worker as a pair of `(wage / quality, quality)`. We sort these workers based on the wage-to-quality ratio, making it easier to track the cost of hiring each worker. The algorithm maintains a priority queue, which is initially empty. The total quality sum starts at 0. \n\nWe iterate through the sorted workers, for each worker:\n1. Add their quality value to the max heap and increment the total quality sum.\n2. If max heap size is greater than `k`, we subtract the largest quality value from the sum and pop it from the max heap.\n3. If max heap size equals `k`, we update the result with the minimum of the current result and the product of the total quality sum and the current worker's wage-to-quality ratio.\n\nFinally, we return the lowest cost.\n    "
    },
    {
        "id": 140,
        "title": "Sum of Subsequence Widths",
        "difficulty": "Hard",
        "content": {
            "problem": "The **width** of a sequence is the difference between the maximum and minimum elements in the sequence.\n\nGiven an array of integers `nums`, return _the sum of the **widths** of all the non-empty **subsequences** of_ `nums`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,3\\]\n**Output:** 6\nExplanation: The subsequences are \\[1\\], \\[2\\], \\[3\\], \\[2,1\\], \\[2,3\\], \\[1,3\\], \\[2,1,3\\].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Sorting"
        ],
        "example": [
            {
                "input": "[2,1,3]",
                "output": "6\nExplanation:Thesubsequencesare[1],[2],[3],[2,1],[2,3],[1,3],[2,1,3].\nThecorrespondingwidthsare0,0,0,1,1,2,2.\nThesumofthesewidthsis6."
            },
            {
                "input": "[2]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int matrixScore(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    for (int i = 0; i < m; i++) {\n        if (grid[i][0] == 0) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    for (int j = 1; j < n; j++) {\n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            count += grid[i][j];\n        }\n        if (count <= m / 2) {\n            for (int i = 0; i < m; i++) {\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    int sum = 0;\n    for (int i = 0; i < m; i++) {\n        int num = 0;\n        for (int j = 0; j < n; j++) {\n            num = num * 2 + grid[i][j];\n        }\n        sum += num;\n    }\n    return sum;\n}\n```\n    \n    The algorithm begins by looping through each row and checking if the first element is 0. If it is, we toggle the row values to ensure the row starts with 1. This way, we maximize the values of the binary numbers represented by each row.\n\nNext, we loop through the columns (starting with the second), and for each column, we calculate the count of 1s. If the count is less than or equal to half the number of rows, we toggle the entire column.\n\nFinally, we loop through the modified grid again, summing up the binary numbers represented by each row to get the highest possible score.\n    ",
        "python": "\n    ```python\ndef matrixScore(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        if grid[i][0] == 0:\n            for j in range(n):\n                grid[i][j] = 1 - grid[i][j]\n    for j in range(1, n):\n        count = sum(grid[i][j] for i in range(m))\n        if count <= m // 2:\n            for i in range(m):\n                grid[i][j] = 1 - grid[i][j]\n    return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))\n```\n    \n    The algorithm begins by looping through each row and checking if the first element is 0. If it is, we toggle the row values to ensure the row starts with 1. This way, we maximize the values of the binary numbers represented by each row.\n\nNext, we loop through the columns (starting with the second), and for each column, we calculate the count of 1s. If the count is less than or equal to half the number of rows, we toggle the entire column.\n\nFinally, we loop through the modified grid again, summing up the binary numbers represented by each row to get the highest possible score.\n    ",
        "c++": "\n    ```cpp\nint matrixScore(std::vector<std::vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    for(int i = 0; i < m; i++) {\n        if(grid[i][0] == 0) {\n            for(int j = 0; j < n; j++) {\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    for(int j = 1; j < n; j++) {\n        int count = 0;\n        for(int i = 0; i < m; i++) {\n            count += grid[i][j];\n        }\n        if(count <= m / 2) {\n            for(int i = 0; i < m; i++) {\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    int sum = 0;\n    for(int i = 0; i < m; i++) {\n        int num = 0;\n        for(int j = 0; j < n; j++) {\n            num = num * 2 + grid[i][j];\n        }\n        sum += num;\n    }\n    return sum;\n}\n```\n    \n    The algorithm begins by looping through each row and checking if the first element is 0. If it is, we toggle the row values to ensure the row starts with 1. This way, we maximize the values of the binary numbers represented by each row.\n\nNext, we loop through the columns (starting with the second), and for each column, we calculate the count of 1s. If the count is less than or equal to half the number of rows, we toggle the entire column.\n\nFinally, we loop through the modified grid again, summing up the binary numbers represented by each row to get the highest possible score.\n    ",
        "js": "\n    ```javascript\nfunction matrixScore(grid) {\n    const m = grid.length, n = grid[0].length;\n    for (let i = 0; i < m; i++) {\n        if (grid[i][0] === 0) {\n            for (let j = 0; j < n; j++) {\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    for (let j = 1; j < n; j++) {\n        let count = 0;\n        for (let i = 0; i < m; i++) {\n            count += grid[i][j];\n        }\n        if (count <= m / 2) {\n            for (let i = 0; i < m; i++) {\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    let sum = 0;\n    for (let i = 0; i < m; i++) {\n        let num = 0;\n        for (let j = 0; j < n; j++) {\n            num = num * 2 + grid[i][j];\n        }\n        sum += num;\n    }\n    return sum;\n}\n```\n    \n    The algorithm begins by looping through each row and checking if the first element is 0. If it is, we toggle the row values to ensure the row starts with 1. This way, we maximize the values of the binary numbers represented by each row.\n\nNext, we loop through the columns (starting with the second), and for each column, we calculate the count of 1s. If the count is less than or equal to half the number of rows, we toggle the entire column.\n\nFinally, we loop through the modified grid again, summing up the binary numbers represented by each row to get the highest possible score.\n    "
    },
    {
        "id": 141,
        "title": "Maximum Frequency Stack",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n\nImplement the `FreqStack` class:\n\n*   `FreqStack()` constructs an empty frequency stack.\n*   `void push(int val)` pushes an integer `val` onto the top of the stack.\n*   `int pop()` removes and returns the most frequent element in the stack.\n    *   If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"FreqStack \",  \"push \",  \"push \",  \"push \",  \"push \",  \"push \",  \"push \",  \"pop \",  \"pop \",  \"pop \",  \"pop \"\\]\n\\[\\[\\], \\[5\\], \\[7\\], \\[5\\], \\[7\\], \\[4\\], \\[5\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, null, null, null, null, 5, 7, 5, 4\\]\n\n**Explanation**\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is \\[5\\]\nfreqStack.push(7); // The stack is \\[5,7\\]\nfreqStack.push(5); // The stack is \\[5,7,5\\]\nfreqStack.push(7); // The stack is \\[5,7,5,7\\]\nfreqStack.push(4); // The stack is \\[5,7,5,7,4\\]\nfreqStack.push(5); // The stack is \\[5,7,5,7,4,5\\]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes \\[5,7,5,7,4\\].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes \\[5,7,5,4\\].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes \\[5,7,4\\].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes \\[5,7\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= val <= 109`\n*   At most `2 * 104` calls will be made to `push` and `pop`.\n*   It is guaranteed that there will be at least one element in the stack before calling `pop`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Stack",
            "Design",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,null,null,null,null,5,7,5,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int shortestPathAllKeys(String[] grid) {\n    int m = grid.length, n = grid[0].length(), steps = 0, k = 0, x = -1, y = -1, mask = 0;\n    Queue<int[]> q = new LinkedList<>();\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i].charAt(j) == '@') {\n                x = i;\n                y = j;\n            } else if (grid[i].charAt(j) >= 'a' && grid[i].charAt(j) <= 'f') {\n                k = Math.max(k, grid[i].charAt(j) - 'a' + 1);\n            }\n        }\n    }\n    \n    q.add(new int[]{ x, y, 0 });\n    Set<String> visited = new HashSet<>();\n    visited.add(x + \",\" + y + \",\" + mask);\n    \n    int[][] dirs = { {-1, 0}, {1, 0}, {0, 1}, {0, -1} };\n    \n    while (!q.isEmpty()) {\n        int qs = q.size();\n        \n        for (int sz = 0; sz < qs; sz++) {\n            int[] cur = q.poll();\n            int x = cur[0], y = cur[1], mask = cur[2];\n            \n            if (mask == (1 << k) - 1) return steps;\n            \n            for (int[] dir : dirs) {\n                int nx = x + dir[0], ny = y + dir[1], nmask = mask;\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    char c = grid[nx].charAt(ny);\n                    if (c >= 'A' && c <= 'F' && (nmask & (1 << (c - 'A'))) == 0) continue;\n                    if (c >= 'a' && c <= 'f') nmask |= (1 << (c - 'a'));\n                    \n                    String key = nx + \",\" + ny + \",\" + nmask;\n                    \n                    if (visited.contains(key)) continue;\n                    \n                    visited.add(key);\n                    q.add(new int[]{ nx, ny, nmask });\n                }\n            }\n        }\n        \n        steps++;\n    }\n    \n    return -1;\n}\n```\n\n    \n    The algorithm utilizes BFS to traverse the grid. First, it starts by finding the starting position (marked as '@') in the given grid, and initializing the queue for the BFS. It also sets up a visited set to record positions that have been visited along with its key mask.\n\nFor each position (x, y) in the queue, we check if the current mask (number of keys collected so far) is equal to the all-keys mask. If so, we return the number of steps taken. Otherwise, we continue to attempt each possible moving direction, and if a move results in a valid or updated position, we add/update the new position, updated key mask, and the new position with updated key mask into the queue, visited set, and continue the BFS.\n\nWhen the BFS is exhausted, the algorithm returns -1, indicating no path capable of acquiring all keys.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef shortestPathAllKeys(grid):\n    m, n, steps, k, x, y, mask = len(grid), len(grid[0]), 0, 0, -1, -1, 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                x, y = i, j\n            elif 'a' <= grid[i][j] <= 'f':\n                k = max(k, ord(grid[i][j]) - ord('a') + 1)\n\n    q = deque([(x, y, 0)])\n    visited = {(x, y, mask)}\n\n    dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n\n    while q:\n        qs = len(q)\n        for sz in range(qs):\n            x, y, mask = q.popleft()\n\n            if mask == (1 << k) - 1:\n                return steps\n\n            for dx, dy in dirs:\n                nx, ny, nmask = x + dx, y + dy, mask\n\n                if 0 <= nx < m and 0 <= ny < n:\n                    c = grid[nx][ny]\n                    if 'A' <= c <= 'F' and not nmask & (1 << (ord(c) - ord('A'))):\n                        continue\n                    if 'a' <= c <= 'f':\n                        nmask |= (1 << (ord(c) - ord('a')))\n\n                    if (nx, ny, nmask) in visited:\n                        continue\n\n                    visited.add((nx, ny, nmask))\n                    q.append((nx, ny, nmask))\n\n        steps += 1\n\n    return -1\n```\n\n    \n    The algorithm utilizes BFS to traverse the grid. First, it starts by finding the starting position (marked as '@') in the given grid, and initializing the queue for the BFS. It also sets up a visited set to record positions that have been visited along with its key mask.\n\nFor each position (x, y) in the queue, we check if the current mask (number of keys collected so far) is equal to the all-keys mask. If so, we return the number of steps taken. Otherwise, we continue to attempt each possible moving direction, and if a move results in a valid or updated position, we add/update the new position, updated key mask, and the new position with updated key mask into the queue, visited set, and continue the BFS.\n\nWhen the BFS is exhausted, the algorithm returns -1, indicating no path capable of acquiring all keys.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <string>\n\nusing namespace std;\n\nint shortestPathAllKeys(vector<string>& grid) {\n    int m = grid.size(), n = grid[0].size(), steps = 0, k = 0, x = -1, y = -1, mask = 0;\n    queue<vector<int>> q;\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '@') {\n                x = i;\n                y = j;\n            } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {\n                k = max(k, grid[i][j] - 'a' + 1);\n            }\n        }\n    }\n    \n    q.push({ x, y, 0 });\n    unordered_set<string> visited;\n    visited.insert(to_string(x) + \",\" + to_string(y) + \",\" + to_string(mask));\n    \n    vector<vector<int>> dirs = { {-1, 0}, {1, 0}, {0, 1}, {0, -1} };\n    \n    while (!q.empty()) {\n        int qs = q.size();\n        \n        for (int sz = 0; sz < qs; sz++) {\n            vector<int> cur = q.front(); q.pop();\n            int x = cur[0], y = cur[1], mask = cur[2];\n            \n            if (mask == (1 << k) - 1) return steps;\n            \n            for (vector<int>& dir : dirs) {\n                int nx = x + dir[0], ny = y + dir[1], nmask = mask;\n                \n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    if (grid[nx][ny] >= 'A' && grid[nx][ny] <= 'F' && !(nmask & (1 << (grid[nx][ny] - 'A')))) continue;\n                    if (grid[nx][ny] >= 'a' && grid[nx][ny] <= 'f') nmask |= (1 << (grid[nx][ny] - 'a'));\n                    \n                    string key = to_string(nx) + \",\" + to_string(ny) + \",\" + to_string(nmask);\n                    \n                    if (visited.count(key)) continue;\n                    \n                    visited.insert(key);\n                    q.push({ nx, ny, nmask });\n                }\n            }\n        }\n        \n        steps++;\n    }\n    \n    return -1;\n}\n```\n\n    \n    The algorithm utilizes BFS to traverse the grid. First, it starts by finding the starting position (marked as '@') in the given grid, and initializing the queue for the BFS. It also sets up a visited set to record positions that have been visited along with its key mask.\n\nFor each position (x, y) in the queue, we check if the current mask (number of keys collected so far) is equal to the all-keys mask. If so, we return the number of steps taken. Otherwise, we continue to attempt each possible moving direction, and if a move results in a valid or updated position, we add/update the new position, updated key mask, and the new position with updated key mask into the queue, visited set, and continue the BFS.\n\nWhen the BFS is exhausted, the algorithm returns -1, indicating no path capable of acquiring all keys.\n    ",
        "js": "\n    ```javascript\nfunction shortestPathAllKeys(grid) {\n    const m = grid.length, n = grid[0].length;\n    let steps = 0, k = 0, x = -1, y = -1, mask = 0;\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '@') {\n                x = i;\n                y = j;\n            } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {\n                k = Math.max(k, grid[i][j].charCodeAt() - 'a'.charCodeAt() + 1);\n            }\n        }\n    }\n    \n    const q = [[x, y, 0]];\n    const visited = new Set([`${x},${y},${mask}`]);\n    \n    const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n    \n    while (q.length) {\n        const qs = q.length;\n        \n        for (let sz = 0; sz < qs; sz++) {\n            const [x, y, mask] = q.shift();\n            \n            if (mask === (1 << k) - 1) return steps;\n            \n            dirs.forEach(([dx, dy]) => {\n                const nx = x + dx, ny = y + dy;\n                let nmask = mask;\n                \n                if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                    const c = grid[nx][ny];\n                    if (c >= 'A' && c <= 'F' && (nmask & (1 << (c.charCodeAt() - 'A'.charCodeAt()))) === 0) return;\n                    if (c >= 'a' && c <= 'f') nmask |= (1 << (c.charCodeAt() - 'a'.charCodeAt()));\n                    \n                    const key = `${nx},${ny},${nmask}`;\n                    \n                    if (visited.has(key)) return;\n                    \n                    visited.add(key);\n                    q.push([nx, ny, nmask]);\n                }\n            });\n        }\n        \n        steps++;\n    }\n    \n    return -1;\n}\n```\n\n    \n    The algorithm utilizes BFS to traverse the grid. First, it starts by finding the starting position (marked as '@') in the given grid, and initializing the queue for the BFS. It also sets up a visited set to record positions that have been visited along with its key mask.\n\nFor each position (x, y) in the queue, we check if the current mask (number of keys collected so far) is equal to the all-keys mask. If so, we return the number of steps taken. Otherwise, we continue to attempt each possible moving direction, and if a move results in a valid or updated position, we add/update the new position, updated key mask, and the new position with updated key mask into the queue, visited set, and continue the BFS.\n\nWhen the BFS is exhausted, the algorithm returns -1, indicating no path capable of acquiring all keys.\n    "
    },
    {
        "id": 142,
        "title": "Orderly Queue",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` and an integer `k`. You can choose one of the first `k` letters of `s` and append it at the end of the string..\n\nReturn _the lexicographically smallest string you could have after applying the mentioned step any number of moves_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"cba \", k = 1\n**Output:**  \"acb \"\n**Explanation:** \nIn the first move, we move the 1st character 'c' to the end, obtaining the string  \"bac \".\nIn the second move, we move the 1st character 'b' to the end, obtaining the final result  \"acb \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"baaca \", k = 3\n**Output:**  \"aaabc \"\n**Explanation:** \nIn the first move, we move the 1st character 'b' to the end, obtaining the string  \"aacab \".\nIn the second move, we move the 3rd character 'c' to the end, obtaining the final result  \"aaabc \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= s.length <= 1000`\n*   `s` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"cba\",1",
                "output": "\"acb\""
            },
            {
                "input": "\"baaca\",3",
                "output": "\"aaabc\""
            }
        ],
        "java": "\n    ```java\nint longestDistance(int n) {\n    int last = -1, longest = 0;\n    for (int i = 0; n > 0; n >>= 1, i++) {\n        if ((n & 1) == 1) {\n            if (last >= 0)\n                longest = Math.max(longest, i - last);\n            last = i;\n        }\n    }\n    return longest;\n}\n```\n    \n    The algorithm iterates through the bits of the integer `n` using bitwise operations. It keeps track of the position of the last encountered 1 and calculates the distance between the current 1 and the last 1, updating the longest distance if necessary. If two consecutive 1's are found, it updates the last 1's position with the current position.\n\n1. Initialize `last` to -1 and `longest` to 0.\n2. Iterate through the binary representation of `n` (by shifting n right by 1)\n   a. If the current bit is 1:\n      i. If `last` is not -1, calculate the distance between the current bit position and the last position of 1 and update `longest` with the maximum of current `longest` value and calculated distance.\n      ii. Update `last` with the current position i.\n3. Return `longest`.\n    ",
        "python": "\n    ```python\ndef longest_distance(n):\n    last = -1\n    longest = 0\n    i = 0\n    while n:\n        if n & 1:\n            if last >= 0:\n                longest = max(longest, i - last)\n            last = i\n        n >>= 1\n        i += 1\n    return longest\n```\n    \n    The algorithm iterates through the bits of the integer `n` using bitwise operations. It keeps track of the position of the last encountered 1 and calculates the distance between the current 1 and the last 1, updating the longest distance if necessary. If two consecutive 1's are found, it updates the last 1's position with the current position.\n\n1. Initialize `last` to -1 and `longest` to 0.\n2. Iterate through the binary representation of `n` (by shifting n right by 1)\n   a. If the current bit is 1:\n      i. If `last` is not -1, calculate the distance between the current bit position and the last position of 1 and update `longest` with the maximum of current `longest` value and calculated distance.\n      ii. Update `last` with the current position i.\n3. Return `longest`.\n    ",
        "c++": "\n    ```cpp\nint longest_distance(int n) {\n    int last = -1, longest = 0;\n    for (int i = 0; n > 0; n >>= 1, i++) {\n        if (n & 1) {\n            if (last >= 0)\n                longest = std::max(longest, i - last);\n            last = i;\n        }\n    }\n    return longest;\n}\n```\n    \n    The algorithm iterates through the bits of the integer `n` using bitwise operations. It keeps track of the position of the last encountered 1 and calculates the distance between the current 1 and the last 1, updating the longest distance if necessary. If two consecutive 1's are found, it updates the last 1's position with the current position.\n\n1. Initialize `last` to -1 and `longest` to 0.\n2. Iterate through the binary representation of `n` (by shifting n right by 1)\n   a. If the current bit is 1:\n      i. If `last` is not -1, calculate the distance between the current bit position and the last position of 1 and update `longest` with the maximum of current `longest` value and calculated distance.\n      ii. Update `last` with the current position i.\n3. Return `longest`.\n    ",
        "js": "\n    ```javascript\nfunction longestDistance(n) {\n    let last = -1, longest = 0;\n    for (let i = 0; n > 0; n >>= 1, i++) {\n        if (n & 1) {\n            if (last >= 0)\n                longest = Math.max(longest, i - last);\n            last = i;\n        }\n    }\n    return longest;\n}\n```\n    \n    The algorithm iterates through the bits of the integer `n` using bitwise operations. It keeps track of the position of the last encountered 1 and calculates the distance between the current 1 and the last 1, updating the longest distance if necessary. If two consecutive 1's are found, it updates the last 1's position with the current position.\n\n1. Initialize `last` to -1 and `longest` to 0.\n2. Iterate through the binary representation of `n` (by shifting n right by 1)\n   a. If the current bit is 1:\n      i. If `last` is not -1, calculate the distance between the current bit position and the last position of 1 and update `longest` with the maximum of current `longest` value and calculated distance.\n      ii. Update `last` with the current position i.\n3. Return `longest`.\n    "
    },
    {
        "id": 143,
        "title": "Numbers At Most N Given Digit Set",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of `digits` which is sorted in **non-decreasing** order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.\n\nReturn _the number of positive integers that can be generated_ that are less than or equal to a given integer `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits = \\[ \"1 \", \"3 \", \"5 \", \"7 \"\\], n = 100\n**Output:** 20\n**Explanation:** \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n",
                "**Example 2:**\n\n**Input:** digits = \\[ \"1 \", \"4 \", \"9 \"\\], n = 1000000000\n**Output:** 29523\n**Explanation:** \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\n",
                "**Example 3:**\n\n**Input:** digits = \\[ \"7 \"\\], n = 8\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= digits.length <= 9`\n*   `digits[i].length == 1`\n*   `digits[i]` is a digit from `'1'` to `'9'`.\n*   All the values in `digits` are **unique**.\n*   `digits` is sorted in **non-decreasing** order.\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "String",
            "Binary Search",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[\"1\",\"3\",\"5\",\"7\"],100",
                "output": "20"
            },
            {
                "input": "[\"1\",\"4\",\"9\"],1000000000",
                "output": "29523"
            },
            {
                "input": "[\"7\"],8",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\n    int i = 0, stops = 0, curFuel = startFuel;\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    while (curFuel < target) {\n        while (i < stations.length && stations[i][0] <= curFuel) {\n            pq.offer(stations[i][1]);\n            i++;\n        }\n        if (pq.isEmpty()) return -1;\n        curFuel += pq.poll();\n        stops++;\n    }\n    return stops;\n}\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int:\n    i, stops, curFuel = 0, 0, startFuel\n    pq = []\n    while curFuel < target:\n        while i < len(stations) and stations[i][0] <= curFuel:\n            heapq.heappush(pq, -stations[i][1])\n            i += 1\n        if not pq: return -1\n        curFuel += -heapq.heappop(pq)\n        stops += 1\n    return stops\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\n    int i = 0, stops = 0, curFuel = startFuel;\n    priority_queue<int> pq;\n    while (curFuel < target) {\n        while (i < stations.size() && stations[i][0] <= curFuel) {\n            pq.push(stations[i][1]);\n            i++;\n        }\n        if (pq.empty()) return -1;\n        curFuel += pq.top();\n        pq.pop();\n        stops++;\n    }\n    return stops;\n}\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    ",
        "js": "\n    ```javascript\nfunction minRefuelStops(target, startFuel, stations) {\n    let i = 0, stops = 0, curFuel = startFuel;\n    let pq = new PriorityQueue((a, b) => b - a);\n    while (curFuel < target) {\n        while (i < stations.length && stations[i][0] <= curFuel) {\n            pq.offer(stations[i][1]);\n            i++;\n        }\n        if (pq.isEmpty()) return -1;\n        curFuel += pq.poll();\n        stops++;\n    }\n    return stops;\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this._heap = [];\n        this._comparator = comparator || ((a, b) => a - b);\n    }\n    size() {\n        return this._heap.length;\n    }\n    isEmpty() {\n        return this.size() == 0;\n    }\n    peek() {\n        return this._heap[0];\n    }\n    offer(value) {\n        this._heap.push(value);\n        this._siftUp();\n    }\n    poll() {\n        const head = this.peek();\n        this._heap[0] = this._heap.pop();\n        this._siftDown();\n        return head;\n    }\n    _parent(idx) {\n        return Math.floor((idx - 1) / 2);\n    }\n    _left(idx) {\n        return idx * 2 + 1;\n    }\n    _right(idx) {\n        return idx * 2 + 2;\n    }\n    _siftUp() {\n        let node = this.size() - 1;\n\n        while (node > 0 && this._comparator(this._heap[node], this._heap[this._parent(node)]) < 0) {\n            [this._heap[node], this._heap[this._parent(node)]] = [this._heap[this._parent(node)], this._heap[node]];\n            node = this._parent(node);\n        }\n    }\n    _siftDown() {\n        let node = 0;\n        while ((this._left(node) < this.size() && this._comparator(this._heap[this._left(node)], this._heap[node]) < 0) ||\n            (this._right(node) < this.size() && this._comparator(this._heap[this._right(node)], this._heap[node]) < 0)) {\n                \n            let minChild = this._left(node);\n            if (this._right(node) < this.size() && this._comparator(this._heap[this._right(node)], this._heap[this._left(node)]) < 0) {\n                minChild = this._right(node);\n            }\n\n            [this._heap[node], this._heap[minChild]] = [this._heap[minChild], this._heap[node]];\n            node = minChild;\n        }\n    }\n}\n```\n\n    \n    1. Initialize a variable `stops` to store the number of refueling stops made, `curFuel` to save the current fuel, and a max heap (priority queue) `pq` to store the gas station capacities encountered along the way.\n2. While `curFuel` is not sufficient to reach the target, perform the following steps:\n   a. Loop through the gas stations that can be reached from the current fuel, add their fuel capacity to the priority queue, and increment the station index.\n   b. If the priority queue is empty, it means no gas station can be reached, so return -1.\n   c. Add the maximum fuel capacity from the priority queue (the top value) to the `curFuel` and remove it from the priority queue.\n   d. Increment the `stops` variable.\n3. When the loop ends and the car has enough `curFuel` to reach the target, return the number of `stops`.\n    "
    },
    {
        "id": 144,
        "title": "Valid Permutations for DI Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` of length `n` where `s[i]` is either:\n\n*   `'D'` means decreasing, or\n*   `'I'` means increasing.\n\nA permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` is called a **valid permutation** if for all valid `i`:\n\n*   If `s[i] == 'D'`, then `perm[i] > perm[i + 1]`, and\n*   If `s[i] == 'I'`, then `perm[i] < perm[i + 1]`.\n\nReturn _the number of **valid permutations**_ `perm`. Since the answer may be large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"DID \"\n**Output:** 5\n**Explanation:** The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\n",
                "**Example 2:**\n\n**Input:** s =  \"D \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == s.length`\n*   `1 <= n <= 200`\n*   `s[i]` is either `'I'` or `'D'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "\"DID\"",
                "output": "5"
            },
            {
                "input": "\"D\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int rand7(); // Given API\n\npublic int rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    ",
        "python": "\n    ```python\ndef rand7(): # Given API\n    pass\n\ndef rand10():\n    result = 41\n    while result > 40:\n        result = (rand7() - 1) * 7 + rand7()\n    return result % 10 + 1\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    ",
        "c++": "\n    ```cpp\nint rand7(); // Given API\n\nint rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    ",
        "js": "\n    ```javascript\nfunction rand7() {} // Given API\n\nfunction rand10() {\n    let result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n```\n    \n    The algorithm is based on generating a uniform random integer in the range of [1, 49] using the given rand7() API by the following formula:\n\n`result = (rand7() - 1) * 7 + rand7()`\n\nSince rand7() generates a number between 1 and 7, `(rand7() - 1) * 7` generates multiples of 7 ranging from 0 to 42. By adding another rand7(), we fill in the gaps to create a uniformly random number between 1 and 49.\n\nHowever, we need to generate a number in the range of [1, 10]. To do this, we can discard any numbers greater than 40 (since 40 is the largest multiple of 10 within the generated range) and use the modulo operator to convert the range from [1, 40] to [1, 10].\n\n`result % 10 + 1`\n\nWe repeat the process in a loop until we get a number in the range of [1, 40], following which we apply the modulo operator and return the final result. This ensures a uniform distribution of random integers in the [1, 10] range.\n    "
    },
    {
        "id": 145,
        "title": "Super Palindromes",
        "difficulty": "Hard",
        "content": {
            "problem": "Let's say a positive integer is a **super-palindrome** if it is a palindrome, and it is also the square of a palindrome.\n\nGiven two positive integers `left` and `right` represented as strings, return _the number of **super-palindromes** integers in the inclusive range_ `[left, right]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** left =  \"4 \", right =  \"1000 \"\n**Output:** 4\n**Explanation**: 4, 9, 121, and 484 are superpalindromes.\nNote that 676 is not a superpalindrome: 26 \\* 26 = 676, but 26 is not a palindrome.\n\n",
                "**Example 2:**\n\n**Input:** left =  \"1 \", right =  \"2 \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left.length, right.length <= 18`\n*   `left` and `right` consist of only digits.\n*   `left` and `right` cannot have leading zeros.\n*   `left` and `right` represent integers in the range `[1, 1018 - 1]`.\n*   `left` is less than or equal to `right`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration"
        ],
        "example": [
            {
                "input": "\"4\",\"1000\"",
                "output": "4"
            },
            {
                "input": "\"1\",\"2\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int robotSim(int[] commands, int[][] obstacles) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        int x = 0, y = 0, di = 0;\n        \n        Set<Long> obstacleSet = new HashSet<>();\n        for (int[] obstacle : obstacles) {\n            long ox = (long) obstacle[0] + 30000;\n            long oy = (long) obstacle[1] + 30000;\n            obstacleSet.add((ox << 16) + oy);\n        }\n        \n        int ans = 0;\n        for (int cmd : commands) {\n            if (cmd == -2) {\n                di = (di + 3) % 4;\n            } else if (cmd == -1) {\n                di = (di + 1) % 4;\n            } else {\n                for (int k = 0; k < cmd; k++) {\n                    int nx = x + dx[di];\n                    int ny = y + dy[di];\n                    long code = (((long) nx + 30000) << 16) + ((long) ny + 30000);\n                    \n                    if (!obstacleSet.contains(code)) {\n                        x = nx;\n                        y = ny;\n                        ans = Math.max(ans, x * x + y * y);\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n\n    \n    The algorithm consists of simulating the robot's movements for each command, while keeping track of its position, direction, and obstacles. If the command is to turn left or right, the direction is updated accordingly. If the command is to move straight, the robot moves one unit at a time in its current direction unless it is blocked by an obstacle. We use a set to store the obstacle locations (In Javascript, we use bitwise operations to encode the location in a single number). \n\nWe compute the Euclidean square distance (x^2 + y^2) every time the robot moves successfully and update the maximum distance found so far. After executing all commands, the maximum distance is returned.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n\n        ans = 0\n        for cmd in commands:\n            if cmd == -2:\n                di = (di - 1) % 4\n            elif cmd == -1:\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    nx = x + dx[di]\n                    ny = y + dy[di]\n                    if (nx, ny) not in obstacleSet:\n                        x = nx\n                        y = ny\n                        ans = max(ans, x * x + y * y)\n\n        return ans\n```\n\n    \n    The algorithm consists of simulating the robot's movements for each command, while keeping track of its position, direction, and obstacles. If the command is to turn left or right, the direction is updated accordingly. If the command is to move straight, the robot moves one unit at a time in its current direction unless it is blocked by an obstacle. We use a set to store the obstacle locations (In Javascript, we use bitwise operations to encode the location in a single number). \n\nWe compute the Euclidean square distance (x^2 + y^2) every time the robot moves successfully and update the maximum distance found so far. After executing all commands, the maximum distance is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nint robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    int x = 0, y = 0, di = 0;\n\n    set<pair<int, int>> obstacleSet;\n    for (vector<int> obstacle : obstacles)\n        obstacleSet.insert(make_pair(obstacle[0], obstacle[1]));\n\n    int ans = 0;\n    for (int cmd : commands) {\n        if (cmd == -2) {\n            di = (di + 3) % 4;\n        } else if (cmd == -1) {\n            di = (di + 1) % 4;\n        } else {\n            for (int k = 0; k < cmd; ++k) {\n                int nx = x + dx[di];\n                int ny = y + dy[di];\n                if (!obstacleSet.count(make_pair(nx, ny))) {\n                    x = nx;\n                    y = ny;\n                    ans = max(ans, x * x + y * y);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    The algorithm consists of simulating the robot's movements for each command, while keeping track of its position, direction, and obstacles. If the command is to turn left or right, the direction is updated accordingly. If the command is to move straight, the robot moves one unit at a time in its current direction unless it is blocked by an obstacle. We use a set to store the obstacle locations (In Javascript, we use bitwise operations to encode the location in a single number). \n\nWe compute the Euclidean square distance (x^2 + y^2) every time the robot moves successfully and update the maximum distance found so far. After executing all commands, the maximum distance is returned.\n    ",
        "js": "\n    ```javascript\nvar robotSim = function(commands, obstacles) {\n    let dx = [0, 1, 0, -1];\n    let dy = [1, 0, -1, 0];\n    let x = 0, y = 0, di = 0;\n    \n    let obsSet = new Set();\n    obstacles.forEach(([ox, oy]) => {\n        obsSet.add((ox + 30000) << 16 | (oy + 30000));\n    });\n    \n    let ans = 0;\n    \n    commands.forEach(cmd => {\n        if (cmd == -2) {\n            di = (di + 3) % 4;\n        } else if (cmd == -1) {\n            di = (di + 1) % 4;\n        } else {\n            for (let k = 0; k < cmd; k++) {\n                let nx = x + dx[di];\n                let ny = y + dy[di];\n                let code = (((nx + 30000) << 16) | (ny + 30000));\n                \n                if (!obsSet.has(code)) {\n                    x = nx;\n                    y = ny;\n                    ans = Math.max(ans, x * x + y * y);\n                }\n            }\n        }\n    });\n    \n    return ans;\n};\n```\n\n    \n    The algorithm consists of simulating the robot's movements for each command, while keeping track of its position, direction, and obstacles. If the command is to turn left or right, the direction is updated accordingly. If the command is to move straight, the robot moves one unit at a time in its current direction unless it is blocked by an obstacle. We use a set to store the obstacle locations (In Javascript, we use bitwise operations to encode the location in a single number). \n\nWe compute the Euclidean square distance (x^2 + y^2) every time the robot moves successfully and update the maximum distance found so far. After executing all commands, the maximum distance is returned.\n    "
    },
    {
        "id": 146,
        "title": "Cat and Mouse",
        "difficulty": "Hard",
        "content": {
            "problem": "A game on an **undirected** graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.\n\nDuring each player's turn, they **must** travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it **must** travel to any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n*   If ever the Cat occupies the same node as the Mouse, the Cat wins.\n*   If ever the Mouse reaches the Hole, the Mouse wins.\n*   If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n*   `1` if the mouse wins the game,\n*   `2` if the cat wins the game, or\n*   `0` if the game is a draw.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[2,5\\],\\[3\\],\\[0,4,5\\],\\[1,4,5\\],\\[2,3\\],\\[0,2,3\\]\\]\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0\\],\\[3\\],\\[0,2\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= graph.length <= 50`\n*   `1 <= graph[i].length < graph.length`\n*   `0 <= graph[i][j] < graph.length`\n*   `graph[i][j] != i`\n*   `graph[i]` is unique.\n*   The mouse and the cat can always move.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Game Theory"
        ],
        "example": [
            {
                "input": "[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]",
                "output": "0"
            },
            {
                "input": "[[1,3],[0],[3],[0,2]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Random;\n\nclass Solution {\n    private int[][] grid;\n    private int zeroCount;\n    private final Random rng = new Random();\n\n    public Solution(int m, int n) {\n        this.grid = new int[m][n];\n        this.zeroCount = m * n;\n    }\n\n    public int[] pick() {\n        int index = rng.nextInt(zeroCount);\n\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 0) {\n                    if (index == 0) {\n                        grid[i][j] = 1;\n                        zeroCount--;\n                        return new int[]{i, j};\n                    }\n                    index--;\n                }\n            }\n        }\n        return new int[]{-1, -1};  // Should not happen\n    }\n}\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    ",
        "python": "\n    ```python\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.grid = [[0] * n for _ in range(m)]\n        self.zero_count = m * n\n\n    def pick(self):\n        index = random.randrange(self.zero_count)\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                if cell == 0:\n                    if index == 0:\n                        self.grid[i][j] = 1\n                        self.zero_count -= 1\n                        return (i, j)\n                    index -= 1\n        return (-1, -1)  # Should not happen\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    Solution(int m, int n) : _grid(m, std::vector<int>(n, 0)), _zero_count(m * n), _rng(std::random_device{}()) {}\n\n    std::pair<int, int> pick() {\n        std::uniform_int_distribution<int> dist(0, _zero_count - 1);\n        int index = dist(_rng);\n\n        for (int i = 0; i < _grid.size(); ++i) {\n            for (int j = 0; j < _grid[0].size(); ++j) {\n                if (_grid[i][j] == 0) {\n                    if (index == 0) {\n                        _grid[i][j] = 1;\n                        --_zero_count;\n                        return {i, j};\n                    }\n                    --index;\n                }\n            }\n        }\n        return {-1, -1};  // Should not happen\n    }\n\nprivate:\n    std::vector<std::vector<int>> _grid;\n    int _zero_count;\n    std::mt19937 _rng;\n};\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    ",
        "js": "\n    ```javascript\nclass Solution {\n    constructor(m, n) {\n        this.grid = new Array(m).fill(0).map(() => new Array(n).fill(0));\n        this.zeroCount = m * n;\n    }\n\n    pick() {\n        let index = Math.floor(Math.random() * this.zeroCount);\n\n        for (let i = 0; i < this.grid.length; i++) {\n            for (let j = 0; j < this.grid[0].length; j++) {\n                if (this.grid[i][j] === 0) {\n                    if (index === 0) {\n                        this.grid[i][j] = 1;\n                        this.zeroCount--;\n                        return [i, j];\n                    }\n                    index--;\n                }\n            }\n        }\n        return [-1, -1];  // Should not happen\n    }\n}\n```\n    \n    The algorithm initializes an m x n grid with all 0s and keeps track of the count of 0s (`_zero_count`). When the `pick()` function is called, it generates a random number between 0 and `zero_count - 1`. Then, it iterates over the grid elements, skipping the 1s. When it encounters a 0, it checks if the random index equals 0. If so, it flips the value to 1, decrements the zero count, and returns the current index. Otherwise, it decrements the random index value. This process ensures that each unfilled index has an equal chance of being picked.\n\nThe code is language-specific due to the random number generation mechanism and the classes/constructors used. However, the core algorithm remains the same across all languages. The time complexity is O(mn) as the function iterates through the entire grid. The space complexity is O(mn), as it stores the matrix. The usage of the built-in random function is minimized as it is called only once for each pick operation.\n    "
    },
    {
        "id": 147,
        "title": "Number of Music Playlists",
        "difficulty": "Hard",
        "content": {
            "problem": "Your music player contains `n` different songs. You want to listen to `goal` songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n*   Every song is played **at least once**.\n*   A song can only be played again only if `k` other songs have been played.\n\nGiven `n`, `goal`, and `k`, return _the number of possible playlists that you can create_. Since the answer can be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, goal = 3, k = 1\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 2, 3\\], \\[1, 3, 2\\], \\[2, 1, 3\\], \\[2, 3, 1\\], \\[3, 1, 2\\], and \\[3, 2, 1\\].\n\n",
                "**Example 2:**\n\n**Input:** n = 2, goal = 3, k = 0\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 1, 2\\], \\[1, 2, 1\\], \\[2, 1, 1\\], \\[2, 2, 1\\], \\[2, 1, 2\\], and \\[1, 2, 2\\].\n\n",
                "**Example 3:**\n\n**Input:** n = 2, goal = 3, k = 1\n**Output:** 2\n**Explanation:** There are 2 possible playlists: \\[1, 2, 1\\] and \\[2, 1, 2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= k < n <= goal <= 100`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "3,3,1",
                "output": "6"
            },
            {
                "input": "2,3,0",
                "output": "6"
            },
            {
                "input": "2,3,1",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<String> uncommonFromSentences(String s1, String s2) {\n    Map<String, Integer> wordCount = new HashMap<>();\n    for (String word : (s1 + \" \" + s2).split(\" \")) {\n        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n    }\n\n    List<String> result = new ArrayList<>();\n    for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {\n        if (entry.getValue() == 1) {\n            result.add(entry.getKey());\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    ",
        "python": "\n    ```python\ndef uncommon_from_sentences(s1, s2):\n    word_count = {}\n    for word in (s1 + \" \" + s2).split():\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return [key for key, val in word_count.items() if val == 1]\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nstd::vector<std::string> uncommonFromSentences(std::string s1, std::string s2) {\n    std::unordered_map<std::string, int> word_count;\n    std::istringstream is(s1 + ' ' + s2);\n    std::string word;\n\n    while (is >> word) {\n        word_count[word]++;\n    }\n\n    std::vector<std::string> result;\n    for (const auto &pair : word_count) {\n        if (pair.second == 1) {\n            result.push_back(pair.first);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    ",
        "js": "\n    ```javascript\nfunction uncommonFromSentences(s1, s2) {\n    const wordCount = new Map();\n    const words = (s1 + \" \" + s2).split(\" \");\n    \n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n\n    const result = [];\n    for (const [key, value] of wordCount.entries()) {\n        if (value === 1) {\n            result.push(key);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Create a hash map called `word_count` to store the word count of each word.\n2. Concatenate `s1` and `s2` separated by a space and split the string into words.\n3. Iterate through each word and update the value in the `wordCount` hash map.\n4. Create a list (Java: ArrayList, Python: list, JavaScript: array) called `result`.\n5. Iterate through each key-value pair in `wordCount`, and if the value is 1, push the key (the word) into `result`.\n6. Return `result`.\n\nThe time complexity of the algorithm is O(N) where N is the number of words in both sentences. The space complexity is also O(N) for storing the hash map and the result list.\n    "
    },
    {
        "id": 148,
        "title": "Minimize Malware Spread",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.\n\nSome nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove **exactly one node** from `initial`.\n\nReturn the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with **the smallest index**.\n\nNote that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[1,1,0\\],\\[0,0,1\\]\\], initial = \\[0,1\\]\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1,0,0\\],\\[0,1,0\\],\\[0,0,1\\]\\], initial = \\[0,2\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** graph = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], initial = \\[1,2\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == graph.length`\n*   `n == graph[i].length`\n*   `2 <= n <= 300`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][j] == graph[j][i]`\n*   `graph[i][i] == 1`\n*   `1 <= initial.length <= n`\n*   `0 <= initial[i] <= n - 1`\n*   All the integers in `initial` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "[[1,1,0],[1,1,0],[0,0,1]],[0,1]",
                "output": "0"
            },
            {
                "input": "[[1,0,0],[0,1,0],[0,0,1]],[0,2]",
                "output": "0"
            },
            {
                "input": "[[1,1,1],[1,1,1],[1,1,1]],[1,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n    int aliceTotal = 0, bobTotal = 0;\n    for (int candy : aliceSizes) aliceTotal += candy;\n    for (int candy : bobSizes) bobTotal += candy;\n\n    int delta = (bobTotal - aliceTotal) / 2;\n    for (int a : aliceSizes) {\n        for (int b : bobSizes) {\n            if (a + delta == b) {\n                return new int[]{a, b};\n            }\n        }\n    }\n    return new int[]{};\n}\n```\n    \n    1. Calculate the total number of candies for both Alice and Bob by summing their respective arrays.\n2. Calculate the difference between their totals divided by 2. This will be the amount needed to balance their candies after the swap.\n3. Iterate over both arrays (nested loop), and if a value from Alice's array plus the calculated difference equals a value from Bob's array, return the pair as the answer. This is because swapping these two boxes would result in equal total candies for both.\n4. If no such pair is found (which is not possible as per the given problem statement), return an empty array or list based on the language.\n    ",
        "python": "\n    ```python\ndef fair_candy_swap(aliceSizes, bobSizes):\n    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)\n    delta = (bobTotal - aliceTotal) // 2\n    for a in aliceSizes:\n        for b in bobSizes:\n            if a + delta == b:\n                return [a, b]\n    return []\n```\n    \n    1. Calculate the total number of candies for both Alice and Bob by summing their respective arrays.\n2. Calculate the difference between their totals divided by 2. This will be the amount needed to balance their candies after the swap.\n3. Iterate over both arrays (nested loop), and if a value from Alice's array plus the calculated difference equals a value from Bob's array, return the pair as the answer. This is because swapping these two boxes would result in equal total candies for both.\n4. If no such pair is found (which is not possible as per the given problem statement), return an empty array or list based on the language.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> fairCandySwap(std::vector<int>& aliceSizes, std::vector<int>& bobSizes) {\n    int aliceTotal = 0, bobTotal = 0;\n    for (int candy : aliceSizes) aliceTotal += candy;\n    for (int candy : bobSizes) bobTotal += candy;\n\n    int delta = (bobTotal - aliceTotal) / 2;\n    for (int a : aliceSizes) {\n        for (int b : bobSizes) {\n            if (a + delta == b) {\n                return {a, b};\n            }\n        }\n    }\n    return {};\n}\n```\n    \n    1. Calculate the total number of candies for both Alice and Bob by summing their respective arrays.\n2. Calculate the difference between their totals divided by 2. This will be the amount needed to balance their candies after the swap.\n3. Iterate over both arrays (nested loop), and if a value from Alice's array plus the calculated difference equals a value from Bob's array, return the pair as the answer. This is because swapping these two boxes would result in equal total candies for both.\n4. If no such pair is found (which is not possible as per the given problem statement), return an empty array or list based on the language.\n    ",
        "js": "\n    ```javascript\nfunction fairCandySwap(aliceSizes, bobSizes) {\n    const aliceTotal = aliceSizes.reduce((a, b) => a + b, 0);\n    const bobTotal = bobSizes.reduce((a, b) => a + b, 0);\n\n    const delta = (bobTotal - aliceTotal) / 2;\n    for (const a of aliceSizes) {\n        for (const b of bobSizes) {\n            if (a + delta === b) {\n                return [a, b];\n            }\n        }\n    }\n    return [];\n}\n```\n    \n    1. Calculate the total number of candies for both Alice and Bob by summing their respective arrays.\n2. Calculate the difference between their totals divided by 2. This will be the amount needed to balance their candies after the swap.\n3. Iterate over both arrays (nested loop), and if a value from Alice's array plus the calculated difference equals a value from Bob's array, return the pair as the answer. This is because swapping these two boxes would result in equal total candies for both.\n4. If no such pair is found (which is not possible as per the given problem statement), return an empty array or list based on the language.\n    "
    },
    {
        "id": 149,
        "title": "Three Equal Parts",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `arr` which consists of only zeros and ones, divide the array into **three non-empty parts** such that all of these parts represent the same binary value.\n\nIf it is possible, return any `[i, j]` with `i + 1 < j`, such that:\n\n*   `arr[0], arr[1], ..., arr[i]` is the first part,\n*   `arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and\n*   `arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.\n*   All three parts have equal binary values.\n\nIf it is not possible, return `[-1, -1]`.\n\nNote that the entire part is used when considering what binary value it represents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also, leading zeros **are allowed**, so `[0,1,1]` and `[1,1]` represent the same value.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,0,1,0,1\\]\n**Output:** \\[0,3\\]\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,1,0,1,1\\]\n**Output:** \\[-1,-1\\]\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[1,1,0,0,1\\]\n**Output:** \\[0,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 3 * 104`\n*   `arr[i]` is `0` or `1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math"
        ],
        "example": [
            {
                "input": "[1,0,1,0,1]",
                "output": "[0,3]"
            },
            {
                "input": "[1,1,0,1,1]",
                "output": "[-1,-1]"
            },
            {
                "input": "[1,1,0,0,1]",
                "output": "[0,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic class Solution {\n    private static final int MOD = 1000000007;\n\n    public int sumOfWidths(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        long res = 0, c = 1;\n        \n        for (int i = 0; i < n; i++, c = c * 2 % MOD)\n            res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD;\n            \n        return (int) res;\n    }\n}\n```\n    \n    1. Sort the given array of integers, nums, in ascending order.\n2. Initialize a variable, res, to store the final result, and another variable, c, to keep track of the power of 2.\n3. Iterate through the sorted nums array.\n4. For each element, calculate the difference between the current element and the corresponding element from the end of the array. Multiply the difference by the current value of c and add the result to res.\n5. Update the value of c by multiplying it by 2 and taking the modulo value.\n6. Continue this process until the entire nums array has been traversed.\n7. Return the final value of res modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef sum_of_widths(nums):\n    MOD = 10**9 + 7\n    nums.sort()\n    c, res = 1, 0\n    n = len(nums)\n\n    for i in range(n):\n        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD\n        c = c * 2 % MOD\n\n    return res\n```\n    \n    1. Sort the given array of integers, nums, in ascending order.\n2. Initialize a variable, res, to store the final result, and another variable, c, to keep track of the power of 2.\n3. Iterate through the sorted nums array.\n4. For each element, calculate the difference between the current element and the corresponding element from the end of the array. Multiply the difference by the current value of c and add the result to res.\n5. Update the value of c by multiplying it by 2 and taking the modulo value.\n6. Continue this process until the entire nums array has been traversed.\n7. Return the final value of res modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\n\nint sumOfWidths(std::vector<int>& nums) {\n    int n = nums.size();\n    std::sort(nums.begin(), nums.end());\n    long long res = 0, c = 1;\n    \n    for (int i = 0; i < n; i++, c = c * 2 % MOD)\n        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD;\n        \n    return res;\n}\n```\n    \n    1. Sort the given array of integers, nums, in ascending order.\n2. Initialize a variable, res, to store the final result, and another variable, c, to keep track of the power of 2.\n3. Iterate through the sorted nums array.\n4. For each element, calculate the difference between the current element and the corresponding element from the end of the array. Multiply the difference by the current value of c and add the result to res.\n5. Update the value of c by multiplying it by 2 and taking the modulo value.\n6. Continue this process until the entire nums array has been traversed.\n7. Return the final value of res modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction sumOfWidths(nums) {\n    const MOD = 1e9 + 7;\n    nums.sort((a, b) => a - b);\n    let res = 0, c = 1, n = nums.length;\n\n    for (let i = 0; i < n; i++, c = (c * 2) % MOD)\n        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD;\n\n    return res;\n}\n```\n    \n    1. Sort the given array of integers, nums, in ascending order.\n2. Initialize a variable, res, to store the final result, and another variable, c, to keep track of the power of 2.\n3. Iterate through the sorted nums array.\n4. For each element, calculate the difference between the current element and the corresponding element from the end of the array. Multiply the difference by the current value of c and add the result to res.\n5. Update the value of c by multiplying it by 2 and taking the modulo value.\n6. Continue this process until the entire nums array has been traversed.\n7. Return the final value of res modulo 10^9 + 7.\n    "
    },
    {
        "id": 150,
        "title": "Minimize Malware Spread II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.\n\nSome nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops.\n\nWe will remove **exactly one node** from `initial`, **completely removing it and any connections from this node to any other node**.\n\nReturn the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with **the smallest index**.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[1,1,0\\],\\[0,0,1\\]\\], initial = \\[0,1\\]\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[1,1,1\\],\\[0,1,1\\]\\], initial = \\[0,1\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** graph = \\[\\[1,1,0,0\\],\\[1,1,1,0\\],\\[0,1,1,1\\],\\[0,0,1,1\\]\\], initial = \\[0,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == graph.length`\n*   `n == graph[i].length`\n*   `2 <= n <= 300`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][j] == graph[j][i]`\n*   `graph[i][i] == 1`\n*   `1 <= initial.length < n`\n*   `0 <= initial[i] <= n - 1`\n*   All the integers in `initial` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "[[1,1,0],[1,1,0],[0,0,1]],[0,1]",
                "output": "0"
            },
            {
                "input": "[[1,1,0],[1,1,1],[0,1,1]],[0,1]",
                "output": "1"
            },
            {
                "input": "[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]],[0,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int surfaceArea(int[][] grid) {\n    int n = grid.length;\n    int area = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] > 0) {\n                area += 4 * grid[i][j] + 2;\n                if (i > 0) area -= 2 * Math.min(grid[i][j], grid[i - 1][j]);\n                if (j > 0) area -= 2 * Math.min(grid[i][j], grid[i][j - 1]);\n            }\n        }\n    }\n\n    return area;\n}\n```\n    \n    The algorithm iterates through each cell of the given n x n grid. For each cell with value v, the total surface area of the tower of cubes is calculated using the formula `4 * v + 2` (4 sides, top and bottom), plus the adjacent cells' shared side areas. During each iteration, in order to avoid over-counting the shared sides between adjacent cells, we subtract 2 times the minimum of the current cell's height and the adjacent cell's height (for both the left and top neighbors). This way, the result will only take into account the visible surface areas of each shape without considering the shared sides. The final result is the total surface area of all the shapes.\n    ",
        "python": "\n    ```python\ndef surfaceArea(grid):\n    n = len(grid)\n    area = 0\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                area += 4 * grid[i][j] + 2\n                if i > 0:\n                    area -= 2 * min(grid[i][j], grid[i - 1][j])\n                if j > 0:\n                    area -= 2 * min(grid[i][j], grid[i][j - 1])\n\n    return area\n```\n    \n    The algorithm iterates through each cell of the given n x n grid. For each cell with value v, the total surface area of the tower of cubes is calculated using the formula `4 * v + 2` (4 sides, top and bottom), plus the adjacent cells' shared side areas. During each iteration, in order to avoid over-counting the shared sides between adjacent cells, we subtract 2 times the minimum of the current cell's height and the adjacent cell's height (for both the left and top neighbors). This way, the result will only take into account the visible surface areas of each shape without considering the shared sides. The final result is the total surface area of all the shapes.\n    ",
        "c++": "\n    ```cpp\nint surfaceArea(vector<vector<int>>& grid) {\n    int n = grid.size();\n    int area = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                area += 4 * grid[i][j] + 2;\n                if (i > 0) area -= 2 * min(grid[i][j], grid[i - 1][j]);\n                if (j > 0) area -= 2 * min(grid[i][j], grid[i][j - 1]);\n            }\n        }\n    }\n\n    return area;\n}\n```\n    \n    The algorithm iterates through each cell of the given n x n grid. For each cell with value v, the total surface area of the tower of cubes is calculated using the formula `4 * v + 2` (4 sides, top and bottom), plus the adjacent cells' shared side areas. During each iteration, in order to avoid over-counting the shared sides between adjacent cells, we subtract 2 times the minimum of the current cell's height and the adjacent cell's height (for both the left and top neighbors). This way, the result will only take into account the visible surface areas of each shape without considering the shared sides. The final result is the total surface area of all the shapes.\n    ",
        "js": "\n    ```javascript\nfunction surfaceArea(grid) {\n    const n = grid.length;\n    let area = 0;\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] > 0) {\n                area += 4 * grid[i][j] + 2;\n                if (i > 0) area -= 2 * Math.min(grid[i][j], grid[i - 1][j]);\n                if (j > 0) area -= 2 * Math.min(grid[i][j], grid[i][j - 1]);\n            }\n        }\n    }\n\n    return area;\n}\n```\n\n    \n    The algorithm iterates through each cell of the given n x n grid. For each cell with value v, the total surface area of the tower of cubes is calculated using the formula `4 * v + 2` (4 sides, top and bottom), plus the adjacent cells' shared side areas. During each iteration, in order to avoid over-counting the shared sides between adjacent cells, we subtract 2 times the minimum of the current cell's height and the adjacent cell's height (for both the left and top neighbors). This way, the result will only take into account the visible surface areas of each shape without considering the shared sides. The final result is the total surface area of all the shapes.\n    "
    },
    {
        "id": 151,
        "title": "Stamping The Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two strings `stamp` and `target`. Initially, there is a string `s` of length `target.length` with all `s[i] == '?'`.\n\nIn one turn, you can place `stamp` over `s` and replace every letter in the `s` with the corresponding letter from `stamp`.\n\n*   For example, if `stamp = \"abc \"` and `target = \"abcba \"`, then `s` is `\"????? \"` initially. In one turn you can:\n    \n    *   place `stamp` at index `0` of `s` to obtain `\"abc?? \"`,\n    *   place `stamp` at index `1` of `s` to obtain `\"?abc? \"`, or\n    *   place `stamp` at index `2` of `s` to obtain `\"??abc \"`.\n    \n    Note that `stamp` must be fully contained in the boundaries of `s` in order to stamp (i.e., you cannot place `stamp` at index `3` of `s`).\n\nWe want to convert `s` to `target` using **at most** `10 * target.length` turns.\n\nReturn _an array of the index of the left-most letter being stamped at each turn_. If we cannot obtain `target` from `s` within `10 * target.length` turns, return an empty array.",
            "examples": [
                "**Example 1:**\n\n**Input:** stamp =  \"abc \", target =  \"ababc \"\n**Output:** \\[0,2\\]\n**Explanation:** Initially s =  \"????? \".\n- Place stamp at index 0 to get  \"abc?? \".\n- Place stamp at index 2 to get  \"ababc \".\n\\[1,0,2\\] would also be accepted as an answer, as well as some other answers.\n\n",
                "**Example 2:**\n\n**Input:** stamp =  \"abca \", target =  \"aabcaca \"\n**Output:** \\[3,0,1\\]\n**Explanation:** Initially s =  \"??????? \".\n- Place stamp at index 3 to get  \"???abca \".\n- Place stamp at index 0 to get  \"abcabca \".\n- Place stamp at index 1 to get  \"aabcaca \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= stamp.length <= target.length <= 1000`\n*   `stamp` and `target` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack",
            "Greedy",
            "Queue"
        ],
        "example": [
            {
                "input": "\"abc\",\"ababc\"",
                "output": "[0,2]"
            },
            {
                "input": "\"abca\",\"aabcaca\"",
                "output": "[3,0,1]"
            }
        ],
        "java": "\n    ```java\nclass RLEIterator {\n    private int[] encoding;\n    private int index;\n\n    public RLEIterator(int[] encoding) {\n        this.encoding = encoding;\n        this.index = 0;\n    }\n    \n    public int next(int n) {\n        while (index < encoding.length) {\n            if (n <= encoding[index]) {\n                encoding[index] -= n;\n                return encoding[index + 1];\n            }\n            n -= encoding[index];\n            index += 2;\n        }\n        return -1;\n    }\n}\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    ",
        "python": "\n    ```python\nclass RLEIterator:\n    def __init__(self, encoding):\n        self.encoding = encoding\n        self.index = 0\n\n    def next(self, n):\n        while self.index < len(self.encoding):\n            if n <= self.encoding[self.index]:\n                self.encoding[self.index] -= n\n                return self.encoding[self.index + 1]\n            n -= self.encoding[self.index]\n            self.index += 2\n        return -1\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    ",
        "c++": "\n    ```cpp\nclass RLEIterator {\npublic:\n    RLEIterator(vector<int>& encoding) {\n        data = encoding;\n        index = 0;\n    }\n    \n    int next(int n) {\n        while (index < data.size()) {\n            if (n <= data[index]) {\n                data[index] -= n;\n                return data[index + 1];\n            }\n            n -= data[index];\n            index += 2;\n        }\n        return -1;\n    }\n\nprivate:\n    vector<int> data;\n    int index;\n};\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    ",
        "js": "\n    ```javascript\nclass RLEIterator {\n    constructor(encoding) {\n        this.encoding = encoding;\n        this.index = 0;\n    }\n\n    next(n) {\n        while (this.index < this.encoding.length) {\n            if (n <= this.encoding[this.index]) {\n                this.encoding[this.index] -= n;\n                return this.encoding[this.index + 1];\n            }\n            n -= this.encoding[this.index];\n            this.index += 2;\n        }\n        return -1;\n    }\n}\n```\n    \n    The RLEIterator class creates an iterator for a given run-length encoded array. In the constructor, it initializes the class with the `encoding` array and initializes the `index` variable to 0.\n\nThe `next` function takes an integer `n` and iterates through the run-length encoded array to find the value at the given position. If `n` is less than or equal to the current run's count (`encoding[index]), we update the run count by subtracting n and return the corresponding value. If `n` is greater than the run's count, we subtract the run count from `n` and move to the next run by incrementing the index by 2. If the iterator reaches the end of the encoding array, it returns -1.\n    "
    },
    {
        "id": 152,
        "title": "Distinct Subsequences II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string s, return _the number of **distinct non-empty subsequences** of_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 7\n**Explanation:** The 7 distinct subsequences are  \"a \",  \"b \",  \"c \",  \"ab \",  \"ac \",  \"bc \", and  \"abc \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 6\n**Explanation:** The 6 distinct subsequences are  \"a \",  \"b \",  \"ab \",  \"aa \",  \"ba \", and  \"aba \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aaa \"\n**Output:** 3\n**Explanation:** The 3 distinct subsequences are  \"a \",  \"aa \" and  \"aaa \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"abc\"",
                "output": "7"
            },
            {
                "input": "\"aba\"",
                "output": "6"
            },
            {
                "input": "\"aaa\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int totalFruit(int[] fruits) {\n    int left = 0, right = 0, max_count = 0, n = fruits.length;\n    HashMap<Integer, Integer> count = new HashMap<>();\n\n    while (right < n) {\n        count.put(fruits[right], count.getOrDefault(fruits[right], 0) + 1);\n        while (count.size() > 2) {\n            count.put(fruits[left], count.get(fruits[left]) - 1);\n            if (count.get(fruits[left]) == 0) {\n                count.remove(fruits[left]);\n            }\n            left++;\n        }\n        max_count = Math.max(max_count, right - left + 1);\n        right++;\n    }\n    return max_count;\n}\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    ",
        "python": "\n    ```python\ndef totalFruit(fruits):\n    left, right, max_count = 0, 0, 0\n    count = {}\n\n    while right < len(fruits):\n        count[fruits[right]] = count.get(fruits[right], 0) + 1\n        while len(count) > 2:\n            count[fruits[left]] -= 1\n            if count[fruits[left]] == 0:\n                del count[fruits[left]]\n            left += 1\n        max_count = max(max_count, right - left + 1)\n        right += 1\n\n    return max_count\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint totalFruit(vector<int>& fruits) {\n    int left = 0, right = 0, max_count = 0, n = fruits.size();\n    unordered_map<int, int> count;\n\n    while (right < n) {\n        count[fruits[right]]++;\n        while (count.size() > 2) {\n            count[fruits[left]]--;\n            if (count[fruits[left]] == 0) {\n                count.erase(fruits[left]);\n            }\n            left++;\n        }\n        max_count = max(max_count, right - left + 1);\n        right++;\n    }\n    return max_count;\n}\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    ",
        "js": "\n    ```javascript\nfunction totalFruit(fruits) {\n    let left = 0, right = 0, max_count = 0;\n    const count = new Map();\n\n    while (right < fruits.length) {\n        count.set(fruits[right], (count.get(fruits[right]) || 0) + 1);\n        while (count.size > 2) {\n            count.set(fruits[left], count.get(fruits[left]) - 1);\n            if (count.get(fruits[left]) === 0) {\n                count.delete(fruits[left]);\n            }\n            left++;\n        }\n        max_count = Math.max(max_count, right - left + 1);\n        right++;\n    }\n    return max_count;\n}\n```\n    \n    The algorithm uses a sliding window approach where two pointers \"left\" and \"right\" traverse through the `fruits` array while maintaining a frequency \"count\" hashmap (or map in JavaScript) to count the occurrences of different fruits in the current window.\n\n1. First, initialize `left`, `right`, and `max_count` to 0, and an empty hashmap for `count`.\n2. Perform a while loop where the condition is `right < length of fruits`.\n3. Update the hashmap `count` with the fruit at the right index, incrementing the count by 1.\n4. If the hashmap size is greater than 2, it means more than two types of fruits are in the current window, so we need to remove the leftmost fruit from the hashmap and increment the left pointer.\n5. Calculate the maximum collected fruit count (`max_count`) by getting the max of the current `max_count` and the number of fruits in the current window (i.e., `right - left + 1`).\n6. Increment the right pointer to move the window.\n7. When the while loop finishes, return the `max_count`.\n    "
    },
    {
        "id": 153,
        "title": "Find the Shortest Superstring",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of strings `words`, return _the smallest string that contains each string in_ `words` _as a substring_. If there are multiple valid strings of the smallest length, return **any of them**.\n\nYou may assume that no string in `words` is a substring of another string in `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"alex \", \"loves \", \"leetcode \"\\]\n**Output:**  \"alexlovesleetcode \"\n**Explanation:** All permutations of  \"alex \", \"loves \", \"leetcode \" would also be accepted.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"catg \", \"ctaagt \", \"gcta \", \"ttca \", \"atgcatc \"\\]\n**Output:**  \"gctaagttcatgcatc \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 12`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[\"alex\",\"loves\",\"leetcode\"]",
                "output": "\"alexlovesleetcode\""
            },
            {
                "input": "[\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]",
                "output": "\"gctaagttcatgcatc\""
            }
        ],
        "java": "\n    ```java\npublic int sumOfMins(int[] arr) {\n    int mod = (int)1e9 + 7;\n    int n = arr.length;\n    int[] left = new int[n], right = new int[n];\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; i++) {\n        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {\n            st.pop();\n        }\n        left[i] = st.isEmpty() ? -1 : st.peek();\n        st.push(i);\n    }\n\n    st.clear();\n    for (int i = n - 1; i >= 0; i--) {\n        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {\n            st.pop();\n        }\n        right[i] = st.isEmpty() ? n : st.peek();\n        st.push(i);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = (int)((ans + (long)arr[i] * (i - left[i]) * (right[i] - i)) % mod);\n    }\n    return ans;\n}\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef sum_of_mins(arr):\n    mod = 10**9 + 7\n    n = len(arr)\n    left, right = [0] * n, [0] * n\n    st = []\n\n    for i in range(n):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        left[i] = st[-1] if st else -1\n        st.append(i)\n\n    st.clear()\n    for i in range(n - 1, -1, -1):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        right[i] = st[-1] if st else n\n        st.append(i)\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod\n    return ans\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\nint sumOfMins(vector<int>& arr) {\n    int mod = 1e9 + 7;\n    int n = arr.size();\n    vector<int> left(n), right(n);\n    stack<int> st;\n\n    for (int i = 0; i < n; i++) {\n        while (!st.empty() && arr[st.top()] > arr[i]) {\n            st.pop();\n        }\n        left[i] = st.empty() ? -1 : st.top();\n        st.push(i);\n    }\n\n    while (!st.empty()) st.pop();\n    for (int i = n - 1; i >= 0; i--) {\n        while (!st.empty() && arr[st.top()] > arr[i]) {\n            st.pop();\n        }\n        right[i] = st.empty() ? n : st.top();\n        st.push(i);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod;\n    }\n    return ans;\n}\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction sumOfMins(arr) {\n    let mod = 1e9 + 7;\n    let n = arr.length;\n    let left = new Array(n), right = new Array(n);\n    let st = [];\n\n    for (let i = 0; i < n; i++) {\n        while (st.length && arr[st[st.length - 1]] > arr[i]) {\n            st.pop();\n        }\n        left[i] = st.length === 0 ? -1 : st[st.length - 1];\n        st.push(i);\n    }\n\n    st = [];\n    for (let i = n - 1; i >= 0; i--) {\n        while (st.length && arr[st[st.length - 1]] > arr[i]) {\n            st.pop();\n        }\n        right[i] = st.length === 0 ? n : st[st.length - 1];\n        st.push(i);\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod;\n    }\n    return ans;\n}\n```\n    \n    To find the sum of minimum elements in all subarrays, we first find two auxiliary arrays, 'left' and 'right', which store the index of the closest smaller element for each element in the input array from left and right respectively.\n\nWe then iterate over the array and for each element, we find the product of the element, its distance to the previous smaller element (stored in 'left') and its distance to the next smaller element (stored in 'right'). The sum of these products for all elements in the array gives us the sum of minimums in all subarrays.\n\nFinally, we return the total sum of minimums modulo 10^9 + 7.\n    "
    },
    {
        "id": 154,
        "title": "Largest Component Size by Common Factor",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array of unique positive integers `nums`. Consider the following graph:\n\n*   There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,\n*   There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.\n\nReturn _the size of the largest connected component in the graph_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,6,15,35\\]\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[20,50,9,63\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,3,6,7,4,12,21,39\\]\n**Output:** 8"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 105`\n*   All the values of `nums` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Union Find",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[4,6,15,35]",
                "output": "4"
            },
            {
                "input": "[20,50,9,63]",
                "output": "2"
            },
            {
                "input": "[2,3,6,7,4,12,21,39]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<String> wordSubsets(String[] words1, String[] words2) {\n    Map<Character, Integer> maxChars = new HashMap<>();\n    for (String word : words2) {\n        Map<Character, Integer> chars = new HashMap<>();\n        for (char c : word.toCharArray()) {\n            chars.put(c, chars.getOrDefault(c, 0) + 1);\n        }\n        for (Map.Entry<Character, Integer> entry : chars.entrySet()) {\n            maxChars.put(entry.getKey(), Math.max(maxChars.getOrDefault(entry.getKey(), 0), entry.getValue()));\n        }\n    }\n\n    List<String> result = new ArrayList<>();\n    for (String word : words1) {\n        Map<Character, Integer> wordChars = new HashMap<>();\n        for (char c : word.toCharArray()) {\n            wordChars.put(c, wordChars.getOrDefault(c, 0) + 1);\n        }\n\n        boolean universal = true;\n        for (Map.Entry<Character, Integer> entry : maxChars.entrySet()) {\n            if (wordChars.getOrDefault(entry.getKey(), 0) < entry.getValue()) {\n                universal = false;\n                break;\n            }\n        }\n\n        if (universal) {\n            result.add(word);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap that contains the maximum frequency of each character across all words in `words2`. We will call this hashmap `max_chars`.\n2. Iterate through every word in `words1` and for each word, create another hashmap `word_chars` that counts the frequency of each character in that word.\n3. Check if every character in `max_chars` is present in `word_chars` with a frequency equal to or greater than its frequency in `max_chars`. If this is true for every character, the word is considered universal and we add it to the list of results.\n4. Return the list of results.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef word_subsets(words1, words2):\n    max_chars = Counter()\n    for word in words2:\n        chars = Counter(word)\n        for c, count in chars.items():\n            max_chars[c] = max(max_chars[c], count)\n    \n    result = []\n    for word in words1:\n        word_chars = Counter(word)\n        universal = all(word_chars[c] >= max_chars[c] for c in max_chars)\n        if universal:\n            result.append(word)\n    \n    return result\n```\n\n    \n    1. Create a hashmap that contains the maximum frequency of each character across all words in `words2`. We will call this hashmap `max_chars`.\n2. Iterate through every word in `words1` and for each word, create another hashmap `word_chars` that counts the frequency of each character in that word.\n3. Check if every character in `max_chars` is present in `word_chars` with a frequency equal to or greater than its frequency in `max_chars`. If this is true for every character, the word is considered universal and we add it to the list of results.\n4. Return the list of results.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::string> wordSubsets(std::vector<std::string>& words1, std::vector<std::string>& words2) {\n    std::unordered_map<char, int> max_chars;\n    for (const auto& word : words2) {\n        std::unordered_map<char, int> chars;\n        for (char c : word) {\n            chars[c]++;\n        }\n        for (const auto& entry : chars) {\n            max_chars[entry.first] = std::max(max_chars[entry.first], entry.second);\n        }\n    }\n\n    std::vector<std::string> result;\n    for (const auto& word : words1) {\n        std::unordered_map<char, int> word_chars;\n        for (char c : word) {\n            word_chars[c]++;\n        }\n\n        bool universal = true;\n        for (const auto& entry : max_chars) {\n            if (word_chars[entry.first] < entry.second) {\n                universal = false;\n                break;\n            }\n        }\n\n        if (universal) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap that contains the maximum frequency of each character across all words in `words2`. We will call this hashmap `max_chars`.\n2. Iterate through every word in `words1` and for each word, create another hashmap `word_chars` that counts the frequency of each character in that word.\n3. Check if every character in `max_chars` is present in `word_chars` with a frequency equal to or greater than its frequency in `max_chars`. If this is true for every character, the word is considered universal and we add it to the list of results.\n4. Return the list of results.\n    ",
        "js": "\n    ```javascript\nfunction wordSubsets(words1, words2) {\n    const maxChars = {};\n    for (const word of words2) {\n        const chars = {};\n        for (const c of word) {\n            chars[c] = (chars[c] || 0) + 1;\n        }\n        for (const c in chars) {\n            maxChars[c] = Math.max(maxChars[c] || 0, chars[c]);\n        }\n    }\n    \n    const result = [];\n    for (const word of words1) {\n        const wordChars = {};\n        for (const c of word) {\n            wordChars[c] = (wordChars[c] || 0) + 1;\n        }\n        \n        let universal = true;\n        for (const c in maxChars) {\n            if ((wordChars[c] || 0) < maxChars[c]) {\n                universal = false;\n                break;\n            }\n        }\n        \n        if (universal) {\n            result.push(word);\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Create a hashmap that contains the maximum frequency of each character across all words in `words2`. We will call this hashmap `max_chars`.\n2. Iterate through every word in `words1` and for each word, create another hashmap `word_chars` that counts the frequency of each character in that word.\n3. Check if every character in `max_chars` is present in `word_chars` with a frequency equal to or greater than its frequency in `max_chars`. If this is true for every character, the word is considered universal and we add it to the list of results.\n4. Return the list of results.\n    "
    },
    {
        "id": 155,
        "title": "Tallest Billboard",
        "difficulty": "Hard",
        "content": {
            "problem": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n\nYou are given a collection of `rods` that can be welded together. For example, if you have rods of lengths `1`, `2`, and `3`, you can weld them together to make a support of length `6`.\n\nReturn _the largest possible height of your billboard installation_. If you cannot support the billboard, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rods = \\[1,2,3,6\\]\n**Output:** 6\n**Explanation:** We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n",
                "**Example 2:**\n\n**Input:** rods = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n",
                "**Example 3:**\n\n**Input:** rods = \\[1,2\\]\n**Output:** 0\n**Explanation:** The billboard cannot be supported, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rods.length <= 20`\n*   `1 <= rods[i] <= 1000`\n*   `sum(rods[i]) <= 5000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,2,3,6]",
                "output": "6"
            },
            {
                "input": "[1,2,3,4,5,6]",
                "output": "10"
            },
            {
                "input": "[1,2]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numMusicPlaylists(int n, int goal, int k) {\n    long MOD = 1000000007;\n    long[][] dp = new long[goal + 1][n + 1];\n    dp[0][0] = 1;\n    for (int i = 1; i <= goal; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * Math.max(0, j - k) % MOD) % MOD;\n        }\n    }\n    return (int) dp[goal][n];\n}\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    ",
        "python": "\n    ```python\ndef numMusicPlaylists(n, goal, k):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(goal + 1)]\n    dp[0][0] = 1\n    for i in range(1, goal + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD\n    return dp[goal][n]\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#define MOD 1000000007\n\nint numMusicPlaylists(int n, int goal, int k) {\n    std::vector<std::vector<long long>> dp(goal + 1, std::vector<long long>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= goal; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = ((dp[i - 1][j - 1] * (n - (j - 1))) % MOD + (dp[i - 1][j] * std::max(0, j - k)) % MOD) % MOD;\n        }\n    }\n    return dp[goal][n];\n}\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    ",
        "js": "\n    ```javascript\nfunction numMusicPlaylists(n, goal, k) {\n    const MOD = 1_000_000_007;\n    const dp = Array.from({ length: goal + 1 }, () => Array.from({ length: n + 1 }, () => 0));\n    dp[0][0] = 1;\n    for (let i = 1; i <= goal; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = ((dp[i - 1][j - 1] * (n - (j - 1))) % MOD + (dp[i - 1][j] * Math.max(0, j - k)) % MOD) % MOD;\n        }\n    }\n    return dp[goal][n];\n}\n```\n    \n    Here, we use a Dynamic Programming approach to solve the problem. We first create a 2D array dp where dp[i][j] represents the number of playlists of length i formed using j different songs. We initialize dp[0][0] to 1.\n\nThen, we loop through each cell of the dp array from length 1 to goal and from song 1 to n. For each cell, we do the following:\n1. Add a new song to the playlist. The number of ways to do this is (n - (j - 1)).\n2. Add an existing song to the playlist, with the condition that the song is not played in the last k positions. The number of ways to do this is max(0, j - k).\n\nWe add both of these to update the value of dp[i][j] and calculate the result modulo 109 + 7. Eventually, we return the value in dp[goal][n] which is the number of possible playlists of length goal formed using n different songs.\n    "
    },
    {
        "id": 156,
        "title": "Delete Columns to Make Sorted III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of `n` strings `strs`, all of the same length.\n\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\n\nFor example, if we have `strs = [ \"abcdef \", \"uvwxyz \"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[ \"bef \", \"vyz \"]`.\n\nSuppose we chose a set of deletion indices `answer` such that after deletions, the final array has **every string (row) in lexicographic** order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return _the minimum possible value of_ `answer.length`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"babca \", \"bbazb \"\\]\n**Output:** 3\n**Explanation:** After deleting columns 0, 1, and 4, the final array is strs = \\[ \"bc \",  \"az \"\\].\nBoth these rows are individually in lexicographic order (ie. strs\\[0\\]\\[0\\] <= strs\\[0\\]\\[1\\] and strs\\[1\\]\\[0\\] <= strs\\[1\\]\\[1\\]).\nNote that strs\\[0\\] > strs\\[1\\] - the array strs is not necessarily in lexicographic order.\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"edcba \"\\]\n**Output:** 4\n**Explanation:** If we delete less than 4 columns, the only row will not be lexicographically sorted.\n\n",
                "**Example 3:**\n\n**Input:** strs = \\[ \"ghi \", \"def \", \"abc \"\\]\n**Output:** 0\n**Explanation:** All rows are already lexicographically sorted."
            ],
            "constraints": "**Constraints:**\n\n*   `n == strs.length`\n*   `1 <= n <= 100`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[\"babca\",\"bbazb\"]",
                "output": "3"
            },
            {
                "input": "[\"edcba\"]",
                "output": "4"
            },
            {
                "input": "[\"ghi\",\"def\",\"abc\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        Arrays.sort(initial);\n        \n        Set<Integer> malware = new HashSet<>();\n        for (int i : initial) {\n            malware.add(i);\n        }\n        \n        int minNode = initial[0], minSpread = n + 1;\n        for (int node : initial) {\n            Queue<Integer> q = new LinkedList<>();\n            boolean[] visited = new boolean[n];\n            \n            for (int otherNode : initial) {\n                if (node != otherNode) {\n                    q.offer(otherNode);\n                    visited[otherNode] = true;\n                }\n            }\n\n            while (!q.isEmpty()) {\n                int cur = q.poll();\n                for (int next = 0; next < n; ++next) {\n                    if (graph[cur][next] == 1 && !visited[next] && !malware.contains(next)) {\n                        visited[next] = true;\n                        q.offer(next);\n                    }\n                }\n            }\n            \n            int spread = 0;\n            for (boolean v : visited) {\n                spread += v ? 1 : 0;\n            }\n\n            if (spread < minSpread) {\n                minNode = node;\n                minSpread = spread;\n            }\n        }\n        \n        return minNode;\n    }\n}\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef minMalwareSpread(graph, initial):\n    n = len(graph)\n    initial.sort()\n    \n    malware = set(initial)\n    \n    minNode = initial[0]\n    minSpread = n + 1\n\n    for node in initial:\n        q = deque(otherNode for otherNode in initial if node != otherNode)\n        visited = [node != otherNode and otherNode in malware for otherNode in range(n)]\n        \n        while q:\n            cur = q.popleft()\n            for next, isConnected in enumerate(graph[cur]):\n                if isConnected and not visited[next] and next not in malware:\n                    visited[next] = True\n                    q.append(next)\n        \n        spread = sum(visited)\n        \n        if spread < minSpread:\n            minNode = node\n            minSpread = spread\n    \n    return minNode\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <queue>\n\nint minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial) {\n    int n = graph.size();\n    std::sort(initial.begin(), initial.end());\n    \n    std::unordered_set<int> malware(initial.begin(), initial.end());\n    \n    int minNode = initial[0], minSpread = n + 1;\n    for (int node : initial) {\n        std::queue<int> q;\n        std::vector<bool> visited(n, false);\n        \n        for (int otherNode : initial) {\n            if (node != otherNode) {\n                q.push(otherNode);\n                visited[otherNode] = true;\n            }\n        }\n\n        while (!q.empty()) {\n            int cur = q.front(); q.pop();\n            for (int next = 0; next < n; ++next) {\n                if (graph[cur][next] == 1 && !visited[next] && !malware.count(next)) {\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n        \n        int spread = 0;\n        for (bool v : visited) {\n            spread += v;\n        }\n\n        if (spread < minSpread) {\n            minNode = node;\n            minSpread = spread;\n        }\n    }\n    \n    return minNode;\n}\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    ",
        "js": "\n    ```javascript\nfunction minMalwareSpread(graph, initial) {\n    const n = graph.length;\n    initial.sort((a, b) => a - b);\n    \n    const malware = new Set(initial);\n    \n    let minNode = initial[0];\n    let minSpread = n + 1;\n\n    for (const node of initial) {\n        const q = [];\n        const visited = new Array(n).fill(false);\n\n        for (const otherNode of initial) {\n            if (node !== otherNode) {\n                q.push(otherNode);\n                visited[otherNode] = true;\n            }\n        }\n\n        while (q.length) {\n            const cur = q.shift();\n            for (let next = 0; next < n; ++next) {\n                if (graph[cur][next] === 1 && !visited[next] && !malware.has(next)) {\n                    visited[next] = true;\n                    q.push(next);\n                }\n            }\n        }\n        \n        const spread = visited.reduce((acc, v) => acc + (v ? 1 : 0), 0);\n\n        if (spread < minSpread) {\n            minNode = node;\n            minSpread = spread;\n        }\n    }\n    \n    return minNode;\n}\n```\n\n    \n    The algorithm starts by sorting the node indices of the initial malware-infected nodes in ascending order. Then, it initializes a set called `malware` for efficient look-up of malware-infected nodes. We also initialize variables to store the node index that, when removed, minimizes the number of infected nodes (i.e., `minNode`) and the minimum number of infected nodes across all node removals (i.e., `minSpread`). Next, we iterate through each malware-infected node and simulate the spread of malware after removing the node from the initial set of infected nodes. During each iteration/simulation, we maintain a queue (FIFO) `q` that stores the currently traversed nodes and a `visited` array to keep track of previously traversed nodes. While there are still nodes to traverse, we dequeue a node `cur` from `q` and enqueue all unvisited, non-infected neighboring nodes. After the traversal, we calculate the total number of infected nodes (`spread`) and update `minNode` accordingly. Finally, we return `minNode` as the node that, if removed, would minimize M(initial).\n    "
    },
    {
        "id": 157,
        "title": "Least Operators to Express Number",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a single positive integer `x`, we will write an expression of the form `x (op1) x (op2) x (op3) x ...` where each operator `op1`, `op2`, etc. is either addition, subtraction, multiplication, or division (`+`, `-`, `*`, or `/)`. For example, with `x = 3`, we might write `3 * 3 / 3 + 3 - 3` which is a value of 3.\n\nWhen writing such an expression, we adhere to the following conventions:\n\n*   The division operator (`/`) returns rational numbers.\n*   There are no parentheses placed anywhere.\n*   We use the usual order of operations: multiplication and division happen before addition and subtraction.\n*   It is not allowed to use the unary negation operator (`-`). For example, \"`x - x` \" is a valid expression as it only uses subtraction, but \"`-x + x` \" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such that the expression equals the given `target`. Return the least number of operators used.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 3, target = 19\n**Output:** 5\n**Explanation:** 3 \\* 3 + 3 \\* 3 + 3 / 3.\nThe expression contains 5 operations.\n\n",
                "**Example 2:**\n\n**Input:** x = 5, target = 501\n**Output:** 8\n**Explanation:** 5 \\* 5 \\* 5 \\* 5 - 5 \\* 5 \\* 5 + 5 / 5.\nThe expression contains 8 operations.\n\n",
                "**Example 3:**\n\n**Input:** x = 100, target = 100000000\n**Output:** 3\n**Explanation:** 100 \\* 100 \\* 100 \\* 100.\nThe expression contains 3 operations."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= x <= 100`\n*   `1 <= target <= 2 * 108`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "3,19",
                "output": "5"
            },
            {
                "input": "5,501",
                "output": "8"
            },
            {
                "input": "100,100000000",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length, res = 0, minSize = Integer.MAX_VALUE;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n        int colors = 0;\n\n        for (int i = 0; i < n; ++i) {\n            if (color[i] == -1) {\n                Queue<Integer> q = new LinkedList<>();\n                q.offer(i);\n                color[i] = colors;\n\n                while (!q.isEmpty()) {\n                    int t = q.poll();\n                    for (int j = 0; j < n; ++j) {\n                        if (graph[t][j] == 1 && color[j] == -1) {\n                            q.offer(j);\n                            color[j] = colors;\n                        }\n                    }\n                }\n                ++colors;\n            }\n        }\n\n        int[] area = new int[colors], count = new int[colors];\n        Set<Integer> initiallyInfected = new HashSet<>();\n        for (int i : initial) {\n            initiallyInfected.add(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            ++area[color[i]];\n            if (initiallyInfected.contains(i)) {\n                ++count[color[i]];\n            }\n        }\n\n        for (int i : initial) {\n            if (count[color[i]] == 1) {\n                if (area[color[i]] < minSize) {\n                    minSize = area[color[i]];\n                    res = i;\n                } else if (area[color[i]] == minSize && i < res) {\n                    res = i;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    ",
        "python": "\n    ```python\nfrom collections import deque\nfrom typing import List\n\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -> int:\n    n = len(graph)\n    color = [-1] * n\n    colors = 0\n\n    for i in range(n):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = colors\n\n            while q:\n                t = q.popleft()\n                for j in range(n):\n                    if graph[t][j] == 1 and color[j] == -1:\n                        q.append(j)\n                        color[j] = colors\n\n            colors += 1\n\n    area = [0] * colors\n    count = [0] * colors\n    initially_infected = set(initial)\n    for i in range(n):\n        area[color[i]] += 1\n        if i in initially_infected:\n            count[color[i]] += 1\n\n    res = min(initial)\n    min_size = n + 1\n    for i in initial:\n        if count[color[i]] == 1:\n            if area[color[i]] < min_size:\n                min_size = area[color[i]]\n                res = i\n            elif area[color[i]] == min_size and i < res:\n                res = i\n\n    return res\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\nint minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n    int n = graph.size(), res = 0, minSize = INT_MAX;\n    vector<int> color(n, -1);\n    int colors = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (color[i] == -1) {\n            queue<int> q;\n            q.push(i);\n            color[i] = colors;\n\n            while (!q.empty()) {\n                int t = q.front(); q.pop();\n                for (int j = 0; j < n; ++j) {\n                    if (graph[t][j] == 1 && color[j] == -1) {\n                        q.push(j);\n                        color[j] = colors;\n                    }\n                }\n            }\n            ++colors;\n        }\n    }\n\n    vector<int> area(colors, 0), count(colors, 0);\n    set<int> initiallyInfected(initial.begin(), initial.end());\n    for (int i = 0; i < n; ++i) {\n        ++area[color[i]];\n        if (initiallyInfected.count(i)) {\n            ++count[color[i]];\n        }\n    }\n\n    for (int i : initial) {\n        if (count[color[i]] == 1) {\n            if (area[color[i]] < minSize) {\n                minSize = area[color[i]];\n                res = i;\n            } else if (area[color[i]] == minSize && i < res) {\n                res = i;\n            }\n        }\n    }\n\n    return res;\n}\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    ",
        "js": "\n    ```javascript\nfunction minMalwareSpread(graph, initial) {\n    const n = graph.length;\n    const color = new Array(n).fill(-1);\n    let colors = 0;\n\n    for (let i = 0; i < n; ++i) {\n        if (color[i] === -1) {\n            const q = [i];\n            color[i] = colors;\n\n            while (q.length) {\n                const t = q.shift();\n                for (let j = 0; j < n; ++j) {\n                    if (graph[t][j] === 1 && color[j] === -1) {\n                        q.push(j);\n                        color[j] = colors;\n                    }\n                }\n            }\n            ++colors;\n        }\n    }\n\n    const area = new Array(colors).fill(0);\n    const count = new Array(colors).fill(0);\n    const initiallyInfected = new Set(initial);\n\n    for (let i = 0; i < n; ++i) {\n        ++area[color[i]];\n        if (initiallyInfected.has(i)) {\n            ++count[color[i]];\n        }\n    }\n\n    let res = initial[0];\n    let minSize = n + 1;\n    for (const i of initial) {\n        if (count[color[i]] === 1) {\n            if (area[color[i]] < minSize) {\n                minSize = area[color[i]];\n                res = i;\n            } else if (area[color[i]] === minSize && i < res) {\n                res = i;\n            }\n        }\n    }\n\n    return res;\n}\n```\n    \n    Initially, we mark all nodes with a unique color in such a way that adjacent nodes have the same color, so that we can track how many uninfected nodes are connected to every infected node in the initial set. We use BFS to do the coloring operation. Then, we calculate the number of nodes for each unique color and calculate the count of nodes in the initial set that share the same color. \n\nFinally, we iterate through every node in the initial list, and if that node's color has a count of 1, meaning it is the only infected node in its group, we check if it minimizes the number of nodes infected post-removal. If so, the result is updated to the current node. The result is the node that, if removed, would minimize M(initial). If there are multiple such nodes, the one with the smallest index is returned.\n    "
    },
    {
        "id": 158,
        "title": "Binary Tree Cameras",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given the `root` of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\nReturn _the minimum number of cameras needed to monitor all nodes of the tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[0,0,null,0,0\\]\n**Output:** 1\n**Explanation:** One camera is enough to monitor all nodes if placed as shown.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0,0,null,0,null,0,null,null,0\\]\n**Output:** 2\n**Explanation:** At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `Node.val == 0`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[0,0,null,0,0]",
                "output": "1"
            },
            {
                "input": "[0,0,null,0,null,0,null,null,0]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int[] beautifulArray(int n) {\n    List<Integer> result = new ArrayList<>();\n    result.add(1);\n    while (result.size() < n) {\n        List<Integer> temp = new ArrayList<>();\n        for (int i : result) {\n            if (i * 2 - 1 <= n)\n                temp.add(i * 2 - 1);\n        }\n        for (int i : result) {\n            if (i * 2 <= n)\n                temp.add(i * 2);\n        }\n        result = temp;\n    }\n    return result.stream().mapToInt(i->i).toArray();\n}\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    ",
        "python": "\n    ```python\ndef beautifulArray(n: int) -> List[int]:\n    result = [1]\n    while len(result) < n:\n        temp = []\n        for i in result:\n            if i * 2 - 1 <= n:\n                temp.append(i * 2 - 1)\n        for i in result:\n            if i * 2 <= n:\n                temp.append(i * 2)\n        result = temp\n    return result\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    ",
        "c++": "\n    ```cpp\nvector<int> beautifulArray(int n) {\n    vector<int> result = {1};\n    while (result.size() < n) {\n        vector<int> temp;\n        for (int i : result) {\n            if (i * 2 - 1 <= n)\n                temp.push_back(i * 2 - 1);\n        }\n        for (int i : result) {\n            if (i * 2 <= n)\n                temp.push_back(i * 2);\n        }\n        result = temp;\n    }\n    return result;\n}\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    ",
        "js": "\n    ```javascript\nfunction beautifulArray(n) {\n    let result = [1];\n    while (result.length < n) {\n        let temp = [];\n        for (let i of result) {\n            if (i * 2 - 1 <= n)\n                temp.push(i * 2 - 1);\n        }\n        for (let i of result) {\n            if (i * 2 <= n)\n                temp.push(i * 2);\n        }\n        result = temp;\n    }\n    return result;\n}\n```\n    \n    The algorithm starts with an array containing just the number 1. It then generates a new array by iterating through the current array and checking if the element value multiplied by 2 minus 1 and the element value multiplied by 2 are both less than or equal to n. If they are, these two new numbers are added to a temporary array. The current array now becomes the temporary array. This process continues until the size of the current array is equal to the integer n.\n\nThe resulting array is a beautiful array because it satisfies the conditions of the question. This approach works as the operations in the algorithm ensure that elements in the odd positions and even positions will always be less than or equal to n, thus maintaining the desired intervals between elements.\n    "
    },
    {
        "id": 159,
        "title": "Equal Rational Numbers",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t`, each of which represents a non-negative rational number, return `true` if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\n\nA **rational number** can be represented using up to three parts: , , and a . The number will be represented in one of the following three ways:\n\n*   *   For example, `12`, `0`, and `123`.\n*   `**<.>**`\n    *   For example, `0.5`, `1.`, `2.12`, and `123.0001`.\n*   `**<.>****<(>****<)>**`\n    *   For example, `0.1(6)`, `1.(9)`, `123.00(1212)`.\n\nThe repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:\n\n*   `1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"0.(52) \", t =  \"0.5(25) \"\n**Output:** true\n**Explanation:** Because  \"0.(52) \" represents 0.52525252..., and  \"0.5(25) \" represents 0.52525252525..... , the strings represent the same number.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"0.1666(6) \", t =  \"0.166(66) \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"0.9(9) \", t =  \"1. \"\n**Output:** true\n**Explanation:**  \"0.9(9) \" represents 0.999999999... repeated forever, which equals 1.  \\[[See this link for an explanation.](https://en.wikipedia.org/wiki/0.999...)\\]\n \"1. \" represents the number 1, which is formed correctly: (IntegerPart) =  \"1 \" and (NonRepeatingPart) =  \" \"."
            ],
            "constraints": "**Constraints:**\n\n*   Each part consists only of digits.\n*   The does not have leading zeros (except for the zero itself).\n*   `1 <= .length <= 4`\n*   `0 <= .length <= 4`\n*   `1 <= .length <= 4`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String"
        ],
        "example": [
            {
                "input": "\"0.(52)\",\"0.5(25)\"",
                "output": "true"
            },
            {
                "input": "\"0.1666(6)\",\"0.166(66)\"",
                "output": "true"
            },
            {
                "input": "\"0.9(9)\",\"1.\"",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic int knightDialer(int n) {\n    if (n == 1) return 10;\n    final int MOD = 1000000007;\n    int[][] moves = {\n        {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9},\n        {}, {1, 7, 0}, {2, 6}, {1, 3}, {2, 4}\n    };\n    int[] dp = new int[10];\n    Arrays.fill(dp, 1);\n    for (int i = 2; i <= n; ++i) {\n        int[] new_dp = new int[10];\n        for (int j = 0; j < 10; ++j)\n            for (int move : moves[j])\n                new_dp[j] = (new_dp[j] + dp[move]) % MOD;\n        dp = new_dp;\n    }\n    return Arrays.stream(dp).reduce(0, (a, b) -> (a + b) % MOD);\n}\n```\n    \n    The algorithm uses dynamic programming to find how many distinct phone numbers of length n can be dialed with valid knight jumps.\n\nWe first define the knight's possible moves for every digit in `moves`. Then, we initialize a `dp` vector (or an array in Java and JavaScript) with length 10, and fill it with 1, representing there is 1 way to reach each digit in 1 step.\n\nNext, we iterate through 2 to n, and in every iteration, we calculate the next state using the current state in the `dp`. We create a `new_dp` vector/array of size 10 filled with 0, representing the number of ways to reach each digit in the next iteration. For each digit `j`, we iterate through its possible moves and update the `new_dp[j]` accordingly. After that, we replace the `dp` with the `new_dp` for the next iteration.\n\nFinally, we sum up the elements in the `dp` array, modulo 10^9 + 7, and return it as the result.\n    ",
        "python": "\n    ```python\ndef knightDialer(n: int) -> int:\n    if n == 1:\n        return 10\n    MOD = 10**9 + 7\n    moves = [\n        [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],\n        [], [1, 7, 0], [2, 6], [1, 3], [2, 4]\n    ]\n    dp = [1] * 10\n    for _ in range(2, n + 1):\n        new_dp = [0] * 10\n        for j in range(10):\n            for move in moves[j]:\n                new_dp[j] = (new_dp[j] + dp[move]) % MOD\n        dp = new_dp\n    return sum(dp) % MOD\n```\n    \n    The algorithm uses dynamic programming to find how many distinct phone numbers of length n can be dialed with valid knight jumps.\n\nWe first define the knight's possible moves for every digit in `moves`. Then, we initialize a `dp` vector (or an array in Java and JavaScript) with length 10, and fill it with 1, representing there is 1 way to reach each digit in 1 step.\n\nNext, we iterate through 2 to n, and in every iteration, we calculate the next state using the current state in the `dp`. We create a `new_dp` vector/array of size 10 filled with 0, representing the number of ways to reach each digit in the next iteration. For each digit `j`, we iterate through its possible moves and update the `new_dp[j]` accordingly. After that, we replace the `dp` with the `new_dp` for the next iteration.\n\nFinally, we sum up the elements in the `dp` array, modulo 10^9 + 7, and return it as the result.\n    ",
        "c++": "\n    ```cpp\nint knightDialer(int n) {\n    if (n == 1) return 10;\n    const int mod = 1e9 + 7;\n    vector<vector<int>> moves = {\n        {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9},\n        {}, {1, 7, 0}, {2, 6}, {1, 3}, {2, 4}\n    };\n    vector<int> dp(10, 1);\n    for (int i = 2; i <= n; ++i) {\n        vector<int> new_dp(10, 0);\n        for (int j = 0; j < 10; ++j)\n            for (const auto& move : moves[j])\n                new_dp[j] = (new_dp[j] + dp[move]) % mod;\n        dp = std::move(new_dp);\n    }\n    return accumulate(dp.begin(), dp.end(), 0, [&](int a, int b) { return (a + b) % mod; });\n}\n```\n    \n    The algorithm uses dynamic programming to find how many distinct phone numbers of length n can be dialed with valid knight jumps.\n\nWe first define the knight's possible moves for every digit in `moves`. Then, we initialize a `dp` vector (or an array in Java and JavaScript) with length 10, and fill it with 1, representing there is 1 way to reach each digit in 1 step.\n\nNext, we iterate through 2 to n, and in every iteration, we calculate the next state using the current state in the `dp`. We create a `new_dp` vector/array of size 10 filled with 0, representing the number of ways to reach each digit in the next iteration. For each digit `j`, we iterate through its possible moves and update the `new_dp[j]` accordingly. After that, we replace the `dp` with the `new_dp` for the next iteration.\n\nFinally, we sum up the elements in the `dp` array, modulo 10^9 + 7, and return it as the result.\n    ",
        "js": "\n    ```javascript\nfunction knightDialer(n) {\n  if (n === 1) return 10;\n  const MOD = 1e9 + 7;\n  const moves = [\n    [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],\n    [], [1, 7, 0], [2, 6], [1, 3], [2, 4]\n  ];\n  const dp = new Array(10).fill(1);\n  for (let i = 2; i <= n; ++i) {\n    const new_dp = new Array(10).fill(0);\n    for (let j = 0; j < 10; ++j)\n      for (const move of moves[j])\n        new_dp[j] = (new_dp[j] + dp[move]) % MOD;\n    dp.splice(0, dp.length, ...new_dp);\n  }\n  return dp.reduce((a, b) => (a + b) % MOD);\n}\n```\n    \n    The algorithm uses dynamic programming to find how many distinct phone numbers of length n can be dialed with valid knight jumps.\n\nWe first define the knight's possible moves for every digit in `moves`. Then, we initialize a `dp` vector (or an array in Java and JavaScript) with length 10, and fill it with 1, representing there is 1 way to reach each digit in 1 step.\n\nNext, we iterate through 2 to n, and in every iteration, we calculate the next state using the current state in the `dp`. We create a `new_dp` vector/array of size 10 filled with 0, representing the number of ways to reach each digit in the next iteration. For each digit `j`, we iterate through its possible moves and update the `new_dp[j]` accordingly. After that, we replace the `dp` with the `new_dp` for the next iteration.\n\nFinally, we sum up the elements in the `dp` array, modulo 10^9 + 7, and return it as the result.\n    "
    },
    {
        "id": 160,
        "title": "Odd Even Jump",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called **odd-numbered jumps**, and the (2nd, 4th, 6th, ...) jumps in the series are called **even-numbered jumps**. Note that the **jumps** are numbered, not the indices.\n\nYou may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n\n*   During **odd-numbered jumps** (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   During **even-numbered jumps** (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   It may be the case that for some index `i`, there are no legal jumps.\n\nA starting index is **good** if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n\nReturn _the number of **good** starting indices_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[10,13,12,14,15\\]\n**Output:** 2\n**Explanation:** \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr\\[2\\] is the smallest among arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\] that is greater or equal to arr\\[0\\]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[2,3,1,1,4\\]\n**Output:** 3\n**Explanation:** \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr\\[1\\] is the smallest value in \\[arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[0\\].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr\\[2\\] is the largest value in \\[arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is less than or equal to arr\\[1\\]. arr\\[3\\] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr\\[3\\] is the smallest value in \\[arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[2\\].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[5,1,3,4,2\\]\n**Output:** 3\n**Explanation:** We can reach the end from starting indices 1, 2, and 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 2 * 104`\n*   `0 <= arr[i] < 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Stack",
            "Monotonic Stack",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[10,13,12,14,15]",
                "output": "2"
            },
            {
                "input": "[2,3,1,1,4]",
                "output": "3"
            },
            {
                "input": "[5,1,3,4,2]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int rangeSumBST(TreeNode root, int low, int high) {\n    if (root == null) return 0;\n    if (root.val < low) return rangeSumBST(root.right, low, high);\n    if (root.val > high) return rangeSumBST(root.left, low, high);\n    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n}\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    ",
        "python": "\n    ```python\ndef rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\n    if not root:\n        return 0\n    if root.val < low:\n        return self.rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return self.rangeSumBST(root.left, low, high)\n    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    ",
        "c++": "\n    ```cpp\nint rangeSumBST(TreeNode* root, int low, int high) {\n    if (!root) return 0;\n    if (root->val < low) return rangeSumBST(root->right, low, high);\n    if (root->val > high) return rangeSumBST(root->left, low, high);\n    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n}\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    ",
        "js": "\n    ```javascript\nfunction rangeSumBST(root, low, high) {\n    if (!root) return 0;\n    if (root.val < low) return rangeSumBST(root.right, low, high);\n    if (root.val > high) return rangeSumBST(root.left, low, high);\n    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n}\n```\n    \n    The algorithm uses a recursive approach to traverse the binary search tree. At each step, we check whether the current node's value is within the given range or not. If it's within the range, we add it to the sum and continue traversing left and right subtrees. If the current node's value is less than `low`, it means that all the nodes in the left subtree will also be smaller, so we only traverse the right subtree. If the current node's value is greater than `high`, it means that all the nodes in the right subtree will also be larger, so we only traverse the left subtree.\n    "
    },
    {
        "id": 161,
        "title": "Unique Paths III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` integer array `grid` where `grid[i][j]` could be:\n\n*   `1` representing the starting square. There is exactly one starting square.\n*   `2` representing the ending square. There is exactly one ending square.\n*   `0` representing empty squares we can walk over.\n*   `-1` representing obstacles that we cannot walk over.\n\nReturn _the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,2,-1\\]\\]\n**Output:** 2\n**Explanation:** We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,0,2\\]\\]\n**Output:** 4\n**Explanation:** We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[0,1\\],\\[2,0\\]\\]\n**Output:** 0\n**Explanation:** There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 20`\n*   `1 <= m * n <= 20`\n*   `-1 <= grid[i][j] <= 2`\n*   There is exactly one starting cell and one ending cell.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking",
            "Bit Manipulation",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]",
                "output": "2"
            },
            {
                "input": "[[1,0,0,0],[0,0,0,0],[0,0,0,2]]",
                "output": "4"
            },
            {
                "input": "[[0,1],[2,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic String smallestSuperstring(String[] words) {\n    List<String> wordList = new ArrayList<>();\n    for (String word : words) {\n        wordList.add(word);\n    }\n\n    while (wordList.size() > 1) {\n        int maxLength = -1, p1 = 0, p2 = 0;\n        String temp = \"\";\n        for (int i = 0; i < wordList.size(); ++i) {\n            for (int j = i + 1; j < wordList.size(); ++j) {\n                int sharedLength = Math.min(wordList.get(i).length(), wordList.get(j).length());\n                for (; sharedLength > maxLength; --sharedLength) {\n                    if (wordList.get(i).endsWith(wordList.get(j).substring(0, sharedLength))) {\n                        maxLength = sharedLength;\n                        p1 = i;\n                        p2 = j;\n                        temp = wordList.get(i) + wordList.get(j).substring(sharedLength);\n                        break;\n                    }\n                }\n            }\n        }\n        wordList.set(p1, temp);\n        wordList.remove(p2);\n    }\n    return wordList.get(0);\n}\n```\n    \n    For C++, Java, and JavaScript, the implementation is similar. The algorithm tries to merge words greedily by their overlapped ends:\n1. Initialize a while loop that continues while there are more than 1 words in the list.\n2. Iterate over each pair of words i and j.\n3. Find the largest shared length between the end of the word at index i and the start of the word at index j.\n4. If the shared length is the maximum seen so far, store the indices i and j and the merged word formed by combining them.\n5. Replace the word at index i with the merged word and remove the word at index j.\n6. Continue the process until there's only one word left in the list, which is the final answer.\n\nThe Python implementation is slightly different. It first generates all permutations of words and iterates over each permutation. It calculates the merged length of the current permutation by merging consecutive words by their overlapped ends. Finally, the permutation with the shortest merged length is returned as the solution.\n    ",
        "python": "\n    ```python\nfrom itertools import permutations\n\ndef smallestSuperstring(words):\n    def get_shared_length(a, b):\n        for shared_length in range(min(len(a), len(b)), 0, -1):\n            if a[-shared_length:] == b[:shared_length]:\n                return shared_length\n        return 0\n\n    def merge(a, b, shared_length):\n        return a + b[shared_length:]\n\n    def get_total_length(merged_words):\n        return sum(len(word) for word in merged_words)\n\n    best = None\n    for perm in permutations(words):\n        merged_words = list(perm)\n        for i in range(len(words) - 1):\n            shared_length = get_shared_length(merged_words[i], merged_words[i + 1])\n            merged_words[i + 1] = merge(merged_words[i], merged_words[i + 1], shared_length)\n        if best is None or get_total_length(merged_words) < len(best):\n            best = \"\".join(merged_words)\n\n    return best\n```\n    \n    For C++, Java, and JavaScript, the implementation is similar. The algorithm tries to merge words greedily by their overlapped ends:\n1. Initialize a while loop that continues while there are more than 1 words in the list.\n2. Iterate over each pair of words i and j.\n3. Find the largest shared length between the end of the word at index i and the start of the word at index j.\n4. If the shared length is the maximum seen so far, store the indices i and j and the merged word formed by combining them.\n5. Replace the word at index i with the merged word and remove the word at index j.\n6. Continue the process until there's only one word left in the list, which is the final answer.\n\nThe Python implementation is slightly different. It first generates all permutations of words and iterates over each permutation. It calculates the merged length of the current permutation by merging consecutive words by their overlapped ends. Finally, the permutation with the shortest merged length is returned as the solution.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string smallestSuperstring(std::vector<std::string>& words) {\n    while (words.size() > 1) {\n        int maxLength = -1, p1 = 0, p2 = 0;\n        std::string temp;\n        for (int i = 0; i < words.size(); ++i) {\n            for (int j = i + 1; j < words.size(); ++j) {\n                int sharedLength = std::min(words[i].length(), words[j].length());\n                for (; sharedLength > maxLength; --sharedLength) {\n                    if (words[i].substr(words[i].length() - sharedLength) == words[j].substr(0, sharedLength)) {\n                        maxLength = sharedLength;\n                        p1 = i;\n                        p2 = j;\n                        temp = words[i] + words[j].substr(sharedLength);\n                        break;\n                    }\n                }\n            }\n        }\n        words[p1] = temp;\n        words.erase(words.begin() + p2);\n    }\n    return words[0];\n}\n```\n    \n    For C++, Java, and JavaScript, the implementation is similar. The algorithm tries to merge words greedily by their overlapped ends:\n1. Initialize a while loop that continues while there are more than 1 words in the list.\n2. Iterate over each pair of words i and j.\n3. Find the largest shared length between the end of the word at index i and the start of the word at index j.\n4. If the shared length is the maximum seen so far, store the indices i and j and the merged word formed by combining them.\n5. Replace the word at index i with the merged word and remove the word at index j.\n6. Continue the process until there's only one word left in the list, which is the final answer.\n\nThe Python implementation is slightly different. It first generates all permutations of words and iterates over each permutation. It calculates the merged length of the current permutation by merging consecutive words by their overlapped ends. Finally, the permutation with the shortest merged length is returned as the solution.\n    ",
        "js": "\n    ```javascript\nfunction smallestSuperstring(words) {\n    while (words.length > 1) {\n        let maxLength = -1, p1 = 0, p2 = 0;\n        let temp = \"\";\n        for (let i = 0; i < words.length; ++i) {\n            for (let j = i + 1; j < words.length; ++j) {\n                let sharedLength = Math.min(words[i].length, words[j].length);\n                for (; sharedLength > maxLength; --sharedLength) {\n                    if (words[i].slice(-sharedLength) === words[j].slice(0, sharedLength)) {\n                        maxLength = sharedLength;\n                        p1 = i;\n                        p2 = j;\n                        temp = words[i] + words[j].slice(sharedLength);\n                        break;\n                    }\n                }\n            }\n        }\n        words[p1] = temp;\n        words.splice(p2, 1);\n    }\n    return words[0];\n}\n```\n    \n    For C++, Java, and JavaScript, the implementation is similar. The algorithm tries to merge words greedily by their overlapped ends:\n1. Initialize a while loop that continues while there are more than 1 words in the list.\n2. Iterate over each pair of words i and j.\n3. Find the largest shared length between the end of the word at index i and the start of the word at index j.\n4. If the shared length is the maximum seen so far, store the indices i and j and the merged word formed by combining them.\n5. Replace the word at index i with the merged word and remove the word at index j.\n6. Continue the process until there's only one word left in the list, which is the final answer.\n\nThe Python implementation is slightly different. It first generates all permutations of words and iterates over each permutation. It calculates the merged length of the current permutation by merging consecutive words by their overlapped ends. Finally, the permutation with the shortest merged length is returned as the solution.\n    "
    },
    {
        "id": 162,
        "title": "Triples with Bitwise AND Equal To Zero",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array nums, return _the number of **AND triples**_.\n\nAn **AND triple** is a triple of indices `(i, j, k)` such that:\n\n*   `0 <= i < nums.length`\n*   `0 <= j < nums.length`\n*   `0 <= k < nums.length`\n*   `nums[i] & nums[j] & nums[k] == 0`, where `&` represents the bitwise-AND operator.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,3\\]\n**Output:** 12\n**Explanation:** We could choose the following i, j, k triples:\n(i=0, j=0, k=1) : 2 & 2 & 1\n(i=0, j=1, k=0) : 2 & 1 & 2\n(i=0, j=1, k=1) : 2 & 1 & 1\n(i=0, j=1, k=2) : 2 & 1 & 3\n(i=0, j=2, k=1) : 2 & 3 & 1\n(i=1, j=0, k=0) : 1 & 2 & 2\n(i=1, j=0, k=1) : 1 & 2 & 1\n(i=1, j=0, k=2) : 1 & 2 & 3\n(i=1, j=1, k=0) : 1 & 1 & 2\n(i=1, j=2, k=0) : 1 & 3 & 2\n(i=2, j=0, k=1) : 3 & 2 & 1\n(i=2, j=1, k=0) : 3 & 1 & 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** 27"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < 216`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[2,1,3]",
                "output": "12"
            },
            {
                "input": "[0,0,0]",
                "output": "27"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minMovesUnique(int[] nums) {\n    Arrays.sort(nums);\n    int moves = 0;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            moves += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return moves;\n}\n```\n    \n    1. Sort the given integer array.\n2. Initialize a counter (moves) to store the minimum number of moves.\n3. Iterate through the sorted array starting from the second element (i=1).\n4. Check if the current element (nums[i]) is less than or equal to the previous element (nums[i-1]), if yes, then:\n   a. Calculate the difference between the previous element and current element, and increment it by 1 (since we need the current element to be greater than the previous element).\n   b. Increment the moves counter by the calculated difference.\n   c. Update the current element (nums[i]) by adding the difference to its value (to make it unique).\n5. Return the moves counter after the iteration.\n    ",
        "python": "\n    ```python\ndef min_moves_unique(nums):\n    nums.sort()\n    moves = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            diff = nums[i - 1] - nums[i] + 1\n            moves += diff\n            nums[i] += diff\n    return moves\n```\n    \n    1. Sort the given integer array.\n2. Initialize a counter (moves) to store the minimum number of moves.\n3. Iterate through the sorted array starting from the second element (i=1).\n4. Check if the current element (nums[i]) is less than or equal to the previous element (nums[i-1]), if yes, then:\n   a. Calculate the difference between the previous element and current element, and increment it by 1 (since we need the current element to be greater than the previous element).\n   b. Increment the moves counter by the calculated difference.\n   c. Update the current element (nums[i]) by adding the difference to its value (to make it unique).\n5. Return the moves counter after the iteration.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint min_moves_unique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int moves = 0;\n    for (size_t i = 1; i < nums.size(); ++i) {\n        if (nums[i] <= nums[i - 1]) {\n            moves += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return moves;\n}\n```\n    \n    1. Sort the given integer array.\n2. Initialize a counter (moves) to store the minimum number of moves.\n3. Iterate through the sorted array starting from the second element (i=1).\n4. Check if the current element (nums[i]) is less than or equal to the previous element (nums[i-1]), if yes, then:\n   a. Calculate the difference between the previous element and current element, and increment it by 1 (since we need the current element to be greater than the previous element).\n   b. Increment the moves counter by the calculated difference.\n   c. Update the current element (nums[i]) by adding the difference to its value (to make it unique).\n5. Return the moves counter after the iteration.\n    ",
        "js": "\n    ```javascript\nfunction minMovesUnique(nums) {\n    nums.sort((a, b) => a - b);\n    let moves = 0;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            const diff = nums[i - 1] - nums[i] + 1;\n            moves += diff;\n            nums[i] += diff;\n        }\n    }\n    return moves;\n}\n```\n    \n    1. Sort the given integer array.\n2. Initialize a counter (moves) to store the minimum number of moves.\n3. Iterate through the sorted array starting from the second element (i=1).\n4. Check if the current element (nums[i]) is less than or equal to the previous element (nums[i-1]), if yes, then:\n   a. Calculate the difference between the previous element and current element, and increment it by 1 (since we need the current element to be greater than the previous element).\n   b. Increment the moves counter by the calculated difference.\n   c. Update the current element (nums[i]) by adding the difference to its value (to make it unique).\n5. Return the moves counter after the iteration.\n    "
    },
    {
        "id": 163,
        "title": "Vertical Order Traversal of a Binary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.\n\nFor each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.\n\nThe **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n\nReturn _the **vertical order traversal** of the binary tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[9\\],\\[3,15\\],\\[20\\],\\[7\\]\\]\n**Explanation:**\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3,4,5,6,7\\]\n**Output:** \\[\\[4\\],\\[2\\],\\[1,5,6\\],\\[3\\],\\[7\\]\\]\n**Explanation:**\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,2,3,4,6,5,7\\]\n**Output:** \\[\\[4\\],\\[2\\],\\[1,5,6\\],\\[3\\],\\[7\\]\\]\n**Explanation:**\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `0 <= Node.val <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Sorting",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[3,9,20,null,null,15,7]",
                "output": "[[9],[3,15],[20],[7]]"
            },
            {
                "input": "[1,2,3,4,5,6,7]",
                "output": "[[4],[2],[1,5,6],[3],[7]]"
            },
            {
                "input": "[1,2,3,4,6,5,7]",
                "output": "[[4],[2],[1,5,6],[3],[7]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] deckRevealedIncreasing(int[] deck) {\n    int n = deck.length;\n    Queue<Integer> index = new LinkedList<>();\n    for (int i = 0; i < n; i++)\n        index.add(i);\n\n    int[] ans = new int[n];\n    Arrays.sort(deck);\n    for (int card : deck) {\n        ans[index.poll()] = card;\n        if (!index.isEmpty()) {\n            index.add(index.poll());\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm creates an index deque (or Queue in JavaScript and Java) that stores the indices from 0 to N-1. It then sorts the given deck in increasing order. For each card in the sorted deck, it assigns the card to the answer array at the index taken from the front of the index deque. After that, while the index deque is not empty, it moves the next index at the front of the deque to the back.\n\nThis approach simulates the process of revealing cards and reordering the index deque.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef deckRevealedIncreasing(deck):\n    n = len(deck)\n    index = deque(range(n))\n    ans = [0] * n\n\n    deck.sort()\n    for card in deck:\n        ans[index.popleft()] = card\n        if index:\n            index.append(index.popleft())\n\n    return ans\n```\n    \n    The algorithm creates an index deque (or Queue in JavaScript and Java) that stores the indices from 0 to N-1. It then sorts the given deck in increasing order. For each card in the sorted deck, it assigns the card to the answer array at the index taken from the front of the index deque. After that, while the index deque is not empty, it moves the next index at the front of the deque to the back.\n\nThis approach simulates the process of revealing cards and reordering the index deque.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <deque>\n#include <algorithm>\n\nstd::vector<int> deckRevealedIncreasing(std::vector<int>& deck) {\n    int n = deck.size();\n    std::deque<int> index;\n    for (int i = 0; i < n; ++i)\n        index.push_back(i);\n\n    std::vector<int> ans(n);\n    std::sort(deck.begin(), deck.end());\n\n    for (int card : deck) {\n        ans[index.front()] = card;\n        index.pop_front();\n        if (!index.empty()) {\n            index.push_back(index.front());\n            index.pop_front();\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm creates an index deque (or Queue in JavaScript and Java) that stores the indices from 0 to N-1. It then sorts the given deck in increasing order. For each card in the sorted deck, it assigns the card to the answer array at the index taken from the front of the index deque. After that, while the index deque is not empty, it moves the next index at the front of the deque to the back.\n\nThis approach simulates the process of revealing cards and reordering the index deque.\n    ",
        "js": "\n    ```javascript\nfunction deckRevealedIncreasing(deck) {\n    const n = deck.length;\n    const index = [];\n    for (let i = 0; i < n; i++) {\n        index.push(i);\n    }\n\n    const ans = new Array(n);\n    deck.sort((a, b) => a - b);\n\n    for (const card of deck) {\n        ans[index.shift()] = card;\n        if (index.length) {\n            index.push(index.shift());\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm creates an index deque (or Queue in JavaScript and Java) that stores the indices from 0 to N-1. It then sorts the given deck in increasing order. For each card in the sorted deck, it assigns the card to the answer array at the index taken from the front of the index deque. After that, while the index deque is not empty, it moves the next index at the front of the deque to the back.\n\nThis approach simulates the process of revealing cards and reordering the index deque.\n    "
    },
    {
        "id": 164,
        "title": "Subarrays with K Different Integers",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the number of **good subarrays** of_ `nums`.\n\nA **good array** is an array where the number of different integers in that array is exactly `k`.\n\n*   For example, `[1,2,3,1,2]` has `3` different integers: `1`, `2`, and `3`.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,3\\], k = 2\n**Output:** 7\n**Explanation:** Subarrays formed with exactly 2 different integers: \\[1,2\\], \\[2,1\\], \\[1,2\\], \\[2,3\\], \\[1,2,1\\], \\[2,1,2\\], \\[1,2,1,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,3,4\\], k = 3\n**Output:** 3\n**Explanation:** Subarrays formed with exactly 3 different integers: \\[1,2,1,3\\], \\[2,1,3\\], \\[1,3,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i], k <= nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sliding Window",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,2,1,2,3],2",
                "output": "7"
            },
            {
                "input": "[1,2,1,3,4],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public int minDeletionSize(String[] strs) {\n        int n = strs.length;\n        int m = strs[0].length();\n        int[] dp = new int[m];\n        for (int j = 0; j < m; ++j) {\n            dp[j] = 1;\n            for (int i = 0; i < j; ++i) {\n                boolean flag = true;\n                for (int k = 0; k < n - 1; ++k)\n                    flag = flag && (strs[k].charAt(i) <= strs[k].charAt(j));\n                dp[j] = flag ? Math.max(dp[j], dp[i] + 1) : dp[j];\n            }\n        }\n\n        int maxLength = 0;\n        for (int num : dp)\n            maxLength = Math.max(maxLength, num);\n\n        return m - maxLength;\n    }\n}\n```\n\n    \n    The problem can be solved using dynamic programming. \n1. Create a `dp` array of the length of the strings in the input array, initialized with 1.\n2. Loop through the characters of the string elements twice (using two nested loops with indices `i` and `j`).\n3. For every pair of characters (strs[k][i] and strs[k][j]), check if i-th characters of all the strings are less than or equal to j-th characters in lexicographic order. If this condition is satisfied for all the i-th and j-th characters, update the value of dp[j] with the maximum of its current value and dp[i] + 1.\n4. The minimum number of deletion indices is the difference between the length of the strings in the input array and the maximum value in the `dp` array.\n\nThis approach ensures a dynamic update of the `dp` array by keeping track of the valid pairs of indices where lexicographic order is maintained. The final maximum value in the `dp` array represents the longest valid sequence of characters with lexicographic order maintained. The difference between this value and the length of the strings gives us the required minimum deletion indices to achieve lexicographic order.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        n = len(strs)\n        m = len(strs[0])\n        dp = [1] * m\n\n        for j in range(m):\n            for i in range(j):\n                flag = all(strs[k][i] <= strs[k][j] for k in range(n - 1))\n                dp[j] = max(dp[j], dp[i] + 1) if flag else dp[j]\n\n        return m - max(dp)\n```\n\n    \n    The problem can be solved using dynamic programming. \n1. Create a `dp` array of the length of the strings in the input array, initialized with 1.\n2. Loop through the characters of the string elements twice (using two nested loops with indices `i` and `j`).\n3. For every pair of characters (strs[k][i] and strs[k][j]), check if i-th characters of all the strings are less than or equal to j-th characters in lexicographic order. If this condition is satisfied for all the i-th and j-th characters, update the value of dp[j] with the maximum of its current value and dp[i] + 1.\n4. The minimum number of deletion indices is the difference between the length of the strings in the input array and the maximum value in the `dp` array.\n\nThis approach ensures a dynamic update of the `dp` array by keeping track of the valid pairs of indices where lexicographic order is maintained. The final maximum value in the `dp` array represents the longest valid sequence of characters with lexicographic order maintained. The difference between this value and the length of the strings gives us the required minimum deletion indices to achieve lexicographic order.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint minDeletionSize(vector<string>& strs) {\n    int n = strs.size();\n    int m = strs[0].length();\n    vector<int> dp(m, 1);\n\n    for (int j = 0; j < m; ++j)\n        for (int i = 0; i < j; ++i) {\n            bool flag = true;\n            for (int k = 0; k < n - 1; ++k)\n                flag = flag && (strs[k][i] <= strs[k][j]);\n            dp[j] = flag ? max(dp[j], dp[i] + 1) : dp[j];\n        }\n\n    return m - *max_element(dp.begin(), dp.end());\n}\n```\n\n    \n    The problem can be solved using dynamic programming. \n1. Create a `dp` array of the length of the strings in the input array, initialized with 1.\n2. Loop through the characters of the string elements twice (using two nested loops with indices `i` and `j`).\n3. For every pair of characters (strs[k][i] and strs[k][j]), check if i-th characters of all the strings are less than or equal to j-th characters in lexicographic order. If this condition is satisfied for all the i-th and j-th characters, update the value of dp[j] with the maximum of its current value and dp[i] + 1.\n4. The minimum number of deletion indices is the difference between the length of the strings in the input array and the maximum value in the `dp` array.\n\nThis approach ensures a dynamic update of the `dp` array by keeping track of the valid pairs of indices where lexicographic order is maintained. The final maximum value in the `dp` array represents the longest valid sequence of characters with lexicographic order maintained. The difference between this value and the length of the strings gives us the required minimum deletion indices to achieve lexicographic order.\n    ",
        "js": "\n    ```javascript\nvar minDeletionSize = function (strs) {\n  let n = strs.length;\n  let m = strs[0].length;\n  let dp = new Array(m).fill(1);\n\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0; i < j; ++i) {\n      let flag = true;\n      for (let k = 0; k < n - 1; ++k)\n        flag = flag && (strs[k][i] <= strs[k][j]);\n      dp[j] = flag ? Math.max(dp[j], dp[i] + 1) : dp[j];\n    }\n  }\n\n  return m - Math.max(...dp);\n};\n```\n\n    \n    The problem can be solved using dynamic programming. \n1. Create a `dp` array of the length of the strings in the input array, initialized with 1.\n2. Loop through the characters of the string elements twice (using two nested loops with indices `i` and `j`).\n3. For every pair of characters (strs[k][i] and strs[k][j]), check if i-th characters of all the strings are less than or equal to j-th characters in lexicographic order. If this condition is satisfied for all the i-th and j-th characters, update the value of dp[j] with the maximum of its current value and dp[i] + 1.\n4. The minimum number of deletion indices is the difference between the length of the strings in the input array and the maximum value in the `dp` array.\n\nThis approach ensures a dynamic update of the `dp` array by keeping track of the valid pairs of indices where lexicographic order is maintained. The final maximum value in the `dp` array represents the longest valid sequence of characters with lexicographic order maintained. The difference between this value and the length of the strings gives us the required minimum deletion indices to achieve lexicographic order.\n    "
    },
    {
        "id": 165,
        "title": "Minimum Number of K Consecutive Bit Flips",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a binary array `nums` and an integer `k`.\n\nA **k-bit flip** is choosing a **subarray** of length `k` from `nums` and simultaneously changing every `0` in the subarray to `1`, and every `1` in the subarray to `0`.\n\nReturn _the minimum number of **k-bit flips** required so that there is no_ `0` _in the array_. If it is not possible, return `-1`.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,0\\], k = 1\n**Output:** 2\n**Explanation:** Flip nums\\[0\\], then flip nums\\[2\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,0\\], k = 2\n**Output:** -1\n**Explanation:** No matter how we flip subarrays of size 2, we cannot make the array become \\[1,1,1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,0,0,1,0,1,1,0\\], k = 3\n**Output:** 3\n**Explanation:** \nFlip nums\\[0\\],nums\\[1\\],nums\\[2\\]: nums becomes \\[1,1,1,1,0,1,1,0\\]\nFlip nums\\[4\\],nums\\[5\\],nums\\[6\\]: nums becomes \\[1,1,1,1,1,0,0,0\\]\nFlip nums\\[5\\],nums\\[6\\],nums\\[7\\]: nums becomes \\[1,1,1,1,1,1,1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= k <= nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Queue",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[0,1,0],1",
                "output": "2"
            },
            {
                "input": "[1,1,0],2",
                "output": "-1"
            },
            {
                "input": "[0,0,0,1,0,1,1,0],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minKBitFlips(int[] nums, int k) {\n    int n = nums.length;\n    int[] flipped = new int[n];\n    int flips = 0, ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i >= k) flips -= flipped[i - k];\n        if ((flips + nums[i]) % 2 == 0) {\n            if (i + k > n) return -1;\n            flipped[i] = 1;\n            flips++;\n            ans++;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses the \"lazy flipping\" technique where, for each index `i` in `nums`, it checks whether there is a flip required, and if so, applies that flip \"lazily\" in the form of maintaining a separate `flipped` array. The `flipped` array indicators are then kept and updated as the algorithm iterates through the indices in `nums`.\n\nFor each index `i` in `nums`, the algorithm does the following:\n1. Removes the effect of a flip done K indices before by decrementing the `flips` counter.\n2. Checks if a flip is needed at the current index i.\n3. If a flip is required and it would go out of the array, return -1 as it is not possible.\n4. If a flip is possible, update the `flipped[i]` indicator, increment the `flips` counter, and increment the answer counter.\n5. Return the answer counter as the minimum number of k-bit flips required.\n\nThe final result is obtained by summing the flips as we move along the array effectively determining the minimum number of flips needed.\n    ",
        "python": "\n    ```python\ndef min_k_bit_flips(nums, k):\n    n = len(nums)\n    flipped = [0] * n\n    flips = ans = 0\n    for i in range(n):\n        if i >= k:\n            flips -= flipped[i - k]\n        if (flips + nums[i]) % 2 == 0:\n            if i + k > n:\n                return -1\n            flipped[i] = 1\n            flips += 1\n            ans += 1\n    return ans\n```\n    \n    The algorithm uses the \"lazy flipping\" technique where, for each index `i` in `nums`, it checks whether there is a flip required, and if so, applies that flip \"lazily\" in the form of maintaining a separate `flipped` array. The `flipped` array indicators are then kept and updated as the algorithm iterates through the indices in `nums`.\n\nFor each index `i` in `nums`, the algorithm does the following:\n1. Removes the effect of a flip done K indices before by decrementing the `flips` counter.\n2. Checks if a flip is needed at the current index i.\n3. If a flip is required and it would go out of the array, return -1 as it is not possible.\n4. If a flip is possible, update the `flipped[i]` indicator, increment the `flips` counter, and increment the answer counter.\n5. Return the answer counter as the minimum number of k-bit flips required.\n\nThe final result is obtained by summing the flips as we move along the array effectively determining the minimum number of flips needed.\n    ",
        "c++": "\n    ```cpp\nint minKBitFlips(vector<int>& nums, int k) {\n    int n = nums.size();\n    vector<int> flipped(n, 0);\n    int flips = 0, ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i >= k) flips = (flips - flipped[i - k]) % 2;\n        if ((flips + nums[i]) % 2 == 0) {\n            if (i + k > n) return -1;\n            flipped[i] = 1;\n            flips = (flips + 1) % 2;\n            ans++;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses the \"lazy flipping\" technique where, for each index `i` in `nums`, it checks whether there is a flip required, and if so, applies that flip \"lazily\" in the form of maintaining a separate `flipped` array. The `flipped` array indicators are then kept and updated as the algorithm iterates through the indices in `nums`.\n\nFor each index `i` in `nums`, the algorithm does the following:\n1. Removes the effect of a flip done K indices before by decrementing the `flips` counter.\n2. Checks if a flip is needed at the current index i.\n3. If a flip is required and it would go out of the array, return -1 as it is not possible.\n4. If a flip is possible, update the `flipped[i]` indicator, increment the `flips` counter, and increment the answer counter.\n5. Return the answer counter as the minimum number of k-bit flips required.\n\nThe final result is obtained by summing the flips as we move along the array effectively determining the minimum number of flips needed.\n    ",
        "js": "\n    ```javascript\nfunction minKBitFlips(nums, k) {\n    const n = nums.length;\n    const flipped = Array(n).fill(0);\n    let flips = 0, ans = 0;\n    for (let i = 0; i < n; ++i) {\n        if (i >= k) flips -= flipped[i - k];\n        if ((flips + nums[i]) % 2 === 0) {\n            if (i + k > n) return -1;\n            flipped[i] = 1;\n            flips++;\n            ans++;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses the \"lazy flipping\" technique where, for each index `i` in `nums`, it checks whether there is a flip required, and if so, applies that flip \"lazily\" in the form of maintaining a separate `flipped` array. The `flipped` array indicators are then kept and updated as the algorithm iterates through the indices in `nums`.\n\nFor each index `i` in `nums`, the algorithm does the following:\n1. Removes the effect of a flip done K indices before by decrementing the `flips` counter.\n2. Checks if a flip is needed at the current index i.\n3. If a flip is required and it would go out of the array, return -1 as it is not possible.\n4. If a flip is possible, update the `flipped[i]` indicator, increment the `flips` counter, and increment the answer counter.\n5. Return the answer counter as the minimum number of k-bit flips required.\n\nThe final result is obtained by summing the flips as we move along the array effectively determining the minimum number of flips needed.\n    "
    },
    {
        "id": 166,
        "title": "Number of Squareful Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "An array is **squareful** if the sum of every pair of adjacent elements is a **perfect square**.\n\nGiven an integer array nums, return _the number of permutations of_ `nums` _that are **squareful**_.\n\nTwo permutations `perm1` and `perm2` are different if there is some index `i` such that `perm1[i] != perm2[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,17,8\\]\n**Output:** 2\n**Explanation:** \\[1,8,17\\] and \\[17,8,1\\] are the valid permutations.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 12`\n*   `0 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,17,8]",
                "output": "2"
            },
            {
                "input": "[2,2,2]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int numSquarefulPerms(int[] nums) {\n    Map<Integer, Integer> counter = new HashMap<>();\n    for (int num : nums)\n        counter.put(num, counter.getOrDefault(num, 0) + 1);\n\n    return dfs(nums, 0, counter);\n}\n\nprivate boolean isSquare(int n) {\n    int root = (int) Math.sqrt(n);\n    return root * root == n;\n}\n\nprivate int dfs(int[] nums, int idx, Map<Integer, Integer> counter) {\n    if (idx == nums.length)\n        return 1;\n\n    int count = 0;\n    for (int key : counter.keySet()) {\n        if (counter.get(key) != 0 && (idx == 0 || isSquare(nums[idx - 1] + key))) {\n            counter.put(key, counter.get(key) - 1);\n            nums[idx] = key;\n            count += dfs(nums, idx + 1, counter);\n            counter.put(key, counter.get(key) + 1);\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    The algorithm first captures the frequency of each number in the input `nums` with a counter. Using a depth-first search algorithm, it then processes each permutation that starts with a number existing in `nums`, ensuring that the sum of adjacent elements in the permutation being processed is a perfect square. With each valid instance, the algorithm increases the count.\n\nThe base case for the recursive `dfs` function is when the current index `idx` is equal to the length of the `nums`, which is when a valid permutation is found. If this happens, the function returns 1, signaling the completion of the permutation.\n\nThe `isSquare` helper function checks if the given number `n` is a perfect square by taking its square root, then squaring the result again and comparing the squared value to the original value of `n`.\n\nFor each language, the code starts by creating a counter dict or map for `nums`, which stores the frequency of each element in `nums`. The `dfs` function then deals with forming the permutations and checking if they are squareful. If a permutation is found to be squareful, the count is incremented by 1 until all permutations are checked. The final count is returned.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef numSquarefulPerms(nums):\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    def dfs(idx):\n        if idx == len(nums):\n            return 1\n\n        count = 0\n        for key in counter.keys():\n            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):\n                counter[key] -= 1\n                nums[idx] = key\n                count += dfs(idx + 1)\n                counter[key] += 1\n\n        return count\n\n    key_set, counter = set(nums), Counter(nums)\n    return dfs(0)\n```\n\n    \n    The algorithm first captures the frequency of each number in the input `nums` with a counter. Using a depth-first search algorithm, it then processes each permutation that starts with a number existing in `nums`, ensuring that the sum of adjacent elements in the permutation being processed is a perfect square. With each valid instance, the algorithm increases the count.\n\nThe base case for the recursive `dfs` function is when the current index `idx` is equal to the length of the `nums`, which is when a valid permutation is found. If this happens, the function returns 1, signaling the completion of the permutation.\n\nThe `isSquare` helper function checks if the given number `n` is a perfect square by taking its square root, then squaring the result again and comparing the squared value to the original value of `n`.\n\nFor each language, the code starts by creating a counter dict or map for `nums`, which stores the frequency of each element in `nums`. The `dfs` function then deals with forming the permutations and checking if they are squareful. If a permutation is found to be squareful, the count is incremented by 1 until all permutations are checked. The final count is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nbool isSquare(int n) {\n    int root = sqrt(n);\n    return root * root == n;\n}\n\nvoid dfs(std::vector<int>& nums, int idx, int& count,\n         std::unordered_map<int, int>& counter) {\n    if (idx == nums.size()) {\n        count++;\n        return;\n    }\n\n    for (auto it : counter) {\n        if (it.second && (idx == 0 || isSquare(nums[idx - 1] + it.first))) {\n            counter[it.first]--;\n            nums[idx] = it.first;\n            dfs(nums, idx + 1, count, counter);\n            counter[it.first]++;\n        }\n    }\n}\n\nint numSquarefulPerms(std::vector<int>& nums) {\n    std::unordered_map<int, int> counter;\n    for (int num : nums)\n        counter[num]++;\n\n    int count = 0;\n    dfs(nums, 0, count, counter);\n    return count;\n}\n```\n\n    \n    The algorithm first captures the frequency of each number in the input `nums` with a counter. Using a depth-first search algorithm, it then processes each permutation that starts with a number existing in `nums`, ensuring that the sum of adjacent elements in the permutation being processed is a perfect square. With each valid instance, the algorithm increases the count.\n\nThe base case for the recursive `dfs` function is when the current index `idx` is equal to the length of the `nums`, which is when a valid permutation is found. If this happens, the function returns 1, signaling the completion of the permutation.\n\nThe `isSquare` helper function checks if the given number `n` is a perfect square by taking its square root, then squaring the result again and comparing the squared value to the original value of `n`.\n\nFor each language, the code starts by creating a counter dict or map for `nums`, which stores the frequency of each element in `nums`. The `dfs` function then deals with forming the permutations and checking if they are squareful. If a permutation is found to be squareful, the count is incremented by 1 until all permutations are checked. The final count is returned.\n    ",
        "js": "\n    ```javascript\nfunction numSquarefulPerms(nums) {\n    const counter = new Map();\n    nums.forEach(num => counter.set(num, (counter.get(num) || 0) + 1));\n\n    const isSquare = n => {\n        const root = Math.sqrt(n);\n        return Math.floor(root) * Math.floor(root) === n;\n    };\n\n    const dfs = (idx) => {\n        if (idx === nums.length)\n            return 1;\n\n        let count = 0;\n        for (let key of counter.keys()) {\n            if (counter.get(key) !== 0 && (idx === 0 || isSquare(nums[idx - 1] + key))) {\n                counter.set(key, counter.get(key) - 1);\n                nums[idx] = key;\n                count += dfs(idx + 1);\n                counter.set(key, counter.get(key) + 1);\n            }\n        }\n\n        return count;\n    };\n\n    return dfs(0);\n}\n```\n\n    \n    The algorithm first captures the frequency of each number in the input `nums` with a counter. Using a depth-first search algorithm, it then processes each permutation that starts with a number existing in `nums`, ensuring that the sum of adjacent elements in the permutation being processed is a perfect square. With each valid instance, the algorithm increases the count.\n\nThe base case for the recursive `dfs` function is when the current index `idx` is equal to the length of the `nums`, which is when a valid permutation is found. If this happens, the function returns 1, signaling the completion of the permutation.\n\nThe `isSquare` helper function checks if the given number `n` is a perfect square by taking its square root, then squaring the result again and comparing the squared value to the original value of `n`.\n\nFor each language, the code starts by creating a counter dict or map for `nums`, which stores the frequency of each element in `nums`. The `dfs` function then deals with forming the permutations and checking if they are squareful. If a permutation is found to be squareful, the count is incremented by 1 until all permutations are checked. The final count is returned.\n    "
    },
    {
        "id": 167,
        "title": "Minimum Cost to Merge Stones",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones.\n\nA move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles.\n\nReturn _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 2\n**Output:** 20\n**Explanation:** We start with \\[3, 2, 4, 1\\].\nWe merge \\[3, 2\\] for a cost of 5, and we are left with \\[5, 4, 1\\].\nWe merge \\[4, 1\\] for a cost of 5, and we are left with \\[5, 5\\].\nWe merge \\[5, 5\\] for a cost of 10, and we are left with \\[10\\].\nThe total cost was 20, and this is the minimum possible.\n\n",
                "**Example 2:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 3\n**Output:** -1\n**Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n",
                "**Example 3:**\n\n**Input:** stones = \\[3,5,1,2,6\\], k = 3\n**Output:** 25\n**Explanation:** We start with \\[3, 5, 1, 2, 6\\].\nWe merge \\[5, 1, 2\\] for a cost of 8, and we are left with \\[3, 8, 6\\].\nWe merge \\[3, 8, 6\\] for a cost of 17, and we are left with \\[17\\].\nThe total cost was 25, and this is the minimum possible."
            ],
            "constraints": "**Constraints:**\n\n*   `n == stones.length`\n*   `1 <= n <= 30`\n*   `1 <= stones[i] <= 100`\n*   `2 <= k <= 30`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[3,2,4,1],2",
                "output": "20"
            },
            {
                "input": "[3,2,4,1],3",
                "output": "-1"
            },
            {
                "input": "[3,5,1,2,6],3",
                "output": "25"
            }
        ],
        "java": "\n    ```java\npublic int minDeletionSize(String[] strs) {\n    int rows = strs.length, cols = strs[0].length();\n    int count = 0;\n    for (int c = 0; c < cols; ++c) {\n        for (int r = 1; r < rows; ++r) {\n            if (strs[r - 1].charAt(c) > strs[r].charAt(c)) {\n                ++count;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    ",
        "python": "\n    ```python\ndef min_deletion_size(strs):\n    rows, cols = len(strs), len(strs[0])\n    count = 0\n    for c in range(cols):\n        for r in range(1, rows):\n            if strs[r - 1][c] > strs[r][c]:\n                count += 1\n                break\n    return count\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint minDeletionSize(std::vector<std::string>& strs) {\n    int rows = strs.size(), cols = strs[0].size();\n    int count = 0;\n    for (int c = 0; c < cols; ++c) {\n        for (int r = 1; r < rows; ++r) {\n            if (strs[r - 1][c] > strs[r][c]) {\n                ++count;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    ",
        "js": "\n    ```javascript\nfunction minDeletionSize(strs) {\n    const rows = strs.length;\n    const cols = strs[0].length;\n    let count = 0;\n    for (let c = 0; c < cols; ++c) {\n        for (let r = 1; r < rows; ++r) {\n            if (strs[r - 1][c] > strs[r][c]) {\n                ++count;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n\n    \n    For a given set of strings, we need to find how many characters can be deleted so that each remaining string is in lexicographic order. To achieve this, we iterate through each column (character position) of the strings and compare each character in the current column to its adjacent one in the next row. If the character violates lexicographic order, we increment the deletion count and move to the next column. We do this for all columns and return the minimum number of character deletions required to satisfy the conditions mentioned.\n    "
    },
    {
        "id": 168,
        "title": "Grid Illumination",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp that is initially **turned off**.\n\nYou are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi, coli]` indicates that the lamp at `grid[rowi][coli]` is **turned on**. Even if the same lamp is listed more than once, it is turned on.\n\nWhen a lamp is turned on, it **illuminates its cell** and **all other cells** in the same **row, column, or diagonal**.\n\nYou are also given another 2D array `queries`, where `queries[j] = [rowj, colj]`. For the `jth` query, determine whether `grid[rowj][colj]` is illuminated or not. After answering the `jth` query, **turn off** the lamp at `grid[rowj][colj]` and its **8 adjacent lamps** if they exist. A lamp is adjacent if its cell shares either a side or corner with `grid[rowj][colj]`.\n\nReturn _an array of integers_ `ans`_,_ _where_ `ans[j]` _should be_ `1` _if the cell in the_ `jth` _query was illuminated, or_ `0` _if the lamp was not._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, lamps = \\[\\[0,0\\],\\[4,4\\]\\], queries = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** \\[1,0\\]\n**Explanation:** We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid\\[0\\]\\[0\\] then turning on the lamp at grid\\[4\\]\\[4\\].\nThe 0th query asks if the lamp at grid\\[1\\]\\[1\\] is illuminated or not (the blue square). It is illuminated, so set ans\\[0\\] = 1. Then, we turn off all lamps in the red square.\n \nThe 1st query asks if the lamp at grid\\[1\\]\\[0\\] is illuminated or not (the blue square). It is not illuminated, so set ans\\[1\\] = 0. Then, we turn off all lamps in the red rectangle.\n \n\n",
                "**Example 2:**\n\n**Input:** n = 5, lamps = \\[\\[0,0\\],\\[4,4\\]\\], queries = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** \\[1,1\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 5, lamps = \\[\\[0,0\\],\\[0,4\\]\\], queries = \\[\\[0,4\\],\\[0,1\\],\\[1,4\\]\\]\n**Output:** \\[1,1,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`\n*   `0 <= lamps.length <= 20000`\n*   `0 <= queries.length <= 20000`\n*   `lamps[i].length == 2`\n*   `0 <= rowi, coli < n`\n*   `queries[j].length == 2`\n*   `0 <= rowj, colj < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "5,[[0,0],[4,4]],[[1,1],[1,0]]",
                "output": "[1,0]"
            },
            {
                "input": "5,[[0,0],[4,4]],[[1,1],[1,1]]",
                "output": "[1,1]"
            },
            {
                "input": "5,[[0,0],[0,4]],[[0,4],[0,1],[1,4]]",
                "output": "[1,1,0]"
            }
        ],
        "java": "\n    ```java\npublic int repeatedNTimes(int[] nums) {\n    Map<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n        hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n        if (hashMap.get(num) > 1) return num;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm works in a simple way:\n\n1. Create an empty hash map to store the count of each number in the input array.\n2. Iterate through the input array nums.\n3. For each number in nums, increment its count in the hash map. If the count becomes greater than 1, return the number as it's the repeated element n times.\n\nThe algorithm has a linear time complexity by iterating through the input array once, and it uses a hash map to count the frequency of each element.\n    ",
        "python": "\n    ```python\ndef repeatedNTimes(nums):\n    hash_map = {}\n    for num in nums:\n        if num in hash_map:\n            return num\n        else:\n            hash_map[num] = 1\n```\n\n    \n    The algorithm works in a simple way:\n\n1. Create an empty hash map to store the count of each number in the input array.\n2. Iterate through the input array nums.\n3. For each number in nums, increment its count in the hash map. If the count becomes greater than 1, return the number as it's the repeated element n times.\n\nThe algorithm has a linear time complexity by iterating through the input array once, and it uses a hash map to count the frequency of each element.\n    ",
        "c++": "\n    ```cpp\nint repeatedNTimes(vector<int>& nums) {\n    unordered_map<int, int> hashMap;\n    for (int num : nums) {\n        if (++hashMap[num] > 1) return num;\n    }\n}\n```\n\n    \n    The algorithm works in a simple way:\n\n1. Create an empty hash map to store the count of each number in the input array.\n2. Iterate through the input array nums.\n3. For each number in nums, increment its count in the hash map. If the count becomes greater than 1, return the number as it's the repeated element n times.\n\nThe algorithm has a linear time complexity by iterating through the input array once, and it uses a hash map to count the frequency of each element.\n    ",
        "js": "\n    ```javascript\nfunction repeatedNTimes(nums) {\n    const hashMap = {};\n    for (const num of nums) {\n        if (hashMap[num]) return num;\n        hashMap[num] = 1;\n    }\n}\n```\n\n    \n    The algorithm works in a simple way:\n\n1. Create an empty hash map to store the count of each number in the input array.\n2. Iterate through the input array nums.\n3. For each number in nums, increment its count in the hash map. If the count becomes greater than 1, return the number as it's the repeated element n times.\n\nThe algorithm has a linear time complexity by iterating through the input array once, and it uses a hash map to count the frequency of each element.\n    "
    },
    {
        "id": 169,
        "title": "Numbers With Repeated Digits",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, return _the number of positive integers in the range_ `[1, n]` _that have **at least one** repeated digit_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 20\n**Output:** 1\n**Explanation:** The only positive number (<= 20) with at least 1 repeated digit is 11.\n\n",
                "**Example 2:**\n\n**Input:** n = 100\n**Output:** 10\n**Explanation:** The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\n",
                "**Example 3:**\n\n**Input:** n = 1000\n**Output:** 262"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "20",
                "output": "1"
            },
            {
                "input": "100",
                "output": "10"
            },
            {
                "input": "1000",
                "output": "262"
            }
        ],
        "java": "\n    ```java\npublic boolean isRationalEqual(String s, String t) {\n    Double num1 = evaluateString(s);\n    Double num2 = evaluateString(t);\n    return Math.abs(num1 - num2) < 1e-12;\n}\n\nprivate double evaluateString(String s) {\n    int i = s.indexOf('(');\n    if (i != -1) {\n        String base = s.substring(0, i);\n        String rep = s.substring(i + 1, s.length() - 1);\n        for (int k = 0; k < 20; ++k) {\n            base += rep;\n        }\n        return Double.parseDouble(base);\n    }\n    return Double.parseDouble(s);\n}\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    ",
        "python": "\n    ```python\ndef isRationalEqual(s: str, t: str) -> bool:\n    def evaluate(s: str) -> float:\n        i = s.find('(')\n        if i != -1:\n            base = s[:i]\n            rep = s[i + 1:-1]\n            return float(base + rep * 20)\n        return float(s)\n\n    return abs(evaluate(s) - evaluate(t)) < 1e-12\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    ",
        "c++": "\n    ```cpp\nbool isRationalEqual(std::string s, std::string t) {\n    auto eval = [](std::string s) {\n        int i = s.find('(');\n        if (i != std::string::npos) {\n            std::string base = s.substr(0, i);\n            std::string rep = s.substr(i + 1, s.length() - i - 2);\n            for (int k = 0; k < 20; ++k) base += rep;\n            return stod(base);\n        }\n        return stod(s);\n    };\n    return fabs(eval(s) - eval(t)) < 1e-12;\n}\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    ",
        "js": "\n    ```javascript\nfunction isRationalEqual(s, t) {\n    const evaluate = (s) => {\n        let i = s.indexOf('(');\n        if (i !== -1) {\n            let base = s.substring(0, i);\n            let rep = s.substring(i + 1, s.length - 1);\n            for (let k = 0; k < 20; ++k) {\n                base += rep;\n            }\n            return parseFloat(base);\n        }\n        return parseFloat(s);\n    };\n    return Math.abs(evaluate(s) - evaluate(t)) < 1e-12;\n}\n```\n    \n    The given algorithm proceeds in the following steps:\n\n1. Use a lambda function (or a separate function in Java) named 'eval' or 'evaluate' which takes a string representing a rational number as input.\n2. Check if the input string has the repeating part (by finding the index of the opening bracket `(`).\n3. If the input string has a repeating part, extract the base and repeating part separately. Then append the repeating part 20 times to the base part, and convert the resulting string into a floating-point number. Else, convert the input string into a floating-point number directly.\n4. Call the 'eval' or 'evaluate' function for both input strings `s` and `t`, and calculate the absolute difference between the two numbers.\n5. Check if the absolute difference is less than 1e-12, and if so, return true; else, return false.\n\nThe algorithm thus compares the given rational numbers by converting them into floating-point numbers and checking if they have the same numerical value within a very small margin of error (1e-12). This technique ensures that small differences in the way the numbers are represented do not affect the comparison result.\n    "
    },
    {
        "id": 170,
        "title": "Recover a Tree From Preorder Traversal",
        "difficulty": "Hard",
        "content": {
            "problem": "We run a preorder depth-first search (DFS) on the `root` of a binary tree.\n\nAt each node in this traversal, we output `D` dashes (where `D` is the depth of this node), then we output the value of this node. If the depth of a node is `D`, the depth of its immediate child is `D + 1`. The depth of the `root` node is `0`.\n\nIf a node has only one child, that child is guaranteed to be **the left child**.\n\nGiven the output `traversal` of this traversal, recover the tree and return _its_ `root`.",
            "examples": [
                "**Example 1:**\n\n**Input:** traversal =  \"1-2--3--4-5--6--7 \"\n**Output:** \\[1,2,5,3,4,6,7\\]\n\n",
                "**Example 2:**\n\n**Input:** traversal =  \"1-2--3---4-5--6---7 \"\n**Output:** \\[1,2,5,3,null,6,null,4,null,7\\]\n\n",
                "**Example 3:**\n\n**Input:** traversal =  \"1-401--349---90--88 \"\n**Output:** \\[1,401,null,349,88,90\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the original tree is in the range `[1, 1000]`.\n*   `1 <= Node.val <= 109`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "\"1-2--3--4-5--6--7\"",
                "output": "[1,2,5,3,4,6,7]"
            },
            {
                "input": "\"1-2--3---4-5--6---7\"",
                "output": "[1,2,5,3,null,6,null,4,null,7]"
            },
            {
                "input": "\"1-401--349---90--88\"",
                "output": "[1,401,null,349,88,90]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<int[]> intervalIntersection(int[][] firstList, int[][] secondList) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0, j = 0;\n    \n    while (i < firstList.length && j < secondList.length) {\n        int start = Math.max(firstList[i][0], secondList[j][0]);\n        int end = Math.min(firstList[i][1], secondList[j][1]);\n        \n        if (start <= end) {\n            result.add(new int[]{start, end});\n        }\n        \n        if (firstList[i][1] < secondList[j][1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm starts by initializing two pointers `i` and `j`, which will iterate over `firstList` and `secondList`, respectively. We then loop through both lists simultaneously, finding the start and end intervals of the current intersection by taking the maximum of their respective starts and the minimum of their respective ends.\n\nIf the start of the intersection is less than or equal to the end of the intersection, this means there is an intersection between the intervals, so we add the intersection to the result list.\n\nAfter checking for an intersection, we move one pointer, either `i` or `j`, to the next interval in their respective lists depending on which interval has a smaller end point. This ensures we move closer to the next intersection and keep searching for other intersections between both lists without running into already checked intervals.\n\nThe loop continues until one of the pointers reaches the end of its respective list, which means that we have checked all potential intersections. The resulting list of intersections is then returned.\n    ",
        "python": "\n    ```python\ndef interval_intersection(firstList, secondList):\n    result = []\n    i, j = 0, 0\n\n    while i < len(firstList) and j < len(secondList):\n        start = max(firstList[i][0], secondList[j][0])\n        end = min(firstList[i][1], secondList[j][1])\n\n        if start <= end:\n            result.append([start, end])\n\n        if firstList[i][1] < secondList[j][1]:\n            i += 1\n        else:\n            j += 1\n\n    return result\n```\n    \n    The algorithm starts by initializing two pointers `i` and `j`, which will iterate over `firstList` and `secondList`, respectively. We then loop through both lists simultaneously, finding the start and end intervals of the current intersection by taking the maximum of their respective starts and the minimum of their respective ends.\n\nIf the start of the intersection is less than or equal to the end of the intersection, this means there is an intersection between the intervals, so we add the intersection to the result list.\n\nAfter checking for an intersection, we move one pointer, either `i` or `j`, to the next interval in their respective lists depending on which interval has a smaller end point. This ensures we move closer to the next intersection and keep searching for other intersections between both lists without running into already checked intervals.\n\nThe loop continues until one of the pointers reaches the end of its respective list, which means that we have checked all potential intersections. The resulting list of intersections is then returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {\n    vector<vector<int>> result;\n    int i = 0, j = 0;\n    \n    while (i < firstList.size() && j < secondList.size()) {\n        int start = max(firstList[i][0], secondList[j][0]);\n        int end = min(firstList[i][1], secondList[j][1]);\n        \n        if (start <= end) {\n            result.push_back({start, end});\n        }\n        \n        if (firstList[i][1] < secondList[j][1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm starts by initializing two pointers `i` and `j`, which will iterate over `firstList` and `secondList`, respectively. We then loop through both lists simultaneously, finding the start and end intervals of the current intersection by taking the maximum of their respective starts and the minimum of their respective ends.\n\nIf the start of the intersection is less than or equal to the end of the intersection, this means there is an intersection between the intervals, so we add the intersection to the result list.\n\nAfter checking for an intersection, we move one pointer, either `i` or `j`, to the next interval in their respective lists depending on which interval has a smaller end point. This ensures we move closer to the next intersection and keep searching for other intersections between both lists without running into already checked intervals.\n\nThe loop continues until one of the pointers reaches the end of its respective list, which means that we have checked all potential intersections. The resulting list of intersections is then returned.\n    ",
        "js": "\n    ```javascript\nfunction intervalIntersection(firstList, secondList) {\n    const result = [];\n    let i = 0, j = 0;\n\n    while (i < firstList.length && j < secondList.length) {\n        const start = Math.max(firstList[i][0], secondList[j][0]);\n        const end = Math.min(firstList[i][1], secondList[j][1]);\n\n        if (start <= end) {\n            result.push([start, end]);\n        }\n\n        if (firstList[i][1] < secondList[j][1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by initializing two pointers `i` and `j`, which will iterate over `firstList` and `secondList`, respectively. We then loop through both lists simultaneously, finding the start and end intervals of the current intersection by taking the maximum of their respective starts and the minimum of their respective ends.\n\nIf the start of the intersection is less than or equal to the end of the intersection, this means there is an intersection between the intervals, so we add the intersection to the result list.\n\nAfter checking for an intersection, we move one pointer, either `i` or `j`, to the next interval in their respective lists depending on which interval has a smaller end point. This ensures we move closer to the next intersection and keep searching for other intersections between both lists without running into already checked intervals.\n\nThe loop continues until one of the pointers reaches the end of its respective list, which means that we have checked all potential intersections. The resulting list of intersections is then returned.\n    "
    },
    {
        "id": 171,
        "title": "Stream of Characters",
        "difficulty": "Hard",
        "content": {
            "problem": "Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings `words`.\n\nFor example, if `words = [ \"abc \", \"xyz \"]` and the stream added the four characters (one by one) `'a'`, `'x'`, `'y'`, and `'z'`, your algorithm should detect that the suffix `\"xyz \"` of the characters `\"axyz \"` matches `\"xyz \"` from `words`.\n\nImplement the `StreamChecker` class:\n\n*   `StreamChecker(String[] words)` Initializes the object with the strings array `words`.\n*   `boolean query(char letter)` Accepts a new character from the stream and returns `true` if any non-empty suffix from the stream forms a word that is in `words`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"StreamChecker \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \",  \"query \"\\]\n\\[\\[\\[ \"cd \",  \"f \",  \"kl \"\\]\\], \\[ \"a \"\\], \\[ \"b \"\\], \\[ \"c \"\\], \\[ \"d \"\\], \\[ \"e \"\\], \\[ \"f \"\\], \\[ \"g \"\\], \\[ \"h \"\\], \\[ \"i \"\\], \\[ \"j \"\\], \\[ \"k \"\\], \\[ \"l \"\\]\\]\n**Output**\n\\[null, false, false, false, true, false, true, false, false, false, false, false, true\\]\n\n**Explanation**\nStreamChecker streamChecker = new StreamChecker(\\[ \"cd \",  \"f \",  \"kl \"\\]);\nstreamChecker.query( \"a \"); // return False\nstreamChecker.query( \"b \"); // return False\nstreamChecker.query( \"c \"); // return False\nstreamChecker.query( \"d \"); // return True, because 'cd' is in the wordlist\nstreamChecker.query( \"e \"); // return False\nstreamChecker.query( \"f \"); // return True, because 'f' is in the wordlist\nstreamChecker.query( \"g \"); // return False\nstreamChecker.query( \"h \"); // return False\nstreamChecker.query( \"i \"); // return False\nstreamChecker.query( \"j \"); // return False\nstreamChecker.query( \"k \"); // return False\nstreamChecker.query( \"l \"); // return True, because 'kl' is in the wordlist"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 2000`\n*   `1 <= words[i].length <= 200`\n*   `words[i]` consists of lowercase English letters.\n*   `letter` is a lowercase English letter.\n*   At most `4 * 104` calls will be made to query.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Design",
            "Trie",
            "Data Stream"
        ],
        "example": [
            {
                "input": "]\n]],[\"a\"],[\"b\"],[\"c\"],[\"d\"],[\"e\"],[\"f\"],[\"g\"],[\"h\"],[\"i\"],[\"j\"],[\"k\"],[\"l\"]]",
                "output": "**Output**\n[null,false,false,false,true,false,true,false,false,false,false,false,true]"
            }
        ],
        "java": "\n    ```java\npublic boolean equationsPossible(String[] equations) {\n    int[] parent = new int[26];\n    for (int i = 0; i < 26; ++i) {\n        parent[i] = i;\n    }\n\n    for (String e : equations) {\n        if (e.charAt(1) == '=') {\n            int x = e.charAt(0) - 'a';\n            int y = e.charAt(3) - 'a';\n            parent[find(x, parent)] = find(y, parent);\n        }\n    }\n\n    for (String e : equations) {\n        if (e.charAt(1) == '!' && find(e.charAt(0) - 'a', parent) == find(e.charAt(3) - 'a', parent)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nprivate int find(int x, int[] parent) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x], parent);\n    }\n\n    return parent[x];\n}\n```\n\n    \n    The algorithm is the same for all languages:\n\n1. Create an array `parent` to store the parent indices, initially equal to the indices themselves (i.e., the parent of the element at index i is itself).\n\n2. Iterate through the `equations`, and for each equation where the relationship is equality (value at index 1 is '='), union the elements - update the parent of the first element to be the parent of the second element. Use the find function to find the root of each element.\n\n3. Iterate through the `equations` again, and for each equation where the relationship is inequality (value at index 1 is '!'), check if both variable nodes have the same parent. If they have the same parent, it means their values must be equal, which makes the inequality equation false. Therefore, return false.\n\n4. If all the equalities and inequalities hold, return true.\n\nNote that the only difference in code implementation is due to the syntax differences in each language. The algorithm remains the same.\n    ",
        "python": "\n    ```python\ndef equationsPossible(equations):\n    parent = [i for i in range(26)]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    for e in equations:\n        if e[1] == '=':\n            x = ord(e[0]) - ord('a')\n            y = ord(e[3]) - ord('a')\n            parent[find(x)] = find(y)\n\n    for e in equations:\n        if e[1] == '!' and find(ord(e[0]) - ord('a')) == find(ord(e[3]) - ord('a')):\n            return False\n\n    return True\n```\n\n    \n    The algorithm is the same for all languages:\n\n1. Create an array `parent` to store the parent indices, initially equal to the indices themselves (i.e., the parent of the element at index i is itself).\n\n2. Iterate through the `equations`, and for each equation where the relationship is equality (value at index 1 is '='), union the elements - update the parent of the first element to be the parent of the second element. Use the find function to find the root of each element.\n\n3. Iterate through the `equations` again, and for each equation where the relationship is inequality (value at index 1 is '!'), check if both variable nodes have the same parent. If they have the same parent, it means their values must be equal, which makes the inequality equation false. Therefore, return false.\n\n4. If all the equalities and inequalities hold, return true.\n\nNote that the only difference in code implementation is due to the syntax differences in each language. The algorithm remains the same.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nbool equationsPossible(std::vector<std::string>& equations) {\n    std::vector<int> parent(26, 0);\n\n    for (int i = 0; i < 26; ++i) {\n        parent[i] = i;\n    }\n\n    for (const auto& eq : equations) {\n        if (eq[1] == '=') {\n            int x = eq[0] - 'a';\n            int y = eq[3] - 'a';\n            parent[find(x, parent)] = find(y, parent);\n        }\n    }\n\n    for (const auto& eq : equations) {\n        if (eq[1] == '!' && find(eq[0] - 'a', parent) == find(eq[3] - 'a', parent)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint find(int x, std::vector<int>& parent) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x], parent);\n    }\n\n    return parent[x];\n}\n```\n\n    \n    The algorithm is the same for all languages:\n\n1. Create an array `parent` to store the parent indices, initially equal to the indices themselves (i.e., the parent of the element at index i is itself).\n\n2. Iterate through the `equations`, and for each equation where the relationship is equality (value at index 1 is '='), union the elements - update the parent of the first element to be the parent of the second element. Use the find function to find the root of each element.\n\n3. Iterate through the `equations` again, and for each equation where the relationship is inequality (value at index 1 is '!'), check if both variable nodes have the same parent. If they have the same parent, it means their values must be equal, which makes the inequality equation false. Therefore, return false.\n\n4. If all the equalities and inequalities hold, return true.\n\nNote that the only difference in code implementation is due to the syntax differences in each language. The algorithm remains the same.\n    ",
        "js": "\n    ```javascript\nfunction equationsPossible(equations) {\n    const parent = [...Array(26).keys()];\n\n    const find = (x) => {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    };\n\n    for (let e of equations) {\n        if (e[1] === '=') {\n            const x = e.charCodeAt(0) - 'a'.charCodeAt(0);\n            const y = e.charCodeAt(3) - 'a'.charCodeAt(0);\n            parent[find(x)] = find(y);\n        }\n    }\n\n    for (let e of equations) {\n        if (e[1] === '!' && find(e.charCodeAt(0) - 'a'.charCodeAt(0)) === find(e.charCodeAt(3) - 'a'.charCodeAt(0))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm is the same for all languages:\n\n1. Create an array `parent` to store the parent indices, initially equal to the indices themselves (i.e., the parent of the element at index i is itself).\n\n2. Iterate through the `equations`, and for each equation where the relationship is equality (value at index 1 is '='), union the elements - update the parent of the first element to be the parent of the second element. Use the find function to find the root of each element.\n\n3. Iterate through the `equations` again, and for each equation where the relationship is inequality (value at index 1 is '!'), check if both variable nodes have the same parent. If they have the same parent, it means their values must be equal, which makes the inequality equation false. Therefore, return false.\n\n4. If all the equalities and inequalities hold, return true.\n\nNote that the only difference in code implementation is due to the syntax differences in each language. The algorithm remains the same.\n    "
    },
    {
        "id": 172,
        "title": "Escape a Large Maze",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are `(x, y)`.\n\nWe start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`.\n\nEach move, we can walk one square north, east, south, or west if the square is **not** in the array of `blocked` squares. We are also not allowed to walk outside of the grid.\n\nReturn `true` _if and only if it is possible to reach the_ `target` _square from the_ `source` _square through a sequence of valid moves_.",
            "examples": [
                "**Example 1:**\n\n**Input:** blocked = \\[\\[0,1\\],\\[1,0\\]\\], source = \\[0,0\\], target = \\[0,2\\]\n**Output:** false\n**Explanation:** The target square is inaccessible starting from the source square because we cannot move.\nWe cannot move north or east because those squares are blocked.\nWe cannot move south or west because we cannot go outside of the grid.\n\n",
                "**Example 2:**\n\n**Input:** blocked = \\[\\], source = \\[0,0\\], target = \\[999999,999999\\]\n**Output:** true\n**Explanation:** Because there are no blocked cells, it is possible to reach the target square."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= blocked.length <= 200`\n*   `blocked[i].length == 2`\n*   `0 <= xi, yi < 106`\n*   `source.length == target.length == 2`\n*   `0 <= sx, sy, tx, ty < 106`\n*   `source != target`\n*   It is guaranteed that `source` and `target` are not blocked.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Depth-First Search",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "[[0,1],[1,0]],[0,0],[0,2]",
                "output": "false"
            },
            {
                "input": "[],[0,0],[999999,999999]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int orangesRotting(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int freshOranges = 0;\n    Queue<int[]> rotten = new LinkedList<>();\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1)\n                freshOranges++;\n            else if (grid[i][j] == 2)\n                rotten.offer(new int[]{i, j});\n        }\n    }\n    \n    int minutes = 0;\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    while (!rotten.isEmpty() && freshOranges != 0) {\n        int size = rotten.size();\n        for (int i = 0; i < size; ++i) {\n            int[] current = rotten.poll();\n\n            for (int[] direction : directions) {\n                int x = current[0] + direction[0];\n                int y = current[1] + direction[1];\n\n                if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 1)\n                    continue;\n\n                grid[x][y] = 2;\n                freshOranges--;\n                rotten.offer(new int[]{x, y});\n            }\n        }\n        minutes++;\n    }\n    \n    return freshOranges == 0 ? minutes : -1;\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) approach. Initially, it loops through the grid to count the number of fresh oranges and to store the rotten oranges in a queue. Then, it starts processing rotten oranges from the queue. For each rotten orange, it checks the four adjacent cells (up, down, left, right). If an adjacent cell has a fresh orange, it turns it into a rotten one, decreases the fresh orange counter and appends it to the queue. The process is repeated for all rotten oranges until there are no more fresh oranges or the queue is empty. Finally, the algorithm returns the number of minutes taken, or -1 if there are still fresh oranges left.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef orangesRotting(grid):\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n    \n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    return minutes if fresh_oranges == 0 else -1\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) approach. Initially, it loops through the grid to count the number of fresh oranges and to store the rotten oranges in a queue. Then, it starts processing rotten oranges from the queue. For each rotten orange, it checks the four adjacent cells (up, down, left, right). If an adjacent cell has a fresh orange, it turns it into a rotten one, decreases the fresh orange counter and appends it to the queue. The process is repeated for all rotten oranges until there are no more fresh oranges or the queue is empty. Finally, the algorithm returns the number of minutes taken, or -1 if there are still fresh oranges left.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint orangesRotting(std::vector<std::vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    int freshOranges = 0;\n    std::queue<std::pair<int, int>> rotten;\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1)\n                freshOranges++;\n            else if (grid[i][j] == 2)\n                rotten.push({i, j});\n        }\n    }\n    \n    int minutes = 0;\n    std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    while (!rotten.empty() && freshOranges != 0) {\n        int size = rotten.size();\n        for (int i = 0; i < size; ++i) {\n            auto current = rotten.front();\n            rotten.pop();\n\n            for (auto& direction : directions) {\n                int x = current.first + direction[0];\n                int y = current.second + direction[1];\n\n                if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 1)\n                    continue;\n\n                grid[x][y] = 2;\n                freshOranges--;\n                rotten.push({x, y});\n            }\n        }\n        minutes++;\n    }\n    \n    return freshOranges == 0 ? minutes : -1;\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) approach. Initially, it loops through the grid to count the number of fresh oranges and to store the rotten oranges in a queue. Then, it starts processing rotten oranges from the queue. For each rotten orange, it checks the four adjacent cells (up, down, left, right). If an adjacent cell has a fresh orange, it turns it into a rotten one, decreases the fresh orange counter and appends it to the queue. The process is repeated for all rotten oranges until there are no more fresh oranges or the queue is empty. Finally, the algorithm returns the number of minutes taken, or -1 if there are still fresh oranges left.\n    ",
        "js": "\n    ```javascript\nfunction orangesRotting(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    let freshOranges = 0;\n    const rotten = [];\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] === 1)\n                freshOranges++;\n            else if (grid[i][j] === 2)\n                rotten.push([i, j]);\n        }\n    }\n    \n    let minutes = 0;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    \n    while (rotten.length && freshOranges !== 0) {\n        const size = rotten.length;\n        for (let i = 0; i < size; ++i) {\n            const [x, y] = rotten.shift();\n\n            for (const [dx, dy] of directions) {\n                const nx = x + dx;\n                const ny = y + dy;\n\n                if (nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] !== 1)\n                    continue;\n\n                grid[nx][ny] = 2;\n                freshOranges--;\n                rotten.push([nx, ny]);\n            }\n        }\n        minutes++;\n    }\n    \n    return freshOranges === 0 ? minutes : -1;\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) approach. Initially, it loops through the grid to count the number of fresh oranges and to store the rotten oranges in a queue. Then, it starts processing rotten oranges from the queue. For each rotten orange, it checks the four adjacent cells (up, down, left, right). If an adjacent cell has a fresh orange, it turns it into a rotten one, decreases the fresh orange counter and appends it to the queue. The process is repeated for all rotten oranges until there are no more fresh oranges or the queue is empty. Finally, the algorithm returns the number of minutes taken, or -1 if there are still fresh oranges left.\n    "
    },
    {
        "id": 173,
        "title": "Longest Duplicate Substring",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, consider all _duplicated substrings_: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.\n\nReturn **any** duplicated substring that has the longest possible length. If `s` does not have a duplicated substring, the answer is `\" \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"banana\"\n**Output:** \"ana\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\"\n**Output:** \"\""
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 3 * 104`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Binary Search",
            "Sliding Window",
            "Rolling Hash",
            "Suffix Array",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"banana\"",
                "output": "\"ana\""
            },
            {
                "input": "\"abcd\"",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Character> commonChars(String[] words) {\n    Map<Character, Integer> merged = new HashMap<>();\n\n    for (String word : words) {\n        Map<Character, Integer> wordMap = new HashMap<>();\n        for (char c : word.toCharArray()) {\n            wordMap.put(c, wordMap.getOrDefault(c, 0) + 1);\n        }\n        if (merged.isEmpty()) {\n            merged = wordMap;\n        } else {\n            for (char c : merged.keySet()) {\n                merged.put(c, Math.min(merged.get(c), wordMap.getOrDefault(c, 0)));\n            }\n        }\n    }\n\n    List<Character> result = new ArrayList<>();\n    for (Map.Entry<Character, Integer> entry : merged.entrySet()) {\n        for (int i = 0; i < entry.getValue(); i++) {\n            result.add(entry.getKey());\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm follows these steps:\n\n1. Initialize an empty hash_map (C++)/HashMap (Java)/Counter (Python)/Object (JavaScript) `merged` to store the count of characters that appear in all words.\n2. Iterate through each word in the input array `words`.\n3. For each word, create a map `wordMap` to store the count of each character in the word.\n4. If `merged` is empty, set `merged` equal to `wordMap`. Otherwise, update the count of each character in `merged` with the minimum count of the same character in `wordMap`. This ensures that we only keep the count of characters that appear in all words.\n5. After iterating through all words, create a result array/list.\n6. For each character in `merged`, add the character to the result array/list with its count as the number of duplicates.\n7. Return the result array/list.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef commonChars(words):\n    merged = Counter()\n    for word in words:\n        word_count = Counter(word)\n        if not merged:\n            merged = word_count\n        else:\n            for char in merged:\n                merged[char] = min(merged[char], word_count[char])\n\n    result = []\n    for char, count in merged.items():\n        result.extend([char] * count)\n    return result\n```\n    \n    The algorithm follows these steps:\n\n1. Initialize an empty hash_map (C++)/HashMap (Java)/Counter (Python)/Object (JavaScript) `merged` to store the count of characters that appear in all words.\n2. Iterate through each word in the input array `words`.\n3. For each word, create a map `wordMap` to store the count of each character in the word.\n4. If `merged` is empty, set `merged` equal to `wordMap`. Otherwise, update the count of each character in `merged` with the minimum count of the same character in `wordMap`. This ensures that we only keep the count of characters that appear in all words.\n5. After iterating through all words, create a result array/list.\n6. For each character in `merged`, add the character to the result array/list with its count as the number of duplicates.\n7. Return the result array/list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<char> commonChars(std::vector<std::string>& words) {\n    std::unordered_map<char, int> merged;\n    for (const auto& word : words) {\n        std::unordered_map<char, int> word_map;\n        for (char c : word) {\n            ++word_map[c];\n        }\n        if (merged.empty()) {\n            merged = word_map;\n        }\n        else {\n            for (auto& entry : merged) {\n                entry.second = std::min(entry.second, word_map[entry.first]);\n            }\n        }\n    }\n\n    std::vector<char> result;\n    for (const auto& entry : merged) {\n        for (int i = 0; i < entry.second; ++i) {\n            result.push_back(entry.first);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm follows these steps:\n\n1. Initialize an empty hash_map (C++)/HashMap (Java)/Counter (Python)/Object (JavaScript) `merged` to store the count of characters that appear in all words.\n2. Iterate through each word in the input array `words`.\n3. For each word, create a map `wordMap` to store the count of each character in the word.\n4. If `merged` is empty, set `merged` equal to `wordMap`. Otherwise, update the count of each character in `merged` with the minimum count of the same character in `wordMap`. This ensures that we only keep the count of characters that appear in all words.\n5. After iterating through all words, create a result array/list.\n6. For each character in `merged`, add the character to the result array/list with its count as the number of duplicates.\n7. Return the result array/list.\n    ",
        "js": "\n    ```javascript\nfunction commonChars(words) {\n    let merged = {};\n\n    for (const word of words) {\n        let wordMap = {};\n        for (const char of word) {\n            wordMap[char] = (wordMap[char] || 0) + 1;\n        }\n        if (Object.keys(merged).length === 0) {\n            merged = wordMap;\n        } else {\n            for (const char in merged) {\n                merged[char] = Math.min(merged[char], wordMap[char] || 0);\n            }\n        }\n    }\n\n    let result = [];\n    for (const char in merged) {\n        for (let i = 0; i < merged[char]; i++) {\n            result.push(char);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm follows these steps:\n\n1. Initialize an empty hash_map (C++)/HashMap (Java)/Counter (Python)/Object (JavaScript) `merged` to store the count of characters that appear in all words.\n2. Iterate through each word in the input array `words`.\n3. For each word, create a map `wordMap` to store the count of each character in the word.\n4. If `merged` is empty, set `merged` equal to `wordMap`. Otherwise, update the count of each character in `merged` with the minimum count of the same character in `wordMap`. This ensures that we only keep the count of characters that appear in all words.\n5. After iterating through all words, create a result array/list.\n6. For each character in `merged`, add the character to the result array/list with its count as the number of duplicates.\n7. Return the result array/list.\n    "
    },
    {
        "id": 174,
        "title": "Number of Submatrices That Sum to Target",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `matrix` and a `target`, return the number of non-empty submatrices that sum to target.\n\nA submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.\n\nTwo submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[0,1,0\\],\\[1,1,1\\],\\[0,1,0\\]\\], target = 0\n**Output:** 4\n**Explanation:** The four 1x1 submatrices that only contain 0.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,-1\\],\\[-1,1\\]\\], target = 0\n**Output:** 5\n**Explanation:** The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[904\\]\\], target = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= matrix.length <= 100`\n*   `1 <= matrix[0].length <= 100`\n*   `-1000 <= matrix[i] <= 1000`\n*   `-10^8 <= target <= 10^8`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Matrix",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[0,1,0],[1,1,1],[0,1,0]],0",
                "output": "4"
            },
            {
                "input": "[[1,-1],[-1,1]],0",
                "output": "5"
            },
            {
                "input": "[[904]],0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\n    int rows = matrix.length, cols = matrix[0].length;\n    for (int row = 0; row < rows; ++row)\n        for (int col = 1; col < cols; ++col)\n            matrix[row][col] += matrix[row][col-1];\n    \n    int count = 0;\n    Map<Integer, Integer> counter = new HashMap<>();\n    for (int col1 = 0; col1 < cols; ++col1) {\n        for (int col2 = col1; col2 < cols; ++col2) {\n            counter.clear();\n            counter.put(0, 1);\n            int cur_sum = 0;\n            for (int row = 0; row < rows; ++row) {\n                cur_sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\n                count += counter.getOrDefault(cur_sum - target, 0);\n                counter.put(cur_sum, counter.getOrDefault(cur_sum, 0) + 1);\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. First, we need to find the prefix sum of each row in the matrix. This means that the value at the cell (i, j) will store the sum of all elements from (i, 0) to (i, j) in the same row.\n2. Then, we iterate through all possible column pairs (col1, col2), and calculate the sum between those columns for each row using the prefix sum.\n3. We use a hashmap to store the sum we have encountered so far and their counts.\n4. For each row, update the sum and check how many times we have encountered the sum - target from the hashmap.\n5. Add the count and update the hashmap for the current sum.\n6. Return the total count after iterating all possible column pairs.\n    ",
        "python": "\n    ```python\ndef numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    for row in range(rows):\n        for col in range(1, cols):\n            matrix[row][col] += matrix[row][col-1]\n    \n    count = 0\n    for col1 in range(cols):\n        for col2 in range(col1, cols):\n            counter = collections.defaultdict(int)\n            counter[0] = 1\n            cur_sum = 0\n            for row in range(rows):\n                cur_sum += matrix[row][col2] - (matrix[row][col1-1] if col1 > 0 else 0)\n                count += counter[cur_sum - target]\n                counter[cur_sum] += 1\n\n    return count\n```\n    \n    1. First, we need to find the prefix sum of each row in the matrix. This means that the value at the cell (i, j) will store the sum of all elements from (i, 0) to (i, j) in the same row.\n2. Then, we iterate through all possible column pairs (col1, col2), and calculate the sum between those columns for each row using the prefix sum.\n3. We use a hashmap to store the sum we have encountered so far and their counts.\n4. For each row, update the sum and check how many times we have encountered the sum - target from the hashmap.\n5. Add the count and update the hashmap for the current sum.\n6. Return the total count after iterating all possible column pairs.\n    ",
        "c++": "\n    ```cpp\nint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\n    int rows = matrix.size(), cols = matrix[0].size();\n    for (int row = 0; row < rows; ++row)\n        for (int col = 1; col < cols; ++col)\n            matrix[row][col] += matrix[row][col-1];\n    \n    int count = 0;\n    unordered_map<int, int> counter;\n    for (int col1 = 0; col1 < cols; ++col1) {\n        for (int col2 = col1; col2 < cols; ++col2) {\n            counter.clear();\n            counter[0] = 1;\n            int cur_sum = 0;\n            for (int row = 0; row < rows; ++row) {\n                cur_sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\n                count += counter[cur_sum - target];\n                ++counter[cur_sum];\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    1. First, we need to find the prefix sum of each row in the matrix. This means that the value at the cell (i, j) will store the sum of all elements from (i, 0) to (i, j) in the same row.\n2. Then, we iterate through all possible column pairs (col1, col2), and calculate the sum between those columns for each row using the prefix sum.\n3. We use a hashmap to store the sum we have encountered so far and their counts.\n4. For each row, update the sum and check how many times we have encountered the sum - target from the hashmap.\n5. Add the count and update the hashmap for the current sum.\n6. Return the total count after iterating all possible column pairs.\n    ",
        "js": "\n    ```javascript\nvar numSubmatrixSumTarget = function(matrix, target) {\n    const rows = matrix.length, cols = matrix[0].length;\n    for (let row = 0; row < rows; ++row)\n        for (let col = 1; col < cols; ++col)\n            matrix[row][col] += matrix[row][col-1];\n    \n    let count = 0;\n    for (let col1 = 0; col1 < cols; ++col1) {\n        for (let col2 = col1; col2 < cols; ++col2) {\n            const counter = new Map();\n            counter.set(0, 1);\n            let cur_sum = 0;\n            for (let row = 0; row < rows; ++row) {\n                cur_sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\n                count += (counter.get(cur_sum - target) || 0);\n                counter.set(cur_sum, (counter.get(cur_sum) || 0) + 1);\n            }\n        }\n    }\n    return count;\n};\n```\n    \n    1. First, we need to find the prefix sum of each row in the matrix. This means that the value at the cell (i, j) will store the sum of all elements from (i, 0) to (i, j) in the same row.\n2. Then, we iterate through all possible column pairs (col1, col2), and calculate the sum between those columns for each row using the prefix sum.\n3. We use a hashmap to store the sum we have encountered so far and their counts.\n4. For each row, update the sum and check how many times we have encountered the sum - target from the hashmap.\n5. Add the count and update the hashmap for the current sum.\n6. Return the total count after iterating all possible column pairs.\n    "
    },
    {
        "id": 175,
        "title": "Find in Mountain Array",
        "difficulty": "Hard",
        "content": {
            "problem": "_(This problem is an **interactive problem**.)_\n\nYou may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven a mountain array `mountainArr`, return the **minimum** `index` such that `mountainArr.get(index) == target`. If such an `index` does not exist, return `-1`.\n\n**You cannot access the mountain array directly.** You may only access the array using a `MountainArray` interface:\n\n*   `MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).\n*   `MountainArray.length()` returns the length of the array.\n\nSubmissions making more than `100` calls to `MountainArray.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.",
            "examples": [
                "**Example 1:**\n\n**Input:** array = \\[1,2,3,4,5,3,1\\], target = 3\n**Output:** 2\n**Explanation:** 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\n\n",
                "**Example 2:**\n\n**Input:** array = \\[0,1,2,4,2,1\\], target = 3\n**Output:** -1\n**Explanation:** 3 does not exist in `the array,` so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= mountain_arr.length() <= 104`\n*   `0 <= target <= 109`\n*   `0 <= mountain_arr.get(index) <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Interactive"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5,3,1],3",
                "output": "2"
            },
            {
                "input": "[0,1,2,4,2,1],3",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int twoCitySchedCost(int[][] costs) {\n    Arrays.sort(costs, (a, b) -> (a[0] - a[1]) - (b[0] - b[1]));\n\n    int totalCost = 0;\n    int n = costs.length / 2;\n\n    for (int i = 0; i < n; i++) {\n        totalCost += costs[i][0] + costs[i + n][1];\n    }\n\n    return totalCost;\n}\n```\n    \n    1. Sort the costs by the difference between the cost of flying to city A and city B. This will effectively prioritize the people who may benefit most from flying to a particular city.\n2. Calculate the total cost by adding the costs for the first half of the sorted list flying to city A, and the latter half flying to city B.\n3. Return the total cost as the result.\n\nThis greedy algorithm minimizes the total cost by selecting the closest suitable matchings for each city, ensuring that we get the lowest possible cost across all possibilities.\n    ",
        "python": "\n    ```python\ndef twoCitySchedCost(costs):\n    costs.sort(key=lambda x: x[0] - x[1])\n\n    totalCost = 0\n    n = len(costs) // 2\n\n    for i in range(n):\n        totalCost += costs[i][0] + costs[i + n][1]\n\n    return totalCost\n```\n    \n    1. Sort the costs by the difference between the cost of flying to city A and city B. This will effectively prioritize the people who may benefit most from flying to a particular city.\n2. Calculate the total cost by adding the costs for the first half of the sorted list flying to city A, and the latter half flying to city B.\n3. Return the total cost as the result.\n\nThis greedy algorithm minimizes the total cost by selecting the closest suitable matchings for each city, ensuring that we get the lowest possible cost across all possibilities.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint twoCitySchedCost(std::vector<std::vector<int>>& costs) {\n    std::sort(costs.begin(), costs.end(), [](const std::vector<int>& a, const std::vector<int>& b){\n        return (a[0] - a[1]) < (b[0] - b[1]);\n    });\n\n    int totalCost = 0;\n    int n = costs.size() / 2;\n\n    for (int i = 0; i < n; i++) {\n        totalCost += costs[i][0] + costs[i+n][1];\n    }\n\n    return totalCost;\n}\n```\n    \n    1. Sort the costs by the difference between the cost of flying to city A and city B. This will effectively prioritize the people who may benefit most from flying to a particular city.\n2. Calculate the total cost by adding the costs for the first half of the sorted list flying to city A, and the latter half flying to city B.\n3. Return the total cost as the result.\n\nThis greedy algorithm minimizes the total cost by selecting the closest suitable matchings for each city, ensuring that we get the lowest possible cost across all possibilities.\n    ",
        "js": "\n    ```javascript\nfunction twoCitySchedCost(costs) {\n    costs.sort((a, b) => (a[0] - a[1]) - (b[0] - b[1]));\n\n    let totalCost = 0;\n    const n = costs.length / 2;\n\n    for (let i = 0; i < n; i++) {\n        totalCost += costs[i][0] + costs[i + n][1];\n    }\n\n    return totalCost;\n}\n```\n    \n    1. Sort the costs by the difference between the cost of flying to city A and city B. This will effectively prioritize the people who may benefit most from flying to a particular city.\n2. Calculate the total cost by adding the costs for the first half of the sorted list flying to city A, and the latter half flying to city B.\n3. Return the total cost as the result.\n\nThis greedy algorithm minimizes the total cost by selecting the closest suitable matchings for each city, ensuring that we get the lowest possible cost across all possibilities.\n    "
    },
    {
        "id": 176,
        "title": "Brace Expansion II",
        "difficulty": "Hard",
        "content": {
            "problem": "Under the grammar given below, strings can represent a set of lowercase words. Let `R(expr)` denote the set of words the expression represents.\n\nThe grammar can best be understood through simple examples:\n\n*   Single letters represent a singleton set containing that word.\n    *   `R( \"a \") = { \"a \"}`\n    *   `R( \"w \") = { \"w \"}`\n*   When we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n    *   `R( \"{a,b,c} \") = { \"a \", \"b \", \"c \"}`\n    *   `R( \"{{a,b},{b,c}} \") = { \"a \", \"b \", \"c \"}` (notice the final set only contains each word at most once)\n*   When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n    *   `R( \"{a,b}{c,d} \") = { \"ac \", \"ad \", \"bc \", \"bd \"}`\n    *   `R( \"a{b,c}{d,e}f{g,h} \") = { \"abdfg \", \"abdfh \", \"abefg \", \"abefh \", \"acdfg \", \"acdfh \", \"acefg \", \"acefh \"}`\n\nFormally, the three rules for our grammar:\n\n*   For every lowercase letter `x`, we have `R(x) = {x}`.\n*   For expressions `e1, e2, ... , ek` with `k >= 2`, we have `R({e1, e2, ...}) = R(e1) ∪ R(e2) ∪ ...`\n*   For expressions `e1` and `e2`, we have `R(e1 + e2) = {a + b for (a, b) in R(e1) * R(e2)}`, where `+` denotes concatenation, and `*` denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return _the sorted list of words that the expression represents_.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"{a,b}{c,{d,e}} \"\n**Output:** \\[ \"ac \", \"ad \", \"ae \", \"bc \", \"bd \", \"be \"\\]\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"{{a,z},a{b,c},{ab,z}} \"\n**Output:** \\[ \"a \", \"ab \", \"ac \", \"z \"\\]\n**Explanation:** Each distinct word is written only once in the final answer."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 60`\n*   `expression[i]` consists of `'{'`, `'}'`, `','`or lowercase English letters.\n*   The given `expression` represents a set of words based on the grammar given in the description.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking",
            "Stack",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "\"{a,",
                "output": "[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]"
            },
            {
                "input": "\"{{a,",
                "output": "[\"a\",\"ab\",\"ac\",\"z\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public List<String> braceExpansionII(String expression) {\n        int[] i = new int[]{0};\n        Set<String> parsedSet = parse(expression, i);\n        List<String> result = new ArrayList<>(parsedSet);\n        Collections.sort(result);\n        return result;\n    }\n\n    private Set<String> parse(String expression, int[] i) {\n        HashSet<String> current = new HashSet<>();\n        current.add(\"\");\n        HashSet<String> result = new HashSet<>();\n\n        while (i[0] < expression.length()) {\n            char c = expression.charAt(i[0]++);\n            if (c == '{') {\n                HashSet<String> temp = new HashSet<>();\n                for (String postfix : parse(expression, i)) {\n                    for (String prefix : current) {\n                        temp.add(prefix + postfix);\n                    }\n                }\n                current = temp;\n            } else if (c == '}') {\n                break;\n            } else if (c == ',') {\n                result.addAll(current);\n                current.clear();\n                current.add(\"\");\n            } else {\n                HashSet<String> temp = new HashSet<>();\n                for (String s : current) {\n                    temp.add(s + c);\n                }\n                current = temp;\n            }\n        }\n        result.addAll(current);\n        return result;\n    }\n}\n```\n    \n    The core of the algorithm is a parse function that takes an expression and current index. The parse function returns a set of possible strings based on the grammar. Initially, we call parse with the input expression and index 0. The parse function uses a loop that iterates through the expression characters. During each iteration:\n\n1. If the current character is \"{\", we create a temporary set and generate all possible combinations of prefixes from the current set and postfixes from the inner parse call's result. We update the current set with this temporary set and update the index to the matching \"}\".\n\n2. If the current character is \"}\", we break the loop as we reached the end of the recursion level.\n\n3. If the current character is \",\", we merge the current set into the result set and reset the current set to just contain an empty string.\n\n4. Else, the character is a lowercase letter, so we create a new set by appending the character to each element of the current set and update the current set with this new set.\n\nWhen the loop ends, we merge the current set into the result set one more time and return it. In the main function, we convert the final result set into a sorted list or array.\n\nNotice that this algorithm respects the constraints given in the problem, and as such, it's guaranteed to work with the input expressions provided. The time complexity is O(N * M), where N is the expression length, and M is the maximum number of possible combinations that can be generated.\n    ",
        "python": "\n    ```python\nclass Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        def parse(expr: str, i: int) -> Set[str]:\n            result, current = set(), {\"\"}\n            while i < len(expr):\n                if expr[i] == '{':\n                    update = set()\n                    for postfix in parse(expr, i + 1):\n                        for prefix in current:\n                            update.add(prefix + postfix)\n                    current = update\n                    i = expr.index('}', i)\n                elif expr[i] == '}':\n                    break\n                elif expr[i] == ',':\n                    result |= current\n                    current = {\"\"}\n                else:\n                    current = {s + expr[i] for s in current}\n                i += 1\n            return result | current\n        \n        return sorted(parse(expression, 0))\n```\n    \n    The core of the algorithm is a parse function that takes an expression and current index. The parse function returns a set of possible strings based on the grammar. Initially, we call parse with the input expression and index 0. The parse function uses a loop that iterates through the expression characters. During each iteration:\n\n1. If the current character is \"{\", we create a temporary set and generate all possible combinations of prefixes from the current set and postfixes from the inner parse call's result. We update the current set with this temporary set and update the index to the matching \"}\".\n\n2. If the current character is \"}\", we break the loop as we reached the end of the recursion level.\n\n3. If the current character is \",\", we merge the current set into the result set and reset the current set to just contain an empty string.\n\n4. Else, the character is a lowercase letter, so we create a new set by appending the character to each element of the current set and update the current set with this new set.\n\nWhen the loop ends, we merge the current set into the result set one more time and return it. In the main function, we convert the final result set into a sorted list or array.\n\nNotice that this algorithm respects the constraints given in the problem, and as such, it's guaranteed to work with the input expressions provided. The time complexity is O(N * M), where N is the expression length, and M is the maximum number of possible combinations that can be generated.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <set>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> braceExpansionII(string expression) {\n        int i = 0;\n        return vector<string>(parse(expression, i).begin(), parse(expression, i).end());\n    }\n\n    set<string> parse(string& expresion, int& i) {\n        set<string> current;\n        current.insert(\"\");\n        set<string> result;\n        \n        for (; i < expresion.size(); ++i) {\n            char c = expresion[i];\n            if (c == '{') {\n                set<string> update;\n                for (string postfix : parse(expresion, ++i)) {\n                    for (string prefix : current) {\n                        update.insert(prefix + postfix);\n                    }\n                }\n                current = update;\n            } else if (c == ',') {\n                result.insert(current.begin(), current.end());\n                current.clear();\n                current.insert(\"\");\n            } else if (c == '}') {\n                break;\n            } else { \n                set<string> update;\n                for (string element : current) {\n                    update.insert(element + c);\n                }\n                current = update;\n            }\n        }\n        \n        result.insert(current.begin(), current.end());\n        return result;\n    }\n};\n```\n    \n    The core of the algorithm is a parse function that takes an expression and current index. The parse function returns a set of possible strings based on the grammar. Initially, we call parse with the input expression and index 0. The parse function uses a loop that iterates through the expression characters. During each iteration:\n\n1. If the current character is \"{\", we create a temporary set and generate all possible combinations of prefixes from the current set and postfixes from the inner parse call's result. We update the current set with this temporary set and update the index to the matching \"}\".\n\n2. If the current character is \"}\", we break the loop as we reached the end of the recursion level.\n\n3. If the current character is \",\", we merge the current set into the result set and reset the current set to just contain an empty string.\n\n4. Else, the character is a lowercase letter, so we create a new set by appending the character to each element of the current set and update the current set with this new set.\n\nWhen the loop ends, we merge the current set into the result set one more time and return it. In the main function, we convert the final result set into a sorted list or array.\n\nNotice that this algorithm respects the constraints given in the problem, and as such, it's guaranteed to work with the input expressions provided. The time complexity is O(N * M), where N is the expression length, and M is the maximum number of possible combinations that can be generated.\n    ",
        "js": "\n    ```javascript\n/**\n * @param {string} expression\n * @return {string[]}\n */\nvar braceExpansionII = function(expression) {\n    function parse(expresion, i) {\n        let current = new Set();\n        current.add(\"\");\n        let result = new Set();\n        \n        while (i[0] < expresion.length) {\n            let c = expresion[i[0]++];\n            if (c === '{') {\n                let update = new Set();\n                for(let postfix of parse(expresion, i)) {\n                    for(let prefix of current) {\n                        update.add(prefix + postfix);\n                    }\n                }\n                current = update;\n            } else if (c === '}') {\n                break;\n            } else if (c === ',') {\n                for(let cur of current) {\n                    result.add(cur);\n                }\n                current.clear();\n                current.add(\"\");\n            } else {\n                let update = new Set();\n                for(let element of current) {\n                    update.add(element + c);\n                }\n                current = update;\n            }\n        }\n        \n        for(let cur of current) {\n            result.add(cur);\n        }\n        return result;\n    }\n\n    const i = [0];\n    return Array.from(parse(expression, i)).sort();\n};\n```\n    \n    The core of the algorithm is a parse function that takes an expression and current index. The parse function returns a set of possible strings based on the grammar. Initially, we call parse with the input expression and index 0. The parse function uses a loop that iterates through the expression characters. During each iteration:\n\n1. If the current character is \"{\", we create a temporary set and generate all possible combinations of prefixes from the current set and postfixes from the inner parse call's result. We update the current set with this temporary set and update the index to the matching \"}\".\n\n2. If the current character is \"}\", we break the loop as we reached the end of the recursion level.\n\n3. If the current character is \",\", we merge the current set into the result set and reset the current set to just contain an empty string.\n\n4. Else, the character is a lowercase letter, so we create a new set by appending the character to each element of the current set and update the current set with this new set.\n\nWhen the loop ends, we merge the current set into the result set one more time and return it. In the main function, we convert the final result set into a sorted list or array.\n\nNotice that this algorithm respects the constraints given in the problem, and as such, it's guaranteed to work with the input expressions provided. The time complexity is O(N * M), where N is the expression length, and M is the maximum number of possible combinations that can be generated.\n    "
    },
    {
        "id": 177,
        "title": "Parsing A Boolean Expression",
        "difficulty": "Hard",
        "content": {
            "problem": "A **boolean expression** is an expression that evaluates to either `true` or `false`. It can be in one of the following shapes:\n\n*   `'t'` that evaluates to `true`.\n*   `'f'` that evaluates to `false`.\n*   `'!(subExpr)'` that evaluates to **the logical NOT** of the inner expression `subExpr`.\n*   `'&(subExpr1, subExpr2, ..., subExprn)'` that evaluates to **the logical AND** of the inner expressions `subExpr1, subExpr2, ..., subExprn` where `n >= 1`.\n*   `'|(subExpr1, subExpr2, ..., subExprn)'` that evaluates to **the logical OR** of the inner expressions `subExpr1, subExpr2, ..., subExprn` where `n >= 1`.\n\nGiven a string `expression` that represents a **boolean expression**, return _the evaluation of that expression_.\n\nIt is **guaranteed** that the given expression is valid and follows the given rules.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"&(|(f)) \"\n**Output:** false\n**Explanation:** \nFirst, evaluate |(f) --> f. The expression is now  \"&(f) \".\nThen, evaluate &(f) --> f. The expression is now  \"f \".\nFinally, return false.\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"|(f,f,f,t) \"\n**Output:** true\n**Explanation:** The evaluation of (false OR false OR false OR true) is true.\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"!(&(f,t)) \"\n**Output:** true\n**Explanation:** \nFirst, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now  \"!(f) \".\nThen, evaluate !(f) --> NOT false --> true. We return true."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 2 * 104`\n*   expression\\[i\\] is one following characters: `'('`, `')'`, `'&'`, `'|'`, `'!'`, `'t'`, `'f'`, and `','`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack",
            "Recursion"
        ],
        "example": [
            {
                "input": "\"&(|(f))\"",
                "output": "false"
            },
            {
                "input": "\"|(f,",
                "output": "true"
            },
            {
                "input": "\"!(&(f,",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.List;\n\npublic boolean isEscapePossible(List<List<Integer>> blocked, List<Integer> source, List<Integer> target) {\n    Set<String> blockedSet = new HashSet<>();\n    Set<String> visited = new HashSet<>();\n    int maxSteps = 200;\n\n    for (List<Integer> block : blocked)\n        blockedSet.add(block.get(0) + \"_\" + block.get(1));\n\n    return dfs(source.get(0), source.get(1), target.get(0), target.get(1), blockedSet, visited, 0, maxSteps);\n}\n\nprivate boolean dfs(int x, int y, int tx, int ty, Set<String> blocked, Set<String> visited, int steps, int maxSteps) {\n    String pos = x + \"_\" + y;\n    if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || steps >= maxSteps || blocked.contains(pos) || visited.contains(pos)) {\n        return false;\n    }\n\n    if (x == tx && y == ty) {\n        return true;\n    }\n\n    visited.add(pos);\n\n    return dfs(x + 1, y, tx, ty, blocked, visited, steps + 1, maxSteps) ||\n           dfs(x, y + 1, tx, ty, blocked, visited, steps + 1, maxSteps) ||\n           dfs(x - 1, y, tx, ty, blocked, visited, steps + 1, maxSteps) ||\n           dfs(x, y - 1, tx, ty, blocked, visited, steps + 1, maxSteps);\n}\n```\n\n    \n    We can use DFS (Depth First Search) to solve this problem. The limitation of a maximum of 1 million by 1 million grid is to limit the search space, while the 200-move limit prevents the DFS search from running excessively long. The key is to have a `blockedSet` to store the blocked positions and a `visited` set to keep track of visited positions.\n\nWe will implement a helper function named `dfs` with the current position `(x, y)`, target position `(tx, ty)`, the `blockedSet`, the `visited` set, and the current step count.\n\nAt each step, we first check if the current position is valid (inside the grid, not blocked, not visited, and the step count below 200), if not, return false. If the current position is the target position, return true. Otherwise, we mark the current position as visited and call the `dfs` function in all four directions (North, South, East, West) and return true if any of them return true.\n\nFinally, we call our `dfs` function with the source position as the starting point and return the result.\n\nUsing this algorithm, we can achieve the result without exceeding the provided limitations.\n    ",
        "python": "\n    ```python\nMAX_STEPS = 200\n\ndef isEscapePossible(blocked, source, target):\n    blockedSet = set([\"{}_{}\".format(block[0], block[1]) for block in blocked])\n    visited = set()\n\n    def dfs(x, y, tx, ty, steps):\n        pos = \"{}_{}\".format(x, y)\n        if x < 0 or x >= 1000000 or y < 0 or y >= 1000000 or steps >= MAX_STEPS or pos in blockedSet or pos in visited:\n            return False\n\n        if x == tx and y == ty:\n            return True\n\n        visited.add(pos)\n\n        return (dfs(x + 1, y, tx, ty, steps + 1) or dfs(x, y + 1, tx, ty, steps + 1)\n                or dfs(x - 1, y, tx, ty, steps + 1) or dfs(x, y - 1, tx, ty, steps + 1))\n\n    return dfs(source[0], source[1], target[0], target[1], 0)\n```\n\n    \n    We can use DFS (Depth First Search) to solve this problem. The limitation of a maximum of 1 million by 1 million grid is to limit the search space, while the 200-move limit prevents the DFS search from running excessively long. The key is to have a `blockedSet` to store the blocked positions and a `visited` set to keep track of visited positions.\n\nWe will implement a helper function named `dfs` with the current position `(x, y)`, target position `(tx, ty)`, the `blockedSet`, the `visited` set, and the current step count.\n\nAt each step, we first check if the current position is valid (inside the grid, not blocked, not visited, and the step count below 200), if not, return false. If the current position is the target position, return true. Otherwise, we mark the current position as visited and call the `dfs` function in all four directions (North, South, East, West) and return true if any of them return true.\n\nFinally, we call our `dfs` function with the source position as the starting point and return the result.\n\nUsing this algorithm, we can achieve the result without exceeding the provided limitations.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_set>\n#include <vector>\n#include <string>\n\nconst int MAX_STEPS = 200;\n\nbool dfs(int x, int y, int tx, int ty, std::unordered_set<std::string> &blocked, std::unordered_set<std::string> &visited, int steps) {\n    std::string pos = std::to_string(x) + \"_\" + std::to_string(y);\n    if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || steps >= MAX_STEPS || blocked.count(pos) || visited.count(pos))\n        return false;\n\n    if (x == tx && y == ty)\n        return true;\n\n    visited.insert(pos);\n\n    if (dfs(x + 1, y, tx, ty, blocked, visited, steps + 1) || dfs(x, y + 1, tx, ty, blocked, visited, steps + 1) ||\n        dfs(x - 1, y, tx, ty, blocked, visited, steps + 1) || dfs(x, y - 1, tx, ty, blocked, visited, steps + 1))\n        return true;\n\n    return false;\n}\n\nbool isEscapePossible(std::vector<std::vector<int>>& blocked, std::vector<int>& source, std::vector<int>& target) {\n    std::unordered_set<std::string> blockedSet, visited;\n    for (auto &block : blocked)\n        blockedSet.insert(std::to_string(block[0]) + \"_\" + std::to_string(block[1]));\n\n    return dfs(source[0], source[1], target[0], target[1], blockedSet, visited, 0);\n}\n```\n\n    \n    We can use DFS (Depth First Search) to solve this problem. The limitation of a maximum of 1 million by 1 million grid is to limit the search space, while the 200-move limit prevents the DFS search from running excessively long. The key is to have a `blockedSet` to store the blocked positions and a `visited` set to keep track of visited positions.\n\nWe will implement a helper function named `dfs` with the current position `(x, y)`, target position `(tx, ty)`, the `blockedSet`, the `visited` set, and the current step count.\n\nAt each step, we first check if the current position is valid (inside the grid, not blocked, not visited, and the step count below 200), if not, return false. If the current position is the target position, return true. Otherwise, we mark the current position as visited and call the `dfs` function in all four directions (North, South, East, West) and return true if any of them return true.\n\nFinally, we call our `dfs` function with the source position as the starting point and return the result.\n\nUsing this algorithm, we can achieve the result without exceeding the provided limitations.\n    ",
        "js": "\n    ```javascript\nconst MAX_STEPS = 200;\n\nfunction isEscapePossible(blocked, source, target) {\n    const blockedSet = new Set(blocked.map(block => `${block[0]}_${block[1]}`));\n    const visited = new Set();\n\n    function dfs(x, y, tx, ty, steps) {\n        const pos = `${x}_${y}`;\n        if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || steps >= MAX_STEPS || blockedSet.has(pos) || visited.has(pos)) {\n            return false;\n        }\n\n        if (x === tx && y === ty) {\n            return true;\n        }\n\n        visited.add(pos);\n\n        return dfs(x + 1, y, tx, ty, steps + 1) || dfs(x, y + 1, tx, ty, steps + 1) ||\n               dfs(x - 1, y, tx, ty, steps + 1) || dfs(x, y - 1, tx, ty, steps + 1);\n    }\n\n    return dfs(source[0], source[1], target[0], target[1], 0);\n}\n```\n\n    \n    We can use DFS (Depth First Search) to solve this problem. The limitation of a maximum of 1 million by 1 million grid is to limit the search space, while the 200-move limit prevents the DFS search from running excessively long. The key is to have a `blockedSet` to store the blocked positions and a `visited` set to keep track of visited positions.\n\nWe will implement a helper function named `dfs` with the current position `(x, y)`, target position `(tx, ty)`, the `blockedSet`, the `visited` set, and the current step count.\n\nAt each step, we first check if the current position is valid (inside the grid, not blocked, not visited, and the step count below 200), if not, return false. If the current position is the target position, return true. Otherwise, we mark the current position as visited and call the `dfs` function in all four directions (North, South, East, West) and return true if any of them return true.\n\nFinally, we call our `dfs` function with the source position as the starting point and return the result.\n\nUsing this algorithm, we can achieve the result without exceeding the provided limitations.\n    "
    },
    {
        "id": 178,
        "title": "Smallest Sufficient Team",
        "difficulty": "Hard",
        "content": {
            "problem": "In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.\n\nConsider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n\n*   For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.\n\nReturn _any sufficient team of the smallest possible size, represented by the index of each person_. You may return the answer in **any order**.\n\nIt is **guaranteed** an answer exists.",
            "examples": [
                "**Example 1:**\n\n**Input:** req\\_skills = \\[\"java\",\"nodejs\",\"reactjs\"\\], people = \\[\\[\"java\"\\],\\[\"nodejs\"\\],\\[\"nodejs\",\"reactjs\"\\]\\]\n**Output:** \\[0,2\\]\n\n",
                "**Example 2:**\n\n**Input:** req\\_skills = \\[\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"\\], people = \\[\\[\"algorithms\",\"math\",\"java\"\\],\\[\"algorithms\",\"math\",\"reactjs\"\\],\\[\"java\",\"csharp\",\"aws\"\\],\\[\"reactjs\",\"csharp\"\\],\\[\"csharp\",\"math\"\\],\\[\"aws\",\"java\"\\]\\]\n**Output:** \\[1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= req_skills.length <= 16`\n*   `1 <= req_skills[i].length <= 16`\n*   `req_skills[i]` consists of lowercase English letters.\n*   All the strings of `req_skills` are **unique**.\n*   `1 <= people.length <= 60`\n*   `0 <= people[i].length <= 16`\n*   `1 <= people[i][j].length <= 16`\n*   `people[i][j]` consists of lowercase English letters.\n*   All the strings of `people[i]` are **unique**.\n*   Every skill in `people[i]` is a skill in `req_skills`.\n*   It is guaranteed a sufficient team exists.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[\"java\",\"nodejs\",\"reactjs\"],[[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]",
                "output": "[0,2]"
            },
            {
                "input": "[\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"],[[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]",
                "output": "[1,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> smallestSufficientTeam(String[] req_skills, List<List<String>> people) {\n    Map<String, Integer> skillToId = new HashMap<>();\n    int idx = 0;\n    for (String skill : req_skills) {\n        skillToId.put(skill, idx++);\n    }\n\n    int n = people.size(), m = req_skills.length;\n    int[] dp = new int[1 << m];\n    int[] pre = new int[1 << m];\n    int[] skillSet = new int[1 << m];\n\n    Arrays.fill(dp, Integer.MAX_VALUE / 2);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int skillMask = 0;\n        for (String skill : people.get(i)) {\n            skillMask |= 1 << skillToId.get(skill);\n        }\n        for (int j = (1 << m) - 1; j >= 0; --j) {\n            if (dp[j | skillMask] > dp[j] + 1) {\n                dp[j | skillMask] = dp[j] + 1;\n                pre[j | skillMask] = j;\n                skillSet[j | skillMask] = i;\n            }\n        }\n    }\n\n    List<Integer> res = new ArrayList<>();\n    int mask = (1 << m) - 1;\n    while (mask != 0) {\n        res.add(skillSet[mask]);\n        mask = pre[mask];\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm uses dynamic programming and bitmasking to find the smallest sufficient team. We represent the skills of each person and the required skills using a bitmask. After initializing the DP and the required mappings/arrays, we loop through each person and find their skill mask. Then we loop backwards from the maximum bitmask to update the DP array with the findings.\n\nThe final result is extracted by iterating through the updated DP array and storing the indices of the required team members in the `res` array. The algorithm has a time complexity of O(n * m * 2^m), where n is the number of people and m is the number of required skills.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\nfrom math import log2\n\ndef smallestSufficientTeam(req_skills, people):\n    skill_to_id = {skill: idx for idx, skill in enumerate(req_skills)}\n\n    n, m = len(people), len(req_skills)\n    dp = [float(\"inf\")] * (1 << m)\n    pre = [0] * (1 << m)\n    skill_set = [0] * (1 << m)\n\n    dp[0] = 0\n\n    for i, skills in enumerate(people):\n        skill_mask = sum(1 << skill_to_id[skill] for skill in skills)\n        for j in range((1 << m) - 1, -1, -1):\n            if dp[j | skill_mask] > dp[j] + 1:\n                dp[j | skill_mask] = dp[j] + 1\n                pre[j | skill_mask] = j\n                skill_set[j | skill_mask] = i\n\n    res = []\n    mask = (1 << m) - 1\n    while mask:\n        res.append(skill_set[mask])\n        mask = pre[mask]\n\n    return res\n```\n\n    \n    The algorithm uses dynamic programming and bitmasking to find the smallest sufficient team. We represent the skills of each person and the required skills using a bitmask. After initializing the DP and the required mappings/arrays, we loop through each person and find their skill mask. Then we loop backwards from the maximum bitmask to update the DP array with the findings.\n\nThe final result is extracted by iterating through the updated DP array and storing the indices of the required team members in the `res` array. The algorithm has a time complexity of O(n * m * 2^m), where n is the number of people and m is the number of required skills.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\nvector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n    unordered_map<int, string> id_to_skill;\n    unordered_map<string, int> skill_to_id;\n    int idx = 0;\n    for (const auto& skill : req_skills) {\n        skill_to_id[skill] = idx++;\n        id_to_skill[idx - 1] = skill;\n    }\n\n    vector<int> res;\n    vector<bitset<16>> dp(1 << idx, bitset<16>());\n    vector<int> pre(1 << idx, -1);\n    dp[0].set(31);\n\n    int people_size = people.size();\n    for (int i = 0; i < people_size; ++i) {\n        int skill_mask = 0;\n        for (const auto& skill : people[i]) {\n            skill_mask |= 1 << skill_to_id[skill];\n        }\n        for (int j = (1 << idx) - 1; j >= 0; --j) {\n            int next_mask = j | skill_mask;\n            if (dp[next_mask].count() > dp[j].count() + 1) {\n                dp[next_mask] = dp[j];\n                dp[next_mask].set(i);\n                pre[next_mask] = j;\n            }\n        }\n    }\n\n    int current_mask = (1 << idx) - 1;\n    while (current_mask != 0) {\n        int previous_mask = pre[current_mask];\n        int mask = current_mask ^ previous_mask;\n        int id = log2(mask);\n        res.push_back(id);\n        current_mask = previous_mask;\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm uses dynamic programming and bitmasking to find the smallest sufficient team. We represent the skills of each person and the required skills using a bitmask. After initializing the DP and the required mappings/arrays, we loop through each person and find their skill mask. Then we loop backwards from the maximum bitmask to update the DP array with the findings.\n\nThe final result is extracted by iterating through the updated DP array and storing the indices of the required team members in the `res` array. The algorithm has a time complexity of O(n * m * 2^m), where n is the number of people and m is the number of required skills.\n    ",
        "js": "\n    ```javascript\nfunction smallestSufficientTeam(req_skills, people) {\n    const skillToId = new Map();\n    for (let i = 0; i < req_skills.length; ++i) {\n        skillToId.set(req_skills[i], i);\n    }\n\n    const n = people.length, m = req_skills.length;\n    const dp = Array(1 << m).fill(Number.MAX_SAFE_INTEGER / 2);\n    const pre = Array(1 << m).fill(0);\n    const skillSet = Array(1 << m).fill(0);\n\n    dp[0] = 0;\n\n    for (let i = 0; i < n; ++i) {\n        let skillMask = 0;\n        for (let skill of people[i]) {\n            skillMask |= 1 << skillToId.get(skill);\n        }\n        for (let j = (1 << m) - 1; j >= 0; --j) {\n            if (dp[j | skillMask] > dp[j] + 1) {\n                dp[j | skillMask] = dp[j] + 1;\n                pre[j | skillMask] = j;\n                skillSet[j | skillMask] = i;\n            }\n        }\n    }\n\n    const res = [];\n    let mask = (1 << m) - 1;\n    while (mask !== 0) {\n        res.push(skillSet[mask]);\n        mask = pre[mask];\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm uses dynamic programming and bitmasking to find the smallest sufficient team. We represent the skills of each person and the required skills using a bitmask. After initializing the DP and the required mappings/arrays, we loop through each person and find their skill mask. Then we loop backwards from the maximum bitmask to update the DP array with the findings.\n\nThe final result is extracted by iterating through the updated DP array and storing the indices of the required team members in the `res` array. The algorithm has a time complexity of O(n * m * 2^m), where n is the number of people and m is the number of required skills.\n    "
    },
    {
        "id": 179,
        "title": "Longest Chunked Palindrome Decomposition",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:\n\n*   `subtexti` is a **non-empty** string.\n*   The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).\n*   `subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).\n\nReturn the largest possible value of `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"ghiabcdefhelloadamhelloabcdefghi \"\n**Output:** 7\n**Explanation:** We can split the string on  \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi) \".\n\n",
                "**Example 2:**\n\n**Input:** text =  \"merchant \"\n**Output:** 1\n**Explanation:** We can split the string on  \"(merchant) \".\n\n",
                "**Example 3:**\n\n**Input:** text =  \"antaprezatepzapreanta \"\n**Output:** 11\n**Explanation:** We can split the string on  \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a) \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists only of lowercase English characters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming",
            "Greedy",
            "Rolling Hash",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"ghiabcdefhelloadamhelloabcdefghi\"",
                "output": "7"
            },
            {
                "input": "\"merchant\"",
                "output": "1"
            },
            {
                "input": "\"antaprezatepzapreanta\"",
                "output": "11"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int maxEqualRowsAfterFlips(int[][] matrix) {\n    Map<String, Integer> count = new HashMap<>();\n    for (int[] row : matrix) {\n        StringBuilder row_str = new StringBuilder();\n        int first = row[0];\n        for (int val : row) {\n            row_str.append(first == 1 ? 1 - val : val);\n        }\n        count.put(row_str.toString(), count.getOrDefault(row_str.toString(), 0) + 1);\n    }\n    int res = 0;\n    for (int value : count.values()) {\n        res = Math.max(res, value);\n    }\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef maxEqualRowsAfterFlips(matrix):\n    count = defaultdict(int)\n    for row in matrix:\n        row_str = \"\".join(str(row[0] ^ val) for val in row)\n        count[row_str] += 1\n    return max(count.values())\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ",
        "c++": "\n    ```cpp\nint maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {\n    unordered_map<string, int> count;\n    for (auto& row : matrix) {\n        string row_str;\n        if (row[0] == 1) {\n            for (int val : row)\n                row_str += '0' + 1 - val;\n        } else {\n            for (int val : row)\n                row_str += '0' + val;\n        }\n        count[row_str]++;\n    }\n    int res = 0;\n    for (auto& [key, value] : count)\n        res = max(res, value);\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    ",
        "js": "\n    ```javascript\nfunction maxEqualRowsAfterFlips(matrix) {\n    const count = new Map();\n    for (const row of matrix) {\n        const rowStr = row.map(val => row[0] ^ val).join('');\n        count.set(rowStr, (count.get(rowStr) || 0) + 1);\n    }\n    let res = 0;\n    for (const value of count.values()) {\n        res = Math.max(res, value);\n    }\n    return res;\n}\n```\n    \n    The algorithm initializes an empty map (or dictionary) for counting rows. For each row in the matrix, the algorithm generates a string composed of the XOR of the first element in the row with every element in that row. This operation helps to represent the rows that can be flipped to be equal. The row string is stored as a key in the dictionary, and the count of such rows is incremented.\n\nFinally, the algorithm iterates through the values in the dictionary and returns the maximum count encountered. This is the maximum number of rows that become equal after some number of flips.\n\nThe time complexity of this algorithm is O(m * n), where m is the number of rows and n is the number of columns in the matrix, as it iterates through every cell of the matrix.\n    "
    },
    {
        "id": 180,
        "title": "Online Majority Element In Subarray",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a data structure that efficiently finds the **majority element** of a given subarray.\n\nThe **majority element** of a subarray is an element that occurs `threshold` times or more in the subarray.\n\nImplementing the `MajorityChecker` class:\n\n*   `MajorityChecker(int[] arr)` Initializes the instance of the class with the given array `arr`.\n*   `int query(int left, int right, int threshold)` returns the element in the subarray `arr[left...right]` that occurs at least `threshold` times, or `-1` if no such element exists.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MajorityChecker \",  \"query \",  \"query \",  \"query \"\\]\n\\[\\[\\[1, 1, 2, 2, 1, 1\\]\\], \\[0, 5, 4\\], \\[0, 3, 3\\], \\[2, 3, 2\\]\\]\n**Output**\n\\[null, 1, -1, 2\\]\n\n**Explanation**\nMajorityChecker majorityChecker = new MajorityChecker(\\[1, 1, 2, 2, 1, 1\\]);\nmajorityChecker.query(0, 5, 4); // return 1\nmajorityChecker.query(0, 3, 3); // return -1\nmajorityChecker.query(2, 3, 2); // return 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 2 * 104`\n*   `1 <= arr[i] <= 2 * 104`\n*   `0 <= left <= right < arr.length`\n*   `threshold <= right - left + 1`\n*   `2 * threshold > right - left + 1`\n*   At most `104` calls will be made to `query`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Design",
            "Binary Indexed Tree",
            "Segment Tree"
        ],
        "example": [
            {
                "input": "]\n]],[0,5,4],[0,3,3],[2,3,2]]",
                "output": "**Output**\n[null,1,-1,2]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean isInsufficient(TreeNode node, int limit, int sum) {\n    if (node == null) {\n        return true;\n    }\n    \n    sum += node.val;\n    if (node.left == null && node.right == null) {\n        return sum < limit;\n    }\n    \n    boolean leftInsufficient = isInsufficient(node.left, limit, sum);\n    boolean rightInsufficient = isInsufficient(node.right, limit, sum);\n    \n    if (leftInsufficient) {\n        node.left = null;\n    }\n    if (rightInsufficient) {\n        node.right = null;\n    }\n    \n    return leftInsufficient && rightInsufficient;\n}\n\npublic TreeNode sufficientSubset(TreeNode root, int limit) {\n    if (isInsufficient(root, limit, 0)) {\n        return null;\n    }\n    return root;\n}\n```\n\n    \n    The algorithm starts by performing a depth-first search to find the leaf nodes of the given binary tree. At each node visited, the current sum is updated by adding the value of the current node. If a leaf node is reached, the sum is compared with the given limit. If the sum is less than the limit, that node is considered insufficient and the helper function returns `True`, else it returns `False`.\n\nThis process is repeated recursively for both the left and right child nodes of the current node. If a subtree is found to be insufficient, it is removed from the original tree by setting the corresponding child reference of the parent node to `null`.\n\nAfter the depth-first search is completed, the root node is checked for insufficiency. If the root node is insufficient, the function returns `null` (i.e., no nodes in the tree satisfy the given condition). If the root node is still sufficient, the function returns the modified tree with all insufficient nodes removed.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_insufficient(node, limit, current_sum):\n    if not node:\n        return True\n\n    current_sum += node.val\n    if not node.left and not node.right:\n        return current_sum < limit\n\n    left_insufficient = is_insufficient(node.left, limit, current_sum)\n    right_insufficient = is_insufficient(node.right, limit, current_sum)\n\n    if left_insufficient:\n        node.left = None\n    if right_insufficient:\n        node.right = None\n\n    return left_insufficient and right_insufficient\n\ndef sufficient_subset(root, limit):\n    if is_insufficient(root, limit, 0):\n        return None\n    return root\n```\n\n    \n    The algorithm starts by performing a depth-first search to find the leaf nodes of the given binary tree. At each node visited, the current sum is updated by adding the value of the current node. If a leaf node is reached, the sum is compared with the given limit. If the sum is less than the limit, that node is considered insufficient and the helper function returns `True`, else it returns `False`.\n\nThis process is repeated recursively for both the left and right child nodes of the current node. If a subtree is found to be insufficient, it is removed from the original tree by setting the corresponding child reference of the parent node to `null`.\n\nAfter the depth-first search is completed, the root node is checked for insufficiency. If the root node is insufficient, the function returns `null` (i.e., no nodes in the tree satisfy the given condition). If the root node is still sufficient, the function returns the modified tree with all insufficient nodes removed.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n  int val;\n  TreeNode* left;\n  TreeNode* right;\n};\n\nbool isInsufficient(TreeNode* node, int limit, int sum) {\n  if (!node) {\n    return true;\n  }\n  \n  sum += node->val;\n  if (!node->left && !node->right) {\n    return sum < limit;\n  }\n  \n  bool leftInsufficient = isInsufficient(node->left, limit, sum);\n  bool rightInsufficient = isInsufficient(node->right, limit, sum);\n  \n  if (leftInsufficient) {\n    delete(node->left);\n    node->left = nullptr;\n  }\n  if (rightInsufficient) {\n    delete(node->right);\n    node->right = nullptr;\n  }\n  \n  return leftInsufficient && rightInsufficient;\n}\n\nTreeNode* sufficientSubset(TreeNode* root, int limit) {\n  if (isInsufficient(root, limit, 0)) {\n    delete(root);\n    return nullptr;\n  }\n  return root;\n}\n```\n\n    \n    The algorithm starts by performing a depth-first search to find the leaf nodes of the given binary tree. At each node visited, the current sum is updated by adding the value of the current node. If a leaf node is reached, the sum is compared with the given limit. If the sum is less than the limit, that node is considered insufficient and the helper function returns `True`, else it returns `False`.\n\nThis process is repeated recursively for both the left and right child nodes of the current node. If a subtree is found to be insufficient, it is removed from the original tree by setting the corresponding child reference of the parent node to `null`.\n\nAfter the depth-first search is completed, the root node is checked for insufficiency. If the root node is insufficient, the function returns `null` (i.e., no nodes in the tree satisfy the given condition). If the root node is still sufficient, the function returns the modified tree with all insufficient nodes removed.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isInsufficient(node, limit, sum) {\n    if (!node) {\n        return true;\n    }\n\n    sum += node.val;\n    if (!node.left && !node.right) {\n        return sum < limit;\n    }\n\n    const leftInsufficient = isInsufficient(node.left, limit, sum);\n    const rightInsufficient = isInsufficient(node.right, limit, sum);\n\n    if (leftInsufficient) {\n        node.left = null;\n    }\n    if (rightInsufficient) {\n        node.right = null;\n    }\n\n    return leftInsufficient && rightInsufficient;\n}\n\nfunction sufficientSubset(root, limit) {\n    if (isInsufficient(root, limit, 0)) {\n        return null;\n    }\n    return root;\n}\n```\n\n    \n    The algorithm starts by performing a depth-first search to find the leaf nodes of the given binary tree. At each node visited, the current sum is updated by adding the value of the current node. If a leaf node is reached, the sum is compared with the given limit. If the sum is less than the limit, that node is considered insufficient and the helper function returns `True`, else it returns `False`.\n\nThis process is repeated recursively for both the left and right child nodes of the current node. If a subtree is found to be insufficient, it is removed from the original tree by setting the corresponding child reference of the parent node to `null`.\n\nAfter the depth-first search is completed, the root node is checked for insufficiency. If the root node is insufficient, the function returns `null` (i.e., no nodes in the tree satisfy the given condition). If the root node is still sufficient, the function returns the modified tree with all insufficient nodes removed.\n    "
    },
    {
        "id": 181,
        "title": "Last Substring in Lexicographical Order",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, return _the last substring of_ `s` _in lexicographical order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abab \"\n**Output:**  \"bab \"\n**Explanation:** The substrings are \\[ \"a \",  \"ab \",  \"aba \",  \"abab \",  \"b \",  \"ba \",  \"bab \"\\]. The lexicographically maximum substring is  \"bab \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"leetcode \"\n**Output:**  \"tcode \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 4 * 105`\n*   `s` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String"
        ],
        "example": [
            {
                "input": "\"abab\"",
                "output": "\"bab\""
            },
            {
                "input": "\"leetcode\"",
                "output": "\"tcode\""
            }
        ],
        "java": "\n    ```java\npublic String lastSubstring(String s) {\n    int maxIndex = 0;\n    int curIndex = 1;\n    while (curIndex < s.length()) {\n        int i = 0;\n        while (curIndex + i < s.length() && s.charAt(maxIndex + i) == s.charAt(curIndex + i)) {\n            i++;\n        }\n        if (curIndex + i == s.length()) break;\n        if (s.charAt(maxIndex + i) < s.charAt(curIndex + i)) {\n            maxIndex = curIndex;\n        }\n        curIndex++;\n    }\n    return s.substring(maxIndex);\n}\n```\n    \n    The algorithm initializes two indices, `maxIndex` and `curIndex`, both starting at the beginning of the string. We use a while loop to scan the input string until `curIndex` reaches the end.\n\nInside the loop, we check if both substrings - made with the current `maxIndex` and current `curIndex` - are lexicographically equal. If they are, we increment the \"equality\" index, `i`, until they are no longer equal or the end of the string is encountered. If the endIndex (curIndex + i) reaches the string's length, the loop ends since it's the end of the string.\n\nOtherwise, we compare `s[maxIndex + i]` and `s[curIndex + i]`. If `s[curIndex + i]` is lexicographically greater, we update `maxIndex` to the value of `curIndex`. Then, increment `curIndex`.\n\nFinally, we return the last lexicographically greater substring using the `maxIndex`.\n\nThe complexity of this solution is O(N) where N is the length of the input string.\n    ",
        "python": "\n    ```python\ndef lastSubstring(s: str) -> str:\n    maxIndex = 0\n    curIndex = 1\n    while curIndex < len(s):\n        i = 0\n        while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]:\n            i += 1\n        if curIndex + i == len(s):\n            break\n        if s[maxIndex + i] < s[curIndex + i]:\n            maxIndex = curIndex\n        curIndex += 1\n    return s[maxIndex:]\n```\n    \n    The algorithm initializes two indices, `maxIndex` and `curIndex`, both starting at the beginning of the string. We use a while loop to scan the input string until `curIndex` reaches the end.\n\nInside the loop, we check if both substrings - made with the current `maxIndex` and current `curIndex` - are lexicographically equal. If they are, we increment the \"equality\" index, `i`, until they are no longer equal or the end of the string is encountered. If the endIndex (curIndex + i) reaches the string's length, the loop ends since it's the end of the string.\n\nOtherwise, we compare `s[maxIndex + i]` and `s[curIndex + i]`. If `s[curIndex + i]` is lexicographically greater, we update `maxIndex` to the value of `curIndex`. Then, increment `curIndex`.\n\nFinally, we return the last lexicographically greater substring using the `maxIndex`.\n\nThe complexity of this solution is O(N) where N is the length of the input string.\n    ",
        "c++": "\n    ```cpp\nstd::string lastSubstring(std::string s) {\n    int maxIndex = 0;\n    int curIndex = 1;\n    while (curIndex < s.length()) {\n        int i = 0;\n        while (curIndex + i < s.length() && s[maxIndex + i] == s[curIndex + i]) {\n            i++;\n        }\n        if (curIndex + i == s.length()) break;\n        if (s[maxIndex + i] < s[curIndex + i]) {\n            maxIndex = curIndex;\n        }\n        curIndex++;\n    }\n    return s.substr(maxIndex);\n}\n```\n    \n    The algorithm initializes two indices, `maxIndex` and `curIndex`, both starting at the beginning of the string. We use a while loop to scan the input string until `curIndex` reaches the end.\n\nInside the loop, we check if both substrings - made with the current `maxIndex` and current `curIndex` - are lexicographically equal. If they are, we increment the \"equality\" index, `i`, until they are no longer equal or the end of the string is encountered. If the endIndex (curIndex + i) reaches the string's length, the loop ends since it's the end of the string.\n\nOtherwise, we compare `s[maxIndex + i]` and `s[curIndex + i]`. If `s[curIndex + i]` is lexicographically greater, we update `maxIndex` to the value of `curIndex`. Then, increment `curIndex`.\n\nFinally, we return the last lexicographically greater substring using the `maxIndex`.\n\nThe complexity of this solution is O(N) where N is the length of the input string.\n    ",
        "js": "\n    ```javascript\nfunction lastSubstring(s) {\n    let maxIndex = 0;\n    let curIndex = 1;\n    while (curIndex < s.length) {\n        let i = 0;\n        while (curIndex + i < s.length && s[maxIndex + i] === s[curIndex + i]) {\n            i++;\n        }\n        if (curIndex + i === s.length) break;\n        if (s[maxIndex + i] < s[curIndex + i]) {\n            maxIndex = curIndex;\n        }\n        curIndex++;\n    }\n    return s.slice(maxIndex);\n}\n```\n    \n    The algorithm initializes two indices, `maxIndex` and `curIndex`, both starting at the beginning of the string. We use a while loop to scan the input string until `curIndex` reaches the end.\n\nInside the loop, we check if both substrings - made with the current `maxIndex` and current `curIndex` - are lexicographically equal. If they are, we increment the \"equality\" index, `i`, until they are no longer equal or the end of the string is encountered. If the endIndex (curIndex + i) reaches the string's length, the loop ends since it's the end of the string.\n\nOtherwise, we compare `s[maxIndex + i]` and `s[curIndex + i]`. If `s[curIndex + i]` is lexicographically greater, we update `maxIndex` to the value of `curIndex`. Then, increment `curIndex`.\n\nFinally, we return the last lexicographically greater substring using the `maxIndex`.\n\nThe complexity of this solution is O(N) where N is the length of the input string.\n    "
    },
    {
        "id": 182,
        "title": "Dinner Plate Stacks",
        "difficulty": "Hard",
        "content": {
            "problem": "You have an infinite number of stacks arranged in a row and numbered (left to right) from `0`, each of the stacks has the same maximum capacity.\n\nImplement the `DinnerPlates` class:\n\n*   `DinnerPlates(int capacity)` Initializes the object with the maximum capacity of the stacks `capacity`.\n*   `void push(int val)` Pushes the given integer `val` into the leftmost stack with a size less than `capacity`.\n*   `int pop()` Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns `-1` if all the stacks are empty.\n*   `int popAtStack(int index)` Returns the value at the top of the stack with the given index `index` and removes it from that stack or returns `-1` if the stack with that given index is empty.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"DinnerPlates \",  \"push \",  \"push \",  \"push \",  \"push \",  \"push \",  \"popAtStack \",  \"push \",  \"push \",  \"popAtStack \",  \"popAtStack \",  \"pop \",  \"pop \",  \"pop \",  \"pop \",  \"pop \"\\]\n\\[\\[2\\], \\[1\\], \\[2\\], \\[3\\], \\[4\\], \\[5\\], \\[0\\], \\[20\\], \\[21\\], \\[0\\], \\[2\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1\\]\n\n**Explanation:** \nDinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // The stacks are now:  2  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                       1  3  5\n                                                       ﹈ ﹈ ﹈\nD.push(20);        // The stacks are now: 20  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.push(21);        // The stacks are now: 20  4 21\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈\nD.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈ \nD.pop()            // Returns 5.  The stacks are now:      4\n                                                        1  3 \n                                                        ﹈ ﹈  \nD.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                        ﹈ ﹈   \nD.pop()            // Returns 3.  The stacks are now:   1 \n                                                        ﹈   \nD.pop()            // Returns 1.  There are no stacks.\nD.pop()            // Returns -1.  There are still no stacks."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= capacity <= 2 * 104`\n*   `1 <= val <= 2 * 104`\n*   `0 <= index <= 105`\n*   At most `2 * 105` calls will be made to `push`, `pop`, and `popAtStack`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Stack",
            "Design",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass DinnerPlates {\n    int capacity;\n    List<List<Integer>> stacks;\n    \n    public DinnerPlates(int capacity) {\n        this.capacity = capacity;\n        stacks = new ArrayList<>();\n    }\n    \n    public void push(int val) {\n        for (List<Integer> stack : stacks) {\n            if (stack.size() < capacity) {\n                stack.add(val);\n                return;\n            }\n        }\n        stacks.add(new ArrayList<>(List.of(val)));\n    }\n    \n    public int pop() {\n        while (!stacks.isEmpty() && stacks.get(stacks.size() - 1).isEmpty()) {\n            stacks.remove(stacks.size() - 1);\n        }\n        if (stacks.isEmpty()) return -1;\n        List<Integer> lastStack = stacks.get(stacks.size() - 1);\n        int result = lastStack.get(lastStack.size() - 1);\n        lastStack.remove(lastStack.size() - 1);\n        return result;\n    }\n    \n    public int popAtStack(int index) {\n        if (index >= stacks.size() || stacks.get(index).isEmpty()) {\n            return -1;\n        }\n        List<Integer> stack = stacks.get(index);\n        int result = stack.get(stack.size() - 1);\n        stack.remove(stack.size() - 1);\n        return result;\n    }\n}\n```\n\n    \n    The algorithm uses a 2D array named \"stacks\", where each inner array represents a stack. Initially, \"stacks\" is empty. When \"push\" is called, it checks for the first stack where the size is smaller than capacity and pushes the value to that stack. If none are found, create a new stack with the value.\n\nTo perform \"pop\", we first check and remove any empty stacks from the right of our \"stacks\" array, then perform the pop operation on the right-most stack if it exists, or return -1 if there are no stacks.\n\nIn the \"popAtStack\" function, it checks if the given index exists and if the stack at that index is not empty. If so, return the popped value from that stack, otherwise, return -1.\n    ",
        "python": "\n    ```python\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        for stack in self.stacks:\n            if len(stack) < self.capacity:\n                stack.append(val)\n                return\n        self.stacks.append([val])\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        if not self.stacks:\n            return -1\n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        return self.stacks[index].pop()\n```\n\n    \n    The algorithm uses a 2D array named \"stacks\", where each inner array represents a stack. Initially, \"stacks\" is empty. When \"push\" is called, it checks for the first stack where the size is smaller than capacity and pushes the value to that stack. If none are found, create a new stack with the value.\n\nTo perform \"pop\", we first check and remove any empty stacks from the right of our \"stacks\" array, then perform the pop operation on the right-most stack if it exists, or return -1 if there are no stacks.\n\nIn the \"popAtStack\" function, it checks if the given index exists and if the stack at that index is not empty. If so, return the popped value from that stack, otherwise, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nclass DinnerPlates {\npublic:\n    int capacity;\n    vector<vector<int>> stacks;\n    \n    DinnerPlates(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    void push(int val) {\n        for (auto &s : stacks) {\n            if (s.size() < capacity) {\n                s.push_back(val);\n                return;\n            }\n        }\n        stacks.push_back({val});\n    }\n    \n    int pop() {\n        while (!stacks.empty() && stacks.back().empty()) {\n            stacks.pop_back();\n        }\n        if (stacks.empty()) return -1;\n        int result = stacks.back().back();\n        stacks.back().pop_back();\n        return result;\n    }\n    \n    int popAtStack(int index) {\n        if (index >= stacks.size() || stacks[index].empty()) {\n            return -1;\n        }\n        int result = stacks[index].back();\n        stacks[index].pop_back();\n        return result;\n    }\n};\n```\n\n    \n    The algorithm uses a 2D array named \"stacks\", where each inner array represents a stack. Initially, \"stacks\" is empty. When \"push\" is called, it checks for the first stack where the size is smaller than capacity and pushes the value to that stack. If none are found, create a new stack with the value.\n\nTo perform \"pop\", we first check and remove any empty stacks from the right of our \"stacks\" array, then perform the pop operation on the right-most stack if it exists, or return -1 if there are no stacks.\n\nIn the \"popAtStack\" function, it checks if the given index exists and if the stack at that index is not empty. If so, return the popped value from that stack, otherwise, return -1.\n    ",
        "js": "\n    ```javascript\nclass DinnerPlates {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.stacks = [];\n    }\n    \n    push(val) {\n        for (const stack of this.stacks) {\n            if (stack.length < this.capacity) {\n                stack.push(val);\n                return;\n            }\n        }\n        this.stacks.push([val]);\n    }\n    \n    pop() {\n        while (this.stacks.length && !this.stacks[this.stacks.length - 1].length) {\n            this.stacks.pop();\n        }\n        if (!this.stacks.length) return -1;\n        return this.stacks[this.stacks.length - 1].pop();\n    }\n    \n    popAtStack(index) {\n        if (index >= this.stacks.length || !this.stacks[index].length) {\n            return -1;\n        }\n        return this.stacks[index].pop();\n    }\n}\n```\n\n    \n    The algorithm uses a 2D array named \"stacks\", where each inner array represents a stack. Initially, \"stacks\" is empty. When \"push\" is called, it checks for the first stack where the size is smaller than capacity and pushes the value to that stack. If none are found, create a new stack with the value.\n\nTo perform \"pop\", we first check and remove any empty stacks from the right of our \"stacks\" array, then perform the pop operation on the right-most stack if it exists, or return -1 if there are no stacks.\n\nIn the \"popAtStack\" function, it checks if the given index exists and if the stack at that index is not empty. If so, return the popped value from that stack, otherwise, return -1.\n    "
    },
    {
        "id": 183,
        "title": "Number of Valid Words for Each Puzzle",
        "difficulty": "Hard",
        "content": {
            "problem": "With respect to a given `puzzle` string, a `word` is _valid_ if both the following conditions are satisfied:\n\n*   `word` contains the first letter of `puzzle`.\n*   For each letter in `word`, that letter is in `puzzle`.\n    *   For example, if the puzzle is `\"abcdefg \"`, then valid words are `\"faced \"`, `\"cabbage \"`, and `\"baggage \"`, while\n    *   invalid words are `\"beefed \"` (does not include `'a'`) and `\"based \"` (includes `'s'` which is not in the puzzle).\n\nReturn _an array_ `answer`_, where_ `answer[i]` _is the number of words in the given word list_ `words` _that is valid with respect to the puzzle_ `puzzles[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"aaaa \", \"asas \", \"able \", \"ability \", \"actt \", \"actor \", \"access \"\\], puzzles = \\[ \"aboveyz \", \"abrodyz \", \"abslute \", \"absoryz \", \"actresz \", \"gaswxyz \"\\]\n**Output:** \\[1,1,3,2,4,0\\]\n**Explanation:** \n1 valid word for  \"aboveyz \" :  \"aaaa \" \n1 valid word for  \"abrodyz \" :  \"aaaa \"\n3 valid words for  \"abslute \" :  \"aaaa \",  \"asas \",  \"able \"\n2 valid words for  \"absoryz \" :  \"aaaa \",  \"asas \"\n4 valid words for  \"actresz \" :  \"aaaa \",  \"asas \",  \"actt \",  \"access \"\nThere are no valid words for  \"gaswxyz \" cause none of the words in the list contains letter 'g'.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"apple \", \"pleas \", \"please \"\\], puzzles = \\[ \"aelwxyz \", \"aelpxyz \", \"aelpsxy \", \"saelpxy \", \"xaelpsy \"\\]\n**Output:** \\[0,1,3,2,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 105`\n*   `4 <= words[i].length <= 50`\n*   `1 <= puzzles.length <= 104`\n*   `puzzles[i].length == 7`\n*   `words[i]` and `puzzles[i]` consist of lowercase English letters.\n*   Each `puzzles[i]` does not contain repeated characters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Trie"
        ],
        "example": [
            {
                "input": "[\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"],[\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]",
                "output": "[1,1,3,2,4,0]"
            },
            {
                "input": "[\"apple\",\"pleas\",\"please\"],[\"aelwxyz\",\"aelpxyz\",\"aelpsxy\",\"saelpxy\",\"xaelpsy\"]",
                "output": "[0,1,3,2,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\n    List<Integer> result = new ArrayList<>();\n    for (String puzzle : puzzles) {\n        int count = 0;\n        Set<Character> puzzleSet = new HashSet<>();\n        for (char c : puzzle.toCharArray()) {\n            puzzleSet.add(c);\n        }\n        for (String word : words) {\n            if (word.indexOf(puzzle.charAt(0)) >= 0) {\n                if (word.chars().allMatch(c -> puzzleSet.contains((char) c))) {\n                    count++;\n                }\n            }\n        }\n        result.add(count);\n    }\n    return result;\n}\n```\n\n    \n    We iterate through each puzzle in the given puzzles array. Then, we create a set containing all the unique characters of the current puzzle, which will be used later for checking if a word is valid with respect to the puzzle. Afterward, for each word in the words array, we check if the first letter of the puzzle is in this word. If it is, we check if all the characters in the word are present in the puzzle set. If they are, we increment the count of the valid words for the current puzzle. Finally, we append the count to our result list and move on to the next puzzle. We do this for all the puzzles, and the result list is returned.\n    ",
        "python": "\n    ```python\ndef find_num_of_valid_words(words, puzzles):\n    result = []\n    for puzzle in puzzles:\n        count = 0\n        puzzle_set = set(puzzle)\n        for word in words:\n            if puzzle[0] in word:\n                if all(c in puzzle_set for c in word):\n                    count += 1\n        result.append(count)\n    return result\n```\n\n    \n    We iterate through each puzzle in the given puzzles array. Then, we create a set containing all the unique characters of the current puzzle, which will be used later for checking if a word is valid with respect to the puzzle. Afterward, for each word in the words array, we check if the first letter of the puzzle is in this word. If it is, we check if all the characters in the word are present in the puzzle set. If they are, we increment the count of the valid words for the current puzzle. Finally, we append the count to our result list and move on to the next puzzle. We do this for all the puzzles, and the result list is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<int> findNumOfValidWords(std::vector<std::string>& words, std::vector<std::string>& puzzles) {\n    std::vector<int> result;\n    for (const std::string& puzzle : puzzles) {\n        int count = 0;\n        std::unordered_set<char> puzzleSet(puzzle.begin(), puzzle.end());\n        for (const std::string& word : words) {\n            if (word.find(puzzle[0]) != std::string::npos) {\n                if (std::all_of(word.begin(), word.end(), [&](char c) { return puzzleSet.count(c) > 0; })) {\n                    count++;\n                }\n            }\n        }\n        result.push_back(count);\n    }\n    return result;\n}\n```\n\n    \n    We iterate through each puzzle in the given puzzles array. Then, we create a set containing all the unique characters of the current puzzle, which will be used later for checking if a word is valid with respect to the puzzle. Afterward, for each word in the words array, we check if the first letter of the puzzle is in this word. If it is, we check if all the characters in the word are present in the puzzle set. If they are, we increment the count of the valid words for the current puzzle. Finally, we append the count to our result list and move on to the next puzzle. We do this for all the puzzles, and the result list is returned.\n    ",
        "js": "\n    ```javascript\nfunction findNumOfValidWords(words, puzzles) {\n    const result = [];\n    for (const puzzle of puzzles) {\n        let count = 0;\n        const puzzleSet = new Set(puzzle);\n        for (const word of words) {\n            if (word.includes(puzzle[0])) {\n                if (Array.from(word).every(c => puzzleSet.has(c))) {\n                    count++;\n                }\n            }\n        }\n        result.push(count);\n    }\n    return result;\n}\n```\n\n    \n    We iterate through each puzzle in the given puzzles array. Then, we create a set containing all the unique characters of the current puzzle, which will be used later for checking if a word is valid with respect to the puzzle. Afterward, for each word in the words array, we check if the first letter of the puzzle is in this word. If it is, we check if all the characters in the word are present in the puzzle set. If they are, we increment the count of the valid words for the current puzzle. Finally, we append the count to our result list and move on to the next puzzle. We do this for all the puzzles, and the result list is returned.\n    "
    },
    {
        "id": 184,
        "title": "Make Array Strictly Increasing",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two integer arrays `arr1` and `arr2`, return the minimum number of operations (possibly zero) needed to make `arr1` strictly increasing.\n\nIn one operation, you can choose two indices `0 <= i < arr1.length` and `0 <= j < arr2.length` and do the assignment `arr1[i] = arr2[j]`.\n\nIf there is no way to make `arr1` strictly increasing, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[1,3,2,4\\]\n**Output:** 1\n**Explanation:** Replace `5` with `2`, then `arr1 = [1, 2, 3, 6, 7]`.\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[4,3,1\\]\n**Output:** 2\n**Explanation:** Replace `5` with `3` and then replace `3` with `4`. `arr1 = [1, 3, 4, 6, 7]`.\n\n",
                "**Example 3:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[1,6,3,3\\]\n**Output:** -1\n**Explanation:** You can't make `arr1` strictly increasing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 2000`\n*   `0 <= arr1[i], arr2[i] <= 10^9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,5,3,6,7],[1,3,2,4]",
                "output": "1"
            },
            {
                "input": "[1,5,3,6,7],[4,3,1]",
                "output": "2"
            },
            {
                "input": "[1,5,3,6,7],[1,6,3,3]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.concurrent.*;\n\nclass FooBar {\n    private int n;\n    private Semaphore fooSemaphore = new Semaphore(1);\n    private Semaphore barSemaphore = new Semaphore(0);\n\n    public FooBar(int n) {\n        this.n = n;\n    }\n\n    public void foo(Runnable printFoo) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            fooSemaphore.acquire();\n            printFoo.run();\n            barSemaphore.release();\n        }\n    }\n\n    public void bar(Runnable printBar) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            barSemaphore.acquire();\n            printBar.run();\n            fooSemaphore.release();\n        }\n    }\n}\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    ",
        "python": "\n    ```python\nfrom threading import Lock\n\nclass FooBar:\n    def __init__(self, n: int):\n        self.n = n\n        self.foo_lock = Lock()\n        self.bar_lock = Lock()\n        self.bar_lock.acquire()\n\n    def foo(self, printFoo) -> None:\n        for _ in range(self.n):\n            self.foo_lock.acquire()\n            printFoo()\n            self.bar_lock.release()\n\n    def bar(self, printBar) -> None:\n        for _ in range(self.n):\n            self.bar_lock.acquire()\n            printBar()\n            self.foo_lock.release()\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    ",
        "c++": "\n    ```cpp\n#include <mutex>\n#include <condition_variable>\n\nclass FooBar {\nprivate:\n    int n;\n    std::mutex mtx;\n    std::condition_variable cv;\n    bool foo_done = false;\n\npublic:\n    FooBar(int n) {\n        this->n = n;\n    }\n\n    void foo(function<void()> printFoo) {\n        for (int i = 0; i < n; i++) {\n            std::unique_lock<std::mutex> lock(mtx);\n            cv.wait(lock, [this]() { return !foo_done; });\n            printFoo();\n            foo_done = true;\n            cv.notify_all();\n        }\n    }\n\n    void bar(function<void()> printBar) {\n        for (int i = 0; i < n; i++) {\n            std::unique_lock<std::mutex> lock(mtx);\n            cv.wait(lock, [this]() { return foo_done; });\n            printBar();\n            foo_done = false;\n            cv.notify_all();\n        }\n    }\n};\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    ",
        "js": "\n    ```javascript\nclass FooBar {\n  constructor(n) {\n    this.n = n;\n    this.fooPromiseResolver = null;\n    this.fooPromise = new Promise((resolve) => (this.fooPromiseResolver = resolve));\n    this.barPromiseResolver = null;\n    this.barPromise = new Promise((resolve) => (this.barPromiseResolver = resolve));\n  }\n\n  async foo(printFoo) {\n    for (let i = 0; i < this.n; i++) {\n      await this.fooPromise;\n      printFoo();\n      this.barPromiseResolver();\n      this.fooPromise = new Promise((resolve) => (this.fooPromiseResolver = resolve));\n    }\n  }\n\n  async bar(printBar) {\n    for (let i = 0; i < this.n; i++) {\n      await this.barPromise;\n      printBar();\n      this.fooPromiseResolver();\n      this.barPromise = new Promise((resolve) => (this.barPromiseResolver = resolve));\n    }\n  }\n}\n```\n    \n    1. In all four languages, a class named FooBar is created. The constructor accepts a single integer argument, `n`, which will be used later for looping purposes.\n\n2. The main challenge is to ensure that functions 'foo' and 'bar' are executed in the correct order (\"foobar\") `n` times by the two threads simultaneously. The method of synchronization differs in each language implementation.\n\n3. In C++, the implementation uses mutex and condition_variable from the standard library to synchronize the threads. A boolean, `foo_done`, is used to maintain the state of whether the foo function has been executed or not.\n\n4. In Java, semaphores are used to synchronize the threads in the `foo` and `bar` functions. The `acquire()` and `release()` methods of semaphores ensure that the threads wait and proceed in the correct order.\n\n5. In Python, Lock objects from the `threading` library are used to synchronize the two functions. `foo_lock` and `bar_lock` ensure the correct order of execution.\n\n6. In JavaScript, Promises and async/await are used to synchronize the execution of the `foo` and `bar` functions. By using the `await` keyword, the functions wait for each other to complete their execution before progressing, ensuring the correct order.\n\nIn all implementations, the goal is to ensure that the 'foo' function is executed before the 'bar' function for `n` iterations in two separate threads, such that the output is \"foobar\" repeated `n` times.\n    "
    },
    {
        "id": 185,
        "title": "Critical Connections in a Network",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\nA _critical connection_ is a connection that, if removed, will make some servers unable to reach some other server.\n\nReturn all critical connections in the network in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, connections = \\[\\[0,1\\],\\[1,2\\],\\[2,0\\],\\[1,3\\]\\]\n**Output:** \\[\\[1,3\\]\\]\n**Explanation:** \\[\\[3,1\\]\\] is also accepted.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, connections = \\[\\[0,1\\]\\]\n**Output:** \\[\\[0,1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 105`\n*   `n - 1 <= connections.length <= 105`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   There are no repeated connections.",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Biconnected Component"
        ],
        "example": [
            {
                "input": "4,[[0,1],[1,2],[2,0],[1,3]]",
                "output": "[[1,3]]"
            },
            {
                "input": "2,[[0,1]]",
                "output": "[[0,1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n    List<List<Integer>> result = new ArrayList<>();\n    Map<Integer, List<Integer>> graph = new HashMap<>();\n    for (List<Integer> connection : connections) {\n        graph.putIfAbsent(connection.get(0), new ArrayList<>());\n        graph.putIfAbsent(connection.get(1), new ArrayList<>());\n        graph.get(connection.get(0)).add(connection.get(1));\n        graph.get(connection.get(1)).add(connection.get(0));\n    }\n    int[] rank = new int[n];\n    for (int i = 0; i < n; i++) {\n        rank[i] = -1;\n    }\n    dfs(0, -1, 0, rank, graph, result);\n    return result;\n}\n\nprivate void dfs(int node, int parent, int depth, int[] rank, Map<Integer, List<Integer>> graph, List<List<Integer>> result) {\n    rank[node] = depth;\n    for (int neighbor : graph.get(node)) {\n        if (neighbor == parent) {\n            continue;\n        }\n        if (rank[neighbor] == -1) {\n            dfs(neighbor, node, depth + 1, rank, graph, result);\n        }\n        rank[node] = Math.min(rank[node], rank[neighbor]);\n        if (rank[neighbor] == depth + 1) {\n            result.add(List.of(node, neighbor));\n        }\n    }\n}\n```\n\n    \n    The problem can be solved using a Depth-First Search (DFS) algorithm. The algorithm starts by creating a graph from the server connections, represented by an adjacency list. Then a Rank array is initialized with -1 as initial value, which will store the rank/depth of each node in the DFS traversal.\n\nWe execute a DFS starting from the initial node (0) and at each step, we update the rank of the current node accordingly. Then, we visit neighbors. If the neighbor is the parent node from where the current node is visited, we just skip and continue to the next neighbor.\n\nIf the neighbor node has not been visited yet, DFS is called recursively for the neighbor node, increasing the depth by one. After the DFS call, we update the current node's rank with the minimum rank between its rank and the neighbors' rank if a neighbor node has been visited earlier.\n\nFinally, we check if the neighbor node's rank is equal to the depth of the current node plus one. If true, it means the connection between the current node and the neighbor node is critical, thus we add this connection to the result.\n\nOnce the algorithm is done executing the DFS, the result will contain all critical connections.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef criticalConnections(n, connections):\n    def dfs(node, parent, depth, rank, graph, result):\n        rank[node] = depth\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if rank[neighbor] == -1:\n                dfs(neighbor, node, depth + 1, rank, graph, result)\n            rank[node] = min(rank[node], rank[neighbor])\n            if rank[neighbor] == depth + 1:\n                result.append((node, neighbor))\n\n    graph = defaultdict(list)\n    for fr, to in connections:\n        graph[fr].append(to)\n        graph[to].append(fr)\n\n    rank = [-1] * n\n    result = []\n    dfs(0, -1, 0, rank, graph, result)\n    return result\n```\n\n    \n    The problem can be solved using a Depth-First Search (DFS) algorithm. The algorithm starts by creating a graph from the server connections, represented by an adjacency list. Then a Rank array is initialized with -1 as initial value, which will store the rank/depth of each node in the DFS traversal.\n\nWe execute a DFS starting from the initial node (0) and at each step, we update the rank of the current node accordingly. Then, we visit neighbors. If the neighbor is the parent node from where the current node is visited, we just skip and continue to the next neighbor.\n\nIf the neighbor node has not been visited yet, DFS is called recursively for the neighbor node, increasing the depth by one. After the DFS call, we update the current node's rank with the minimum rank between its rank and the neighbors' rank if a neighbor node has been visited earlier.\n\nFinally, we check if the neighbor node's rank is equal to the depth of the current node plus one. If true, it means the connection between the current node and the neighbor node is critical, thus we add this connection to the result.\n\nOnce the algorithm is done executing the DFS, the result will contain all critical connections.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvoid dfs(int node, int parent, int depth, vector<int>& rank, unordered_map<int, vector<int>>& graph, vector<vector<int>>& result) {\n    rank[node] = depth;\n    for (const int& neighbor : graph[node]) {\n        if (neighbor == parent) {\n            continue;\n        }\n        if (rank[neighbor] == -1) {\n            dfs(neighbor, node, depth + 1, rank, graph, result);\n        }\n        rank[node] = min(rank[node], rank[neighbor]);\n        if (rank[neighbor] == depth + 1) {\n            result.push_back({node, neighbor});\n        }\n    }\n}\n\nvector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n    vector<vector<int>> result;\n    unordered_map<int, vector<int>> graph;\n    for (const vector<int>& connection : connections) {\n        graph[connection[0]].push_back(connection[1]);\n        graph[connection[1]].push_back(connection[0]);\n    }\n    vector<int> rank(n, -1);\n    dfs(0, -1, 0, rank, graph, result);\n    return result;\n}\n```\n\n    \n    The problem can be solved using a Depth-First Search (DFS) algorithm. The algorithm starts by creating a graph from the server connections, represented by an adjacency list. Then a Rank array is initialized with -1 as initial value, which will store the rank/depth of each node in the DFS traversal.\n\nWe execute a DFS starting from the initial node (0) and at each step, we update the rank of the current node accordingly. Then, we visit neighbors. If the neighbor is the parent node from where the current node is visited, we just skip and continue to the next neighbor.\n\nIf the neighbor node has not been visited yet, DFS is called recursively for the neighbor node, increasing the depth by one. After the DFS call, we update the current node's rank with the minimum rank between its rank and the neighbors' rank if a neighbor node has been visited earlier.\n\nFinally, we check if the neighbor node's rank is equal to the depth of the current node plus one. If true, it means the connection between the current node and the neighbor node is critical, thus we add this connection to the result.\n\nOnce the algorithm is done executing the DFS, the result will contain all critical connections.\n    ",
        "js": "\n    ```javascript\nfunction criticalConnections(n, connections) {\n    const graph = new Map();\n    for (const [fr, to] of connections) {\n        if (!graph.has(fr)) {\n            graph.set(fr, []);\n        }\n        if (!graph.has(to)) {\n            graph.set(to, []);\n        }\n        graph.get(fr).push(to);\n        graph.get(to).push(fr);\n    }\n\n    const rank = new Array(n).fill(-1);\n    const result = [];\n    dfs(0, -1, 0, rank, graph, result);\n    return result;\n}\n\nfunction dfs(node, parent, depth, rank, graph, result) {\n    rank[node] = depth;\n    for (const neighbor of graph.get(node)) {\n        if (neighbor === parent) {\n            continue;\n        }\n        if (rank[neighbor] === -1) {\n            dfs(neighbor, node, depth + 1, rank, graph, result);\n        }\n        rank[node] = Math.min(rank[node], rank[neighbor]);\n        if (rank[neighbor] === depth + 1) {\n            result.push([node, neighbor]);\n        }\n    }\n}\n```\n\n    \n    The problem can be solved using a Depth-First Search (DFS) algorithm. The algorithm starts by creating a graph from the server connections, represented by an adjacency list. Then a Rank array is initialized with -1 as initial value, which will store the rank/depth of each node in the DFS traversal.\n\nWe execute a DFS starting from the initial node (0) and at each step, we update the rank of the current node accordingly. Then, we visit neighbors. If the neighbor is the parent node from where the current node is visited, we just skip and continue to the next neighbor.\n\nIf the neighbor node has not been visited yet, DFS is called recursively for the neighbor node, increasing the depth by one. After the DFS call, we update the current node's rank with the minimum rank between its rank and the neighbors' rank if a neighbor node has been visited earlier.\n\nFinally, we check if the neighbor node's rank is equal to the depth of the current node plus one. If true, it means the connection between the current node and the neighbor node is critical, thus we add this connection to the result.\n\nOnce the algorithm is done executing the DFS, the result will contain all critical connections.\n    "
    },
    {
        "id": 186,
        "title": "Sort Items by Groups Respecting Dependencies",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`\\-th item belongs to and it's equal to `-1` if the `i`\\-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\nReturn a sorted list of the items such that:\n\n*   The items that belong to the same group are next to each other in the sorted list.\n*   There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`\\-th item in the sorted array (to the left of the `i`\\-th item).\n\nReturn any solution if there is more than one solution and return an **empty list** if there is no solution.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 8, m = 2, group = \\[-1,-1,1,0,0,1,0,-1\\], beforeItems = \\[\\[\\],\\[6\\],\\[5\\],\\[6\\],\\[3,6\\],\\[\\],\\[\\],\\[\\]\\]\n**Output:** \\[6,3,4,1,5,2,0,7\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 8, m = 2, group = \\[-1,-1,1,0,0,1,0,-1\\], beforeItems = \\[\\[\\],\\[6\\],\\[5\\],\\[6\\],\\[3\\],\\[\\],\\[4\\],\\[\\]\\]\n**Output:** \\[\\]\n**Explanation:** This is the same as example 1 except that 4 needs to be before 6 in the sorted list."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m <= n <= 3 * 104`\n*   `group.length == beforeItems.length == n`\n*   `-1 <= group[i] <= m - 1`\n*   `0 <= beforeItems[i].length <= n - 1`\n*   `0 <= beforeItems[i][j] <= n - 1`\n*   `i != beforeItems[i][j]`\n*   `beforeItems[i]` does not contain duplicates elements.",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "8,2,[-1,-1,1,0,0,1,0,-1],[[],[6],[5],[6],[3,6],[],[],[]]",
                "output": "[6,3,4,1,5,2,0,7]"
            },
            {
                "input": "8,2,[-1,-1,1,0,0,1,0,-1],[[],[6],[5],[6],[3],[],[4],[]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\nclass Foo {\n    private AtomicInteger order = new AtomicInteger(1);\n\n    public Foo() {}\n\n    public void first() {\n        synchronized(this) {\n            // printFirst() outputs \"first\". Do not change or remove this line.\n            printFirst();\n            order.set(2);\n            this.notifyAll();\n        }\n    }\n\n    public void second() {\n        synchronized(this) {\n            while (order.get() != 2) {\n                try {\n                    this.wait();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n            // printSecond() outputs \"second\". Do not change or remove this line.\n            printSecond();\n            order.set(3);\n            this.notifyAll();\n        }\n    }\n\n    public void third() {\n        synchronized(this) {\n            while (order.get() != 3) {\n                try {\n                    this.wait();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n            // printThird() outputs \"third\". Do not change or remove this line.\n            printThird();\n        }\n    }\n}\n```\n    \n    The class `Foo` in each language implementation is designed to ensure the proper execution order of its `first()`, `second()`, and `third()` methods, regardless of the order of their calls. This is achieved by using synchronization mechanisms like `std::mutex` and `std::condition_variable` in C++, `AtomicInteger` and `synchronized` block in Java, `Condition` object in Python, and `Promise` and `Map` objects in JavaScript. \n\nFor each language implementation, we keep track of the current order of execution using an integer variable, initially set to 1. The `first()` function executes the `printFirst()` with the current order and updates the order to 2, notifying the other functions waiting on the condition variable. The `second()` function waits for the order to become 2. Once the `first()` function updates the order, the `second()` function proceeds to execute `printSecond()`, and then updates the order to 3, notifying the remaining functions. Finally, the `third()` function waits for the order to become 3, then, upon receiving the update, executes `printThird()`.\n\nThis ensures that the methods are executed in the correct order, regardless of their initial calls order or the threads scheduling.\n    ",
        "python": "\n    ```python\nfrom threading import Condition\n\nclass Foo:\n    def __init__(self):\n        self.order = 1\n        self.cv = Condition()\n\n    def first(self):\n        with self.cv:\n            # printFirst() outputs \"first\". Do not change or remove this line.\n            printFirst()\n            self.order = 2\n            self.cv.notify_all()\n\n    def second(self):\n        with self.cv:\n            self.cv.wait_for(lambda: self.order == 2)\n            # printSecond() outputs \"second\". Do not change or remove this line.\n            printSecond()\n            self.order = 3\n            self.cv.notify_all()\n\n    def third(self):\n        with self.cv:\n            self.cv.wait_for(lambda: self.order == 3)\n            # printThird() outputs \"third\". Do not change or remove this line.\n            printThird()\n```\n    \n    The class `Foo` in each language implementation is designed to ensure the proper execution order of its `first()`, `second()`, and `third()` methods, regardless of the order of their calls. This is achieved by using synchronization mechanisms like `std::mutex` and `std::condition_variable` in C++, `AtomicInteger` and `synchronized` block in Java, `Condition` object in Python, and `Promise` and `Map` objects in JavaScript. \n\nFor each language implementation, we keep track of the current order of execution using an integer variable, initially set to 1. The `first()` function executes the `printFirst()` with the current order and updates the order to 2, notifying the other functions waiting on the condition variable. The `second()` function waits for the order to become 2. Once the `first()` function updates the order, the `second()` function proceeds to execute `printSecond()`, and then updates the order to 3, notifying the remaining functions. Finally, the `third()` function waits for the order to become 3, then, upon receiving the update, executes `printThird()`.\n\nThis ensures that the methods are executed in the correct order, regardless of their initial calls order or the threads scheduling.\n    ",
        "c++": "\n    ```cpp\n#include <mutex>\n#include <condition_variable>\n\nclass Foo {\n    std::mutex mtx;\n    std::condition_variable cv;\n    int order = 1;\n\npublic:\n    Foo() {}\n\n    void first() {\n        std::unique_lock<std::mutex> lock(mtx);\n        // PrintFirst() outputs \"first\". Do not change or remove this line.\n        printFirst();\n        order = 2;\n        cv.notify_all();\n    }\n\n    void second() {\n        std::unique_lock<std::mutex> lock(mtx);\n        cv.wait(lock, [&](){ return order == 2; });\n        // PrintSecond() outputs \"second\". Do not change or remove this line.\n        printSecond();\n        order = 3;\n        cv.notify_all();\n    }\n\n    void third() {\n        std::unique_lock<std::mutex> lock(mtx);\n        cv.wait(lock, [&](){ return order == 3; });\n        // PrintThird() outputs \"third\". Do not change or remove this line.\n        printThird();\n    }\n};\n```\n    \n    The class `Foo` in each language implementation is designed to ensure the proper execution order of its `first()`, `second()`, and `third()` methods, regardless of the order of their calls. This is achieved by using synchronization mechanisms like `std::mutex` and `std::condition_variable` in C++, `AtomicInteger` and `synchronized` block in Java, `Condition` object in Python, and `Promise` and `Map` objects in JavaScript. \n\nFor each language implementation, we keep track of the current order of execution using an integer variable, initially set to 1. The `first()` function executes the `printFirst()` with the current order and updates the order to 2, notifying the other functions waiting on the condition variable. The `second()` function waits for the order to become 2. Once the `first()` function updates the order, the `second()` function proceeds to execute `printSecond()`, and then updates the order to 3, notifying the remaining functions. Finally, the `third()` function waits for the order to become 3, then, upon receiving the update, executes `printThird()`.\n\nThis ensures that the methods are executed in the correct order, regardless of their initial calls order or the threads scheduling.\n    ",
        "js": "\n    ```javascript\nclass Foo {\n    constructor() {\n        this.order = 1;\n        this.cv = new Map(); // empty map to hold promises\n    }\n\n    async first(printFirst) {\n        // printFirst() outputs \"first\". Do not change or remove this line.\n        await printFirst();\n        this.order = 2;\n        if (this.cv.has(2)) {\n            this.cv.get(2)(); // resolve promise\n        }\n    }\n\n    async second(printSecond) {\n        if (this.order < 2) {\n            // creates a new promise\n            await new Promise((resolve) => this.cv.set(2, resolve));\n        }\n        // printSecond() outputs \"second\". Do not change or remove this line.\n        await printSecond();\n        this.order = 3;\n        if (this.cv.has(3)) {\n            this.cv.get(3)(); // resolve promise\n        }\n    }\n\n    async third(printThird) {\n        if (this.order < 3) {\n            // creates a new promise\n            await new Promise((resolve) => this.cv.set(3, resolve));\n        }\n        // printThird() outputs \"third\". Do not change or remove this line.\n        await printThird();\n    }\n}\n```\n    \n    The class `Foo` in each language implementation is designed to ensure the proper execution order of its `first()`, `second()`, and `third()` methods, regardless of the order of their calls. This is achieved by using synchronization mechanisms like `std::mutex` and `std::condition_variable` in C++, `AtomicInteger` and `synchronized` block in Java, `Condition` object in Python, and `Promise` and `Map` objects in JavaScript. \n\nFor each language implementation, we keep track of the current order of execution using an integer variable, initially set to 1. The `first()` function executes the `printFirst()` with the current order and updates the order to 2, notifying the other functions waiting on the condition variable. The `second()` function waits for the order to become 2. Once the `first()` function updates the order, the `second()` function proceeds to execute `printSecond()`, and then updates the order to 3, notifying the remaining functions. Finally, the `third()` function waits for the order to become 3, then, upon receiving the update, executes `printThird()`.\n\nThis ensures that the methods are executed in the correct order, regardless of their initial calls order or the threads scheduling.\n    "
    },
    {
        "id": 187,
        "title": "Design Skiplist",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a **Skiplist** without using any built-in libraries.\n\nA **skiplist** is a data structure that takes `O(log(n))` time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.\n\nFor example, we have a Skiplist containing `[30,40,50,60,70,90]` and we want to add `80` and `45` into it. The Skiplist works this way:\n\n  \nArtyom Kalinin \\[CC BY-SA 3.0\\], via [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif \"Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons\")\n\nYou can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than `O(n)`. It can be proven that the average time complexity for each operation is `O(log(n))` and space complexity is `O(n)`.\n\nSee more about Skiplist: [https://en.wikipedia.org/wiki/Skip\\_list](https://en.wikipedia.org/wiki/Skip_list)\n\nImplement the `Skiplist` class:\n\n*   `Skiplist()` Initializes the object of the skiplist.\n*   `bool search(int target)` Returns `true` if the integer `target` exists in the Skiplist or `false` otherwise.\n*   `void add(int num)` Inserts the value `num` into the SkipList.\n*   `bool erase(int num)` Removes the value `num` from the Skiplist and returns `true`. If `num` does not exist in the Skiplist, do nothing and return `false`. If there exist multiple `num` values, removing any one of them is fine.\n\nNote that duplicates may exist in the Skiplist, your code needs to handle this situation.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Skiplist \",  \"add \",  \"add \",  \"add \",  \"search \",  \"add \",  \"search \",  \"erase \",  \"erase \",  \"search \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[3\\], \\[0\\], \\[4\\], \\[1\\], \\[0\\], \\[1\\], \\[1\\]\\]\n**Output**\n\\[null, null, null, null, false, null, true, false, true, false\\]\n\n**Explanation**\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0); // return False\nskiplist.add(4);\nskiplist.search(1); // return True\nskiplist.erase(0);  // return False, 0 is not in skiplist.\nskiplist.erase(1);  // return True\nskiplist.search(1); // return False, 1 has already been erased."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num, target <= 2 * 104`\n*   At most `5 * 104` calls will be made to `search`, `add`, and `erase`.",
            "follow_up": null
        },
        "tag": [
            "Linked List",
            "Design"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,null,false,null,true,false,true,false]"
            }
        ],
        "java": "\n    ```java\npublic int[] corpFlightBookings(int[][] bookings, int n) {\n    int[] answer = new int[n];\n    for (int[] booking : bookings) {\n        answer[booking[0] - 1] += booking[2];\n        if (booking[1] < n) {\n            answer[booking[1]] -= booking[2];\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        answer[i] += answer[i - 1];\n    }\n    return answer;\n}\n```\n    \n    For each booking `[first, last, seats]`, we add the number of `seats` to the array `answer` at the index `first-1` and subtract the number of `seats` at the index `last`. This means that we have a running total of reserved seats at each index of the array `answer`. Then, to finalize the result, we go through the array `answer`, summing up the previous values to get the total reserved seats at each index.\n    ",
        "python": "\n    ```python\ndef corp_flight_bookings(bookings, n):\n    answer = [0] * n\n    for start, end, seats in bookings:\n        answer[start - 1] += seats\n        if end < n:\n            answer[end] -= seats\n    for i in range(1, n):\n        answer[i] += answer[i - 1]\n    return answer\n```\n    \n    For each booking `[first, last, seats]`, we add the number of `seats` to the array `answer` at the index `first-1` and subtract the number of `seats` at the index `last`. This means that we have a running total of reserved seats at each index of the array `answer`. Then, to finalize the result, we go through the array `answer`, summing up the previous values to get the total reserved seats at each index.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> corpFlightBookings(std::vector<std::vector<int>>& bookings, int n) {\n    std::vector<int> answer(n, 0);\n    for (const auto& booking : bookings) {\n        answer[booking[0] - 1] += booking[2];\n        if (booking[1] < n) {\n            answer[booking[1]] -= booking[2];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        answer[i] += answer[i - 1];\n    }\n    return answer;\n}\n```\n    \n    For each booking `[first, last, seats]`, we add the number of `seats` to the array `answer` at the index `first-1` and subtract the number of `seats` at the index `last`. This means that we have a running total of reserved seats at each index of the array `answer`. Then, to finalize the result, we go through the array `answer`, summing up the previous values to get the total reserved seats at each index.\n    ",
        "js": "\n    ```javascript\nfunction corpFlightBookings(bookings, n) {\n    let answer = new Array(n).fill(0);\n    for (let booking of bookings) {\n        answer[booking[0] - 1] += booking[2];\n        if (booking[1] < n) {\n            answer[booking[1]] -= booking[2];\n        }\n    }\n    for (let i = 1; i < n; i++) {\n        answer[i] += answer[i - 1];\n    }\n    return answer;\n}\n```\n    \n    For each booking `[first, last, seats]`, we add the number of `seats` to the array `answer` at the index `first-1` and subtract the number of `seats` at the index `last`. This means that we have a running total of reserved seats at each index of the array `answer`. Then, to finalize the result, we go through the array `answer`, summing up the previous values to get the total reserved seats at each index.\n    "
    },
    {
        "id": 188,
        "title": "Minimum Moves to Reach Target with Rotations",
        "difficulty": "Hard",
        "content": {
            "problem": "In an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.\n\nIn one move the snake can:\n\n*   Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n*   Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n*   Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.  \n    \n*   Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.  \n    \n\nReturn the minimum number of moves to reach the target.\n\nIf there is no way to reach the target, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0,0,1\\],\n               \\[1,1,0,0,1,0\\],\n               \\[0,0,0,0,1,1\\],\n               \\[0,0,1,0,1,0\\],\n               \\[0,1,1,0,0,0\\],\n               \\[0,1,1,0,0,0\\]\\]\n**Output:** 11\n**Explanation:**\nOne possible solution is \\[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down\\].\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,0,1,1,1,1\\],\n               \\[0,0,0,0,1,1\\],\n               \\[1,1,0,0,0,1\\],\n               \\[1,1,1,0,0,1\\],\n               \\[1,1,1,0,0,1\\],\n               \\[1,1,1,0,0,0\\]\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 100`\n*   `0 <= grid[i][j] <= 1`\n*   It is guaranteed that the snake starts at empty cells.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,0,0,0,0,1],\n[1,1,0,0,1,0],\n[0,0,0,0,1,1],\n[0,0,1,0,1,0],\n[0,1,1,0,0,0],\n[0,1,1,0,0,0]]",
                "output": "11"
            },
            {
                "input": "[[0,0,1,1,1,1],\n[0,0,0,0,1,1],\n[1,1,0,0,0,1],\n[1,1,1,0,0,1],\n[1,1,1,0,0,1],\n[1,1,1,0,0,0]]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic double trimmedMean(int[] arr) {\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    Arrays.sort(arr);\n    double sum = 0.0;\n    for (int i = remove; i < n - remove; i++) {\n        sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n}\n```\n    \n    1. Calculate the number of elements to remove from each side which is equal to 5% of the array length.\n2. Sort the input array in ascending order.\n3. Calculate the sum of the remaining elements after removing the smallest 5% and largest 5% of the sorted array.\n4. Return the mean for the remaining elements by dividing the sum by `(n - 2 * remove)`.\n    ",
        "python": "\n    ```python\ndef trimmed_mean(arr):\n    n = len(arr)\n    remove = int(n * 0.05)\n    arr.sort()\n    return sum(arr[remove:n - remove]) / (n - 2 * remove)\n```\n    \n    1. Calculate the number of elements to remove from each side which is equal to 5% of the array length.\n2. Sort the input array in ascending order.\n3. Calculate the sum of the remaining elements after removing the smallest 5% and largest 5% of the sorted array.\n4. Return the mean for the remaining elements by dividing the sum by `(n - 2 * remove)`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\ndouble trimmedMean(std::vector<int>& arr) {\n    int n = arr.size();\n    int remove = n * 0.05;\n    std::sort(arr.begin(), arr.end());\n    double sum = 0.0;\n    for (int i = remove; i < n - remove; i++) {\n        sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n}\n```\n    \n    1. Calculate the number of elements to remove from each side which is equal to 5% of the array length.\n2. Sort the input array in ascending order.\n3. Calculate the sum of the remaining elements after removing the smallest 5% and largest 5% of the sorted array.\n4. Return the mean for the remaining elements by dividing the sum by `(n - 2 * remove)`.\n    ",
        "js": "\n    ```javascript\nfunction trimmedMean(arr) {\n    const n = arr.length;\n    const remove = Math.floor(n * 0.05);\n    arr.sort((a, b) => a - b);\n    let sum = 0.0;\n    for (let i = remove; i < n - remove; i++) {\n        sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n}\n```\n\n    \n    1. Calculate the number of elements to remove from each side which is equal to 5% of the array length.\n2. Sort the input array in ascending order.\n3. Calculate the sum of the remaining elements after removing the smallest 5% and largest 5% of the sorted array.\n4. Return the mean for the remaining elements by dividing the sum by `(n - 2 * remove)`.\n    "
    },
    {
        "id": 189,
        "title": "Count Vowels Permutation",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n*   Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n*   Each vowel `'a'` may only be followed by an `'e'`.\n*   Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n*   Each vowel `'i'` **may not** be followed by another `'i'`.\n*   Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n*   Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** 5\n**Explanation:** All possible strings are:  \"a \",  \"e \",  \"i \" ,  \"o \" and  \"u \".\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 10\n**Explanation:** All possible strings are:  \"ae \",  \"ea \",  \"ei \",  \"ia \",  \"ie \",  \"io \",  \"iu \",  \"oi \",  \"ou \" and  \"ua \".\n\n",
                "**Example 3:**\n\n**Input:** n = 5\n**Output:** 68"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2 * 10^4`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "1",
                "output": "5"
            },
            {
                "input": "2",
                "output": "10"
            },
            {
                "input": "5",
                "output": "68"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {\n        Map<String, Integer> index = new HashMap<>();\n        int num_skills = req_skills.length;\n        for (int i = 0; i < num_skills; i++) {\n            index.put(req_skills[i], i);\n        }\n        \n        List<Integer> sks = new ArrayList<>();\n        for (int i = 0; i < people.size(); i++) {\n            int cur = 0;\n            for (String s : people.get(i)) {\n                cur |= 1 << index.get(s);\n            }\n            sks.add(cur);\n        }\n\n        int INF = 64;\n        int[] dp = new int[1 << num_skills];\n        int[] parent = new int[1 << num_skills];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        \n        for (int i = 0; i < people.size(); i++) {\n            int hiskills = sks.get(i);\n            for (int done = (1 << num_skills) - 1; done >= 0; done--) {\n                int withhim = done | hiskills;\n                if (dp[withhim] > dp[done] + 1) {\n                    dp[withhim] = dp[done] + 1;\n                    parent[withhim] = done;\n                }\n            }\n        }\n        \n        int[] ans = new int[dp[(1 << num_skills) - 1]];\n        int cur = (1 << num_skills) - 1;\n        int t = dp[(1 << num_skills) - 1] - 1;\n        \n        for (int i = people.size() - 1; i >= 0; i--) {\n            int old = parent[cur];\n            int diff = cur ^ old;\n            boolean isEssential = (sks.get(i) & diff) > 0;\n            if (isEssential) {\n                ans[t] = i;\n                t--;\n            }\n            cur = old;\n        }\n        return ans;\n    }\n}\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n    skill_to_int = {s: i for i, s in enumerate(req_skills)}\n    people_skills = [sum(1 << skill_to_int[skill] for skill in person) for person in people]\n        \n    n = len(req_skills)\n    INF = 64\n    dp = [INF] * (1 << n)\n    dp[0] = 0\n    parent = [None] * (1 << n)\n        \n    for i, person_skills in enumerate(people_skills):\n        for completed_skills in range((1 << n) - 1, -1, -1):\n            with_person_skills = completed_skills | person_skills\n            if dp[with_person_skills] > dp[completed_skills] + 1:\n                dp[with_person_skills] = dp[completed_skills] + 1\n                parent[with_person_skills] = completed_skills\n                \n    ans = [0] * dp[-1]\n    cur = (1 << n) - 1\n    t = dp[-1] - 1\n        \n    for i in range(len(people) - 1, -1, -1):\n        old = parent[cur]\n        diff = cur ^ old\n        is_essential = (people_skills[i] & diff) > 0\n        if is_essential:\n            ans[t] = i\n            t -= 1\n        cur = old\n    return ans\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nvector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n    int n = req_skills.size(), m = people.size();\n    vector<int> skill_to_int(128, -1);\n    vector<vector<int>> people_int(m);\n    vector<int> res(n);\n    int cur_min = n + 1;\n\n    for (int i = 0; i < n; ++i) skill_to_int[req_skills[i].front()] = i;\n\n    for (int i = 0; i < m; ++i)\n        for (const string& s : people[i]) people_int[i].push_back(skill_to_int[s.front()]);\n\n    function<void(bitset<26>, int, int)> dfs = [&](bitset<26> s, int p, int count) {\n        if (count >= cur_min) return;\n        if (p == m && (s & ((1 << n) - 1)) != (1 << n) - 1) return;\n        if (p == m) {\n            cur_min = count;\n            int idx = 0;\n            for (int i = 0; i < m; ++i) if (s[26 - i - 1]) res[idx++] = i;\n            return;\n    }\n        dfs(s | (s >> people_int[p]) | (s << n << people_int[p]), p + 1, count + 1);\n        dfs(s, p + 1, count);\n    };\n\n    dfs(0, 0, 0);\n    res.resize(cur_min);\n    return res;\n}\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    ",
        "js": "\n    ```javascript\nfunction smallestSufficientTeam(req_skills, people) {\n    const skill_to_int = new Map()\n    req_skills.forEach((v, i) => skill_to_int.set(v, i))\n\n    const people_int = people.map(person =>\n        person.reduce((skills, p) => skills | 1 << skill_to_int.get(p), 0)\n    )\n\n    const n = req_skills.length\n    const INF = 64\n    const dp = Array(1 << n).fill(INF)\n    const parent = Array(1 << n).fill(0)\n\n    dp[0] = 0\n\n    for (let i = 0; i < people.length; i++) {\n        for (let skills_done = (1 << n) - 1; skills_done >= 0; skills_done--) {\n            const with_person_skills = skills_done | people_int[i]\n            if (dp[with_person_skills] > dp[skills_done] + 1) {\n                dp[with_person_skills] = dp[skills_done] + 1\n                parent[with_person_skills] = skills_done\n            }\n        }\n    }\n\n    const result = Array(dp[(1 << n) - 1])\n    let cur = (1 << n) - 1\n    let t = result.length - 1\n\n    for (let i = people.length - 1; i >= 0; i--) {\n        const old = parent[cur]\n        const diff = cur ^ old\n        const is_essential = (people_int[i] & diff) > 0\n        if (is_essential) {\n            result[t] = i\n            t -= 1\n        }\n        cur = old\n    }\n\n    return result\n}\n```\n    \n    The algorithm can be described as follows:\n\n1. Create a map of each required skill to a unique integer (0-indexed).\n2. Convert the people's skills into integers using bitwise operations, where each bit represents whether the person has a particular skill or not.\n3. Use dynamic programming to find the smallest sufficient team. For each person in the list, iterate through all possible skill subsets (done by looping from (2^n - 1) to 0, where n is the number of required skills) and calculate the skill set with the current person.\n4. If the team size with the current person is smaller than the previously known team size without the person for the same skill set, update the dynamic programming table with the new team size and store the parent state.\n5. Finally, iterate through the parent state array to reconstruct the team and return the indices of the team members.\n\nThe time complexity of the algorithm is O(people * 2^req_skills). As req_skills is guaranteed to be at most 16, the time complexity is at most O(60 * 2^16), which is enough for the constraints in the problem statement.\n    "
    },
    {
        "id": 190,
        "title": "Dice Roll Simulation",
        "difficulty": "Hard",
        "content": {
            "problem": "A die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\nGiven an array of integers `rollMax` and an integer `n`, return _the number of distinct sequences that can be obtained with exact_ `n` _rolls_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered different if at least one element differs from each other.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, rollMax = \\[1,1,2,2,2,3\\]\n**Output:** 34\n**Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 \\* 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, rollMax = \\[1,1,1,1,1,1\\]\n**Output:** 30\n\n",
                "**Example 3:**\n\n**Input:** n = 3, rollMax = \\[1,1,1,2,2,3\\]\n**Output:** 181"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `rollMax.length == 6`\n*   `1 <= rollMax[i] <= 15`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "2,[1,1,2,2,2,3]",
                "output": "34"
            },
            {
                "input": "2,[1,1,1,1,1,1]",
                "output": "30"
            },
            {
                "input": "3,[1,1,1,2,2,3]",
                "output": "181"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.function.Function;\nimport java.util.function.BiConsumer;\n\npublic boolean[] areConnected(int n, int threshold, int[][] queries) {\n    boolean[] answer = new boolean[queries.length];\n    int[] parent = new int[n + 1];\n    int[] rank = new int[n + 1];\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    Function<Integer, Integer> find = x -> {\n        if (parent[x] != x)\n            parent[x] = find.apply(parent[x]);\n        return parent[x];\n    };\n\n    BiConsumer<Integer, Integer> unite = (x, y) -> {\n        int rootx = find.apply(x);\n        int rooty = find.apply(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                int temp = rootx;\n                rootx = rooty;\n                rooty = temp;\n            }\n            parent[rootx] = rooty;\n            if (rank[rootx] == rank[rooty])\n                rank[rooty]++;\n        }\n    };\n\n    for (int i = threshold + 1; i <= n; i++) {\n        for (int j = 2 * i; j <= n; j += i) {\n            unite.accept(i, j);\n        }\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n        answer[i] = find.apply(queries[i][0]) == find.apply(queries[i][1]);\n    }\n\n    return answer;\n}\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    ",
        "python": "\n    ```python\ndef areConnected(n, threshold, queries):\n    answer = [False] * len(queries)\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def unite(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                rootx, rooty = rooty, rootx\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n    for i in range(threshold + 1, n + 1):\n        for j in range(i * 2, n + 1, i):\n            unite(i, j)\n\n    for i, query in enumerate(queries):\n        answer[i] = find(query[0]) == find(query[1])\n\n    return answer\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) {\n    vector<bool> answer(queries.size());\n    vector<int> parent(n + 1), rank(n + 1, 0);\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        int rootx = find(x);\n        int rooty = find(y);\n        if (rootx != rooty) {\n            if (rank[rootx] > rank[rooty])\n                swap(rootx, rooty);\n            parent[rootx] = rooty;\n            if (rank[rootx] == rank[rooty])\n                rank[rooty]++;\n        }\n    };\n\n    for (int i = threshold + 1; i <= n; ++i)\n        for (int j = 2 * i; j <= n; j += i)\n            unite(i, j);\n\n    for (int i = 0; i < queries.size(); ++i)\n        answer[i] = find(queries[i][0]) == find(queries[i][1]);\n\n    return answer;\n}\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    ",
        "js": "\n    ```javascript\nfunction areConnected(n, threshold, queries) {\n    const answer = new Array(queries.length).fill(false);\n    const parent = Array.from({ length: n + 1 }, (v, i) => i);\n    const rank = new Array(n + 1).fill(0);\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function unite(x, y) {\n        let rootx = find(x);\n        let rooty = find(y);\n        if (rootx !== rooty) {\n            if (rank[rootx] > rank[rooty]) {\n                [rootx, rooty] = [rooty, rootx];\n            }\n            parent[rootx] = rooty;\n            if (rank[rootx] === rank[rooty]) {\n                rank[rooty]++;\n            }\n        }\n    }\n\n    for (let i = threshold + 1; i <= n; i++) {\n        for (let j = 2 * i; j <= n; j += i) {\n            unite(i, j);\n        }\n    }\n\n    for (let i = 0; i < queries.length; i++) {\n        answer[i] = find(queries[i][0]) === find(queries[i][1]);\n    }\n\n    return answer;\n}\n```\n    \n    We can treat each city as a node, and if city x and y are connected, we can add an edge between them. To solve this problem, we can use the disjoint set data structure (union-find). First, we initialize the data structure with n sets, each containing one element (city).\nNext, we use a nested loop to iterate over all possible pairs of cities (i and j), and if i and j share a common divisor greater than the threshold, we connect them in the data structure. Note that we start the inner loop at 2 * i since we don't need to consider divisors less than i. After finding and connecting all cities that share a common divisor and satisfy the condition, we can then iterate through the queries and check if the cities in the query are connected using the find function. If they are connected, we return true, otherwise false for the corresponding query.\n    "
    },
    {
        "id": 191,
        "title": "Maximum Equal Frequency",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array `nums` of positive integers, return the longest possible length of an array prefix of `nums`, such that it is possible to remove **exactly one** element from this prefix so that every number that has appeared in it will have the same number of occurrences.\n\nIf after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,2,1,1,5,3,3,5\\]\n**Output:** 7\n**Explanation:** For the subarray \\[2,2,1,1,5,3,3\\] of length 7, if we remove nums\\[4\\] = 5, we will get \\[2,2,1,1,3,3\\], so that each number will appear exactly twice.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,2,2,2,3,3,3,4,4,4,5\\]\n**Output:** 13"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table"
        ],
        "example": [
            {
                "input": "[2,2,1,1,5,3,3,5]",
                "output": "7"
            },
            {
                "input": "[1,1,1,2,2,2,3,3,3,4,4,4,5]",
                "output": "13"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\nclass Solution {\n    public int minFallingPathSum(int[][] grid) {\n        int n = grid.length;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int minVal = Integer.MAX_VALUE;\n                for (int k = 0; k < n; k++) {\n                    if (k == j) continue;\n                    minVal = Math.min(minVal, grid[i - 1][k]);\n                }\n                grid[i][j] += minVal;\n            }\n        }\n        return Arrays.stream(grid[n - 1]).min().getAsInt();\n    }\n}\n```\n    \n    The algorithm involves iterating through the grid and computing the minimum sum for each element, considering only the adjacent elements in the previous row that have non-zero shifts (elements with different column indices than the current element). \n\nWe first iterate through the rows of grid (starting at row 1, because the base case is row 0). Then, we iterate through the columns in each row, calculating the minimum sum value for each element at grid[i][j] by iterating through all the elements in the previous row (grid[i - 1][k]) and choosing the element with the minimum sum that isn't in the same column (k != j). We then add the calculated minimum sum value to the current element grid[i][j] to update it. \n\nAfter traversal of the whole grid, we return the minimum value in the last row of grid, as this value now represents the minimum sum of the falling path with non-zero shifts.\n\nThe time complexity of this algorithm is O(n^3), where n is the dimension of the grid, since we are using three nested loops to iterate through the elements of the grid. The space complexity is O(1), since we are not using any additional data structures.\n    ",
        "python": "\n    ```python\ndef minFallingPathSum(grid):\n    n = len(grid)\n    for i in range(1, n):\n        for j in range(n):\n            minVal = float('inf')\n            for k in range(n):\n                if k == j:\n                    continue\n                minVal = min(minVal, grid[i - 1][k])\n            grid[i][j] += minVal\n    return min(grid[n - 1])\n```\n    \n    The algorithm involves iterating through the grid and computing the minimum sum for each element, considering only the adjacent elements in the previous row that have non-zero shifts (elements with different column indices than the current element). \n\nWe first iterate through the rows of grid (starting at row 1, because the base case is row 0). Then, we iterate through the columns in each row, calculating the minimum sum value for each element at grid[i][j] by iterating through all the elements in the previous row (grid[i - 1][k]) and choosing the element with the minimum sum that isn't in the same column (k != j). We then add the calculated minimum sum value to the current element grid[i][j] to update it. \n\nAfter traversal of the whole grid, we return the minimum value in the last row of grid, as this value now represents the minimum sum of the falling path with non-zero shifts.\n\nThe time complexity of this algorithm is O(n^3), where n is the dimension of the grid, since we are using three nested loops to iterate through the elements of the grid. The space complexity is O(1), since we are not using any additional data structures.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint minFallingPathSum(vector<vector<int>>& grid) {\n    int n = grid.size();\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int minVal = INT_MAX;\n            for (int k = 0; k < n; ++k) {\n                if (k == j) continue;\n                minVal = min(minVal, grid[i - 1][k]);\n            }\n            grid[i][j] += minVal;\n        }\n    }\n    return *min_element(grid[n-1].begin(), grid[n-1].end());\n}\n```\n    \n    The algorithm involves iterating through the grid and computing the minimum sum for each element, considering only the adjacent elements in the previous row that have non-zero shifts (elements with different column indices than the current element). \n\nWe first iterate through the rows of grid (starting at row 1, because the base case is row 0). Then, we iterate through the columns in each row, calculating the minimum sum value for each element at grid[i][j] by iterating through all the elements in the previous row (grid[i - 1][k]) and choosing the element with the minimum sum that isn't in the same column (k != j). We then add the calculated minimum sum value to the current element grid[i][j] to update it. \n\nAfter traversal of the whole grid, we return the minimum value in the last row of grid, as this value now represents the minimum sum of the falling path with non-zero shifts.\n\nThe time complexity of this algorithm is O(n^3), where n is the dimension of the grid, since we are using three nested loops to iterate through the elements of the grid. The space complexity is O(1), since we are not using any additional data structures.\n    ",
        "js": "\n    ```javascript\nfunction minFallingPathSum(grid) {\n    const n = grid.length;\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            let minVal = Infinity;\n            for (let k = 0; k < n; k++) {\n                if (k === j) continue;\n                minVal = Math.min(minVal, grid[i - 1][k]);\n            }\n            grid[i][j] += minVal;\n        }\n    }\n    return Math.min(...grid[n - 1]);\n}\n```\n    \n    The algorithm involves iterating through the grid and computing the minimum sum for each element, considering only the adjacent elements in the previous row that have non-zero shifts (elements with different column indices than the current element). \n\nWe first iterate through the rows of grid (starting at row 1, because the base case is row 0). Then, we iterate through the columns in each row, calculating the minimum sum value for each element at grid[i][j] by iterating through all the elements in the previous row (grid[i - 1][k]) and choosing the element with the minimum sum that isn't in the same column (k != j). We then add the calculated minimum sum value to the current element grid[i][j] to update it. \n\nAfter traversal of the whole grid, we return the minimum value in the last row of grid, as this value now represents the minimum sum of the falling path with non-zero shifts.\n\nThe time complexity of this algorithm is O(n^3), where n is the dimension of the grid, since we are using three nested loops to iterate through the elements of the grid. The space complexity is O(1), since we are not using any additional data structures.\n    "
    },
    {
        "id": 192,
        "title": "Maximum Profit in Job Scheduling",
        "difficulty": "Hard",
        "content": {
            "problem": "We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.",
            "examples": [
                "**Example 1:**\n\n**Input:** startTime = \\[1,2,3,3\\], endTime = \\[3,4,5,6\\], profit = \\[50,10,40,70\\]\n**Output:** 120\n**Explanation:** The subset chosen is the first and fourth job. \nTime range \\[1-3\\]+\\[3-6\\] , we get profit of 120 = 50 + 70.\n\n",
                "**Example 2:**\n\n**Input:** startTime = \\[1,2,3,4,6\\], endTime = \\[3,5,10,6,9\\], profit = \\[20,20,100,70,60\\]\n**Output:** 150\n**Explanation:** The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n",
                "**Example 3:**\n\n**Input:** startTime = \\[1,1,1\\], endTime = \\[2,3,4\\], profit = \\[5,6,4\\]\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n*   `1 <= startTime[i] < endTime[i] <= 109`\n*   `1 <= profit[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,2,3,3],[3,4,5,6],[50,10,40,70]",
                "output": "120"
            },
            {
                "input": "[1,2,3,4,6],[3,5,10,6,9],[20,20,100,70,60]",
                "output": "150"
            },
            {
                "input": "[1,1,1],[2,3,4],[5,6,4]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n    int n = startTime.length;\n    int[][] jobs = new int[n][3];\n\n    for (int i = 0; i < n; i++) {\n        jobs[i] = new int[] {endTime[i], startTime[i], profit[i]};\n    }\n\n    Arrays.sort(jobs, (a, b) -> a[0] - b[0]);\n    int[] dp = new int[n];\n    dp[0] = jobs[0][2];\n\n    for (int i = 1; i < n; i++) {\n        int L = -1;\n        for (int j = i - 1; j >= 0; j--) {\n            if (jobs[j][1] >= jobs[L == -1 ? i : L][0]) {\n                L = j;\n            }\n        }\n        dp[i] = Math.max(dp[i - 1], (L == -1 ? 0 : dp[L]) + jobs[i][2]);\n    }\n\n    return dp[n - 1];\n}\n```\n    \n    1. Create an array of jobs containing tuples (endTime, startTime, profit)\n2. Sort the jobs in increasing order of their end times\n3. Initialize a dynamic programming array, `dp`. Set `dp[0]` to the profit of the first job in the sorted jobs array\n4. Iterate over the sorted jobs array, and for each job, find the index `L` of the latest non-conflicting job in the array (i.e., a job whose end time is less than or equal to the start time of the current job)\n5. Update `dp[i]` to the maximum of the profit of the previous job `dp[i - 1]`, and the sum of the profit of the current job and the profit of the latest non-conflicting job `(0 if L == -1 else dp[L]) + jobs[i][2]`\n6. Return the last element of the `dp` array, which represents the maximum profit that can be obtained considering all non-overlapping scheduled jobs\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]\n```\n    \n    1. Create an array of jobs containing tuples (endTime, startTime, profit)\n2. Sort the jobs in increasing order of their end times\n3. Initialize a dynamic programming array, `dp`. Set `dp[0]` to the profit of the first job in the sorted jobs array\n4. Iterate over the sorted jobs array, and for each job, find the index `L` of the latest non-conflicting job in the array (i.e., a job whose end time is less than or equal to the start time of the current job)\n5. Update `dp[i]` to the maximum of the profit of the previous job `dp[i - 1]`, and the sum of the profit of the current job and the profit of the latest non-conflicting job `(0 if L == -1 else dp[L]) + jobs[i][2]`\n6. Return the last element of the `dp` array, which represents the maximum profit that can be obtained considering all non-overlapping scheduled jobs\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint jobScheduling(std::vector<int>& startTime, std::vector<int>& endTime, std::vector<int>& profit) {\n    int n = startTime.size();\n    std::vector<std::tuple<int, int, int>> jobs(n);\n    \n    for (int i = 0; i < n; ++i) {\n        jobs[i] = {endTime[i], startTime[i], profit[i]};\n    }\n    \n    std::sort(jobs.begin(), jobs.end());\n\n    std::vector<int> dp(n);\n    dp[0] = std::get<2>(jobs[0]);\n\n    for (int i = 1; i < n; ++i) {\n        int L = -1;\n        for (int j = i - 1; j >= 0; --j) {\n            if (std::get<1>(jobs[j]) >= std::get<0>(jobs[L == -1 ? i : L])) {\n                L = j;\n            }\n        }\n        dp[i] = std::max(dp[i - 1], (L == -1 ? 0 : dp[L]) + std::get<2>(jobs[i]));\n    }\n\n    return dp[n - 1];\n}\n```\n    \n    1. Create an array of jobs containing tuples (endTime, startTime, profit)\n2. Sort the jobs in increasing order of their end times\n3. Initialize a dynamic programming array, `dp`. Set `dp[0]` to the profit of the first job in the sorted jobs array\n4. Iterate over the sorted jobs array, and for each job, find the index `L` of the latest non-conflicting job in the array (i.e., a job whose end time is less than or equal to the start time of the current job)\n5. Update `dp[i]` to the maximum of the profit of the previous job `dp[i - 1]`, and the sum of the profit of the current job and the profit of the latest non-conflicting job `(0 if L == -1 else dp[L]) + jobs[i][2]`\n6. Return the last element of the `dp` array, which represents the maximum profit that can be obtained considering all non-overlapping scheduled jobs\n    ",
        "js": "\n    ```javascript\nfunction jobScheduling(startTime, endTime, profit) {\n    const n = startTime.length;\n    const jobs = [];\n\n    for (let i = 0; i < n; i++) {\n        jobs.push([endTime[i], startTime[i], profit[i]]);\n    }\n\n    jobs.sort((a, b) => a[0] - b[0]);\n    const dp = new Array(n);\n    dp[0] = jobs[0][2];\n\n    for (let i = 1; i < n; i++) {\n        let L = -1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (jobs[j][1] >= jobs[L === -1 ? i : L][0]) {\n                L = j;\n            }\n        }\n        dp[i] = Math.max(dp[i - 1], (L === -1 ? 0 : dp[L]) + jobs[i][2]);\n    }\n\n    return dp[n - 1];\n}\n```\n    \n    1. Create an array of jobs containing tuples (endTime, startTime, profit)\n2. Sort the jobs in increasing order of their end times\n3. Initialize a dynamic programming array, `dp`. Set `dp[0]` to the profit of the first job in the sorted jobs array\n4. Iterate over the sorted jobs array, and for each job, find the index `L` of the latest non-conflicting job in the array (i.e., a job whose end time is less than or equal to the start time of the current job)\n5. Update `dp[i]` to the maximum of the profit of the previous job `dp[i - 1]`, and the sum of the profit of the current job and the profit of the latest non-conflicting job `(0 if L == -1 else dp[L]) + jobs[i][2]`\n6. Return the last element of the `dp` array, which represents the maximum profit that can be obtained considering all non-overlapping scheduled jobs\n    "
    },
    {
        "id": 193,
        "title": "Tiling a Rectangle with the Fewest Squares",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a rectangle of size `n` x `m`, return _the minimum number of integer-sided squares that tile the rectangle_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, m = 3\n**Output:** 3\n**Explanation:** `3` squares are necessary to cover the rectangle.\n`2` (squares of `1x1`)\n`1` (square of `2x2`)\n\n",
                "**Example 2:**\n\n**Input:** n = 5, m = 8\n**Output:** 5\n\n",
                "**Example 3:**\n\n**Input:** n = 11, m = 13\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n, m <= 13`",
            "follow_up": null
        },
        "tag": [
            "Backtracking"
        ],
        "example": [
            {
                "input": "2,3",
                "output": "3"
            },
            {
                "input": "5,8",
                "output": "5"
            },
            {
                "input": "11,13",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int stoneGameII(int[] piles) {\n    int n = piles.length;\n    int[][] memo = new int[n][n + 1];\n    \n    for (int i = n - 2 ; i >= 0; --i) {\n        piles[i] += piles[i + 1];\n    }\n\n    return search(piles, 0, 1, memo);\n}\n\nprivate int search(int[] piles, int idx, int M, int[][] memo) {\n    int n = piles.length;\n    \n    if (idx + 2 * M >= n) {\n        return piles[idx];\n    }\n    \n    if (memo[idx][M] > 0) {\n        return memo[idx][M];\n    }\n    \n    memo[idx][M] = 0;\n    \n    for (int x = 1; x <= 2 * M; ++x) {\n        memo[idx][M] = Math.max(memo[idx][M], piles[idx] - search(piles, idx + x, Math.max(M, x), memo));\n    }\n    \n    return memo[idx][M];\n}\n```\n    \n    The algorithm uses dynamic programming with memoization. It first calculates the total number of remaining stones starting from each pile. This can be done in O(n) time complexity. Then, it checks the memoization table for previously computed values.\n\nThe main search function goes through all possible values of X (1 <= X <= 2M) while recursively maximizing the stones difference. After all the positions are checked, it returns the maximum value found. This way, the algorithm guarantees that Alice will choose the optimal move to get the maximum number of stones possible.\n\nThe time complexity is O(n^2*M) where n is the number of piles and M is the maximum limit of piles that can be picked.\n    ",
        "python": "\n    ```python\nfrom functools import lru_cache\n\ndef stoneGameII(piles):\n    n = len(piles)\n    for i in range(n - 2, -1, -1):\n        piles[i] += piles[i + 1]\n\n    @lru_cache(None)\n    def search(idx, M):\n        if idx + 2 * M >= n:\n            return piles[idx]\n        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2 * M + 1))\n\n    return search(0, 1)\n```\n    \n    The algorithm uses dynamic programming with memoization. It first calculates the total number of remaining stones starting from each pile. This can be done in O(n) time complexity. Then, it checks the memoization table for previously computed values.\n\nThe main search function goes through all possible values of X (1 <= X <= 2M) while recursively maximizing the stones difference. After all the positions are checked, it returns the maximum value found. This way, the algorithm guarantees that Alice will choose the optimal move to get the maximum number of stones possible.\n\nThe time complexity is O(n^2*M) where n is the number of piles and M is the maximum limit of piles that can be picked.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint stoneGameII(std::vector<int>& piles) {\n    int n = piles.size();\n    std::vector<std::vector<int>> memo(n, std::vector<int>(n + 1, 0));\n    \n    for (int i = n - 2; i >= 0; --i) {\n        piles[i] += piles[i + 1];\n    }\n\n    function<int(int, int)> search = [&](int idx, int M) {\n        if (idx + 2 * M >= n) {\n            return piles[idx];\n        }\n        if (memo[idx][M] > 0) {\n            return memo[idx][M];\n        }\n        memo[idx][M] = 0;\n        for (int x = 1; x <= 2 * M; ++x) {\n            memo[idx][M] = std::max(memo[idx][M], piles[idx] - search(idx + x, std::max(M, x)));\n        }\n        return memo[idx][M];\n    };\n    \n    return search(0, 1);\n}\n```\n    \n    The algorithm uses dynamic programming with memoization. It first calculates the total number of remaining stones starting from each pile. This can be done in O(n) time complexity. Then, it checks the memoization table for previously computed values.\n\nThe main search function goes through all possible values of X (1 <= X <= 2M) while recursively maximizing the stones difference. After all the positions are checked, it returns the maximum value found. This way, the algorithm guarantees that Alice will choose the optimal move to get the maximum number of stones possible.\n\nThe time complexity is O(n^2*M) where n is the number of piles and M is the maximum limit of piles that can be picked.\n    ",
        "js": "\n    ```javascript\nfunction stoneGameII(piles) {\n    let n = piles.length;\n    let memo = new Array(n).fill(0).map(() => new Array(n + 1).fill(0));\n    \n    for (let i = n - 2 ; i >= 0; --i) {\n        piles[i] += piles[i + 1];\n    }\n\n    function search(idx, M) {\n        if (idx + 2 * M >= n) {\n            return piles[idx];\n        }\n        \n        if (memo[idx][M] > 0) {\n            return memo[idx][M];\n        }\n        \n        memo[idx][M] = 0;\n        \n        for (let x = 1; x <= 2 * M; ++x) {\n            memo[idx][M] = Math.max(memo[idx][M], piles[idx] - search(idx + x, Math.max(M, x)));\n        }\n        \n        return memo[idx][M];\n    }\n    \n    return search(0, 1);\n}\n```\n    \n    The algorithm uses dynamic programming with memoization. It first calculates the total number of remaining stones starting from each pile. This can be done in O(n) time complexity. Then, it checks the memoization table for previously computed values.\n\nThe main search function goes through all possible values of X (1 <= X <= 2M) while recursively maximizing the stones difference. After all the positions are checked, it returns the maximum value found. This way, the algorithm guarantees that Alice will choose the optimal move to get the maximum number of stones possible.\n\nThe time complexity is O(n^2*M) where n is the number of piles and M is the maximum limit of piles that can be picked.\n    "
    },
    {
        "id": 194,
        "title": "Check If It Is a Good Array",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array `nums` of positive integers. Your task is to select some subset of `nums`, multiply each element by an integer and add all these numbers. The array is said to be **good** if you can obtain a sum of `1` from the array by any possible subset and multiplicand.\n\nReturn `True` if the array is **good** otherwise return `False`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[12,5,7,23\\]\n**Output:** true\n**Explanation:** Pick numbers 5 and 7.\n5\\*3 + 7\\*(-2) = 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[29,6,10\\]\n**Output:** true\n**Explanation:** Pick numbers 29, 6 and 10.\n29\\*1 + 6\\*(-3) + 10\\*(-1) = 1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,6\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 10^5`\n*   `1 <= nums[i] <= 10^9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[12,5,7,23]",
                "output": "true"
            },
            {
                "input": "[29,6,10]",
                "output": "true"
            },
            {
                "input": "[3,6]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public boolean isGoodArray(int[] nums) {\n        int res = nums[0];\n        for (int num : nums) {\n            res = gcd(res, num);\n        }\n        return res == 1;\n    }\n    \n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n```\n    \n    The problem can be solved using the mathematical concept of Bézout's identity, which states that the greates common divisor (GCD) of two integers `a` and `b` can be represented in the form `ax + by = gcd(a, b)`. The array is said to be good if there exists a combination of elements which can be multiplied by an integer and added together to result in 1.\n\nThe solution involves iterating through the input array and finding the GCD of all the numbers. To find the GCD, we use the Euclidean algorithm. If the GCD is 1, then there exists a subset and multiplicand that satisfies the given condition, and the function returns true. Otherwise, the function returns false.\n    ",
        "python": "\n    ```python\nfrom math import gcd\nfrom functools import reduce\n\ndef isGoodArray(nums):\n    return reduce(gcd, nums) == 1\n```\n    \n    The problem can be solved using the mathematical concept of Bézout's identity, which states that the greates common divisor (GCD) of two integers `a` and `b` can be represented in the form `ax + by = gcd(a, b)`. The array is said to be good if there exists a combination of elements which can be multiplied by an integer and added together to result in 1.\n\nThe solution involves iterating through the input array and finding the GCD of all the numbers. To find the GCD, we use the Euclidean algorithm. If the GCD is 1, then there exists a subset and multiplicand that satisfies the given condition, and the function returns true. Otherwise, the function returns false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nbool isGoodArray(vector<int>& nums) {\n    int res = nums[0];\n    for (int num : nums) {\n        res = gcd(res, num);\n    }\n    return res == 1;\n}\n```\n    \n    The problem can be solved using the mathematical concept of Bézout's identity, which states that the greates common divisor (GCD) of two integers `a` and `b` can be represented in the form `ax + by = gcd(a, b)`. The array is said to be good if there exists a combination of elements which can be multiplied by an integer and added together to result in 1.\n\nThe solution involves iterating through the input array and finding the GCD of all the numbers. To find the GCD, we use the Euclidean algorithm. If the GCD is 1, then there exists a subset and multiplicand that satisfies the given condition, and the function returns true. Otherwise, the function returns false.\n    ",
        "js": "\n    ```javascript\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n\nfunction isGoodArray(nums) {\n    let res = nums[0];\n    for (let num of nums) {\n        res = gcd(res, num);\n    }\n    return res === 1;\n}\n```\n    \n    The problem can be solved using the mathematical concept of Bézout's identity, which states that the greates common divisor (GCD) of two integers `a` and `b` can be represented in the form `ax + by = gcd(a, b)`. The array is said to be good if there exists a combination of elements which can be multiplied by an integer and added together to result in 1.\n\nThe solution involves iterating through the input array and finding the GCD of all the numbers. To find the GCD, we use the Euclidean algorithm. If the GCD is 1, then there exists a subset and multiplicand that satisfies the given condition, and the function returns true. Otherwise, the function returns false.\n    "
    },
    {
        "id": 195,
        "title": "Maximum Score Words Formed by Letters",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a list of `words`, list of single `letters` (might be repeating) and `score` of every character.\n\nReturn the maximum score of **any** valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).\n\nIt is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"dog \", \"cat \", \"dad \", \"good \"\\], letters = \\[ \"a \", \"a \", \"c \", \"d \", \"d \", \"d \", \"g \", \"o \", \"o \"\\], score = \\[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0\\]\n**Output:** 23\n**Explanation:**\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words  \"dad \" (5+1+5) and  \"good \" (3+2+2+5) with a score of 23.\nWords  \"dad \" and  \"dog \" only get a score of 21.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"xxxz \", \"ax \", \"bx \", \"cx \"\\], letters = \\[ \"z \", \"a \", \"b \", \"c \", \"x \", \"x \", \"x \"\\], score = \\[4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10\\]\n**Output:** 27\n**Explanation:**\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words  \"ax \" (4+5),  \"bx \" (4+5) and  \"cx \" (4+5) with a score of 27.\nWord  \"xxxz \" only get a score of 25.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"leetcode \"\\], letters = \\[ \"l \", \"e \", \"t \", \"c \", \"o \", \"d \"\\], score = \\[0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0\\]\n**Output:** 0\n**Explanation:**\nLetter  \"e \" can only be used once."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 14`\n*   `1 <= words[i].length <= 15`\n*   `1 <= letters.length <= 100`\n*   `letters[i].length == 1`\n*   `score.length == 26`\n*   `0 <= score[i] <= 10`\n*   `words[i]`, `letters[i]` contains only lower case English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[\"dog\",\"cat\",\"dad\",\"good\"],[\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"],[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]",
                "output": "23"
            },
            {
                "input": "[\"xxxz\",\"ax\",\"bx\",\"cx\"],[\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"],[4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]",
                "output": "27"
            },
            {
                "input": "[\"leetcode\"],[\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"],[0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxValueAfterReverse(int[] nums) {\n    int total = 0, diff = 0;\n    int min2 = Integer.MAX_VALUE, max2 = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.length - 1; ++i) {\n        total += Math.abs(nums[i] - nums[i + 1]);\n        min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));\n        max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));\n        diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));\n        diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));\n    }\n    return total + Math.max(diff, 2 * (max2 - min2));\n}\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    ",
        "python": "\n    ```python\ndef maxValueAfterReverse(nums):\n    total, diff = 0, 0\n    min2, max2 = float('inf'), float('-inf')\n    for i in range(len(nums) - 1):\n        total += abs(nums[i] - nums[i + 1])\n        min2 = min(min2, max(nums[i], nums[i + 1]))\n        max2 = max(max2, min(nums[i], nums[i + 1]))\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))\n        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))\n    return total + max(diff, 2 * (max2 - min2))\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    ",
        "c++": "\n    ```cpp\nint maxValueAfterReverse(vector<int>& nums) {\n    int total = 0, diff = 0;\n    int min2 = INT_MAX, max2 = INT_MIN;\n    for (int i = 0; i < nums.size() - 1; ++i) {\n        total += abs(nums[i] - nums[i + 1]);\n        min2 = min(min2, max(nums[i], nums[i + 1]));\n        max2 = max(max2, min(nums[i], nums[i + 1]));\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]));\n        diff = max(diff, abs(nums[i] - nums[nums.size() - 1]) - abs(nums[i] - nums[i + 1]));\n    }\n    return total + max(diff, 2 * (max2 - min2));\n}\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    ",
        "js": "\n    ```javascript\nfunction maxValueAfterReverse(nums) {\n    let total = 0, diff = 0;\n    let min2 = Infinity, max2 = -Infinity;\n    for (let i = 0; i < nums.length - 1; ++i) {\n        total += Math.abs(nums[i] - nums[i + 1]);\n        min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));\n        max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));\n        diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));\n        diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));\n    }\n    return total + Math.max(diff, 2 * (max2 - min2));\n}\n```\n    \n    1. Initialize the required variables for total sum, difference, and minimum and maximum values for further calculations.\n2. Iterate through the given array from index 0 to nums.length - 2.\n3. Calculate the total sum by adding the absolute difference between nums[i] and nums[i+1].\n4. Update the min2 and max2 with the required calculations.\n5. Find the maximum possible difference by considering swapping a subarray (0...i+1) or (i...nums.length-1).\n6. Return the sum of the total and the maximum value of the calculated difference and 2 times (max2 - min2).\n    "
    },
    {
        "id": 196,
        "title": "Minimum Moves to Move a Box to Their Target Location",
        "difficulty": "Hard",
        "content": {
            "problem": "A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\n\nThe game is represented by an `m x n` grid of characters `grid` where each element is a wall, floor, or box.\n\nYour task is to move the box `'B'` to the target position `'T'` under the following rules:\n\n*   The character `'S'` represents the player. The player can move up, down, left, right in `grid` if it is a floor (empty cell).\n*   The character `'.'` represents the floor which means a free cell to walk.\n*   The character `'#'` represents the wall which means an obstacle (impossible to walk there).\n*   There is only one box `'B'` and one target cell `'T'` in the `grid`.\n*   The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a **push**.\n*   The player cannot walk through the box.\n\nReturn _the minimum number of **pushes** to move the box to the target_. If there is no way to reach the target, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[ \"# \", \"# \", \"# \", \"# \", \"# \", \"# \"\\],\n               \\[ \"# \", \"T \", \"# \", \"# \", \"# \", \"# \"\\],\n               \\[ \"# \", \". \", \". \", \"B \", \". \", \"# \"\\],\n               \\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\],\n               \\[ \"# \", \". \", \". \", \". \", \"S \", \"# \"\\],\n               \\[ \"# \", \"# \", \"# \", \"# \", \"# \", \"# \"\\]\\]\n**Output:** 3\n**Explanation:** We return only the number of times the box is pushed.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[ \"# \", \"# \", \"# \", \"# \", \"# \", \"# \"\\],\n               \\[ \"# \", \"T \", \"# \", \"# \", \"# \", \"# \"\\],\n               \\[ \"# \", \". \", \". \", \"B \", \". \", \"# \"\\],\n               \\[ \"# \", \"# \", \"# \", \"# \", \". \", \"# \"\\],\n               \\[ \"# \", \". \", \". \", \". \", \"S \", \"# \"\\],\n               \\[ \"# \", \"# \", \"# \", \"# \", \"# \", \"# \"\\]\\]\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[ \"# \", \"# \", \"# \", \"# \", \"# \", \"# \"\\],\n               \\[ \"# \", \"T \", \". \", \". \", \"# \", \"# \"\\],\n               \\[ \"# \", \". \", \"# \", \"B \", \". \", \"# \"\\],\n               \\[ \"# \", \". \", \". \", \". \", \". \", \"# \"\\],\n               \\[ \"# \", \". \", \". \", \". \", \"S \", \"# \"\\],\n               \\[ \"# \", \"# \", \"# \", \"# \", \"# \", \"# \"\\]\\]\n**Output:** 5\n**Explanation:** push the box down, left, left, up and up."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 20`\n*   `grid` contains only characters `'.'`, `'#'`, `'S'`, `'T'`, or `'B'`.\n*   There is only one character `'S'`, `'B'`, and `'T'` in the `grid`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n[\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n[\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n[\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]",
                "output": "3"
            },
            {
                "input": "[[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n[\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n[\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n[\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n[\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]",
                "output": "-1"
            },
            {
                "input": "[[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n[\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n[\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n[\"#\",\".\",\".\",\".\",\".\",\"#\"],\n[\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int numRollsToTarget(int n, int k, int target) {\n    final int MOD = 1000000007;\n    int[][] dp = new int[n+1][target+1];\n    dp[0][0] = 1;\n    \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= target; ++j) {\n            for (int l = 1; l <= k; ++l) {\n                if (j >= l) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;\n                }\n            }\n        }\n    }\n    return dp[n][target];\n}\n```\n    \n    The algorithm uses dynamic programming to find the number of ways to attain the target sum with given `n` dice and `k` faces. We create a 2-D array `dp` where `dp[i][j]` represents the number of ways to reach a sum of `j` using `i` dice.\n\nWe initialize `dp[0][0] = 1` since there's only one way to get a sum of zero using zero dice (by rolling no dice). We iterate through `i` from 1 to `n`, `j` from 1 to `target`, and `l` from 1 to `k`. If the current sum `j` is greater than or equal to the current face value `l`, we update the value in `dp[i][j]` as `(dp[i][j] + dp[i - 1][j - l]) % MOD`.\n\nFinally, we return `dp[n][target]` which gives the number of ways to attain the target sum with given `n` dice and `k` faces.\n    ",
        "python": "\n    ```python\ndef numRollsToTarget(n, k, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            for l in range(1, k + 1):\n                if j >= l:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n    return dp[n][target]\n```\n    \n    The algorithm uses dynamic programming to find the number of ways to attain the target sum with given `n` dice and `k` faces. We create a 2-D array `dp` where `dp[i][j]` represents the number of ways to reach a sum of `j` using `i` dice.\n\nWe initialize `dp[0][0] = 1` since there's only one way to get a sum of zero using zero dice (by rolling no dice). We iterate through `i` from 1 to `n`, `j` from 1 to `target`, and `l` from 1 to `k`. If the current sum `j` is greater than or equal to the current face value `l`, we update the value in `dp[i][j]` as `(dp[i][j] + dp[i - 1][j - l]) % MOD`.\n\nFinally, we return `dp[n][target]` which gives the number of ways to attain the target sum with given `n` dice and `k` faces.\n    ",
        "c++": "\n    ```cpp\nint numRollsToTarget(int n, int k, int target) {\n    const int MOD = 1e9 + 7;\n    vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\n    dp[0][0] = 1;\n    \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= target; ++j) {\n            for (int l = 1; l <= k; ++l) {\n                if (j >= l) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;\n                }\n            }\n        }\n    }\n    return dp[n][target];\n}\n```\n    \n    The algorithm uses dynamic programming to find the number of ways to attain the target sum with given `n` dice and `k` faces. We create a 2-D array `dp` where `dp[i][j]` represents the number of ways to reach a sum of `j` using `i` dice.\n\nWe initialize `dp[0][0] = 1` since there's only one way to get a sum of zero using zero dice (by rolling no dice). We iterate through `i` from 1 to `n`, `j` from 1 to `target`, and `l` from 1 to `k`. If the current sum `j` is greater than or equal to the current face value `l`, we update the value in `dp[i][j]` as `(dp[i][j] + dp[i - 1][j - l]) % MOD`.\n\nFinally, we return `dp[n][target]` which gives the number of ways to attain the target sum with given `n` dice and `k` faces.\n    ",
        "js": "\n    ```javascript\nfunction numRollsToTarget(n, k, target) {\n    const MOD = 1e9 + 7;\n    let dp = Array.from({ length: n + 1 }, () => Array(target + 1).fill(0));\n    dp[0][0] = 1;\n    \n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= target; ++j) {\n            for (let l = 1; l <= k; ++l) {\n                if (j >= l) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;\n                }\n            }\n        }\n    }\n    return dp[n][target];\n}\n```\n    \n    The algorithm uses dynamic programming to find the number of ways to attain the target sum with given `n` dice and `k` faces. We create a 2-D array `dp` where `dp[i][j]` represents the number of ways to reach a sum of `j` using `i` dice.\n\nWe initialize `dp[0][0] = 1` since there's only one way to get a sum of zero using zero dice (by rolling no dice). We iterate through `i` from 1 to `n`, `j` from 1 to `target`, and `l` from 1 to `k`. If the current sum `j` is greater than or equal to the current face value `l`, we update the value in `dp[i][j]` as `(dp[i][j] + dp[i - 1][j - l]) % MOD`.\n\nFinally, we return `dp[n][target]` which gives the number of ways to attain the target sum with given `n` dice and `k` faces.\n    "
    },
    {
        "id": 197,
        "title": "Number of Ways to Stay in the Same Place After Some Steps",
        "difficulty": "Hard",
        "content": {
            "problem": "You have a pointer at index `0` in an array of size `arrLen`. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).\n\nGiven two integers `steps` and `arrLen`, return the number of ways such that your pointer is still at index `0` after **exactly** `steps` steps. Since the answer may be too large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** steps = 3, arrLen = 2\n**Output:** 4\n**Explanation:** There are 4 differents ways to stay at index 0 after 3 steps.\nRight, Left, Stay\nStay, Right, Left\nRight, Stay, Left\nStay, Stay, Stay\n\n",
                "**Example 2:**\n\n**Input:** steps = 2, arrLen = 4\n**Output:** 2\n**Explanation:** There are 2 differents ways to stay at index 0 after 2 steps\nRight, Left\nStay, Stay\n\n",
                "**Example 3:**\n\n**Input:** steps = 4, arrLen = 2\n**Output:** 8"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= steps <= 500`\n*   `1 <= arrLen <= 106`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "3,2",
                "output": "4"
            },
            {
                "input": "2,4",
                "output": "2"
            },
            {
                "input": "4,2",
                "output": "8"
            }
        ],
        "java": "\n    ```java\nfinal int mod = 1000000007;\n\npublic int numOfWays(int steps, int arrLen) {\n  int maxPos = Math.min(steps / 2, arrLen - 1);\n  int[][] dp = new int[2][maxPos + 1];\n  dp[0][0] = 1;\n  for (int s = 1; s <= steps; ++s) {\n    for (int p = 0; p <= maxPos; ++p) {\n      dp[s % 2][p] = dp[(s - 1) % 2][p];\n      if (p > 0)\n        dp[s % 2][p] += dp[(s - 1) % 2][p - 1];\n      if (p < maxPos)\n        dp[s % 2][p] += dp[(s - 1) % 2][p + 1];\n      dp[s % 2][p] %= mod;\n    }\n  }\n  return dp[steps % 2][0];\n}\n```\n\n    \n    We use dynamic programming to solve this problem. The state of our dynamic programming is `dp[s][p]`, which represents the number of ways to be at position `p` after `s` steps.\n\nThe base case is `dp[0][0] = 1`, which means there is only one way to be at position `0` (stay there).\n\nOur transition function is as follows:\n```\ndp[s][p] = dp[s - 1][p - 1] + dp[s - 1][p] + dp[s - 1][p + 1] (% mod)\n```\nIn plain words, for every `s` steps, we can either go left, right, or stay at the current position. We iterate from `s = 1` to `steps`. We also set an upper limit on the maximum position we can consider, which is the minimum between `steps / 2` and `arrLen - 1`. This is because we have to return to position `0` after taking `steps`, and while traversing more than `steps / 2` steps, we can't reach position `0`. \n\nAt the end, we return `dp[steps % 2][0]`, which is the number of ways to be at index `0` after `steps` steps.\n    ",
        "python": "\n    ```python\nfrom functools import lru_cache\n\nmod = 10**9 + 7\n\ndef numOfWays(steps: int, arrLen: int) -> int:\n    @lru_cache(None)\n    def dp(s, p):\n        if p < 0 or p >= arrLen or p > steps - p:\n            return 0\n        if s == 0:\n            return p == 0\n        return (dp(s - 1, p - 1) + dp(s - 1, p) + dp(s - 1, p + 1)) % mod\n\n    return dp(steps, 0)\n```\n\n    \n    We use dynamic programming to solve this problem. The state of our dynamic programming is `dp[s][p]`, which represents the number of ways to be at position `p` after `s` steps.\n\nThe base case is `dp[0][0] = 1`, which means there is only one way to be at position `0` (stay there).\n\nOur transition function is as follows:\n```\ndp[s][p] = dp[s - 1][p - 1] + dp[s - 1][p] + dp[s - 1][p + 1] (% mod)\n```\nIn plain words, for every `s` steps, we can either go left, right, or stay at the current position. We iterate from `s = 1` to `steps`. We also set an upper limit on the maximum position we can consider, which is the minimum between `steps / 2` and `arrLen - 1`. This is because we have to return to position `0` after taking `steps`, and while traversing more than `steps / 2` steps, we can't reach position `0`. \n\nAt the end, we return `dp[steps % 2][0]`, which is the number of ways to be at index `0` after `steps` steps.\n    ",
        "c++": "\n    ```cpp\nconst int mod = 1e9 + 7;\n\nint numOfWays(int steps, int arrLen) {\n  int max_pos = min(steps / 2, arrLen - 1);\n  vector<vector<int>> dp(2, vector<int>(max_pos + 1));\n  dp[0][0] = 1;\n  for (int s = 1; s <= steps; ++s) {\n    for (int p = 0; p <= max_pos; ++p) {\n      dp[s % 2][p] = dp[(s - 1) % 2][p];\n      if (p > 0) {\n        dp[s % 2][p] += dp[(s - 1) % 2][p - 1];\n      }\n      if (p < max_pos) {\n        dp[s % 2][p] += dp[(s - 1) % 2][p + 1];\n      }\n      dp[s % 2][p] %= mod;\n    }\n  }\n  return dp[steps % 2][0];\n}\n```\n\n    \n    We use dynamic programming to solve this problem. The state of our dynamic programming is `dp[s][p]`, which represents the number of ways to be at position `p` after `s` steps.\n\nThe base case is `dp[0][0] = 1`, which means there is only one way to be at position `0` (stay there).\n\nOur transition function is as follows:\n```\ndp[s][p] = dp[s - 1][p - 1] + dp[s - 1][p] + dp[s - 1][p + 1] (% mod)\n```\nIn plain words, for every `s` steps, we can either go left, right, or stay at the current position. We iterate from `s = 1` to `steps`. We also set an upper limit on the maximum position we can consider, which is the minimum between `steps / 2` and `arrLen - 1`. This is because we have to return to position `0` after taking `steps`, and while traversing more than `steps / 2` steps, we can't reach position `0`. \n\nAt the end, we return `dp[steps % 2][0]`, which is the number of ways to be at index `0` after `steps` steps.\n    ",
        "js": "\n    ```javascript\nconst mod = 1e9 + 7;\n\nfunction numOfWays(steps, arrLen) {\n  const maxPos = Math.min(Math.floor(steps / 2), arrLen - 1);\n  const dp = [[], []];\n  dp[0][0] = 1;\n\n  for (let s = 1; s <= steps; s++) {\n    for (let p = 0; p <= maxPos; p++) {\n      dp[s % 2][p] = dp[(s - 1) % 2][p];\n      if (p > 0) {\n        dp[s % 2][p] += dp[(s - 1) % 2][p - 1];\n      }\n      if (p < maxPos) {\n        dp[s % 2][p] += dp[(s - 1) % 2][p + 1];\n      }\n      dp[s % 2][p] %= mod;\n    }\n  }\n  return dp[steps % 2][0];\n}\n```\n\n    \n    We use dynamic programming to solve this problem. The state of our dynamic programming is `dp[s][p]`, which represents the number of ways to be at position `p` after `s` steps.\n\nThe base case is `dp[0][0] = 1`, which means there is only one way to be at position `0` (stay there).\n\nOur transition function is as follows:\n```\ndp[s][p] = dp[s - 1][p - 1] + dp[s - 1][p] + dp[s - 1][p + 1] (% mod)\n```\nIn plain words, for every `s` steps, we can either go left, right, or stay at the current position. We iterate from `s = 1` to `steps`. We also set an upper limit on the maximum position we can consider, which is the minimum between `steps / 2` and `arrLen - 1`. This is because we have to return to position `0` after taking `steps`, and while traversing more than `steps / 2` steps, we can't reach position `0`. \n\nAt the end, we return `dp[steps % 2][0]`, which is the number of ways to be at index `0` after `steps` steps.\n    "
    },
    {
        "id": 198,
        "title": "Palindrome Partitioning III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` containing lowercase letters and an integer `k`. You need to :\n\n*   First, change some characters of `s` to other lowercase English letters.\n*   Then divide `s` into `k` non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn _the minimal number of characters that you need to change to divide the string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abc \", k = 2\n**Output:** 1\n**Explanation:** You can split the string into  \"ab \" and  \"c \", and change 1 character in  \"ab \" to make it palindrome.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aabbc \", k = 3\n**Output:** 0\n**Explanation:** You can split the string into  \"aa \",  \"bb \" and  \"c \", all of them are palindrome.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"leetcode \", k = 8\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= s.length <= 100`.\n*   `s` only contains lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"abc\",2",
                "output": "1"
            },
            {
                "input": "\"aabbc\",3",
                "output": "0"
            },
            {
                "input": "\"leetcode\",8",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int palindromePartition(String s, int k) {\n    int n = s.length();\n    int[][] dp = new int[n][n];\n\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            dp[i][j] = dp[i + 1][j - 1] + (s.charAt(i) != s.charAt(j) ? 1 : 0);\n        }\n    }\n\n    int[] memo = new int[n];\n    for (int i = 0; i < n; ++i) {\n        if (dp[0][i] == 0) {\n            memo[i] = 0;\n        } else {\n            memo[i] = Integer.MAX_VALUE;\n            for (int j = 0; j < i; ++j) {\n                memo[i] = Math.min(memo[i], memo[j] + dp[j + 1][i]);\n            }\n        }\n    }\n\n    return memo[memo.length - 1] + k;\n}\n```\n    \n    The core of this solution consists of two steps:\n\n1. Compute the minimum number of changes required to convert each substring `s[i:j]` into a palindrome.\n2. Find the minimum number of changes needed to split the input string into `k` palindromes.\n\nStep 1 is performed by the dynamic programming approach. A 2D DP array is created to store the number of changes needed to make a substring a palindrome. The nested loop iterates over different lengths of substrings and computes the minimum changes necessary to make it palindrome. It fills the DP array with these values.\n\nStep 2 also employs dynamic programming. It iterates through the input string and keeps track of the number of changes required to convert the substrings into palindromes. If a substring `[0:i]` is palindrome, no changes are needed. Otherwise, the number of changes is updated by iterating through each element and choosing the minimum cost necessary to make it palindrome.\n\nFinally, it returns the sum of the number of changes in the memo array's last element and `k`.\n    ",
        "python": "\n    ```python\ndef palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for len in range(2, n + 1):\n        for i in range(n - len + 1):\n            j = i + len - 1\n            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j])\n\n    memo = [float('inf')] * n\n    for i in range(n):\n        if dp[0][i] == 0:\n            memo[i] = 0\n        else:\n            for j in range(i):\n                memo[i] = min(memo[i], memo[j] + dp[j + 1][i])\n\n    return memo[-1] + k\n```\n\n\n    \n    The core of this solution consists of two steps:\n\n1. Compute the minimum number of changes required to convert each substring `s[i:j]` into a palindrome.\n2. Find the minimum number of changes needed to split the input string into `k` palindromes.\n\nStep 1 is performed by the dynamic programming approach. A 2D DP array is created to store the number of changes needed to make a substring a palindrome. The nested loop iterates over different lengths of substrings and computes the minimum changes necessary to make it palindrome. It fills the DP array with these values.\n\nStep 2 also employs dynamic programming. It iterates through the input string and keeps track of the number of changes required to convert the substrings into palindromes. If a substring `[0:i]` is palindrome, no changes are needed. Otherwise, the number of changes is updated by iterating through each element and choosing the minimum cost necessary to make it palindrome.\n\nFinally, it returns the sum of the number of changes in the memo array's last element and `k`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint palindromePartition(std::string s, int k) {\n    int n = s.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j]);\n        }\n    }\n\n    std::vector<int> memo(n, 1e9);\n    for (int i = 0; i < n; ++i) {\n        if (dp[0][i] == 0) {\n            memo[i] = 0;\n        } else {\n            for (int j = 0; j < i; ++j) {\n                memo[i] = std::min(memo[i], memo[j] + dp[j + 1][i]);\n            }\n        }\n    }\n\n    return memo.back() + k;\n}\n```\n    \n    The core of this solution consists of two steps:\n\n1. Compute the minimum number of changes required to convert each substring `s[i:j]` into a palindrome.\n2. Find the minimum number of changes needed to split the input string into `k` palindromes.\n\nStep 1 is performed by the dynamic programming approach. A 2D DP array is created to store the number of changes needed to make a substring a palindrome. The nested loop iterates over different lengths of substrings and computes the minimum changes necessary to make it palindrome. It fills the DP array with these values.\n\nStep 2 also employs dynamic programming. It iterates through the input string and keeps track of the number of changes required to convert the substrings into palindromes. If a substring `[0:i]` is palindrome, no changes are needed. Otherwise, the number of changes is updated by iterating through each element and choosing the minimum cost necessary to make it palindrome.\n\nFinally, it returns the sum of the number of changes in the memo array's last element and `k`.\n    ",
        "js": "\n    ```javascript\nfunction palindromePartition(s, k) {\n    const n = s.length;\n    const dp = Array.from(Array(n), () => Array(n).fill(0));\n\n    for (let len = 2; len <= n; ++len) {\n        for (let i = 0; i <= n - len; ++i) {\n            const j = i + len - 1;\n            dp[i][j] = dp[i + 1][j - 1] + (s[i] !== s[j] ? 1 : 0);\n        }\n    }\n\n    const memo = Array(n).fill(1e9);\n    for (let i = 0; i < n; ++i) {\n        if (dp[0][i] === 0) {\n            memo[i] = 0;\n        } else {\n            for (let j = 0; j < i; ++j) {\n                memo[i] = Math.min(memo[i], memo[j] + dp[j + 1][i]);\n            }\n        }\n    }\n\n    return memo[memo.length - 1] + k;\n}\n```\n\n    \n    The core of this solution consists of two steps:\n\n1. Compute the minimum number of changes required to convert each substring `s[i:j]` into a palindrome.\n2. Find the minimum number of changes needed to split the input string into `k` palindromes.\n\nStep 1 is performed by the dynamic programming approach. A 2D DP array is created to store the number of changes needed to make a substring a palindrome. The nested loop iterates over different lengths of substrings and computes the minimum changes necessary to make it palindrome. It fills the DP array with these values.\n\nStep 2 also employs dynamic programming. It iterates through the input string and keeps track of the number of changes required to convert the substrings into palindromes. If a substring `[0:i]` is palindrome, no changes are needed. Otherwise, the number of changes is updated by iterating through each element and choosing the minimum cost necessary to make it palindrome.\n\nFinally, it returns the sum of the number of changes in the memo array's last element and `k`.\n    "
    },
    {
        "id": 199,
        "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing `1` to `0` and `0` to `1`). A pair of cells are called neighbors if they share one edge.\n\nReturn the _minimum number of steps_ required to convert `mat` to a zero matrix or `-1` if you cannot.\n\nA **binary matrix** is a matrix with all cells equal to `0` or `1` only.\n\nA **zero matrix** is a matrix with all cells equal to `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[0,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[0\\]\\]\n**Output:** 0\n**Explanation:** Given matrix is a zero matrix. We do not need to change it.\n\n",
                "**Example 3:**\n\n**Input:** mat = \\[\\[1,0,0\\],\\[1,0,0\\]\\]\n**Output:** -1\n**Explanation:** Given matrix cannot be a zero matrix."
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 3`\n*   `mat[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,0],[0,1]]",
                "output": "3"
            },
            {
                "input": "[[0]]",
                "output": "0"
            },
            {
                "input": "[[1,0,0],[1,0,0]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int sumOfDivisorsWithFourDivisors(int[] nums) {\n    int sum = 0;\n    for (int num : nums) {\n        int divCount = 0;\n        int divSum = 0;\n\n        for (int i = 1; i * i <= num; ++i) {\n            if (num % i == 0) {\n                divSum += i;\n                ++divCount;\n\n                if (num / i != i) {\n                    divSum += (num / i);\n                    ++divCount;\n                }\n            }\n\n            if (divCount > 4) {\n                break;\n            }\n        }\n\n        if (divCount == 4) {\n            sum += divSum;\n        }\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm starts by initializing a sum variable that will be used to store the sum of all divisors for the numbers with exactly four divisors. Then, we loop through each number in the input array. For each number, we initialize a div_count and div_sum variable to count the number of divisors and to store the sum of its divisors, respectively.\n\nInside the loop, we iterate from 1 to the square root of the current number (inclusive) using another loop. For each iteration, we check if the current number is divisible by the iterating variable 'i'. If it is, we add 'i' to the div_sum and increment the div_count. Next, we check if the result of the division (num / i) is different from 'i' and, if so, we add it to div_sum and increment div_count as well.\n\nAfter checking all divisors, we exit the inner loop and check if div_count is equal to 4. If it is, we add div_sum to the total sum. The process continues until we reach the end of the input array.\n\nFinally, we return the total sum.\n    ",
        "python": "\n    ```python\ndef sum_of_divisors_with_four_divisors(nums):\n    total_sum = 0\n\n    for num in nums:\n        div_count = 0\n        div_sum = 0\n\n        for i in range(1, int(num ** 0.5) + 1):\n            if num % i == 0:\n                div_sum += i\n                div_count += 1\n\n                if num // i != i:\n                    div_sum += num // i\n                    div_count += 1\n\n            if div_count > 4:\n                break\n\n        if div_count == 4:\n            total_sum += div_sum\n\n    return total_sum\n```\n    \n    The algorithm starts by initializing a sum variable that will be used to store the sum of all divisors for the numbers with exactly four divisors. Then, we loop through each number in the input array. For each number, we initialize a div_count and div_sum variable to count the number of divisors and to store the sum of its divisors, respectively.\n\nInside the loop, we iterate from 1 to the square root of the current number (inclusive) using another loop. For each iteration, we check if the current number is divisible by the iterating variable 'i'. If it is, we add 'i' to the div_sum and increment the div_count. Next, we check if the result of the division (num / i) is different from 'i' and, if so, we add it to div_sum and increment div_count as well.\n\nAfter checking all divisors, we exit the inner loop and check if div_count is equal to 4. If it is, we add div_sum to the total sum. The process continues until we reach the end of the input array.\n\nFinally, we return the total sum.\n    ",
        "c++": "\n    ```cpp\nint sum_of_divisors_with_four_divisors(const std::vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        int div_count = 0;\n        int div_sum = 0;\n\n        for (int i = 1; i * i <= num; ++i) {\n            if (num % i == 0) {\n                div_sum += i;\n                ++div_count;\n\n                if (num / i != i) {\n                    div_sum += (num / i);\n                    ++div_count;\n                }\n            }\n\n            if (div_count > 4) {\n                break;\n            }\n        }\n\n        if (div_count == 4) {\n            sum += div_sum;\n        }\n    }\n\n    return sum;\n}\n```\n    \n    The algorithm starts by initializing a sum variable that will be used to store the sum of all divisors for the numbers with exactly four divisors. Then, we loop through each number in the input array. For each number, we initialize a div_count and div_sum variable to count the number of divisors and to store the sum of its divisors, respectively.\n\nInside the loop, we iterate from 1 to the square root of the current number (inclusive) using another loop. For each iteration, we check if the current number is divisible by the iterating variable 'i'. If it is, we add 'i' to the div_sum and increment the div_count. Next, we check if the result of the division (num / i) is different from 'i' and, if so, we add it to div_sum and increment div_count as well.\n\nAfter checking all divisors, we exit the inner loop and check if div_count is equal to 4. If it is, we add div_sum to the total sum. The process continues until we reach the end of the input array.\n\nFinally, we return the total sum.\n    ",
        "js": "\n    ```javascript\nfunction sumOfDivisorsWithFourDivisors(nums) {\n    let sum = 0;\n    for (let num of nums) {\n        let divCount = 0;\n        let divSum = 0;\n\n        for (let i = 1; i * i <= num; ++i) {\n            if (num % i === 0) {\n                divSum += i;\n                ++divCount;\n\n                if (num / i !== i) {\n                    divSum += (num / i);\n                    ++divCount;\n                }\n            }\n\n            if (divCount > 4) {\n                break;\n            }\n        }\n\n        if (divCount === 4) {\n            sum += divSum;\n        }\n    }\n\n    return sum;\n}\n```\n\n    \n    The algorithm starts by initializing a sum variable that will be used to store the sum of all divisors for the numbers with exactly four divisors. Then, we loop through each number in the input array. For each number, we initialize a div_count and div_sum variable to count the number of divisors and to store the sum of its divisors, respectively.\n\nInside the loop, we iterate from 1 to the square root of the current number (inclusive) using another loop. For each iteration, we check if the current number is divisible by the iterating variable 'i'. If it is, we add 'i' to the div_sum and increment the div_count. Next, we check if the result of the division (num / i) is different from 'i' and, if so, we add it to div_sum and increment div_count as well.\n\nAfter checking all divisors, we exit the inner loop and check if div_count is equal to 4. If it is, we add div_sum to the total sum. The process continues until we reach the end of the input array.\n\nFinally, we return the total sum.\n    "
    },
    {
        "id": 200,
        "title": "Minimum Falling Path Sum II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `n x n` integer matrix `grid`, return _the minimum sum of a **falling path with non-zero shifts**_.\n\nA **falling path with non-zero shifts** is a choice of exactly one element from each row of `grid` such that no two elements chosen in adjacent rows are in the same column.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** 13\n**Explanation:** \nThe possible falling paths are:\n\\[1,5,9\\], \\[1,5,7\\], \\[1,6,7\\], \\[1,6,8\\],\n\\[2,4,8\\], \\[2,4,9\\], \\[2,6,7\\], \\[2,6,8\\],\n\\[3,4,8\\], \\[3,4,9\\], \\[3,5,7\\], \\[3,5,9\\]\nThe falling path with the smallest sum is \\[1,5,7\\], so the answer is 13.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[7\\]\\]\n**Output:** 7"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 200`\n*   `-99 <= grid[i][j] <= 99`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                "output": "13"
            },
            {
                "input": "[[7]]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic String dayOfTheWeek(int day, int month, int year) {\n    String[] days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    if (month < 3) {\n        month += 12;\n        year -= 1;\n    }\n    int k = year % 100;\n    int j = year / 100;\n    int dayOfWeek = (day + 13 * (month + 1) / 5 + k + k / 4 + 5 * j + j / 4) % 7;\n    return days[dayOfWeek];\n}\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    ",
        "python": "\n    ```python\ndef day_of_the_week(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    if month < 3:\n        month += 12\n        year -= 1\n    k = year % 100\n    j = year // 100\n    day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7\n    return days[day_of_week]\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    ",
        "c++": "\n    ```cpp\n#include <array>\n#include <string>\n\nstd::string dayOfTheWeek(int day, int month, int year) {\n    std::array<std::string, 7> days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    if (month < 3) {\n        month += 12;\n        year -= 1;\n    }\n    int k = year % 100;\n    int j = year / 100;\n    int dayOfWeek = (day + 13 * (month + 1) / 5 + k + k / 4 + 5 * j + j / 4) % 7;\n    return days[dayOfWeek];\n}\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    ",
        "js": "\n    ```javascript\nfunction dayOfTheWeek(day, month, year) {\n    const days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    if (month < 3) {\n        month += 12;\n        year -= 1;\n    }\n    const k = year % 100;\n    const j = Math.floor(year / 100);\n    const dayOfWeek = (day + Math.floor(13 * (month + 1) / 5) + k + Math.floor(k / 4) + 5 * j + Math.floor(j / 4)) % 7;\n    return days[dayOfWeek];\n}\n```\n    \n    This algorithm is based on Zeller's Congruence. First, we create an array of week days. If the month is smaller than 3 (meaning January or February), we add 12 to the month and reduce the year by 1. Then, we calculate k and j, which are the year%100 and year/100, respectively. Finally, the day of the week is calculated by a formula considering the day, month, k, j, and some constants, and the output is the corresponding day string from our week days array.\n    "
    },
    {
        "id": 201,
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` integer matrix `grid` where each cell is either `0` (empty) or `1` (obstacle). You can move up, down, left, or right from and to an empty cell in **one step**.\n\nReturn _the minimum number of **steps** to walk from the upper left corner_ `(0, 0)` _to the lower right corner_ `(m - 1, n - 1)` _given that you can eliminate **at most**_ `k` _obstacles_. If it is not possible to find such walk return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[1,1,0\\],\\[0,0,0\\],\\[0,1,1\\],\\[0,0,0\\]\\], k = 1\n**Output:** 6\n**Explanation:** \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> **(3,2)** -> (4,2).\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1\\],\\[1,1,1\\],\\[1,0,0\\]\\], k = 1\n**Output:** -1\n**Explanation:** We need to eliminate at least two obstacles to find such a walk."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 40`\n*   `1 <= k <= m * n`\n*   `grid[i][j]` is either `0` **or** `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]],1",
                "output": "6"
            },
            {
                "input": "[[0,1,1],[1,1,1],[1,0,0]],1",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int shortestPath(int[][] grid, int k) {\n    int m = grid.length;\n    int n = grid[0].length;\n    boolean[][][] visited = new boolean[m][n][k + 1];\n    Queue<int[]> q  = new LinkedList<>();\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    q.offer(new int[]{0, 0, 0, k});\n\n    int steps = 0;\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; i++) {\n            int[] tmp = q.poll();\n            int x = tmp[0];\n            int y = tmp[1];\n            if (x == m - 1 && y == n - 1) return steps;\n\n            for (int[] move : moves) {\n                int newX = x + move[0];\n                int newY = y + move[1];\n                int newK = tmp[3] - grid[newX][newY];\n                if (newX >= 0 && newX < m && newY >= 0 && newY < n && newK >= 0 && !visited[newX][newY][newK]) {\n                    visited[newX][newY][newK] = true;\n                    q.offer(new int[]{newX, newY, steps + 1, newK});\n                }\n            }\n        }\n        steps++;\n    }\n\n    return -1;\n}\n```\n    \n    The given problem can be solved using BFS with an additional state for the number of obstacles we can still eliminate. We use a 3D visited array to keep track of the states we have visited at each cell with a certain number of obstacle eliminations remaining. \n\nFor each cell, we perform 4 possible moves: left, right, up and down. We then calculate the new number of obstacles we can eliminate. If the move is valid within the boundaries of the grid and the new number of obstacles we can eliminate is non-negative, we add the new state to the queue and mark it as visited. \n\nWe continue the BFS until the queue is empty or we have visited the cell at the bottom right corner with valid number of obstacle eliminations remaining. If we visit the target cell, we return the number of steps taken so far. If the queue is empty, we return -1 as we couldn't find a valid path.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef shortestPath(grid, k):\n    m, n = len(grid), len(grid[0])\n    visited = [[[False for _ in range(k + 1)] for _ in range(n)] for _ in range(m)]\n    q = deque([(0, 0, 0, k)])\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    steps = 0\n\n    while q:\n        for _ in range(len(q)):\n            x, y, steps, k_remaining = q.popleft()\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in moves:\n                new_x, new_y, = x + dx, y + dy\n                if 0 <= new_x < m and 0 <= new_y < n:\n                    new_k_remaining = k_remaining - grid[new_x][new_y]\n                    if new_k_remaining >= 0 and not visited[new_x][new_y][new_k_remaining]:\n                        visited[new_x][new_y][new_k_remaining] = True\n                        q.append((new_x, new_y, steps + 1, new_k_remaining))\n        steps += 1\n\n    return -1\n```\n    \n    The given problem can be solved using BFS with an additional state for the number of obstacles we can still eliminate. We use a 3D visited array to keep track of the states we have visited at each cell with a certain number of obstacle eliminations remaining. \n\nFor each cell, we perform 4 possible moves: left, right, up and down. We then calculate the new number of obstacles we can eliminate. If the move is valid within the boundaries of the grid and the new number of obstacles we can eliminate is non-negative, we add the new state to the queue and mark it as visited. \n\nWe continue the BFS until the queue is empty or we have visited the cell at the bottom right corner with valid number of obstacle eliminations remaining. If we visit the target cell, we return the number of steps taken so far. If the queue is empty, we return -1 as we couldn't find a valid path.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nint shortestPath(std::vector<std::vector<int>>& grid, int k) {\n    int m = grid.size();\n    int n = grid[0].size();\n    std::vector<std::vector<std::vector<int>>> visited(m, std::vector<std::vector<int>>(n, std::vector<int>(k + 1, 0)));\n    std::queue<std::tuple<int, int, int, int>> q;\n    int steps = 0;\n    int moves[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    q.push({0, 0, 0, k});\n\n    while (!q.empty()) {\n        int q_size = q.size();\n        for (int i = 0; i < q_size; ++i) {\n            int x, y, steps, k_remaining;\n            std::tie(x, y, steps, k_remaining) = q.front();\n            q.pop();\n            if (x == m - 1 && y == n - 1) return steps;\n\n            for (const auto& move : moves) {\n                int new_x = x + move[0];\n                int new_y = y + move[1];\n                if (new_x >= 0 && new_x < m && new_y >= 0 && new_y < n) {\n                    int new_k_remaining = k_remaining - grid[new_x][new_y];\n                    if (new_k_remaining >= 0 && !visited[new_x][new_y][new_k_remaining]) {\n                        visited[new_x][new_y][new_k_remaining] = 1;\n                        q.push({new_x, new_y, steps + 1, new_k_remaining});\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n```\n    \n    The given problem can be solved using BFS with an additional state for the number of obstacles we can still eliminate. We use a 3D visited array to keep track of the states we have visited at each cell with a certain number of obstacle eliminations remaining. \n\nFor each cell, we perform 4 possible moves: left, right, up and down. We then calculate the new number of obstacles we can eliminate. If the move is valid within the boundaries of the grid and the new number of obstacles we can eliminate is non-negative, we add the new state to the queue and mark it as visited. \n\nWe continue the BFS until the queue is empty or we have visited the cell at the bottom right corner with valid number of obstacle eliminations remaining. If we visit the target cell, we return the number of steps taken so far. If the queue is empty, we return -1 as we couldn't find a valid path.\n    ",
        "js": "\n    ```javascript\nfunction shortestPath(grid, k) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const visited = Array.from({ length: m }, () => Array.from({ length: n }, () => Array(k + 1).fill(false)));\n    const q = [[0, 0, 0, k]];\n    const moves = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let steps = 0;\n\n    while (q.length > 0) {\n        const size = q.length;\n        for (let i = 0; i < size; i++) {\n            const [x, y, , k_remaining] = q.shift();\n            if (x === m - 1 && y === n - 1) return steps;\n\n            for (let [dx, dy] of moves) {\n                const newX = x + dx;\n                const newY = y + dy;\n                if (newX >= 0 && newX < m && newY >= 0 && newY < n) {\n                    const newKRemaining = k_remaining - grid[newX][newY];\n                    if (newKRemaining >= 0 && !visited[newX][newY][newKRemaining]) {\n                        visited[newX][newY][newKRemaining] = true;\n                        q.push([newX, newY, steps + 1, newKRemaining]);\n                    }\n                }\n            }\n        }\n        steps++;\n    }\n\n    return -1;\n}\n```\n    \n    The given problem can be solved using BFS with an additional state for the number of obstacles we can still eliminate. We use a 3D visited array to keep track of the states we have visited at each cell with a certain number of obstacle eliminations remaining. \n\nFor each cell, we perform 4 possible moves: left, right, up and down. We then calculate the new number of obstacles we can eliminate. If the move is valid within the boundaries of the grid and the new number of obstacles we can eliminate is non-negative, we add the new state to the queue and mark it as visited. \n\nWe continue the BFS until the queue is empty or we have visited the cell at the bottom right corner with valid number of obstacle eliminations remaining. If we visit the target cell, we return the number of steps taken so far. If the queue is empty, we return -1 as we couldn't find a valid path.\n    "
    },
    {
        "id": 202,
        "title": "Maximum Candies You Can Get from Boxes",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` boxes labeled from `0` to `n - 1`. You are given four arrays: `status`, `candies`, `keys`, and `containedBoxes` where:\n\n*   `status[i]` is `1` if the `ith` box is open and `0` if the `ith` box is closed,\n*   `candies[i]` is the number of candies in the `ith` box,\n*   `keys[i]` is a list of the labels of the boxes you can open after opening the `ith` box.\n*   `containedBoxes[i]` is a list of the boxes you found inside the `ith` box.\n\nYou are given an integer array `initialBoxes` that contains the labels of the boxes you initially have. You can take all the candies in **any open box** and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\n\nReturn _the maximum number of candies you can get following the rules above_.",
            "examples": [
                "**Example 1:**\n\n**Input:** status = \\[1,0,1,0\\], candies = \\[7,5,4,100\\], keys = \\[\\[\\],\\[\\],\\[1\\],\\[\\]\\], containedBoxes = \\[\\[1,2\\],\\[3\\],\\[\\],\\[\\]\\], initialBoxes = \\[0\\]\n**Output:** 16\n**Explanation:** You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.\nBox 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\nIn box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\nTotal number of candies collected = 7 + 4 + 5 = 16 candy.\n\n",
                "**Example 2:**\n\n**Input:** status = \\[1,0,0,0,0,0\\], candies = \\[1,1,1,1,1,1\\], keys = \\[\\[1,2,3,4,5\\],\\[\\],\\[\\],\\[\\],\\[\\],\\[\\]\\], containedBoxes = \\[\\[1,2,3,4,5\\],\\[\\],\\[\\],\\[\\],\\[\\],\\[\\]\\], initialBoxes = \\[0\\]\n**Output:** 6\n**Explanation:** You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.\nThe total number of candies will be 6."
            ],
            "constraints": "**Constraints:**\n\n*   `n == status.length == candies.length == keys.length == containedBoxes.length`\n*   `1 <= n <= 1000`\n*   `status[i]` is either `0` or `1`.\n*   `1 <= candies[i] <= 1000`\n*   `0 <= keys[i].length <= n`\n*   `0 <= keys[i][j] < n`\n*   All values of `keys[i]` are **unique**.\n*   `0 <= containedBoxes[i].length <= n`\n*   `0 <= containedBoxes[i][j] < n`\n*   All values of `containedBoxes[i]` are unique.\n*   Each box is contained in one box at most.\n*   `0 <= initialBoxes.length <= n`\n*   `0 <= initialBoxes[i] < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Graph"
        ],
        "example": [
            {
                "input": "[1,0,1,0],[7,5,4,100],[[],[],[1],[]],[[1,2],[3],[],[]],[0]",
                "output": "16"
            },
            {
                "input": "[1,0,0,0,0,0],[1,1,1,1,1,1],[[1,2,3,4,5],[],[],[],[],[]],[[1,2,3,4,5],[],[],[],[],[]],[0]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic String reverseParentheses(String s) {\n    Stack<Character> st = new Stack<>();\n    String result = \"\";\n\n    for (char c : s.toCharArray()) {\n        if (c != ')') {\n            st.push(c);\n        } else {\n            String temp = \"\";\n            while (!st.empty() && st.peek() != '(') {\n                temp += st.pop();\n            }\n            if (!st.empty()) st.pop(); // Remove '('\n            for (char t : temp.toCharArray()) {\n                st.push(t);\n            }\n        }\n    }\n\n    while (!st.empty()) {\n        result = st.pop() + result;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm uses a single stack to reverse the substrings enclosed by matching parentheses. It iterates through the characters in the given string, adding them to the stack. When a closing parenthesis is encountered, it starts popping elements from the stack and adding them to a temporary substring until an opening parenthesis is encountered. Then, the algorithm removes the opening parenthesis from the stack and pushes the reversed temporary substring back onto the stack. After the whole iteration, the remaining characters in the stack represent the resulting string without the brackets.\n    ",
        "python": "\n    ```python\ndef reverseParentheses(s: str) -> str:\n    st = []\n    result = []\n\n    for c in s:\n        if c != ')':\n            st.append(c)\n        else:\n            temp = []\n            while st and st[-1] != '(':\n                temp.append(st.pop())\n            if st: st.pop()  # Remove '('\n            st.extend(temp)\n\n    result = \"\".join(st)\n    return result\n```\n\n    \n    The algorithm uses a single stack to reverse the substrings enclosed by matching parentheses. It iterates through the characters in the given string, adding them to the stack. When a closing parenthesis is encountered, it starts popping elements from the stack and adding them to a temporary substring until an opening parenthesis is encountered. Then, the algorithm removes the opening parenthesis from the stack and pushes the reversed temporary substring back onto the stack. After the whole iteration, the remaining characters in the stack represent the resulting string without the brackets.\n    ",
        "c++": "\n    ```cpp\n#include <stack>\n#include <string>\n\nstd::string reverseParentheses(std::string s) {\n    std::stack<char> st;\n    std::string result = \"\";\n\n    for (char c : s) {\n        if (c != ')') {\n            st.push(c);\n        } else {\n            std::string temp = \"\";\n            while (!st.empty() && st.top() != '(') {\n                temp += st.top();\n                st.pop();\n            }\n            if (!st.empty()) st.pop(); // Remove '('\n            for (char t : temp) {\n                st.push(t);\n            }\n        }\n    }\n\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm uses a single stack to reverse the substrings enclosed by matching parentheses. It iterates through the characters in the given string, adding them to the stack. When a closing parenthesis is encountered, it starts popping elements from the stack and adding them to a temporary substring until an opening parenthesis is encountered. Then, the algorithm removes the opening parenthesis from the stack and pushes the reversed temporary substring back onto the stack. After the whole iteration, the remaining characters in the stack represent the resulting string without the brackets.\n    ",
        "js": "\n    ```javascript\nfunction reverseParentheses(s) {\n    const st = [];\n    let result = \"\";\n\n    for (const c of s) {\n        if (c !== ')') {\n            st.push(c);\n        } else {\n            let temp = \"\";\n            while (st.length > 0 && st[st.length - 1] !== '(') {\n                temp += st.pop();\n            }\n            if (st.length > 0) st.pop(); // Remove '('\n            for (const t of temp) {\n                st.push(t);\n            }\n        }\n    }\n\n    result = st.join(\"\");\n    return result;\n}\n```\n\n    \n    The algorithm uses a single stack to reverse the substrings enclosed by matching parentheses. It iterates through the characters in the given string, adding them to the stack. When a closing parenthesis is encountered, it starts popping elements from the stack and adding them to a temporary substring until an opening parenthesis is encountered. Then, the algorithm removes the opening parenthesis from the stack and pushes the reversed temporary substring back onto the stack. After the whole iteration, the remaining characters in the stack represent the resulting string without the brackets.\n    "
    },
    {
        "id": 203,
        "title": "Number of Paths with Max Score",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, **taken modulo `10^9 + 7`**.\n\nIn case there is no path, return `[0, 0]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\"E23\",\"2X2\",\"12S\"\\]\n**Output:** \\[7,1\\]\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\"E12\",\"1X1\",\"21S\"\\]\n**Output:** \\[4,2\\]\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\"E11\",\"XXX\",\"11S\"\\]\n**Output:** \\[0,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= board.length == board[i].length <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[\"E23\",\"2X2\",\"12S\"]",
                "output": "[7,1]"
            },
            {
                "input": "[\"E12\",\"1X1\",\"21S\"]",
                "output": "[4,2]"
            },
            {
                "input": "[\"E11\",\"XXX\",\"11S\"]",
                "output": "[0,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    private static final int MOD = 1000000007;\n\n    public List<Integer> pathsWithMaxScore(List<String> board) {\n        int n = board.size();\n        int[][] dp = new int[n][n];\n        int[][] cnt = new int[n][n];\n        \n        board.set(0, \"0\" + board.get(0).substring(1));\n        board.set(n-1, board.get(n-1).substring(0, n - 1) + \"0\");\n        cnt[n-1][n-1] = 1;\n        \n        for (int i = n-1; i >= 0; i--) {\n            for (int j = n-1; j >= 0; j--) {\n                if (board.get(i).charAt(j) != 'X') {\n                    int[][] neighbors = {{i-1, j}, {i, j-1}, {i-1, j-1}};\n                    for (int[] neighbor : neighbors) {\n                        int x = neighbor[0], y = neighbor[1];\n                        if(x >= 0 && y >= 0) {\n                            if (dp[i][j] < dp[x][y] + board.get(i).charAt(j) - '0') {\n                                dp[i][j] = dp[x][y] + board.get(i).charAt(j) - '0';\n                                cnt[i][j] = cnt[x][y];\n                            } else if (dp[i][j] == dp[x][y] + board.get(i).charAt(j) - '0') {\n                                cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return Arrays.asList(dp[0][0], cnt[0][0]);\n    }\n}\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef pathsWithMaxScore(board: List[str]) -> List[int]:\n    n = len(board)\n    dp = [[0] * n for _ in range(n)]\n    cnt = [[0] * n for _ in range(n)]\n\n    board[0] = list(board[0])\n    board[0][0] = '0'\n    board[n-1] = list(board[n-1])\n    board[n-1][n-1] = '0'\n    cnt[n-1][n-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if board[i][j] != 'X':\n                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]\n                for x, y in neighbors:\n                    if x >= 0 and y >= 0:\n                        if dp[i][j] < dp[x][y] + int(board[i][j]):\n                            dp[i][j] = dp[x][y] + int(board[i][j])\n                            cnt[i][j] = cnt[x][y]\n                        elif dp[i][j] == dp[x][y] + int(board[i][j]):\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD\n\n    return [dp[0][0], cnt[0][0]]\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\nconst int MOD = 1000000007;\n\nvector<int> pathsWithMaxScore(vector<string>& board) {\n    int n = board.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0)), cnt(n, vector<int>(n, 0));\n    \n    board[0][0] = '0';\n    board[n-1][n-1] = '0';\n    cnt[n-1][n-1] = 1;\n    \n    for (int i = n-1; i >= 0; i--) {\n        for (int j = n-1; j >= 0; j--) {\n            if (board[i][j] != 'X') {\n                vector<pair<int, int>> neighbors = {{i-1, j}, {i, j-1}, {i-1, j-1}};\n                for (auto neighbor : neighbors) {\n                    int x = neighbor.first, y = neighbor.second;\n                    if(x>=0 && y>=0) {\n                        if (dp[i][j] < dp[x][y] + board[i][j] - '0') {\n                            dp[i][j] = dp[x][y] + board[i][j] - '0';\n                            cnt[i][j] = cnt[x][y];\n                        } else if (dp[i][j] == dp[x][y] + board[i][j] - '0') {\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return {dp[0][0], cnt[0][0]};\n}\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    ",
        "js": "\n    ```javascript\nconst MOD = 1000000007;\n\nfunction pathsWithMaxScore(board) {\n    const n = board.length;\n    const dp = Array.from({length: n}, () => Array(n).fill(0));\n    const cnt = Array.from({length: n}, () => Array(n).fill(0));\n\n    board[0] = '0' + board[0].slice(1);\n    board[n - 1] = board[n - 1].slice(0, -1) + '0';\n    cnt[n - 1][n - 1] = 1;\n\n    for (let i = n-1; i >= 0; i--) {\n        for (let j = n-1; j >= 0; j--) {\n            if (board[i][j] !== 'X') {\n                const neighbors = [[i-1, j], [i, j-1], [i-1, j-1]];\n                for (const [x, y] of neighbors) {\n                    if (x >= 0 && y >= 0) {\n                        if (dp[i][j] < dp[x][y] + parseInt(board[i][j])) {\n                            dp[i][j] = dp[x][y] + parseInt(board[i][j]);\n                            cnt[i][j] = cnt[x][y];\n                        } else if (dp[i][j] === dp[x][y] + parseInt(board[i][j])) {\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return [dp[0][0], cnt[0][0]];\n}\n```\n\n    \n    We can use dynamic programming to solve this problem. We create two matrices, `dp` and `cnt`, where `dp[i][j]` represents the maximum sum of numeric characters that can be collected starting from (i, j) and `cnt[i][j]` represents the count of paths that can achieve that maximum sum.\n\nWe start from the bottom right corner (start position labeled 'S') and work our way up to the top left corner (end position labeled 'E') by checking for up, left, and up-left neighbors.\n\nIf the current cell (i, j) is not an obstacle ('X'), we iterate through its non-obstacle neighbors (x, y):\n- If `dp[i][j] < dp[x][y] + board[i][j] - '0'`, we update the maximum sum value at `dp[i][j]` and assign the count of paths to `cnt[i][j]` from the current neighbor, `cnt[x][y]`.\n- If `dp[i][j] == dp[x][y] + board[i][j] - '0'`, we increase the count of paths at `cnt[i][j]` by adding the count of paths from the current neighbor, `cnt[x][y]`, mod `10^9 + 7` to prevent integer overflow.\n\nOnce the iterations complete, we return the maximum sum and count of paths at the top left corner, `dp[0][0]` and `cnt[0][0]`. If there is no path, the values will remain 0, and we'll return `[0, 0]`.\n    "
    },
    {
        "id": 204,
        "title": "Verbal Arithmetic Puzzle",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an equation, represented by `words` on the left side and the `result` on the right side.\n\nYou need to check if the equation is solvable under the following rules:\n\n*   Each character is decoded as one digit (0 - 9).\n*   No two characters can map to the same digit.\n*   Each `words[i]` and `result` are decoded as one number **without** leading zeros.\n*   Sum of numbers on the left side (`words`) will equal to the number on the right side (`result`).\n\nReturn `true` _if the equation is solvable, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"SEND \", \"MORE \"\\], result =  \"MONEY \"\n**Output:** true\n**Explanation:** Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\nSuch that:  \"SEND \" +  \"MORE \" =  \"MONEY \" ,  9567 + 1085 = 10652\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"SIX \", \"SEVEN \", \"SEVEN \"\\], result =  \"TWENTY \"\n**Output:** true\n**Explanation:** Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\nSuch that:  \"SIX \" +  \"SEVEN \" +  \"SEVEN \" =  \"TWENTY \" ,  650 + 68782 + 68782 = 138214\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"LEET \", \"CODE \"\\], result =  \"POINT \"\n**Output:** false\n**Explanation:** There is no possible mapping to satisfy the equation, so we return false.\nNote that two different characters cannot map to the same digit."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= words.length <= 5`\n*   `1 <= words[i].length, result.length <= 7`\n*   `words[i], result` contain only uppercase English letters.\n*   The number of different characters used in the expression is at most `10`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "String",
            "Backtracking"
        ],
        "example": [
            {
                "input": "[\"SEND\",\"MORE\"],\"MONEY\"",
                "output": "true"
            },
            {
                "input": "[\"SIX\",\"SEVEN\",\"SEVEN\"],\"TWENTY\"",
                "output": "true"
            },
            {
                "input": "[\"LEET\",\"CODE\"],\"POINT\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int nthUglyNumber(int n, int a, int b, int c) {\n    long ab = a * b / gcd(a, b);\n    long ac = a * c / gcd(a, c);\n    long bc = b * c / gcd(b, c);\n    long abc = a * (b * c / gcd(b, c)) / gcd(a, (b * c / gcd(b, c)));\n\n    long left = 0, right = 2000000000;\n    while (left < right) {\n        long mid = left + (right - left) / 2;\n        long cnt = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\n        if (cnt < n) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return (int)left;\n}\n\nprivate long gcd(long a, long b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n    \n    We can solve this problem using binary search. First, we find the least common multiple of each pair of numbers (a, b), (a, c), and (b, c) as well as the least common multiple of all three numbers (a, b, c). Then, we use binary search to find the ugly number. In each iteration, we check the count of numbers divisible by a, b, or c in the range [0, mid] and compare it with our target index n. If the count is less than n, we search in the larger half of the search space, otherwise, we search in the smaller half. When our search range becomes [0,1] or left becomes equal to right, we have found the nth ugly number.\n    ",
        "python": "\n    ```python\ndef nthUglyNumber(n, a, b, c):\n    from math import gcd\n\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * bc // gcd(a, bc)\n\n    left, right = 0, 2 * 10**9\n    while left < right:\n        mid = left + (right - left) // 2\n        cnt = mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc\n        if cnt < n:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n    \n    We can solve this problem using binary search. First, we find the least common multiple of each pair of numbers (a, b), (a, c), and (b, c) as well as the least common multiple of all three numbers (a, b, c). Then, we use binary search to find the ugly number. In each iteration, we check the count of numbers divisible by a, b, or c in the range [0, mid] and compare it with our target index n. If the count is less than n, we search in the larger half of the search space, otherwise, we search in the smaller half. When our search range becomes [0,1] or left becomes equal to right, we have found the nth ugly number.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nint nthUglyNumber(int n, int a1, int a2, int a3) {\n    long long a = a1, b = a2, c = a3;\n    long long ab = a * b / std::__gcd(a, b);\n    long long ac = a * c / std::__gcd(a, c);\n    long long bc = b * c / std::__gcd(b, c);\n    long long abc = a * bc / std::__gcd(a, bc);\n\n    long long left = 0, right = 2e9;\n    while (left < right) {\n        long long mid = left + (right - left) / 2;\n        long long cnt = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\n        if (cnt < n) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    We can solve this problem using binary search. First, we find the least common multiple of each pair of numbers (a, b), (a, c), and (b, c) as well as the least common multiple of all three numbers (a, b, c). Then, we use binary search to find the ugly number. In each iteration, we check the count of numbers divisible by a, b, or c in the range [0, mid] and compare it with our target index n. If the count is less than n, we search in the larger half of the search space, otherwise, we search in the smaller half. When our search range becomes [0,1] or left becomes equal to right, we have found the nth ugly number.\n    ",
        "js": "\n    ```javascript\nfunction nthUglyNumber(n, a, b, c) {\n    const gcd = (x, y) => y === 0 ? x : gcd(y, x % y);\n\n    let ab = a * b / gcd(a, b);\n    let ac = a * c / gcd(a, c);\n    let bc = b * c / gcd(b, c);\n    let abc = a * (b * c / gcd(b, c)) / gcd(a, (b * c / gcd(b, c)));\n\n    let left = 0, right = 2e9;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        let cnt = Math.floor(mid / a) + Math.floor(mid / b) + Math.floor(mid / c) - Math.floor(mid / ab) -\n                  Math.floor(mid / ac) - Math.floor(mid / bc) + Math.floor(mid / abc);\n        if (cnt < n) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    We can solve this problem using binary search. First, we find the least common multiple of each pair of numbers (a, b), (a, c), and (b, c) as well as the least common multiple of all three numbers (a, b, c). Then, we use binary search to find the ugly number. In each iteration, we check the count of numbers divisible by a, b, or c in the range [0, mid] and compare it with our target index n. If the count is less than n, we search in the larger half of the search space, otherwise, we search in the smaller half. When our search range becomes [0,1] or left becomes equal to right, we have found the nth ugly number.\n    "
    },
    {
        "id": 205,
        "title": "Minimum Insertion Steps to Make a String Palindrome",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`. In one step you can insert any character at any index of the string.\n\nReturn _the minimum number of steps_ to make `s` palindrome.\n\nA **Palindrome String** is one that reads the same backward as well as forward.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"zzazz \"\n**Output:** 0\n**Explanation:** The string  \"zzazz \" is already palindrome we do not need any insertions.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"mbadm \"\n**Output:** 2\n**Explanation:** String can be  \"mbdadbm \" or  \"mdbabdm \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"leetcode \"\n**Output:** 5\n**Explanation:** Inserting 5 characters the string becomes  \"leetcodocteel \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"zzazz\"",
                "output": "0"
            },
            {
                "input": "\"mbadm\"",
                "output": "2"
            },
            {
                "input": "\"leetcode\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int extractArtifacts(int n, int[][] artifacts, int[][] dig) {\n    Map<Integer, Set<Integer>> artifactCells = new HashMap<>();\n    Map<Integer, Integer> artifactCount = new HashMap<>();\n    for (int i = 0; i < artifacts.length; i++) {\n        for (int r = artifacts[i][0]; r <= artifacts[i][2]; r++) {\n            for (int c = artifacts[i][1]; c <= artifacts[i][3]; c++) {\n                int cell = r * n + c;\n                artifactCells.computeIfAbsent(cell, k -> new HashSet<>()).add(i);\n                artifactCount.put(i, artifactCount.getOrDefault(i, 0) + 1);\n            }\n        }\n    }\n    \n    int ans = 0;\n    for (int[] d : dig) {\n        int cell = d[0] * n + d[1];\n        Set<Integer> artifactsInCell = artifactCells.remove(cell);\n        if (artifactsInCell != null) {\n            for (int artifactId : artifactsInCell) {\n                int remaining = artifactCount.get(artifactId) - 1;\n                artifactCount.put(artifactId, remaining);\n                if (remaining == 0) ans++;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    ",
        "python": "\n    ```python\ndef extract_artifacts(n, artifacts, dig):\n    artifact_cells = {}\n    artifact_count = {}\n\n    for i, (r1, c1, r2, c2) in enumerate(artifacts):\n        for r in range(r1, r2 + 1):\n            for c in range(c1, c2 + 1):\n                cell = r * n + c\n                if cell not in artifact_cells:\n                    artifact_cells[cell] = set()\n                artifact_cells[cell].add(i)\n                artifact_count[i] = artifact_count.get(i, 0) + 1\n\n    ans = 0\n    for r, c in dig:\n        cell = r * n + c\n        if cell in artifact_cells:\n            for artifact_id in artifact_cells[cell]:\n                artifact_count[artifact_id] -= 1\n                if artifact_count[artifact_id] == 0:\n                    ans += 1\n            del artifact_cells[cell]\n\n    return ans\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    ",
        "c++": "\n    ```cpp\nint extractArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\n    unordered_map<int, set<pair<int, int>>> artifact_cells;\n    unordered_map<int, int> artifact_count;\n    for (int i = 0; i < artifacts.size(); i++) {\n        for (int r = artifacts[i][0]; r <= artifacts[i][2]; r++) {\n            for (int c = artifacts[i][1]; c <= artifacts[i][3]; c++) {\n                artifact_cells[r * n + c].insert({i, r * n + c});\n                artifact_count[i]++;\n            }\n        }\n    }\n    \n    int ans = 0;\n    for (const auto& d : dig) {\n        int cell = d[0] * n + d[1];\n        for (const auto& p : artifact_cells[cell]) {\n            artifact_count[p.first]--;\n            if (artifact_count[p.first] == 0) ans++;\n        }\n        artifact_cells.erase(cell);\n    }\n    return ans;\n}\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    ",
        "js": "\n    ```javascript\nfunction extractArtifacts(n, artifacts, dig) {\n    const artifactCells = new Map();\n    const artifactCount = new Map();\n\n    for (let i = 0; i < artifacts.length; i++) {\n        for (let r = artifacts[i][0]; r <= artifacts[i][2]; r++) {\n            for (let c = artifacts[i][1]; c <= artifacts[i][3]; c++) {\n                const cell = r * n + c;\n                if (!artifactCells.has(cell)) {\n                    artifactCells.set(cell, new Set());\n                }\n                artifactCells.get(cell).add(i);\n                artifactCount.set(i, (artifactCount.get(i) || 0) + 1);\n            }\n        }\n    }\n    \n    let ans = 0;\n    for (const [r, c] of dig) {\n        const cell = r * n + c;\n        if (artifactCells.has(cell)) {\n            for (const artifactId of artifactCells.get(cell)) {\n                const remaining = artifactCount.get(artifactId) - 1;\n                artifactCount.set(artifactId, remaining);\n                if (remaining === 0) ans++;\n            }\n            artifactCells.delete(cell);\n        }\n    }\n    return ans;\n}\n```\n    \n    1. For each artifact, iterate through its grid positions and store the positions in an unordered_map or HashMap (artifact_cells) with the key being the cell value (row * n + column) and the value being a set containing the artifact ID. Also, maintain a count of the number of cells for each artifact in another unordered_map or HashMap (artifact_count).\n\n2. Iterate through the dig array and for each cell, check if it contains any artifacts using the artifact_cells. If so, decrement the count of the corresponding artifacts in the artifact_count, and remove the cell from the artifact_cells.\n\n3. If the count of an artifact reaches 0, increment the result (ans) by 1, as the whole artifact has been uncovered and can be extracted now.\n\n4. Return the final count (ans) after iterating through all the dig cells. This represents the number of artifacts that can be extracted.\n    "
    },
    {
        "id": 206,
        "title": "Minimum Distance to Type a Word Using Two Fingers",
        "difficulty": "Hard",
        "content": {
            "problem": "You have a keyboard layout as shown above in the **X-Y** plane, where each English uppercase letter is located at some coordinate.\n\n*   For example, the letter `'A'` is located at coordinate `(0, 0)`, the letter `'B'` is located at coordinate `(0, 1)`, the letter `'P'` is located at coordinate `(2, 3)` and the letter `'Z'` is located at coordinate `(4, 1)`.\n\nGiven the string `word`, return _the minimum total **distance** to type such string using only two fingers_.\n\nThe **distance** between coordinates `(x1, y1)` and `(x2, y2)` is `|x1 - x2| + |y1 - y2|`.\n\n**Note** that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"CAKE \"\n**Output:** 3\n**Explanation:** Using two fingers, one optimal way to type  \"CAKE \" is: \nFinger 1 on letter 'C' -> cost = 0 \nFinger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \nFinger 2 on letter 'K' -> cost = 0 \nFinger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \nTotal distance = 3\n\n",
                "**Example 2:**\n\n**Input:** word =  \"HAPPY \"\n**Output:** 6\n**Explanation:** Using two fingers, one optimal way to type  \"HAPPY \" is:\nFinger 1 on letter 'H' -> cost = 0\nFinger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\nFinger 2 on letter 'P' -> cost = 0\nFinger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\nFinger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\nTotal distance = 6"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= word.length <= 300`\n*   `word` consists of uppercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"CAKE\"",
                "output": "3"
            },
            {
                "input": "\"HAPPY\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic String removeDuplicates(String s, int k) {\n    Stack<Pair<Character, Integer>> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (!st.isEmpty() && st.peek().getKey() == c) {\n            st.peek().setValue(st.peek().getValue() + 1);\n            if (st.peek().getValue() == k) st.pop();\n        } else {\n            st.push(new Pair<>(c, 1));\n        }\n    }\n    StringBuilder result = new StringBuilder();\n    while (!st.isEmpty()) {\n        Pair<Character, Integer> top = st.pop();\n        for (int i = 0; i < top.getValue(); i++) {\n            result.insert(0, top.getKey());\n        }\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    ",
        "python": "\n    ```python\ndef removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    return ''.join(c * n for c, n in stack)\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string removeDuplicates(std::string s, int k) {\n    std::stack<std::pair<char, int>> st;\n    for (char c : s) {\n        if (!st.empty() && st.top().first == c) {\n            st.top().second++;\n            if (st.top().second == k) st.pop();\n        } else {\n            st.push({c, 1});\n        }\n    }\n    std::string result = \"\";\n    while (!st.empty()) {\n        result = std::string(st.top().second, st.top().first) + result;\n        st.pop();\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    ",
        "js": "\n    ```javascript\nfunction removeDuplicates(s, k) {\n    let stack = [];\n    for (let c of s) {\n        if (stack.length > 0 && stack[stack.length - 1][0] === c) {\n            stack[stack.length - 1][1]++;\n            if (stack[stack.length - 1][1] === k) stack.pop();\n        } else {\n            stack.push([c, 1]);\n        }\n    }\n    return stack.map(([c, n]) => c.repeat(n)).join('');\n}\n```\n    \n    The algorithm initializes an empty stack for storing input string characters and their counts. It iterates through the input string, checking each character. If the top of the stack contains the same character, its count is incremented by 1. If the count becomes equal to k, remove that character from the stack, as we've found k adjacent and equal letters to remove. If the top of the stack does not contain the same character, push the character and the count 1 to the stack.\n\nOnce the input string has been processed, build the resulting string by concatenating characters from the stack with their respective counts.\n\nThe time complexity of this algorithm is O(n), as it iterates over each character in the input string once, and the space complexity is O(n), as it uses a stack to store elements. \n    "
    },
    {
        "id": 207,
        "title": "Minimum Number of Taps to Open to Water a Garden",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "5,[3,4,1,1,0,0]",
                "output": "1"
            },
            {
                "input": "3,[0,0,0,0]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int sumOfFlooredPairs(int[] nums) {\n    int mod = 1000000007;\n    int maxVal = Integer.MIN_VALUE;\n    for (int num : nums) {\n        maxVal = Math.max(maxVal, num);\n    }\n    int[] count = new int[maxVal + 1];\n    long[] prefSum = new long[maxVal + 1];\n\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    for (int i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    long res = 0;\n    for (int x = 1; x <= maxVal; x++) {\n        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return (int) res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ",
        "python": "\n    ```python\ndef sum_of_floored_pairs(nums):\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint sumOfFlooredPairs(std::vector<int>& nums) {\n    int mod = 1e9 + 7;\n    int maxVal = *max_element(nums.begin(), nums.end());\n    std::vector<int> count(maxVal + 1, 0);\n    std::vector<long long> prefSum(maxVal + 1, 0);\n\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    for (int i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    long long res = 0;\n    for (int x = 1; x <= maxVal; x++) {\n        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    ",
        "js": "\n    ```javascript\nfunction sumOfFlooredPairs(nums) {\n    const mod = 1e9 + 7;\n    const maxVal = Math.max(...nums);\n    const count = Array(maxVal + 1).fill(0);\n    const prefSum = Array(maxVal + 1).fill(0);\n\n    for (let num of nums) {\n        count[num]++;\n    }\n\n    for (let i = 1; i <= maxVal; i++) {\n        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;\n    }\n\n    let res = 0;\n    for (let x = 1; x <= maxVal; x++) {\n        for (let k = 1, nx = x; nx <= maxVal; k++, nx += x) {\n            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm first calculates the maximum value present in the array named maxVal. Then it initializes two other arrays: count and prefSum of size (maxVal + 1). The count array stores the frequency count of numbers in the input array, and prefSum stores the prefix sum of count array modulo mod (10^9 + 7).\n\nThe main logic is implemented using nested loops. The outer loop iterates through each unique number (x) in the input array, and the inner loop generates multiples of that number (nx) within the range of the maximum value. For each nx, calculate the result as the product of count[x], k, and the sum of the prefSum values within the range (nx - x) and nx modulo mod. The final result is obtained by summing these products modulo mod for every possible pair of numbers in the input array.\n\nThe time complexity of the algorithm is O(maxVal^2) where maxVal is the maximum value in the input array nums. The space complexity is O(maxVal) due to the count and prefSum arrays.\n    "
    },
    {
        "id": 208,
        "title": "Reverse Subarray To Maximize Array Value",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums`. The _value_ of this array is defined as the sum of `|nums[i] - nums[i + 1]|` for all `0 <= i < nums.length - 1`.\n\nYou are allowed to select any subarray of the given array and reverse it. You can perform this operation **only once**.\n\nFind maximum possible value of the final array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,1,5,4\\]\n**Output:** 10\n**Explanation:** By reversing the subarray \\[3,1,5\\] the array becomes \\[2,5,1,3,4\\] whose value is 10.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,4,9,24,2,1,10\\]\n**Output:** 68"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "[2,3,1,5,4]",
                "output": "10"
            },
            {
                "input": "[2,4,9,24,2,1,10]",
                "output": "68"
            }
        ],
        "java": "\n    ```java\npublic int longestSubsequence(int[] arr, int difference) {\n    HashMap<Integer, Integer> dp = new HashMap<>();\n    int maxLength = 0;\n    for (int num : arr) {\n        dp.put(num, dp.getOrDefault(num - difference, 0) + 1);\n        maxLength = Math.max(maxLength, dp.get(num));\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    ",
        "python": "\n    ```python\ndef longestSubsequence(arr, difference):\n    dp = {}\n    maxLength = 0\n    for num in arr:\n        dp[num] = dp.get(num - difference, 0) + 1\n        maxLength = max(maxLength, dp[num])\n    return maxLength\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    ",
        "c++": "\n    ```cpp\nint longestSubsequence(vector<int>& arr, int difference) {\n    unordered_map<int, int> dp;\n    int maxLength = 0;\n    for (int num : arr) {\n        dp[num] = dp[num - difference] + 1;\n        maxLength = max(maxLength, dp[num]);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    ",
        "js": "\n    ```javascript\nfunction longestSubsequence(arr, difference) {\n    const dp = new Map();\n    let maxLength = 0;\n    for (let num of arr) {\n        dp.set(num, (dp.get(num - difference) || 0) + 1);\n        maxLength = Math.max(maxLength, dp.get(num));\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm creates a hashmap to store the maximum length of the arithmetic subsequence with difference \"difference\" ending at each element of the array. We iterate through each element in the array, calculate the length of the arithmetic subsequence ending at the current number, and update the hashmap accordingly. During the loop, we also keep track of the maximum length of the arithmetic subsequence seen so far. At the end of the loop, we return the maxLength.\n\nThe time complexity of this algorithm is O(n), where n is the length of the array \"arr\".\n    "
    },
    {
        "id": 209,
        "title": "Minimum Difficulty of a Job Schedule",
        "difficulty": "Hard",
        "content": {
            "problem": "You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `ith` job, you have to finish all the jobs `j` where `0 <= j < i`).\n\nYou have to finish **at least** one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array `jobDifficulty` and an integer `d`. The difficulty of the `ith` job is `jobDifficulty[i]`.\n\nReturn _the minimum difficulty of a job schedule_. If you cannot find a schedule for the jobs return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** jobDifficulty = \\[6,5,4,3,2,1\\], d = 2\n**Output:** 7\n**Explanation:** First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\n",
                "**Example 2:**\n\n**Input:** jobDifficulty = \\[9,9,9\\], d = 4\n**Output:** -1\n**Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\n",
                "**Example 3:**\n\n**Input:** jobDifficulty = \\[1,1,1\\], d = 3\n**Output:** 3\n**Explanation:** The schedule is one job per day. total difficulty will be 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= jobDifficulty.length <= 300`\n*   `0 <= jobDifficulty[i] <= 1000`\n*   `1 <= d <= 10`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[6,5,4,3,2,1],2",
                "output": "7"
            },
            {
                "input": "[9,9,9],4",
                "output": "-1"
            },
            {
                "input": "[1,1,1],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int maxCandies(int[] candies, int k) {\n    int left = 1;\n    int right = 0;\n\n    for (int candy : candies) {\n        right = Math.max(right, candy);\n    }\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int count = 0;\n        for (int candy : candies) {\n            count += candy / mid;\n        }\n        if (count >= k) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    ",
        "python": "\n    ```python\ndef max_candies(candies, k):\n    left, right = 1, max(candies)\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        count = sum(candy // mid for candy in candies)\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxCandies(const std::vector<int>& candies, int k) {\n    int left = 1;\n    int right = *std::max_element(candies.begin(), candies.end());\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int count = 0;\n        for (int candy : candies) {\n            count += candy / mid;\n        }\n        if (count >= k) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    ",
        "js": "\n    ```javascript\nfunction maxCandies(candies, k) {\n    let left = 1;\n    let right = Math.max(...candies);\n\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        let count = candies.reduce((acc, candy) => acc + Math.floor(candy / mid), 0);\n        if (count >= k) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n```\n    \n    We can use binary search to find the maximum number of candies. Initialize two pointers `left` and `right` with values 1 and the maximum value in the candies array, respectively. \n\nWhile `left` is smaller or equal to `right`, calculate the middle value `mid`, which is the current number of candies to be distributed per child. Then calculate the number of children that can be given `mid` candies by dividing each `candies[i]` by `mid` and summing the values. \n\nIf the sum is greater or equal to `k`, it means that we can give the current `mid` value of candies to `k` children or more, so we can try increasing the candy count by setting `left` to `mid + 1`. If the sum is less than `k`, it means we cannot give `mid` candies to `k` children, so we set `right` to `mid - 1`.\n\nThe binary search ends when `left` is greater than `right`, and we return the value of `right`, which is the maximum number of candies per child that can be distributed to `k` children.\n    "
    },
    {
        "id": 210,
        "title": "Jump Game V",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:\n\n*   `i + x` where: `i + x < arr.length` and `0 < x <= d`.\n*   `i - x` where: `i - x >= 0` and `0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum number of indices_ you can visit.\n\nNotice that you can not jump outside of the array at any time.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[6,4,14,6,8,13,9,7,10,6,12\\], d = 2\n**Output:** 4\n**Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[3,3,3,3,3\\], d = 3\n**Output:** 1\n**Explanation:** You can start at any index. You always cannot jump to any index.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[7,6,5,4,3,2,1\\], d = 1\n**Output:** 7\n**Explanation:** Start at index 0. You can visit all the indicies."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 105`\n*   `1 <= d <= arr.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[6,4,14,6,8,13,9,7,10,6,12],2",
                "output": "4"
            },
            {
                "input": "[3,3,3,3,3],3",
                "output": "1"
            },
            {
                "input": "[7,6,5,4,3,2,1],1",
                "output": "7"
            }
        ],
        "java": "\n    ```java\nimport java.util.concurrent.locks.*;\n\nclass DiningPhilosophers {\n    private final ReentrantLock[] locks = new ReentrantLock[5];\n    private final Condition[] notBusy = new Condition[5];\n\n    public DiningPhilosophers() {\n        for (int i = 0; i < 5; i++) {\n            locks[i] = new ReentrantLock();\n            notBusy[i] = locks[i].newCondition();\n        }\n    }\n\n    public void wantsToEat(int philosopher,\n                            Runnable pickLeftFork,\n                            Runnable pickRightFork,\n                            Runnable eat,\n                            Runnable putLeftFork,\n                            Runnable putRightFork) throws InterruptedException {\n        int leftFork = philosopher;\n        int rightFork = (philosopher + 1) % 5;\n\n        locks[leftFork].lock();\n        try {\n            while (!locks[rightFork].tryLock()) {\n                notBusy[leftFork].await();\n            }\n            pickLeftFork.run();\n\n            try {\n                pickRightFork.run();\n                eat.run();\n                putRightFork.run();\n            } finally {\n                locks[rightFork].unlock();\n            }\n            notBusy[rightFork].signalAll();\n\n            putLeftFork.run();\n        } finally {\n            locks[leftFork].unlock();\n        }\n        notBusy[leftFork].signalAll();\n    }\n}\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    ",
        "python": "\n    ```python\nimport threading\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    ",
        "c++": "\n    ```cpp\n#include <mutex>\n#include <condition_variable>\n\nclass DiningPhilosophers {\n    std::mutex forks[5];\n    std::condition_variable not_busy[5];\n\npublic:\n    void wantsToEat(int philosopher,\n                    std::function<void()> pickLeftFork,\n                    std::function<void()> pickRightFork,\n                    std::function<void()> eat,\n                    std::function<void()> putLeftFork,\n                    std::function<void()> putRightFork) {\n        int left_fork = philosopher;\n        int right_fork = (philosopher + 1) % 5;\n\n        {\n            std::unique_lock<std::mutex> lock(forks[left_fork]);\n            not_busy[left_fork].wait(lock, [&] { return !forks[right_fork].try_lock(); });\n            pickLeftFork();\n\n            std::unique_lock<std::mutex> right_lock(forks[right_fork], std::adopt_lock);\n            pickRightFork();\n            eat();\n\n            putRightFork();\n            right_lock.unlock();\n            not_busy[right_fork].notify_all();\n        }\n\n        putLeftFork();\n        not_busy[left_fork].notify_all();\n    }\n};\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    ",
        "js": "\n    ```javascript\nclass DiningPhilosophers {\n    constructor() {\n        this.forks = Array.from({ length: 5 }, () => new Mutex());\n        this.notBusy = Array.from({ length: 5 }, (_, i) => new ConditionVariable(this.forks[i]));\n    }\n\n    async wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) {\n        const leftFork = philosopher;\n        const rightFork = (philosopher + 1) % 5;\n\n        await this.forks[leftFork].lock();\n        try {\n            await this.notBusy[leftFork].wait(async () => !(await this.forks[rightFork].tryLock()));\n            pickLeftFork();\n\n            try {\n                await this.forks[rightFork].lock();\n                pickRightFork();\n                eat();\n                putRightFork();\n                this.forks[rightFork].unlock();\n                this.notBusy[rightFork].signalAll();\n\n                putLeftFork();\n            } finally {\n                this.forks[leftFork].unlock();\n            }\n        } finally {\n            this.notBusy[leftFork].signalAll();\n        }\n    }\n}\n```\n    \n    The algorithm uses one mutex for each fork and a condition variable for each philosopher to manage the synchronization of accessing forks. When a philosopher starts to eat, they first lock the mutex of the left fork and indicate that the corresponding fork is busy. After that, they try to lock the mutex of the right fork. If they are able to lock the right mutex, they can eat. After eating, they release the mutex of the right fork and indicate that it is not busy. Finally, the mutex of the left fork is unlocked.\n\nTo avoid deadlocks, a philosopher will only proceed with eating if they can lock the mutex of the right fork while holding the mutex of the left fork. If they can't lock the right mutex, they will wait using a condition variable until the right mutex is available. After eating, the philosopher will signal to other philosophers that they have finished eating and the forks are available.\n\nThe main idea of this approach is to ensure that a philosopher is always able to acquire both forks without causing deadlocks or starving. By waiting on the condition variable until both forks are available, we prevent deadlocks and ensure fairness among the philosophers. This behavior is obtained by having each philosopher try to grab its left fork first and then its right fork, only eating once it has acquired both. This ensures that philosophers will not deadlock by all grabbing one fork and waiting for another.\n    "
    },
    {
        "id": 211,
        "title": "Jump Game IV",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of integers `arr`, you are initially positioned at the first index of the array.\n\nIn one step you can jump from index `i` to index:\n\n*   `i + 1` where: `i + 1 < arr.length`.\n*   `i - 1` where: `i - 1 >= 0`.\n*   `j` where: `arr[i] == arr[j]` and `i != j`.\n\nReturn _the minimum number of steps_ to reach the **last index** of the array.\n\nNotice that you can not jump outside of the array at any time.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[100,-23,-23,404,100,23,23,23,3,404\\]\n**Output:** 3\n**Explanation:** You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[7\\]\n**Output:** 0\n**Explanation:** Start index is the last index. You do not need to jump.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[7,6,9,6,9,6,9,7\\]\n**Output:** 1\n**Explanation:** You can jump directly from index 0 to index 7 which is last index of the array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 5 * 104`\n*   `-108 <= arr[i] <= 108`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Breadth-First Search"
        ],
        "example": [
            {
                "input": "[100,-23,-23,404,100,23,23,23,3,404]",
                "output": "3"
            },
            {
                "input": "[7]",
                "output": "0"
            },
            {
                "input": "[7,6,9,6,9,6,9,7]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int minJumps(int[] arr) {\n    int n = arr.length;\n    if (n <= 1) return 0;\n\n    HashMap<Integer, LinkedList<Integer>> valueIndices = new HashMap<>();\n    \n    for (int i = 0; i < n; ++i) {\n        valueIndices.computeIfAbsent(arr[i], v -> new LinkedList<>()).add(i);\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    boolean[] visited = new boolean[n];\n    \n    queue.offer(0);\n    visited[0] = true;\n    int steps = 0;\n    \n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        \n        for (int i = 0; i < size; ++i) {\n            int index = queue.poll();\n            \n            if (index == n - 1) return steps;\n            \n            if (index > 0 && !visited[index - 1]) {\n                queue.offer(index - 1);\n                visited[index - 1] = true;\n            }\n            \n            if (index < n - 1 && !visited[index + 1]) {\n                queue.offer(index + 1);\n                visited[index + 1] = true;\n            }\n\n            for (int neighbor : valueIndices.get(arr[index])) {\n                if (!visited[neighbor]) {\n                    queue.offer(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n            \n            valueIndices.get(arr[index]).clear();\n        }\n        \n        ++steps;\n    }\n\n    return -1;\n}\n```\n    \n    The algorithm to solve this problem is using the Breadth-First Search (BFS) approach.\n\n1. First, iterate through the `arr` and create a hash map (`value_indices`) to map each unique value to their indices in the array.\n2. Initialize the BFS queue `q`, the visited array `visited`, and steps counter `steps`.\n3. While queue `q` is not empty, perform the following:\n   a. Set the `size` variable as the current length of the queue `q`.\n   b. Iterate through the `size` of the queue `q`. For each iteration:\n      i. Pop the front of the queue `q` and assign the popped index to `index`.\n      ii. If the popped index is the last index of the array, return the steps counter.\n      iii. Check the valid neighbors `(index-1, index+1, or the same value as arr[index])` that haven't been visited yet:\n         - If it's a valid neighbor and not visited before, mark the neighbor as visited and push the neighbor to the queue `q`.\n      iv. Clear the value_indices entry for this index, as we don't want to revisit it.\n   c. Increase the steps counter by 1.\n4. If the last index is not reached, return -1. (This will not happen in the given constraints)\n\nIn each programming language, the major difference is in the syntax and data structures used to implement this algorithm. The key points of the language-specific implementations are as follows:\n\n- In C++, we use `std::vector`, `std::queue`, `std::unordered_map`, and `std::vector<bool>` for array manipulation and storage.\n- In Java, we use `java.util.HashMap`, `java.util.LinkedList` for both queue and mapping values, and a boolean array for storing visited status.\n- In Python, we use Python's `list` and `collections.defaultdict` for mapping values and storing visited status.\n- In JavaScript, we use a `Map` and `Array` objects to implement the algorithm.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef minJumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    value_indices = defaultdict(list)\n    \n    for i, value in enumerate(arr):\n        value_indices[value].append(i)\n\n    q = [0]\n    visited = [False] * n\n    visited[0] = True\n    steps = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            index = q.pop(0)\n            \n            if index == n - 1:\n                return steps\n            \n            if index > 0 and not visited[index - 1]:\n                q.append(index - 1)\n                visited[index - 1] = True\n                \n            if index < n - 1 and not visited[index + 1]:\n                q.append(index + 1)\n                visited[index + 1] = True\n\n            for neighbor in value_indices[arr[index]]:\n                if not visited[neighbor]:\n                    q.append(neighbor)\n                    visited[neighbor] = True\n            \n            value_indices[arr[index]] = []\n\n        steps += 1\n\n    return -1\n```\n    \n    The algorithm to solve this problem is using the Breadth-First Search (BFS) approach.\n\n1. First, iterate through the `arr` and create a hash map (`value_indices`) to map each unique value to their indices in the array.\n2. Initialize the BFS queue `q`, the visited array `visited`, and steps counter `steps`.\n3. While queue `q` is not empty, perform the following:\n   a. Set the `size` variable as the current length of the queue `q`.\n   b. Iterate through the `size` of the queue `q`. For each iteration:\n      i. Pop the front of the queue `q` and assign the popped index to `index`.\n      ii. If the popped index is the last index of the array, return the steps counter.\n      iii. Check the valid neighbors `(index-1, index+1, or the same value as arr[index])` that haven't been visited yet:\n         - If it's a valid neighbor and not visited before, mark the neighbor as visited and push the neighbor to the queue `q`.\n      iv. Clear the value_indices entry for this index, as we don't want to revisit it.\n   c. Increase the steps counter by 1.\n4. If the last index is not reached, return -1. (This will not happen in the given constraints)\n\nIn each programming language, the major difference is in the syntax and data structures used to implement this algorithm. The key points of the language-specific implementations are as follows:\n\n- In C++, we use `std::vector`, `std::queue`, `std::unordered_map`, and `std::vector<bool>` for array manipulation and storage.\n- In Java, we use `java.util.HashMap`, `java.util.LinkedList` for both queue and mapping values, and a boolean array for storing visited status.\n- In Python, we use Python's `list` and `collections.defaultdict` for mapping values and storing visited status.\n- In JavaScript, we use a `Map` and `Array` objects to implement the algorithm.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nint minJumps(std::vector<int>& arr) {\n    int n = arr.size();\n    if (n <= 1) return 0;\n    \n    std::unordered_map<int, std::vector<int>> value_indices;\n    for (int i = 0; i < n; ++i) {\n        value_indices[arr[i]].push_back(i);\n    }\n    \n    std::queue<int> q;\n    std::vector<bool> visited(n, false);\n    \n    q.push(0);\n    visited[0] = true;\n    int steps = 0;\n    \n    while (!q.empty()) {\n        int size = q.size();\n        \n        for (int i = 0; i < size; ++i) {\n            int index = q.front();\n            q.pop();\n            \n            if (index == n - 1) return steps;\n            \n            if (index > 0 && !visited[index - 1]) {\n                q.push(index - 1);\n                visited[index - 1] = true;\n            }\n            \n            if (index < n - 1 && !visited[index + 1]) {\n                q.push(index + 1);\n                visited[index + 1] = true;\n            }\n            \n            for (int neighbor : value_indices[arr[index]]) {\n                if (!visited[neighbor]) {\n                    q.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n            \n            value_indices[arr[index]].clear();\n        }\n        \n        ++steps;\n    }\n    \n    return -1;\n}\n```\n    \n    The algorithm to solve this problem is using the Breadth-First Search (BFS) approach.\n\n1. First, iterate through the `arr` and create a hash map (`value_indices`) to map each unique value to their indices in the array.\n2. Initialize the BFS queue `q`, the visited array `visited`, and steps counter `steps`.\n3. While queue `q` is not empty, perform the following:\n   a. Set the `size` variable as the current length of the queue `q`.\n   b. Iterate through the `size` of the queue `q`. For each iteration:\n      i. Pop the front of the queue `q` and assign the popped index to `index`.\n      ii. If the popped index is the last index of the array, return the steps counter.\n      iii. Check the valid neighbors `(index-1, index+1, or the same value as arr[index])` that haven't been visited yet:\n         - If it's a valid neighbor and not visited before, mark the neighbor as visited and push the neighbor to the queue `q`.\n      iv. Clear the value_indices entry for this index, as we don't want to revisit it.\n   c. Increase the steps counter by 1.\n4. If the last index is not reached, return -1. (This will not happen in the given constraints)\n\nIn each programming language, the major difference is in the syntax and data structures used to implement this algorithm. The key points of the language-specific implementations are as follows:\n\n- In C++, we use `std::vector`, `std::queue`, `std::unordered_map`, and `std::vector<bool>` for array manipulation and storage.\n- In Java, we use `java.util.HashMap`, `java.util.LinkedList` for both queue and mapping values, and a boolean array for storing visited status.\n- In Python, we use Python's `list` and `collections.defaultdict` for mapping values and storing visited status.\n- In JavaScript, we use a `Map` and `Array` objects to implement the algorithm.\n    ",
        "js": "\n    ```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nfunction minJumps(arr) {\n  const n = arr.length;\n  if (n <= 1) return 0;\n\n  const valueIndices = new Map();\n\n  for (let i = 0; i < n; ++i) {\n    if (!valueIndices.has(arr[i])) valueIndices.set(arr[i], []);\n    valueIndices.get(arr[i]).push(i);\n  }\n\n  const q = [0];\n  const visited = new Array(n).fill(false);\n  visited[0] = true;\n  let steps = 0;\n\n  while (q.length) {\n    const size = q.length;\n\n    for (let i = 0; i < size; ++i) {\n      const index = q.shift();\n\n      if (index === n - 1) return steps;\n\n      if (index > 0 && !visited[index - 1]) {\n        q.push(index - 1);\n        visited[index - 1] = true;\n      }\n\n      if (index < n - 1 && !visited[index + 1]) {\n        q.push(index + 1);\n        visited[index + 1] = true;\n      }\n\n      for (const neighbor of valueIndices.get(arr[index])) {\n        if (!visited[neighbor]) {\n          q.push(neighbor);\n          visited[neighbor] = true;\n        }\n      }\n\n      valueIndices.set(arr[index], []);\n    }\n\n    ++steps;\n  }\n\n  return -1;\n}\n```\n    \n    The algorithm to solve this problem is using the Breadth-First Search (BFS) approach.\n\n1. First, iterate through the `arr` and create a hash map (`value_indices`) to map each unique value to their indices in the array.\n2. Initialize the BFS queue `q`, the visited array `visited`, and steps counter `steps`.\n3. While queue `q` is not empty, perform the following:\n   a. Set the `size` variable as the current length of the queue `q`.\n   b. Iterate through the `size` of the queue `q`. For each iteration:\n      i. Pop the front of the queue `q` and assign the popped index to `index`.\n      ii. If the popped index is the last index of the array, return the steps counter.\n      iii. Check the valid neighbors `(index-1, index+1, or the same value as arr[index])` that haven't been visited yet:\n         - If it's a valid neighbor and not visited before, mark the neighbor as visited and push the neighbor to the queue `q`.\n      iv. Clear the value_indices entry for this index, as we don't want to revisit it.\n   c. Increase the steps counter by 1.\n4. If the last index is not reached, return -1. (This will not happen in the given constraints)\n\nIn each programming language, the major difference is in the syntax and data structures used to implement this algorithm. The key points of the language-specific implementations are as follows:\n\n- In C++, we use `std::vector`, `std::queue`, `std::unordered_map`, and `std::vector<bool>` for array manipulation and storage.\n- In Java, we use `java.util.HashMap`, `java.util.LinkedList` for both queue and mapping values, and a boolean array for storing visited status.\n- In Python, we use Python's `list` and `collections.defaultdict` for mapping values and storing visited status.\n- In JavaScript, we use a `Map` and `Array` objects to implement the algorithm.\n    "
    },
    {
        "id": 212,
        "title": "Maximum Students Taking Exam",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `m * n` matrix `seats` that represent seats distributions in a classroom. If a seat is broken, it is denoted by `'#'` character otherwise it is denoted by a `'.'` character.\n\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the **maximum** number of students that can take the exam together without any cheating being possible..\n\nStudents must be placed in seats in good condition.",
            "examples": [
                "**Example 1:**\n\n**Input:** seats = \\[\\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\],\n                \\[ \". \", \"# \", \"# \", \"# \", \"# \", \". \"\\],\n                \\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\]\\]\n**Output:** 4\n**Explanation:** Teacher can place 4 students in available seats so they don't cheat on the exam. \n\n",
                "**Example 2:**\n\n**Input:** seats = \\[\\[ \". \", \"# \"\\],\n                \\[ \"# \", \"# \"\\],\n                \\[ \"# \", \". \"\\],\n                \\[ \"# \", \"# \"\\],\n                \\[ \". \", \"# \"\\]\\]\n**Output:** 3\n**Explanation:** Place all students in available seats. \n\n",
                "**Example 3:**\n\n**Input:** seats = \\[\\[ \"# \", \". \", \"**.** \", \". \", \"# \"\\],\n                \\[ \"**.** \", \"# \", \"**.** \", \"# \", \"**.** \"\\],\n                \\[ \"**.** \", \". \", \"# \", \". \", \"**.** \"\\],\n                \\[ \"**.** \", \"# \", \"**.** \", \"# \", \"**.** \"\\],\n                \\[ \"# \", \". \", \"**.** \", \". \", \"# \"\\]\\]\n**Output:** 10\n**Explanation:** Place students in available seats in column 1, 3 and 5."
            ],
            "constraints": "**Constraints:**\n\n*   `seats` contains only characters `'.' and``'#'.`\n*   `m == seats.length`\n*   `n == seats[i].length`\n*   `1 <= m <= 8`\n*   `1 <= n <= 8`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Matrix",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n[\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n[\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]",
                "output": "4"
            },
            {
                "input": "[[\".\",\"#\"],\n[\"#\",\"#\"],\n[\"#\",\".\"],\n[\"#\",\"#\"],\n[\".\",\"#\"]]",
                "output": "3"
            },
            {
                "input": "[[\"#\",\".\",\"**.**\",\".\",\"#\"],\n[\"**.**\",\"#\",\"**.**\",\"#\",\"**.**\"],\n[\"**.**\",\".\",\"#\",\".\",\"**.**\"],\n[\"**.**\",\"#\",\"**.**\",\"#\",\"**.**\"],\n[\"#\",\".\",\"**.**\",\".\",\"#\"]]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\nclass Solution {\n    public boolean checkStraightLine(int[][] coordinates) {\n        int dx = coordinates[1][0] - coordinates[0][0];\n        int dy = coordinates[1][1] - coordinates[0][1];\n\n        for(int i = 2; i < coordinates.length; i++) {\n            int x = coordinates[i][0] - coordinates[0][0];\n            int y = coordinates[i][1] - coordinates[0][1];\n            if(dx * y != dy * x) return false;\n        }\n\n        return true;\n    }\n}\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef checkStraightLine(coordinates: List[List[int]]) -> bool:\n    dx = coordinates[1][0] - coordinates[0][0]\n    dy = coordinates[1][1] - coordinates[0][1]\n\n    for x, y in coordinates[2:]:\n        if dx * (y - coordinates[0][1]) != dy * (x - coordinates[0][0]):\n            return False\n\n    return True\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool checkStraightLine(vector<vector<int>>& coordinates) {\n    int dx = coordinates[1][0] - coordinates[0][0];\n    int dy = coordinates[1][1] - coordinates[0][1];\n\n    for(int i = 2; i < coordinates.size(); ++i) {\n        int x = coordinates[i][0] - coordinates[0][0];\n        int y = coordinates[i][1] - coordinates[0][1];\n        if(dx * y != dy * x) return false;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    ",
        "js": "\n    ```javascript\nvar checkStraightLine = function(coordinates) {\n    let dx = coordinates[1][0] - coordinates[0][0];\n    let dy = coordinates[1][1] - coordinates[0][1];\n\n    for(let i = 2; i < coordinates.length; i++) {\n        let x = coordinates[i][0] - coordinates[0][0];\n        let y = coordinates[i][1] - coordinates[0][1];\n        if(dx * y != dy * x) return false;\n    }\n\n    return true;\n};\n```\n    \n    The algorithm checks if the given points make a straight line in the XY plane. It calculates the slope (delta y / delta x) between the first two points in the array, and then iterates through the rest of the points comparing their slopes against the calculated slope. This is done by checking if `(dx * y) == (dy * x)` for each point. If any point has a different slope, return false (meaning the points don't make a straight line). If all points have the same slope, return true (meaning the points make a straight line).\n    "
    },
    {
        "id": 213,
        "title": "Construct Target Array With Multiple Sums",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `target` of n integers. From a starting array `arr` consisting of `n` 1's, you may perform the following procedure :\n\n*   let `x` be the sum of all elements currently in your array.\n*   choose index `i`, such that `0 <= i < n` and set the value of `arr` at index `i` to `x`.\n*   You may repeat this procedure as many times as needed.\n\nReturn `true` _if it is possible to construct the_ `target` _array from_ `arr`_, otherwise, return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = \\[9,3,5\\]\n**Output:** true\n**Explanation:** Start with arr = \\[1, 1, 1\\] \n\\[1, 1, 1\\], sum = 3 choose index 1\n\\[1, 3, 1\\], sum = 5 choose index 2\n\\[1, 3, 5\\], sum = 9 choose index 0\n\\[9, 3, 5\\] Done\n\n",
                "**Example 2:**\n\n**Input:** target = \\[1,1,1,2\\]\n**Output:** false\n**Explanation:** Impossible to create target array from \\[1,1,1,1\\].\n\n",
                "**Example 3:**\n\n**Input:** target = \\[8,5\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `n == target.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= target[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[9,3,5]",
                "output": "true"
            },
            {
                "input": "[1,1,1,2]",
                "output": "false"
            },
            {
                "input": "[8,5]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<List<Integer>> winnersAndLosers(int[][] matches) {\n    TreeSet<Integer> winners = new TreeSet<>();\n    TreeSet<Integer> losers = new TreeSet<>();\n    for (int[] match : matches) {\n        winners.add(match[0]);\n        losers.add(match[1]);\n    }\n    return Arrays.asList(new ArrayList<>(winners), new ArrayList<>(losers));\n}\n```\n    \n    The algorithm first initializes two sorted sets - one for winners and one for losers.\n\nFor each match in the input, we extract the winner and loser and insert them into their respective sorted sets. Sorted sets automatically maintain the ordering and uniqueness of elements.\n\nFinally, we convert the sorted sets to arrays/lists in their respective languages and return an array/list containing two arrays/lists - the winners and the losers - each sorted in increasing order.\n    ",
        "python": "\n    ```python\nfrom sortedcontainers import SortedSet\n\ndef winners_and_losers(matches):\n    winners, losers = SortedSet(), SortedSet()\n\n    for winner, loser in matches:\n        winners.add(winner)\n        losers.add(loser)\n\n    return [list(winners), list(losers)]\n```\n    \n    The algorithm first initializes two sorted sets - one for winners and one for losers.\n\nFor each match in the input, we extract the winner and loser and insert them into their respective sorted sets. Sorted sets automatically maintain the ordering and uniqueness of elements.\n\nFinally, we convert the sorted sets to arrays/lists in their respective languages and return an array/list containing two arrays/lists - the winners and the losers - each sorted in increasing order.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<vector<int>> winnersAndLosers(vector<vector<int>>& matches) {\n    set<int> winners, losers;\n    for (vector<int> &match : matches) {\n        winners.insert(match[0]);\n        losers.insert(match[1]);\n    }\n    return {vector<int>(winners.begin(), winners.end()), vector<int>(losers.begin(), losers.end())};\n}\n```\n    \n    The algorithm first initializes two sorted sets - one for winners and one for losers.\n\nFor each match in the input, we extract the winner and loser and insert them into their respective sorted sets. Sorted sets automatically maintain the ordering and uniqueness of elements.\n\nFinally, we convert the sorted sets to arrays/lists in their respective languages and return an array/list containing two arrays/lists - the winners and the losers - each sorted in increasing order.\n    ",
        "js": "\n    ```javascript\nfunction winnersAndLosers(matches) {\n    const winners = new Set();\n    const losers = new Set();\n\n    for (const match of matches) {\n        winners.add(match[0]);\n        losers.add(match[1]);\n    }\n\n    return [Array.from(winners).sort((a, b) => a - b), Array.from(losers).sort((a, b) => a - b)];\n}\n```\n    \n    The algorithm first initializes two sorted sets - one for winners and one for losers.\n\nFor each match in the input, we extract the winner and loser and insert them into their respective sorted sets. Sorted sets automatically maintain the ordering and uniqueness of elements.\n\nFinally, we convert the sorted sets to arrays/lists in their respective languages and return an array/list containing two arrays/lists - the winners and the losers - each sorted in increasing order.\n    "
    },
    {
        "id": 214,
        "title": "Count All Valid Pickup and Delivery Options",
        "difficulty": "Hard",
        "content": {
            "problem": "Given `n` orders, each order consist in pickup and delivery services.\n\nCount all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).\n\nSince the answer may be too large, return it modulo 10^9 + 7.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 6\n**Explanation:** All possible orders: \n(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\nThis is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n\n",
                "**Example 3:**\n\n**Input:** n = 3\n**Output:** 90"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 500`\n\nGiven 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that : p\\[0\\] = start, p\\[i\\] and p\\[i+1\\] differ by only one bit for all 0 <= i < 2^n - 1.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "1",
                "output": "1"
            },
            {
                "input": "2",
                "output": "6"
            },
            {
                "input": "3",
                "output": "90"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic static ArrayList<Integer> circularPermutation(int n, int start) {\n    ArrayList<Integer> result = new ArrayList<>(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n        result.add(start ^ (i ^ (i >> 1)));\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    ",
        "python": "\n    ```python\ndef circular_permutation(n, start):\n    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]\n    return result\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> circularPermutation(int n, int start) {\n    std::vector<int> result(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n        result[i] = start ^ (i ^ (i >> 1));\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    ",
        "js": "\n    ```javascript\nfunction circularPermutation(n, start) {\n    let result = new Array(1 << n);\n    for (let i = 0; i < (1 << n); ++i) {\n        result[i] = start ^ (i ^ (i >> 1));\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is based on the Gray Code sequence generation, which guarantees only one bit difference between consecutive elements.\n\n1. Initialize a list or an array called result with the size of 2^n.\n2. Iterate through the range 0 to 2^n - 1.\n3. For each i in the range, calculate the Gray Code with the formula `i ^ (i >> 1)`.\n4. XOR the Gray Code with the given start value and store it in the result array.\n5. Return the result array.\n\nThis algorithm generates a sequence that fulfills the given requirements of having a one-bit difference between consecutive elements and it starts with the provided start value.\n    "
    },
    {
        "id": 215,
        "title": "Largest Multiple of Three",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of digits `digits`, return _the largest multiple of **three** that can be formed by concatenating some of the given digits in **any order**_. If there is no answer return an empty string.\n\nSince the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits = \\[8,1,9\\]\n**Output:**  \"981 \"\n\n",
                "**Example 2:**\n\n**Input:** digits = \\[8,6,7,1,0\\]\n**Output:**  \"8760 \"\n\n",
                "**Example 3:**\n\n**Input:** digits = \\[1\\]\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= digits.length <= 104`\n*   `0 <= digits[i] <= 9`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[8,1,9]",
                "output": "\"981\""
            },
            {
                "input": "[8,6,7,1,0]",
                "output": "\"8760\""
            },
            {
                "input": "[1]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String largestMultipleOfThree(int[] digits) {\n    Arrays.sort(digits);\n    int sum = 0;\n    for (int digit : digits) {\n        sum += digit;\n    }\n\n    if (sum % 3 == 0) {\n        if (digits[0] == 0) return \"0\";\n        StringBuilder result = new StringBuilder();\n        for (int i = digits.length - 1; i >= 0; --i) {\n            result.append(digits[i]);\n        }\n        return result.toString();\n    }\n\n    List<Integer>[] mod = new List[3];\n    for (int i = 0; i < 3; ++i) {\n        mod[i] = new ArrayList<Integer>();\n    }\n    for (int digit : digits) {\n        mod[digit % 3].add(digit);\n    }\n\n    if (sum % 3 == 1) {\n        if (!mod[1].isEmpty()) {\n            mod[1].remove(mod[1].size() - 1);\n        } else {\n            mod[2].remove(mod[2].size() - 1);\n            mod[2].remove(mod[2].size() - 1);\n        }\n    } else {\n        if (!mod[2].isEmpty()) {\n            mod[2].remove(mod[2].size() - 1);\n        } else {\n            mod[1].remove(mod[1].size() - 1);\n            mod[1].remove(mod[1].size() - 1);\n        }\n    }\n\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < 3; ++i) {\n        for (int digit : mod[i]) {\n            result.append(digit);\n        }\n    }\n\n    result.reverse();\n    if (result.length() == 0 || result.charAt(0) == '0') {\n        return \"0\";\n    }\n\n    return result.toString();\n}\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef largest_multiple_of_three(digits):\n    digits.sort(reverse=True)\n    sum_digits = sum(digits)\n\n    if sum_digits % 3 == 0:\n        return '0' if digits[-1] == 0 else ''.join(map(str, digits))\n\n    mod = defaultdict(list)\n    for digit in digits:\n        mod[digit % 3].append(digit)\n\n    if sum_digits % 3 == 1:\n        if mod[1]:\n            mod[1].pop()\n        else:\n            mod[2].pop(), mod[2].pop()\n    else:\n        if mod[2]:\n            mod[2].pop()\n        else:\n            mod[1].pop(), mod[1].pop()\n\n    result = \"\".join(str(digit) for value in mod.values() for digit in value)\n    result = \"\".join(sorted(result, reverse=True))\n\n    return '0' if not result or result[0] == '0' else result\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string largestMultipleOfThree(std::vector<int>& digits) {\n    std::sort(digits.rbegin(), digits.rend());\n    int sum = 0;\n    for (int digit : digits) {\n        sum += digit;\n    }\n\n    if (sum % 3 == 0) {\n        if (digits.back() == 0) return \"0\";\n        std::string result(digits.begin(), digits.end());\n        return result;\n    }\n\n    std::vector<int> mod[3];\n    for (int digit : digits) {\n        mod[digit % 3].push_back(digit);\n    }\n\n    if (sum % 3 == 1) {\n        if (!mod[1].empty()) {\n            mod[1].pop_back();\n        } else {\n            mod[2].pop_back();\n            mod[2].pop_back();\n        }\n    } else {\n        if (!mod[2].empty()) {\n            mod[2].pop_back();\n        } else {\n            mod[1].pop_back();\n            mod[1].pop_back();\n        }\n    }\n\n    std::string result;\n    for (int i = 0; i < 3; ++i) {\n        for (int digit : mod[i]) {\n            result += std::to_string(digit);\n        }\n    }\n\n    std::sort(result.rbegin(), result.rend());\n    if (result.empty() || result[0] == '0') {\n        return \"0\";\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    ",
        "js": "\n    ```javascript\nfunction largestMultipleOfThree(digits) {\n    digits.sort((a, b) => b - a);\n    const sum = digits.reduce((a, b) => a + b, 0);\n\n    if (sum % 3 === 0) {\n        if (digits[digits.length - 1] === 0) return \"0\";\n        return digits.join(\"\");\n    }\n\n    let mod = new Array(3).fill(null).map(() => []);\n    for (let digit of digits) {\n        mod[digit % 3].push(digit);\n    }\n\n    if (sum % 3 === 1) {\n        if (mod[1].length > 0) {\n            mod[1].pop();\n        } else {\n            mod[2].pop(), mod[2].pop();\n        }\n    } else {\n        if (mod[2].length > 0) {\n            mod[2].pop();\n        } else {\n            mod[1].pop(), mod[1].pop();\n        }\n    }\n\n    let result = mod.flat().join(\"\");\n    result = Array.from(result).sort((a, b) => b - a).join(\"\");\n\n    if (!result || result[0] === \"0\") {\n        return \"0\";\n    }\n\n    return result;\n}\n```\n\n    \n    1. Sort the input array in descending order.\n2. Calculate the sum of all digits.\n3. If the sum is divisible by 3, return the joined digits as a string (or \"0\" if the last digit is 0).\n4. Create a mod array where mod[i] contains digits with the remainder i when divided by 3.\n5. If the remainder of the sum is 1:\n    - Remove the smallest digit from mod[1], if not empty.\n    - Otherwise, remove the two smallest digits from mod[2].\n6. If the remainder of the sum is 2:\n    - Remove the smallest digit from mod[2], if not empty.\n    - Otherwise, remove the two smallest digits from mod[1].\n7. Flatten the mod array and join its digits into a string. Sort the string in descending order.\n8. Return the sorted string (or \"0\" if empty or starting with \"0\").\n    "
    },
    {
        "id": 216,
        "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:\n\n*   `1` which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)\n*   `2` which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)\n*   `3` which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)\n*   `4` which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\n\nYou will initially start at the upper left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path does not have to be the shortest.\n\nYou can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell **one time only**.\n\nReturn _the minimum cost to make the grid have at least one valid path_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1,1\\],\\[2,2,2,2\\],\\[1,1,1,1\\],\\[2,2,2,2\\]\\]\n**Output:** 3\n**Explanation:** You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,3\\],\\[3,2,2\\],\\[1,1,4\\]\\]\n**Output:** 0\n**Explanation:** You can follow the path from (0, 0) to (2, 2).\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,2\\],\\[4,3\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `1 <= grid[i][j] <= 4`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Matrix",
            "Shortest Path"
        ],
        "example": [
            {
                "input": "[[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]",
                "output": "3"
            },
            {
                "input": "[[1,1,3],[3,2,2],[1,1,4]]",
                "output": "0"
            },
            {
                "input": "[[1,2],[4,3]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minCost(int[][] grid) {\n        int m = grid.length, n = grid[0].length, cost = 0;\n\n        int[][] visited = new int[m][n];\n        for (int[] row : visited) {\n            Arrays.fill(row, 1000000);\n        }\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0});\n        visited[0][0] = 0;\n\n        while (!q.isEmpty()) {\n            int[] curr = q.poll();\n            int y = curr[0], x = curr[1];\n            if (y == m - 1 && x == n - 1) {\n                cost = visited[y][x];\n                break;\n            }\n\n            int[] dx = {1, 0, -1, 0};\n            int[] dy = {0, 1, 0, -1};\n\n            for (int dir = 0; dir < 4; ++dir) {\n                int newY = y + dy[dir], newX = x + dx[dir];\n                if (0 <= newY && newY < m && 0 <= newX && newX < n) {\n                    int newCost = visited[y][x] + (dir + 1 != grid[y][x] ? 1 : 0);\n                    if (newCost < visited[newY][newX]) {\n                        visited[newY][newX] = newCost;\n                        q.offer(new int[]{newY, newX});\n                    }\n                }\n            }\n        }\n        return cost;\n    }\n}\n```\n    \n    The algorithm performs a breadth-first search traversal based on the current grid directions. For each cell visited (starting at the upper left cell), it checks all four neighboring cells in the grid and calculates the new cost based on the direction. \nIf the direction required to reach the neighboring cell matches the direction in the grid, the cost remains the same, otherwise it increments by 1 (indicating that we have to modify the sign in one cell).\n\nAt each step, the BFS traversal keeps track of visited cells and their corresponding costs. When the bottom-right cell is reached, the function returns the cost of reaching it.\n\nBy using BFS, the traversal ensures that the first time the bottom-right cell is reached is with the minimum cost possible. Since it visits cells in layers, once it reaches the final cell, all cells at the same or lower cost must have already been visited, ensuring the validity of the path.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    cost = 0\n\n    visited = [[1000000] * n for _ in range(m)]\n    q = deque([(0, 0)])\n    visited[0][0] = 0\n\n    while q:\n        y, x = q.popleft()\n        if y == m - 1 and x == n - 1:\n            cost = visited[y][x]\n            break\n\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n\n        for dir in range(4):\n            newY, newX = y + dy[dir], x + dx[dir]\n            if 0 <= newY < m and 0 <= newX < n:\n                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)\n                if newCost < visited[newY][newX]:\n                    visited[newY][newX] = newCost\n                    q.append((newY, newX))\n\n    return cost\n```\n    \n    The algorithm performs a breadth-first search traversal based on the current grid directions. For each cell visited (starting at the upper left cell), it checks all four neighboring cells in the grid and calculates the new cost based on the direction. \nIf the direction required to reach the neighboring cell matches the direction in the grid, the cost remains the same, otherwise it increments by 1 (indicating that we have to modify the sign in one cell).\n\nAt each step, the BFS traversal keeps track of visited cells and their corresponding costs. When the bottom-right cell is reached, the function returns the cost of reaching it.\n\nBy using BFS, the traversal ensures that the first time the bottom-right cell is reached is with the minimum cost possible. Since it visits cells in layers, once it reaches the final cell, all cells at the same or lower cost must have already been visited, ensuring the validity of the path.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint minCost(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size(), cost = 0;\n\n    vector<vector<int>> visited(m, vector<int>(n, 1000000));\n    queue<pair<int, int>> q;\n    q.push({0, 0});\n    visited[0][0] = 0;\n\n    while (!q.empty()) {\n        pair<int, int> curr = q.front();\n        q.pop();\n        int y = curr.first, x = curr.second;\n        if (y == m - 1 && x == n - 1) {\n            cost = visited[y][x];\n            break;\n        }\n\n        int dx[4] = {1, 0, -1, 0};\n        int dy[4] = {0, 1, 0, -1};\n\n        for (int dir = 0; dir < 4; ++dir) {\n            int newY = y + dy[dir], newX = x + dx[dir];\n            if (0 <= newY && newY < m && 0 <= newX && newX < n) {\n                int newCost = visited[y][x] + (dir + 1 != grid[y][x]);\n                if (newCost < visited[newY][newX]) {\n                    visited[newY][newX] = newCost;\n                    q.push({newY, newX});\n                }\n            }\n        }\n    }\n    return cost;\n}\n```\n    \n    The algorithm performs a breadth-first search traversal based on the current grid directions. For each cell visited (starting at the upper left cell), it checks all four neighboring cells in the grid and calculates the new cost based on the direction. \nIf the direction required to reach the neighboring cell matches the direction in the grid, the cost remains the same, otherwise it increments by 1 (indicating that we have to modify the sign in one cell).\n\nAt each step, the BFS traversal keeps track of visited cells and their corresponding costs. When the bottom-right cell is reached, the function returns the cost of reaching it.\n\nBy using BFS, the traversal ensures that the first time the bottom-right cell is reached is with the minimum cost possible. Since it visits cells in layers, once it reaches the final cell, all cells at the same or lower cost must have already been visited, ensuring the validity of the path.\n    ",
        "js": "\n    ```javascript\nvar minCost = function(grid) {\n    let m = grid.length, n = grid[0].length, cost = 0;\n\n    let visited = new Array(m).fill(null).map(() => new Array(n).fill(1000000));\n    let q = [{i: 0, j: 0}];\n    visited[0][0] = 0;\n\n    while (q.length !== 0) {\n        let {i, j} = q.shift();\n        if (i === m - 1 && j === n - 1) {\n            cost = visited[i][j];\n            break;\n        }\n\n        let dx = [1, 0, -1, 0];\n        let dy = [0, 1, 0, -1];\n\n        for (let dir = 0; dir < 4; ++dir) {\n            let newI = i + dx[dir], newJ = j + dy[dir];\n            if (0 <= newI && newI < m && 0 <= newJ && newJ < n) {\n                let newCost = visited[i][j] + ((dir + 1 !== grid[i][j]) ? 1 : 0);\n                if (newCost < visited[newI][newJ]) {\n                    visited[newI][newJ] = newCost;\n                    q.push({i: newI, j: newJ});\n                }\n            }\n        }\n    }\n    return cost;\n};\n```\n    \n    The algorithm performs a breadth-first search traversal based on the current grid directions. For each cell visited (starting at the upper left cell), it checks all four neighboring cells in the grid and calculates the new cost based on the direction. \nIf the direction required to reach the neighboring cell matches the direction in the grid, the cost remains the same, otherwise it increments by 1 (indicating that we have to modify the sign in one cell).\n\nAt each step, the BFS traversal keeps track of visited cells and their corresponding costs. When the bottom-right cell is reached, the function returns the cost of reaching it.\n\nBy using BFS, the traversal ensures that the first time the bottom-right cell is reached is with the minimum cost possible. Since it visits cells in layers, once it reaches the final cell, all cells at the same or lower cost must have already been visited, ensuring the validity of the path.\n    "
    },
    {
        "id": 217,
        "title": "Maximum Sum BST in Binary Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a **binary tree** `root`, return _the maximum sum of all keys of **any** sub-tree which is also a Binary Search Tree (BST)_.\n\nAssume a BST is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,4,3,2,4,2,5,null,null,null,null,null,null,4,6\\]\n**Output:** 20\n**Explanation:** Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[4,3,null,1,2\\]\n**Output:** 2\n**Explanation:** Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n\n",
                "**Example 3:**\n\n**Input:** root = \\[-4,-2,-5\\]\n**Output:** 0\n**Explanation:** All values are negatives. Return an empty BST."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 4 * 104]`.\n*   `-4 * 104 <= Node.val <= 4 * 104`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]",
                "output": "20"
            },
            {
                "input": "[4,3,null,1,2]",
                "output": "2"
            },
            {
                "input": "[-4,-2,-5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    int maxSum = 0;\n    \n    public int maxSumBST(TreeNode root) {\n        dfs(root);\n        return maxSum;\n    }\n\n    private int[] dfs(TreeNode node) {\n        if (node == null) \n            return new int[]{1, 0, Integer.MAX_VALUE, Integer.MIN_VALUE};\n\n        int[] l = dfs(node.left);\n        int[] r = dfs(node.right);\n\n        if (l[0] == 0 || r[0] == 0 || node.val <= l[3] || node.val >= r[2]) \n            return new int[4];\n\n        int currSum = node.val + l[1] + r[1];\n        maxSum = Math.max(maxSum, currSum);\n\n        return new int[]{1, currSum, Math.min(node.val, l[2]), Math.max(node.val, r[3])};\n    }\n}\n```\n\n    \n    The algorithm starts with a Depth First Search (DFS) traversal of the tree. For each node, it checks if the left and right subtree are both BSTs, and the current node's value is within the range defined by its left and right subtrees.\n\nIf the current node and its subtrees form a valid BST, we calculate the sum of the current subtree and update the maximum sum if the current sum is greater. We return an array from the `dfs()` function, where the elements at indices:\n\n- `[0]` is 1 if it's a BST and 0 if it's not.\n- `[1]` is the sum of the subtree rooted at this node.\n- `[2]` is the minimum value in the subtree rooted at this node.\n- `[3]` is the maximum value in the subtree rooted at this node.\n\nAs we traverse the tree from the root to the leaves, we update the maximum sum of a subtree rooted at the current node if the subtree rooted at this node is a BST. Finally, when we reach the root node, we return the (updated) maximum sum.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxSumBST(self, root: TreeNode) -> int:\n        max_sum = [0]\n\n        def dfs(node):\n            if not node:\n                return 1, 0, float(\"inf\"), float(\"-inf\")\n\n            l = dfs(node.left)\n            r = dfs(node.right)\n\n            if not l[0] or not r[0] or node.val <= l[3] or node.val >= r[2]:\n                return 0, 0, 0, 0\n\n            curr_sum = node.val + l[1] + r[1]\n            max_sum[0] = max(max_sum[0], curr_sum)\n\n            return 1, curr_sum, min(node.val, l[2]), max(node.val, r[3])\n\n        dfs(root)\n        return max_sum[0]\n```\n\n    \n    The algorithm starts with a Depth First Search (DFS) traversal of the tree. For each node, it checks if the left and right subtree are both BSTs, and the current node's value is within the range defined by its left and right subtrees.\n\nIf the current node and its subtrees form a valid BST, we calculate the sum of the current subtree and update the maximum sum if the current sum is greater. We return an array from the `dfs()` function, where the elements at indices:\n\n- `[0]` is 1 if it's a BST and 0 if it's not.\n- `[1]` is the sum of the subtree rooted at this node.\n- `[2]` is the minimum value in the subtree rooted at this node.\n- `[3]` is the maximum value in the subtree rooted at this node.\n\nAs we traverse the tree from the root to the leaves, we update the maximum sum of a subtree rooted at the current node if the subtree rooted at this node is a BST. Finally, when we reach the root node, we return the (updated) maximum sum.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxSumBST(TreeNode* root) {\n        int maxSum = 0;\n        dfs(root, maxSum);\n        return maxSum;\n    }\n\nprivate:\n    array<int, 4> dfs(TreeNode* node, int &maxSum) {\n        if (!node) \n            return {1, 0, 1e5, -1e5};\n\n        auto l = dfs(node->left, maxSum);\n        auto r = dfs(node->right, maxSum);\n\n        if (l[0] == 0 || r[0] == 0 || node->val <= l[3] || node->val >= r[2]) \n            return {0, 0, 0, 0};\n\n        int currSum = node->val + l[1] + r[1];\n        maxSum = max(maxSum, currSum);\n\n        return {1, currSum, min(node->val, l[2]), max(node->val, r[3])};\n    }\n};\n```\n\n    \n    The algorithm starts with a Depth First Search (DFS) traversal of the tree. For each node, it checks if the left and right subtree are both BSTs, and the current node's value is within the range defined by its left and right subtrees.\n\nIf the current node and its subtrees form a valid BST, we calculate the sum of the current subtree and update the maximum sum if the current sum is greater. We return an array from the `dfs()` function, where the elements at indices:\n\n- `[0]` is 1 if it's a BST and 0 if it's not.\n- `[1]` is the sum of the subtree rooted at this node.\n- `[2]` is the minimum value in the subtree rooted at this node.\n- `[3]` is the maximum value in the subtree rooted at this node.\n\nAs we traverse the tree from the root to the leaves, we update the maximum sum of a subtree rooted at the current node if the subtree rooted at this node is a BST. Finally, when we reach the root node, we return the (updated) maximum sum.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val\n        this.left = left\n        this.right = right\n    }\n}\n\nfunction maxSumBST(root) {\n    let maxSum = 0;\n\n    function dfs(node) {\n        if (node === null) \n            return [1, 0, Number.MAX_VALUE, Number.MIN_VALUE];\n\n        const l = dfs(node.left);\n        const r = dfs(node.right);\n\n        if (l[0] === 0 || r[0] === 0 || node.val <= l[3] || node.val >= r[2]) \n            return new Array(4).fill(0);\n\n        const currSum = node.val + l[1] + r[1];\n        maxSum = Math.max(maxSum, currSum);\n\n        return [1, currSum, Math.min(node.val, l[2]), Math.max(node.val, r[3])];\n    }\n\n    dfs(root);\n    return maxSum;\n}\n```\n\n    \n    The algorithm starts with a Depth First Search (DFS) traversal of the tree. For each node, it checks if the left and right subtree are both BSTs, and the current node's value is within the range defined by its left and right subtrees.\n\nIf the current node and its subtrees form a valid BST, we calculate the sum of the current subtree and update the maximum sum if the current sum is greater. We return an array from the `dfs()` function, where the elements at indices:\n\n- `[0]` is 1 if it's a BST and 0 if it's not.\n- `[1]` is the sum of the subtree rooted at this node.\n- `[2]` is the minimum value in the subtree rooted at this node.\n- `[3]` is the maximum value in the subtree rooted at this node.\n\nAs we traverse the tree from the root to the leaves, we update the maximum sum of a subtree rooted at the current node if the subtree rooted at this node is a BST. Finally, when we reach the root node, we return the (updated) maximum sum.\n    "
    },
    {
        "id": 218,
        "title": "Frog Position After T Seconds",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an undirected tree consisting of `n` vertices numbered from `1` to `n`. A frog starts jumping from **vertex 1**. In one second, the frog jumps from its current vertex to another **unvisited** vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n\nThe edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`.\n\n_Return the probability that after `t` seconds the frog is on the vertex `target`._ Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,7\\],\\[2,4\\],\\[2,6\\],\\[3,5\\]\\], t = 2, target = 4\n**Output:** 0.16666666666666666 \n**Explanation:** The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after **second 1** and then jumping with 1/2 probability to vertex 4 after **second 2**. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 \\* 1/2 = 1/6 = 0.16666666666666666. \n\n",
                "**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,7\\],\\[2,4\\],\\[2,6\\],\\[3,5\\]\\], t = 1, target = 7\n**Output:** 0.3333333333333333\n**Explanation:** The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after **second 1**."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `1 <= ai, bi <= n`\n*   `1 <= t <= 50`\n*   `1 <= target <= n`",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph"
        ],
        "example": [
            {
                "input": "7,[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]],2,4",
                "output": "0.16666666666666666"
            },
            {
                "input": "7,[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]],1,7",
                "output": "0.3333333333333333"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public void dfs(int node, int parent, int t, int target, List<List<Integer>> graph, double prob, double[] ans) {\n        if (t == 0) {\n            if(node == target) ans[0] += prob;\n            return;\n        }\n        \n        boolean has_child = false;\n        for(Integer child : graph.get(node)) {\n            if(child != parent) {\n                has_child = true;\n                dfs(child, node, t - 1, target, graph, prob / (graph.get(node).size() - (node != 1 ? 1 : 0)), ans);\n            }\n        }\n        \n        if(!has_child && node == target) ans[0] += prob;\n    }\n\n    public double frogPosition(int n, int[][] edges, int t, int target) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; ++i) {\n            graph.add(new ArrayList<Integer>());\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int a = edges[i][0], b = edges[i][1];\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        \n        double[] ans = {0.0};\n        dfs(1, -1, t, target, graph, 1.0, ans);\n        return ans[0];\n    }\n}\n```\n\n    \n    The problem can be solved using Depth First Search (DFS). The basic idea is to traverse the tree using DFS starting from the vertex 1 with a probability of 1.0. During the traversal, at each visited vertex we calculate the probability that the frog reaches the current vertex. To do this, we maintain the probability of the current subtree traversal, and at each step we update this probability by dividing it by the number of unvisited neighbor vertices (excluding the parent vertex of the current vertex).\n\nWe continue the traversal for t seconds. At each step, if the traversal time (t) is zero or the frog reaches the target vertex, we store the probability of reaching the target vertex into the answer.\n\nUpon completion of the DFS traversal, we return the final answer, which is the probability of the frog being on the vertex target after t seconds.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, t, target, graph, prob, ans):\n    if t == 0:\n        if node == target:\n            ans[0] += prob\n        return\n\n    has_child = False\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            has_child = True\n            dfs(neighbor, node, t - 1, target, graph, prob / (len(graph[node]) - (1 if node != 1 else 0)), ans)\n\n    if not has_child and node == target:\n        ans[0] += prob\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    ans = [0.0]\n    dfs(1, -1, t, target, graph, 1.0, ans)\n    return ans[0]\n```\n\n    \n    The problem can be solved using Depth First Search (DFS). The basic idea is to traverse the tree using DFS starting from the vertex 1 with a probability of 1.0. During the traversal, at each visited vertex we calculate the probability that the frog reaches the current vertex. To do this, we maintain the probability of the current subtree traversal, and at each step we update this probability by dividing it by the number of unvisited neighbor vertices (excluding the parent vertex of the current vertex).\n\nWe continue the traversal for t seconds. At each step, if the traversal time (t) is zero or the frog reaches the target vertex, we store the probability of reaching the target vertex into the answer.\n\nUpon completion of the DFS traversal, we return the final answer, which is the probability of the frog being on the vertex target after t seconds.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, int parent, int t, int target, vector<vector<int>>& graph, double prob, vector<double>& ans) {\n    if (t == 0) {\n        if(node == target) ans[0] += prob;\n        return;\n    }\n    \n    bool has_child = false;\n    for(int i = 0; i < graph[node].size(); ++i) {\n        if(graph[node][i] != parent) {\n            has_child = true;\n            dfs(graph[node][i], node, t - 1, target, graph, prob / (graph[node].size() - (node != 1)), ans);\n        }\n    }\n    \n    if(!has_child && node == target) ans[0] += prob;\n}\n\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < n - 1; ++i) {\n        int a = edges[i][0], b = edges[i][1];\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    \n    vector<double> ans(1, 0.0);\n    dfs(1, -1, t, target, graph, 1.0, ans);\n    return ans[0];\n}\n```\n\n    \n    The problem can be solved using Depth First Search (DFS). The basic idea is to traverse the tree using DFS starting from the vertex 1 with a probability of 1.0. During the traversal, at each visited vertex we calculate the probability that the frog reaches the current vertex. To do this, we maintain the probability of the current subtree traversal, and at each step we update this probability by dividing it by the number of unvisited neighbor vertices (excluding the parent vertex of the current vertex).\n\nWe continue the traversal for t seconds. At each step, if the traversal time (t) is zero or the frog reaches the target vertex, we store the probability of reaching the target vertex into the answer.\n\nUpon completion of the DFS traversal, we return the final answer, which is the probability of the frog being on the vertex target after t seconds.\n    ",
        "js": "\n    ```javascript\nfunction dfs(node, parent, t, target, graph, prob, ans) {\n    if (t === 0) {\n        if (node === target) ans[0] += prob;\n        return;\n    }\n\n    let hasChild = false;\n    for (let neighbor of graph[node]) {\n        if (neighbor !== parent) {\n            hasChild = true;\n            dfs(neighbor, node, t - 1, target, graph, prob / (graph[node].length - (node !== 1 ? 1 : 0)), ans);\n        }\n    }\n\n    if (!hasChild && node === target) ans[0] += prob;\n}\n\nfunction frogPosition(n, edges, t, target) {\n    const graph = new Map();\n    for (let i = 1; i <= n; ++i) {\n        graph.set(i, []);\n    }\n    for (let i = 0; i < n - 1; ++i) {\n        const a = edges[i][0],\n              b = edges[i][1];\n        graph.get(a).push(b);\n        graph.get(b).push(a);\n    }\n\n    const ans = [0.0];\n    dfs(1, -1, t, target, graph, 1.0, ans);\n    return ans[0];\n}\n```\n\n    \n    The problem can be solved using Depth First Search (DFS). The basic idea is to traverse the tree using DFS starting from the vertex 1 with a probability of 1.0. During the traversal, at each visited vertex we calculate the probability that the frog reaches the current vertex. To do this, we maintain the probability of the current subtree traversal, and at each step we update this probability by dividing it by the number of unvisited neighbor vertices (excluding the parent vertex of the current vertex).\n\nWe continue the traversal for t seconds. At each step, if the traversal time (t) is zero or the frog reaches the target vertex, we store the probability of reaching the target vertex into the answer.\n\nUpon completion of the DFS traversal, we return the final answer, which is the probability of the frog being on the vertex target after t seconds.\n    "
    },
    {
        "id": 219,
        "title": "Maximum Performance of a Team",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integers `n` and `k` and two integer arrays `speed` and `efficiency` both of length `n`. There are `n` engineers numbered from `1` to `n`. `speed[i]` and `efficiency[i]` represent the speed and efficiency of the `ith` engineer respectively.\n\nChoose **at most** `k` different engineers out of the `n` engineers to form a team with the maximum **performance**.\n\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\n\nReturn _the maximum performance of this team_. Since the answer can be a huge number, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 2\n**Output:** 60\n**Explanation:** \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) \\* min(4, 7) = 60.\n\n",
                "**Example 2:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 3\n**Output:** 68\n**Explanation:**\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) \\* min(5, 4, 7) = 68.\n\n",
                "**Example 3:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 4\n**Output:** 72"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= n <= 105`\n*   `speed.length == n`\n*   `efficiency.length == n`\n*   `1 <= speed[i] <= 105`\n*   `1 <= efficiency[i] <= 108`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "6,[2,10,3,1,5,8],[5,4,3,9,7,2],2",
                "output": "60"
            },
            {
                "input": "6,[2,10,3,1,5,8],[5,4,3,9,7,2],3",
                "output": "68"
            },
            {
                "input": "6,[2,10,3,1,5,8],[5,4,3,9,7,2],4",
                "output": "72"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxPerformance(int n, int k, int[] speed, int[] efficiency) {\n    int[][] engineers = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        engineers[i] = new int[] {efficiency[i], speed[i]};\n    }\n\n    Arrays.sort(engineers, (a, b) -> b[0] - a[0]);\n\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k, Comparator.reverseOrder());\n    long speedSum = 0;\n    long maxPerformance = 0;\n\n    for (int[] engineer : engineers) {\n        speedSum += engineer[1];\n        minHeap.offer(engineer[1]);\n\n        if (minHeap.size() > k) {\n            speedSum -= minHeap.poll();\n        }\n\n        maxPerformance = Math.max(maxPerformance, speedSum * engineer[0]);\n    }\n\n    return (int) (maxPerformance % (1e9 + 7));\n}\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    ",
        "python": "\n    ```python\nimport heapq\nfrom typing import List\n\ndef max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    min_heap = []\n    speed_sum = 0\n    max_performance = 0\n\n    for e, s in engineers:\n        speed_sum += s\n        heapq.heappush(min_heap, s)\n\n        if len(min_heap) > k:\n            speed_sum -= heapq.heappop(min_heap)\n\n        max_performance = max(max_performance, speed_sum * e)\n\n    return max_performance % (10**9 + 7)\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) {\n    std::vector<std::pair<int, int>> engineers(n);\n    for (int i = 0; i < n; ++i) {\n        engineers[i] = {efficiency[i], speed[i]};\n    }\n    \n    std::sort(engineers.rbegin(), engineers.rend());\n    \n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    \n    long long speed_sum = 0;\n    long long max_performance = 0;\n    \n    for (auto& engineer : engineers) {\n        speed_sum += engineer.second;\n        min_heap.push(engineer.second);\n        \n        if (min_heap.size() > k) {\n            speed_sum -= min_heap.top();\n            min_heap.pop();\n        }\n        \n        max_performance = std::max(max_performance, speed_sum * engineer.first);\n    }\n    \n    return max_performance % 1000000007;\n}\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    ",
        "js": "\n    ```javascript\nfunction maxPerformance(n, k, speed, efficiency) {\n    const engineers = efficiency.map((e, i) => [e, speed[i]]).sort((a, b) => b[0] - a[0]);\n    const minHeap = new MinHeap();\n\n    let speedSum = 0;\n    let maxPerformance = 0;\n\n    for (const [e, s] of engineers) {\n        speedSum += s;\n        minHeap.insert(s);\n\n        if (minHeap.size() > k) {\n            speedSum -= minHeap.extractMin();\n        }\n\n        maxPerformance = Math.max(maxPerformance, speedSum * e);\n    }\n\n    return maxPerformance % (10**9 + 7);\n}\n\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n    insert(value) {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    extractMin() {\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return min;\n    }\n    size() {\n        return this.heap.length;\n    }\n    bubbleUp(index) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            if (this.heap[index] >= this.heap[parentIndex]) {\n                break;\n            }\n            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n            index = parentIndex;\n        }\n    }\n    bubbleDown(index) {\n        while (true) {\n            let minIndex = index;\n            const leftChildIndex = 2 * index + 1;\n            const rightChildIndex = 2 * index + 2;\n            if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[minIndex]) {\n                minIndex = leftChildIndex;\n            }\n            if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[minIndex]) {\n                minIndex = rightChildIndex;\n            }\n            if (minIndex === index) {\n                break;\n            }\n            [this.heap[index], this.heap[minIndex]] = [this.heap[minIndex], this.heap[index]];\n            index = minIndex;\n        }\n    }\n}\n```\n    \n    1. Store each engineer as pair of efficiency and speed in a list/array and sort that list/array in decreasing order based on efficiency.\n2. Initialize an empty min-heap, speed_sum and max_performance.\n3. Iterate over the sorted engineers list/array:\n   a. Add the current engineer's speed to the speed_sum.\n   b. Add the current engineer's speed to the min-heap.\n   c. If the min-heap's size is greater than given k, remove the minimum speed from the min-heap and subtract it from the speed_sum.\n   d. Update max_performance by comparing the current max_performance with the product of speed_sum and the current engineer's efficiency.\n4. Return max_performance % (10^9 + 7).\n    "
    },
    {
        "id": 220,
        "title": "Pizza With 3n Slices",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a pizza with `3n` slices of varying size, you and your friends will take slices of pizza as follows:\n\n*   You will pick **any** pizza slice.\n*   Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n*   Your friend Bob will pick the next slice in the clockwise direction of your pick.\n*   Repeat until there are no more slices of pizzas.\n\nGiven an integer array `slices` that represent the sizes of the pizza slices in a clockwise direction, return _the maximum possible sum of slice sizes that you can pick_.",
            "examples": [
                "**Example 1:**\n\n**Input:** slices = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\n",
                "**Example 2:**\n\n**Input:** slices = \\[8,9,8,6,1,1\\]\n**Output:** 16\n**Explanation:** Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8."
            ],
            "constraints": "**Constraints:**\n\n*   `3 * n == slices.length`\n*   `1 <= slices.length <= 500`\n*   `1 <= slices[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5,6]",
                "output": "10"
            },
            {
                "input": "[8,9,8,6,1,1]",
                "output": "16"
            }
        ],
        "java": "\n    ```java\npublic int maxSumDivThree(int[] nums) {\n    int[] dp = new int[3];\n    for (int num : nums) {\n        int[] temp = Arrays.copyOf(dp, 3);\n        for (int s : temp) {\n            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ",
        "python": "\n    ```python\ndef maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ",
        "c++": "\n    ```cpp\nint maxSumDivThree(vector<int>& nums) {\n    vector<int> dp(3, 0);\n    for (int num : nums) {\n        vector<int> temp(dp);\n        for (int s : temp) {\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    ",
        "js": "\n    ```javascript\nfunction maxSumDivThree(nums) {\n    let dp = [0, 0, 0];\n    for (let num of nums) {\n        let temp = [...dp];\n        for (let s of temp) {\n            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);\n        }\n    }\n    return dp[0];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` having 3 elements with all 0's. This will store the maximum sum for % 3 == 0, % 3 == 1, and % 3 == 2.\n2. Iterate through the input array `nums`.\n3. For each number, create a temporary copy of the current `dp` state, as we want to make changes to the original `dp` array based on the original state.\n4. For each number, iterate through the temporary copy of `dp` (temp). Calculate `(s + num) % 3` for the current number and the sum, and update the respective position in `dp` array with the maximum sum.\n5. The answer will be stored at `dp[0]`, which is the maximum sum that is divisible by three.\n    "
    },
    {
        "id": 221,
        "title": "Find All Good Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the strings `s1` and `s2` of size `n` and the string `evil`, return _the number of **good** strings_.\n\nA **good** string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, s1 =  \"aa \", s2 =  \"da \", evil =  \"b \"\n**Output:** 51 \n**Explanation:** There are 25 good strings starting with 'a':  \"aa \", \"ac \", \"ad \",..., \"az \". Then there are 25 good strings starting with 'c':  \"ca \", \"cc \", \"cd \",..., \"cz \" and finally there is one good string starting with 'd':  \"da \". \n\n",
                "**Example 2:**\n\n**Input:** n = 8, s1 =  \"leetcode \", s2 =  \"leetgoes \", evil =  \"leet \"\n**Output:** 0 \n**Explanation:** All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix  \"leet \", therefore, there is not any good string.\n\n",
                "**Example 3:**\n\n**Input:** n = 2, s1 =  \"gx \", s2 =  \"gz \", evil =  \"x \"\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `s1.length == n`\n*   `s2.length == n`\n*   `s1 <= s2`\n*   `1 <= n <= 500`\n*   `1 <= evil.length <= 50`\n*   All strings consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "String Matching"
        ],
        "example": [
            {
                "input": "2,\"aa\",\"da\",\"b\"",
                "output": "51"
            },
            {
                "input": "8,\"leetcode\",\"leetgoes\",\"leet\"",
                "output": "0"
            },
            {
                "input": "2,\"gx\",\"gz\",\"x\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<List<String>> suggestedProducts(String[] products, String searchWord) {\n    Arrays.sort(products);\n    \n    List<List<String>> result = new ArrayList<>();\n    String currentPrefix = \"\";\n    \n    for (char letter : searchWord.toCharArray()) {\n        currentPrefix += letter;\n        \n        int index = Arrays.binarySearch(products, currentPrefix);\n        if (index < 0) {\n            index = -index - 1;\n        }\n        \n        List<String> suggestions = new ArrayList<>();\n        for (int i = 0; i < 3 && index < products.length && products[index].startsWith(currentPrefix); i++) {\n            suggestions.add(products[index]);\n            index++;\n        }\n        \n        result.add(suggestions);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef suggestedProducts(products, searchWord):\n    products.sort()\n    result = []\n    current_prefix = \"\"\n    \n    for letter in searchWord:\n        current_prefix += letter\n        index = bisect_left(products, current_prefix)\n        suggestions = []\n        \n        for i in range(3):\n            if index < len(products) and products[index].startswith(current_prefix):\n                suggestions.append(products[index])\n                index += 1\n            else:\n                break\n        \n        result.append(suggestions)\n    \n    return result\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> suggestedProducts(std::vector<std::string>& products, std::string searchWord) {\n    std::sort(products.begin(), products.end());\n    \n    std::vector<std::vector<std::string>> result;\n    std::string currentPrefix;\n    \n    for (char letter : searchWord) {\n        currentPrefix += letter;\n        \n        auto it = std::lower_bound(products.begin(), products.end(), currentPrefix);\n        std::vector<std::string> suggestions;\n        \n        for (int i = 0; i < 3 && it != products.end() && it->substr(0, currentPrefix.size()) == currentPrefix; ++i) {\n            suggestions.push_back(*it);\n            ++it;\n        }\n        \n        result.push_back(suggestions);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    ",
        "js": "\n    ```javascript\nfunction suggestedProducts(products, searchWord) {\n    products.sort();\n    \n    let result = [];\n    let currentPrefix = \"\";\n    \n    for (let letter of searchWord) {\n        currentPrefix += letter;\n        \n        let index = products.findIndex(product => product.startsWith(currentPrefix));\n        \n        let suggestions = [];\n        for (let i = 0; i < 3 && index < products.length && products[index].startsWith(currentPrefix); i++) {\n            suggestions.push(products[index]);\n            index++;\n        }\n        \n        result.push(suggestions);\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm for solving this problem consists of the following steps:\n1. Sort the `products` lexicographically.\n2. Initialize an empty result list and an empty `currentPrefix` string.\n3. Iterate through each letter of `searchWord`, appending the letter to `currentPrefix`.\n4. Use a binary search to find the starting position of the suggested products with the common prefix `currentPrefix`.\n5. Initialize an empty suggestions list.\n6. Iterate from the starting position and add at most 3 product names to the suggestions list that have the common prefix with `currentPrefix`. Stop adding product names either when there are no more products with the common prefix or 3 suggestions are added.\n7. Add the suggestions list to the result list.\n8. Return the result list after iterating through all the characters of `searchWord`.\n    "
    },
    {
        "id": 222,
        "title": "Reducing Dishes",
        "difficulty": "Hard",
        "content": {
            "problem": "A chef has collected data on the `satisfaction` level of his `n` dishes. Chef can cook any dish in 1 unit of time.\n\n**Like-time coefficient** of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. `time[i] * satisfaction[i]`.\n\nReturn _the maximum sum of **like-time coefficient** that the chef can obtain after dishes preparation_.\n\nDishes can be prepared in **any** order and the chef can discard some dishes to get this maximum value.",
            "examples": [
                "**Example 1:**\n\n**Input:** satisfaction = \\[-1,-8,0,5,-9\\]\n**Output:** 14\n**Explanation:** After Removing the second and last dish, the maximum total **like-time coefficient** will be equal to (-1\\*1 + 0\\*2 + 5\\*3 = 14).\nEach dish is prepared in one unit of time.\n\n",
                "**Example 2:**\n\n**Input:** satisfaction = \\[4,3,2\\]\n**Output:** 20\n**Explanation:** Dishes can be prepared in any order, (2\\*1 + 3\\*2 + 4\\*3 = 20)\n\n",
                "**Example 3:**\n\n**Input:** satisfaction = \\[-1,-4,-5\\]\n**Output:** 0\n**Explanation:** People do not like the dishes. No dish is prepared."
            ],
            "constraints": "**Constraints:**\n\n*   `n == satisfaction.length`\n*   `1 <= n <= 500`\n*   `-1000 <= satisfaction[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[-1,-8,0,5,-9]",
                "output": "14"
            },
            {
                "input": "[4,3,2]",
                "output": "20"
            },
            {
                "input": "[-1,-4,-5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countSquares(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length, ans = 0;\n    int[][] dp = new int[m][n];\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j] == 1) dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ",
        "python": "\n    ```python\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n, ans = len(matrix), len(matrix[0]), 0\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = matrix[i][j]\n            elif matrix[i][j]:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            ans += dp[i][j]\n    return ans\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ",
        "c++": "\n    ```cpp\nint countSquares(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size(), ans = 0;\n    vector<vector<int>> dp(m, vector<int>(n, 0));\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j]) dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    ",
        "js": "\n    ```javascript\nfunction countSquares(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    let ans = 0, dp = Array.from({length: m}, () => Array(n));\n    for(let i = 0; i < m; i++) {\n        for(let j = 0; j < n; j++) {\n            if(i === 0 || j === 0) dp[i][j] = matrix[i][j];\n            else if(matrix[i][j]) dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a dynamic programming approach. For each cell of the input matrix, we create a `dp` matrix that will store the size of the square that ends at the current cell `[i, j]`. If the current cell contains 1, we need to check the values of the neighbors, i.e., cells `[i-1, j-1]`, `[i-1, j]`, and `[i, j-1]`. To form a square of size `k`, all three neighboring cells must have squares of size `k-1`. Thus, we set the current cell in `dp` to the minimum of the neighboring cells plus one (`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`).\n\nFor each cell, we then add its value in the `dp` matrix to the result (`ans += dp[i][j]`). Finally, we return the total number of squares found.\n    "
    },
    {
        "id": 223,
        "title": "Stone Game III",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.",
            "examples": [
                "**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n",
                "**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n",
                "**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Game Theory"
        ],
        "example": [
            {
                "input": "[1,2,3,7]",
                "output": "\"Bob\""
            },
            {
                "input": "[1,2,3,-9]",
                "output": "\"Alice\""
            },
            {
                "input": "[1,2,3,6]",
                "output": "\"Tie\""
            }
        ],
        "java": "\n    ```java\npublic String stoneGameIII(int[] stoneValue) {\n    int n = stoneValue.length;\n    int[] dp = new int[n + 1];\n    dp[n] = 0;\n    \n    for (int i = n - 1; i >= 0; --i) {\n        dp[i] = Integer.MIN_VALUE;\n        int curr = 0;\n        for (int j = 0; j < 3 && i + j < n; ++j) {\n            curr += stoneValue[i + j];\n            dp[i] = Math.max(dp[i], curr - dp[i + j + 1]);\n        }\n    }\n    \n    return dp[0] == 0 ? \"Tie \" : dp[0] > 0 ? \"Alice \" : \"Bob \";\n}\n```\n\n    \n    We can solve this problem using dynamic programming. Create a `dp` array of size `n+1` where `n` is the length of the stoneValue array, and initialize it with the minimum possible integer value (in Python, use `-inf`). The last element of the `dp` array should be initialized to 0.\nThe idea is to find the maximum score difference each player can achieve, starting from index i, for 0 ≤ i < n. \n\nFor each index i, we calculate the current score (sum of values at most 3 consecutive stones starting from i) and update the `dp[i]` to max(`dp[i]`, current - `dp[i+j+1]`). \n\nAt the end, `dp[0]` represents the maximum score difference between Alice and Bob. If `dp[0] > 0`, Alice wins, if `dp[0] < 0`, Bob wins, and if `dp[0] == 0`, it's a tie.\n    ",
        "python": "\n    ```python\ndef stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \"\n```\n\n    \n    We can solve this problem using dynamic programming. Create a `dp` array of size `n+1` where `n` is the length of the stoneValue array, and initialize it with the minimum possible integer value (in Python, use `-inf`). The last element of the `dp` array should be initialized to 0.\nThe idea is to find the maximum score difference each player can achieve, starting from index i, for 0 ≤ i < n. \n\nFor each index i, we calculate the current score (sum of values at most 3 consecutive stones starting from i) and update the `dp[i]` to max(`dp[i]`, current - `dp[i+j+1]`). \n\nAt the end, `dp[0]` represents the maximum score difference between Alice and Bob. If `dp[0] > 0`, Alice wins, if `dp[0] < 0`, Bob wins, and if `dp[0] == 0`, it's a tie.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring stoneGameIII(vector<int>& stoneValue) {\n    int n = stoneValue.size();\n    vector<int> dp(n + 1, INT_MIN);\n    dp[n] = 0;\n    \n    for (int i = n - 1; i >= 0; --i) {\n        int curr = 0;\n        for (int j = 0; j < 3 && i + j < n; ++j) {\n            curr += stoneValue[i + j];\n            dp[i] = max(dp[i], curr - dp[i + j + 1]);\n        }\n    }\n    \n    return dp[0] == 0 ? \"Tie \" : dp[0] > 0 ? \"Alice \" : \"Bob \";\n}\n```\n\n    \n    We can solve this problem using dynamic programming. Create a `dp` array of size `n+1` where `n` is the length of the stoneValue array, and initialize it with the minimum possible integer value (in Python, use `-inf`). The last element of the `dp` array should be initialized to 0.\nThe idea is to find the maximum score difference each player can achieve, starting from index i, for 0 ≤ i < n. \n\nFor each index i, we calculate the current score (sum of values at most 3 consecutive stones starting from i) and update the `dp[i]` to max(`dp[i]`, current - `dp[i+j+1]`). \n\nAt the end, `dp[0]` represents the maximum score difference between Alice and Bob. If `dp[0] > 0`, Alice wins, if `dp[0] < 0`, Bob wins, and if `dp[0] == 0`, it's a tie.\n    ",
        "js": "\n    ```javascript\nvar stoneGameIII = function(stoneValue) {\n    let n = stoneValue.length;\n    let dp = new Array(n + 1).fill(Number.MIN_SAFE_INTEGER);\n    dp[n] = 0;\n    \n    for (let i = n - 1; i >= 0; --i) {\n        let curr = 0;\n        for (let j = 0; j < 3 && i + j < n; ++j) {\n            curr += stoneValue[i + j];\n            dp[i] = Math.max(dp[i], curr - dp[i + j + 1]);\n        }\n    }\n    \n    return dp[0] === 0 ? \"Tie \" : dp[0] > 0 ? \"Alice \" : \"Bob \";\n};\n```\n\n    \n    We can solve this problem using dynamic programming. Create a `dp` array of size `n+1` where `n` is the length of the stoneValue array, and initialize it with the minimum possible integer value (in Python, use `-inf`). The last element of the `dp` array should be initialized to 0.\nThe idea is to find the maximum score difference each player can achieve, starting from index i, for 0 ≤ i < n. \n\nFor each index i, we calculate the current score (sum of values at most 3 consecutive stones starting from i) and update the `dp[i]` to max(`dp[i]`, current - `dp[i+j+1]`). \n\nAt the end, `dp[0]` represents the maximum score difference between Alice and Bob. If `dp[0] > 0`, Alice wins, if `dp[0] < 0`, Bob wins, and if `dp[0] == 0`, it's a tie.\n    "
    },
    {
        "id": 224,
        "title": "Restore The Array",
        "difficulty": "Hard",
        "content": {
            "problem": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits `s` and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.\n\nGiven the string `s` and the integer `k`, return _the number of the possible arrays that can be printed as_ `s` _using the mentioned program_. Since the answer may be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1000 \", k = 10000\n**Output:** 1\n**Explanation:** The only possible array is \\[1000\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"1000 \", k = 10\n**Output:** 0\n**Explanation:** There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"1317 \", k = 2000\n**Output:** 8\n**Explanation:** Possible arrays are \\[1317\\],\\[131,7\\],\\[13,17\\],\\[1,317\\],\\[13,1,7\\],\\[1,31,7\\],\\[1,3,17\\],\\[1,3,1,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only digits and does not contain leading zeros.\n*   `1 <= k <= 109`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"1000\",10000",
                "output": "1"
            },
            {
                "input": "\"1000\",10",
                "output": "0"
            },
            {
                "input": "\"1317\",2000",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int numDecodings(String s, int k) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[n] = 1;\n    int MOD = 1000000007;\n\n    for (int i = n - 1; i >= 0; i--) {\n        long num = 0;\n        for (int j = i; j < n && num <= k; j++) {\n            num = num * 10 + s.charAt(j) - '0';\n            if (num >= 1 && num <= k) {\n                dp[i] = (dp[i] + dp[j + 1]) % MOD;\n            }\n        }\n    }\n    return dp[0];\n}\n```\n    \n    The algorithm uses dynamic programming approach to solve the problem. We define a `dp` array of length `n + 1`, where `n` is the length of the input string `s`. The last element `dp[n]` is set to 1. Then we move backwards through the `s` string, and for each digit, calculate the possible number of decodings.\n\nWe iterate from position `i` to `j`, creating a number using the digits from `i` to `j`. If the number falls within the range `[1, k]`, it is a valid number and we add the number of ways of decoding the string from position `j+1` to the current numDecodings count for position `i`. If the number becomes greater than `k`, we break the inner loop.\n\nFinally, the first element of the `dp` array (`dp[0]`) contains the result, which is the number of possible arrays that can be printed from string `s`.\n    ",
        "python": "\n    ```python\ndef numDecodings(s: str, k: int) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    MOD = 1000000007\n\n    for i in range(n - 1, -1, -1):\n        num = 0\n        for j in range(i, n):\n            num = num * 10 + int(s[j])\n            if num >= 1 and num <= k:\n                dp[i] = (dp[i] + dp[j + 1]) % MOD\n            if num > k:\n                break\n\n    return dp[0]\n```\n    \n    The algorithm uses dynamic programming approach to solve the problem. We define a `dp` array of length `n + 1`, where `n` is the length of the input string `s`. The last element `dp[n]` is set to 1. Then we move backwards through the `s` string, and for each digit, calculate the possible number of decodings.\n\nWe iterate from position `i` to `j`, creating a number using the digits from `i` to `j`. If the number falls within the range `[1, k]`, it is a valid number and we add the number of ways of decoding the string from position `j+1` to the current numDecodings count for position `i`. If the number becomes greater than `k`, we break the inner loop.\n\nFinally, the first element of the `dp` array (`dp[0]`) contains the result, which is the number of possible arrays that can be printed from string `s`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nconst int MOD = 1e9 + 7;\n\nint numDecodings(std::string s, int k) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[n] = 1;\n\n    for (int i = n - 1; i >= 0; i--) {\n        long num = 0;\n        for (int j = i; j < n && num <= k; j++) {\n            num = num * 10 + s[j] - '0';\n            if (num >= 1 && num <= k) {\n                dp[i] = (dp[i] + dp[j + 1]) % MOD;\n            }\n        }\n    }\n    return dp[0];\n}\n```\n    \n    The algorithm uses dynamic programming approach to solve the problem. We define a `dp` array of length `n + 1`, where `n` is the length of the input string `s`. The last element `dp[n]` is set to 1. Then we move backwards through the `s` string, and for each digit, calculate the possible number of decodings.\n\nWe iterate from position `i` to `j`, creating a number using the digits from `i` to `j`. If the number falls within the range `[1, k]`, it is a valid number and we add the number of ways of decoding the string from position `j+1` to the current numDecodings count for position `i`. If the number becomes greater than `k`, we break the inner loop.\n\nFinally, the first element of the `dp` array (`dp[0]`) contains the result, which is the number of possible arrays that can be printed from string `s`.\n    ",
        "js": "\n    ```javascript\nfunction numDecodings(s, k) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[n] = 1;\n    const MOD = 1000000007;\n\n    for (let i = n - 1; i >= 0; i--) {\n        let num = 0;\n        for (let j = i; j < n && num <= k; j++) {\n            num = num * 10 + parseInt(s[j]);\n            if (num >= 1 && num <= k) {\n                dp[i] = (dp[i] + dp[j + 1]) % MOD;\n            }\n        }\n    }\n\n    return dp[0];\n}\n```\n    \n    The algorithm uses dynamic programming approach to solve the problem. We define a `dp` array of length `n + 1`, where `n` is the length of the input string `s`. The last element `dp[n]` is set to 1. Then we move backwards through the `s` string, and for each digit, calculate the possible number of decodings.\n\nWe iterate from position `i` to `j`, creating a number using the digits from `i` to `j`. If the number falls within the range `[1, k]`, it is a valid number and we add the number of ways of decoding the string from position `j+1` to the current numDecodings count for position `i`. If the number becomes greater than `k`, we break the inner loop.\n\nFinally, the first element of the `dp` array (`dp[0]`) contains the result, which is the number of possible arrays that can be printed from string `s`.\n    "
    },
    {
        "id": 225,
        "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:\n\nYou should build the array arr which has the following properties:\n\n*   `arr` has exactly `n` integers.\n*   `1 <= arr[i] <= m` where `(0 <= i < n)`.\n*   After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.\n\nReturn _the number of ways_ to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, m = 3, k = 1\n**Output:** 6\n**Explanation:** The possible arrays are \\[1, 1\\], \\[2, 1\\], \\[2, 2\\], \\[3, 1\\], \\[3, 2\\] \\[3, 3\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 5, m = 2, k = 3\n**Output:** 0\n**Explanation:** There are no possible arrays that satisify the mentioned conditions.\n\n",
                "**Example 3:**\n\n**Input:** n = 9, m = 1, k = 1\n**Output:** 1\n**Explanation:** The only possible array is \\[1, 1, 1, 1, 1, 1, 1, 1, 1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= m <= 100`\n*   `0 <= k <= n`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "2,3,1",
                "output": "6"
            },
            {
                "input": "5,2,3",
                "output": "0"
            },
            {
                "input": "9,1,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int waysToBuildArray(int n, int m, int k) {\n    final int mod = 1000000007;\n    int[][] dp = new int[n+1][k+1];\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= k; ++j) {\n            for (int x = 1; x <= m; ++x) {\n                if (j < i * (x-1)) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod;\n                }\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    The goal is to find the number of ways to build an array with n elements that satisfy the given conditions.\n\nCreate an `n+1` by `k+1` 2D array named `dp`, and initializing `dp[0][0] = 1`.\n\nThen, loop through `i` (1 to n) and `j` (0 to k) and for each `i` and `j`, loop through `x` (1 to m). For each `x`, if `j < i * (x-1)`, then update `dp[i][j]` as `(dp[i][j] + dp[i-1][j-(i-1)*(x-1)])` modulo the given constant (1e9 + 7).\n\nAt the end, return `dp[n][k]` as the result.\n\nThis will give you the number of ways to build the array with n elements while satisfying the given conditions.\n    ",
        "python": "\n    ```python\ndef waysToBuildArray(n, m, k):\n    mod = 10**9 + 7\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            for x in range(1, m+1):\n                if j < i * (x-1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod\n    return dp[n][k]\n```\n    \n    The goal is to find the number of ways to build an array with n elements that satisfy the given conditions.\n\nCreate an `n+1` by `k+1` 2D array named `dp`, and initializing `dp[0][0] = 1`.\n\nThen, loop through `i` (1 to n) and `j` (0 to k) and for each `i` and `j`, loop through `x` (1 to m). For each `x`, if `j < i * (x-1)`, then update `dp[i][j]` as `(dp[i][j] + dp[i-1][j-(i-1)*(x-1)])` modulo the given constant (1e9 + 7).\n\nAt the end, return `dp[n][k]` as the result.\n\nThis will give you the number of ways to build the array with n elements while satisfying the given conditions.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint waysToBuildArray(int n, int m, int k) {\n    const int mod = 1e9 + 7;\n    vector<vector<int>> dp(n+1, vector<int>(k+1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= k; ++j) {\n            for (int x = 1; x <= m; ++x) {\n                if (j < i * (x-1)) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod;\n                }\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    The goal is to find the number of ways to build an array with n elements that satisfy the given conditions.\n\nCreate an `n+1` by `k+1` 2D array named `dp`, and initializing `dp[0][0] = 1`.\n\nThen, loop through `i` (1 to n) and `j` (0 to k) and for each `i` and `j`, loop through `x` (1 to m). For each `x`, if `j < i * (x-1)`, then update `dp[i][j]` as `(dp[i][j] + dp[i-1][j-(i-1)*(x-1)])` modulo the given constant (1e9 + 7).\n\nAt the end, return `dp[n][k]` as the result.\n\nThis will give you the number of ways to build the array with n elements while satisfying the given conditions.\n    ",
        "js": "\n    ```javascript\nfunction waysToBuildArray(n, m, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n+1 }, () => Array(k+1).fill(0));\n    dp[0][0] = 1;\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j <= k; ++j) {\n            for (let x = 1; x <= m; ++x) {\n                if (j < i * (x-1)) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod;\n                }\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    The goal is to find the number of ways to build an array with n elements that satisfy the given conditions.\n\nCreate an `n+1` by `k+1` 2D array named `dp`, and initializing `dp[0][0] = 1`.\n\nThen, loop through `i` (1 to n) and `j` (0 to k) and for each `i` and `j`, loop through `x` (1 to m). For each `x`, if `j < i * (x-1)`, then update `dp[i][j]` as `(dp[i][j] + dp[i-1][j-(i-1)*(x-1)])` modulo the given constant (1e9 + 7).\n\nAt the end, return `dp[n][k]` as the result.\n\nThis will give you the number of ways to build the array with n elements while satisfying the given conditions.\n    "
    },
    {
        "id": 226,
        "title": "Constrained Subsequence Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return the maximum sum of a **non-empty** subsequence of that array such that for every two **consecutive** integers in the subsequence, `nums[i]` and `nums[j]`, where `i < j`, the condition `j - i <= k` is satisfied.\n\nA _subsequence_ of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[10,2,-10,5,20\\], k = 2\n**Output:** 37\n**Explanation:** The subsequence is \\[10, 2, 5, 20\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,-2,-3\\], k = 1\n**Output:** -1\n**Explanation:** The subsequence must be non-empty, so we choose the largest number.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[10,-2,-10,-5,20\\], k = 2\n**Output:** 23\n**Explanation:** The subsequence is \\[10, -2, -5, 20\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[10,2,-10,5,20],2",
                "output": "37"
            },
            {
                "input": "[-1,-2,-3],1",
                "output": "-1"
            },
            {
                "input": "[10,-2,-10,-5,20],2",
                "output": "23"
            }
        ],
        "java": "\n    ```java\npublic int maxSum(int[] nums, int k) {\n    int n = nums.length;\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    long[] dp = new long[n + 1];\n    long sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (i >= k) pq.poll(); // Maintain the maximum size of k\n        pq.offer((int)(dp[i] - nums[i]));\n        dp[i + 1] = Math.max(dp[i], nums[i] + pq.peek());\n        sum = Math.max(sum, dp[i + 1]);\n    }\n\n    return (int) sum;\n}\n```\n    \n    We'll use dynamic programming to solve this problem. We use a variable `dp` to store the maximum subsequence sum ending at position `i`. We also use a priority queue `pq` to maintain the maximum size of `k` and hold the differences between `dp[i]` and `nums[i]`.\n\nIterating through the array, we first remove elements from `pq` when it is of size larger than `k`. Then, we add the difference between `dp[i]` and `nums[i]` into the priority queue. Next, we update `dp[i+1]` by selecting the maximum between `dp[i]` and the sum of `nums[i]` and the top element of the priority queue. This top element represents the maximum possible previous choice that satisfies the condition `j - i <= k`. Finally, we update the running maximum sum and continue iterating through the array.\n\nOnce the for loop is done, the maximum sum of a valid subsequence is stored in the `sum` variable. We return this value as the final answer.\n    ",
        "python": "\n    ```python\ndef maxSum(nums, k):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    pq = []\n    sum_ = 0\n\n    for i in range(n):\n        if i >= k:\n            pq.remove(-(dp[i] - nums[i]))  # Remove element from pq\n        heapq.heappush(pq, -(dp[i] - nums[i]))  # Push in the negative for max heap\n        dp[i + 1] = max(dp[i], nums[i] - pq[0])\n        sum_ = max(sum_, dp[i + 1])\n\n    return sum_\n```\n    \n    We'll use dynamic programming to solve this problem. We use a variable `dp` to store the maximum subsequence sum ending at position `i`. We also use a priority queue `pq` to maintain the maximum size of `k` and hold the differences between `dp[i]` and `nums[i]`.\n\nIterating through the array, we first remove elements from `pq` when it is of size larger than `k`. Then, we add the difference between `dp[i]` and `nums[i]` into the priority queue. Next, we update `dp[i+1]` by selecting the maximum between `dp[i]` and the sum of `nums[i]` and the top element of the priority queue. This top element represents the maximum possible previous choice that satisfies the condition `j - i <= k`. Finally, we update the running maximum sum and continue iterating through the array.\n\nOnce the for loop is done, the maximum sum of a valid subsequence is stored in the `sum` variable. We return this value as the final answer.\n    ",
        "c++": "\n    ```cpp\nint maxSum(vector<int>& nums, int k) {\n    int n = nums.size();\n    priority_queue<int> pq;\n    vector<long long> dp(n + 1, 0);\n    long long sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (i >= k) pq.pop(); // Maintain the maximum size of k\n        pq.push(dp[i] - nums[i]);\n        dp[i + 1] = max(dp[i], nums[i] + pq.top());\n        sum = max(sum, dp[i + 1]);\n    }\n\n    return sum;\n}\n```\n    \n    We'll use dynamic programming to solve this problem. We use a variable `dp` to store the maximum subsequence sum ending at position `i`. We also use a priority queue `pq` to maintain the maximum size of `k` and hold the differences between `dp[i]` and `nums[i]`.\n\nIterating through the array, we first remove elements from `pq` when it is of size larger than `k`. Then, we add the difference between `dp[i]` and `nums[i]` into the priority queue. Next, we update `dp[i+1]` by selecting the maximum between `dp[i]` and the sum of `nums[i]` and the top element of the priority queue. This top element represents the maximum possible previous choice that satisfies the condition `j - i <= k`. Finally, we update the running maximum sum and continue iterating through the array.\n\nOnce the for loop is done, the maximum sum of a valid subsequence is stored in the `sum` variable. We return this value as the final answer.\n    ",
        "js": "\n    ```javascript\nfunction maxSum(nums, k) {\n    const n = nums.length;\n    const pq = new PriorityQueue((a, b) => b - a);\n    const dp = new Array(n + 1).fill(0);\n    let sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        if (i >= k) pq.poll(); // Maintain the maximum size of k\n        pq.offer(dp[i] - nums[i]);\n        dp[i + 1] = Math.max(dp[i], nums[i] + pq.peek());\n        sum = Math.max(sum, dp[i + 1]);\n    }\n\n    return sum;\n}\n\nclass PriorityQueue {\n    constructor(comparator = (a, b) => a - b) {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n\n    size() {\n        return this._heap.length;\n    }\n\n    isEmpty() {\n        return this.size() === 0;\n    }\n\n    peek() {\n        return this._heap[0];\n    }\n\n    push(value) {\n        this._heap.push(value);\n        this._shiftUp();\n    }\n\n    poll() {\n        const rootNode = this.peek();\n        this._heap[0] = this._heap.pop();\n        this._shiftDown();\n        return rootNode;\n    }\n\n    _parent(idx) {\n        return Math.floor((idx - 1) / 2);\n    }\n\n    _left(idx) {\n        return idx * 2 + 1;\n    }\n\n    _right(idx) {\n        return idx * 2 + 2;\n    }\n\n    _hasLeft(idx) {\n        return this._left(idx) < this._heap.length;\n    }\n\n    _hasRight(idx) {\n        return this._right(idx) < this._heap.length;\n    }\n\n    _shiftUp() {\n        let nodeIdx = this.size() - 1;\n        while (\n            nodeIdx > 0 &&\n            this._comparator(this._heap[nodeIdx], this._heap[this._parent(nodeIdx)]) < 0\n        ) {\n            this._swap(nodeIdx, this._parent(nodeIdx));\n            nodeIdx = this._parent(nodeIdx);\n        }\n    }\n\n    _shiftDown() {\n        let nodeIdx = 0;\n        while (this._hasLeft(nodeIdx)) {\n            let smallerChildIdx = this._left(nodeIdx);\n            if (\n                this._hasRight(nodeIdx) &&\n                this._comparator(this._heap[this._right(nodeIdx)], this._heap[this._left(nodeIdx)]) < 0\n            ) {\n                smallerChildIdx = this._right(nodeIdx);\n            }\n            if (this._comparator(this._heap[nodeIdx], this._heap[smallerChildIdx]) < 0) {\n                break;\n            }\n            this._swap(smallerChildIdx, nodeIdx);\n            nodeIdx = smallerChildIdx;\n        }\n    }\n\n    _swap(i, j) {\n        const tmp = this._heap[i];\n        this._heap[i] = this._heap[j];\n        this._heap[j] = tmp;\n    }\n}\n```\n    \n    We'll use dynamic programming to solve this problem. We use a variable `dp` to store the maximum subsequence sum ending at position `i`. We also use a priority queue `pq` to maintain the maximum size of `k` and hold the differences between `dp[i]` and `nums[i]`.\n\nIterating through the array, we first remove elements from `pq` when it is of size larger than `k`. Then, we add the difference between `dp[i]` and `nums[i]` into the priority queue. Next, we update `dp[i+1]` by selecting the maximum between `dp[i]` and the sum of `nums[i]` and the top element of the priority queue. This top element represents the maximum possible previous choice that satisfies the condition `j - i <= k`. Finally, we update the running maximum sum and continue iterating through the array.\n\nOnce the for loop is done, the maximum sum of a valid subsequence is stored in the `sum` variable. We return this value as the final answer.\n    "
    },
    {
        "id": 227,
        "title": "Number of Ways to Wear Different Hats to Each Other",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` people and `40` types of hats labeled from `1` to `40`.\n\nGiven a 2D integer array `hats`, where `hats[i]` is a list of all hats preferred by the `ith` person.\n\nReturn _the number of ways that the `n` people wear different hats to each other_.\n\nSince the answer may be too large, return it modulo `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** hats = \\[\\[3,4\\],\\[4,5\\],\\[5\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n\n",
                "**Example 2:**\n\n**Input:** hats = \\[\\[3,5,1\\],\\[3,5\\]\\]\n**Output:** 4\n**Explanation:** There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n\n",
                "**Example 3:**\n\n**Input:** hats = \\[\\[1,2,3,4\\],\\[1,2,3,4\\],\\[1,2,3,4\\],\\[1,2,3,4\\]\\]\n**Output:** 24\n**Explanation:** Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24."
            ],
            "constraints": "**Constraints:**\n\n*   `n == hats.length`\n*   `1 <= n <= 10`\n*   `1 <= hats[i].length <= 40`\n*   `1 <= hats[i][j] <= 40`\n*   `hats[i]` contains a list of **unique** integers.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[[3,4],[4,5],[5]]",
                "output": "1"
            },
            {
                "input": "[[3,5,1],[3,5]]",
                "output": "4"
            },
            {
                "input": "[[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]",
                "output": "24"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    public String freqAlphabets(String s) {\n        StringBuilder result = new StringBuilder();\n        int i = 0;\n        while (i < s.length()) {\n            if (i + 2 < s.length() && s.charAt(i + 2) == '#') {\n                result.append((char) ('a' + (s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0') - 10));\n                i += 3;\n            } else {\n                result.append((char) ('a' + s.charAt(i) - '1'));\n                i++;\n            }\n        }\n        return result.toString();\n    }\n}\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    ",
        "python": "\n    ```python\ndef freqAlphabets(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + 2 < len(s) and s[i + 2] == '#':\n            result.append(chr(ord('a') + int(s[i:i + 2]) - 1))\n            i += 3\n        else:\n            result.append(chr(ord('a') + int(s[i]) - 1))\n            i += 1\n    return ''.join(result)\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring freqAlphabets(string s) {\n    string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        if (i + 2 < s.length() && s[i + 2] == '#') {\n            result += ('a' + (s[i] - '0') * 10 + (s[i + 1] - '0') - 10);\n            i += 2;\n        } else {\n            result += ('a' + s[i] - '1');\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    ",
        "js": "\n    ```javascript\nfunction freqAlphabets(s) {\n    let result = [];\n    for (let i = 0; i < s.length;) {\n        if (i + 2 < s.length && s[i + 2] === \"#\") {\n            result.push(String.fromCharCode(\"a\".charCodeAt(0) + parseInt(s.substring(i, i + 2)) - 1));\n            i += 3;\n        } else {\n            result.push(String.fromCharCode(\"a\".charCodeAt(0) + parseInt(s[i]) - 1));\n            i++;\n        }\n    }\n    return result.join('');\n}\n```\n    \n    The algorithm iterates through the given input string `s`. When it encounters a '#' symbol, it means the 2 characters before the '#' form a two-digit number that maps to a character. We take that 2-digit number, convert it to an English lowercase character using ASCII by adding the number to the ASCII code of 'a', and append the character to the result string. If there is no '#' symbol, we simply consider the single-digit number and map it to a character. Finally, we return the mapped string.\n    "
    },
    {
        "id": 228,
        "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`.\n\nYou are allowed to choose **exactly one element** from each row to form an array.\n\nReturn _the_ `kth` _smallest array sum among all possible arrays_.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,3,11\\],\\[2,4,6\\]\\], k = 5\n**Output:** 7\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n\\[1,2\\], \\[1,4\\], \\[3,2\\], \\[3,4\\], \\[1,6\\]. Where the 5th sum is 7.\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,3,11\\],\\[2,4,6\\]\\], k = 9\n**Output:** 17\n\n",
                "**Example 3:**\n\n**Input:** mat = \\[\\[1,10,10\\],\\[1,4,5\\],\\[2,3,6\\]\\], k = 7\n**Output:** 9\n**Explanation:** Choosing one element from each row, the first k smallest sum are:\n\\[1,1,2\\], \\[1,1,3\\], \\[1,4,2\\], \\[1,4,3\\], \\[1,1,6\\], \\[1,5,2\\], \\[1,5,3\\]. Where the 7th sum is 9."
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat.length[i]`\n*   `1 <= m, n <= 40`\n*   `1 <= mat[i][j] <= 5000`\n*   `1 <= k <= min(200, nm)`\n*   `mat[i]` is a non-decreasing array.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,3,11],[2,4,6]],5",
                "output": "7"
            },
            {
                "input": "[[1,3,11],[2,4,6]],9",
                "output": "17"
            },
            {
                "input": "[[1,10,10],[1,4,5],[2,3,6]],7",
                "output": "9"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int kthSmallest(int[][] mat, int k) {\n    int m = mat.length, n = mat[0].length;\n    PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\n    minHeap.offer(new int[]{mat[0][0], 0, 0});\n\n    boolean[][] visited = new boolean[m][n];\n    visited[0][0] = true;\n    int count = 0;\n\n    while (!minHeap.isEmpty()) {\n        int[] cur = minHeap.poll();\n        int sum = cur[0], row = cur[1], col = cur[2];\n\n        count++;\n        if (count == k) {\n            return sum;\n        }\n\n        if (row + 1 < m && !visited[row + 1][col]) {\n            visited[row + 1][col] = true;\n            minHeap.offer(new int[]{sum - mat[row][col] + mat[row + 1][col], row + 1, col});\n        }\n        \n        if (col + 1 < n && !visited[row][col + 1]) {\n            visited[row][col + 1] = true;\n            minHeap.offer(new int[]{sum - mat[row][col] + mat[row][col + 1], row, col + 1});\n        }\n    }\n    \n    return -1;\n}\n```\n    \n    We can solve this problem using a min-heap. The main idea is as follows:\n1. Initialize a min-heap and insert the first element with its coordinates (0, 0).\n2. Keep a visited set or 2D boolean array to remember which elements have been inserted into the min-heap. Set the element (0, 0) as visited.\n3. Using a loop, pop the smallest element along with its coordinates from the min-heap and increment a counter.\n4. If the counter reached k, then return the popped sum.\n5. Add the element right below the current element if it is still inside the matrix and is not visited.\n6. Add the element right to the current element if it is still inside the matrix and is not visited.\n7. During each addition of a new cell, update the visited set or array and add the new sum (subtract the previous matrix element and add the new one) along with its coordinates to the heap.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef kthSmallest(mat, k):\n    m, n = len(mat), len(mat[0])\n    minHeap = [(mat[0][0], 0, 0)]\n\n    visited = set([(0, 0)])\n    count = 0\n\n    while minHeap:\n        cur = heapq.heappop(minHeap)\n        sum, row, col = cur\n\n        count += 1\n        if count == k:\n            return sum\n\n        if row + 1 < m and (row + 1, col) not in visited:\n            visited.add((row + 1, col))\n            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row + 1][col], row + 1, col))\n        \n        if col + 1 < n and (row, col + 1) not in visited:\n            visited.add((row, col + 1))\n            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row][col + 1], row, col + 1))\n\n    return -1\n```\n    \n    We can solve this problem using a min-heap. The main idea is as follows:\n1. Initialize a min-heap and insert the first element with its coordinates (0, 0).\n2. Keep a visited set or 2D boolean array to remember which elements have been inserted into the min-heap. Set the element (0, 0) as visited.\n3. Using a loop, pop the smallest element along with its coordinates from the min-heap and increment a counter.\n4. If the counter reached k, then return the popped sum.\n5. Add the element right below the current element if it is still inside the matrix and is not visited.\n6. Add the element right to the current element if it is still inside the matrix and is not visited.\n7. During each addition of a new cell, update the visited set or array and add the new sum (subtract the previous matrix element and add the new one) along with its coordinates to the heap.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint kthSmallest(vector<vector<int>>& mat, int k) {\n    int m = mat.size(), n = mat[0].size();\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;\n    minHeap.push({mat[0][0], 0, 0});\n\n    vector<vector<bool>> visited(m, vector<bool>(n, false));\n    visited[0][0] = true;\n    int count = 0;\n\n    while (!minHeap.empty()) {\n        auto cur = minHeap.top();\n        minHeap.pop();\n        int sum = cur[0], row = cur[1], col = cur[2];\n\n        count++;\n        if (count == k) {\n            return sum;\n        }\n\n        if (row + 1 < m && !visited[row + 1][col]) {\n            visited[row + 1][col] = true;\n            minHeap.push({sum - mat[row][col] + mat[row + 1][col], row + 1, col});\n        }\n        \n        if (col + 1 < n && !visited[row][col + 1]) {\n            visited[row][col + 1] = true;\n            minHeap.push({sum - mat[row][col] + mat[row][col + 1], row, col + 1});\n        }\n    }\n    \n    return -1;\n}\n```\n    \n    We can solve this problem using a min-heap. The main idea is as follows:\n1. Initialize a min-heap and insert the first element with its coordinates (0, 0).\n2. Keep a visited set or 2D boolean array to remember which elements have been inserted into the min-heap. Set the element (0, 0) as visited.\n3. Using a loop, pop the smallest element along with its coordinates from the min-heap and increment a counter.\n4. If the counter reached k, then return the popped sum.\n5. Add the element right below the current element if it is still inside the matrix and is not visited.\n6. Add the element right to the current element if it is still inside the matrix and is not visited.\n7. During each addition of a new cell, update the visited set or array and add the new sum (subtract the previous matrix element and add the new one) along with its coordinates to the heap.\n    ",
        "js": "\n    ```javascript\nfunction kthSmallest(mat, k) {\n    let m = mat.length, n = mat[0].length;\n    let minHeap = new PriorityQueue((a, b) => a[0] - b[0]);\n    minHeap.push([mat[0][0], 0, 0]);\n\n    let visited = new Set([0 * n]);\n    let count = 0;\n\n    while (minHeap.length) {\n        let [sum, row, col] = minHeap.pop();\n\n        count++;\n        if (count === k) {\n            return sum;\n        }\n\n        if (row + 1 < m && !visited.has((row + 1) * n + col)) {\n            visited.add((row + 1) * n + col);\n            minHeap.push([sum - mat[row][col] + mat[row + 1][col], row + 1, col]);\n        }\n        \n        if (col + 1 < n && !visited.has(row * n + (col + 1))) {\n            visited.add(row * n + (col + 1));\n            minHeap.push([sum - mat[row][col] + mat[row][col + 1], row, col + 1]);\n        }\n    }\n    \n    return -1;\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.heap = [];\n        this.comparator = comparator;\n    }\n\n    get length() {\n        return this.heap.length;\n    }\n\n    push(value) {\n        this.heap.push(value);\n        this._bubbleUp();\n    }\n\n    pop() {\n        const top = this.heap[0];\n        const bottom = this.heap.pop();\n        if (this.heap.length) {\n            this.heap[0] = bottom;\n            this._siftDown();\n        }\n        return top;\n    }\n\n    _bubbleUp() {\n        let index = this.heap.length - 1;\n        const element = this.heap[index];\n        \n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            const parent = this.heap[parentIndex];\n\n            if (this.comparator(element, parent) >= 0) break;\n            \n            this.heap[index] = parent;\n            this.heap[parentIndex] = element;\n            index = parentIndex;\n        }\n    }\n\n    _siftDown() {\n        let parentIndex = 0;\n        \n        while (true) {\n            const leftChildIndex = (parentIndex * 2) + 1;\n            const rightChildIndex = (parentIndex * 2) + 2;\n            let newIndex = parentIndex;\n\n            if (leftChildIndex < this.heap.length && this.comparator(this.heap[leftChildIndex], this.heap[newIndex]) < 0) {\n                newIndex = leftChildIndex;\n            }\n\n            if (rightChildIndex < this.heap.length && this.comparator(this.heap[rightChildIndex], this.heap[newIndex]) < 0) {\n                newIndex = rightChildIndex;\n            }\n\n            if (newIndex === parentIndex) break;\n            \n            [this.heap[parentIndex], this.heap[newIndex]] = [this.heap[newIndex], this.heap[parentIndex]];\n            parentIndex = newIndex;\n        }\n    }\n}\n```\n    \n    We can solve this problem using a min-heap. The main idea is as follows:\n1. Initialize a min-heap and insert the first element with its coordinates (0, 0).\n2. Keep a visited set or 2D boolean array to remember which elements have been inserted into the min-heap. Set the element (0, 0) as visited.\n3. Using a loop, pop the smallest element along with its coordinates from the min-heap and increment a counter.\n4. If the counter reached k, then return the popped sum.\n5. Add the element right below the current element if it is still inside the matrix and is not visited.\n6. Add the element right to the current element if it is still inside the matrix and is not visited.\n7. During each addition of a new cell, update the visited set or array and add the new sum (subtract the previous matrix element and add the new one) along with its coordinates to the heap.\n    "
    },
    {
        "id": 229,
        "title": "Number of Ways of Cutting a Pizza",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.",
            "examples": [
                "**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n",
                "**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Memoization",
            "Matrix"
        ],
        "example": [
            {
                "input": "[\"A..\",\"AAA\",\"...\"],3",
                "output": "3"
            },
            {
                "input": "[\"A..\",\"AA.\",\"...\"],3",
                "output": "1"
            },
            {
                "input": "[\"A..\",\"A..\",\"...\"],1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nint numberOfSteps(int num) {\n    int steps = 0;\n    while (num != 0) {\n        steps += (num % 2 == 0) ? 1 : 2;\n        num >>= 1;\n    }\n    return steps - 1;\n}\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    ",
        "python": "\n    ```python\ndef number_of_steps(num):\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    ",
        "c++": "\n    ```cpp\nint numberOfSteps(int num) {\n    int steps = 0;\n    while (num) {\n        steps += (num % 2 == 0) ? 1 : 2;\n        num >>= 1;\n    }\n    return steps - 1;\n}\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    ",
        "js": "\n    ```javascript\nfunction numberOfSteps(num) {\n    let steps = 0;\n    while (num) {\n        steps += (num % 2 === 0) ? 1 : 2;\n        num >>= 1;\n    }\n    return steps - 1;\n}\n```\n    \n    The algorithm initializes a `steps` variable to count the number of steps taken. It then iterates through a loop as long as the value of `num` is not zero. Inside the loop, if `num` is even, add one step; if `num` is odd, add two steps (subtracting one, getting an even number, then dividing by 2). The loop uses bit manipulation to divide `num` by 2 (shifting right by 1). Finally, we return the total steps minus one since we considered one extra step when subtracting an odd number.\n    "
    },
    {
        "id": 230,
        "title": "Form Largest Integer With Digits That Add up to Target",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of integers `cost` and an integer `target`, return _the **maximum** integer you can paint under the following rules_:\n\n*   The cost of painting a digit `(i + 1)` is given by `cost[i]` (**0-indexed**).\n*   The total cost used must be equal to `target`.\n*   The integer does not have `0` digits.\n\nSince the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return `\"0 \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** cost = \\[4,3,2,5,6,7,2,5,5\\], target = 9\n**Output:**  \"7772 \"\n**Explanation:** The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost( \"7772 \") = 2\\*3+ 3\\*1 = 9. You could also paint  \"977 \", but  \"7772 \" is the largest number.\n**Digit    cost**\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n\n",
                "**Example 2:**\n\n**Input:** cost = \\[7,6,5,5,5,6,8,7,8\\], target = 12\n**Output:**  \"85 \"\n**Explanation:** The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost( \"85 \") = 7 + 5 = 12.\n\n",
                "**Example 3:**\n\n**Input:** cost = \\[2,4,6,2,4,6,4,4,4\\], target = 5\n**Output:**  \"0 \"\n**Explanation:** It is impossible to paint any integer with total cost equal to target."
            ],
            "constraints": "**Constraints:**\n\n*   `cost.length == 9`\n*   `1 <= cost[i], target <= 5000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[4,3,2,5,6,7,2,5,5],9",
                "output": "\"7772\""
            },
            {
                "input": "[7,6,5,5,5,6,8,7,8],12",
                "output": "\"85\""
            },
            {
                "input": "[2,4,6,2,4,6,4,4,4],5",
                "output": "\"0\""
            }
        ],
        "java": "\n    ```java\npublic String largestNumber(int[] cost, int target) {\n    String[] dp = new String[target + 1];\n    dp[0] = \"\";\n\n    for (int i = 0; i < 9; ++i) {\n        for (int j = cost[i]; j <= target; ++j) {\n            if (dp[j - cost[i]] != null && dp[j - cost[i]].length() < j - cost[i]\n                    && (dp[j] == null || dp[j - cost[i]].length() + 1 > dp[j].length())) {\n                dp[j] = dp[j - cost[i]] + (char) ('1' + i);\n            }\n        }\n    }\n\n    return dp[target] == null ? \"0\" : dp[target];\n}\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    ",
        "python": "\n    ```python\ndef largestNumber(cost, target):\n    dp = [\"\" for _ in range(target + 1)]\n    dp[0] = \"\"\n\n    for i in range(9):\n        for j in range(cost[i], target + 1):\n            if dp[j - cost[i]] != None and len(dp[j - cost[i]]) < j - cost[i] \\\n               and (dp[j] == None or len(dp[j - cost[i]]) + 1 > len(dp[j])):\n                dp[j] = dp[j - cost[i]] + str(i + 1)\n\n    return dp[target] if dp[target] else \"0\"\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string largestNumber(std::vector<int>& cost, int target) {\n    std::vector<std::string> dp(target + 1, \"\");\n\n    for (int i = 0; i < 9; ++i) {\n        for (int j = cost[i]; j <= target; ++j) {\n            if (dp[j - cost[i]].size() < j - cost[i] && dp[j - cost[i]].size() + 1 > dp[j].size()) {\n                dp[j] = dp[j - cost[i]] + std::to_string(i + 1);\n            }\n        }\n    }\n\n    return dp[target].empty() ? \"0\" : dp[target];\n}\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    ",
        "js": "\n    ```javascript\nfunction largestNumber(cost, target) {\n    const dp = new Array(target + 1).fill(\"\");\n    dp[0] = \"\";\n\n    for (let i = 0; i < 9; ++i) {\n        for (let j = cost[i]; j <= target; ++j) {\n            if (dp[j - cost[i]].length < j - cost[i] && dp[j - cost[i]].length + 1 > dp[j].length) {\n                dp[j] = dp[j - cost[i]] + (i + 1).toString();\n            }\n        }\n    }\n\n    return dp[target] || \"0\";\n}\n```\n    \n    To solve this problem, we use a dynamic programming approach. We create an array `dp` where `dp[i]` keeps the maximum integer using the total cost `i`. To find the value of `dp[i]`, we keep track of the maximum integer up to the cost `i - cost[j]` for each of the paint costs and add the digit `j + 1`. Then, we compare the lengths of the integers at `dp[i - cost[j]]` and `dp[i]` to determine which one generates the maximum integer. At the end, we return `dp[target]`. If there is no solution, the default value will be an empty string which is changed to \"0\" before returning.\n    "
    },
    {
        "id": 231,
        "title": "Maximum Number of Darts Inside of a Circular Dartboard",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall.\n\nBob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lies on the dartboard.\n\nGiven the integer `r`, return _the maximum number of darts that can lie on the dartboard_.",
            "examples": [
                "**Example 1:**\n\n**Input:** darts = \\[\\[-2,0\\],\\[2,0\\],\\[0,2\\],\\[0,-2\\]\\], r = 2\n**Output:** 4\n**Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\n",
                "**Example 2:**\n\n**Input:** darts = \\[\\[-3,0\\],\\[3,0\\],\\[2,6\\],\\[5,4\\],\\[0,9\\],\\[7,8\\]\\], r = 5\n**Output:** 5\n**Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= darts.length <= 100`\n*   `darts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `darts` are unique\n*   `1 <= r <= 5000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry"
        ],
        "example": [
            {
                "input": "[[-2,0],[2,0],[0,2],[0,-2]],2",
                "output": "4"
            },
            {
                "input": "[[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]],5",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int numPoints(List<List<Integer>> darts, int r) {\n    int n = darts.size();\n    int result = 1;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int cnt = 0;\n            for (int k = 0; k < n; ++k) {\n                int dx = darts.get(i).get(0) - darts.get(k).get(0);\n                int dy = darts.get(i).get(1) - darts.get(k).get(1);\n                if (Math.sqrt(dx * dx + dy * dy) <= r) cnt++;\n            }\n            \n            if (cnt > result) result = cnt;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm is fairly straightforward. We iterate through all pairs of darts and try to place the dartboard center on each pair. Then, for each pair of darts, we check how many darts are within the distance `r` from both darts in the pair. The answer is the maximum count of darts that can be covered by the dartboard for all pairs of darts.\n\nThe time complexity of the algorithm is O(n^3), where n is the number of darts. In the worst case, there can be up to 100 darts, so the algorithm will be fast enough.\n    ",
        "python": "\n    ```python\ndef numPoints(darts, r):\n    n = len(darts)\n    result = 1\n    \n    for i in range(n):\n        for j in range(n):\n            cnt = 0\n            for k in range(n):\n                dx = darts[i][0] - darts[k][0]\n                dy = darts[i][1] - darts[k][1]\n                if (dx * dx + dy * dy) ** 0.5 <= r:\n                    cnt += 1\n                    \n            if cnt > result:\n                result = cnt\n                \n    return result\n```\n    \n    The algorithm is fairly straightforward. We iterate through all pairs of darts and try to place the dartboard center on each pair. Then, for each pair of darts, we check how many darts are within the distance `r` from both darts in the pair. The answer is the maximum count of darts that can be covered by the dartboard for all pairs of darts.\n\nThe time complexity of the algorithm is O(n^3), where n is the number of darts. In the worst case, there can be up to 100 darts, so the algorithm will be fast enough.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nint numPoints(std::vector<std::vector<int>>& darts, int r) {\n    int n = darts.size();\n    int result = 1;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int cnt = 0;\n            for (int k = 0; k < n; ++k) {\n                int dx = darts[i][0] - darts[k][0];\n                int dy = darts[i][1] - darts[k][1];\n                if (sqrt(dx * dx + dy * dy) <= r) cnt++;\n            }\n            \n            if (cnt > result) result = cnt;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm is fairly straightforward. We iterate through all pairs of darts and try to place the dartboard center on each pair. Then, for each pair of darts, we check how many darts are within the distance `r` from both darts in the pair. The answer is the maximum count of darts that can be covered by the dartboard for all pairs of darts.\n\nThe time complexity of the algorithm is O(n^3), where n is the number of darts. In the worst case, there can be up to 100 darts, so the algorithm will be fast enough.\n    ",
        "js": "\n    ```javascript\nfunction numPoints(darts, r) {\n    const n = darts.length;\n    let result = 1;\n    \n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            let cnt = 0;\n            for (let k = 0; k < n; ++k) {\n                const dx = darts[i][0] - darts[k][0];\n                const dy = darts[i][1] - darts[k][1];\n                if (Math.sqrt(dx * dx + dy * dy) <= r) cnt++;\n            }\n            \n            if (cnt > result) result = cnt;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm is fairly straightforward. We iterate through all pairs of darts and try to place the dartboard center on each pair. Then, for each pair of darts, we check how many darts are within the distance `r` from both darts in the pair. The answer is the maximum count of darts that can be covered by the dartboard for all pairs of darts.\n\nThe time complexity of the algorithm is O(n^3), where n is the number of darts. In the worst case, there can be up to 100 darts, so the algorithm will be fast enough.\n    "
    },
    {
        "id": 232,
        "title": "Max Dot Product of Two Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two arrays `nums1` and `nums2`.\n\nReturn the maximum dot product between **non-empty** subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[2,1,-2,5\\], nums2 = \\[3,0,-6\\]\n**Output:** 18\n**Explanation:** Take subsequence \\[2,-2\\] from nums1 and subsequence \\[3,-6\\] from nums2.\nTheir dot product is (2\\*3 + (-2)\\*(-6)) = 18.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[3,-2\\], nums2 = \\[2,-6,7\\]\n**Output:** 21\n**Explanation:** Take subsequence \\[3\\] from nums1 and subsequence \\[7\\] from nums2.\nTheir dot product is (3\\*7) = 21.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[-1,-1\\], nums2 = \\[1,1\\]\n**Output:** -1\n**Explanation:** Take subsequence \\[-1\\] from nums1 and subsequence \\[1\\] from nums2.\nTheir dot product is -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `-1000 <= nums1[i], nums2[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[2,1,-2,5],[3,0,-6]",
                "output": "18"
            },
            {
                "input": "[3,-2],[2,-6,7]",
                "output": "21"
            },
            {
                "input": "[-1,-1],[1,1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int[] sortByBits(int[] arr) {\n    Integer[] boxedArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n    Arrays.sort(boxedArr, new Comparator<Integer>() {\n        @Override\n        public int compare(Integer a, Integer b) {\n            int count_a = Integer.bitCount(a);\n            int count_b = Integer.bitCount(b);\n            \n            if (count_a == count_b) {\n                return a - b;\n            }\n            return count_a - count_b;\n        }\n    });\n\n    return Arrays.stream(boxedArr).mapToInt(Integer::intValue).toArray();\n}\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    ",
        "python": "\n    ```python\ndef sortByBits(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nbool compare(int a, int b) {\n    int count_a = __builtin_popcount(a);\n    int count_b = __builtin_popcount(b);\n    \n    if (count_a == count_b) {\n        return a < b;\n    }\n    return count_a < count_b;\n}\n\nvector<int> sortByBits(vector<int>& arr) {\n    sort(arr.begin(), arr.end(), compare);\n    return arr;\n}\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    ",
        "js": "\n    ```javascript\nfunction sortByBits(arr) {\n    function countOnes(n) {\n        let count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n\n    return arr.sort((a, b) => {\n        let diff = countOnes(a) - countOnes(b);\n        return diff !== 0 ? diff : a - b;\n    });\n}\n```\n\n    \n    The basic algorithm for solving this problem is to use a sorting algorithm that takes a custom comparator function. This custom comparator function is responsible for sorting the integers based on the number of 1's in their binary representation.\n\nFor C++, the `sort()` function and `__builtin_popcount()` function from the `<algorithm>` header are used. The comparator function `compare()` sorts the elements based on the number of 1's and if equal, by ascending value.\n\nFor Java, the boxed Integer array is created and the `Arrays.sort()` method is used with a custom anonymous Comparator. The `Integer.bitCount()` method is used to get the number of 1's.\n\nFor Python, a lambda function is passed as the `key` argument for the `sorted()` function, where it returns a tuple that contains the number of 1's (calculated using the `bin()` function and `count()` method) and the value itself for sorting purposes.\n\nFor JavaScript, a custom function `countOnes()` is implemented to count the number of 1's in each number. The `arr.sort()` method is used with an anonymous comparator function that calculates the difference in 1's and the difference in value if the number of 1's is the same.\n    "
    },
    {
        "id": 233,
        "title": "Cherry Pickup II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\n\nYou have two robots that can collect cherries for you:\n\n*   **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n*   **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\n\nReturn _the maximum number of cherries collection using both robots by following the rules below_:\n\n*   From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n*   When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n*   When both robots stay in the same cell, only one takes the cherries.\n*   Both robots cannot move outside of the grid at any moment.\n*   Both robots should reach the bottom row in `grid`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[3,1,1\\],\\[2,5,1\\],\\[1,5,5\\],\\[2,1,1\\]\\]\n**Output:** 24\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0,0,0,1\\],\\[2,0,0,0,0,3,0\\],\\[2,0,9,0,0,0,0\\],\\[0,3,0,5,4,0,0\\],\\[1,0,2,3,0,0,6\\]\\]\n**Output:** 28\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28."
            ],
            "constraints": "**Constraints:**\n\n*   `rows == grid.length`\n*   `cols == grid[i].length`\n*   `2 <= rows, cols <= 70`\n*   `0 <= grid[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[3,1,1],[2,5,1],[1,5,5],[2,1,1]]",
                "output": "24"
            },
            {
                "input": "[[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]",
                "output": "28"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] kWeakestRows(int[][] mat, int k) {\n    int m = mat.length;\n    int[] result = new int[k];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n\n    for (int i = 0; i < m; ++i) {\n        int soldiers = 0;\n        for (int val : mat[i]) {\n            if (val == 1) {\n                soldiers++;\n            } else {\n                break;\n            }\n        }\n        pq.add(new int[]{soldiers, i});\n    }\n\n    for (int i = 0; i < k; ++i) {\n        result[i] = pq.poll()[1];\n    }\n    return result;\n}\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    ",
        "python": "\n    ```python\nfrom typing import List\nimport heapq\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]\n    heapq.heapify(soldier_rows)\n    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nvector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n    vector<pair<int, int>> soldier_row;\n    for (int i = 0; i < mat.size(); ++i) {\n        int soldiers = count(mat[i].begin(), mat[i].end(), 1);\n        soldier_row.push_back({soldiers, i});\n    }\n\n    sort(soldier_row.begin(), soldier_row.end());\n    \n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(soldier_row[i].second);\n    }\n    return result;\n}\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    ",
        "js": "\n    ```javascript\nfunction kWeakestRows(mat, k) {\n    const soldierRows = mat.map((row, i) => [row.reduce((count, val) => count + val, 0), i]);\n    soldierRows.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    return soldierRows.slice(0, k).map(row => row[1]);\n}\n```\n\n    \n    The given problem can be solved by iterating through the matrix and counting the number of 1's (soldiers) in each row. We create a list `soldier_row` (or priority queue in java) of pairs (or arrays) such that pairs first element is the count of 1's and second element is the row index.\n\nThen we sort the list `soldier_row` (not needed in java, as priority queue handles that internally). While sorting, if there is a tie for the number of soldiers, the row index will be the tiebreaker.\n\nFinally, we create an output list by taking indices of the first `k` weakest rows from the sorted list and return that list as our answer.\n    "
    },
    {
        "id": 234,
        "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
        "difficulty": "Hard",
        "content": {
            "problem": "Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`.\n\nAll the balls will be **shuffled uniformly at random**, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully).\n\nPlease note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a)` (Please read the explanation of the first example carefully).\n\nReturn _the probability_ that the two boxes have the same number of distinct balls. Answers within `10-5` of the actual value will be accepted as correct.",
            "examples": [
                "**Example 1:**\n\n**Input:** balls = \\[1,1\\]\n**Output:** 1.00000\n**Explanation:** Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1\n\n",
                "**Example 2:**\n\n**Input:** balls = \\[2,1,1\\]\n**Output:** 0.66667\n**Explanation:** We have the set of balls \\[1, 1, 2, 3\\]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n\\[1,1 / 2,3\\], \\[1,1 / 3,2\\], \\[1,2 / 1,3\\], \\[1,2 / 3,1\\], \\[1,3 / 1,2\\], \\[1,3 / 2,1\\], \\[2,1 / 1,3\\], \\[2,1 / 3,1\\], \\[2,3 / 1,1\\], \\[3,1 / 1,2\\], \\[3,1 / 2,1\\], \\[3,2 / 1,1\\]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667\n\n",
                "**Example 3:**\n\n**Input:** balls = \\[1,2,1,2\\]\n**Output:** 0.60000\n**Explanation:** The set of balls is \\[1, 2, 2, 3, 4, 4\\]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= balls.length <= 8`\n*   `1 <= balls[i] <= 6`\n*   `sum(balls)` is even.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Backtracking",
            "Combinatorics",
            "Probability and Statistics"
        ],
        "example": [
            {
                "input": "[1,1]",
                "output": "1.00000"
            },
            {
                "input": "[2,1,1]",
                "output": "0.66667"
            },
            {
                "input": "[1,2,1,2]",
                "output": "0.60000"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic double factorial(int num) {\n    double result = 1;\n    for (int i = 1; i <= num; i++)\n        result *= i;\n    return result;\n}\n\npublic double countCombinations(int[] balls, List<Integer> combinations, int currBall) {\n    double totalCombinations = 1;\n    for (int i = 0; i < currBall; i++)\n        totalCombinations *= factorial(balls[i] + combinations.get(i)) / (factorial(balls[i]) * factorial(combinations.get(i)));\n\n    return totalCombinations;\n}\n\npublic double dfs(int[] balls, List<Integer> combinations, int currBall) {\n    if (currBall == balls.length) {\n        if (combinations.get(combinations.size() - 1).equals(combinations.get(0)))\n            return countCombinations(balls, combinations, currBall);\n        else\n            return 0;\n    }\n\n    double result = 0;\n    for (int i = 0; i <= balls[currBall]; i++) {\n        combinations.add(i);\n        result += dfs(balls, combinations, currBall + 1);\n        combinations.remove(combinations.size() - 1);\n    }\n\n    return result;\n}\n\npublic double getProbability(int[] balls) {\n    int sumBalls = 0;\n    for (int ball : balls)\n        sumBalls += ball;\n\n    double totalCombinations = 1;\n    for (int ball : balls)\n        totalCombinations *= factorial(ball);\n\n    List<Integer> combinations = new ArrayList<>();\n    return dfs(balls, combinations, 0) / totalCombinations;\n}\n```\n    \n    The algorithm is based on recursion and backtracking. We do a depth-first search for each ball in the input array, and use a variable called `combinations` to help compute the probabilities considering all arrangements of balls.\n\n1. First, we calculate the factorial of each ball count to simplify probability calculation later.\n2. We use a depth-first search approach to explore possible combinations of ball arrangements.\n3. We exclude any combinations in which the last and the first elements in the `combinations` array do not have the same value. If the values are the same, we continue and compute the total probability for the current combination using the helper function `count_combinations`.\n4. We recursively extend the `combinations` array and accumulate the probabilities in the `result`.\n5. Finally, we return the sum of probabilities divided by the total number of combinations.\n\nThe time complexity of the algorithm is O(KN), where K is the number of distinct colors, and N is the total number of balls. The space complexity is also O(KN) as we store the `combinations` array for each color during the recursion.\n    ",
        "python": "\n    ```python\nfrom math import factorial\n\ndef count_combinations(balls, combinations, curr_ball):\n    total_combinations = 1\n    for i in range(curr_ball):\n        total_combinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]))\n\n    return total_combinations\n\ndef dfs(balls, combinations, curr_ball):\n    if curr_ball == len(balls):\n        if combinations[-1] == combinations[0]:\n            return count_combinations(balls, combinations, curr_ball)\n        else:\n            return 0\n\n    result = 0\n    for i in range(balls[curr_ball] + 1):\n        combinations.append(i)\n        result += dfs(balls, combinations, curr_ball + 1)\n        combinations.pop()\n\n    return result\n\ndef get_probability(balls):\n    sum_balls = sum(balls)\n\n    total_combinations = 1\n    for ball in balls:\n        total_combinations *= factorial(ball)\n\n    combinations = []\n    return dfs(balls, combinations, 0) / total_combinations\n```\n    \n    The algorithm is based on recursion and backtracking. We do a depth-first search for each ball in the input array, and use a variable called `combinations` to help compute the probabilities considering all arrangements of balls.\n\n1. First, we calculate the factorial of each ball count to simplify probability calculation later.\n2. We use a depth-first search approach to explore possible combinations of ball arrangements.\n3. We exclude any combinations in which the last and the first elements in the `combinations` array do not have the same value. If the values are the same, we continue and compute the total probability for the current combination using the helper function `count_combinations`.\n4. We recursively extend the `combinations` array and accumulate the probabilities in the `result`.\n5. Finally, we return the sum of probabilities divided by the total number of combinations.\n\nThe time complexity of the algorithm is O(KN), where K is the number of distinct colors, and N is the total number of balls. The space complexity is also O(KN) as we store the `combinations` array for each color during the recursion.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\ndouble factorial(int num) {\n    double result = 1;\n    for (int i = 1; i <= num; i++)\n        result *= i;\n    return result;\n}\n\ndouble countCombinations(std::vector<int>& balls, std::vector<int>& combinations, int currBall) {\n    double totalCombinations = 1;\n    for (int i = 0; i < currBall; i++)\n        totalCombinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]));\n\n    return totalCombinations;\n}\n\ndouble dfs(std::vector<int>& balls, std::vector<int>& combinations, int currBall) {\n    if (currBall == balls.size()) {\n        if (combinations.back() == combinations.front())\n            return countCombinations(balls, combinations, currBall);\n        else\n            return 0;\n    }\n\n    double result = 0;\n    for (int i = 0; i <= balls[currBall]; i++) {\n        combinations.push_back(i);\n        result += dfs(balls, combinations, currBall + 1);\n        combinations.pop_back();\n    }\n\n    return result;\n}\n\ndouble getProbability(std::vector<int>& balls) {\n    int sumBalls = 0;\n    for (int ball : balls)\n        sumBalls += ball;\n\n    double totalCombinations = 1;\n    for (int ball : balls)\n        totalCombinations *= factorial(ball);\n\n    std::vector<int> combinations;\n    return dfs(balls, combinations, 0) / totalCombinations;\n}\n```\n    \n    The algorithm is based on recursion and backtracking. We do a depth-first search for each ball in the input array, and use a variable called `combinations` to help compute the probabilities considering all arrangements of balls.\n\n1. First, we calculate the factorial of each ball count to simplify probability calculation later.\n2. We use a depth-first search approach to explore possible combinations of ball arrangements.\n3. We exclude any combinations in which the last and the first elements in the `combinations` array do not have the same value. If the values are the same, we continue and compute the total probability for the current combination using the helper function `count_combinations`.\n4. We recursively extend the `combinations` array and accumulate the probabilities in the `result`.\n5. Finally, we return the sum of probabilities divided by the total number of combinations.\n\nThe time complexity of the algorithm is O(KN), where K is the number of distinct colors, and N is the total number of balls. The space complexity is also O(KN) as we store the `combinations` array for each color during the recursion.\n    ",
        "js": "\n    ```javascript\nfunction factorial(num) {\n    let result = 1;\n    for (let i = 1; i <= num; i++)\n        result *= i;\n    return result;\n}\n\nfunction countCombinations(balls, combinations, currBall) {\n    let totalCombinations = 1;\n    for (let i = 0; i < currBall; i++)\n        totalCombinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]));\n\n    return totalCombinations;\n}\n\nfunction dfs(balls, combinations, currBall) {\n    if (currBall === balls.length) {\n        if (combinations[combinations.length - 1] === combinations[0])\n            return countCombinations(balls, combinations, currBall);\n        else\n            return 0;\n    }\n\n    let result = 0;\n    for (let i = 0; i <= balls[currBall]; i++) {\n        combinations.push(i);\n        result += dfs(balls, combinations, currBall + 1);\n        combinations.pop();\n    }\n\n    return result;\n}\n\nfunction getProbability(balls) {\n    let sumBalls = balls.reduce((a, b) => a + b);\n\n    let totalCombinations = 1;\n    for (let ball of balls)\n        totalCombinations *= factorial(ball);\n\n    let combinations = [];\n    return dfs(balls, combinations, 0) / totalCombinations;\n}\n```\n    \n    The algorithm is based on recursion and backtracking. We do a depth-first search for each ball in the input array, and use a variable called `combinations` to help compute the probabilities considering all arrangements of balls.\n\n1. First, we calculate the factorial of each ball count to simplify probability calculation later.\n2. We use a depth-first search approach to explore possible combinations of ball arrangements.\n3. We exclude any combinations in which the last and the first elements in the `combinations` array do not have the same value. If the values are the same, we continue and compute the total probability for the current combination using the helper function `count_combinations`.\n4. We recursively extend the `combinations` array and accumulate the probabilities in the `result`.\n5. Finally, we return the sum of probabilities divided by the total number of combinations.\n\nThe time complexity of the algorithm is O(KN), where K is the number of distinct colors, and N is the total number of balls. The space complexity is also O(KN) as we store the `combinations` array for each color during the recursion.\n    "
    },
    {
        "id": 235,
        "title": "Paint House III",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again.\n\nA neighborhood is a maximal group of continuous houses that are painted with the same color.\n\n*   For example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`.\n\nGiven an array `houses`, an `m x n` matrix `cost` and an integer `target` where:\n\n*   `houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet.\n*   `cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.\n\nReturn _the minimum cost of painting all the remaining houses in such a way that there are exactly_ `target` _neighborhoods_. If it is not possible, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** houses = \\[0,0,0,0,0\\], cost = \\[\\[1,10\\],\\[10,1\\],\\[10,1\\],\\[1,10\\],\\[5,1\\]\\], m = 5, n = 2, target = 3\n**Output:** 9\n**Explanation:** Paint houses of this way \\[1,2,2,1,1\\]\nThis array contains target = 3 neighborhoods, \\[{1}, {2,2}, {1,1}\\].\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n\n",
                "**Example 2:**\n\n**Input:** houses = \\[0,2,1,2,0\\], cost = \\[\\[1,10\\],\\[10,1\\],\\[10,1\\],\\[1,10\\],\\[5,1\\]\\], m = 5, n = 2, target = 3\n**Output:** 11\n**Explanation:** Some houses are already painted, Paint the houses of this way \\[2,2,1,2,2\\]\nThis array contains target = 3 neighborhoods, \\[{2,2}, {1}, {2,2}\\]. \nCost of paint the first and last house (10 + 1) = 11.\n\n",
                "**Example 3:**\n\n**Input:** houses = \\[3,1,2,3\\], cost = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], m = 4, n = 3, target = 3\n**Output:** -1\n**Explanation:** Houses are already painted with a total of 4 neighborhoods \\[{3},{1},{2},{3}\\] different of target = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `m == houses.length == cost.length`\n*   `n == cost[i].length`\n*   `1 <= m <= 100`\n*   `1 <= n <= 20`\n*   `1 <= target <= m`\n*   `0 <= houses[i] <= n`\n*   `1 <= cost[i][j] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[0,0,0,0,0],[[1,10],[10,1],[10,1],[1,10],[5,1]],5,2,3",
                "output": "9"
            },
            {
                "input": "[0,2,1,2,0],[[1,10],[10,1],[10,1],[1,10],[5,1]],5,2,3",
                "output": "11"
            },
            {
                "input": "[3,1,2,3],[[1,1,1],[1,1,1],[1,1,1],[1,1,1]],4,3,3",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int findTheLongestSubstring(String s) {\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);\n    int res = 0, n = s.length(), i, j = 0;\n    for (i = 0; i < n; i++) {\n        switch (s.charAt(i)) {\n            case 'a': j ^= 1; break;\n            case 'e': j ^= 2; break;\n            case 'i': j ^= 4; break;\n            case 'o': j ^= 8; break;\n            case 'u': j ^= 16; break;\n        }\n        map.putIfAbsent(j, i);\n        res = Math.max(res, i - map.get(j));\n    }\n    return res;\n}\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    ",
        "python": "\n    ```python\ndef findTheLongestSubstring(s: str) -> int:\n    pos = {-1: 0}\n    ans = cur = 0\n    for i, c in enumerate(s):\n        cur ^= 1 << (\"aeiou\".find(c) + 1) >> 1\n        if cur not in pos:\n            pos[cur] = i + 1\n        ans = max(ans, i + 1 - pos[cur])\n    return ans\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint findTheLongestSubstring(string s) {\n    unordered_map<int, int> mp;\n    mp[0] = -1;\n    int res = 0, n = s.length(), i, j = 0;\n    for (i = 0; i < n; ++i) {\n        if (s[i] == 'a') j ^= 1;\n        else if (s[i] == 'e') j ^= 2;\n        else if (s[i] == 'i') j ^= 4;\n        else if (s[i] == 'o') j ^= 8;\n        else if (s[i] == 'u') j ^= 16;\n        if(!mp.count(j)) mp[j] = i;\n        res = max(res, i - mp[j]);\n    }\n    return res;\n}\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    ",
        "js": "\n    ```javascript\nfunction findTheLongestSubstring(s) {\n    const pos = new Map();\n    pos.set(0, -1);\n    let ans = 0, n = s.length, i, cur = 0;\n    for (i = 0; i < n; ++i) {\n        switch (s.charAt(i)) {\n            case 'a': cur ^= 1; break;\n            case 'e': cur ^= 2; break;\n            case 'i': cur ^= 4; break;\n            case 'o': cur ^= 8; break;\n            case 'u': cur ^= 16; break;\n        }\n        if(!pos.has(cur)) pos.set(cur, i);\n        ans = Math.max(ans, i - pos.get(cur));\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses XOR to find a bitmask where each vowel corresponds to a bit (1 for odd occurrences, 0 for even occurrences). It loops through the input string and does bitwise XOR with an encoded version of the current character.\n\nEach XOR operation computes the even and odd occurrences for each vowel thus far. It records the first index of the bitmask in the position mapping. The difference between the current index and the value in the position map for the bitmask will give the length of the longest substring with even vowel occurrences. It updates the answer with the maximum substring length found.\n    "
    },
    {
        "id": 236,
        "title": "Allocate Mailboxes",
        "difficulty": "Hard",
        "content": {
            "problem": "Given the array `houses` where `houses[i]` is the location of the `ith` house along a street and an integer `k`, allocate `k` mailboxes in the street.\n\nReturn _the **minimum** total distance between each house and its nearest mailbox_.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** houses = \\[1,4,8,10,20\\], k = 3\n**Output:** 5\n**Explanation:** Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n\n",
                "**Example 2:**\n\n**Input:** houses = \\[2,3,5,12,18\\], k = 2\n**Output:** 9\n**Explanation:** Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= houses.length <= 100`\n*   `1 <= houses[i] <= 104`\n*   All the integers of `houses` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,4,8,10,20],3",
                "output": "5"
            },
            {
                "input": "[2,3,5,12,18],2",
                "output": "9"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxEvents(int[][] events) {\n    Arrays.sort(events, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int lastDay = -1;\n\n    for (int[] event : events) {\n        if (event[0] > lastDay) {\n            count++;\n            lastDay = event[1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    ",
        "python": "\n    ```python\ndef max_events(events):\n    events.sort(key=lambda x: x[1])\n\n    count = 0\n    last_day = -1\n\n    for event in events:\n        if event[0] > last_day:\n            count += 1\n            last_day = event[1]\n\n    return count\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxEvents(std::vector<std::vector<int>>& events) {\n    std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int count = 0;\n    int lastDay = -1;\n\n    for (const auto& event : events) {\n        if (event[0] > lastDay) {\n            ++count;\n            lastDay = event[1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    ",
        "js": "\n    ```javascript\nfunction maxEvents(events) {\n    events.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let lastDay = -1;\n\n    for (const event of events) {\n        if (event[0] > lastDay) {\n            count++;\n            lastDay = event[1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The idea is to sort the events by end day. After sorting, iterate through the events and use a variable `lastDay` to keep track of the last day an event was attended. If the current event's start day is greater than the `lastDay`, increment the `count` (number of attended events) and set `lastDay` as the current event's end day. This greedy approach ensures we attend the events that end early and maximize the number of total attended events.\n    "
    },
    {
        "id": 237,
        "title": "Kth Ancestor of a Tree Node",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of `ith` node. The root of the tree is node `0`. Find the `kth` ancestor of a given node.\n\nThe `kth` ancestor of a tree node is the `kth` node in the path from that node to the root node.\n\nImplement the `TreeAncestor` class:\n\n*   `TreeAncestor(int n, int[] parent)` Initializes the object with the number of nodes in the tree and the parent array.\n*   `int getKthAncestor(int node, int k)` return the `kth` ancestor of the given node `node`. If there is no such ancestor, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"TreeAncestor \",  \"getKthAncestor \",  \"getKthAncestor \",  \"getKthAncestor \"\\]\n\\[\\[7, \\[-1, 0, 0, 1, 1, 2, 2\\]\\], \\[3, 1\\], \\[5, 2\\], \\[6, 3\\]\\]\n**Output**\n\\[null, 1, 0, -1\\]\n\n**Explanation**\nTreeAncestor treeAncestor = new TreeAncestor(7, \\[-1, 0, 0, 1, 1, 2, 2\\]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= n <= 5 * 104`\n*   `parent.length == n`\n*   `parent[0] == -1`\n*   `0 <= parent[i] < n` for all `0 < i < n`\n*   `0 <= node < n`\n*   There will be at most `5 * 104` queries.",
            "follow_up": null
        },
        "tag": [
            "Binary Search",
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Design"
        ],
        "example": [
            {
                "input": "]\n]],[3,1],[5,2],[6,3]]",
                "output": "**Output**\n[null,1,0,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String rankTeams(String[] votes) {\n        int teams = votes[0].length();\n        int[][] ranks = new int[26][teams];\n\n        for (String vote : votes) {\n            for (int i = 0; i < teams; ++i) {\n                ranks[vote.charAt(i) - 'A'][i]++;\n            }\n        }\n\n        Character[] result = new Character[teams];\n        for (int i = 0; i < teams; ++i) {\n            result[i] = votes[0].charAt(i);\n        }\n\n        Arrays.sort(result, new Comparator<Character>() {\n            public int compare(Character a, Character b) {\n                for (int i = 0; i < teams; ++i) {\n                    if (ranks[a - 'A'][i] != ranks[b - 'A'][i]) {\n                        return ranks[b - 'A'][i] - ranks[a - 'A'][i];\n                    }\n                }\n                return a.compareTo(b);\n            }\n        });\n\n        StringBuilder sb = new StringBuilder();\n        for (Character ch : result) {\n            sb.append(ch);\n        }\n        return sb.toString();\n    }\n}\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    ",
        "python": "\n    ```python\ndef rank_teams(votes):\n    teams = len(votes[0])\n    ranks = [[0] * teams for _ in range(26)]\n\n    for vote in votes:\n        for i in range(teams):\n            ranks[ord(vote[i]) - ord('A')][i] += 1\n\n    result = list(votes[0])\n    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))\n    return ''.join(result)\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n#include <vector>\n\nstd::string rankTeams(std::vector<std::string>& votes) {\n    int teams = votes[0].size();\n    std::vector<std::vector<int>> ranks(26, std::vector<int>(teams, 0));\n\n    for (const std::string& vote : votes) {\n        for (int i = 0; i < teams; ++i) {\n            ranks[vote[i] - 'A'][i]++;\n        }\n    }\n\n    std::string result = votes[0];\n    std::sort(result.begin(), result.end(), [&](char a, char b) {\n        for (int i = 0; i < teams; ++i) {\n            if (ranks[a - 'A'][i] != ranks[b - 'A'][i]) {\n                return ranks[a - 'A'][i] > ranks[b - 'A'][i];\n            }\n        }\n        return a < b;\n    });\n\n    return result;\n}\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    ",
        "js": "\n    ```javascript\nfunction rankTeams(votes) {\n    const teams = votes[0].length;\n    const ranks = Array.from({ length: 26 }, () => Array(teams).fill(0));\n\n    for (const vote of votes) {\n        for (let i = 0; i < teams; ++i) {\n            ranks[vote.charCodeAt(i) - \"A\".charCodeAt(0)][i]++;\n        }\n    }\n\n    const result = [...votes[0]];\n    result.sort((a, b) => {\n        for (let i = 0; i < teams; ++i) {\n            if (ranks[a.charCodeAt(0) - \"A\".charCodeAt(0)][i] !== ranks[b.charCodeAt(0) - \"A\".charCodeAt(0)][i]) {\n                return ranks[b.charCodeAt(0) - \"A\".charCodeAt(0)][i] - ranks[a.charCodeAt(0) - \"A\".charCodeAt(0)][i];\n            }\n        }\n        return a.localeCompare(b);\n    });\n\n    return result.join(\"\");\n}\n```\n\n    \n    1. Count the rank positions of each team in a 2D array (index 0-25 represent the team letter). The array stores the votes count for each position.\n2. Sort the given team letters in lexicographical order, so it can be later used for the stable sort.\n3. For each position and its votes count, sort the teams based on the number of votes they received in descending order. If two or more teams tie, use the next position's votes count, and so on. If they tie after considering all positions, sort them based on their team letter.\n4. Convert the sorted team letters back into a string.\n    "
    },
    {
        "id": 238,
        "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a weighted undirected connected graph with `n` vertices numbered from `0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional and weighted edge between nodes `ai` and `bi`. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.\n\nFind _all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST)_. An MST edge whose deletion from the graph would cause the MST weight to increase is called a _critical edge_. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\n\nNote that you can return the indices of the edges in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1,1\\],\\[1,2,1\\],\\[2,3,2\\],\\[0,3,2\\],\\[0,4,3\\],\\[3,4,3\\],\\[1,4,6\\]\\]\n**Output:** \\[\\[0,1\\],\\[2,3,4,5\\]\\]\n**Explanation:** The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n \nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1,1\\],\\[1,2,1\\],\\[2,3,1\\],\\[0,3,1\\]\\]\n**Output:** \\[\\[\\],\\[0,1,2,3\\]\\]\n**Explanation:** We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= min(200, n * (n - 1) / 2)`\n*   `edges[i].length == 3`\n*   `0 <= ai < bi < n`\n*   `1 <= weighti <= 1000`\n*   All pairs `(ai, bi)` are **distinct**.",
            "follow_up": null
        },
        "tag": [
            "Union Find",
            "Graph",
            "Sorting",
            "Minimum Spanning Tree",
            "Strongly Connected Component"
        ],
        "example": [
            {
                "input": "5,[[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]",
                "output": "[[0,1],[2,3,4,5]]"
            },
            {
                "input": "4,[[0,1,1],[1,2,1],[2,3,1],[0,3,1]]",
                "output": "[[],[0,1,2,3]]"
            }
        ],
        "java": "\n    ```java\npublic int maxSizeSlices(int[] slices) {\n    int n = slices.length / 3;\n    int[][] memo1 = new int[slices.length][n + 1];\n    for (int[] row : memo1) {\n        Arrays.fill(row, -1);\n    }\n    int[][] memo2 = new int[slices.length][n + 1];\n    for (int[] row : memo2) {\n        Arrays.fill(row, -1);\n    }\n\n    return Math.max(maxSum(slices, 0, slices.length - 1, n, memo1),\n                    maxSum(slices, 1, slices.length, n, memo2));\n}\n\nint maxSum(int[] slices, int start, int end, int n, int[][] memo) {\n    if (n == 0) return 0;\n    if (end - start + 1 < n * 2) return Integer.MIN_VALUE;\n    if (memo[start][n] != -1) return memo[start][n];\n\n    int pick = maxSum(slices, start + 2, end, n - 1, memo) + slices[start];\n    int notPick = maxSum(slices, start + 1, end, n, memo);\n\n    memo[start][n] = Math.max(pick, notPick);\n    return memo[start][n];\n}\n```\n\n    \n    We take a dynamic programming approach to solve the problem. Since we cannot take adjacent slices, we can start from the first slice and recurse with the remaining slices when we have taken the first slice, and when we haven't taken the first slice. When our n equals 0, that means we have taken all slices we can, and we should return 0.\n\nIf the remaining slices are less than 2 * n, we return the minimum sum possible. We store the memo for each case, the memo when we have taken the first slice and memo when we haven't taken the first slice. We return the max from both the memos, which is the maximum possible sum of slice sizes that we can pick.\n    ",
        "python": "\n    ```python\ndef max_size_slices(slices):\n    def max_sum(slices, start, end, n, memo):\n        if n == 0:\n            return 0\n        if end - start + 1 < n * 2:\n            return float('-inf')\n        if memo[start][n] != -1:\n            return memo[start][n]\n\n        pick = max_sum(slices, start + 2, end, n - 1, memo) + slices[start]\n        not_pick = max_sum(slices, start + 1, end, n, memo)\n\n        memo[start][n] = max(pick, not_pick)\n        return memo[start][n]\n\n    n = len(slices) // 3\n    memo1 = [[-1] * (n + 1) for _ in range(len(slices))]\n    memo2 = [[-1] * (n + 1) for _ in range(len(slices))]\n\n    return max(max_sum(slices, 0, len(slices) - 1, n, memo1),\n               max_sum(slices, 1, len(slices), n, memo2))\n```\n\n    \n    We take a dynamic programming approach to solve the problem. Since we cannot take adjacent slices, we can start from the first slice and recurse with the remaining slices when we have taken the first slice, and when we haven't taken the first slice. When our n equals 0, that means we have taken all slices we can, and we should return 0.\n\nIf the remaining slices are less than 2 * n, we return the minimum sum possible. We store the memo for each case, the memo when we have taken the first slice and memo when we haven't taken the first slice. We return the max from both the memos, which is the maximum possible sum of slice sizes that we can pick.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxSum(vector<int>& slices, int start, int end, int n, vector<vector<int>>& memo) {\n    if (n == 0) return 0;\n    if (end - start + 1 < n * 2) return INT_MIN;\n    if (memo[start][n] != -1) return memo[start][n];\n\n    int pick = maxSum(slices, start + 2, end, n - 1, memo) + slices[start];\n    int notPick = maxSum(slices, start + 1, end, n, memo);\n\n    memo[start][n] = max(pick, notPick);\n    return memo[start][n];\n}\n\nint maxSizeSlices(vector<int>& slices) {\n    int n = slices.size() / 3;\n    vector<vector<int>> memo1(slices.size(), vector<int>(n + 1, -1));\n    vector<vector<int>> memo2(slices.size(), vector<int>(n + 1, -1));\n\n    return max(maxSum(slices, 0, slices.size() - 1, n, memo1),\n               maxSum(slices, 1, slices.size(), n, memo2));\n}\n```\n\n    \n    We take a dynamic programming approach to solve the problem. Since we cannot take adjacent slices, we can start from the first slice and recurse with the remaining slices when we have taken the first slice, and when we haven't taken the first slice. When our n equals 0, that means we have taken all slices we can, and we should return 0.\n\nIf the remaining slices are less than 2 * n, we return the minimum sum possible. We store the memo for each case, the memo when we have taken the first slice and memo when we haven't taken the first slice. We return the max from both the memos, which is the maximum possible sum of slice sizes that we can pick.\n    ",
        "js": "\n    ```javascript\nfunction maxSizeSlices(slices) {\n    function maxSum(slices, start, end, n, memo) {\n        if (n === 0) return 0;\n        if (end - start + 1 < n * 2) return Number.NEGATIVE_INFINITY;\n        if (memo[start][n] !== -1) return memo[start][n];\n\n        const pick = maxSum(slices, start + 2, end, n - 1, memo) + slices[start];\n        const notPick = maxSum(slices, start + 1, end, n, memo);\n\n        memo[start][n] = Math.max(pick, notPick);\n        return memo[start][n];\n    }\n\n    const n = slices.length / 3;\n    const memo1 = Array.from({ length: slices.length }, () => Array(n + 1).fill(-1));\n    const memo2 = Array.from({ length: slices.length }, () => Array(n + 1).fill(-1));\n\n    return Math.max(maxSum(slices, 0, slices.length - 1, n, memo1),\n                   maxSum(slices, 1, slices.length, n, memo2));\n}\n```\n\n    \n    We take a dynamic programming approach to solve the problem. Since we cannot take adjacent slices, we can start from the first slice and recurse with the remaining slices when we have taken the first slice, and when we haven't taken the first slice. When our n equals 0, that means we have taken all slices we can, and we should return 0.\n\nIf the remaining slices are less than 2 * n, we return the minimum sum possible. We store the memo for each case, the memo when we have taken the first slice and memo when we haven't taken the first slice. We return the max from both the memos, which is the maximum possible sum of slice sizes that we can pick.\n    "
    },
    {
        "id": 239,
        "title": "Parallel Courses II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.\n\nIn one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, relations = \\[\\[2,1\\],\\[3,1\\],\\[1,4\\]\\], k = 2\n**Output:** 3\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[2,1\\],\\[3,1\\],\\[4,1\\],\\[1,5\\]\\], k = 2\n**Output:** 4\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 15`\n*   `1 <= k <= n`\n*   `0 <= relations.length <= n * (n-1) / 2`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.\n*   The given graph is a directed acyclic graph.",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation",
            "Graph",
            "Bitmask"
        ],
        "example": [
            {
                "input": "4,[[2,1],[3,1],[1,4]],2",
                "output": "3"
            },
            {
                "input": "5,[[2,1],[3,1],[4,1],[1,5]],2",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minNumberOfSemesters(int n, int[][] relations, int k) {\n    int[] indegree = new int[n + 1];\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i <= n; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] relation : relations) {\n        graph.get(relation[0]).add(relation[1]);\n        indegree[relation[1]]++;\n    }\n\n    int semesters = 0;\n    while (n > 0) {\n        Queue<Integer> zero_indegree = new LinkedList<>();\n        for (int i = 1; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                zero_indegree.add(i);\n                indegree[i] = -1;\n            }\n        }\n\n        int courses = 0;\n        while (!zero_indegree.isEmpty() && courses < k) {\n            int curr_course = zero_indegree.poll();\n            n--;\n\n            for (int next_course : graph.get(curr_course)) {\n                indegree[next_course]--;\n            }\n            courses++;\n        }\n        semesters++;\n    }\n    return semesters;\n}\n```\n    \n    The algorithm uses the topological sorting approach to solve the problem.\n\n1. First, initialize an indegree array that stores the indegree of each node (course) and a graph array, which will store the adjacency list representation of the given directed graph.\n\n2. Iterate through the relations and construct the adjacency list and update the indegree array.\n\n3. Initialize a variable `semesters` to keep track of the minimum number of semesters.\n\n4. Until all courses have been taken (n > 0), perform the following steps:\n   a. Initialize a queue `zero_indegree` and iterate through the indegree array to push nodes with indegree 0 into the queue. Also, mark the indegree at that position as -1 to avoid duplicates.\n   b. Initialize a variable `courses` to keep track of courses taken this semester.\n   c. While there are still courses to take this semester and `courses` is less than k, do the following:\n      i. Dequeue a course with 0 indegree from the queue, decrease the total number of courses to be taken(n--).\n      ii. Update the indegree for each next course adjacent to the dequeued course.\n      iii. Increment the `courses` counter.\n   d. Increment the `semesters` counter.\n\n5. Return the `semesters` as the minimum number of semesters to take all courses.\n\nThis approach guarantees a minimal number of semesters because it first takes the courses that have no prerequisites in each semester up to the limit k, and then the courses with the least pre-requisites, making it possible to take as many courses as possible in each semester.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters\n```\n    \n    The algorithm uses the topological sorting approach to solve the problem.\n\n1. First, initialize an indegree array that stores the indegree of each node (course) and a graph array, which will store the adjacency list representation of the given directed graph.\n\n2. Iterate through the relations and construct the adjacency list and update the indegree array.\n\n3. Initialize a variable `semesters` to keep track of the minimum number of semesters.\n\n4. Until all courses have been taken (n > 0), perform the following steps:\n   a. Initialize a queue `zero_indegree` and iterate through the indegree array to push nodes with indegree 0 into the queue. Also, mark the indegree at that position as -1 to avoid duplicates.\n   b. Initialize a variable `courses` to keep track of courses taken this semester.\n   c. While there are still courses to take this semester and `courses` is less than k, do the following:\n      i. Dequeue a course with 0 indegree from the queue, decrease the total number of courses to be taken(n--).\n      ii. Update the indegree for each next course adjacent to the dequeued course.\n      iii. Increment the `courses` counter.\n   d. Increment the `semesters` counter.\n\n5. Return the `semesters` as the minimum number of semesters to take all courses.\n\nThis approach guarantees a minimal number of semesters because it first takes the courses that have no prerequisites in each semester up to the limit k, and then the courses with the least pre-requisites, making it possible to take as many courses as possible in each semester.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\n    vector<int> indegree(n + 1, 0);\n    vector<vector<int>> graph(n + 1);\n\n    for (const auto& relation : relations) {\n        graph[relation[0]].push_back(relation[1]);\n        indegree[relation[1]]++;\n    }\n\n    int semesters = 0;\n    while (n > 0) {\n        queue<int> zero_indegree;\n        for (int i = 1; i < indegree.size(); ++i) {\n            if (indegree[i] == 0) {\n                zero_indegree.push(i);\n                indegree[i] = -1;\n            }\n        }\n\n        int courses = 0;\n        while (!zero_indegree.empty() && courses < k) {\n            int curr_course = zero_indegree.front();\n            zero_indegree.pop();\n            n--;\n\n            for (int next_course : graph[curr_course]) {\n                indegree[next_course]--;\n            }\n            courses++;\n        }\n        semesters++;\n    }\n    return semesters;\n}\n```\n    \n    The algorithm uses the topological sorting approach to solve the problem.\n\n1. First, initialize an indegree array that stores the indegree of each node (course) and a graph array, which will store the adjacency list representation of the given directed graph.\n\n2. Iterate through the relations and construct the adjacency list and update the indegree array.\n\n3. Initialize a variable `semesters` to keep track of the minimum number of semesters.\n\n4. Until all courses have been taken (n > 0), perform the following steps:\n   a. Initialize a queue `zero_indegree` and iterate through the indegree array to push nodes with indegree 0 into the queue. Also, mark the indegree at that position as -1 to avoid duplicates.\n   b. Initialize a variable `courses` to keep track of courses taken this semester.\n   c. While there are still courses to take this semester and `courses` is less than k, do the following:\n      i. Dequeue a course with 0 indegree from the queue, decrease the total number of courses to be taken(n--).\n      ii. Update the indegree for each next course adjacent to the dequeued course.\n      iii. Increment the `courses` counter.\n   d. Increment the `semesters` counter.\n\n5. Return the `semesters` as the minimum number of semesters to take all courses.\n\nThis approach guarantees a minimal number of semesters because it first takes the courses that have no prerequisites in each semester up to the limit k, and then the courses with the least pre-requisites, making it possible to take as many courses as possible in each semester.\n    ",
        "js": "\n    ```javascript\nfunction minNumberOfSemesters(n, relations, k) {\n    const indegree = new Array(n + 1).fill(0);\n    const graph = new Array(n + 1).fill().map(() => []);\n  \n    for (const [prevCourse, nextCourse] of relations) {\n        graph[prevCourse].push(nextCourse);\n        indegree[nextCourse]++;\n    }\n  \n    let semesters = 0;\n    while (n > 0) {\n        const zero_indegree = [];\n        for (let i = 1; i < indegree.length; i++) {\n            if (indegree[i] === 0) {\n                zero_indegree.push(i);\n                indegree[i] = -1;\n            }\n        }\n  \n        let courses = 0;\n        while (zero_indegree.length > 0 && courses < k) {\n            const curr_course = zero_indegree.shift();\n            n--;\n  \n            for (const next_course of graph[curr_course]) {\n                indegree[next_course]--;\n            }\n            courses++;\n        }\n        semesters++;\n    }\n    return semesters;\n}\n```\n    \n    The algorithm uses the topological sorting approach to solve the problem.\n\n1. First, initialize an indegree array that stores the indegree of each node (course) and a graph array, which will store the adjacency list representation of the given directed graph.\n\n2. Iterate through the relations and construct the adjacency list and update the indegree array.\n\n3. Initialize a variable `semesters` to keep track of the minimum number of semesters.\n\n4. Until all courses have been taken (n > 0), perform the following steps:\n   a. Initialize a queue `zero_indegree` and iterate through the indegree array to push nodes with indegree 0 into the queue. Also, mark the indegree at that position as -1 to avoid duplicates.\n   b. Initialize a variable `courses` to keep track of courses taken this semester.\n   c. While there are still courses to take this semester and `courses` is less than k, do the following:\n      i. Dequeue a course with 0 indegree from the queue, decrease the total number of courses to be taken(n--).\n      ii. Update the indegree for each next course adjacent to the dequeued course.\n      iii. Increment the `courses` counter.\n   d. Increment the `semesters` counter.\n\n5. Return the `semesters` as the minimum number of semesters to take all courses.\n\nThis approach guarantees a minimal number of semesters because it first takes the courses that have no prerequisites in each semester up to the limit k, and then the courses with the least pre-requisites, making it possible to take as many courses as possible in each semester.\n    "
    },
    {
        "id": 240,
        "title": "Max Value of Equation",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.\n\nReturn _the maximum value of the equation_ `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`.\n\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[2,0\\],\\[5,10\\],\\[6,-10\\]\\], k = 1\n**Output:** 4\n**Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[0,0\\],\\[3,0\\],\\[9,2\\]\\], k = 3\n**Output:** 3\n**Explanation:** Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-108 <= xi, yi <= 108`\n*   `0 <= k <= 2 * 108`\n*   `xi < xj` for all `1 <= i < j <= points.length`\n*   `xi` form a strictly increasing sequence.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[[1,3],[2,0],[5,10],[6,-10]],1",
                "output": "4"
            },
            {
                "input": "[[0,0],[3,0],[9,2]],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int maxPerformance(int n, int k, int[] speed, int[] efficiency) {\n        int[][] engineers = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            engineers[i] = new int[]{efficiency[i], speed[i]};\n        }\n        Arrays.sort(engineers, (a, b) -> b[0] - a[0]);\n\n        long sum = 0, result = 0;\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        for (int[] engineer : engineers) {\n            if (minHeap.size() >= k) {\n                sum -= minHeap.poll();\n            }\n            minHeap.offer(engineer[1]);\n            sum += engineer[1];\n            result = Math.max(result, engineer[0] * sum);\n        }\n        return (int) (result % 1000000007);\n    }\n}\n```\n    \n    1. Create an array of engineers where each element is a pair of efficiency and speed. Sort the array in descending order based on efficiency.\n2. Initialize a sum variable to store the sum of chosen engineers' speeds, and a result variable to store the maximum performance.\n3. Create and use a min heap (priority queue). Iterate through the sorted engineer array:\n   a. If the size of the min heap is equal to or greater than k, remove the smallest speed from the sum and min heap.\n   b. Add the engineer's speed to the min heap and the sum.\n   c. Calculate the performance (current efficiency * sum) and keep track of the maximum performance.\n4. Return the maximum performance modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef max_performance(n, k, speed, efficiency):\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n\n    result = 0\n    sum_speed = 0\n    min_heap = []\n    for e, s in engineers:\n        if len(min_heap) >= k:\n            sum_speed -= heapq.heappop(min_heap)\n\n        heapq.heappush(min_heap, s)\n        sum_speed += s\n        result = max(result, e * sum_speed)\n\n    return result % (10**9 + 7)\n```\n    \n    1. Create an array of engineers where each element is a pair of efficiency and speed. Sort the array in descending order based on efficiency.\n2. Initialize a sum variable to store the sum of chosen engineers' speeds, and a result variable to store the maximum performance.\n3. Create and use a min heap (priority queue). Iterate through the sorted engineer array:\n   a. If the size of the min heap is equal to or greater than k, remove the smallest speed from the sum and min heap.\n   b. Add the engineer's speed to the min heap and the sum.\n   c. Calculate the performance (current efficiency * sum) and keep track of the maximum performance.\n4. Return the maximum performance modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxPerformance(int n, int k, std::vector<int>& speed, std::vector<int>& efficiency) {\n    std::vector<std::pair<int, int>> engineers;\n    for (int i = 0; i < n; ++i) {\n        engineers.emplace_back(efficiency[i], speed[i]);\n    }\n    std::sort(engineers.rbegin(), engineers.rend());\n\n    long long sum = 0;\n    long long result = 0;\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    for (const auto& engineer : engineers) {\n        if (min_heap.size() >= k) {\n            sum -= min_heap.top();\n            min_heap.pop();\n        }\n        min_heap.push(engineer.second);\n        sum += engineer.second;\n        result = std::max(result, engineer.first * sum);\n    }\n    return result % 1000000007;\n}\n```\n    \n    1. Create an array of engineers where each element is a pair of efficiency and speed. Sort the array in descending order based on efficiency.\n2. Initialize a sum variable to store the sum of chosen engineers' speeds, and a result variable to store the maximum performance.\n3. Create and use a min heap (priority queue). Iterate through the sorted engineer array:\n   a. If the size of the min heap is equal to or greater than k, remove the smallest speed from the sum and min heap.\n   b. Add the engineer's speed to the min heap and the sum.\n   c. Calculate the performance (current efficiency * sum) and keep track of the maximum performance.\n4. Return the maximum performance modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction maxPerformance(n, k, speed, efficiency) {\n  const engineers = efficiency.map((e, i) => [e, speed[i]]);\n  engineers.sort((a, b) => b[0] - a[0]);\n\n  let sum = 0, result = 0;\n  const minHeap = new MinHeap();\n  for (const [e, s] of engineers) {\n    if (minHeap.size() >= k) {\n      sum -= minHeap.poll();\n    }\n    minHeap.offer(s);\n    sum += s;\n    result = Math.max(result, e * sum);\n  }\n\n  return result % 1000000007;\n}\n\nclass MinHeap {\n  constructor() {\n    this.data = [];\n  }\n\n  offer(value) {\n    this.data.push(value);\n    this._bubbleUp(this.data.length - 1);\n  }\n\n  poll() {\n    if (this.data.length === 0) {\n      return null;\n    }\n    if (this.data.length === 1) {\n      return this.data.pop();\n    }\n    const result = this.data[0];\n    this.data[0] = this.data.pop();\n    this._sinkDown(0);\n\n    return result;\n  }\n\n  size() {\n    return this.data.length;\n  }\n\n  _bubbleUp(index) {\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      const value = this.data[index];\n      const parentValue = this.data[parentIndex];\n      if (value >= parentValue) {\n        break;\n      }\n      this.data[parentIndex] = value;\n      this.data[index] = parentValue;\n      index = parentIndex;\n    }\n  }\n\n  _sinkDown(index) {\n    const last = this.data.length - 1;\n    while (true) {\n      const leftChildIndex = index * 2 + 1;\n      const rightChildIndex = leftChildIndex + 1;\n      let swapIndex = index;\n\n      if (leftChildIndex <= last && this.data[leftChildIndex] < this.data[swapIndex]) {\n        swapIndex = leftChildIndex;\n      }\n      if (rightChildIndex <= last && this.data[rightChildIndex] < this.data[swapIndex]) {\n        swapIndex = rightChildIndex;\n      }\n      if (swapIndex === index) {\n        break;\n      }\n      [this.data[index], this.data[swapIndex]] = [this.data[swapIndex], this.data[index]];\n      index = swapIndex;\n    }\n  }\n}\n```\n    \n    1. Create an array of engineers where each element is a pair of efficiency and speed. Sort the array in descending order based on efficiency.\n2. Initialize a sum variable to store the sum of chosen engineers' speeds, and a result variable to store the maximum performance.\n3. Create and use a min heap (priority queue). Iterate through the sorted engineer array:\n   a. If the size of the min heap is equal to or greater than k, remove the smallest speed from the sum and min heap.\n   b. Add the engineer's speed to the min heap and the sum.\n   c. Calculate the performance (current efficiency * sum) and keep track of the maximum performance.\n4. Return the maximum performance modulo 10^9 + 7.\n    "
    },
    {
        "id": 241,
        "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `num` representing **the digits** of a very large integer and an integer `k`. You are allowed to swap any two adjacent digits of the integer **at most** `k` times.\n\nReturn _the minimum integer you can obtain also as a string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"4321 \", k = 4\n**Output:**  \"1342 \"\n**Explanation:** The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"100 \", k = 1\n**Output:**  \"010 \"\n**Explanation:** It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"36789 \", k = 1000\n**Output:**  \"36789 \"\n**Explanation:** We can keep the number without any swaps."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 3 * 104`\n*   `num` consists of only **digits** and does not contain **leading zeros**.\n*   `1 <= k <= 109`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Binary Indexed Tree",
            "Segment Tree"
        ],
        "example": [
            {
                "input": "\"4321\",4",
                "output": "\"1342\""
            },
            {
                "input": "\"100\",1",
                "output": "\"010\""
            },
            {
                "input": "\"36789\",1000",
                "output": "\"36789\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int[] createTargetArray(int[] nums, int[] index) {\n    ArrayList<Integer> target = new ArrayList<>();\n    for (int i = 0; i < nums.length; ++i) {\n        target.add(index[i], nums[i]);\n    }\n    int[] result = new int[target.size()];\n    for (int i = 0; i < target.size(); ++i) {\n        result[i] = target.get(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    ",
        "python": "\n    ```python\ndef createTargetArray(nums, index):\n    target = []\n    for i in range(len(nums)):\n        target.insert(index[i], nums[i])\n    return target\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> createTargetArray(std::vector<int>& nums, std::vector<int>& index) {\n    std::vector<int> target;\n    for (int i = 0; i < nums.size(); ++i) {\n        target.insert(target.begin() + index[i], nums[i]);\n    }\n    return target;\n}\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    ",
        "js": "\n    ```javascript\nfunction createTargetArray(nums, index) {\n    let target = [];\n    for (let i = 0; i < nums.length; ++i) {\n        target.splice(index[i], 0, nums[i]);\n    }\n    return target;\n}\n```\n    \n    The algorithm first initializes an empty target array (or ArrayList in Java). Then, it iterates through the nums and index arrays. At each iteration, it inserts the current number from the nums array at the position specified by the current value in the index array. This is done using the insert function in C++ and Python, the splice function in JavaScript, and the add function in Java. At the end, the target array is returned.\n    "
    },
    {
        "id": 242,
        "title": "Stone Game IV",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there are `n` stones in a pile. On each player's turn, that player makes a _move_ consisting of removing **any** non-zero **square number** of stones in the pile.\n\nAlso, if a player cannot make a move, he/she loses the game.\n\nGiven a positive integer `n`, return `true` if and only if Alice wins the game otherwise return `false`, assuming both players play optimally.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** false\n**Explanation:** Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** true\n**Explanation:** n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Game Theory"
        ],
        "example": [
            {
                "input": "1",
                "output": "true"
            },
            {
                "input": "2",
                "output": "false"
            },
            {
                "input": "4",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int findLucky(int[] arr) {\n    HashMap<Integer, Integer> freq = new HashMap<>();\n\n    for (int n : arr) {\n        freq.put(n, freq.getOrDefault(n, 0) + 1);\n    }\n\n    int lucky = -1;\n    for (int key : freq.keySet()) {\n        if (key == freq.get(key)) {\n            lucky = Math.max(lucky, key);\n        }\n    }\n\n    return lucky;\n}\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    ",
        "python": "\n    ```python\ndef find_lucky(arr):\n    freq = {}\n\n    for n in arr:\n        if n in freq:\n            freq[n] += 1\n        else:\n            freq[n] = 1\n\n    lucky = -1\n    for key, value in freq.items():\n        if key == value:\n            lucky = max(lucky, key)\n\n    return lucky\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint findLucky(std::vector<int>& arr) {\n    std::unordered_map<int, int> freq;\n\n    for (int n : arr) {\n        freq[n]++;\n    }\n\n    int lucky = -1;\n    for (auto &pair : freq) {\n        if (pair.first == pair.second) {\n            lucky = std::max(lucky, pair.first);\n        }\n    }\n\n    return lucky;\n}\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    ",
        "js": "\n    ```javascript\nfunction findLucky(arr) {\n    let freq = {};\n\n    for (let n of arr) {\n        if (n in freq) {\n            freq[n]++;\n        } else {\n            freq[n] = 1;\n        }\n    }\n\n    let lucky = -1;\n    for (let key in freq) {\n        let value = freq[key];\n        if (parseInt(key) === value) {\n            lucky = Math.max(lucky, key);\n        }\n    }\n\n    return lucky;\n}\n```\n    \n    The algorithm starts by initializing an empty hash map called `freq` to store the frequencies of each integer in the array. Then, it iterates over the array and updates the frequencies in the hash map accordingly.\n\nAfter populating the hash map, the algorithm initializes a variable `lucky` with a value of -1. It then iterates over the key-value pairs in the hash map, checking if the key (the integer from the array) is equal to its value (the frequency). If an integer in the array has a frequency equal to its value, the algorithm updates the `lucky` variable to be the maximum of its current value and the integer in question.\n\nFinally, the `lucky` variable is returned as the largest lucky integer in the array. If no lucky integer is present, the initial value of -1 will be returned.\n    "
    },
    {
        "id": 243,
        "title": "Best Position for a Service Centre",
        "difficulty": "Hard",
        "content": {
            "problem": "A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that **the sum of the euclidean distances to all customers is minimum**.\n\nGiven an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return _the minimum sum of the euclidean distances_ to all customers.\n\nIn other words, you need to choose the position of the service center `[xcentre, ycentre]` such that the following formula is minimized:\n\nAnswers within `10-5` of the actual value will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** positions = \\[\\[0,1\\],\\[1,0\\],\\[1,2\\],\\[2,1\\]\\]\n**Output:** 4.00000\n**Explanation:** As shown, you can see that choosing \\[xcentre, ycentre\\] = \\[1, 1\\] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.\n\n",
                "**Example 2:**\n\n**Input:** positions = \\[\\[1,1\\],\\[3,3\\]\\]\n**Output:** 2.82843\n**Explanation:** The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= positions.length <= 50`\n*   `positions[i].length == 2`\n*   `0 <= xi, yi <= 100`\n\nF(0) = 0, F(1) = 1, F(n) = F(n - 1) + F(n - 2) for n >= 2.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry",
            "Randomized"
        ],
        "example": [
            {
                "input": "[[0,1],[1,0],[1,2],[2,1]]",
                "output": "4.00000"
            },
            {
                "input": "[[1,1],[3,3]]",
                "output": "2.82843"
            }
        ],
        "java": "\n    ```java\npublic int findMinFibonacciNumbers(int k) {\n    if (k == 0) return 0;\n    int a = 0, b = 1;\n    while (b <= k) {\n        int temp = a;\n        a = b;\n        b = temp + a;\n    }\n    return 1 + findMinFibonacciNumbers(k - a);\n}\n```\n    \n    The algorithm starts by initializing two variables to represent the Fibonacci sequence, a and b, initialized as 0 and 1 respectively. The algorithm then iterates through the Fibonacci sequence until it reaches a number greater than k, which will be stored in b. During iteration, a and b are swapped, and then, b is updated by adding the current value of a to the current value of b. Once the loop is done, the algorithm calls itself recursively by passing (k - a) as an input, which will deduct the last Fibonacci number found from k. Finally, the count returned from this recursive call is incremented by 1 (because we found one Fibonacci number in the current call), and the result is returned.\n\nThis process continues recursively until k reaches 0, which means we've found the minimum number of Fibonacci numbers that sum up to k.\n    ",
        "python": "\n    ```python\ndef find_min_fibonacci_numbers(k):\n    if k == 0:\n        return 0\n    a, b = 0, 1\n    while b <= k:\n        a, b = b, a + b\n    return 1 + find_min_fibonacci_numbers(k - a)\n```\n    \n    The algorithm starts by initializing two variables to represent the Fibonacci sequence, a and b, initialized as 0 and 1 respectively. The algorithm then iterates through the Fibonacci sequence until it reaches a number greater than k, which will be stored in b. During iteration, a and b are swapped, and then, b is updated by adding the current value of a to the current value of b. Once the loop is done, the algorithm calls itself recursively by passing (k - a) as an input, which will deduct the last Fibonacci number found from k. Finally, the count returned from this recursive call is incremented by 1 (because we found one Fibonacci number in the current call), and the result is returned.\n\nThis process continues recursively until k reaches 0, which means we've found the minimum number of Fibonacci numbers that sum up to k.\n    ",
        "c++": "\n    ```cpp\nint findMinFibonacciNumbers(int k) {\n    if (k == 0) return 0;\n    int a = 0, b = 1;\n    while (b <= k) {\n        swap(a, b);\n        b += a;\n    }\n    return 1 + findMinFibonacciNumbers(k - a);\n}\n```\n    \n    The algorithm starts by initializing two variables to represent the Fibonacci sequence, a and b, initialized as 0 and 1 respectively. The algorithm then iterates through the Fibonacci sequence until it reaches a number greater than k, which will be stored in b. During iteration, a and b are swapped, and then, b is updated by adding the current value of a to the current value of b. Once the loop is done, the algorithm calls itself recursively by passing (k - a) as an input, which will deduct the last Fibonacci number found from k. Finally, the count returned from this recursive call is incremented by 1 (because we found one Fibonacci number in the current call), and the result is returned.\n\nThis process continues recursively until k reaches 0, which means we've found the minimum number of Fibonacci numbers that sum up to k.\n    ",
        "js": "\n    ```javascript\nfunction findMinFibonacciNumbers(k) {\n    if (k === 0) return 0;\n    let a = 0, b = 1;\n    while (b <= k) {\n        [a, b] = [b, a + b];\n    }\n    return 1 + findMinFibonacciNumbers(k - a);\n}\n```\n    \n    The algorithm starts by initializing two variables to represent the Fibonacci sequence, a and b, initialized as 0 and 1 respectively. The algorithm then iterates through the Fibonacci sequence until it reaches a number greater than k, which will be stored in b. During iteration, a and b are swapped, and then, b is updated by adding the current value of a to the current value of b. Once the loop is done, the algorithm calls itself recursively by passing (k - a) as an input, which will deduct the last Fibonacci number found from k. Finally, the count returned from this recursive call is incremented by 1 (because we found one Fibonacci number in the current call), and the result is returned.\n\nThis process continues recursively until k reaches 0, which means we've found the minimum number of Fibonacci numbers that sum up to k.\n    "
    },
    {
        "id": 244,
        "title": "Maximum Number of Non-Overlapping Substrings",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` of lowercase letters, you need to find the maximum number of **non-empty** substrings of `s` that meet the following conditions:\n\n1.  The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[x..y]`, either `j < x` or `i > y` is true.\n2.  A substring that contains a certain character `c` must also contain all occurrences of `c`.\n\nFind _the maximum number of substrings that meet the above conditions_. If there are multiple solutions with the same number of substrings, _return the one with minimum total length._ It can be shown that there exists a unique solution of minimum total length.\n\nNotice that you can return the substrings in **any** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"adefaddaccc \"\n**Output:** \\[ \"e \", \"f \", \"ccc \"\\]\n**Explanation:** The following are all the possible substrings that meet the conditions:\n\\[\n   \"adefaddaccc \"\n   \"adefadda \",\n   \"ef \",\n   \"e \",\n   \"f \",\n   \"ccc \",\n\\]\nIf we choose the first string, we cannot choose anything else and we'd get only 1. If we choose  \"adefadda \", we are left with  \"ccc \" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose  \"ef \" since it can be split into two. Therefore, the optimal way is to choose \\[ \"e \", \"f \", \"ccc \"\\] which gives us 3 substrings. No other solution of the same number of substrings exist.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abbaccd \"\n**Output:** \\[ \"d \", \"bb \", \"cc \"\\]\n**Explanation:** Notice that while the set of substrings \\[ \"d \", \"abba \", \"cc \"\\] also has length 3, it's considered incorrect since it has larger total length."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"adefaddaccc\"",
                "output": "[\"e\",\"f\",\"ccc\"]"
            },
            {
                "input": "\"abbaccd\"",
                "output": "[\"d\",\"bb\",\"cc\"]"
            }
        ],
        "java": "\n    ```java\npublic int numSteps(String s) {\n    int steps = 0, carry = 0;\n    for (int i = s.length() - 1; i > 0; --i) {\n        int current = s.charAt(i) - '0' + carry;\n        if (current == 1) {\n            steps += 2;\n            carry = 1;\n        } else {\n            steps += carry;\n            carry = current;\n        }\n    }\n\n    return steps + carry;\n}\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    ",
        "python": "\n    ```python\ndef num_steps(s: str) -> int:\n    steps = 0\n    carry = 0\n\n    for i in range(len(s) - 1, 0, -1):\n        current = int(s[i]) + carry\n        if current == 1:\n            steps += 2\n            carry = 1\n        else:\n            steps += carry\n            carry = current\n\n    return steps + carry\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    ",
        "c++": "\n    ```cpp\nint num_steps(const std::string& s) {\n    int steps = 0, carry = 0;\n    for (int i = s.size() - 1; i > 0; --i) {\n        if (s[i] - '0' + carry == 1) {\n            steps += 2;\n            carry = 1;\n        } else {\n            steps += carry;\n            carry = s[i] - '0';\n        }\n    }\n\n    return steps + carry;\n}\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    ",
        "js": "\n    ```javascript\nfunction numSteps(s) {\n    let steps = 0, carry = 0;\n    for (let i = s.length - 1; i > 0; --i) {\n        let current = parseInt(s[i]) + carry;\n        if (current == 1) {\n            steps += 2;\n            carry = 1;\n        } else {\n            steps += carry;\n            carry = current;\n        }\n    }\n\n    return steps + carry;\n}\n```\n    \n    1. Initialize the count of steps and carry to 0.\n2. Iterate through the elements of the binary string from the least significant digit to the most significant digit.\n3. In each iteration, add the carry and the current digit.\n4. If the result is 1, increment the steps by 2 and update the carry to 1.\n5. If the result is not 1, increment the steps by the previous carry and update the carry with the result.\n6. Return the total number of steps taken plus the final carry.\n    "
    },
    {
        "id": 245,
        "title": "Find a Value of a Mysterious Function Closest to Target",
        "difficulty": "Hard",
        "content": {
            "problem": "Winston was given the above mysterious function `func`. He has an integer array `arr` and an integer `target` and he wants to find the values `l` and `r` that make the value `|func(arr, l, r) - target|` minimum possible.\n\nReturn _the minimum possible value_ of `|func(arr, l, r) - target|`.\n\nNotice that `func` should be called with the values `l` and `r` where `0 <= l, r < arr.length`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[9,12,3,7,15\\], target = 5\n**Output:** 2\n**Explanation:** Calling func with all the pairs of \\[l,r\\] = \\[\\[0,0\\],\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[0,2\\],\\[1,3\\],\\[2,4\\],\\[0,3\\],\\[1,4\\],\\[0,4\\]\\], Winston got the following results \\[9,12,3,7,15,8,0,3,7,0,0,3,0,0,0\\]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1000000,1000000,1000000\\], target = 1\n**Output:** 999999\n**Explanation:** Winston called the func with all possible values of \\[l,r\\] and he always got 1000000, thus the min difference is 999999.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[1,2,4,8,16\\], target = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 106`\n*   `0 <= target <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Bit Manipulation",
            "Segment Tree"
        ],
        "example": [
            {
                "input": "[9,12,3,7,15],5",
                "output": "2"
            },
            {
                "input": "[1000000,1000000,1000000],1",
                "output": "999999"
            },
            {
                "input": "[1,2,4,8,16],0",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int closestToTarget(int[] arr, int target) {\n    int minDiff = Integer.MAX_VALUE;\n    Set<Integer> prefix = new HashSet<>();\n\n    for (int n : arr) {\n        Set<Integer> nextPrefix = new HashSet<>();\n        for (int p : prefix) {\n            nextPrefix.add(p & n);\n        }\n        nextPrefix.add(n);\n\n        for (int p : nextPrefix) {\n            minDiff = Math.min(minDiff, Math.abs(p - target));\n        }\n        prefix = nextPrefix;\n    }\n    return minDiff;\n}\n```\n    \n    The algorithm iterates over each value `n` in the given array `arr`. For each `n`, it maintains a set `prefix` that contains all the bitwise AND results from the subsequences that end at the current index. For each value `p` in the current `prefix`, it calculates a new set `next_prefix` by applying the bitwise AND operation using the current value `n`. This way, it keeps track of all the possible bitwise AND values while iterating over the array. Then, it evaluates the difference between each of these values `p` and the target `target`, updating the `min_diff` whenever a smaller difference is found.\n    ",
        "python": "\n    ```python\ndef closestToTarget(arr: List[int], target: int) -> int:\n    min_diff = float('inf')\n    prefix = set()\n\n    for n in arr:\n        next_prefix = set()\n        for p in prefix:\n            next_prefix.add(p & n)\n        next_prefix.add(n)\n\n        for p in next_prefix:\n            min_diff = min(min_diff, abs(p - target))\n        prefix = next_prefix\n    return min_diff\n```\n    \n    The algorithm iterates over each value `n` in the given array `arr`. For each `n`, it maintains a set `prefix` that contains all the bitwise AND results from the subsequences that end at the current index. For each value `p` in the current `prefix`, it calculates a new set `next_prefix` by applying the bitwise AND operation using the current value `n`. This way, it keeps track of all the possible bitwise AND values while iterating over the array. Then, it evaluates the difference between each of these values `p` and the target `target`, updating the `min_diff` whenever a smaller difference is found.\n    ",
        "c++": "\n    ```cpp\nint closestToTarget(vector<int>& arr, int target) {\n    int min_diff = INT_MAX;\n    unordered_set<int> prefix;\n    \n    for (int n : arr) {\n        unordered_set<int> next_prefix;\n        for (int p : prefix) {\n            next_prefix.insert(p & n);\n        }\n        next_prefix.insert(n);\n\n        for (int p : next_prefix) {\n            min_diff = min(min_diff, abs(p - target));\n        }\n        swap(prefix, next_prefix);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm iterates over each value `n` in the given array `arr`. For each `n`, it maintains a set `prefix` that contains all the bitwise AND results from the subsequences that end at the current index. For each value `p` in the current `prefix`, it calculates a new set `next_prefix` by applying the bitwise AND operation using the current value `n`. This way, it keeps track of all the possible bitwise AND values while iterating over the array. Then, it evaluates the difference between each of these values `p` and the target `target`, updating the `min_diff` whenever a smaller difference is found.\n    ",
        "js": "\n    ```javascript\nfunction closestToTarget(arr, target) {\n    let minDiff = Infinity;\n    let prefix = new Set();\n\n    for (const n of arr) {\n        let nextPrefix = new Set();\n        for (const p of prefix) {\n            nextPrefix.add(p & n);\n        }\n        nextPrefix.add(n);\n\n        for (const p of nextPrefix) {\n            minDiff = Math.min(minDiff, Math.abs(p - target));\n        }\n        prefix = nextPrefix;\n    }\n    return minDiff;\n}\n```\n    \n    The algorithm iterates over each value `n` in the given array `arr`. For each `n`, it maintains a set `prefix` that contains all the bitwise AND results from the subsequences that end at the current index. For each value `p` in the current `prefix`, it calculates a new set `next_prefix` by applying the bitwise AND operation using the current value `n`. This way, it keeps track of all the possible bitwise AND values while iterating over the array. Then, it evaluates the difference between each of these values `p` and the target `target`, updating the `min_diff` whenever a smaller difference is found.\n    "
    },
    {
        "id": 246,
        "title": "Minimum Number of Increments on Subarrays to Form a Target Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment each value by one.\n\nReturn _the minimum number of operations to form a_ `target` _array from_ `initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = \\[1,2,3,2,1\\]\n**Output:** 3\n**Explanation:** We need at least 3 operations to form the target array from the initial array.\n\\[**0,0,0,0,0**\\] increment 1 from index 0 to 4 (inclusive).\n\\[1,**1,1,1**,1\\] increment 1 from index 1 to 3 (inclusive).\n\\[1,2,**2**,2,1\\] increment 1 at index 2.\n\\[1,2,3,2,1\\] target array is formed.\n\n",
                "**Example 2:**\n\n**Input:** target = \\[3,1,1,2\\]\n**Output:** 4\n**Explanation:** \\[**0,0,0,0**\\] -> \\[1,1,1,**1**\\] -> \\[**1**,1,1,2\\] -> \\[**2**,1,1,2\\] -> \\[3,1,1,2\\]\n\n",
                "**Example 3:**\n\n**Input:** target = \\[3,1,5,4,2\\]\n**Output:** 7\n**Explanation:** \\[**0,0,0,0,0**\\] -> \\[**1**,1,1,1,1\\] -> \\[**2**,1,1,1,1\\] -> \\[3,1,**1,1,1**\\] -> \\[3,1,**2,2**,2\\] -> \\[3,1,**3,3**,2\\] -> \\[3,1,**4**,4,2\\] -> \\[3,1,5,4,2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target.length <= 105`\n*   `1 <= target[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[1,2,3,2,1]",
                "output": "3"
            },
            {
                "input": "[3,1,1,2]",
                "output": "4"
            },
            {
                "input": "[3,1,5,4,2]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String entityParser(String text) {\n    HashMap<String, Character> entities = new HashMap<String, Character>();\n    entities.put(\"&quot;\", '\\\"');\n    entities.put(\"&apos;\", '\\'');\n    entities.put(\"&amp;\", '&');\n    entities.put(\"&gt;\", '>');\n    entities.put(\"&lt;\", '<');\n    entities.put(\"&frasl;\", '/');\n    \n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < text.length(); ++i) {\n        if (text.charAt(i) == '&') {\n            StringBuilder temp = new StringBuilder();\n            for (int j = i; j < text.length() && j < i + 7; ++j) {\n                temp.append(text.charAt(j));\n                Character c = entities.get(temp.toString());\n                if (c != null) {\n                    result.append(c);\n                    i = j;\n                    break;\n                }\n            }\n            if (temp.charAt(temp.length() - 1) != ';') result.append(text.charAt(i));\n        } else {\n            result.append(text.charAt(i));\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ",
        "python": "\n    ```python\ndef entityParser(text: str) -> str:\n    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nstring entityParser(string text) {\n    unordered_map<string, char> entities{\n        {\"&quot;\", '\\\"'},\n        {\"&apos;\", '\\''},\n        {\"&amp;\", '&'},\n        {\"&gt;\", '>'},\n        {\"&lt;\", '<'},\n        {\"&frasl;\", '/'}\n    };\n    string result;\n    for (int i = 0; i < text.size(); ++i) {\n        if (text[i] == '&') {\n            string temp;\n            for (int j = i; j < text.size() && j < i + 7; ++j) {\n                temp.push_back(text[j]);\n                if (entities.find(temp) != entities.end()) {\n                    result.push_back(entities[temp]);\n                    i = j;\n                    break;\n                }\n            }\n            if (temp.back() != ';') result.push_back(text[i]);\n        } else {\n            result.push_back(text[i]);\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ",
        "js": "\n    ```javascript\nfunction entityParser(text) {\n    const entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    };\n\n    let result = '';\n    for (let i = 0; i < text.length; ++i) {\n        if (text[i] === '&') {\n            let temp = '';\n            for (let j = i; j < text.length && j < i + 7; ++j) {\n                temp += text[j];\n                if (temp in entities) {\n                    result += entities[temp];\n                    i = j;\n                    break;\n                }\n            }\n            if (temp[temp.length - 1] !== ';') result += text[i];\n        } else {\n            result += text[i];\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    "
    },
    {
        "id": 247,
        "title": "String Compression II",
        "difficulty": "Hard",
        "content": {
            "problem": "[Run-length encoding](http://en.wikipedia.org/wiki/Run-length_encoding) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `\"aabccc \"` we replace `\"aa \"` by `\"a2 \"` and replace `\"ccc \"` by `\"c3 \"`. Thus the compressed string becomes `\"a2bc3 \"`.\n\nNotice that in this problem, we are not adding `'1'` after single characters.\n\nGiven a string `s` and an integer `k`. You need to delete **at most** `k` characters from `s` such that the run-length encoded version of `s` has minimum length.\n\nFind the _minimum length of the run-length encoded version of_ `s` _after deleting at most_ `k` _characters_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaabcccd \", k = 2\n**Output:** 4\n**Explanation:** Compressing s without deleting anything will give us  \"a3bc3d \" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s =  \"abcccd \" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be  \"a3c3 \" of length 4.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aabbaa \", k = 2\n**Output:** 2\n**Explanation:** If we delete both 'b' characters, the resulting compressed string would be  \"a4 \" of length 2.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aaaaaaaaaaa \", k = 0\n**Output:** 3\n**Explanation:** Since k is zero, we cannot delete anything. The compressed string is  \"a11 \" of length 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `0 <= k <= s.length`\n*   `s` contains only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"aaabcccd\",2",
                "output": "4"
            },
            {
                "input": "\"aabbaa\",2",
                "output": "2"
            },
            {
                "input": "\"aaaaaaaaaaa\",0",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int numberWays(List<List<Integer>> hats) {\n    final int kMod = 1000000007;\n    final int kMaxHats = 40;\n    \n    int num_people = hats.size();\n    List<List<Integer>> people_with_hat = new ArrayList<>();\n    \n    for (int i = 0; i < kMaxHats; ++i) {\n        people_with_hat.add(new ArrayList<>());\n    }\n\n    for (int i = 0; i < num_people; ++i) {\n        for (int hat : hats.get(i)) {\n            people_with_hat.get(hat - 1).add(i);\n        }\n    }\n\n    int[][] dp = new int[1 << num_people][kMaxHats + 1];\n    dp[0][0] = 1;\n\n    for (int hat = 0; hat < kMaxHats; ++hat) {\n        for (int mask = (1 << num_people) - 1; mask >= 0; --mask) {\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;\n            for (int person : people_with_hat.get(hat)) {\n                if ((mask & (1 << person)) == 0) {\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod;\n                }\n            }\n        }\n    }\n\n    return dp[(1 << num_people) - 1][kMaxHats];\n}\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    ",
        "python": "\n    ```python\ndef number_ways(hats):\n    kMod = 1000000007\n    kMaxHats = 40\n\n    num_people = len(hats)\n    people_with_hat = [[] for _ in range(kMaxHats)]\n\n    for i in range(num_people):\n        for hat in hats[i]:\n            people_with_hat[hat - 1].append(i)\n\n    dp = [[0] * (kMaxHats + 1) for _ in range(1 << num_people)]\n    dp[0][0] = 1\n\n    for hat in range(kMaxHats):\n        for mask in reversed(range(1 << num_people)):\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod\n            for person in people_with_hat[hat]:\n                if mask & (1 << person) == 0:\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod\n\n    return dp[(1 << num_people) - 1][kMaxHats]\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n\nint numberWays(std::vector<std::vector<int>>& hats) {\n    const int kMod = 1000000007;\n    const int kMaxHats = 40;\n    \n    int num_people = hats.size();\n    std::vector<std::vector<int>> people_with_hat(kMaxHats);\n    std::vector<std::vector<int>> dp(1<<num_people, std::vector<int>(kMaxHats+1, 0));\n    \n    for(int i = 0; i < num_people; ++i) {\n        for(int hat : hats[i]) {\n            people_with_hat[hat - 1].push_back(i);\n        }\n    }\n    \n    dp[0][0] = 1;\n    \n    for(int hat = 0; hat < kMaxHats; ++hat) {\n        for(int mask = (1<<num_people) - 1; mask >= 0; --mask) {\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;\n            for(int person : people_with_hat[hat]) {\n                if((mask & (1<<person)) == 0) {\n                    dp[mask | (1<<person)][hat + 1] = (dp[mask | (1<<person)][hat + 1] + dp[mask][hat]) % kMod;\n                }\n            }\n        }\n    }\n    \n    return dp[(1<<num_people) - 1][kMaxHats];\n}\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    ",
        "js": "\n    ```javascript\nfunction numberWays(hats) {\n    const kMod = 1000000007;\n    const kMaxHats = 40;\n\n    const num_people = hats.length;\n    const people_with_hat = Array.from({length: kMaxHats}, () => []);\n\n    for (let i = 0; i < num_people; ++i) {\n        for (const hat of hats[i]) {\n            people_with_hat[hat - 1].push(i);\n        }\n    }\n\n    const dp = Array.from({length: 1 << num_people}, () => Array(kMaxHats + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let hat = 0; hat < kMaxHats; ++hat) {\n        for (let mask = (1 << num_people) - 1; mask >= 0; --mask) {\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;\n            for (const person of people_with_hat[hat]) {\n                if ((mask & (1 << person)) === 0) {\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod;\n                }\n            }\n        }\n    }\n\n    return dp[(1 << num_people) - 1][kMaxHats];\n}\n```\n    \n    We create an array `people_with_hat` to store the indexes of people who prefer each hat. Then, we use dynamic programming to find the number of ways that the n people wear different hats to each other.\n\nOur DP state is `dp[mask][hat]`, which represents the number of ways to assign hats 1 through hat to people, such that people with index `i` (0-indexed) gets a hat if the `i`-th bit of `mask` is set. We initialize `dp[0][0] = 1`.\n\nWe iterate through each hat (0-indexed array) and, for each mask from (1<<num_people)-1 to 0, we try two options:\n1. Assign the current hat to no one - add `dp[mask][hat]` to `dp[mask][hat+1]`.\n2. Assign the current hat to one of the people who prefer it, if the `i`-th bit of `mask` (0-indexed) is unset. In this case, we set the `i`-th bit of the mask and update `dp[mask | (1<<person)][hat+1]`.\n\nFinally, we return the value in `dp[(1<<num_people) - 1][kMaxHats]`, which represents the number of ways of assigning all hats to the given people with their preferences.\n\nNotice that we are using modulo 109 + 7 to avoid integer overflow.\n    "
    },
    {
        "id": 248,
        "title": "Get the Maximum Score",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[2,4,5,8,10],[4,6,8,9]",
                "output": "30"
            },
            {
                "input": "[1,3,5,7,9],[3,5,100]",
                "output": "109"
            },
            {
                "input": "[1,2,3,4,5],[6,7,8,9,10]",
                "output": "40"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(String s) {\n    int left_zeros = 0, right_ones = 0, max_score = 0;\n    for(char c : s.toCharArray()) if(c == '1') right_ones++;      \n        \n    for(int i = 0; i < s.length() - 1; i++) {\n        if(s.charAt(i) == '0') left_zeros++;\n        else right_ones--;\n        max_score = Math.max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ",
        "python": "\n    ```python\ndef maxScore(s):\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ",
        "c++": "\n    ```cpp\nint maxScore(string s) {\n    int left_zeros = 0, right_ones = 0, max_score = 0;\n    for(char c : s) if(c == '1') right_ones++;\n        \n    for(int i = 0; i < s.size() - 1; i++) {\n        if(s[i] == '0') left_zeros++;\n        else right_ones--;\n        max_score = max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(s) {\n    let left_zeros = 0, right_ones = 0, max_score = 0;\n    for(let c of s) if(c === '1') right_ones++;\n        \n    for(let i = 0; i < s.length - 1; i++) {\n        if(s[i] === '0') left_zeros++;\n        else right_ones--;\n        max_score = Math.max(max_score, left_zeros + right_ones);\n    }\n    return max_score;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize three variables: `left_zeros` to count zeros in the left substring, `right_ones` to count ones in the right substring, and `max_score` to store the maximum score after checking all possible splits.\n2. Count the total number of ones in the whole string and store it in `right_ones`.\n3. Iterate through the string (excluding the last character since both substrings should be non-empty) and for each character i, do the following:\n   a. If the character is '0', increment `left_zeros`. Else, decrement `right_ones` as the character '1' is moving from the right substring to the left substring.\n   b. Calculate the score by adding `left_zeros` and `right_ones`, and update `max_score` if it is less than the current score.\n4. Return the `max_score` after the iteration is complete.\n    "
    },
    {
        "id": 249,
        "title": "Find Longest Awesome Substring",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s`. An **awesome** substring is a non-empty substring of `s` such that we can make any number of swaps in order to make it a palindrome.\n\nReturn _the length of the maximum length **awesome substring** of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"3242415 \"\n**Output:** 5\n**Explanation:**  \"24241 \" is the longest awesome substring, we can form the palindrome  \"24142 \" with some swaps.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"12345678 \"\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** s =  \"213123 \"\n**Output:** 6\n**Explanation:**  \"213123 \" is the longest awesome substring, we can form the palindrome  \"231132 \" with some swaps."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists only of digits.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "\"3242415\"",
                "output": "5"
            },
            {
                "input": "\"12345678\"",
                "output": "1"
            },
            {
                "input": "\"213123\"",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int maxPower(String s) {\n    int maxPower = 0, currentPower = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i-1)) {\n            currentPower++;\n        } else {\n            maxPower = Math.max(maxPower, currentPower);\n            currentPower = 1;\n        }\n    }\n\n    return Math.max(maxPower, currentPower);\n}\n```\n    \n    The given algorithm iterates through the input string `s` and compares the current character with the previous character. If the current character is equal to the previous one, it increments the `currentPower` value. If not, it compares the `maxPower` and `currentPower` values, assigning the maximum value to `maxPower` and resetting the `currentPower` to 1. Once the string has been iterated through, the max power is the maximum of `maxPower` and `currentPower`. This algorithm works in O(n) time complexity, where n is the length of the input string.\n    ",
        "python": "\n    ```python\ndef max_power(s: str) -> int:\n    max_power = current_power = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            current_power += 1\n        else:\n            max_power = max(max_power, current_power)\n            current_power = 1\n\n    return max(max_power, current_power)\n```\n    \n    The given algorithm iterates through the input string `s` and compares the current character with the previous character. If the current character is equal to the previous one, it increments the `currentPower` value. If not, it compares the `maxPower` and `currentPower` values, assigning the maximum value to `maxPower` and resetting the `currentPower` to 1. Once the string has been iterated through, the max power is the maximum of `maxPower` and `currentPower`. This algorithm works in O(n) time complexity, where n is the length of the input string.\n    ",
        "c++": "\n    ```cpp\nint maxPower(const std::string& s) {\n    int maxPower = 0, currentPower = 1;\n\n    for (int i = 1; i < s.length(); ++i) {\n        if (s[i] == s[i-1]) {\n            currentPower++;\n        } else {\n            maxPower = std::max(maxPower, currentPower);\n            currentPower = 1;\n        }\n    }\n\n    return std::max(maxPower, currentPower);\n}\n```\n    \n    The given algorithm iterates through the input string `s` and compares the current character with the previous character. If the current character is equal to the previous one, it increments the `currentPower` value. If not, it compares the `maxPower` and `currentPower` values, assigning the maximum value to `maxPower` and resetting the `currentPower` to 1. Once the string has been iterated through, the max power is the maximum of `maxPower` and `currentPower`. This algorithm works in O(n) time complexity, where n is the length of the input string.\n    ",
        "js": "\n    ```javascript\nfunction maxPower(s) {\n    let maxPower = 0, currentPower = 1;\n\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i-1]) {\n            currentPower++;\n        } else {\n            maxPower = Math.max(maxPower, currentPower);\n            currentPower = 1;\n        }\n    }\n\n    return Math.max(maxPower, currentPower);\n}\n```\n    \n    The given algorithm iterates through the input string `s` and compares the current character with the previous character. If the current character is equal to the previous one, it increments the `currentPower` value. If not, it compares the `maxPower` and `currentPower` values, assigning the maximum value to `maxPower` and resetting the `currentPower` to 1. Once the string has been iterated through, the max power is the maximum of `maxPower` and `currentPower`. This algorithm works in O(n) time complexity, where n is the length of the input string.\n    "
    },
    {
        "id": 250,
        "title": "Minimum Cost to Cut a Stick",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n",
                "**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "7,[1,3,4,5]",
                "output": "16"
            },
            {
                "input": "9,[5,6,1,4,2]",
                "output": "22"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String destCity(List<List<String>> paths) {\n    Set<String> startingCities = new HashSet<>();\n    for (List<String> path : paths)\n        startingCities.add(path.get(0));\n\n    for (List<String> path : paths) {\n        if (!startingCities.contains(path.get(1)))\n            return path.get(1);\n    }\n\n    return \"\";\n}\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    ",
        "python": "\n    ```python\ndef destCity(paths):\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\"\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nstd::string destCity(std::vector<std::vector<std::string>>& paths) {\n    std::unordered_set<std::string> starting_cities;\n    for (const auto& path : paths)\n        starting_cities.insert(path[0]);\n\n    for (const auto& path : paths) {\n        if (starting_cities.find(path[1]) == starting_cities.end())\n            return path[1];\n    }\n\n    return \"\";\n}\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    ",
        "js": "\n    ```javascript\nfunction destCity(paths) {\n    const startingCities = new Set();\n\n    for (const path of paths)\n        startingCities.add(path[0]);\n\n    for (const path of paths) {\n        if (!startingCities.has(path[1]))\n            return path[1];\n    }\n\n    return \"\";\n}\n```\n    \n    We start by creating a set `starting_cities` that will contain all the cities that have a direct path _outgoing_ from them. Then, for each path, we add the city where the path starts to our set.\n\nOnce we have the set, we iterate through the given paths again, checking if the destination city of each path (cityBi) is present in the set `starting_cities`. If a city is not present in the set, that means it doesn't have any outgoing path, and we return that city as the destination city.\n\nThe algorithm has a time complexity of O(n), where n is the number of paths, since we iterate through the paths twice. \n    "
    },
    {
        "id": 251,
        "title": "Stone Game V",
        "difficulty": "Hard",
        "content": {
            "problem": "There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.",
            "examples": [
                "**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n",
                "**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n",
                "**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Game Theory"
        ],
        "example": [
            {
                "input": "[6,2,3,4,5,5]",
                "output": "18"
            },
            {
                "input": "[7,7,7,7,7,7,7]",
                "output": "28"
            },
            {
                "input": "[4]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.awt.geom.Point2D;\nimport java.util.List;\n\npublic int maxNumberOfDarts(List<List<Integer>> darts, int r) {\n    int n = darts.size();\n    int maxDarts = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = Point2D.distance(darts.get(j).get(0), darts.get(j).get(1), darts.get(i).get(0), darts.get(i).get(1));\n            if (dist > 2.0 * r) continue;\n\n            double angle = Math.acos(dist / (2.0 * r));\n            for (int k = 0; k < 2; k++) {\n                double locAngle = angle * (k == 0 ? 1 : -1);\n                double cx = darts.get(i).get(0) + r * (darts.get(j).get(0) - darts.get(i).get(0)) / dist * Math.cos(locAngle) - r * (darts.get(j).get(1) - darts.get(i).get(1)) / dist * Math.sin(locAngle);\n                double cy = darts.get(i).get(1) + r * (darts.get(j).get(0) - darts.get(i).get(0)) / dist * Math.sin(locAngle) + r * (darts.get(j).get(1) - darts.get(i).get(1)) / dist * Math.cos(locAngle);\n\n                int cnt = 0;\n                for (int l = 0; l < n; l++) {\n                    double newDist = Point2D.distance(darts.get(l).get(0), darts.get(l).get(1), cx, cy);\n                    if (newDist <= r + 1e-5) cnt++;\n                }\n\n                maxDarts = Math.max(maxDarts, cnt);\n            }\n        }\n    }\n\n    return maxDarts;\n}\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    ",
        "python": "\n    ```python\nfrom math import acos, cos, sin, sqrt\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    ",
        "c++": "\n    ```cpp\n#include <cmath>\n#include <vector>\n\nint maxNumberOfDarts(vector<vector<int>>& darts, int r) {\n    int n = darts.size();\n    int max_darts = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = hypot(darts[j][0] - darts[i][0], darts[j][1] - darts[i][1]);\n            if (dist > 2.0 * r) continue;\n\n            double angle = acos(dist / (2.0 * r));\n            for (int k = 0; k < 2; k++) {\n                double loc_angle = angle * (k == 0 ? 1 : -1);\n                double cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle);\n                double cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle);\n\n                int cnt = 0;\n                for (int l = 0; l < n; l++) {\n                    double new_dist = hypot(darts[l][0] - cx, darts[l][1] - cy);\n                    if (new_dist <= r + 1e-5) cnt++;\n                }\n\n                max_darts = max(max_darts, cnt);\n            }\n        }\n    }\n\n    return max_darts;\n}\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    ",
        "js": "\n    ```javascript\nfunction maxNumberOfDarts(darts, r) {\n    const n = darts.length;\n    let maxDarts = 1;\n\n    function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);\n    }\n\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            const dist = distance(darts[j][0], darts[j][1], darts[i][0], darts[i][1]);\n            if (dist > 2.0 * r) continue;\n\n            const angle = Math.acos(dist / (2.0 * r));\n            for (let k = 0; k < 2; k++) {\n                const locAngle = angle * (k === 0 ? 1 : -1);\n                const cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * Math.cos(locAngle) - r * (darts[j][1] - darts[i][1]) / dist * Math.sin(locAngle);\n                const cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * Math.sin(locAngle) + r * (darts[j][1] - darts[i][1]) / dist * Math.cos(locAngle);\n\n                let cnt = 0;\n                for (let l = 0; l < n; l++) {\n                    const newDist = distance(darts[l][0], darts[l][1], cx, cy);\n                    if (newDist <= r + 1e-5) cnt++;\n                }\n\n                maxDarts = Math.max(maxDarts, cnt);\n            }\n        }\n    }\n\n    return maxDarts;\n}\n```\n    \n    For each dart pair (i, j), we calculate the distance between them, and check if it's smaller than or equal to the diameter (2*r) of the dartboard. If so, find the two possible centers (c1, c2) of the dartboard using trigonometry (getting the angle between the chord connecting two darts and the radius, and the angle between the radius and the wall), where i-th and j-th darts lie on the edge.\n\nThen, for both possible centers of the dartboard, count how many darts in the array have a distance less than or equal to r and choose the highest value among all possible combinations of dart pairs and possible centers. This value is the maximum number of darts that can fit on the dartboard.\n    "
    },
    {
        "id": 252,
        "title": "Minimum Number of Days to Disconnect Island",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal **4-directionally** (horizontal or vertical) connected group of `1`'s.\n\nThe grid is said to be **connected** if we have **exactly one island**, otherwise is said **disconnected**.\n\nIn one day, we are allowed to change **any** single land cell `(1)` into a water cell `(0)`.\n\nReturn _the minimum number of days to disconnect the grid_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n\n**Output:** 2\n**Explanation:** We need at least 2 days to get a disconnected grid.\nChange land grid\\[1\\]\\[1\\] and grid\\[0\\]\\[2\\] to water and get 2 disconnected island.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 2\n**Explanation:** Grid of full water is also disconnected (\\[\\[1,1\\]\\] -> \\[\\[0,0\\]\\]), 0 islands."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Depth-First Search",
            "Breadth-First Search",
            "Matrix",
            "Strongly Connected Component"
        ],
        "example": [
            {
                "input": "[[0,1,1,0],[0,1,1,0],[0,0,0,0]]",
                "output": "2"
            },
            {
                "input": "[[1,1]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int pseudoPalindromicPaths(TreeNode root, int cnt) {\n    if (root == null) return 0;\n    cnt ^= 1 << (root.val - 1);\n    if (root.left == null && root.right == null)\n        return (cnt & (cnt - 1)) == 0 ? 1 : 0;\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt);\n}\n```\n    \n    The algorithm takes the root of the binary tree and iterates through each path from the root to leaf nodes using recursion. For each node in the path, it toggles the bit corresponding to the node's value in the integer `cnt`. The total number of non-empty pseudo-palindrome paths is found by recursively traversing the tree.\n\nWhen encountering a leaf node, the algorithm checks if the bitwise-and between `cnt` and `(cnt - 1)` is equal to 0. If true, this means that at most one bit is set in `cnt`, which indicates a pseudo-palindrome as there are either zero or one nodes that have an odd count, and the rest of the nodes have even counts. If the condition is satisfied, return 1, otherwise, return 0.\n\nThe function then adds up the number of pseudo-palindromic paths found in all branches of the tree.\n    ",
        "python": "\n    ```python\ndef pseudoPalindromicPaths(root, cnt = 0):\n    if not root:\n        return 0\n    cnt ^= 1 << (root.val - 1)\n    if not root.left and not root.right:\n        return (cnt & (cnt - 1)) == 0\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)\n```\n    \n    The algorithm takes the root of the binary tree and iterates through each path from the root to leaf nodes using recursion. For each node in the path, it toggles the bit corresponding to the node's value in the integer `cnt`. The total number of non-empty pseudo-palindrome paths is found by recursively traversing the tree.\n\nWhen encountering a leaf node, the algorithm checks if the bitwise-and between `cnt` and `(cnt - 1)` is equal to 0. If true, this means that at most one bit is set in `cnt`, which indicates a pseudo-palindrome as there are either zero or one nodes that have an odd count, and the rest of the nodes have even counts. If the condition is satisfied, return 1, otherwise, return 0.\n\nThe function then adds up the number of pseudo-palindromic paths found in all branches of the tree.\n    ",
        "c++": "\n    ```cpp\nint pseudoPalindromicPaths(TreeNode* root, int cnt = 0) {\n    if (!root) return 0;\n    cnt ^= 1 << (root->val - 1);\n    if (!root->left && !root->right)\n        return (cnt & (cnt - 1)) == 0; \n    return pseudoPalindromicPaths(root->left, cnt) + pseudoPalindromicPaths(root->right, cnt);\n}\n```\n    \n    The algorithm takes the root of the binary tree and iterates through each path from the root to leaf nodes using recursion. For each node in the path, it toggles the bit corresponding to the node's value in the integer `cnt`. The total number of non-empty pseudo-palindrome paths is found by recursively traversing the tree.\n\nWhen encountering a leaf node, the algorithm checks if the bitwise-and between `cnt` and `(cnt - 1)` is equal to 0. If true, this means that at most one bit is set in `cnt`, which indicates a pseudo-palindrome as there are either zero or one nodes that have an odd count, and the rest of the nodes have even counts. If the condition is satisfied, return 1, otherwise, return 0.\n\nThe function then adds up the number of pseudo-palindromic paths found in all branches of the tree.\n    ",
        "js": "\n    ```javascript\nfunction pseudoPalindromicPaths(root, cnt = 0) {\n    if (!root) return 0;\n    cnt ^= 1 << (root.val - 1);\n    if (!root.left && !root.right)\n        return (cnt & (cnt - 1)) == 0 ? 1 : 0;\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt);\n}\n```\n\n    \n    The algorithm takes the root of the binary tree and iterates through each path from the root to leaf nodes using recursion. For each node in the path, it toggles the bit corresponding to the node's value in the integer `cnt`. The total number of non-empty pseudo-palindrome paths is found by recursively traversing the tree.\n\nWhen encountering a leaf node, the algorithm checks if the bitwise-and between `cnt` and `(cnt - 1)` is equal to 0. If true, this means that at most one bit is set in `cnt`, which indicates a pseudo-palindrome as there are either zero or one nodes that have an odd count, and the rest of the nodes have even counts. If the condition is satisfied, return 1, otherwise, return 0.\n\nThe function then adds up the number of pseudo-palindromic paths found in all branches of the tree.\n    "
    },
    {
        "id": 253,
        "title": "Number of Ways to Reorder Array to Get Same BST",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n\n*   For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n\nReturn _the number of ways to reorder_ `nums` _such that the BST formed is identical to the original BST formed from_ `nums`.\n\nSince the answer may be very large, **return it modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,3\\]\n**Output:** 1\n**Explanation:** We can reorder nums to be \\[2,3,1\\] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 5\n**Explanation:** The following 5 arrays will yield the same BST: \n\\[3,1,2,4,5\\]\n\\[3,1,4,2,5\\]\n\\[3,1,4,5,2\\]\n\\[3,4,1,2,5\\]\n\\[3,4,1,5,2\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** There are no other orderings of nums that will yield the same BST."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= nums.length`\n*   All integers in `nums` are **distinct**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Divide and Conquer",
            "Dynamic Programming",
            "Tree",
            "Union Find",
            "Binary Search Tree",
            "Memoization",
            "Combinatorics",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[2,1,3]",
                "output": "1"
            },
            {
                "input": "[3,4,5,1,2]",
                "output": "5"
            },
            {
                "input": "[1,2,3]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxDotProduct(int[] nums1, int[] nums2) {\n    int n = nums1.length, m = nums2.length;\n    int[][] dp = new int[n + 1][m + 1];\n    for (int i = 0; i <= n; ++i) {\n        Arrays.fill(dp[i], Integer.MIN_VALUE);\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][j], Math.max(dp[i][j - 1], Math.max(dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]))));\n        }\n    }\n    return dp[n][m];\n}\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    ",
        "python": "\n    ```python\ndef maxDotProduct(nums1, nums2):\n    n, m = len(nums1), len(nums2)\n    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])\n    return dp[n][m]\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    ",
        "c++": "\n    ```cpp\nint maxDotProduct(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size(), m = nums2.size();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = max({dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]});\n        }\n    }\n    return dp[n][m];\n}\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    ",
        "js": "\n    ```javascript\nfunction maxDotProduct(nums1, nums2) {\n    const n = nums1.length, m = nums2.length;\n    const dp = Array.from(Array(n + 1), () => Array(m + 1).fill(Number.MIN_SAFE_INTEGER));\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= m; ++j) {\n            dp[i][j] = Math.max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]);\n        }\n    }\n    return dp[n][m];\n}\n```\n    \n    The algorithm iterates over both input arrays with nested loops, creating a two-dimensional DP table. For each cell (i, j) in the table, it finds the maximum between multiple alternatives:\n1. Previous value at dp[i][j]\n2. Value at dp[i-1][j]\n3. Value at dp[i][j-1]\n4. Value at (dp[i-1][j-1] + nums1[i-1] * nums2[j-1]) (i.e., including a dot product at the current position)\n5. Value at (nums1[i-1] * nums2[j-1]) (i.e., starting a new subsequence at the current position)\n\nAfter filling the DP table, dp[n][m] contains the maximum dot product between the two input arrays.\n    "
    },
    {
        "id": 254,
        "title": "Count All Possible Routes",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of **distinct** positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively.\n\nAt each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.\n\nNotice that `fuel` **cannot** become negative at any point in time, and that you are **allowed** to visit any city more than once (including `start` and `finish`).\n\nReturn _the count of all possible routes from_ `start` _to_ `finish`. Since the answer may be too large, return it modulo `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** locations = \\[2,3,6,8,4\\], start = 1, finish = 3, fuel = 5\n**Output:** 4\n**Explanation:** The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\n",
                "**Example 2:**\n\n**Input:** locations = \\[4,3,1\\], start = 1, finish = 0, fuel = 6\n**Output:** 5\n**Explanation:** The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\n",
                "**Example 3:**\n\n**Input:** locations = \\[5,2,1\\], start = 0, finish = 2, fuel = 3\n**Output:** 0\n**Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= locations.length <= 100`\n*   `1 <= locations[i] <= 109`\n*   All integers in `locations` are **distinct**.\n*   `0 <= start, finish < locations.length`\n*   `1 <= fuel <= 200`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "[2,3,6,8,4],1,3,5",
                "output": "4"
            },
            {
                "input": "[4,3,1],1,0,6",
                "output": "5"
            },
            {
                "input": "[5,2,1],0,2,3",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n    Arrays.sort(horizontalCuts);\n    Arrays.sort(verticalCuts);\n    \n    int maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);\n    int maxV = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);\n    \n    for (int i = 1; i < horizontalCuts.length; ++i) {\n        maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n    \n    for (int i = 1; i < verticalCuts.length; ++i) {\n        maxV = Math.max(maxV, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n    \n    return (int)((long)maxH * maxV % 1000000007);\n}\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])\n    maxV = max(verticalCuts[0], w - verticalCuts[-1])\n\n    for i in range(1, len(horizontalCuts)):\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])\n\n    for i in range(1, len(verticalCuts)):\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])\n\n    return (maxH * maxV) % (10**9 + 7)\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {\n    sort(horizontalCuts.begin(), horizontalCuts.end());\n    sort(verticalCuts.begin(), verticalCuts.end());\n    \n    int maxH = max(horizontalCuts[0], h - horizontalCuts.back());\n    int maxV = max(verticalCuts[0], w - verticalCuts.back());\n    \n    for (int i = 1; i < horizontalCuts.size(); ++i) {\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n    \n    for (int i = 1; i < verticalCuts.size(); ++i) {\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n    \n    return (long long)maxH * maxV % 1000000007;\n}\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction maxArea(h, w, horizontalCuts, verticalCuts) {\n    horizontalCuts.sort((a, b) => a - b);\n    verticalCuts.sort((a, b) => a - b);\n\n    let maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);\n    let maxV = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);\n\n    for (let i = 1; i < horizontalCuts.length; ++i) {\n        maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);\n    }\n\n    for (let i = 1; i < verticalCuts.length; ++i) {\n        maxV = Math.max(maxV, verticalCuts[i] - verticalCuts[i - 1]);\n    }\n\n    return BigInt(maxH) * BigInt(maxV) % 1000000007n;\n}\n```\n    \n    1. Sort both horizontalCuts and verticalCuts arrays in ascending order.\n2. Calculate the initial values of maxH and maxV as the maximum of the first cut distance and the distance from the last cut to the cake's edge.\n3. Loop through each cut in both arrays (starting from index 1), updating maxH and maxV to be the maximum value between their current value and the difference between the current cut and the previous cut. This will give us the largest distance between cuts for both horizontal and vertical directions.\n4. Return the product of maxH and maxV modulo 10^9 + 7.\n    "
    },
    {
        "id": 255,
        "title": "Remove Max Number of Edges to Keep Graph Fully Traversable",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice and Bob have an undirected graph of `n` nodes and three types of edges:\n\n*   Type 1: Can be traversed by Alice only.\n*   Type 2: Can be traversed by Bob only.\n*   Type 3: Can be traversed by both Alice and Bob.\n\nGiven an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n\nReturn _the maximum number of edges you can remove, or return_ `-1` _if Alice and Bob cannot fully traverse the graph._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[3,1,2\\],\\[3,2,3\\],\\[1,1,3\\],\\[1,2,4\\],\\[1,1,2\\],\\[2,3,4\\]\\]\n**Output:** 2\n**Explanation:** If we remove the 2 edges \\[1,1,2\\] and \\[1,1,3\\]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[3,1,2\\],\\[3,2,3\\],\\[1,1,4\\],\\[2,1,4\\]\\]\n**Output:** 0\n**Explanation:** Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n\n",
                "**Example 3:**\n\n**Input:** n = 4, edges = \\[\\[3,2,3\\],\\[1,1,2\\],\\[2,3,4\\]\\]\n**Output:** -1\n**Explanation:** In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)`\n*   `edges[i].length == 3`\n*   `1 <= typei <= 3`\n*   `1 <= ui < vi <= n`\n*   All tuples `(typei, ui, vi)` are distinct.",
            "follow_up": null
        },
        "tag": [
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "4,[[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]",
                "output": "2"
            },
            {
                "input": "4,[[3,1,2],[3,2,3],[1,1,4],[2,1,4]]",
                "output": "0"
            },
            {
                "input": "4,[[3,2,3],[1,1,2],[2,3,4]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nclass UnionFind {\n    int[] parent;\n    int components;\n\n    UnionFind(int size) {\n        parent = new int[size];\n        components = size;\n        for (int i = 0; i < size; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (x != parent[x])\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    boolean unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n            components--;\n            return true;\n        }\n        return false;\n    }\n}\n\npublic int maxNumEdgesToRemove(int n, int[][] edges) {\n    UnionFind ufA = new UnionFind(n + 1);\n    UnionFind ufB = new UnionFind(n + 1);\n    int common_edges = 0;\n\n    for (int[] edge : edges) {\n        if (edge[0] == 3) {\n            if (ufA.unite(edge[1], edge[2])) {\n                ufB.unite(edge[1], edge[2]);\n                common_edges++;\n            }\n        }\n    }\n\n    int removed_edges = 0;\n    for (int[] edge : edges) {\n        UnionFind uf = (edge[0] == 1) ? ufA : (edge[0] == 2) ? ufB : null;\n        if (uf != null && !uf.unite(edge[1], edge[2])) {\n            removed_edges++;\n        }\n    }\n\n    if (ufA.components != 2 || ufB.components != 2)\n        return -1;\n    return removed_edges - common_edges;\n}\n```\n    \n    The algorithm first initializes one union-find data structure for Alice (ufA) and another for Bob (ufB). \n\nIn the first loop, the algorithm goes through all the edges and unites the endpoints of type 3 edges using both Alice's and Bob's union-find data structures. This is because type 3 edges can be traversed by both Alice and Bob. The number of type 3 edges united is counted as `common_edges`.\n\nIn the second loop, the algorithm goes through all the edges again, this time trying to unite the endpoints using the respective union-find data structure for type 1 and type 2 edges. If an edge cannot be united (because the two endpoints already belong to the same connected component), it means that this edge can be removed, so the count of `removed_edges` is incremented.\n\nFinally, the algorithm checks if both Alice's and Bob's graphs are fully traversable by verifying that the number of connected components in each union-find data structure is 2 (the initial connected component and the fully connected graph). If they are, the algorithm returns the count of removed edges minus the count of common edges (this subtraction is done because common_edges shouldn't be counted twice); otherwise, it returns -1, indicating that the graph cannot be fully traversed by both Alice and Bob.\n    ",
        "python": "\n    ```python\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.components = size\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n            self.components -= 1\n            return True\n        return False\n\ndef max_num_edges_to_remove(n, edges):\n    ufA, ufB = UnionFind(n + 1), UnionFind(n + 1)\n    common_edges = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if ufA.unite(u, v):\n                ufB.unite(u, v)\n                common_edges += 1\n\n    removed_edges = 0\n    for t, u, v in edges:\n        uf = ufA if t == 1 else ufB if t == 2 else None\n        if uf and not uf.unite(u, v):\n            removed_edges += 1\n\n    return -1 if ufA.components != 2 or ufB.components != 2 else removed_edges - common_edges\n```\n    \n    The algorithm first initializes one union-find data structure for Alice (ufA) and another for Bob (ufB). \n\nIn the first loop, the algorithm goes through all the edges and unites the endpoints of type 3 edges using both Alice's and Bob's union-find data structures. This is because type 3 edges can be traversed by both Alice and Bob. The number of type 3 edges united is counted as `common_edges`.\n\nIn the second loop, the algorithm goes through all the edges again, this time trying to unite the endpoints using the respective union-find data structure for type 1 and type 2 edges. If an edge cannot be united (because the two endpoints already belong to the same connected component), it means that this edge can be removed, so the count of `removed_edges` is incremented.\n\nFinally, the algorithm checks if both Alice's and Bob's graphs are fully traversable by verifying that the number of connected components in each union-find data structure is 2 (the initial connected component and the fully connected graph). If they are, the algorithm returns the count of removed edges minus the count of common edges (this subtraction is done because common_edges shouldn't be counted twice); otherwise, it returns -1, indicating that the graph cannot be fully traversed by both Alice and Bob.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent;\n    int components;\n\n    UnionFind(int size) {\n        parent.resize(size);\n        components = size;\n        for (int i = 0; i < size; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (x != parent[x])\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n            components--;\n            return true;\n        }\n        return false;\n    }\n};\n\nint maxNumEdgesToRemove(int n, vector<vector<int>> &edges) {\n    UnionFind ufA(n + 1), ufB(n + 1);\n    int common_edges = 0;\n\n    for (auto &edge : edges) {\n        if (edge[0] == 3) {\n            if (ufA.unite(edge[1], edge[2])) {\n                ufB.unite(edge[1], edge[2]);\n                common_edges++;\n            }\n        }\n    }\n\n    int removed_edges = 0;\n    for (auto &edge : edges) {\n        UnionFind *uf = (edge[0] == 1) ? &ufA : (edge[0] == 2) ? &ufB : nullptr;\n        if (uf && !uf->unite(edge[1], edge[2])) {\n            removed_edges++;\n        }\n    }\n\n    if (ufA.components != 2 || ufB.components != 2)\n        return -1;\n    return removed_edges - common_edges;\n}\n```\n    \n    The algorithm first initializes one union-find data structure for Alice (ufA) and another for Bob (ufB). \n\nIn the first loop, the algorithm goes through all the edges and unites the endpoints of type 3 edges using both Alice's and Bob's union-find data structures. This is because type 3 edges can be traversed by both Alice and Bob. The number of type 3 edges united is counted as `common_edges`.\n\nIn the second loop, the algorithm goes through all the edges again, this time trying to unite the endpoints using the respective union-find data structure for type 1 and type 2 edges. If an edge cannot be united (because the two endpoints already belong to the same connected component), it means that this edge can be removed, so the count of `removed_edges` is incremented.\n\nFinally, the algorithm checks if both Alice's and Bob's graphs are fully traversable by verifying that the number of connected components in each union-find data structure is 2 (the initial connected component and the fully connected graph). If they are, the algorithm returns the count of removed edges minus the count of common edges (this subtraction is done because common_edges shouldn't be counted twice); otherwise, it returns -1, indicating that the graph cannot be fully traversed by both Alice and Bob.\n    ",
        "js": "\n    ```javascript\nclass UnionFind {\n    constructor(size) {\n        this.parent = Array.from({length: size}, (_, i) => i);\n        this.components = size;\n    }\n\n    find(x) {\n        if (x !== this.parent[x]) {\n            this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n    }\n\n    unite(x, y) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        if (rootX !== rootY) {\n            this.parent[rootX] = rootY;\n            this.components--;\n            return true;\n        }\n        return false;\n    }\n}\n\nfunction maxNumEdgesToRemove(n, edges) {\n    const ufA = new UnionFind(n + 1);\n    const ufB = new UnionFind(n + 1);\n    let common_edges = 0;\n\n    for (const [t, u, v] of edges) {\n        if (t === 3) {\n            if (ufA.unite(u, v)) {\n                ufB.unite(u, v);\n                common_edges++;\n            }\n        }\n    }\n\n    let removed_edges = 0;\n    for (const [t, u, v] of edges) {\n        const uf = (t === 1) ? ufA : (t === 2) ? ufB : null;\n        if (uf && !uf.unite(u, v)) {\n            removed_edges++;\n        }\n    }\n\n    return (ufA.components !== 2 || ufB.components !== 2) ? -1 : removed_edges - common_edges;\n}\n```\n    \n    The algorithm first initializes one union-find data structure for Alice (ufA) and another for Bob (ufB). \n\nIn the first loop, the algorithm goes through all the edges and unites the endpoints of type 3 edges using both Alice's and Bob's union-find data structures. This is because type 3 edges can be traversed by both Alice and Bob. The number of type 3 edges united is counted as `common_edges`.\n\nIn the second loop, the algorithm goes through all the edges again, this time trying to unite the endpoints using the respective union-find data structure for type 1 and type 2 edges. If an edge cannot be united (because the two endpoints already belong to the same connected component), it means that this edge can be removed, so the count of `removed_edges` is incremented.\n\nFinally, the algorithm checks if both Alice's and Bob's graphs are fully traversable by verifying that the number of connected components in each union-find data structure is 2 (the initial connected component and the fully connected graph). If they are, the algorithm returns the count of removed edges minus the count of common edges (this subtraction is done because common_edges shouldn't be counted twice); otherwise, it returns -1, indicating that the graph cannot be fully traversed by both Alice and Bob.\n    "
    },
    {
        "id": 256,
        "title": "Check If String Is Transformable With Substring Sort Operations",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t`, transform string `s` into string `t` using the following operation any number of times:\n\n*   Choose a **non-empty** substring in `s` and sort it in place so the characters are in **ascending order**.\n    *   For example, applying the operation on the underlined substring in `\"14234 \"` results in `\"12344 \"`.\n\nReturn `true` if _it is possible to transform `s` into `t`_. Otherwise, return `false`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"84532 \", t =  \"34852 \"\n**Output:** true\n**Explanation:** You can transform s into t using the following sort operations:\n \"84532 \" (from index 2 to 3) ->  \"84352 \"\n \"84352 \" (from index 0 to 2) ->  \"34852 \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"34521 \", t =  \"23415 \"\n**Output:** true\n**Explanation:** You can transform s into t using the following sort operations:\n \"34521 \" ->  \"23451 \"\n \"23451 \" ->  \"23415 \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"12345 \", t =  \"12435 \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `s.length == t.length`\n*   `1 <= s.length <= 105`\n*   `s` and `t` consist of only digits.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "\"84532\",\"34852\"",
                "output": "true"
            },
            {
                "input": "\"34521\",\"23415\"",
                "output": "true"
            },
            {
                "input": "\"12345\",\"12435\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int kthFactor(int n, int k) {\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            --k;\n            if (k == 0) return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    ",
        "python": "\n    ```python\ndef kth_factor(n: int, k: int) -> int:\n    for i in range(1, n+1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    ",
        "c++": "\n    ```cpp\nint kthFactor(int n, int k) {\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            --k;\n            if (k == 0) return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    ",
        "js": "\n    ```javascript\nfunction kthFactor(n, k) {\n    for (let i = 1; i <= n; ++i) {\n        if (n % i === 0) {\n            --k;\n            if (k === 0) return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm starts with the smallest possible factor `i=1` and iterates through all numbers up to `n`. For each iteration, the algorithm checks if `n % i` is equal to 0, which means the current `i` is a factor of `n`. If so, it decrements the value of `k`. When `k` becomes zero, return the current `i`, as it is the kth factor. If the loop ends without finding the kth factor, return -1, since there are no k factors for given `n`.\n    "
    },
    {
        "id": 257,
        "title": "Strange Printer II",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a strange printer with the following two special requirements:\n\n*   On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n*   Once the printer has used a color for the above operation, **the same color cannot be used again**.\n\nYou are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.\n\nReturn `true` _if it is possible to print the matrix_ `targetGrid`_,_ _otherwise, return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** targetGrid = \\[\\[1,1,1,1\\],\\[1,2,2,1\\],\\[1,2,2,1\\],\\[1,1,1,1\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** targetGrid = \\[\\[1,1,1,1\\],\\[1,1,3,3\\],\\[1,1,3,4\\],\\[5,5,1,4\\]\\]\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** targetGrid = \\[\\[1,2,1\\],\\[2,1,2\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** It is impossible to form targetGrid because it is not allowed to print the same color in different turns."
            ],
            "constraints": "**Constraints:**\n\n*   `m == targetGrid.length`\n*   `n == targetGrid[i].length`\n*   `1 <= m, n <= 60`\n*   `1 <= targetGrid[row][col] <= 60`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Graph",
            "Topological Sort",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]",
                "output": "true"
            },
            {
                "input": "[[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]",
                "output": "true"
            },
            {
                "input": "[[1,2,1],[2,1,2],[1,2,1]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic boolean isPrintable(int[][] targetGrid) {\n    int m = targetGrid.length, n = targetGrid[0].length;\n    Map<Integer, int[]> colorBounds = new HashMap<>();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int color = targetGrid[i][j];\n            colorBounds.putIfAbsent(color, new int[] {i, j, i, j});\n            colorBounds.get(color)[0] = Math.min(colorBounds.get(color)[0], i);\n            colorBounds.get(color)[1] = Math.min(colorBounds.get(color)[1], j);\n            colorBounds.get(color)[2] = Math.max(colorBounds.get(color)[2], i);\n            colorBounds.get(color)[3] = Math.max(colorBounds.get(color)[3], j);\n        }\n    }\n\n    Set<Integer> remainingColors = new HashSet<>(colorBounds.keySet());\n    while (!remainingColors.isEmpty()) {\n        boolean progress = false;\n        for (Iterator<Integer> it = remainingColors.iterator(); it.hasNext();) {\n            int color = it.next();\n            int[] bounds = colorBounds.get(color);\n            boolean contained = true;\n            for (int i = bounds[0]; i <= bounds[2] && contained; ++i) {\n                for (int j = bounds[1]; j <= bounds[3]; ++j) {\n                    if (targetGrid[i][j] != color && targetGrid[i][j] != -1) {\n                        contained = false;\n                        break;\n                    }\n                }\n            }\n            if (contained) {\n                for (int i = bounds[0]; i <= bounds[2]; ++i) {\n                    for (int j = bounds[1]; j <= bounds[3]; ++j) {\n                        targetGrid[i][j] = -1;\n                    }\n                }\n                it.remove();\n                progress = true;\n            }\n        }\n        if (!progress) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm keeps track of the bounding rectangles of each color and tries to print them in any order.\n\nFor each color, the bounding rectangle is calculated by searching for the minimum/maximum row/col coordinates of the same color.\n\nTo check if a rectangle can be printed, we examine each cell in the rectangle, making sure that either the cell is already covered by the current color or the cell is transparent and has not been covered by any other color. If a rectangle can be printed, we make it transparent (set its value in targetGrid to -1) and remove the color from the remaining colors set.\n\nIf a progress is made in the current iteration (removing at least one color), we continue with the next iteration. This loop will continue until there are no remaining colors or no further progress is made. If there are still remaining colors in the set when progress is not made anymore, it is impossible to print the target grid, and the function returns False. Otherwise, it returns True.\n\nThe time complexity is O(N^4) since we iterate over all colors and 2D coordinates. The space complexity is O(N^2) because of the memory used in targetGrid and colorBounds.\n    ",
        "python": "\n    ```python\ndef isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    color_bounds = {}\n    m, n = len(targetGrid), len(targetGrid[0])\n\n    for i in range(m):\n        for j in range(n):\n            color = targetGrid[i][j]\n            if color not in color_bounds:\n                color_bounds[color] = [i, j, i, j]\n            else:\n                color_bounds[color][0] = min(color_bounds[color][0], i)\n                color_bounds[color][1] = min(color_bounds[color][1], j)\n                color_bounds[color][2] = max(color_bounds[color][2], i)\n                color_bounds[color][3] = max(color_bounds[color][3], j)\n\n    remaining_colors = set(color_bounds.keys())\n    while remaining_colors:\n        progress = False\n        to_remove = set()\n        for color in remaining_colors:\n            bounds = color_bounds[color]\n            contained = all(targetGrid[i][j] == color or targetGrid[i][j] == -1\n                        for i in range(bounds[0], bounds[2] + 1)\n                        for j in range(bounds[1], bounds[3] + 1))\n            if contained:\n                for i in range(bounds[0], bounds[2] + 1):\n                    for j in range(bounds[1], bounds[3] + 1):\n                        targetGrid[i][j] = -1\n                to_remove.add(color)\n                progress = True\n\n        remaining_colors -= to_remove\n        if not progress:\n            return False\n\n    return True\n```\n\n    \n    The algorithm keeps track of the bounding rectangles of each color and tries to print them in any order.\n\nFor each color, the bounding rectangle is calculated by searching for the minimum/maximum row/col coordinates of the same color.\n\nTo check if a rectangle can be printed, we examine each cell in the rectangle, making sure that either the cell is already covered by the current color or the cell is transparent and has not been covered by any other color. If a rectangle can be printed, we make it transparent (set its value in targetGrid to -1) and remove the color from the remaining colors set.\n\nIf a progress is made in the current iteration (removing at least one color), we continue with the next iteration. This loop will continue until there are no remaining colors or no further progress is made. If there are still remaining colors in the set when progress is not made anymore, it is impossible to print the target grid, and the function returns False. Otherwise, it returns True.\n\nThe time complexity is O(N^4) since we iterate over all colors and 2D coordinates. The space complexity is O(N^2) because of the memory used in targetGrid and colorBounds.\n    ",
        "c++": "\n    ```cpp\nbool isPrintable(vector<vector<int>>& targetGrid) {\n    unordered_map<int, vector<int>> color_bounds;\n    int m = targetGrid.size(), n = targetGrid[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int color = targetGrid[i][j];\n            if (!color_bounds.count(color)) color_bounds[color] = {i, j, i, j};\n            else {\n                color_bounds[color][0] = min(color_bounds[color][0], i);\n                color_bounds[color][1] = min(color_bounds[color][1], j);\n                color_bounds[color][2] = max(color_bounds[color][2], i);\n                color_bounds[color][3] = max(color_bounds[color][3], j);\n            }\n        }\n    }\n\n    set<int> remaining_colors;\n    for (const auto& p : color_bounds) {\n        remaining_colors.insert(p.first);\n    }\n    while (!remaining_colors.empty()) {\n        bool progress = false;\n        for (auto it = remaining_colors.begin(); it != remaining_colors.end();) {\n            int color = *it;\n            const auto& bounds = color_bounds[color];\n            bool contained = true;\n            for (int i = bounds[0]; i <= bounds[2] && contained; ++i) {\n                for (int j = bounds[1]; j <= bounds[3]; ++j) {\n                    if (targetGrid[i][j] != color && targetGrid[i][j] != -1) {\n                        contained = false;\n                        break;\n                    }\n                }\n            }\n            if (contained) {\n                for (int i = bounds[0]; i <= bounds[2]; ++i) {\n                    for (int j = bounds[1]; j <= bounds[3]; ++j) {\n                        targetGrid[i][j] = -1;\n                    }\n                }\n                it = remaining_colors.erase(it);\n                progress = true;\n            } else {\n                ++it;\n            }\n        }\n        if (!progress) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm keeps track of the bounding rectangles of each color and tries to print them in any order.\n\nFor each color, the bounding rectangle is calculated by searching for the minimum/maximum row/col coordinates of the same color.\n\nTo check if a rectangle can be printed, we examine each cell in the rectangle, making sure that either the cell is already covered by the current color or the cell is transparent and has not been covered by any other color. If a rectangle can be printed, we make it transparent (set its value in targetGrid to -1) and remove the color from the remaining colors set.\n\nIf a progress is made in the current iteration (removing at least one color), we continue with the next iteration. This loop will continue until there are no remaining colors or no further progress is made. If there are still remaining colors in the set when progress is not made anymore, it is impossible to print the target grid, and the function returns False. Otherwise, it returns True.\n\nThe time complexity is O(N^4) since we iterate over all colors and 2D coordinates. The space complexity is O(N^2) because of the memory used in targetGrid and colorBounds.\n    ",
        "js": "\n    ```javascript\nconst isPrintable = (targetGrid) => {\n    const m = targetGrid.length, n = targetGrid[0].length;\n    const colorBounds = new Map();\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            const color = targetGrid[i][j];\n            if (!colorBounds.has(color)) colorBounds.set(color, [i, j, i, j]);\n            else {\n                colorBounds.get(color)[0] = Math.min(colorBounds.get(color)[0], i);\n                colorBounds.get(color)[1] = Math.min(colorBounds.get(color)[1], j);\n                colorBounds.get(color)[2] = Math.max(colorBounds.get(color)[2], i);\n                colorBounds.get(color)[3] = Math.max(colorBounds.get(color)[3], j);\n            }\n        }\n    }\n\n    const remainingColors = new Set(colorBounds.keys());\n    while (remainingColors.size) {\n        let progress = false;\n        for (const color of Array.from(remainingColors)) {\n            const bounds = colorBounds.get(color);\n            let contained = true;\n            for (let i = bounds[0]; i <= bounds[2] && contained; ++i) {\n                for (let j = bounds[1]; j <= bounds[3]; ++j) {\n                    if (targetGrid[i][j] !== color && targetGrid[i][j] !== -1) {\n                        contained = false;\n                        break;\n                    }\n                }\n            }\n            if (contained) {\n                for (let i = bounds[0]; i <= bounds[2]; ++i) {\n                    for (let j = bounds[1]; j <= bounds[3]; ++j) {\n                        targetGrid[i][j] = -1;\n                    }\n                }\n                remainingColors.delete(color);\n                progress = true;\n            }\n        }\n        if (!progress) return false;\n    }\n    return true;\n};\n```\n    \n    The algorithm keeps track of the bounding rectangles of each color and tries to print them in any order.\n\nFor each color, the bounding rectangle is calculated by searching for the minimum/maximum row/col coordinates of the same color.\n\nTo check if a rectangle can be printed, we examine each cell in the rectangle, making sure that either the cell is already covered by the current color or the cell is transparent and has not been covered by any other color. If a rectangle can be printed, we make it transparent (set its value in targetGrid to -1) and remove the color from the remaining colors set.\n\nIf a progress is made in the current iteration (removing at least one color), we continue with the next iteration. This loop will continue until there are no remaining colors or no further progress is made. If there are still remaining colors in the set when progress is not made anymore, it is impossible to print the target grid, and the function returns False. Otherwise, it returns True.\n\nThe time complexity is O(N^4) since we iterate over all colors and 2D coordinates. The space complexity is O(N^2) because of the memory used in targetGrid and colorBounds.\n    "
    },
    {
        "id": 258,
        "title": "Minimum Cost to Connect Two Groups of Points",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two groups of points where the first group has `size1` points, the second group has `size2` points, and `size1 >= size2`.\n\nThe `cost` of the connection between any two points are given in an `size1 x size2` matrix where `cost[i][j]` is the cost of connecting point `i` of the first group and point `j` of the second group. The groups are connected if **each point in both groups is connected to one or more points in the opposite group**. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.\n\nReturn _the minimum cost it takes to connect the two groups_.",
            "examples": [
                "**Example 1:**\n\n**Input:** cost = \\[\\[15, 96\\], \\[36, 2\\]\\]\n**Output:** 17\n**Explanation**: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.\n\n",
                "**Example 2:**\n\n**Input:** cost = \\[\\[1, 3, 5\\], \\[4, 1, 1\\], \\[1, 5, 3\\]\\]\n**Output:** 4\n**Explanation**: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n\n",
                "**Example 3:**\n\n**Input:** cost = \\[\\[2, 5, 1\\], \\[3, 4, 7\\], \\[8, 1, 2\\], \\[6, 2, 4\\], \\[3, 8, 8\\]\\]\n**Output:** 10"
            ],
            "constraints": "**Constraints:**\n\n*   `size1 == cost.length`\n*   `size2 == cost[i].length`\n*   `1 <= size1, size2 <= 12`\n*   `size1 >= size2`\n*   `0 <= cost[i][j] <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Matrix",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[[15,96],[36,2]]",
                "output": "17"
            },
            {
                "input": "[[1,3,5],[4,1,1],[1,5,3]]",
                "output": "4"
            },
            {
                "input": "[[2,5,1],[3,4,7],[8,1,2],[6,2,4],[3,8,8]]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int connectTwoGroups(List<List<Integer>> cost) {\n    int size1 = cost.size(), size2 = cost.get(0).size();\n    int[] min_cost = new int[size2];\n    Arrays.fill(min_cost, Integer.MAX_VALUE);\n\n    for (int i = 0; i < size1; i++) {\n        for (int j = 0; j < size2; j++) {\n            min_cost[j] = Math.min(min_cost[j], cost.get(i).get(j));\n        }\n    }\n\n    int total_cost = 0;\n    for (int i = 0; i < size1; i++) {\n        total_cost += Collections.min(cost.get(i));\n    }\n\n    for (int j = 0; j < size2; j++) {\n        total_cost += min_cost[j];\n    }\n\n    return total_cost;\n}\n```\n\n    \n    To minimize the cost of connecting the two groups, we should first find the minimum cost of connecting each point i in the first group with all the points in the second group, and then find the minimum cost of connecting each point j in the second group with all the points in the first group.\n\n1. Iterate through each point of the first group.\n2. For each point i in the first group, find the minimum cost of connecting it with all the points in the second group.\n3. Store the minimum cost in the min_cost array for the second group points.\n4. Add up the total minimum cost for all points in the first group.\n5. Add up the minimum cost for all points in the second group from the min_cost array.\n6. Return the total cost as the minimum cost to connect the two groups.\n    ",
        "python": "\n    ```python\ndef connectTwoGroups(cost):\n    size1, size2 = len(cost), len(cost[0])\n    min_cost = [float('inf')] * size2\n\n    for i in range(size1):\n        for j in range(size2):\n            min_cost[j] = min(min_cost[j], cost[i][j])\n\n    total_cost = 0\n    for i in range(size1):\n        total_cost += min(cost[i])\n\n    for j in range(size2):\n        total_cost += min_cost[j]\n\n    return total_cost\n```\n\n    \n    To minimize the cost of connecting the two groups, we should first find the minimum cost of connecting each point i in the first group with all the points in the second group, and then find the minimum cost of connecting each point j in the second group with all the points in the first group.\n\n1. Iterate through each point of the first group.\n2. For each point i in the first group, find the minimum cost of connecting it with all the points in the second group.\n3. Store the minimum cost in the min_cost array for the second group points.\n4. Add up the total minimum cost for all points in the first group.\n5. Add up the minimum cost for all points in the second group from the min_cost array.\n6. Return the total cost as the minimum cost to connect the two groups.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint connectTwoGroups(vector<vector<int>>& cost) {\n    int size1 = cost.size(), size2 = cost[0].size();\n    vector<int> min_cost(size2, INT_MAX);\n\n    for (int i = 0; i < size1; i++) {\n        for (int j = 0; j < size2; j++) {\n            min_cost[j] = min(min_cost[j], cost[i][j]);\n        }\n    }\n\n    int total_cost = 0;\n    for (int i = 0; i < size1; i++) {\n        total_cost += *min_element(cost[i].begin(), cost[i].end());\n    }\n\n    for (int j = 0; j < size2; j++) {\n        total_cost += min_cost[j];\n    }\n\n    return total_cost;\n}\n```\n\n    \n    To minimize the cost of connecting the two groups, we should first find the minimum cost of connecting each point i in the first group with all the points in the second group, and then find the minimum cost of connecting each point j in the second group with all the points in the first group.\n\n1. Iterate through each point of the first group.\n2. For each point i in the first group, find the minimum cost of connecting it with all the points in the second group.\n3. Store the minimum cost in the min_cost array for the second group points.\n4. Add up the total minimum cost for all points in the first group.\n5. Add up the minimum cost for all points in the second group from the min_cost array.\n6. Return the total cost as the minimum cost to connect the two groups.\n    ",
        "js": "\n    ```javascript\nfunction connectTwoGroups(cost) {\n    const size1 = cost.length, size2 = cost[0].length;\n    const min_cost = Array(size2).fill(Infinity);\n\n    for (let i = 0; i < size1; i++) {\n        for (let j = 0; j < size2; j++) {\n            min_cost[j] = Math.min(min_cost[j], cost[i][j]);\n        }\n    }\n\n    let total_cost = 0;\n    for (let i = 0; i < size1; i++) {\n        total_cost += Math.min(...cost[i]);\n    }\n\n    for (let j = 0; j < size2; j++) {\n        total_cost += min_cost[j];\n    }\n\n    return total_cost;\n}\n```\n\n    \n    To minimize the cost of connecting the two groups, we should first find the minimum cost of connecting each point i in the first group with all the points in the second group, and then find the minimum cost of connecting each point j in the second group with all the points in the first group.\n\n1. Iterate through each point of the first group.\n2. For each point i in the first group, find the minimum cost of connecting it with all the points in the second group.\n3. Store the minimum cost in the min_cost array for the second group points.\n4. Add up the total minimum cost for all points in the first group.\n5. Add up the minimum cost for all points in the second group from the min_cost array.\n6. Return the total cost as the minimum cost to connect the two groups.\n    "
    },
    {
        "id": 259,
        "title": "Maximum Number of Achievable Transfer Requests",
        "difficulty": "Hard",
        "content": {
            "problem": "We have `n` buildings numbered from `0` to `n - 1`. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n\nYou are given an array `requests` where `requests[i] = [fromi, toi]` represents an employee's request to transfer from building `fromi` to building `toi`.\n\n**All buildings are full**, so a list of requests is achievable only if for each building, the **net change in employee transfers is zero**. This means the number of employees **leaving** is **equal** to the number of employees **moving in**. For example if `n = 3` and two employees are leaving building `0`, one is leaving building `1`, and one is leaving building `2`, there should be two employees moving to building `0`, one employee moving to building `1`, and one employee moving to building `2`.\n\nReturn _the maximum number of achievable requests_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, requests = \\[\\[0,1\\],\\[1,0\\],\\[0,1\\],\\[1,2\\],\\[2,0\\],\\[3,4\\]\\]\n**Output:** 5\n**Explantion:** Let's see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don't have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, requests = \\[\\[0,0\\],\\[1,2\\],\\[2,1\\]\\]\n**Output:** 3\n**Explantion:** Let's see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests. \n\n",
                "**Example 3:**\n\n**Input:** n = 4, requests = \\[\\[0,3\\],\\[3,1\\],\\[1,2\\],\\[2,0\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 20`\n*   `1 <= requests.length <= 16`\n*   `requests[i].length == 2`\n*   `0 <= fromi, toi < n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking",
            "Bit Manipulation",
            "Enumeration"
        ],
        "example": [
            {
                "input": "5,[[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]",
                "output": "5\n**Explantion:**Let'sseetherequests:\nFrombuilding0wehaveemployeesxandyandbothwanttomovetobuilding1.\nFrombuilding1wehaveemployeesaandbandtheywanttomovetobuildings2and0respectively.\nFrombuilding2wehaveemployeezandtheywanttomovetobuilding0.\nFrombuilding3wehaveemployeecandtheywanttomovetobuilding4.\nFrombuilding4wedon'thaveanyrequests.\nWecanachievetherequestsofusersxandbbyswappingtheirplaces.\nWecanachievetherequestsofusersy,aandzbyswappingtheplacesinthe3buildings."
            },
            {
                "input": "3,[[0,0],[1,2],[2,1]]",
                "output": "3\n**Explantion:**Let'sseetherequests:\nFrombuilding0wehaveemployeexandtheywanttostayinthesamebuilding0.\nFrombuilding1wehaveemployeeyandtheywanttomovetobuilding2.\nFrombuilding2wehaveemployeezandtheywanttomovetobuilding1.\nWecanachievealltherequests."
            },
            {
                "input": "4,[[0,3],[3,1],[1,2],[2,0]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int maximumRequests(int n, List<List<Integer>> requests) {\n    int req_size = requests.size();\n    int max_requests = 0;\n\n    for (int i = 0; i < (1 << req_size); ++i) {\n        int[] net_transfers = new int[n];\n        int count = 0;\n\n        for (int j = 0; j < req_size; ++j) {\n            if ((i & (1 << j)) != 0) {\n                net_transfers[requests.get(j).get(0)]--;\n                net_transfers[requests.get(j).get(1)]++;\n                count++;\n            }\n        }\n\n        boolean valid = true;\n        for (int val : net_transfers) {\n            if (val != 0) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid)\n            max_requests = Math.max(max_requests, count);\n    }\n\n    return max_requests;\n}\n```\n    \n    To solve this problem, we need to iterate through all the possible combinations of employee requests, and for each combination, we check if it satisfies the building transfer constraints where the net change of employees to every building is 0. Here we use a bit manipulation technique to represent different subsets.\n\nWe start by iterating over all integers from 0 to 2^requests.length. For each such integer, we iterate over each bit and, if it is set, include the corresponding request from the list of requests. Then, we calculate the net employee changes in each building based on this subset of requests. If after updating the net employee changes, all the entries in the building change array are still 0, it means the current subset of requests meets the requirements.\n\nWe then update the maximum number of achievable requests if the current count of requests is greater than the previous maximum one. We return the maximum achievable number of requests after checking all sets of requests.\n\nThe time complexity of this solution is O(2^R * (R + N)), where R is requests.length and N is the number of buildings.\n    ",
        "python": "\n    ```python\ndef maximumRequests(n, requests):\n    req_size = len(requests)\n    max_requests = 0\n\n    for i in range(1 << req_size):\n        net_transfers = [0] * n\n        count = 0\n        \n        for j in range(req_size):\n            if i & (1 << j):\n                net_transfers[requests[j][0]] -= 1\n                net_transfers[requests[j][1]] += 1\n                count += 1\n\n        valid = all(val == 0 for val in net_transfers)\n\n        if valid:\n            max_requests = max(max_requests, count)\n\n    return max_requests\n```\n    \n    To solve this problem, we need to iterate through all the possible combinations of employee requests, and for each combination, we check if it satisfies the building transfer constraints where the net change of employees to every building is 0. Here we use a bit manipulation technique to represent different subsets.\n\nWe start by iterating over all integers from 0 to 2^requests.length. For each such integer, we iterate over each bit and, if it is set, include the corresponding request from the list of requests. Then, we calculate the net employee changes in each building based on this subset of requests. If after updating the net employee changes, all the entries in the building change array are still 0, it means the current subset of requests meets the requirements.\n\nWe then update the maximum number of achievable requests if the current count of requests is greater than the previous maximum one. We return the maximum achievable number of requests after checking all sets of requests.\n\nThe time complexity of this solution is O(2^R * (R + N)), where R is requests.length and N is the number of buildings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint maximumRequests(int n, std::vector<std::vector<int>>& requests) {\n    int req_size = requests.size();\n    int max_requests = 0;\n\n    for (int i = 0; i < (1 << req_size); ++i) {\n        std::vector<int> net_transfers(n, 0);\n        int count = 0;\n\n        for (int j = 0; j < req_size; ++j) {\n            if (i & (1 << j)) {\n                net_transfers[requests[j][0]]--;\n                net_transfers[requests[j][1]]++;\n                count++;\n            }\n        }\n\n        bool valid = true;\n        for (int val : net_transfers) {\n            if (val) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid)\n            max_requests = std::max(max_requests, count);\n    }\n\n    return max_requests;\n}\n```\n    \n    To solve this problem, we need to iterate through all the possible combinations of employee requests, and for each combination, we check if it satisfies the building transfer constraints where the net change of employees to every building is 0. Here we use a bit manipulation technique to represent different subsets.\n\nWe start by iterating over all integers from 0 to 2^requests.length. For each such integer, we iterate over each bit and, if it is set, include the corresponding request from the list of requests. Then, we calculate the net employee changes in each building based on this subset of requests. If after updating the net employee changes, all the entries in the building change array are still 0, it means the current subset of requests meets the requirements.\n\nWe then update the maximum number of achievable requests if the current count of requests is greater than the previous maximum one. We return the maximum achievable number of requests after checking all sets of requests.\n\nThe time complexity of this solution is O(2^R * (R + N)), where R is requests.length and N is the number of buildings.\n    ",
        "js": "\n    ```javascript\nfunction maximumRequests(n, requests) {\n    const req_size = requests.length;\n    let max_requests = 0;\n\n    for (let i = 0; i < (1 << req_size); ++i) {\n        const net_transfers = new Array(n).fill(0);\n        let count = 0;\n\n        for (let j = 0; j < req_size; ++j) {\n            if (i & (1 << j)) {\n                net_transfers[requests[j][0]]--;\n                net_transfers[requests[j][1]]++;\n                count++;\n            }\n        }\n\n        const valid = net_transfers.every(val => val === 0);\n\n        if (valid) {\n            max_requests = Math.max(max_requests, count);\n        }\n    }\n\n    return max_requests;\n}\n```\n    \n    To solve this problem, we need to iterate through all the possible combinations of employee requests, and for each combination, we check if it satisfies the building transfer constraints where the net change of employees to every building is 0. Here we use a bit manipulation technique to represent different subsets.\n\nWe start by iterating over all integers from 0 to 2^requests.length. For each such integer, we iterate over each bit and, if it is set, include the corresponding request from the list of requests. Then, we calculate the net employee changes in each building based on this subset of requests. If after updating the net employee changes, all the entries in the building change array are still 0, it means the current subset of requests meets the requirements.\n\nWe then update the maximum number of achievable requests if the current count of requests is greater than the previous maximum one. We return the maximum achievable number of requests after checking all sets of requests.\n\nThe time complexity of this solution is O(2^R * (R + N)), where R is requests.length and N is the number of buildings.\n    "
    },
    {
        "id": 260,
        "title": "Find Servers That Handled Most Number of Requests",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but **cannot handle more than one request at a time**. The requests are assigned to servers according to a specific algorithm:\n\n*   The `ith` (0-indexed) request arrives.\n*   If all servers are busy, the request is dropped (not handled at all).\n*   If the `(i % k)th` server is available, assign the request to that server.\n*   Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on.\n\nYou are given a **strictly increasing** array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the **busiest server(s)**. A server is considered **busiest** if it handled the most number of requests successfully among all the servers.\n\nReturn _a list containing the IDs (0-indexed) of the **busiest server(s)**_. You may return the IDs in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 3, arrival = \\[1,2,3,4,5\\], load = \\[5,2,3,3,3\\] \n**Output:** \\[1\\] \n**Explanation:** \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n\n",
                "**Example 2:**\n\n**Input:** k = 3, arrival = \\[1,2,3,4\\], load = \\[1,2,1,2\\]\n**Output:** \\[0\\]\n**Explanation:** \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n\n",
                "**Example 3:**\n\n**Input:** k = 3, arrival = \\[1,2,3\\], load = \\[10,12,11\\]\n**Output:** \\[0,1,2\\]\n**Explanation:** Each server handles a single request, so they are all considered the busiest."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 105`\n*   `1 <= arrival.length, load.length <= 105`\n*   `arrival.length == load.length`\n*   `1 <= arrival[i], load[i] <= 109`\n*   `arrival` is **strictly increasing**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Heap (Priority Queue)",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "3,[1,2,3,4,5],[5,2,3,3,3]",
                "output": "[1]"
            },
            {
                "input": "3,[1,2,3,4],[1,2,1,2]",
                "output": "[0]"
            },
            {
                "input": "3,[1,2,3],[10,12,11]",
                "output": "[0,1,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\n    int[] server_status = new int[k];\n    int[] server_request_count = new int[k];\n\n    for (int i = 0; i < arrival.length; i++) {\n        int index = i % k;\n        for (int j = 0; j < k; j++) {\n            if (server_status[index] <= arrival[i]) {\n                server_status[index] = arrival[i] + load[i];\n                server_request_count[index]++;\n                break;\n            }\n            index = (index + 1) % k;\n        }\n    }\n\n    int max_requests = 0;\n    for (int count : server_request_count) {\n        max_requests = Math.max(max_requests, count);\n    }\n    List<Integer> busiest_servers = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        if (server_request_count[i] == max_requests) {\n            busiest_servers.add(i);\n        }\n    }\n    return busiest_servers;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    ",
        "python": "\n    ```python\ndef busiestServers(k, arrival, load):\n    server_status = [-1] * k\n    server_request_count = [0] * k\n\n    for i in range(len(arrival)):\n        index = i % k\n        for _ in range(k):\n            if server_status[index] <= arrival[i]:\n                server_status[index] = arrival[i] + load[i]\n                server_request_count[index] += 1\n                break\n            index = (index + 1) % k\n\n    max_requests = max(server_request_count)\n    return [i for i in range(k) if server_request_count[i] == max_requests]\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\n    vector<int> server_status(k, -1); // -1 means available\n    vector<int> server_request_count(k, 0);\n\n    for (int i = 0; i < arrival.size(); i++) {\n        int index = i % k;\n        for (int j = 0; j < k; j++) {\n            if (server_status[index] <= arrival[i]) {\n                server_status[index] = arrival[i] + load[i];\n                server_request_count[index]++;\n                break;\n            }\n            index = (index + 1) % k;\n        }\n    }\n\n    int max_requests = *max_element(server_request_count.begin(), server_request_count.end());\n    vector<int> busiest_servers;\n    for (int i = 0; i < k; i++) {\n        if (server_request_count[i] == max_requests) {\n            busiest_servers.push_back(i);\n        }\n    }\n    return busiest_servers;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    ",
        "js": "\n    ```javascript\nfunction busiestServers(k, arrival, load) {\n    let server_status = new Array(k).fill(-1);\n    let server_request_count = new Array(k).fill(0);\n\n    for (let i = 0; i < arrival.length; i++) {\n        let index = i % k;\n        for (let j = 0; j < k; j++) {\n            if (server_status[index] <= arrival[i]) {\n                server_status[index] = arrival[i] + load[i];\n                server_request_count[index]++;\n                break;\n            }\n            index = (index + 1) % k;\n        }\n    }\n\n    let max_requests = Math.max(...server_request_count);\n    let busiest_servers = [];\n    for (let i = 0; i < k; i++) {\n        if (server_request_count[i] === max_requests) {\n            busiest_servers.push(i);\n        }\n    }\n    return busiest_servers;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Initialize two arrays: `server_status` and `server_request_count` with lengths `k`. The `server_status` array will store the end time for the committed requests, initially set to -1 (available). The `server_request_count` array will store the number of requests processed by each server, initially set to 0.\n\n2. For each request `i`, calculate the index `index = i % k` and check all servers `k` times (in circular manner) to find an available server.\n\n3. If a server with an end time less than or equal to the current arrival time is found, update the server's end time with the request's end time (`arrival[i] + load[i]`) and increment the server's request count.\n\n4. Once all requests have been processed, find the busiest server(s) by finding the maximum value in the `server_request_count` array and creating a list of indices (server IDs) that match the maximum value.\n\n5. Return the list of busiest server IDs.\n\n*Note: The algorithm's time complexity is O(n * k) where n is the number of requests and k is the number of servers.*\n    "
    },
    {
        "id": 261,
        "title": "Maximum Number of Visible Points",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote **integral coordinates** on the X-Y plane.\n\nInitially, you are facing directly east from your position. You **cannot move** from your position, but you can **rotate**. In other words, `posx` and `posy` cannot be changed. Your field of view in **degrees** is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the **inclusive** range of angles `[d - angle/2, d + angle/2]`.\n\nYour browser does not support the video tag or this video format.\n\nYou can **see** some set of points if, for each point, the **angle** formed by the point, your position, and the immediate east direction from your position is **in your field of view**.\n\nThere can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.\n\nReturn _the maximum number of points you can see_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[2,1\\],\\[2,2\\],\\[3,3\\]\\], angle = 90, location = \\[1,1\\]\n**Output:** 3\n**Explanation:** The shaded region represents your field of view. All points can be made visible in your field of view, including \\[3,3\\] even though \\[2,2\\] is in front and in the same line of sight.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[2,1\\],\\[2,2\\],\\[3,4\\],\\[1,1\\]\\], angle = 90, location = \\[1,1\\]\n**Output:** 4\n**Explanation:** All points can be made visible in your field of view, including the one at your location.\n\n",
                "**Example 3:**\n\n**Input:** points = \\[\\[1,0\\],\\[2,1\\]\\], angle = 13, location = \\[1,1\\]\n**Output:** 1\n**Explanation:** You can only see one of the two points, as shown above."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `location.length == 2`\n*   `0 <= angle < 360`\n*   `0 <= posx, posy, xi, yi <= 100`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Geometry",
            "Sliding Window",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[2,1],[2,2],[3,3]],90,[1,1]",
                "output": "3"
            },
            {
                "input": "[[2,1],[2,2],[3,4],[1,1]],90,[1,1]",
                "output": "4"
            },
            {
                "input": "[[1,0],[2,1]],13,[1,1]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int xorOperation(int n, int start) {\n    int xorResult = 0;\n    for (int i = 0; i < n; i++) {\n        xorResult ^= (start + 2 * i);\n    }\n    return xorResult;\n}\n```\n    \n    1. Initialize an integer variable `xor_result` to store the result of bitwise XOR operations and set it to 0.\n2. Iterate through the range of 0 to n (excluding n).\n3. For each iteration, calculate the value of `start + 2 * i` with the current value of `i`. Perform a bitwise XOR operation between the `xor_result` and the calculated value.\n4. After the iteration, return the final value of `xor_result` which contains the result of bitwise XOR of all elements of the `nums` array.\n    ",
        "python": "\n    ```python\ndef xor_operation(n, start):\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= (start + 2 * i)\n    return xor_result\n```\n    \n    1. Initialize an integer variable `xor_result` to store the result of bitwise XOR operations and set it to 0.\n2. Iterate through the range of 0 to n (excluding n).\n3. For each iteration, calculate the value of `start + 2 * i` with the current value of `i`. Perform a bitwise XOR operation between the `xor_result` and the calculated value.\n4. After the iteration, return the final value of `xor_result` which contains the result of bitwise XOR of all elements of the `nums` array.\n    ",
        "c++": "\n    ```cpp\nint xorOperation(int n, int start) {\n    int xor_result = 0;\n    for (int i = 0; i < n; ++i) {\n        xor_result ^= (start + 2 * i);\n    }\n    return xor_result;\n}\n```\n    \n    1. Initialize an integer variable `xor_result` to store the result of bitwise XOR operations and set it to 0.\n2. Iterate through the range of 0 to n (excluding n).\n3. For each iteration, calculate the value of `start + 2 * i` with the current value of `i`. Perform a bitwise XOR operation between the `xor_result` and the calculated value.\n4. After the iteration, return the final value of `xor_result` which contains the result of bitwise XOR of all elements of the `nums` array.\n    ",
        "js": "\n    ```javascript\nfunction xorOperation(n, start) {\n    let xorResult = 0;\n    for (let i = 0; i < n; i++) {\n        xorResult ^= (start + 2 * i);\n    }\n    return xorResult;\n}\n```\n    \n    1. Initialize an integer variable `xor_result` to store the result of bitwise XOR operations and set it to 0.\n2. Iterate through the range of 0 to n (excluding n).\n3. For each iteration, calculate the value of `start + 2 * i` with the current value of `i`. Perform a bitwise XOR operation between the `xor_result` and the calculated value.\n4. After the iteration, return the final value of `xor_result` which contains the result of bitwise XOR of all elements of the `nums` array.\n    "
    },
    {
        "id": 262,
        "title": "Minimum One Bit Operations to Make Integers Zero",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, you must transform it into `0` using the following operations any number of times:\n\n*   Change the rightmost (`0th`) bit in the binary representation of `n`.\n*   Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`.\n\nReturn _the minimum number of operations to transform_ `n` _into_ `0`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** The binary representation of 3 is  \"11 \".\n \"11 \" ->  \"01 \" with the 2nd operation since the 0th bit is 1.\n \"01 \" ->  \"00 \" with the 1st operation.\n\n",
                "**Example 2:**\n\n**Input:** n = 6\n**Output:** 4\n**Explanation:** The binary representation of 6 is  \"110 \".\n \"110 \" ->  \"010 \" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n \"010 \" ->  \"011 \" with the 1st operation.\n \"011 \" ->  \"001 \" with the 2nd operation since the 0th bit is 1.\n \"001 \" ->  \"000 \" with the 1st operation."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation",
            "Memoization"
        ],
        "example": [
            {
                "input": "3",
                "output": "2"
            },
            {
                "input": "6",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String[] getFolderNames(String[] names) {\n    HashMap<String, Integer> nameCount = new HashMap<String, Integer>();\n    String[] ans = new String[names.length];\n\n    for (int i = 0; i < names.length; i++) {\n        String name = names[i];\n        if (nameCount.get(name) == null) {\n            ans[i] = name;\n            nameCount.put(name, 1);\n        } else {\n            int k = nameCount.get(name);\n            String newName = \"\";\n            while (nameCount.get(name + \"(\" + k + \")\") != null) {\n                k++;\n            }\n            newName = name + \"(\" + k + \")\";\n            ans[i] = newName;\n            nameCount.put(newName, 1);\n            nameCount.put(name, k + 1);\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    ",
        "python": "\n    ```python\ndef get_folder_names(names):\n    name_count = {}\n    ans = []\n\n    for name in names:\n        if name not in name_count:\n            ans.append(name)\n            name_count[name] = 1\n        else:\n            k = name_count[name]\n            new_name = f\"{name}({k})\"\n            while new_name in name_count:\n                k += 1\n                new_name = f\"{name}({k})\"\n            ans.append(new_name)\n            name_count[new_name] = 1\n            name_count[name] = k + 1\n\n    return ans\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::string> getFolderNames(std::vector<std::string> &names) {\n    std::unordered_map<std::string, int> nameCount;\n    std::vector<std::string> ans;\n\n    for (const auto &name : names) {\n        if (nameCount[name] == 0) {\n            ans.push_back(name);\n            nameCount[name] = 1;\n        } else {\n            int k = nameCount[name];\n            while (nameCount[name + \"(\" + std::to_string(k) + \")\"] != 0) {\n                k++;\n            }\n            ans.push_back(name + \"(\" + std::to_string(k) + \")\");\n            nameCount[name + \"(\" + std::to_string(k) + \")\"] = 1;\n            nameCount[name] = k + 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    ",
        "js": "\n    ```javascript\nfunction getFolderNames(names) {\n    const nameCount = {};\n    const ans = [];\n\n    for (let name of names) {\n        if (nameCount[name] === undefined) {\n            ans.push(name);\n            nameCount[name] = 1;\n        } else {\n            let k = nameCount[name];\n            let newName = `${name}(${k})`;\n            while (nameCount[newName] !== undefined) {\n                k++;\n                newName = `${name}(${k})`;\n            }\n            ans.push(newName);\n            nameCount[newName] = 1;\n            nameCount[name] = k + 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm holds an unordered_map (hash_map in Java, dictionary in Python, object in JS) named `nameCount` that stores the count of each name used. For each name in the `names` array, it checks if the name exists in `nameCount`. If not, it puts the name in the resulting array `ans` and initializes its count in `nameCount` by 1. If the name is already in `nameCount`, the algorithm creates a candidate name by adding the current count value in the form of (k), then checks if this name is also in the `nameCount`. If so, it increases the count (k) until finding a unique name. The new name is added to the result array, and its count value is set to 1 in `nameCount`, and the count value in (k+1) is updated. Finally, the function returns the `ans` array containing the unique folder names. \n    "
    },
    {
        "id": 263,
        "title": "Count Subtrees With Max Distance Between Cities",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation",
            "Tree",
            "Enumeration",
            "Bitmask"
        ],
        "example": [
            {
                "input": "4,[[1,2],[2,3],[2,4]]",
                "output": "[3,4,0]"
            },
            {
                "input": "2,[[1,2]]",
                "output": "[1]"
            },
            {
                "input": "3,[[1,2],[2,3]]",
                "output": "[2,1]"
            }
        ],
        "java": "\n    ```java\npublic boolean winnerSquareGame(int n) {\n    boolean[] dp = new boolean[n + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            if (!dp[i - j * j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ",
        "python": "\n    ```python\ndef winnerSquareGame(n: int) -> bool:\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ",
        "c++": "\n    ```cpp\nbool winnerSquareGame(int n) {\n    vector<bool> dp(n + 1, false);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j * j <= i; ++j) {\n            if (!dp[i - j * j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ",
        "js": "\n    ```javascript\nfunction winnerSquareGame(n) {\n    const dp = new Array(n + 1).fill(false);\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            if (!dp[i - j * j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    "
    },
    {
        "id": 264,
        "title": "Fancy Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "Write an API that generates fancy sequences using the `append`, `addAll`, and `multAll` operations.\n\nImplement the `Fancy` class:\n\n*   `Fancy()` Initializes the object with an empty sequence.\n*   `void append(val)` Appends an integer `val` to the end of the sequence.\n*   `void addAll(inc)` Increments all existing values in the sequence by an integer `inc`.\n*   `void multAll(m)` Multiplies all existing values in the sequence by an integer `m`.\n*   `int getIndex(idx)` Gets the current value at index `idx` (0-indexed) of the sequence **modulo** `109 + 7`. If the index is greater or equal than the length of the sequence, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Fancy \",  \"append \",  \"addAll \",  \"append \",  \"multAll \",  \"getIndex \",  \"addAll \",  \"append \",  \"multAll \",  \"getIndex \",  \"getIndex \",  \"getIndex \"\\]\n\\[\\[\\], \\[2\\], \\[3\\], \\[7\\], \\[2\\], \\[0\\], \\[3\\], \\[10\\], \\[2\\], \\[0\\], \\[1\\], \\[2\\]\\]\n**Output**\n\\[null, null, null, null, null, 10, null, null, null, 26, 34, 20\\]\n\n**Explanation**\nFancy fancy = new Fancy();\nfancy.append(2);   // fancy sequence: \\[2\\]\nfancy.addAll(3);   // fancy sequence: \\[2+3\\] -> \\[5\\]\nfancy.append(7);   // fancy sequence: \\[5, 7\\]\nfancy.multAll(2);  // fancy sequence: \\[5\\*2, 7\\*2\\] -> \\[10, 14\\]\nfancy.getIndex(0); // return 10\nfancy.addAll(3);   // fancy sequence: \\[10+3, 14+3\\] -> \\[13, 17\\]\nfancy.append(10);  // fancy sequence: \\[13, 17, 10\\]\nfancy.multAll(2);  // fancy sequence: \\[13\\*2, 17\\*2, 10\\*2\\] -> \\[26, 34, 20\\]\nfancy.getIndex(0); // return 26\nfancy.getIndex(1); // return 34\nfancy.getIndex(2); // return 20"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= val, inc, m <= 100`\n*   `0 <= idx <= 105`\n*   At most `105` calls total will be made to `append`, `addAll`, `multAll`, and `getIndex`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Design",
            "Segment Tree"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,null,null,10,null,null,null,26,34,20]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int findMaxValueOfEquation(int[][] points, int k) {\n        int res = Integer.MIN_VALUE;\n        Deque<int[]> q = new LinkedList<>();\n        \n        for (int[] p : points) {\n            while (!q.isEmpty() && p[0] - q.peekFirst()[1] > k)\n                q.pollFirst();\n            \n            if (!q.isEmpty())\n                res = Math.max(res, p[1] + p[0] + q.peekFirst()[0]);\n            \n            while (!q.isEmpty() && p[1] - p[0] >= q.peekLast()[0])\n                q.pollLast();\n\n            q.offerLast(new int[]{p[1] - p[0], p[0]});\n        }\n        \n        return res;\n    }\n}\n```\n\n    \n    For each point, we maintain a double-ended queue (`deque` in Python and `LinkedList` in Java) of possible candidates that satisfy the condition |xi - xj| <= k, sorted by the value of yk - xk in decreasing order, so that the front of the queue has the largest value.\n\nWe iterate through the points array, and for each point:\n\n1. Remove points for which |xi - xj| > k from the front of the queue.\n2. Calculate the equation value for the current point using the largest yk - xk value from the front of the queue.\n3. Update the result if the calculated value is greater than the current result.\n4. If the current point has a larger yk - xk value than the last element in the queue, remove the last element from the queue. Since we want the largest yk - xk value in the queue, we keep removing the last element until we get a larger yk - xk value or the queue becomes empty. \n5. Append the current point to the queue.\n\nAfter iterating through all the points, return the maximum value found.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef findMaxValueOfEquation(points, k):\n    res = -float(\"inf\")\n    q = deque()\n   \n    for p in points:\n        while q and p[0] - q[0][1] > k:\n            q.popleft()\n        \n        if q:\n            res = max(res, p[1] + p[0] + q[0][0])\n        \n        while q and p[1] - p[0] >= q[-1][0]:\n            q.pop()\n        \n        q.append((p[1] - p[0], p[0]))\n    \n    return res\n```\n\n    \n    For each point, we maintain a double-ended queue (`deque` in Python and `LinkedList` in Java) of possible candidates that satisfy the condition |xi - xj| <= k, sorted by the value of yk - xk in decreasing order, so that the front of the queue has the largest value.\n\nWe iterate through the points array, and for each point:\n\n1. Remove points for which |xi - xj| > k from the front of the queue.\n2. Calculate the equation value for the current point using the largest yk - xk value from the front of the queue.\n3. Update the result if the calculated value is greater than the current result.\n4. If the current point has a larger yk - xk value than the last element in the queue, remove the last element from the queue. Since we want the largest yk - xk value in the queue, we keep removing the last element until we get a larger yk - xk value or the queue becomes empty. \n5. Append the current point to the queue.\n\nAfter iterating through all the points, return the maximum value found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint findMaxValueOfEquation(vector<vector<int>>& points, int k) {\n    int res = INT_MIN, left = 0;\n    vector<pair<int, int>> q;\n    \n    for (auto& p : points) {\n        while (!q.empty() && p[0] - q.front().second > k)\n            q.erase(q.begin());\n        \n        if (!q.empty())\n            res = max(res, p[1] + p[0] + q.front().first);\n        \n        while (!q.empty() && p[1] - p[0] >= q.back().first)\n            q.pop_back();\n\n        q.emplace_back(p[1] - p[0], p[0]);\n    }\n    \n    return res;\n}\n```\n    \n    For each point, we maintain a double-ended queue (`deque` in Python and `LinkedList` in Java) of possible candidates that satisfy the condition |xi - xj| <= k, sorted by the value of yk - xk in decreasing order, so that the front of the queue has the largest value.\n\nWe iterate through the points array, and for each point:\n\n1. Remove points for which |xi - xj| > k from the front of the queue.\n2. Calculate the equation value for the current point using the largest yk - xk value from the front of the queue.\n3. Update the result if the calculated value is greater than the current result.\n4. If the current point has a larger yk - xk value than the last element in the queue, remove the last element from the queue. Since we want the largest yk - xk value in the queue, we keep removing the last element until we get a larger yk - xk value or the queue becomes empty. \n5. Append the current point to the queue.\n\nAfter iterating through all the points, return the maximum value found.\n    ",
        "js": "\n    ```javascript\nfunction findMaxValueOfEquation(points, k) {\n    let res = -Infinity;\n    let q = [];\n    \n    for (let p of points) {\n        while (q.length > 0 && p[0] - q[0][1] > k)\n            q.shift();\n        \n        if (q.length > 0)\n            res = Math.max(res, p[1] + p[0] + q[0][0]);\n        \n        while (q.length > 0 && p[1] - p[0] >= q[q.length - 1][0])\n            q.pop();\n        \n        q.push([p[1] - p[0], p[0]]);\n    }\n    \n    return res;\n}\n```\n\n    \n    For each point, we maintain a double-ended queue (`deque` in Python and `LinkedList` in Java) of possible candidates that satisfy the condition |xi - xj| <= k, sorted by the value of yk - xk in decreasing order, so that the front of the queue has the largest value.\n\nWe iterate through the points array, and for each point:\n\n1. Remove points for which |xi - xj| > k from the front of the queue.\n2. Calculate the equation value for the current point using the largest yk - xk value from the front of the queue.\n3. Update the result if the calculated value is greater than the current result.\n4. If the current point has a larger yk - xk value than the last element in the queue, remove the last element from the queue. Since we want the largest yk - xk value in the queue, we keep removing the last element until we get a larger yk - xk value or the queue becomes empty. \n5. Append the current point to the queue.\n\nAfter iterating through all the points, return the maximum value found.\n    "
    },
    {
        "id": 265,
        "title": "Graph Connectivity With Threshold",
        "difficulty": "Hard",
        "content": {
            "problem": "We have `n` cities labeled from `1` to `n`. Two different cities with labels `x` and `y` are directly connected by a bidirectional road if and only if `x` and `y` share a common divisor **strictly greater** than some `threshold`. More formally, cities with labels `x` and `y` have a road between them if there exists an integer `z` such that all of the following are true:\n\n*   `x % z == 0`,\n*   `y % z == 0`, and\n*   `z > threshold`.\n\nGiven the two integers, `n` and `threshold`, and an array of `queries`, you must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are connected directly or indirectly. (i.e. there is some path between them).\n\nReturn _an array_ `answer`_, where_ `answer.length == queries.length` _and_ `answer[i]` _is_ `true` _if for the_ `ith` _query, there is a path between_ `ai` _and_ `bi`_, or_ `answer[i]` _is_ `false` _if there is no path._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, threshold = 2, queries = \\[\\[1,4\\],\\[2,5\\],\\[3,6\\]\\]\n**Output:** \\[false,false,true\\]\n**Explanation:** The divisors for each number:\n1:   1\n2:   1, 2\n3:   1, 3\n4:   1, 2, 4\n5:   1, 5\n6:   1, 2, 3, 6\nUsing the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the\nonly ones directly connected. The result of each query:\n\\[1,4\\]   1 is not connected to 4\n\\[2,5\\]   2 is not connected to 5\n\\[3,6\\]   3 is connected to 6 through path 3--6\n\n",
                "**Example 2:**\n\n**Input:** n = 6, threshold = 0, queries = \\[\\[4,5\\],\\[3,4\\],\\[3,2\\],\\[2,6\\],\\[1,3\\]\\]\n**Output:** \\[true,true,true,true,true\\]\n**Explanation:** The divisors for each number are the same as the previous example. However, since the threshold is 0,\nall divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.\n\n",
                "**Example 3:**\n\n**Input:** n = 5, threshold = 1, queries = \\[\\[4,5\\],\\[4,5\\],\\[3,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** \\[false,false,false,false,false\\]\n**Explanation:** Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.\nPlease notice that there can be multiple queries for the same pair of nodes \\[x, y\\], and that the query \\[x, y\\] is equivalent to the query \\[y, x\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`\n*   `0 <= threshold <= n`\n*   `1 <= queries.length <= 105`\n*   `queries[i].length == 2`\n*   `1 <= ai, bi <= cities`\n*   `ai != bi`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Union Find",
            "Number Theory"
        ],
        "example": [
            {
                "input": "6,2,[[1,4],[2,5],[3,6]]",
                "output": "[false,false,true]"
            },
            {
                "input": "6,0,[[4,5],[3,4],[3,2],[2,6],[1,3]]",
                "output": "[true,true,true,true,true]"
            },
            {
                "input": "5,1,[[4,5],[4,5],[3,2],[2,3],[3,4]]",
                "output": "[false,false,false,false,false]"
            }
        ],
        "java": "\n    ```java\npublic int lastMoment(int n, int[] left, int[] right) {\n    int max_left = 0;\n    int min_right = n;\n    \n    for(int position : left) {\n        max_left = Math.max(max_left, position);\n    }\n\n    for(int position : right) {\n        min_right = Math.min(min_right, position);\n    }\n\n    return Math.max(max_left, n - min_right);\n}\n```\n    \n    The algorithm calculates the moment when the last ant(s) fall out of the plank by following these steps:\n\n1. Find the maximum position of ants moving towards the left (max_left). These ants will fall off the left end of the plank.\n\n2. Find the minimum position of ants moving towards the right (min_right). These ants will fall off the right end of the plank.\n\n3. Return the maximum time taken among the ants falling off the left end (max_left) and the right end (n - min_right). This is because the ant that takes the maximum time to fall off the plank will be the last one to fall, so that moment will be the answer.\n    ",
        "python": "\n    ```python\ndef lastMoment(n, left, right):\n    max_left = max(left, default=0)\n    min_right = min(right, default=n)\n\n    return max(max_left, n - min_right)\n```\n    \n    The algorithm calculates the moment when the last ant(s) fall out of the plank by following these steps:\n\n1. Find the maximum position of ants moving towards the left (max_left). These ants will fall off the left end of the plank.\n\n2. Find the minimum position of ants moving towards the right (min_right). These ants will fall off the right end of the plank.\n\n3. Return the maximum time taken among the ants falling off the left end (max_left) and the right end (n - min_right). This is because the ant that takes the maximum time to fall off the plank will be the last one to fall, so that moment will be the answer.\n    ",
        "c++": "\n    ```cpp\nint lastMoment(int n, vector<int>& left, vector<int>& right) {\n    int max_left = 0;\n    int min_right = n;\n\n    for(int position : left) {\n        max_left = max(max_left, position);\n    }\n\n    for(int position : right) {\n        min_right = min(min_right, position);\n    }\n\n    return max(max_left, n - min_right);\n}\n```\n    \n    The algorithm calculates the moment when the last ant(s) fall out of the plank by following these steps:\n\n1. Find the maximum position of ants moving towards the left (max_left). These ants will fall off the left end of the plank.\n\n2. Find the minimum position of ants moving towards the right (min_right). These ants will fall off the right end of the plank.\n\n3. Return the maximum time taken among the ants falling off the left end (max_left) and the right end (n - min_right). This is because the ant that takes the maximum time to fall off the plank will be the last one to fall, so that moment will be the answer.\n    ",
        "js": "\n    ```javascript\nfunction lastMoment(n, left, right) {\n    let max_left = 0;\n    let min_right = n;\n\n    for (let position of left) {\n        max_left = Math.max(max_left, position);\n    }\n\n    for (let position of right) {\n        min_right = Math.min(min_right, position);\n    }\n\n    return Math.max(max_left, n - min_right);\n}\n```\n    \n    The algorithm calculates the moment when the last ant(s) fall out of the plank by following these steps:\n\n1. Find the maximum position of ants moving towards the left (max_left). These ants will fall off the left end of the plank.\n\n2. Find the minimum position of ants moving towards the right (min_right). These ants will fall off the right end of the plank.\n\n3. Return the maximum time taken among the ants falling off the left end (max_left) and the right end (n - min_right). This is because the ant that takes the maximum time to fall off the plank will be the last one to fall, so that moment will be the answer.\n    "
    },
    {
        "id": 266,
        "title": "Rank Transform of a Matrix",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` `matrix`, return _a new matrix_ `answer` _where_ `answer[row][col]` _is the_ _**rank** of_ `matrix[row][col]`.\n\nThe **rank** is an **integer** that represents how large an element is compared to other elements. It is calculated using the following rules:\n\n*   The rank is an integer starting from `1`.\n*   If two elements `p` and `q` are in the **same row or column**, then:\n    *   If `p < q` then `rank(p) < rank(q)`\n    *   If `p == q` then `rank(p) == rank(q)`\n    *   If `p > q` then `rank(p) > rank(q)`\n*   The **rank** should be as **small** as possible.\n\nThe test cases are generated so that `answer` is unique under the given rules.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** \\[\\[1,2\\],\\[2,3\\]\\]\n**Explanation:**\nThe rank of matrix\\[0\\]\\[0\\] is 1 because it is the smallest integer in its row and column.\nThe rank of matrix\\[0\\]\\[1\\] is 2 because matrix\\[0\\]\\[1\\] > matrix\\[0\\]\\[0\\] and matrix\\[0\\]\\[0\\] is rank 1.\nThe rank of matrix\\[1\\]\\[0\\] is 2 because matrix\\[1\\]\\[0\\] > matrix\\[0\\]\\[0\\] and matrix\\[0\\]\\[0\\] is rank 1.\nThe rank of matrix\\[1\\]\\[1\\] is 3 because matrix\\[1\\]\\[1\\] > matrix\\[0\\]\\[1\\], matrix\\[1\\]\\[1\\] > matrix\\[1\\]\\[0\\], and both matrix\\[0\\]\\[1\\] and matrix\\[1\\]\\[0\\] are rank 2.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[7,7\\],\\[7,7\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[20,-21,14\\],\\[-19,4,19\\],\\[22,-47,24\\],\\[-19,4,19\\]\\]\n**Output:** \\[\\[4,2,3\\],\\[1,3,4\\],\\[5,1,6\\],\\[1,3,4\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 500`\n*   `-109 <= matrix[row][col] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Union Find",
            "Graph",
            "Topological Sort",
            "Sorting",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2],[3,4]]",
                "output": "[[1,2],[2,3]]"
            },
            {
                "input": "[[7,7],[7,7]]",
                "output": "[[1,1],[1,1]]"
            },
            {
                "input": "[[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]",
                "output": "[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int numSplits(String s) {\n    Set<Character> leftSet = new HashSet<>();\n    Set<Character> rightSet = new HashSet<>();\n    int[] left = new int[s.length()], right = new int[s.length()];\n    int count = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        leftSet.add(s.charAt(i));\n        left[i] = leftSet.size();\n    }\n\n    for (int i = s.length() - 1; i > 0; i--) {\n        rightSet.add(s.charAt(i));\n        right[i] = rightSet.size();\n    }\n\n    for (int i = 0; i < s.length() - 1; i++) {\n        if (left[i] == right[i + 1]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n    \n    To solve this problem, we can iterate through the input string s and maintain two sets, one for distinct characters on the left side of the split (left_set) and one for the right side (right_set). \n\nWe create two arrays, 'left' and 'right', to store the number of distinct characters at each index in the input string. Then we iterate through the input string from left to right and update the 'left' array with the size of the left_set at each index. After that, we iterate through the input string again, but from right to left, and update the 'right' array with the size of the right_set at each index.\n\nFinally, we check whether the number of distinct characters in the left and right arrays are equal for each possible split, and increment the counter if they are equal. The counter will represent the number of good splits in the input string s.\n    ",
        "python": "\n    ```python\ndef numSplits(s: str) -> int:\n    left_set, right_set = set(), set()\n    left, right = [0] * len(s), [0] * len(s)\n    count = 0\n\n    for i, char in enumerate(s):\n        left_set.add(char)\n        left[i] = len(left_set)\n\n    for i in range(len(s) - 1, 0, -1):\n        right_set.add(s[i])\n        right[i] = len(right_set)\n\n    for i in range(len(s) - 1):\n        if left[i] == right[i + 1]:\n            count += 1\n\n    return count\n```\n    \n    To solve this problem, we can iterate through the input string s and maintain two sets, one for distinct characters on the left side of the split (left_set) and one for the right side (right_set). \n\nWe create two arrays, 'left' and 'right', to store the number of distinct characters at each index in the input string. Then we iterate through the input string from left to right and update the 'left' array with the size of the left_set at each index. After that, we iterate through the input string again, but from right to left, and update the 'right' array with the size of the right_set at each index.\n\nFinally, we check whether the number of distinct characters in the left and right arrays are equal for each possible split, and increment the counter if they are equal. The counter will represent the number of good splits in the input string s.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_set>\n#include <string>\nusing namespace std;\n\nint numSplits(string s) {\n    unordered_set<char> left_set, right_set;\n    vector<int> left(s.size()), right(s.size());\n    int count = 0;\n\n    for (int i = 0; i < s.size(); ++i) {\n        left_set.insert(s[i]);\n        left[i] = left_set.size();\n    }\n\n    for (int i = s.size() - 1; i > 0; --i) {\n        right_set.insert(s[i]);\n        right[i] = right_set.size();\n    }\n\n    for (int i = 0; i < s.size() - 1; ++i) {\n        if (left[i] == right[i + 1]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    To solve this problem, we can iterate through the input string s and maintain two sets, one for distinct characters on the left side of the split (left_set) and one for the right side (right_set). \n\nWe create two arrays, 'left' and 'right', to store the number of distinct characters at each index in the input string. Then we iterate through the input string from left to right and update the 'left' array with the size of the left_set at each index. After that, we iterate through the input string again, but from right to left, and update the 'right' array with the size of the right_set at each index.\n\nFinally, we check whether the number of distinct characters in the left and right arrays are equal for each possible split, and increment the counter if they are equal. The counter will represent the number of good splits in the input string s.\n    ",
        "js": "\n    ```javascript\nfunction numSplits(s) {\n    const leftSet = new Set(), rightSet = new Set();\n    const left = new Array(s.length).fill(0), right = new Array(s.length).fill(0);\n    let count = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        leftSet.add(s[i]);\n        left[i] = leftSet.size;\n    }\n\n    for (let i = s.length - 1; i > 0; i--) {\n        rightSet.add(s[i]);\n        right[i] = rightSet.size;\n    }\n\n    for (let i = 0; i < s.length - 1; i++) {\n        if (left[i] === right[i + 1]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n    \n    To solve this problem, we can iterate through the input string s and maintain two sets, one for distinct characters on the left side of the split (left_set) and one for the right side (right_set). \n\nWe create two arrays, 'left' and 'right', to store the number of distinct characters at each index in the input string. Then we iterate through the input string from left to right and update the 'left' array with the size of the left_set at each index. After that, we iterate through the input string again, but from right to left, and update the 'right' array with the size of the right_set at each index.\n\nFinally, we check whether the number of distinct characters in the left and right arrays are equal for each possible split, and increment the counter if they are equal. The counter will represent the number of good splits in the input string s.\n    "
    },
    {
        "id": 267,
        "title": "Number of Ways to Form a Target String Given a Dictionary",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a list of strings of the **same length** `words` and a string `target`.\n\nYour task is to form `target` using the given `words` under the following rules:\n\n*   `target` should be formed from left to right.\n*   To form the `ith` character (**0-indexed**) of `target`, you can choose the `kth` character of the `jth` string in `words` if `target[i] = words[j][k]`.\n*   Once you use the `kth` character of the `jth` string of `words`, you **can no longer** use the `xth` character of any string in `words` where `x <= k`. In other words, all characters to the left of or at index `k` become unusuable for every string.\n*   Repeat the process until you form the string `target`.\n\n**Notice** that you can use **multiple characters** from the **same string** in `words` provided the conditions above are met.\n\nReturn _the number of ways to form `target` from `words`_. Since the answer may be too large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"acca \", \"bbbb \", \"caca \"\\], target =  \"aba \"\n**Output:** 6\n**Explanation:** There are 6 ways to form target.\n \"aba \" -> index 0 ( \"acca \"), index 1 ( \"bbbb \"), index 3 ( \"caca \")\n \"aba \" -> index 0 ( \"acca \"), index 2 ( \"bbbb \"), index 3 ( \"caca \")\n \"aba \" -> index 0 ( \"acca \"), index 1 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 0 ( \"acca \"), index 2 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 1 ( \"caca \"), index 2 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 1 ( \"caca \"), index 2 ( \"bbbb \"), index 3 ( \"caca \")\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"abba \", \"baab \"\\], target =  \"bab \"\n**Output:** 4\n**Explanation:** There are 4 ways to form target.\n \"bab \" -> index 0 ( \"baab \"), index 1 ( \"baab \"), index 2 ( \"abba \")\n \"bab \" -> index 0 ( \"baab \"), index 1 ( \"baab \"), index 3 ( \"baab \")\n \"bab \" -> index 0 ( \"baab \"), index 2 ( \"baab \"), index 3 ( \"baab \")\n \"bab \" -> index 1 ( \"abba \"), index 2 ( \"baab \"), index 3 ( \"baab \")"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   All strings in `words` have the same length.\n*   `1 <= target.length <= 1000`\n*   `words[i]` and `target` contain only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[\"acca\",\"bbbb\",\"caca\"],\"aba\"",
                "output": "6"
            },
            {
                "input": "[\"abba\",\"baab\"],\"bab\"",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int numWays(String[] words, String target) {\n    int n = words.length;\n    int m = target.length();\n    int[][] count = new int[n][26];\n    int[][] dp = new int[m][n];\n    final int mod = 1000000007;\n\n    for (int i = 0; i < n; i++) {\n        for (char c : words[i].toCharArray()) {\n            count[i][c - 'a']++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        dp[0][i] = count[i][target.charAt(0) - 'a'];\n    }\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                dp[i][j] = (dp[i][j] + (int)(((long) dp[i-1][k] * count[j][target.charAt(i) - 'a']) % mod)) % mod;\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        res = (res + dp[m-1][i]) % mod;\n    }\n    return res;\n}\n```\n    \n    1. Count the occurrences of characters for each word in `words` and store them in a 2D array `count`.\n2. Initialize a 2D DP array `dp` where `dp[i][j]` represents the number of ways to form the string `target[0...i]` using the first `j` characters of the strings in `words`.\n3. Set the base case for `dp[0][i]` as the count of target character at index 0 in each word of `words`.\n4. For each target character from index 1 to index `m-1` (where `m` is the length of the target string), iterate through all words and update the `dp` array. Calculate the number of ways to form the target string using the current word and add it to the previous count stored in `dp`.\n5. Add modulo 10^9 + 7 at each step to avoid overflow.\n6. The result is the sum of values in the last row of `dp` array, modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef numWays(words, target):\n    n = len(words)\n    m = len(target)\n    count = [[0] * 26 for _ in range(n)]\n    dp = [[0] * n for _ in range(m)]\n    mod = 1000000007\n\n    for i, word in enumerate(words):\n        for c in word:\n            count[i][ord(c) - ord('a')] += 1\n\n    for i in range(n):\n        dp[0][i] = count[i][ord(target[0]) - ord('a')]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(n):\n                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][ord(target[i]) - ord('a')]) % mod\n\n    return sum(dp[m-1]) % mod\n```\n    \n    1. Count the occurrences of characters for each word in `words` and store them in a 2D array `count`.\n2. Initialize a 2D DP array `dp` where `dp[i][j]` represents the number of ways to form the string `target[0...i]` using the first `j` characters of the strings in `words`.\n3. Set the base case for `dp[0][i]` as the count of target character at index 0 in each word of `words`.\n4. For each target character from index 1 to index `m-1` (where `m` is the length of the target string), iterate through all words and update the `dp` array. Calculate the number of ways to form the target string using the current word and add it to the previous count stored in `dp`.\n5. Add modulo 10^9 + 7 at each step to avoid overflow.\n6. The result is the sum of values in the last row of `dp` array, modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nint numWays(vector<string>& words, string target) {\n    int n = words.size(), m = target.size();\n    vector<vector<int>> count(n, vector<int>(26, 0));\n    vector<vector<int>> dp(m, vector<int>(n, 0));\n    const int mod = 1e9 + 7;\n\n    for(int i = 0; i < n; i++) {\n        for(char c : words[i]) {\n            count[i][c - 'a']++;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        dp[0][i] = count[i][target[0] - 'a'];\n    }\n\n    for(int i = 1; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            for(int k = 0; k < n; k++) {\n                dp[i][j] = (dp[i][j] + (long long)dp[i-1][k] * count[j][target[i] - 'a']) % mod;\n            }\n        }\n    }\n\n    int res = 0;\n    for(int i = 0; i < n; i++) {\n        res = (res + dp[m-1][i]) % mod;\n    }\n    return res;\n}\n```\n    \n    1. Count the occurrences of characters for each word in `words` and store them in a 2D array `count`.\n2. Initialize a 2D DP array `dp` where `dp[i][j]` represents the number of ways to form the string `target[0...i]` using the first `j` characters of the strings in `words`.\n3. Set the base case for `dp[0][i]` as the count of target character at index 0 in each word of `words`.\n4. For each target character from index 1 to index `m-1` (where `m` is the length of the target string), iterate through all words and update the `dp` array. Calculate the number of ways to form the target string using the current word and add it to the previous count stored in `dp`.\n5. Add modulo 10^9 + 7 at each step to avoid overflow.\n6. The result is the sum of values in the last row of `dp` array, modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction numWays(words, target) {\n    const n = words.length;\n    const m = target.length;\n    const count = Array.from({length: n}, () => Array(26).fill(0));\n    const dp = Array.from({length: m}, () => Array(n).fill(0));\n    const mod = 1e9 + 7;\n\n    for (let i = 0; i < n; i++) {\n        for (let c of words[i]) {\n            count[i][c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        dp[0][i] = count[i][target.charCodeAt(0) - 'a'.charCodeAt(0)];\n    }\n\n    for (let i = 1; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            for (let k = 0; k < n; k++) {\n                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][target.charCodeAt(i) - 'a'.charCodeAt(0)]) % mod;\n            }\n        }\n    }\n\n    return dp[m-1].reduce((acc, val) => (acc + val) % mod, 0);\n}\n```\n    \n    1. Count the occurrences of characters for each word in `words` and store them in a 2D array `count`.\n2. Initialize a 2D DP array `dp` where `dp[i][j]` represents the number of ways to form the string `target[0...i]` using the first `j` characters of the strings in `words`.\n3. Set the base case for `dp[0][i]` as the count of target character at index 0 in each word of `words`.\n4. For each target character from index 1 to index `m-1` (where `m` is the length of the target string), iterate through all words and update the `dp` array. Calculate the number of ways to form the target string using the current word and add it to the previous count stored in `dp`.\n5. Add modulo 10^9 + 7 at each step to avoid overflow.\n6. The result is the sum of values in the last row of `dp` array, modulo 10^9 + 7.\n    "
    },
    {
        "id": 268,
        "title": "Kth Smallest Instructions",
        "difficulty": "Hard",
        "content": {
            "problem": "Bob is standing at cell `(0, 0)`, and he wants to reach `destination`: `(row, column)`. He can only travel **right** and **down**. You are going to help Bob by providing **instructions** for him to reach `destination`.\n\nThe **instructions** are represented as a string, where each character is either:\n\n*   `'H'`, meaning move horizontally (go **right**), or\n*   `'V'`, meaning move vertically (go **down**).\n\nMultiple **instructions** will lead Bob to `destination`. For example, if `destination` is `(2, 3)`, both `\"HHHVV \"` and `\"HVHVH \"` are valid **instructions**.\n\nHowever, Bob is very picky. Bob has a lucky number `k`, and he wants the `kth` **lexicographically smallest instructions** that will lead him to `destination`. `k` is **1-indexed**.\n\nGiven an integer array `destination` and an integer `k`, return _the_ `kth` _**lexicographically smallest instructions** that will take Bob to_ `destination`.",
            "examples": [
                "**Example 1:**\n\n**Input:** destination = \\[2,3\\], k = 1\n**Output:**  \"HHHVV \"\n**Explanation:** All the instructions that reach (2, 3) in lexicographic order are as follows:\n\\[ \"HHHVV \",  \"HHVHV \",  \"HHVVH \",  \"HVHHV \",  \"HVHVH \",  \"HVVHH \",  \"VHHHV \",  \"VHHVH \",  \"VHVHH \",  \"VVHHH \"\\].\n\n",
                "**Example 2:**\n\n**Input:** destination = \\[2,3\\], k = 2\n**Output:**  \"HHVHV \"\n\n",
                "**Example 3:**\n\n**Input:** destination = \\[2,3\\], k = 3\n**Output:**  \"HHVVH \""
            ],
            "constraints": "**Constraints:**\n\n*   `destination.length == 2`\n*   `1 <= row, column <= 15`\n*   `1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`​​​​​.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "[2,3],1",
                "output": "\"HHHVV\""
            },
            {
                "input": "[2,3],2",
                "output": "\"HHVHV\""
            },
            {
                "input": "[2,3],3",
                "output": "\"HHVVH\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] countSubTrees(int n, int[][] edges, String labels) {\n    ArrayList<ArrayList<Integer>> g = new ArrayList<>();\n    for (int i = 0; i < n; ++i) g.add(new ArrayList<>());\n    for (int[] edge : edges) g.get(edge[1]).add(edge[0]);\n    int[] ans = new int[n];\n    int[] count = new int[26];\n    dfs(0, g, labels, ans, count);\n    return ans;\n}\n\nprivate void dfs(int node, ArrayList<ArrayList<Integer>> g, String labels, int[] ans, int[] count) {\n    int pre = count[labels.charAt(node) - 'a'];\n    count[labels.charAt(node) - 'a']++;\n    ans[node] = count[labels.charAt(node) - 'a'] - pre;\n    for (int child : g.get(node)) dfs(child, g, labels, ans, count);\n    count[labels.charAt(node) - 'a'] = pre;\n}\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, tree, labels, ans, count):\n    prev_count = count[labels[node]]\n    count[labels[node]] += 1\n    ans[node] = count[labels[node]] - prev_count\n\n    for child in tree[node]:\n        dfs(child, tree, labels, ans, count)\n\n    count[labels[node]] = prev_count\n\ndef countSubTrees(n, edges, labels):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[1]].append(edge[0])\n\n    ans = [0] * n\n    count = defaultdict(int)\n    dfs(0, tree, labels, ans, count)\n\n    return ans\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid dfs(int node, const vector<vector<int>>& g, const string& labels, vector<int>& ans, vector<int> &count) {\n    int pre = count[labels[node] - 'a'];\n    count[labels[node] - 'a']++;\n    ans[node] = count[labels[node] - 'a'] - pre;\n    \n    for (auto child : g[node]) {\n        dfs(child, g, labels, ans, count);\n    }\n    \n    count[labels[node] - 'a'] = pre;\n}\n\nvector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n    vector<vector<int>> g(n);\n    for (const auto& edge : edges) {\n        g[edge[1]].push_back(edge[0]);\n    }\n    vector<int> ans(n);\n    vector<int> count(26);\n    dfs(0, g, labels, ans, count);\n    \n    return ans;\n}\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    ",
        "js": "\n    ```javascript\nfunction dfs(node, tree, labels, ans, count) {\n  const prevCount = count[labels[node]];\n  count[labels[node]]++;\n  ans[node] = count[labels[node]] - prevCount;\n\n  for (const child of tree[node]) {\n    dfs(child, tree, labels, ans, count);\n  }\n\n  count[labels[node]] = prevCount;\n}\n\nfunction countSubTrees(n, edges, labels) {\n  const tree = new Array(n).fill(0).map(() => []);\n  for (const edge of edges) {\n    tree[edge[1]].push(edge[0]);\n  }\n\n  const ans = new Array(n).fill(0);\n  const count = new Array(26).fill(0);\n  dfs(0, tree, labels, ans, count);\n\n  return ans;\n}\n```\n    \n    The algorithm consists of performing a depth-first search (DFS) traversal on the given tree starting from the root node (i.e. node 0). While traversing the tree, maintain a count array to keep track of the labels of the visited nodes. When visiting a node, store the current count of the node's label and increment the count, then visit its child nodes. Calculate the answer for the current node by subtracting the previous count from the updated count. After visiting all the children of a node, restore the previous count of the node's label so that it has the correct count when visiting the siblings in the higher level of the tree traversal. Finally, return the answer vector containing the count of nodes with the same label for each node in their corresponding subtree.\n    "
    },
    {
        "id": 269,
        "title": "Create Sorted Array through Instructions",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `instructions`, you are asked to create a sorted array from the elements in `instructions`. You start with an empty container `nums`. For each element from **left to right** in `instructions`, insert it into `nums`. The **cost** of each insertion is the **minimum** of the following:\n\n*   The number of elements currently in `nums` that are **strictly less than** `instructions[i]`.\n*   The number of elements currently in `nums` that are **strictly greater than** `instructions[i]`.\n\nFor example, if inserting element `3` into `nums = [1,2,3,5]`, the **cost** of insertion is `min(2, 1)` (elements `1` and `2` are less than `3`, element `5` is greater than `3`) and `nums` will become `[1,2,3,3,5]`.\n\nReturn _the **total cost** to insert all elements from_ `instructions` _into_ `nums`. Since the answer may be large, return it **modulo** `109 + 7`",
            "examples": [
                "**Example 1:**\n\n**Input:** instructions = \\[1,5,6,2\\]\n**Output:** 1\n**Explanation:** Begin with nums = \\[\\].\nInsert 1 with cost min(0, 0) = 0, now nums = \\[1\\].\nInsert 5 with cost min(1, 0) = 0, now nums = \\[1,5\\].\nInsert 6 with cost min(2, 0) = 0, now nums = \\[1,5,6\\].\nInsert 2 with cost min(1, 2) = 1, now nums = \\[1,2,5,6\\].\nThe total cost is 0 + 0 + 0 + 1 = 1.\n\n",
                "**Example 2:**\n\n**Input:** instructions = \\[1,2,3,6,5,4\\]\n**Output:** 3\n**Explanation:** Begin with nums = \\[\\].\nInsert 1 with cost min(0, 0) = 0, now nums = \\[1\\].\nInsert 2 with cost min(1, 0) = 0, now nums = \\[1,2\\].\nInsert 3 with cost min(2, 0) = 0, now nums = \\[1,2,3\\].\nInsert 6 with cost min(3, 0) = 0, now nums = \\[1,2,3,6\\].\nInsert 5 with cost min(3, 1) = 1, now nums = \\[1,2,3,5,6\\].\nInsert 4 with cost min(3, 2) = 2, now nums = \\[1,2,3,4,5,6\\].\nThe total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.\n\n",
                "**Example 3:**\n\n**Input:** instructions = \\[1,3,3,3,2,4,2,1,2\\]\n**Output:** 4\n**Explanation:** Begin with nums = \\[\\].\nInsert 1 with cost min(0, 0) = 0, now nums = \\[1\\].\nInsert 3 with cost min(1, 0) = 0, now nums = \\[1,3\\].\nInsert 3 with cost min(1, 0) = 0, now nums = \\[1,3,3\\].\nInsert 3 with cost min(1, 0) = 0, now nums = \\[1,3,3,3\\].\nInsert 2 with cost min(1, 3) = 1, now nums = \\[1,2,3,3,3\\].\nInsert 4 with cost min(5, 0) = 0, now nums = \\[1,2,3,3,3,4\\].\n​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = \\[1,2,2,3,3,3,4\\].\n​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = \\[1,1,2,2,3,3,3,4\\].\n​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = \\[1,1,2,2,2,3,3,3,4\\].\nThe total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= instructions.length <= 105`\n*   `1 <= instructions[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[1,5,6,2]",
                "output": "1"
            },
            {
                "input": "[1,2,3,6,5,4]",
                "output": "3"
            },
            {
                "input": "[1,3,3,3,2,4,2,1,2]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int maxNonOverlapping(int[] nums, int target) {\n    int sum = 0, count = 0;\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, 1);\n    for (int num : nums) {\n        sum += num;\n        if (map.containsKey(sum - target)) {\n            count++;\n            map.clear();\n            map.put(0, 1);\n            sum = 0;\n        } else {\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\n        }\n    }\n    return count;\n}\n```\n\n    \n    The algorithm uses a hashMap to store the prefix_sum values that have been seen so far.\n1. Initialize a hashMap with key-value pair {0: 1} since there is always an empty subarray whose sum is 0.\n2. Iterate through the nums array, for each element, update the sum_so_far value by adding the current element.\n3. At each step, check if the hashMap contains any key which is equal to the (sum_so_far - target). If yes, we have found a non-overlapping subarray with the sum equal to the target, so increment the count and reset the hashMap by retaining the initial key-value pair {0: 1}.\n4. If there is no such key available in the hashMap, add the current sum in hashMap with key equal to the current sum_so_far and add 1 to its value.\n5. Return the count at the end of iteration.\n    ",
        "python": "\n    ```python\ndef maxNonOverlapping(nums, target):\n    prefix_sum = {0: 1}\n    sum_so_far = count = 0\n    for num in nums:\n        sum_so_far += num\n        if sum_so_far - target in prefix_sum:\n            count += 1\n            prefix_sum.clear()\n            prefix_sum[0] = 1\n            sum_so_far = 0\n        else:\n            prefix_sum[sum_so_far] = prefix_sum.get(sum_so_far, 0) + 1\n    return count\n```\n\n    \n    The algorithm uses a hashMap to store the prefix_sum values that have been seen so far.\n1. Initialize a hashMap with key-value pair {0: 1} since there is always an empty subarray whose sum is 0.\n2. Iterate through the nums array, for each element, update the sum_so_far value by adding the current element.\n3. At each step, check if the hashMap contains any key which is equal to the (sum_so_far - target). If yes, we have found a non-overlapping subarray with the sum equal to the target, so increment the count and reset the hashMap by retaining the initial key-value pair {0: 1}.\n4. If there is no such key available in the hashMap, add the current sum in hashMap with key equal to the current sum_so_far and add 1 to its value.\n5. Return the count at the end of iteration.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint maxNonOverlapping(std::vector<int>& nums, int target) {\n    int sum = 0, count = 0;\n    std::unordered_map<int, int> umap;\n    umap[0] = 1;\n    for (int num : nums) {\n        sum += num;\n        if (umap[sum - target]) {\n            count++;\n            umap.clear();\n            umap[0] = 1;\n            sum = 0;\n        } else {\n            umap[sum]++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    The algorithm uses a hashMap to store the prefix_sum values that have been seen so far.\n1. Initialize a hashMap with key-value pair {0: 1} since there is always an empty subarray whose sum is 0.\n2. Iterate through the nums array, for each element, update the sum_so_far value by adding the current element.\n3. At each step, check if the hashMap contains any key which is equal to the (sum_so_far - target). If yes, we have found a non-overlapping subarray with the sum equal to the target, so increment the count and reset the hashMap by retaining the initial key-value pair {0: 1}.\n4. If there is no such key available in the hashMap, add the current sum in hashMap with key equal to the current sum_so_far and add 1 to its value.\n5. Return the count at the end of iteration.\n    ",
        "js": "\n    ```javascript\nfunction maxNonOverlapping(nums, target) {\n    let prefixSum = {};\n    let sumSoFar = 0;\n    let count = 0;\n    prefixSum[0] = 1;\n    for (const num of nums) {\n        sumSoFar += num;\n        if (prefixSum.hasOwnProperty(sumSoFar - target)) {\n            count++;\n            prefixSum = {};\n            prefixSum[0] = 1;\n            sumSoFar = 0;\n        } else {\n            if (!prefixSum.hasOwnProperty(sumSoFar)) {\n                prefixSum[sumSoFar] = 0;\n            }\n            prefixSum[sumSoFar]++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    The algorithm uses a hashMap to store the prefix_sum values that have been seen so far.\n1. Initialize a hashMap with key-value pair {0: 1} since there is always an empty subarray whose sum is 0.\n2. Iterate through the nums array, for each element, update the sum_so_far value by adding the current element.\n3. At each step, check if the hashMap contains any key which is equal to the (sum_so_far - target). If yes, we have found a non-overlapping subarray with the sum equal to the target, so increment the count and reset the hashMap by retaining the initial key-value pair {0: 1}.\n4. If there is no such key available in the hashMap, add the current sum in hashMap with key equal to the current sum_so_far and add 1 to its value.\n5. Return the count at the end of iteration.\n    "
    },
    {
        "id": 270,
        "title": "Distribute Repeating Integers",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of `n` integers, `nums`, where there are at most `50` unique values in the array. You are also given an array of `m` customer order quantities, `quantity`, where `quantity[i]` is the amount of integers the `ith` customer ordered. Determine if it is possible to distribute `nums` such that:\n\n*   The `ith` customer gets **exactly** `quantity[i]` integers,\n*   The integers the `ith` customer gets are **all equal**, and\n*   Every customer is satisfied.\n\nReturn `true` _if it is possible to distribute_ `nums` _according to the above conditions_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\], quantity = \\[2\\]\n**Output:** false\n**Explanation:** The 0th customer cannot be given two different integers.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,3\\], quantity = \\[2\\]\n**Output:** true\n**Explanation:** The 0th customer is given \\[3,3\\]. The integers \\[1,2\\] are not used.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,2,2\\], quantity = \\[2,2\\]\n**Output:** true\n**Explanation:** The 0th customer is given \\[1,1\\], and the 1st customer is given \\[2,2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 1000`\n*   `m == quantity.length`\n*   `1 <= m <= 10`\n*   `1 <= quantity[i] <= 105`\n*   There are at most `50` unique values in `nums`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,2,3,4],[2]",
                "output": "false"
            },
            {
                "input": "[1,2,3,3],[2]",
                "output": "true"
            },
            {
                "input": "[1,1,2,2],[2,2]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic boolean canDistribute(int[] nums, int[] quantity) {\n    Map<Integer, Integer> counts = new HashMap<>();\n    for (int num : nums) {\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\n    }\n\n    List<Integer> values = new ArrayList<>(counts.values());\n    Integer[] quantityArray = new Integer[quantity.length];\n    for (int i = 0; i < quantity.length; i++) {\n        quantityArray[i] = quantity[i];\n    }\n    Arrays.sort(quantityArray, Collections.reverseOrder());\n\n    return dfs(0, values, quantityArray);\n}\n\nprivate boolean dfs(int index, List<Integer> values, Integer[] quantityArray) {\n    if (index == quantityArray.length) {\n        return true;\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (values.get(i) >= quantityArray[index]) {\n            values.set(i, values.get(i) - quantityArray[index]);\n            if (dfs(index + 1, values, quantityArray)) return true;\n            values.set(i, values.get(i) + quantityArray[index]);\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm first calculates the frequency count of each unique number in the input `nums` and store the counts in a list/array `values`. Then it sorts the `quantity` in decreasing order so that we try to satisfy the customers with the largest order first.\n\nThe main part of the algorithm is the `dfs` function. It performs a depth first search on the counts (in `values`), trying to satisfy each customer in order as given in the `quantity` array. It backtracks when it is not possible to satisfy a customer with the remaining counts. The base case is when all the customers have been satisfied. In this case, the function returns `true`. If we cannot satisfy any customer, the function returns `false`.\n\nFinally, the main function `canDistribute` returns the result of the `dfs` function starting from the first customer.\n\nThe algorithm works for any of the four languages: C++, Java, Python, or JavaScript.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef canDistribute(nums, quantity):\n    counts = Counter(nums)\n    values = list(counts.values())\n    quantity.sort(reverse=True)\n\n    def dfs(index, values):\n        if index == len(quantity):\n            return True\n        for i in range(len(values)):\n            if values[i] >= quantity[index]:\n                values[i] -= quantity[index]\n                if dfs(index + 1, values):\n                    return True\n                values[i] += quantity[index]\n        return False\n\n    return dfs(0, values)\n```\n\n    \n    The algorithm first calculates the frequency count of each unique number in the input `nums` and store the counts in a list/array `values`. Then it sorts the `quantity` in decreasing order so that we try to satisfy the customers with the largest order first.\n\nThe main part of the algorithm is the `dfs` function. It performs a depth first search on the counts (in `values`), trying to satisfy each customer in order as given in the `quantity` array. It backtracks when it is not possible to satisfy a customer with the remaining counts. The base case is when all the customers have been satisfied. In this case, the function returns `true`. If we cannot satisfy any customer, the function returns `false`.\n\nFinally, the main function `canDistribute` returns the result of the `dfs` function starting from the first customer.\n\nThe algorithm works for any of the four languages: C++, Java, Python, or JavaScript.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nbool canDistribute(std::vector<int>& nums, std::vector<int>& quantity) {\n    std::unordered_map<int, int> counts;\n    for (int num : nums) {\n        counts[num]++;\n    }\n\n    std::vector<int> values;\n    for (auto& p : counts) {\n        values.push_back(p.second);\n    }\n    \n    std::sort(quantity.begin(), quantity.end(), std::greater<int>());\n\n    function<bool(int, vector<int>&)> dfs = [&](int index, vector<int>& values) {\n        if (index == quantity.size()) {\n            return true;\n        }\n        for (int i = 0; i < values.size(); ++i) {\n            if (values[i] >= quantity[index]) {\n                values[i] -= quantity[index];\n                if (dfs(index + 1, values)) return true;\n                values[i] += quantity[index];\n            }\n        }\n        return false;\n    };\n\n    return dfs(0, values);\n}\n```\n\n    \n    The algorithm first calculates the frequency count of each unique number in the input `nums` and store the counts in a list/array `values`. Then it sorts the `quantity` in decreasing order so that we try to satisfy the customers with the largest order first.\n\nThe main part of the algorithm is the `dfs` function. It performs a depth first search on the counts (in `values`), trying to satisfy each customer in order as given in the `quantity` array. It backtracks when it is not possible to satisfy a customer with the remaining counts. The base case is when all the customers have been satisfied. In this case, the function returns `true`. If we cannot satisfy any customer, the function returns `false`.\n\nFinally, the main function `canDistribute` returns the result of the `dfs` function starting from the first customer.\n\nThe algorithm works for any of the four languages: C++, Java, Python, or JavaScript.\n    ",
        "js": "\n    ```javascript\nfunction canDistribute(nums, quantity) {\n    const counts = new Map();\n    for (const num of nums) {\n        counts.set(num, (counts.get(num) || 0) + 1);\n    }\n\n    const values = Array.from(counts.values());\n    quantity.sort((a, b) => b - a);\n\n    function dfs(index, values) {\n        if (index === quantity.length) {\n            return true;\n        }\n        for (let i = 0; i < values.length; i++) {\n            if (values[i] >= quantity[index]) {\n                values[i] -= quantity[index];\n                if (dfs(index + 1, values)) return true;\n                values[i] += quantity[index];\n            }\n        }\n        return false;\n    }\n\n    return dfs(0, values);\n}\n```\n\n    \n    The algorithm first calculates the frequency count of each unique number in the input `nums` and store the counts in a list/array `values`. Then it sorts the `quantity` in decreasing order so that we try to satisfy the customers with the largest order first.\n\nThe main part of the algorithm is the `dfs` function. It performs a depth first search on the counts (in `values`), trying to satisfy each customer in order as given in the `quantity` array. It backtracks when it is not possible to satisfy a customer with the remaining counts. The base case is when all the customers have been satisfied. In this case, the function returns `true`. If we cannot satisfy any customer, the function returns `false`.\n\nFinally, the main function `canDistribute` returns the result of the `dfs` function starting from the first customer.\n\nThe algorithm works for any of the four languages: C++, Java, Python, or JavaScript.\n    "
    },
    {
        "id": 271,
        "title": "Maximize Grid Happiness",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.\n\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you **do not** have to have all the people living in the grid.\n\nThe **happiness** of each person is calculated as follows:\n\n*   Introverts **start** with `120` happiness and **lose** `30` happiness for each neighbor (introvert or extrovert).\n*   Extroverts **start** with `40` happiness and **gain** `20` happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n\nThe **grid happiness** is the **sum** of each person's happiness. Return _the **maximum possible grid happiness**._",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n**Output:** 240\n**Explanation:** Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 \\* 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 \\* 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 \\* 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n\n",
                "**Example 2:**\n\n**Input:** m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n**Output:** 260\n**Explanation:** Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 \\* 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 \\* 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 \\* 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n\n",
                "**Example 3:**\n\n**Input:** m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n**Output:** 240"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 5`\n*   `0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Bit Manipulation",
            "Memoization",
            "Bitmask"
        ],
        "example": [
            {
                "input": "2,3,1,2",
                "output": "240"
            },
            {
                "input": "3,1,2,1",
                "output": "260"
            },
            {
                "input": "2,2,4,0",
                "output": "240"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxSum(int[] nums1, int[] nums2) {\n    int mod = 1000000007;\n    int m = nums1.length, n = nums2.length;\n    long[] dp1 = new long[m + 1], dp2 = new long[n + 1];\n    int i = m - 1, j = n - 1;\n    while (i >= 0 || j >= 0) {\n        long a = i >= 0 ? dp1[i] + nums1[i] : Long.MIN_VALUE;\n        long b = j >= 0 ? dp2[j] + nums2[j] : Long.MIN_VALUE;\n        Set<Integer> seen = new HashSet<>();\n        if (a > b) {\n            dp1[i--] = a % mod;\n            seen.add(nums1[i + 1]);\n        } else {\n            dp2[j--] = b % mod;\n            seen.add(nums2[j + 1]);\n        }\n    }\n    return (int) Math.max(dp1[0], dp2[0]) % mod;\n}\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    ",
        "python": "\n    ```python\ndef maxSum(nums1, nums2):\n    mod = 10**9 + 7\n    m, n = len(nums1), len(nums2)\n    dp1, dp2 = [0] * (m + 1), [0] * (n + 1)\n    i, j = m - 1, n - 1\n    while i >= 0 or j >= 0:\n        a = dp1[i] + nums1[i] if i >= 0 else float('-inf')\n        b = dp2[j] + nums2[j] if j >= 0 else float('-inf')\n        seen = set()\n        if a > b:\n            dp1[i] = a % mod\n            i -= 1\n            seen.add(nums1[i + 1])\n        else:\n            dp2[j] = b % mod\n            j -= 1\n            seen.add(nums2[j + 1])\n    return max(dp1[0], dp2[0]) % mod\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nint maxSum(vector<int>& nums1, vector<int>& nums2) {\n    int mod = 1e9 + 7;\n    int m = nums1.size(), n = nums2.size();\n    long dp1[m + 1] = {0}, dp2[n + 1] = {0};\n    int i = m - 1, j = n - 1;\n    while (i >= 0 || j >= 0) {\n        long a = i >= 0 ? dp1[i] + nums1[i] : LONG_MIN;\n        long b = j >= 0 ? dp2[j] + nums2[j] : LONG_MIN;\n        set<int> seen;\n        if (a > b) {\n            dp1[i--] = a % mod;\n            seen.insert(nums1[i + 1]);\n        } else {\n            dp2[j--] = b % mod;\n            seen.insert(nums2[j + 1]);\n        }\n    }\n    return max(dp1[0], dp2[0]) % mod;\n}\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    ",
        "js": "\n    ```javascript\nfunction maxSum(nums1, nums2) {\n    const mod = 1e9 + 7;\n    const m = nums1.length, n = nums2.length;\n    const dp1 = new Array(m + 1).fill(0), dp2 = new Array(n + 1).fill(0);\n    let i = m - 1, j = n - 1;\n    while (i >= 0 || j >= 0) {\n        const a = i >= 0 ? dp1[i] + nums1[i] : Number.MIN_SAFE_INTEGER;\n        const b = j >= 0 ? dp2[j] + nums2[j] : Number.MIN_SAFE_INTEGER;\n        const seen = new Set();\n        if (a > b) {\n            dp1[i--] = a % mod;\n            seen.add(nums1[i + 1]);\n        } else {\n            dp2[j--] = b % mod;\n            seen.add(nums2[j + 1]);\n        }\n    }\n    return Math.max(dp1[0], dp2[0]) % mod;\n}\n```\n    \n    The algorithm used to solve this problem is dynamic programming. We create two dp arrays, dp1 and dp2, for nums1 and nums2 respectively. We loop in reverse through both nums1 and nums2, and for each step, we calculate the current sum with the current nums1[i] or nums2[j]. We track the uniques values using the 'seen' set. We'll update the dp array with the maximum sum at each step. Finally, we return the maximum value of the two dp arrays modulo 10^9 + 7.\n\nAt each step, the time complexity is O(1), and we need to perform a total of m + n steps where m and n are the sizes of nums1 and nums2. So, the total time complexity is O(m+n).\n    "
    },
    {
        "id": 272,
        "title": "Minimum Initial Energy to Finish Tasks",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.",
            "examples": [
                "**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n",
                "**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n",
                "**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual​i <= minimumi <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,2],[2,4],[4,8]]",
                "output": "8"
            },
            {
                "input": "[[1,3],[2,4],[10,11],[10,12],[8,9]]",
                "output": "32"
            },
            {
                "input": "[[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]",
                "output": "27"
            }
        ],
        "java": "\n    ```java\npublic int minimumEffort(int[][] tasks) {\n    Arrays.sort(tasks, (a, b) -> (b[1] - b[0]) - (a[1] - a[0]));\n    int ans = 0, sum = 0;\n    for (int[] task : tasks) {\n        ans = Math.max(ans, sum + task[1]);\n        sum += task[0];\n    }\n    return ans;\n}\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    ",
        "python": "\n    ```python\ndef minimumEffort(tasks):\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    ",
        "c++": "\n    ```cpp\nint minimumEffort(vector<vector<int>>& tasks) {\n    sort(tasks.begin(), tasks.end(), [](vector<int>& a, vector<int>& b) {\n        return a[1] - a[0] > b[1] - b[0];\n    });\n    int ans = 0, sum = 0;\n    for (auto& task : tasks) {\n        ans = max(ans, sum + task[1]);\n        sum += task[0];\n    }\n    return ans;\n}\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    ",
        "js": "\n    ```javascript\nfunction minimumEffort(tasks) {\n    tasks.sort((a, b) => (b[1] - b[0]) - (a[1] - a[0]));\n    let ans = 0, sum = 0;\n    for (const task of tasks) {\n        ans = Math.max(ans, sum + task[1]);\n        sum += task[0];\n    }\n    return ans;\n}\n```\n    \n    The main idea of this algorithm is to sort the tasks in descending order based on the difference between their `minimum` and `actual` energy requirements. By sorting in this order, we can ensure that we first finish the tasks which require more minimum energy, and the remaining tasks require less minimum energy to start. \n\nAfter sorting the tasks in the desired order, we iterate through the tasks to find the minimum initial energy required. \n\n1. Set the initial values of `ans` and `sum_energy` to 0.\n2. For each task in the sorted tasks list, calculate the maximum value between the current `ans` and the sum of `sum_energy` and the `minimum` energy required for the current task. Update the `ans` variable with this maximum value.\n3. Add the `actual` energy spent on the current task to the `sum_energy`.\n4. After iterating through all the tasks, the `ans` variable will store the minimum initial amount of energy required to finish all the tasks.\n    "
    },
    {
        "id": 273,
        "title": "Minimum Number of Removals to Make Mountain Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `nums`​​​, return _the **minimum** number of elements to remove to make_ `nums_​​​_` _a **mountain array**._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,1\\]\n**Output:** 0\n**Explanation:** The array itself is a mountain array so we do not need to remove any elements.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,1,1,5,6,2,3,1\\]\n**Output:** 3\n**Explanation:** One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \\[1,5,6,3,1\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 109`\n*   It is guaranteed that you can make a mountain array out of `nums`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "[1,3,1]",
                "output": "0"
            },
            {
                "input": "[2,1,1,5,6,2,3,1]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minimumMountainRemovals(int[] nums) {\n    int n = nums.length;\n    int[] left = new int[n], right = new int[n];\n    for (int i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);\n    }\n    int ans = n - 3;\n    for (int i = 1; i < n - 1; ++i) {\n        ans = Math.min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ",
        "python": "\n    ```python\ndef minimumMountainRemovals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])\n        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])\n    ans = n - 3\n    for i in range(1, n - 1):\n        ans = min(ans, n - 1 - left[i] - right[i])\n    return ans\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ",
        "c++": "\n    ```cpp\nint minimumMountainRemovals(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> left(n), right(n);\n    for (int i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1]);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i]);\n    }\n    int ans = n - 3;\n    for (int i = 1; i < n - 1; ++i) {\n        ans = min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    ",
        "js": "\n    ```javascript\nfunction minimumMountainRemovals(nums) {\n    const n = nums.length;\n    const left = new Array(n).fill(0);\n    const right = new Array(n).fill(0);\n    for (let i = 1; i < n; ++i) {\n        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);\n        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);\n    }\n    let ans = n - 3;\n    for (let i = 1; i < n - 1; ++i) {\n        ans = Math.min(ans, n - 1 - left[i] - right[i]);\n    }\n    return ans;\n}\n```\n    \n    The algorithm calculates the minimum number of elements to remove to make the input array a mountain array. First, it initializes two arrays `left` and `right`, with the same length as the input array. These arrays will store the increasing and decreasing sequence, respectively, ending at position `i`.\n\nFor each index in the range of the input array, the algorithm increases the length of `left` and `right` sequences if the current element is greater than the previous one or if the current element in the reversed array is greater the next one, respectively. Then, the minimum number of elements to remove is calculated by comparing the sum of both sequences for each index, and keeping the minimum value. Subtracting this value from the total length minus one is the final answer.\n    "
    },
    {
        "id": 274,
        "title": "Minimize Deviation in Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums` of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n*   If the element is **even**, **divide** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].`\n*   If the element is **odd**, **multiply** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].`\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn _the **minimum deviation** the array can have after performing some number of operations._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:** You can transform the array to \\[1,2,3,2\\], then to \\[2,2,3,2\\], then the deviation will be 3 - 2 = 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,1,5,20,3\\]\n**Output:** 3\n**Explanation:** You can transform the array after two operations to \\[4,2,5,5,3\\], then the deviation will be 5 - 2 = 3.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,10,8\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 5 * 104`\n*   `1 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Heap (Priority Queue)",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "1"
            },
            {
                "input": "[4,1,5,20,3]",
                "output": "3"
            },
            {
                "input": "[2,10,8]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxDistance(int[] position, int m) {\n    Arrays.sort(position);\n\n    int left = 1;\n    int right = position[position.length - 1] - position[0];\n    int ans = 0;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (canPlaceBalls(mid, position, m)) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n}\n\nprivate boolean canPlaceBalls(int force, int[] position, int m) {\n    int last_position = position[0];\n    int placed_balls = 1;\n\n    for (int i = 1; i < position.length; i++) {\n        if (position[i] - last_position >= force) {\n            placed_balls++;\n            last_position = position[i];\n\n            if (placed_balls == m) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef can_place_balls(force: int, position: List[int], m: int) -> bool:\n    last_position = position[0]\n    placed_balls = 1\n\n    for i in range(1, len(position)):\n        if position[i] - last_position >= force:\n            placed_balls += 1\n            last_position = position[i]\n\n            if placed_balls == m:\n                return True\n\n    return False\n\ndef max_distance(position: List[int], m: int) -> int:\n    position.sort()\n\n    left = 1\n    right = position[-1] - position[0]\n    ans = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_place_balls(mid, position, m):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return ans\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nbool canPlaceBalls(int force, const std::vector<int>& position, int m) {\n    int last_position = position[0];\n    int placed_balls = 1;\n\n    for (int i = 1; i < position.size(); i++) {\n        if (position[i] - last_position >= force) {\n            placed_balls++;\n            last_position = position[i];\n\n            if (placed_balls == m) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint maxDistance(std::vector<int>& position, int m) {\n    std::sort(position.begin(), position.end());\n\n    int left = 1;\n    int right = position.back() - position[0];\n    int ans = 0;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (canPlaceBalls(mid, position, m)) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    ",
        "js": "\n    ```javascript\nfunction canPlaceBalls(force, position, m) {\n    let last_position = position[0];\n    let placed_balls = 1;\n\n    for (let i = 1; i < position.length; i++) {\n        if (position[i] - last_position >= force) {\n            placed_balls++;\n            last_position = position[i];\n\n            if (placed_balls === m) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction maxDistance(position, m) {\n    position.sort((a, b) => a - b);\n\n    let left = 1;\n    let right = position[position.length - 1] - position[0];\n    let ans = 0;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (canPlaceBalls(mid, position, m)) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The algorithm consists of a binary search to find the minimum distance between `m` balls in the baskets. It has a helper function, `canPlaceBalls`, that checks if it is possible to place `m` balls in the baskets with the given minimum distance. The main function, `maxDistance`, sorts the position array first and then does the binary search. During the binary search, it repeatedly calls the `canPlaceBalls` function with different distances to find the maximum distance, where `m` balls can still be placed in the baskets.\n    "
    },
    {
        "id": 275,
        "title": "Delivering Boxes from Storage to Ports",
        "difficulty": "Hard",
        "content": {
            "problem": "You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a **limit** on the **number of boxes** and the **total weight** that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports​​i​, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n*   `ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n*   `portsCount` is the number of ports.\n*   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered **in the order they are given**. The ship will follow these steps:\n\n*   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n*   For each loaded box **in order**, the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no **trip** is needed, and the box can immediately be delivered.\n*   The ship then makes a return **trip** to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn _the **minimum** number of **trips** the ship needs to make to deliver all boxes to their respective ports._",
            "examples": [
                "**Example 1:**\n\n**Input:** boxes = \\[\\[1,1\\],\\[2,1\\],\\[1,1\\]\\], portsCount = 2, maxBoxes = 3, maxWeight = 3\n**Output:** 4\n**Explanation:** The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n\n",
                "**Example 2:**\n\n**Input:** boxes = \\[\\[1,2\\],\\[3,3\\],\\[3,1\\],\\[3,1\\],\\[2,4\\]\\], portsCount = 3, maxBoxes = 3, maxWeight = 6\n**Output:** 6\n**Explanation:** The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n",
                "**Example 3:**\n\n**Input:** boxes = \\[\\[1,4\\],\\[1,2\\],\\[2,1\\],\\[2,1\\],\\[3,2\\],\\[3,4\\]\\], portsCount = 3, maxBoxes = 6, maxWeight = 7\n**Output:** 6\n**Explanation:** The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= boxes.length <= 105`\n*   `1 <= portsCount, maxBoxes, maxWeight <= 105`\n*   `1 <= ports​​i <= portsCount`\n*   `1 <= weightsi <= maxWeight`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Segment Tree",
            "Queue",
            "Heap (Priority Queue)",
            "Prefix Sum",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[[1,1],[2,1],[1,1]],2,3,3",
                "output": "4"
            },
            {
                "input": "[[1,2],[3,3],[3,1],[3,1],[2,4]],3,3,6",
                "output": "6"
            },
            {
                "input": "[[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]],3,6,7",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int min_trips(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\n    int trips = 0, idx = 0, n = boxes.length;\n    while (idx < n) {\n        int curr_limit = maxWeight, prev_port = 0;\n        for (int count = 0; count < maxBoxes && idx < n; ++idx) {\n            if (boxes[idx][1] <= curr_limit) {\n                if (prev_port != boxes[idx][0]) {\n                    prev_port = boxes[idx][0];\n                    ++trips;\n                }\n                curr_limit -= boxes[idx][1];\n                ++count;\n            }\n        }\n        ++trips;\n    }\n    return trips;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize `trips` to store minimum trips, `idx` to traverse boxes, length `n` of boxes.\n2. Create a while loop, while `idx` is less than `n`, repeating steps 3-9.\n3. Set `curr_limit` as the maximum weight to keep track of remaining weight allowed, and set `prev_port` to 0 as the initial previous port.\n4. Run a for loop upto `maxBoxes` and `idx` less than `n`.\n5. Check if the `weights_i` from boxes less than or equal to the `curr_limit`, if yes, go to step 6, else break.\n6. If `ports_i` is not equal to the `prev_port`, update the `prev_port` with the value of `ports_i` and increment `trips`.\n7. Decrement the `curr_limit` by the value of `weights_i`.\n8. Increment the counter for the inner for loop (for the number of boxes).\n9. Increment the `trips`.\n10. Return the value of `trips`.\n    ",
        "python": "\n    ```python\ndef min_trips(boxes, portsCount, maxBoxes, maxWeight):\n    trips = 0\n    idx = 0\n    n = len(boxes)\n    while idx < n:\n        curr_limit = maxWeight\n        prev_port = 0\n        count = 0\n        while count < maxBoxes and idx < n:\n            if boxes[idx][1] <= curr_limit:\n                if prev_port != boxes[idx][0]:\n                    prev_port = boxes[idx][0]\n                    trips += 1\n                curr_limit -= boxes[idx][1]\n                count += 1\n                idx += 1\n            else:\n                break\n        trips += 1\n    return trips\n```\n    \n    The algorithm works as follows:\n1. Initialize `trips` to store minimum trips, `idx` to traverse boxes, length `n` of boxes.\n2. Create a while loop, while `idx` is less than `n`, repeating steps 3-9.\n3. Set `curr_limit` as the maximum weight to keep track of remaining weight allowed, and set `prev_port` to 0 as the initial previous port.\n4. Run a for loop upto `maxBoxes` and `idx` less than `n`.\n5. Check if the `weights_i` from boxes less than or equal to the `curr_limit`, if yes, go to step 6, else break.\n6. If `ports_i` is not equal to the `prev_port`, update the `prev_port` with the value of `ports_i` and increment `trips`.\n7. Decrement the `curr_limit` by the value of `weights_i`.\n8. Increment the counter for the inner for loop (for the number of boxes).\n9. Increment the `trips`.\n10. Return the value of `trips`.\n    ",
        "c++": "\n    ```cpp\nint min_trips(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight) {\n    int trips = 0, idx = 0, n = boxes.size();\n    while (idx < n) {\n        int curr_limit = maxWeight, prev_port = 0;\n        for (int count = 0; count < maxBoxes && idx < n; ++idx) {\n            if (boxes[idx][1] <= curr_limit) {\n                if (prev_port != boxes[idx][0]) {\n                    prev_port = boxes[idx][0];\n                    ++trips;\n                }\n                curr_limit -= boxes[idx][1];\n                ++count;\n            }\n        }\n        ++trips;\n    }\n    return trips;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize `trips` to store minimum trips, `idx` to traverse boxes, length `n` of boxes.\n2. Create a while loop, while `idx` is less than `n`, repeating steps 3-9.\n3. Set `curr_limit` as the maximum weight to keep track of remaining weight allowed, and set `prev_port` to 0 as the initial previous port.\n4. Run a for loop upto `maxBoxes` and `idx` less than `n`.\n5. Check if the `weights_i` from boxes less than or equal to the `curr_limit`, if yes, go to step 6, else break.\n6. If `ports_i` is not equal to the `prev_port`, update the `prev_port` with the value of `ports_i` and increment `trips`.\n7. Decrement the `curr_limit` by the value of `weights_i`.\n8. Increment the counter for the inner for loop (for the number of boxes).\n9. Increment the `trips`.\n10. Return the value of `trips`.\n    ",
        "js": "\n    ```javascript\nfunction min_trips(boxes, portsCount, maxBoxes, maxWeight) {\n    let trips = 0, idx = 0, n = boxes.length;\n    while (idx < n) {\n        let curr_limit = maxWeight, prev_port = 0;\n        for (let count = 0; count < maxBoxes && idx < n; ++idx) {\n            if (boxes[idx][1] <= curr_limit) {\n                if (prev_port !== boxes[idx][0]) {\n                    prev_port = boxes[idx][0];\n                    trips += 1;\n                }\n                curr_limit -= boxes[idx][1];\n                count += 1;\n            }\n        }\n        trips += 1;\n    }\n    return trips;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize `trips` to store minimum trips, `idx` to traverse boxes, length `n` of boxes.\n2. Create a while loop, while `idx` is less than `n`, repeating steps 3-9.\n3. Set `curr_limit` as the maximum weight to keep track of remaining weight allowed, and set `prev_port` to 0 as the initial previous port.\n4. Run a for loop upto `maxBoxes` and `idx` less than `n`.\n5. Check if the `weights_i` from boxes less than or equal to the `curr_limit`, if yes, go to step 6, else break.\n6. If `ports_i` is not equal to the `prev_port`, update the `prev_port` with the value of `ports_i` and increment `trips`.\n7. Decrement the `curr_limit` by the value of `weights_i`.\n8. Increment the counter for the inner for loop (for the number of boxes).\n9. Increment the `trips`.\n10. Return the value of `trips`.\n    "
    },
    {
        "id": 276,
        "title": "Checking Existence of Edge Length Limited Paths",
        "difficulty": "Hard",
        "content": {
            "problem": "An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be **multiple** edges between two nodes.\n\nGiven an array `queries`, where `queries[j] = [pj, qj, limitj]`, your task is to determine for each `queries[j]` whether there is a path between `pj` and `qj` such that each edge on the path has a distance **strictly less than** `limitj` .\n\nReturn _a **boolean array**_ `answer`_, where_ `answer.length == queries.length` _and the_ `jth` _value of_ `answer` _is_ `true` _if there is a path for_ `queries[j]` _is_ `true`_, and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, edgeList = \\[\\[0,1,2\\],\\[1,2,4\\],\\[2,0,8\\],\\[1,0,16\\]\\], queries = \\[\\[0,1,2\\],\\[0,2,5\\]\\]\n**Output:** \\[false,true\\]\n**Explanation:** The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\nFor the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\nFor the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.\n\n",
                "**Example 2:**\n\n**Input:** n = 5, edgeList = \\[\\[0,1,10\\],\\[1,2,5\\],\\[2,3,9\\],\\[3,4,13\\]\\], queries = \\[\\[0,4,14\\],\\[1,4,13\\]\\]\n**Output:** \\[true,false\\]\n**Exaplanation:** The above figure shows the given graph."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= edgeList.length, queries.length <= 105`\n*   `edgeList[i].length == 3`\n*   `queries[j].length == 3`\n*   `0 <= ui, vi, pj, qj <= n - 1`\n*   `ui != vi`\n*   `pj != qj`\n*   `1 <= disi, limitj <= 109`\n*   There may be **multiple** edges between two nodes.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Union Find",
            "Graph",
            "Sorting"
        ],
        "example": [
            {
                "input": "3,[[0,1,2],[1,2,4],[2,0,8],[1,0,16]],[[0,1,2],[0,2,5]]",
                "output": "[false,true]"
            },
            {
                "input": "5,[[0,1,10],[1,2,5],[2,3,9],[3,4,13]],[[0,4,14],[1,4,13]]",
                "output": "[true,false]\n**Exaplanation:**Theabovefigureshowsthegivengraph."
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n\n        for (int[] edge : edgeList) {\n            graph.putIfAbsent(edge[0], new ArrayList<>());\n            graph.putIfAbsent(edge[1], new ArrayList<>());\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\n        }\n\n        boolean[] answer = new boolean[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int pj = queries[i][0], qj = queries[i][1], limitj = queries[i][2];\n\n            Queue<int[]> q = new LinkedList<>();\n            q.add(new int[]{pj, 0});\n            boolean[] visited = new boolean[n];\n            visited[pj] = true;\n\n            while (!q.isEmpty()) {\n                int[] curr = q.poll();\n\n                for (int[] next : graph.getOrDefault(curr[0], new ArrayList<>())) {\n                    if (curr[1] + next[1] < limitj) {\n                        if (next[0] == qj) {\n                            answer[i] = true;\n                            break;\n                        }\n                        if (!visited[next[0]]) {\n                            visited[next[0]] = true;\n                            q.add(new int[]{next[0], curr[1] + next[1]});\n                        }\n                    }\n                }\n                if (answer[i]) \n                    break;\n            }\n        }\n        return answer;\n    }\n}\n```\n    \n    The algorithm first creates a graph representation using adjacency lists. Then, for each query, it performs a modified Breadth-First Search (BFS) starting from the node `pj`. During the BFS, we keep track of the distance travelled so far for each node in the queue. If we find the node `qj` with a distance less than `limitj`, we mark the answer for the current query as `true` and exit the BFS loop. If not, the answer for the current query will be `false`. We repeat this process for all queries and return the result as a boolean array.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef distanceLimitedPathsExist(n, edgeList, queries):\n    graph = defaultdict(list)\n\n    for u, v, dis in edgeList:\n        graph[u].append((v, dis))\n        graph[v].append((u, dis))\n\n    answer = [False] * len(queries)\n    for i, (pj, qj, limitj) in enumerate(queries):\n        q = deque([(pj, 0)])\n        visited = [False] * n\n        visited[pj] = True\n\n        while q:\n            curr_node, curr_dist = q.popleft()\n\n            for next_node, next_dist in graph[curr_node]:\n                if curr_dist + next_dist < limitj:\n                    if next_node == qj:\n                        answer[i] = True\n                        break\n                    if not visited[next_node]:\n                        visited[next_node] = True\n                        q.append((next_node, curr_dist + next_dist))\n            if answer[i]:\n                break\n\n    return answer\n```\n    \n    The algorithm first creates a graph representation using adjacency lists. Then, for each query, it performs a modified Breadth-First Search (BFS) starting from the node `pj`. During the BFS, we keep track of the distance travelled so far for each node in the queue. If we find the node `qj` with a distance less than `limitj`, we mark the answer for the current query as `true` and exit the BFS loop. If not, the answer for the current query will be `false`. We repeat this process for all queries and return the result as a boolean array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\n    unordered_map<int, vector<pair<int, int>>> graph;\n    for (auto& edge : edgeList) {\n        graph[edge[0]].emplace_back(edge[1], edge[2]);\n        graph[edge[1]].emplace_back(edge[0], edge[2]);\n    }\n\n    vector<bool> answer(queries.size());\n    for (int i = 0; i < queries.size(); i++) {\n        int pj = queries[i][0], qj = queries[i][1], limitj = queries[i][2];\n\n        queue<pair<int, int>> q;\n        q.push({pj, 0});\n        vector<bool> visited(n, false);\n        visited[pj] = true;\n\n        while (!q.empty()) {\n            auto curr = q.front();\n            q.pop();\n\n            for (auto& next : graph[curr.first]) {\n                if (curr.second + next.second < limitj) {\n                    if (next.first == qj) {\n                        answer[i] = true;\n                        break;\n                    }\n                    if (!visited[next.first]) {\n                        visited[next.first] = true;\n                        q.push({next.first, curr.second + next.second});\n                    }\n                }\n            }\n            if (answer[i]) \n                break;\n        }\n    }\n    return answer;\n}\n```\n    \n    The algorithm first creates a graph representation using adjacency lists. Then, for each query, it performs a modified Breadth-First Search (BFS) starting from the node `pj`. During the BFS, we keep track of the distance travelled so far for each node in the queue. If we find the node `qj` with a distance less than `limitj`, we mark the answer for the current query as `true` and exit the BFS loop. If not, the answer for the current query will be `false`. We repeat this process for all queries and return the result as a boolean array.\n    ",
        "js": "\n    ```javascript\nfunction distanceLimitedPathsExist(n, edgeList, queries) {\n    const graph = new Map();\n\n    for (const [u, v, dis] of edgeList) {\n        if (!graph.has(u)) graph.set(u, []);\n        if (!graph.has(v)) graph.set(v, []);\n        graph.get(u).push([v, dis]);\n        graph.get(v).push([u, dis]);\n    }\n\n    const answer = new Array(queries.length).fill(false);\n    for (let i = 0; i < queries.length; i++) {\n        const [pj, qj, limitj] = queries[i];\n\n        const q = [[pj, 0]];\n        const visited = new Array(n).fill(false);\n        visited[pj] = true;\n\n        while (q.length > 0) {\n            const [curr_node, curr_dist] = q.shift();\n\n            for (const [next_node, next_dist] of graph.get(curr_node) || []) {\n                if (curr_dist + next_dist < limitj) {\n                    if (next_node === qj) {\n                        answer[i] = true;\n                        break;\n                    }\n                    if (!visited[next_node]) {\n                        visited[next_node] = true;\n                        q.push([next_node, curr_dist + next_dist]);\n                    }\n                }\n            }\n            if (answer[i]) break;\n        }\n    }\n    return answer;\n}\n```\n    \n    The algorithm first creates a graph representation using adjacency lists. Then, for each query, it performs a modified Breadth-First Search (BFS) starting from the node `pj`. During the BFS, we keep track of the distance travelled so far for each node in the queue. If we find the node `qj` with a distance less than `limitj`, we mark the answer for the current query as `true` and exit the BFS loop. If not, the answer for the current query will be `false`. We repeat this process for all queries and return the result as a boolean array.\n    "
    },
    {
        "id": 277,
        "title": "Minimum Adjacent Swaps for K Consecutive Ones",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two **adjacent** indices and swap their values.\n\nReturn _the **minimum** number of moves required so that_ `nums` _has_ `k` _**consecutive**_ `1`_'s_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,0,0,1,0,1\\], k = 2\n**Output:** 1\n**Explanation:** In 1 move, nums could be \\[1,0,0,0,1,1\\] and have 2 consecutive 1's.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,0,0,0,0,1,1\\], k = 3\n**Output:** 5\n**Explanation:** In 5 moves, the leftmost 1 can be shifted right until nums = \\[0,0,0,0,0,1,1,1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,0,1\\], k = 2\n**Output:** 0\n**Explanation:** nums already has 2 consecutive 1's."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is `0` or `1`.\n*   `1 <= k <= sum(nums)`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,0,0,1,0,1],2",
                "output": "1"
            },
            {
                "input": "[1,0,0,0,0,0,1,1],3",
                "output": "5"
            },
            {
                "input": "[1,1,0,1],2",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minMoves(int[] nums, int k) {\n    List<Integer> ones_pos = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == 1) {\n            ones_pos.add(i - ones_pos.size());\n        }\n    }\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        sum += ones_pos.get(i);\n    }\n    int min_sum = sum;\n    for (int i = k; i < ones_pos.size(); i++) {\n        sum += ones_pos.get(i) - ones_pos.get(i - k);\n        min_sum = Math.min(min_sum, sum);\n    }\n    return min_sum - (k - 1) * k / 2;\n}\n```\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    ",
        "python": "\n    ```python\ndef minMoves(nums, k):\n    ones_pos = [i for i, x in enumerate(nums) if x == 1]\n    to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)]\n    min_moves = sum(to_move[k // 2:])\n    move = min_moves\n    for left, right in zip(\n        to_move[:-k],       # left \"window\" of k-sized sliding window\n        to_move[k // 2 + 1:],  # right \"window\" of k-sized sliding window\n    ):\n        move += left - right\n        min_moves = min(min_moves, move)\n    return min_moves\n```\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    ",
        "c++": "\n    ```cpp\nint minMoves(vector<int>& nums, int k) {\n    vector<int> ones_pos;\n    int moves = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == 1) {\n            ones_pos.push_back(i);\n        }\n    }\n    for (int i = 0; i + k <= ones_pos.size(); i++) {\n        int pos = ones_pos[i + k / 2];\n        for (int j = i; j < i + k; j++) {\n            moves += abs(ones_pos[j] - pos);\n        }\n    }\n    return moves;\n}\n```\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    ",
        "js": "\n    ```javascript\nfunction minMoves(nums, k) {\n    const ones_pos = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 1) {\n            ones_pos.push(i - ones_pos.length);\n        }\n    }\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += ones_pos[i];\n    }\n    let min_sum = sum;\n    for (let i = k; i < ones_pos.length; i++) {\n        sum += ones_pos[i] - ones_pos[i - k];\n        min_sum = Math.min(min_sum, sum);\n    }\n    return min_sum - (k - 1) * k / 2;\n}\n```\n\n    \n    The algorithm finds the positions of all the 1s in the input array. Then, it calculates the differences between positions and takes out the prefix sum of differences. After that, it finds the minimum sum of the differences for the sliding window of size `k`. The final result is the minimum sum of differences minus the sum of integers from 0 to `k - 1`. All the implementations follow the above algorithm and are adjusted to work with the respective languages.\n    "
    },
    {
        "id": 278,
        "title": "Maximum XOR With an Element From Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums` consisting of non-negative integers. You are also given a `queries` array, where `queries[i] = [xi, mi]`.\n\nThe answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and any element of `nums` that does not exceed `mi`. In other words, the answer is `max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements in `nums` are larger than `mi`, then the answer is `-1`.\n\nReturn _an integer array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,3,4\\], queries = \\[\\[3,1\\],\\[1,3\\],\\[5,6\\]\\]\n**Output:** \\[3,3,7\\]\n**Explanation:**\n1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,2,4,6,6,3\\], queries = \\[\\[12,4\\],\\[8,1\\],\\[6,3\\]\\]\n**Output:** \\[15,-1,5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length, queries.length <= 105`\n*   `queries[i].length == 2`\n*   `0 <= nums[j], xi, mi <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Trie"
        ],
        "example": [
            {
                "input": "[0,1,2,3,4],[[3,1],[1,3],[5,6]]",
                "output": "[3,3,7]"
            },
            {
                "input": "[5,2,4,6,6,3],[[12,4],[8,1],[6,3]]",
                "output": "[15,-1,5]"
            }
        ],
        "java": "\n    ```java\nboolean canTransform(String s, String t) {\n    int i = 0, j = 0;\n    while (i < s.length() && j < t.length()) {\n        if (s.charAt(i) == t.charAt(j)) {\n            i++;\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return j == t.length();\n}\n```\n\n    \n    The algorithm used in all these implementations is the same. We use two pointers `i` and `j` to iterate through string `s` and `t`, respectively. We start at the beginning of each string and compare the characters at `i` and `j` indices. \n\nIf the characters are the same, we increment both `i` and `j`. If the characters are different, we increment only `i`, which effectively deletes the character at index `i` from string `s`. \n\nWe repeat this process until we have iterated through the entire string `s` or string `t`. If we've reached the end of string `t`, it means we could possibly transform `s` into `t` by visiting/deleting some characters from `s`. In this case, we return `true`. If we haven't reached the end of string `t`, it means we couldn't transform `s` into `t`, and we return `false`. \n\nFor all languages, the implementation and logic are the same, only the syntax differs. For example, in Python, we use `len()` to find the length of a string, while in Java, we use the `.length()` method. Likewise, in JavaScript, we use the `.length` property of a string.\n    ",
        "python": "\n    ```python\ndef can_transform(s, t):\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return j == len(t)\n```\n\n    \n    The algorithm used in all these implementations is the same. We use two pointers `i` and `j` to iterate through string `s` and `t`, respectively. We start at the beginning of each string and compare the characters at `i` and `j` indices. \n\nIf the characters are the same, we increment both `i` and `j`. If the characters are different, we increment only `i`, which effectively deletes the character at index `i` from string `s`. \n\nWe repeat this process until we have iterated through the entire string `s` or string `t`. If we've reached the end of string `t`, it means we could possibly transform `s` into `t` by visiting/deleting some characters from `s`. In this case, we return `true`. If we haven't reached the end of string `t`, it means we couldn't transform `s` into `t`, and we return `false`. \n\nFor all languages, the implementation and logic are the same, only the syntax differs. For example, in Python, we use `len()` to find the length of a string, while in Java, we use the `.length()` method. Likewise, in JavaScript, we use the `.length` property of a string.\n    ",
        "c++": "\n    ```cpp\nbool canTransform(string s, string t) {\n    int i = 0, j = 0;\n    while (i < s.size() && j < t.size()) {\n        if (s[i] == t[j]) {\n            i++;\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return j == t.size();\n}\n```\n\n    \n    The algorithm used in all these implementations is the same. We use two pointers `i` and `j` to iterate through string `s` and `t`, respectively. We start at the beginning of each string and compare the characters at `i` and `j` indices. \n\nIf the characters are the same, we increment both `i` and `j`. If the characters are different, we increment only `i`, which effectively deletes the character at index `i` from string `s`. \n\nWe repeat this process until we have iterated through the entire string `s` or string `t`. If we've reached the end of string `t`, it means we could possibly transform `s` into `t` by visiting/deleting some characters from `s`. In this case, we return `true`. If we haven't reached the end of string `t`, it means we couldn't transform `s` into `t`, and we return `false`. \n\nFor all languages, the implementation and logic are the same, only the syntax differs. For example, in Python, we use `len()` to find the length of a string, while in Java, we use the `.length()` method. Likewise, in JavaScript, we use the `.length` property of a string.\n    ",
        "js": "\n    ```javascript\nfunction canTransform(s, t) {\n    let i = 0, j = 0;\n    while (i < s.length && j < t.length) {\n        if (s[i] === t[j]) {\n            i++;\n            j++;\n        } else {\n            i++;\n        }\n    }\n    return j === t.length;\n}\n```\n\n    \n    The algorithm used in all these implementations is the same. We use two pointers `i` and `j` to iterate through string `s` and `t`, respectively. We start at the beginning of each string and compare the characters at `i` and `j` indices. \n\nIf the characters are the same, we increment both `i` and `j`. If the characters are different, we increment only `i`, which effectively deletes the character at index `i` from string `s`. \n\nWe repeat this process until we have iterated through the entire string `s` or string `t`. If we've reached the end of string `t`, it means we could possibly transform `s` into `t` by visiting/deleting some characters from `s`. In this case, we return `true`. If we haven't reached the end of string `t`, it means we couldn't transform `s` into `t`, and we return `false`. \n\nFor all languages, the implementation and logic are the same, only the syntax differs. For example, in Python, we use `len()` to find the length of a string, while in Java, we use the `.length()` method. Likewise, in JavaScript, we use the `.length` property of a string.\n    "
    },
    {
        "id": 279,
        "title": "Minimum Operations to Make a Subsequence",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `target` that consists of **distinct** integers and another integer array `arr` that **can** have duplicates.\n\nIn one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.\n\nReturn _the **minimum** number of operations needed to make_ `target` _a **subsequence** of_ `arr`_._\n\nA **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = \\[5,1,3\\], `arr` = \\[9,4,2,3,4\\]\n**Output:** 2\n**Explanation:** You can add 5 and 1 in such a way that makes `arr` = \\[5,9,4,1,2,3,4\\], then target will be a subsequence of `arr`.\n\n",
                "**Example 2:**\n\n**Input:** target = \\[6,4,8,1,3,2\\], `arr` = \\[4,7,6,2,3,8,6,1\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target.length, arr.length <= 105`\n*   `1 <= target[i], arr[i] <= 109`\n*   `target` contains no duplicates.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Greedy"
        ],
        "example": [
            {
                "input": "[5,1,3],[9,4,2,3,4]",
                "output": "2"
            },
            {
                "input": "[6,4,8,1,3,2],[4,7,6,2,3,8,6,1]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minOperations(int[] target, int[] arr) {\n    Map<Integer, Integer> pos = new HashMap<>();\n    for (int i = 0; i < target.length; ++i) {\n        pos.put(target[i], i);\n    }\n\n    List<Integer> dp = new ArrayList<>();\n    for (int a : arr) {\n        if (pos.containsKey(a)) {\n            int idx = Collections.binarySearch(dp, pos.get(a));\n            if (idx < 0) {\n                idx = -(idx + 1);\n            }\n            if (idx == dp.size()) {\n                dp.add(pos.get(a));\n            } else {\n                dp.set(idx, pos.get(a));\n            }\n        }\n    }\n    return target.length - dp.size();\n}\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef minOperations(target, arr):\n    pos = {x: i for i, x in enumerate(target)}\n\n    dp = []\n    for a in arr:\n        if a in pos:\n            idx = bisect_left(dp, pos[a])\n            if idx == len(dp):\n                dp.append(pos[a])\n            else:\n                dp[idx] = pos[a]\n    return len(target) - len(dp)\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minOperations(vector<int>& target, vector<int>& arr) {\n    unordered_map<int, int> pos;\n    for (int i = 0; i < target.size(); ++i) {\n        pos[target[i]] = i;\n    }\n\n    vector<int> dp;\n    for (const int& a : arr) {\n        if (pos.find(a) != pos.end()) {\n            auto idx = lower_bound(dp.begin(), dp.end(), pos[a]);\n            if (idx == dp.end()) {\n                dp.push_back(pos[a]);\n            } else {\n                *idx = pos[a];\n            }\n        }\n    }\n    return target.size() - dp.size();\n}\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(target, arr) {\n    const pos = new Map();\n    for (let i = 0; i < target.length; ++i) {\n        pos.set(target[i], i);\n    }\n\n    const dp = [];\n    for (const a of arr) {\n        if (pos.has(a)) {\n            const idx = dp.findIndex(x => x >= pos.get(a));\n            if (idx === -1) {\n                dp.push(pos.get(a));\n            } else {\n                dp[idx] = pos.get(a);\n            }\n        }\n    }\n    return target.length - dp.length;\n}\n```\n    \n    The algorithm is based on finding the longest increasing subsequence in the modified `arr` array where only the indices of target numbers are considered. First, a hashmap `pos` is created to store the position of each target number. Then, iterate through the `arr` array and check if a number exists in the target. If it does, find the index of this number in the DP (Dynamic Programming) array using binary search or lower_bound. If the index is at the end of the DP array, append the position to the DP array; otherwise, update the DP array at the found index. Finally, return the difference between the target array's length and the DP array's length as the minimum number of operations needed to make the target a subsequence of `arr`.\n    "
    },
    {
        "id": 280,
        "title": "Number Of Ways To Reconstruct A Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:\n\n*   There are no duplicates.\n*   `xi < yi`\n\nLet `ways` be the number of rooted trees that satisfy the following conditions:\n\n*   The tree consists of nodes whose values appeared in `pairs`.\n*   A pair `[xi, yi]` exists in `pairs` **if and only if** `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.\n*   **Note:** the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has different parents in both ways.\n\nReturn:\n\n*   `0` if `ways == 0`\n*   `1` if `ways == 1`\n*   `2` if `ways > 1`\n\nA **rooted tree** is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\n\nAn **ancestor** of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.",
            "examples": [
                "**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:** There is exactly one valid rooted tree, which is shown in the above figure.\n\n",
                "**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[1,3\\]\\]\n**Output:** 2\n**Explanation:** There are multiple valid rooted trees. Three of them are shown in the above figures.\n\n",
                "**Example 3:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[1,5\\]\\]\n**Output:** 0\n**Explanation:** There are no valid rooted trees."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pairs.length <= 105`\n*   `1 <= xi < yi <= 500`\n*   The elements in `pairs` are unique.",
            "follow_up": null
        },
        "tag": [
            "Tree",
            "Graph"
        ],
        "example": [
            {
                "input": "[[1,2],[2,3]]",
                "output": "1"
            },
            {
                "input": "[[1,2],[2,3],[1,3]]",
                "output": "2"
            },
            {
                "input": "[[1,2],[2,3],[2,4],[1,5]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.List;\n\npublic int checkWays(List<List<Integer>> pairs) {\n    Map<Integer, Integer> candidates = new HashMap<>();\n    for (List<Integer> pair : pairs) {\n        candidates.put(pair.get(0),\n                candidates.getOrDefault(pair.get(0), 0) + 1);\n        candidates.put(pair.get(1),\n                candidates.getOrDefault(pair.get(1), 0) + 1);\n    }\n\n    int rootCount = 0;\n    for (int candidate : candidates.values()) {\n        if (candidate == 1) {\n            rootCount++;\n            if (rootCount > 1) {\n                return 2;\n            }\n        }\n    }\n\n    return rootCount;\n}\n```\n    \n    The algorithm uses a hash map to count the occurrences of each node in the `pairs` array. After counting the occurrences, it iterates through the hash map and counts how many nodes have only a single occurrence, which implies that they could be the root of a tree. If there is more than one node with a single occurrence, it means that there are multiple ways to create trees; therefore, the function returns 2. If there is only one node with a single occurrence, there is only one way to create a tree; hence, the function returns 1. If there are no nodes with a single occurrence, the function returns 0, since we cannot create a tree. All implementations follow this algorithm for each language.\n    ",
        "python": "\n    ```python\ndef check_ways(pairs):\n    candidates = {}\n    for x, y in pairs:\n        candidates[x] = candidates.get(x, 0) + 1\n        candidates[y] = candidates.get(y, 0) + 1\n\n    root_count = sum(1 for v in candidates.values() if v == 1)\n    return min(root_count, 2)\n```\n    \n    The algorithm uses a hash map to count the occurrences of each node in the `pairs` array. After counting the occurrences, it iterates through the hash map and counts how many nodes have only a single occurrence, which implies that they could be the root of a tree. If there is more than one node with a single occurrence, it means that there are multiple ways to create trees; therefore, the function returns 2. If there is only one node with a single occurrence, there is only one way to create a tree; hence, the function returns 1. If there are no nodes with a single occurrence, the function returns 0, since we cannot create a tree. All implementations follow this algorithm for each language.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint checkWays(std::vector<std::vector<int>>& pairs) {\n    std::unordered_map<int, int> candidates;\n    for (const auto& pair : pairs) {\n        ++candidates[pair[0]];\n        ++candidates[pair[1]];\n    }\n\n    int rootCount = 0;\n    for (const auto& candidate : candidates) {\n        if (candidate.second == 1) {\n            ++rootCount;\n            if (rootCount > 1) {\n                return 2;\n            }\n        }\n    }\n\n    return rootCount;\n}\n```\n    \n    The algorithm uses a hash map to count the occurrences of each node in the `pairs` array. After counting the occurrences, it iterates through the hash map and counts how many nodes have only a single occurrence, which implies that they could be the root of a tree. If there is more than one node with a single occurrence, it means that there are multiple ways to create trees; therefore, the function returns 2. If there is only one node with a single occurrence, there is only one way to create a tree; hence, the function returns 1. If there are no nodes with a single occurrence, the function returns 0, since we cannot create a tree. All implementations follow this algorithm for each language.\n    ",
        "js": "\n    ```javascript\nfunction checkWays(pairs) {\n    const candidates = {};\n    for (const [x, y] of pairs) {\n        candidates[x] = (candidates[x] || 0) + 1;\n        candidates[y] = (candidates[y] || 0) + 1;\n    }\n\n    let rootCount = 0;\n    for (const candidate in candidates) {\n        if (candidates[candidate] == 1) {\n            rootCount++;\n            if (rootCount > 1) {\n                return 2;\n            }\n        }\n    }\n\n    return rootCount;\n}\n```\n    \n    The algorithm uses a hash map to count the occurrences of each node in the `pairs` array. After counting the occurrences, it iterates through the hash map and counts how many nodes have only a single occurrence, which implies that they could be the root of a tree. If there is more than one node with a single occurrence, it means that there are multiple ways to create trees; therefore, the function returns 2. If there is only one node with a single occurrence, there is only one way to create a tree; hence, the function returns 1. If there are no nodes with a single occurrence, the function returns 0, since we cannot create a tree. All implementations follow this algorithm for each language.\n    "
    },
    {
        "id": 281,
        "title": "Find Minimum Time to Finish All Jobs",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._",
            "examples": [
                "**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n",
                "**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[3,2,3],3",
                "output": "3"
            },
            {
                "input": "[1,2,4,7,8],2",
                "output": "11"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int maxAchievableRequests(int n, ArrayList<ArrayList<Integer>> requests, int idx, ArrayList<Integer> counts) {\n    if (counts == null) {\n        counts = new ArrayList<Integer>(n);\n        for (int i = 0; i < n; i++) {\n            counts.add(0);\n        }\n    }\n    if (idx == requests.size()) {\n        for (int count : counts) {\n            if (count != 0) return 0;\n        }\n        return 0;\n    }\n    int ignored = maxAchievableRequests(n, requests, idx + 1, counts);\n    counts.set(requests.get(idx).get(0), counts.get(requests.get(idx).get(0)) + 1);\n    counts.set(requests.get(idx).get(1), counts.get(requests.get(idx).get(1)) - 1);\n\n    int accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);\n\n    return Math.max(ignored, accepted);\n}\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    ",
        "python": "\n    ```python\ndef max_achievable_requests(n, requests, idx=0, counts=None):\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint maxAchievableRequests(int n, std::vector<std::vector<int>>& requests, int idx = 0, std::vector<int> counts = {}) {\n    if (counts.empty()) {\n        counts.resize(n, 0);\n    }\n    if (idx == requests.size()) {\n        for (int count : counts) {\n            if (count != 0) return 0;\n        }\n        return 0;\n    }\n    int ignored = maxAchievableRequests(n, requests, idx + 1, counts);\n    counts[requests[idx][0]]++;\n    counts[requests[idx][1]]--;\n\n    int accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);\n\n    return std::max(ignored, accepted);\n}\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    ",
        "js": "\n    ```javascript\nfunction maxAchievableRequests(n, requests, idx = 0, counts = null) {\n    if (counts === null) {\n        counts = new Array(n).fill(0);\n    }\n    if (idx === requests.length) {\n        if (counts.every(count => count === 0)) return 0;\n        return 0;\n    }\n    let ignored = maxAchievableRequests(n, requests, idx + 1, [...counts]);\n    counts[requests[idx][0]]++;\n    counts[requests[idx][1]]--;\n\n    let accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);\n\n    return Math.max(ignored, accepted);\n}\n```\n    \n    The algorithm uses a helper recursive function `max_achievable_requests` that keeps track of four variables:\n- `n`: the number of buildings\n- `requests`: the list of employee transfer requests\n- `idx`: the index of the current request being processed (default is 0 for the start)\n- `counts`: a list that holds the net change in employee transfers for each building (initially empty or None/null)\n\nIt uses a base case when `idx` is equal to the length of the `request` list; it checks if all the counts are balanced (all values in the `counts` array are 0). If the counts are balanced, it means all requests have been checked and return 0 as the value of the maximum achievable requests.\n\nIf the index is not at the end of the requests list, two options are tried: ignore the request and process the next request in the list, and accept the request and process the next request in the list. For each try, it updates the counts based on the current request and chooses the maximum of the combinations tried.\n\nThe time complexity of this algorithm is O(2^n) as it uses a depth-first search approach. It is inefficient for large inputs, but in the context of the question, it should work well to find the maximum number of achievable requests.\n    "
    },
    {
        "id": 282,
        "title": "Cat and Mouse II",
        "difficulty": "Hard",
        "content": {
            "problem": "A game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n*   Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n*   Floors are represented by the character `'.'` and can be walked on.\n*   Walls are represented by the character `'#'` and cannot be walked on.\n*   Food is represented by the character `'F'` and can be walked on.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n*   Mouse **moves first**, then they take turns to move.\n*   During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n*   `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n*   Staying in the same position is allowed.\n*   Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n*   If Cat occupies the same position as Mouse, Cat wins.\n*   If Cat reaches the food first, Cat wins.\n*   If Mouse reaches the food first, Mouse wins.\n*   If Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` _if Mouse can win the game if both Cat and Mouse play optimally, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[ \"####F \", \"#C... \", \"M.... \"\\], catJump = 1, mouseJump = 2\n**Output:** true\n**Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 4\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `rows == grid.length`\n*   `cols = grid[i].length`\n*   `1 <= rows, cols <= 8`\n*   `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n*   `1 <= catJump, mouseJump <= 8`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Matrix",
            "Game Theory"
        ],
        "example": [
            {
                "input": "[\"####F\",\"#C...\",\"M....\"],1,2",
                "output": "true"
            },
            {
                "input": "[\"M.C...F\"],1,4",
                "output": "true"
            },
            {
                "input": "[\"M.C...F\"],1,3",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\n\nclass Fancy {\n    private ArrayList<Integer> sequence;\n\n    public Fancy() {\n        sequence = new ArrayList<>();\n    }\n\n    public void append(int val) {\n        sequence.add(val);\n    }\n\n    public void addAll(int inc) {\n        for (int i = 0; i < sequence.size(); i++) {\n            sequence.set(i, sequence.get(i) + inc);\n        }\n    }\n\n    public void multAll(int m) {\n        for (int i = 0; i < sequence.size(); i++) {\n            sequence.set(i, sequence.get(i) * m);\n        }\n    }\n\n    public int getIndex(int idx) {\n        if (idx >= sequence.size()) return -1;\n        return sequence.get(idx);\n    }\n}\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    ",
        "python": "\n    ```python\nclass Fancy:\n    def __init__(self):\n        self.sequence = []\n\n    def append(self, val):\n        self.sequence.append(val)\n\n    def addAll(self, inc):\n        self.sequence = [num + inc for num in self.sequence]\n\n    def multAll(self, m):\n        self.sequence = [num * m for num in self.sequence]\n\n    def getIndex(self, idx):\n        if idx >= len(self.sequence):\n            return -1\n        return self.sequence[idx]\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    ",
        "c++": "\n    ```cpp\nclass Fancy {\npublic:\n    Fancy() {}\n\n    void append(int val) {\n        sequence.push_back(val);\n    }\n\n    void addAll(int inc) {\n        for(auto& num : sequence) {\n            num += inc;\n        }\n    }\n\n    void multAll(int m) {\n        for(auto& num : sequence) {\n            num *= m;\n        }\n    }\n\n    int getIndex(int idx) {\n        if(idx >= sequence.size()) return -1;\n        return sequence[idx];\n    }\nprivate:\n    vector<int> sequence;\n};\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    ",
        "js": "\n    ```javascript\nclass Fancy {\n    constructor() {\n        this.sequence = [];\n    }\n\n    append(val) {\n        this.sequence.push(val);\n    }\n\n    addAll(inc) {\n        this.sequence = this.sequence.map(num => num + inc);\n    }\n\n    multAll(m) {\n        this.sequence = this.sequence.map(num => num * m);\n    }\n\n    getIndex(idx) {\n        if (idx >= this.sequence.length) return -1;\n        return this.sequence[idx];\n    }\n}\n```\n\n    \n    The Fancy class has a sequence that stores integers. The following methods are implemented:\n1. append(val) - Appends the given value to the sequence.\n2. addAll(inc) - Adds the given increment to all elements in the sequence.\n3. multAll(m) - Multiplies all elements in the sequence with the given multiplier.\n4. getIndex(idx) - Returns the element at the given index in the sequence or -1 if the index is out of bounds. \n\nEach coded implementation in C++, Java, Python, and JavaScript maintains a sequence and manipulates it based on the methods called. The implementation details are the same across these languages, and the basic concepts rely on the usage of arrays, iterating over elements, and modifying elements in the array based on the operations requested.\n    "
    },
    {
        "id": 283,
        "title": "Count Ways to Make Array With Product",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways **modulo** `109 + 7`.\n\nReturn _an integer array_ `answer` _where_ `answer.length == queries.length`_, and_ `answer[i]` _is the answer to the_ `ith` _query._",
            "examples": [
                "**Example 1:**\n\n**Input:** queries = \\[\\[2,6\\],\\[5,1\\],\\[73,660\\]\\]\n**Output:** \\[4,1,50734910\\]\n**Explanation:** Each query is independent.\n\\[2,6\\]: There are 4 ways to fill an array of size 2 that multiply to 6: \\[1,6\\], \\[2,3\\], \\[3,2\\], \\[6,1\\].\n\\[5,1\\]: There is 1 way to fill an array of size 5 that multiply to 1: \\[1,1,1,1,1\\].\n\\[73,660\\]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.\n\n",
                "**Example 2:**\n\n**Input:** queries = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\]\n**Output:** \\[1,2,3,10,5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= queries.length <= 104`\n*   `1 <= ni, ki <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Combinatorics",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[[2,6],[5,1],[73,660]]",
                "output": "[4,1,50734910]"
            },
            {
                "input": "[[1,1],[2,2],[3,3],[4,4],[5,5]]",
                "output": "[1,2,3,10,5]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    private static int mul(int a, int b) {\n        return (int)(((long) a * b) % MOD);\n    }\n\n    private static int powMod(int a, int b) {\n        int res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = mul(res, a);\n            }\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return res;\n    }\n\n    private static int ways(int n, int k, Map<String, Integer> mem) {\n        if (n == 1) return k;\n\n        String key = n + \",\" + k;\n        if (mem.containsKey(key)) {\n            return mem.get(key);\n        }\n\n        if (k == 1) {\n            mem.put(key, 1);\n            return 1;\n        }\n        if (n > k) {\n            mem.put(key, 0);\n            return 0;\n        }\n\n        int res = mul(ways(n, k - 1, mem), n);\n        res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD;\n\n        mem.put(key, res);\n        return res;\n    }\n\n    public int[] waysToFillArray(int[][] queries) {\n        Map<String, Integer> mem = new HashMap<>();\n        int[] ans = new int[queries.length];\n        \n        for (int i = 0; i < queries.length; i++) {\n            ans[i] = ways(queries[i][0], queries[i][1], mem);\n        }\n        \n        return ans;\n    }\n}\n```\n    \n    The approach to solving this problem involves dynamic programming with memoization. We will write a recursive function `ways(n, k, mem)` that returns the number of different ways the problem can be solved for integers n and k. The memoization is done using a 2-tuple (Python), a string concatenation (Java and JavaScript), and a hash map with the key being the product of n and a large number (C++) in the `mem` variable.\n\nWe take the following recursive cases:\n\n1. If n is 1, the only integer that satisfies the condition is k itself (since the product of only integer k is k). In this case, the number of ways is k.\n\n2. If there is already an entry in our memoization data structure for the tuple (or string/combination) `(n, k)`, we return the cached value since we already know the result of this subproblem.\n\n3. If k is 1, we would only have a product of 1 with all 1's in the array, so the number of ways is 1.\n\n4. If n > k, there are no ways to fill an array of size n with a product of k since we are counting only positive integers. In this case, the number of ways is 0.\n\nFor the recursive part, we take two subproblems:\n\n1. The number of ways if the current array element is 1: which is `ways(n-1, k, mem)` multiplied by `n`. The reasoning is that there are `n` elements to place a 1 in the array while we mutate the product of the remaining integers.\n\n2. The number of ways if the current array element is not 1, i.e., equal to k: which is `ways(n-1, k-1, mem)` multiplied by `(n-1)`. This comes from the fact that we have a product of k with (n-1) elements and each element can be chosen in (`n-1`) ways.\n\nWe then find the difference between these two values and return it.\n\nFinally, in the helper function, `waysToFillArray(queries)`, we simply iterate through the queries, and for each pair `(ni, ki)`, we call `ways(ni, ki, mem)` to find the number of ways and append it to the answer array which is then returned as the final result.\n    ",
        "python": "\n    ```python\nMOD = 10**9 + 7\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef ways(n, k, mem):\n    if n == 1:\n        return k\n    if (n_tuple := (n, k)) in mem:\n        return mem[n_tuple]\n    if k == 1:\n        mem[n_tuple] = 1\n        return 1\n    if n > k:\n        mem[n_tuple] = 0\n        return 0\n    res = mul(ways(n, k - 1, mem), n)\n    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD\n    mem[n_tuple] = res\n    return res\n\ndef waysToFillArray(queries):\n    mem = {}\n    ans = []\n    for q in queries:\n        ans.append(ways(q[0], q[1], mem))\n    return ans\n```\n    \n    The approach to solving this problem involves dynamic programming with memoization. We will write a recursive function `ways(n, k, mem)` that returns the number of different ways the problem can be solved for integers n and k. The memoization is done using a 2-tuple (Python), a string concatenation (Java and JavaScript), and a hash map with the key being the product of n and a large number (C++) in the `mem` variable.\n\nWe take the following recursive cases:\n\n1. If n is 1, the only integer that satisfies the condition is k itself (since the product of only integer k is k). In this case, the number of ways is k.\n\n2. If there is already an entry in our memoization data structure for the tuple (or string/combination) `(n, k)`, we return the cached value since we already know the result of this subproblem.\n\n3. If k is 1, we would only have a product of 1 with all 1's in the array, so the number of ways is 1.\n\n4. If n > k, there are no ways to fill an array of size n with a product of k since we are counting only positive integers. In this case, the number of ways is 0.\n\nFor the recursive part, we take two subproblems:\n\n1. The number of ways if the current array element is 1: which is `ways(n-1, k, mem)` multiplied by `n`. The reasoning is that there are `n` elements to place a 1 in the array while we mutate the product of the remaining integers.\n\n2. The number of ways if the current array element is not 1, i.e., equal to k: which is `ways(n-1, k-1, mem)` multiplied by `(n-1)`. This comes from the fact that we have a product of k with (n-1) elements and each element can be chosen in (`n-1`) ways.\n\nWe then find the difference between these two values and return it.\n\nFinally, in the helper function, `waysToFillArray(queries)`, we simply iterate through the queries, and for each pair `(ni, ki)`, we call `ways(ni, ki, mem)` to find the number of ways and append it to the answer array which is then returned as the final result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint powMod(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint ways(int n, int k, unordered_map<int, int>& mem) {\n    if (n == 1) return k;\n    int& res = mem[n * 50000 + k];\n    if (res) return res;\n\n    if (k == 1) {\n        return res = 1;\n    }\n    if (n > k) {\n        return res = 0;\n    }\n\n    res = mul(ways(n, k - 1, mem), n);\n    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD;\n\n    return res;\n}\n\nvector<int> waysToFillArray(vector<vector<int>>& queries) {\n    unordered_map<int, int> mem;\n    vector<int> ans;\n    for (auto& q : queries) {\n        ans.push_back(ways(q[0], q[1], mem));\n    }\n    return ans;\n}\n```\n    \n    The approach to solving this problem involves dynamic programming with memoization. We will write a recursive function `ways(n, k, mem)` that returns the number of different ways the problem can be solved for integers n and k. The memoization is done using a 2-tuple (Python), a string concatenation (Java and JavaScript), and a hash map with the key being the product of n and a large number (C++) in the `mem` variable.\n\nWe take the following recursive cases:\n\n1. If n is 1, the only integer that satisfies the condition is k itself (since the product of only integer k is k). In this case, the number of ways is k.\n\n2. If there is already an entry in our memoization data structure for the tuple (or string/combination) `(n, k)`, we return the cached value since we already know the result of this subproblem.\n\n3. If k is 1, we would only have a product of 1 with all 1's in the array, so the number of ways is 1.\n\n4. If n > k, there are no ways to fill an array of size n with a product of k since we are counting only positive integers. In this case, the number of ways is 0.\n\nFor the recursive part, we take two subproblems:\n\n1. The number of ways if the current array element is 1: which is `ways(n-1, k, mem)` multiplied by `n`. The reasoning is that there are `n` elements to place a 1 in the array while we mutate the product of the remaining integers.\n\n2. The number of ways if the current array element is not 1, i.e., equal to k: which is `ways(n-1, k-1, mem)` multiplied by `(n-1)`. This comes from the fact that we have a product of k with (n-1) elements and each element can be chosen in (`n-1`) ways.\n\nWe then find the difference between these two values and return it.\n\nFinally, in the helper function, `waysToFillArray(queries)`, we simply iterate through the queries, and for each pair `(ni, ki)`, we call `ways(ni, ki, mem)` to find the number of ways and append it to the answer array which is then returned as the final result.\n    ",
        "js": "\n    ```javascript\nconst MOD = 1e9 + 7;\n\nfunction mul(a, b) {\n  return (BigInt(a) * BigInt(b)) % MOD;\n}\n\nfunction ways(n, k, mem) {\n  if (n === 1) return k;\n  const key = n + ',' + k;\n  if (mem[key]) return mem[key];\n\n  if (k === 1) {\n    mem[key] = 1;\n    return 1;\n  }\n  if (n > k) {\n    mem[key] = 0;\n    return 0;\n  }\n\n  let res = mul(ways(n, k - 1, mem), n);\n  res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD;\n  \n  mem[key] = Number(res);\n  return mem[key];\n}\n\nfunction waysToFillArray(queries) {\n  const mem = {};\n  const ans = [];\n  for (let i = 0; i < queries.length; i++) {\n    ans.push(ways(queries[i][0], queries[i][1], mem));\n  }\n  return ans;\n}\n```\n    \n    The approach to solving this problem involves dynamic programming with memoization. We will write a recursive function `ways(n, k, mem)` that returns the number of different ways the problem can be solved for integers n and k. The memoization is done using a 2-tuple (Python), a string concatenation (Java and JavaScript), and a hash map with the key being the product of n and a large number (C++) in the `mem` variable.\n\nWe take the following recursive cases:\n\n1. If n is 1, the only integer that satisfies the condition is k itself (since the product of only integer k is k). In this case, the number of ways is k.\n\n2. If there is already an entry in our memoization data structure for the tuple (or string/combination) `(n, k)`, we return the cached value since we already know the result of this subproblem.\n\n3. If k is 1, we would only have a product of 1 with all 1's in the array, so the number of ways is 1.\n\n4. If n > k, there are no ways to fill an array of size n with a product of k since we are counting only positive integers. In this case, the number of ways is 0.\n\nFor the recursive part, we take two subproblems:\n\n1. The number of ways if the current array element is 1: which is `ways(n-1, k, mem)` multiplied by `n`. The reasoning is that there are `n` elements to place a 1 in the array while we mutate the product of the remaining integers.\n\n2. The number of ways if the current array element is not 1, i.e., equal to k: which is `ways(n-1, k-1, mem)` multiplied by `(n-1)`. This comes from the fact that we have a product of k with (n-1) elements and each element can be chosen in (`n-1`) ways.\n\nWe then find the difference between these two values and return it.\n\nFinally, in the helper function, `waysToFillArray(queries)`, we simply iterate through the queries, and for each pair `(ni, ki)`, we call `ways(ni, ki, mem)` to find the number of ways and append it to the answer array which is then returned as the final result.\n    "
    },
    {
        "id": 284,
        "title": "Building Boxes",
        "difficulty": "Hard",
        "content": {
            "problem": "You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:\n\n*   You can place the boxes anywhere on the floor.\n*   If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` **must** either be adjacent to another box or to a wall.\n\nGiven an integer `n`, return _the **minimum** possible number of boxes touching the floor._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** The figure above is for the placement of the three boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side.\n\n",
                "**Example 2:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** The figure above is for the placement of the four boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side.\n\n",
                "**Example 3:**\n\n**Input:** n = 10\n**Output:** 6\n**Explanation:** The figure above is for the placement of the ten boxes.\nThese boxes are placed in the corner of the room, where the corner is on the back side."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Binary Search",
            "Greedy"
        ],
        "example": [
            {
                "input": "3",
                "output": "3"
            },
            {
                "input": "4",
                "output": "3"
            },
            {
                "input": "10",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    public boolean checkPalindromeFormation(String a, String b) {\n        for (int i = 0, j = a.length() - 1; i < j; ++i, --j) {\n            if (a.charAt(i) != b.charAt(j))\n                return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n        }\n        return true;\n    }\n\n    private boolean isPalindrome(String s, int left, int right) {\n        while (left < right) {\n            if (s.charAt(left++) != s.charAt(right--)) return false;\n        }\n        return true;\n    }\n}\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    ",
        "python": "\n    ```python\ndef check_palindrome_formation(a: str, b: str) -> bool:\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    i, j = 0, len(a) - 1\n    while i < j:\n        if a[i] != b[j]:\n            return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n        i += 1\n        j -= 1\n    return True\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nbool checkPalindromeFormation(std::string a, std::string b) {\n    auto isPalindrome = [](const std::string& s, int left, int right) {\n        while (left < right) {\n            if (s[left++] != s[right--]) return false;\n        }\n        return true;\n    };\n\n    for (int i = 0, j = a.size() - 1; i < j; ++i, --j) {\n        if (a[i] != b[j]) return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n    }\n    return true;\n}\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    ",
        "js": "\n    ```javascript\nfunction checkPalindromeFormation(a, b) {\n    function isPalindrome(s, left, right) {\n        while (left < right) {\n            if (s.charAt(left++) !== s.charAt(right--)) return false;\n        }\n        return true;\n    }\n\n    for (let i = 0, j = a.length - 1; i < j; ++i, --j) {\n        if (a.charAt(i) !== b.charAt(j))\n            return isPalindrome(a, i, j) || isPalindrome(b, i, j);\n    }\n    return true;\n}\n```\n    \n    The algorithm works by iterating through the two strings a and b from both ends (i starts at 0, and j starts at the end). The loop condition is `i < j`, which means it will iterate approximately half of the string length.\n\nInside the loop, we check if `a[i]` is not equal to `b[j]`. If they are not equal, we split the string a and b at the current index i and check if they form a palindrome. The function `isPalindrome` is used to check if a string is a palindrome, which takes a string and two pointers (left and right). It iterates through the string from left to right and checks if the characters are equal. If they are not, the function returns false (not a palindrome), otherwise it continues till left >= right, and returns true (palindrome).\n\nTo check if the concatenated strings (aprefix + bsuffix or bprefix + asuffix) form a palindrome, we call the `isPalindrome` function with the required parameters. If either of the concatenated strings provide a palindrome, the function returns true.\n\nAfter the loop has ended, if no palindrome combination has been found, the function returns false. Otherwise, it returns true.\n    "
    },
    {
        "id": 285,
        "title": "Palindrome Partitioning IV",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, return `true` _if it is possible to split the string_ `s` _into three **non-empty** palindromic substrings. Otherwise, return_ `false`.​​​​​\n\nA string is said to be palindrome if it the same string when reversed.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcbdd \"\n**Output:** true\n**Explanation: ** \"abcbdd \" =  \"a \" +  \"bcb \" +  \"dd \", and all three substrings are palindromes.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"bcbddxy \"\n**Output:** false\n**Explanation:** s cannot be split into 3 palindromes."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= s.length <= 2000`\n*   `s`​​​​​​ consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"abcbdd\"",
                "output": "true\n**Explanation:**\"abcbdd\"=\"a\"+\"bcb\"+\"dd\",andallthreesubstringsarepalindromes."
            },
            {
                "input": "\"bcbddxy\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n\n    public boolean checkPartitioning(String s) {\n        int n = s.length();\n        for (int i = 0; i < n - 2; ++i) {\n            if (isPalindrome(s, 0, i)) {\n                for (int j = i + 1; j < n - 1; ++j) {\n                    if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n    \n    The algorithm creates a helper function `isPalindrome` to check if a given substring is a palindrome based on start and end indices. Then, in the main function `checkPartitioning`, it iterates through the string to find a possible split that gives three non-empty palindromic substrings. In the outer loop, it goes from 0 to `n - 3` and checks if the substring from 0 to `i` is palindrome. In the inner loop, it goes from `i + 1` to `n - 2` and checks if the substring from `i + 1` to `j` and from `j + 1` to `n-1` are both palindromes. If such a split is found, it returns true. If all possible splits are checked and no palindromic split is found, the function returns false.\n    ",
        "python": "\n    ```python\ndef is_palindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef check_partitioning(s):\n    n = len(s)\n    for i in range(0, n - 2):\n        if is_palindrome(s, 0, i):\n            for j in range(i + 1, n - 1):\n                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):\n                    return True\n    return False\n```\n    \n    The algorithm creates a helper function `isPalindrome` to check if a given substring is a palindrome based on start and end indices. Then, in the main function `checkPartitioning`, it iterates through the string to find a possible split that gives three non-empty palindromic substrings. In the outer loop, it goes from 0 to `n - 3` and checks if the substring from 0 to `i` is palindrome. In the inner loop, it goes from `i + 1` to `n - 2` and checks if the substring from `i + 1` to `j` and from `j + 1` to `n-1` are both palindromes. If such a split is found, it returns true. If all possible splits are checked and no palindromic split is found, the function returns false.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nbool isPalindrome(const string& s, int start, int end) {\n    while (start < end) {\n        if (s[start] != s[end]) return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nbool checkPartitioning(const string& s) {\n    int n = s.length();\n    for (int i = 0; i < n - 2; ++i) {\n        if (isPalindrome(s, 0, i)) {\n            for (int j = i + 1; j < n - 1; ++j) {\n                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) return true;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm creates a helper function `isPalindrome` to check if a given substring is a palindrome based on start and end indices. Then, in the main function `checkPartitioning`, it iterates through the string to find a possible split that gives three non-empty palindromic substrings. In the outer loop, it goes from 0 to `n - 3` and checks if the substring from 0 to `i` is palindrome. In the inner loop, it goes from `i + 1` to `n - 2` and checks if the substring from `i + 1` to `j` and from `j + 1` to `n-1` are both palindromes. If such a split is found, it returns true. If all possible splits are checked and no palindromic split is found, the function returns false.\n    ",
        "js": "\n    ```javascript\nfunction isPalindrome(s, start, end) {\n    while (start < end) {\n        if (s[start] !== s[end]) return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nfunction checkPartitioning(s) {\n    const n = s.length;\n    for (let i = 0; i < n - 2; ++i) {\n        if (isPalindrome(s, 0, i)) {\n            for (let j = i + 1; j < n - 1; ++j) {\n                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) return true;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm creates a helper function `isPalindrome` to check if a given substring is a palindrome based on start and end indices. Then, in the main function `checkPartitioning`, it iterates through the string to find a possible split that gives three non-empty palindromic substrings. In the outer loop, it goes from 0 to `n - 3` and checks if the substring from 0 to `i` is palindrome. In the inner loop, it goes from `i + 1` to `n - 2` and checks if the substring from `i + 1` to `j` and from `j + 1` to `n-1` are both palindromes. If such a split is found, it returns true. If all possible splits are checked and no palindromic split is found, the function returns false.\n    "
    },
    {
        "id": 286,
        "title": "Maximum Number of Events That Can Be Attended II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._",
            "examples": [
                "**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n",
                "**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n",
                "**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[1,2,4],[3,4,3],[2,3,1]],2",
                "output": "7"
            },
            {
                "input": "[[1,2,4],[3,4,3],[2,3,10]],2",
                "output": "10"
            },
            {
                "input": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]],3",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic char slowestKey(int[] releaseTimes, String keysPressed) {\n    char max_key = keysPressed.charAt(0);\n    int max_duration = releaseTimes[0];\n    for (int i = 1; i < releaseTimes.length; i++) {\n        int duration = releaseTimes[i] - releaseTimes[i - 1];\n        if (duration > max_duration || (duration == max_duration && keysPressed.charAt(i) > max_key)) {\n            max_key = keysPressed.charAt(i);\n            max_duration = duration;\n        }\n    }\n    return max_key;\n}\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    ",
        "python": "\n    ```python\ndef slowestKey(releaseTimes, keysPressed):\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\nusing namespace std;\n\nchar slowestKey(vector<int>& releaseTimes, string keysPressed) {\n    char max_key = keysPressed[0];\n    int max_duration = releaseTimes[0];\n    for (int i = 1; i < releaseTimes.size(); i++) {\n        int duration = releaseTimes[i] - releaseTimes[i - 1];\n        if (duration > max_duration || (duration == max_duration && keysPressed[i] > max_key)) {\n            max_key = keysPressed[i];\n            max_duration = duration;\n        }\n    }\n    return max_key;\n}\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    ",
        "js": "\n    ```javascript\nfunction slowestKey(releaseTimes, keysPressed) {\n    let max_key = keysPressed[0];\n    let max_duration = releaseTimes[0];\n\n    for (let i = 1; i < releaseTimes.length; i++) {\n        let duration = releaseTimes[i] - releaseTimes[i - 1];\n        if (duration > max_duration || (duration === max_duration && keysPressed[i] > max_key)) {\n            max_key = keysPressed[i];\n            max_duration = duration;\n        }\n    }\n    return max_key;\n}\n```\n\n    \n    The algorithm starts by initializing the max_key to the first key in keysPressed and max_duration to the duration of the first key press. Then, from the second key press to the last, it calculates the duration of each key press by subtracting the previous release time from the current release time. It compares the current duration with the max_duration. If the current duration is larger than max_duration or if the durations are equal and the current key is lexicographically larger than the max_key, update max_key and max_duration. Finally, return max_key as the result.\n    "
    },
    {
        "id": 287,
        "title": "Closest Subsequence Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `goal`.\n\nYou want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to **minimize the absolute difference** `abs(sum - goal)`.\n\nReturn _the **minimum** possible value of_ `abs(sum - goal)`.\n\nNote that a subsequence of an array is an array formed by removing some elements **(possibly all or none)** of the original array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,-7,3,5\\], goal = 6\n**Output:** 0\n**Explanation:** Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,-9,15,-2\\], goal = -5\n**Output:** 1\n**Explanation:** Choose the subsequence \\[7,-9,-2\\], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\], goal = -7\n**Output:** 7"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 40`\n*   `-107 <= nums[i] <= 107`\n*   `-109 <= goal <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[5,-7,3,5],6",
                "output": "0"
            },
            {
                "input": "[7,-9,15,-2],-5",
                "output": "1"
            },
            {
                "input": "[1,2,3],-7",
                "output": "7"
            }
        ],
        "java": "\n    ```java\npublic int[] decrypt(int[] code, int k) {\n    int n = code.length;\n    int[] result = new int[n];\n    if (k == 0) return result;\n    \n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 1; j <= Math.abs(k); j++) {\n            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    ",
        "python": "\n    ```python\ndef decrypt(code, k):\n    n = len(code)\n    result = [0] * n\n    if k == 0: return result\n    \n    for i in range(n):\n        sum = 0\n        for j in range(1, abs(k) + 1):\n            sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n]\n        result[i] = sum\n    return result\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> decrypt(vector<int>& code, int k) {\n    int n = code.size();\n    vector<int> result(n);\n    if (k == 0) return vector<int>(n, 0);\n    \n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 1; j <= abs(k); j++) {\n            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    ",
        "js": "\n    ```javascript\nfunction decrypt(code, k) {\n    const n = code.length;\n    const result = new Array(n).fill(0);\n    if (k === 0) return result;\n    \n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = 1; j <= Math.abs(k); j++) {\n            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];\n        }\n        result[i] = sum;\n    }\n    return result;\n}\n```\n    \n    The given problem requires iterating through each element of the circular array code and, depending on the value of key k, summing up either the k next or k previous elements, and storing the sums into a new array called result. The new array represents the decrypted code.\n1. Create an array called 'result' of the same length as code and initialized with zeros in all fields. If k equals to 0, return the result immediately as all elements are already 0.\n2. Iterate through each element in code (use variable i as index). For each element, let sum be zero.\n3. Nested loop: iterate starting from j = 1 to abs(k), where abs() represents the absolute value. Add code elements to sum depending on k value:\n   - If k is greater than 0, add code[(i + j) % n].\n   - If k is less than 0, add code[(i - j + n) % n].\n4. Store sum in result array at index i.\n5. After iterating through all code elements, return the result array.\n    "
    },
    {
        "id": 288,
        "title": "Minimum Degree of a Connected Trio in a Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.\n\nA **connected trio** is a set of **three** nodes where there is an edge between **every** pair of them.\n\nThe **degree of a connected trio** is the number of edges where one endpoint is in the trio, and the other is not.\n\nReturn _the **minimum** degree of a connected trio in the graph, or_ `-1` _if the graph has no connected trios._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[1,2\\],\\[1,3\\],\\[3,2\\],\\[4,1\\],\\[5,2\\],\\[3,6\\]\\]\n**Output:** 3\n**Explanation:** There is exactly one trio, which is \\[1,2,3\\]. The edges that form its degree are bolded in the figure above.\n\n",
                "**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3\\],\\[4,1\\],\\[4,3\\],\\[2,5\\],\\[5,6\\],\\[6,7\\],\\[7,5\\],\\[2,6\\]\\]\n**Output:** 0\n**Explanation:** There are exactly three trios:\n1) \\[1,4,3\\] with degree 0.\n2) \\[2,5,6\\] with degree 2.\n3) \\[5,6,7\\] with degree 2."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 400`\n*   `edges[i].length == 2`\n*   `1 <= edges.length <= n * (n-1) / 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no repeated edges.",
            "follow_up": null
        },
        "tag": [
            "Graph"
        ],
        "example": [
            {
                "input": "6,[[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]",
                "output": "3"
            },
            {
                "input": "7,[[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countVowelStrings(int n) {\n    int[] dp = {1, 1, 1, 1, 1};\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 3; j >= 0; j--) {\n            dp[j] += dp[j + 1];\n        }\n    }\n\n    return dp[0] + dp[1] + dp[2] + dp[3] + dp[4];\n}\n```\n    \n    We use dynamic programming to efficiently count the number of valid strings. Here, we maintain an array `dp` with 5 elements, each representing the count of strings ending with each vowel (a, e, i, o, u). \n\nWe loop through `1` to `n`, and for each step, we iterate through the `dp` array from the end to the beginning (from 'u' to 'a'). We update the count of strings ending in the current vowel by adding the number of strings ending in the next vowel. This ensures that the strings are lexicographically sorted. Finally, we return the sum of all elements in the `dp` array.\n    ",
        "python": "\n    ```python\ndef count_vowel_strings(n):\n    dp = [1, 1, 1, 1, 1]\n\n    for i in range(1, n):\n        for j in range(3, -1, -1):\n            dp[j] += dp[j + 1]\n\n    return sum(dp)\n```\n    \n    We use dynamic programming to efficiently count the number of valid strings. Here, we maintain an array `dp` with 5 elements, each representing the count of strings ending with each vowel (a, e, i, o, u). \n\nWe loop through `1` to `n`, and for each step, we iterate through the `dp` array from the end to the beginning (from 'u' to 'a'). We update the count of strings ending in the current vowel by adding the number of strings ending in the next vowel. This ensures that the strings are lexicographically sorted. Finally, we return the sum of all elements in the `dp` array.\n    ",
        "c++": "\n    ```cpp\nint countVowelStrings(int n) {\n    int dp[5] = {1, 1, 1, 1, 1};\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 3; j >= 0; j--) {\n            dp[j] += dp[j + 1];\n        }\n    }\n\n    return dp[0] + dp[1] + dp[2] + dp[3] + dp[4];\n}\n```\n    \n    We use dynamic programming to efficiently count the number of valid strings. Here, we maintain an array `dp` with 5 elements, each representing the count of strings ending with each vowel (a, e, i, o, u). \n\nWe loop through `1` to `n`, and for each step, we iterate through the `dp` array from the end to the beginning (from 'u' to 'a'). We update the count of strings ending in the current vowel by adding the number of strings ending in the next vowel. This ensures that the strings are lexicographically sorted. Finally, we return the sum of all elements in the `dp` array.\n    ",
        "js": "\n    ```javascript\nfunction countVowelStrings(n) {\n    const dp = [1, 1, 1, 1, 1];\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 3; j >= 0; j--) {\n            dp[j] += dp[j + 1];\n        }\n    }\n\n    return dp.reduce((a, b) => a + b, 0);\n}\n```\n    \n    We use dynamic programming to efficiently count the number of valid strings. Here, we maintain an array `dp` with 5 elements, each representing the count of strings ending with each vowel (a, e, i, o, u). \n\nWe loop through `1` to `n`, and for each step, we iterate through the `dp` array from the end to the beginning (from 'u' to 'a'). We update the count of strings ending in the current vowel by adding the number of strings ending in the next vowel. This ensures that the strings are lexicographically sorted. Finally, we return the sum of all elements in the `dp` array.\n    "
    },
    {
        "id": 289,
        "title": "Tree of Coprimes",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges. Each node has a value associated with it, and the **root** of the tree is node `0`.\n\nTo represent this tree, you are given an integer array `nums` and a 2D array `edges`. Each `nums[i]` represents the `ith` node's value, and each `edges[j] = [uj, vj]` represents an edge between nodes `uj` and `vj` in the tree.\n\nTwo values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the **greatest common divisor** of `x` and `y`.\n\nAn ancestor of a node `i` is any other node on the shortest path from node `i` to the **root**. A node is **not** considered an ancestor of itself.\n\nReturn _an array_ `ans` _of size_ `n`, _where_ `ans[i]` _is the closest ancestor to node_ `i` _such that_ `nums[i]` _and_ `nums[ans[i]]` are **coprime**, or `-1` _if there is no such ancestor_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,3,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[-1,0,0,1\\]\n**Explanation:** In the above figure, each node's value is in parentheses.\n- Node 0 has no coprime ancestors.\n- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n  closest valid ancestor.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,6,10,2,3,6,15\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[2,6\\]\\]\n**Output:** \\[-1,0,-1,0,0,0,-1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[j].length == 2`\n*   `0 <= uj, vj < n`\n*   `uj != vj`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Tree",
            "Depth-First Search",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[2,3,3,2],[[0,1],[1,2],[1,3]]",
                "output": "[-1,0,0,1]"
            },
            {
                "input": "[5,6,10,2,3,6,15],[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]",
                "output": "[-1,0,-1,0,0,0,-1]"
            }
        ],
        "java": "\n    ```java\npublic int minimumMountainRemovals(int[] nums) {\n    int n = nums.length;\n    int[] left = new int[n], right = new int[n];\n    for (int i = 0; i < n; ++i) {\n        left[i] = lowerBound(Arrays.copyOfRange(left, 0, i), nums[i]);\n        right[n - 1 - i] = lowerBound(reverse(Arrays.copyOfRange(right, n - 1 - i, n)), nums[n - 1 - i]);\n    }\n    int result = n;\n    for (int i = 1; i < n - 1; ++i)\n        result = Math.min(result, n - (left[i] + 1) - (right[i] + 1));\n\n    return result;\n}\n```\n    \n    1. Initialize two arrays `left` and `right` of the same size as the input array `nums`. These arrays will store the length of the increasing subarray at each index for the left and right side respectively.\n2. Iterate through the input array from left to right, putting the longest increasing subarray length for the left side at index `i` in the `left` array using binary search.\n3. Similarly, iterate through the input array from right to left, putting the longest increasing subarray length for the right side at index `i` in the `right` array.\n4. Initialize a variable `result` to store the minimum number of elements to remove. Assign the value of the length of the input array to it.\n5. Iterate through the input array, skipping the first and last elements, and update `result` as the minimum of the current value and the difference between the length of the input array and the sum of the longest subarrays for the left and right sides plus 1.\n6. Return the `result` variable.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef minimum_mountain_removals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(n):\n        left[i] = bisect_left(left[:i], nums[i])\n        right[n - 1 - i] = bisect_left(right[n - i:], nums[n - 1 - i])\n\n    return n - max(left[i] + right[i] for i in range(1, n - 1)) - 1\n```\n    \n    1. Initialize two arrays `left` and `right` of the same size as the input array `nums`. These arrays will store the length of the increasing subarray at each index for the left and right side respectively.\n2. Iterate through the input array from left to right, putting the longest increasing subarray length for the left side at index `i` in the `left` array using binary search.\n3. Similarly, iterate through the input array from right to left, putting the longest increasing subarray length for the right side at index `i` in the `right` array.\n4. Initialize a variable `result` to store the minimum number of elements to remove. Assign the value of the length of the input array to it.\n5. Iterate through the input array, skipping the first and last elements, and update `result` as the minimum of the current value and the difference between the length of the input array and the sum of the longest subarrays for the left and right sides plus 1.\n6. Return the `result` variable.\n    ",
        "c++": "\n    ```cpp\nint minimumMountainRemovals(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> left(n), right(n);\n    for (int i = 0; i < n; ++i) {\n        left[i] = lower_bound(left.begin(), left.begin() + i, nums[i]) - left.begin();\n        right[n - 1 - i] = lower_bound(right.rbegin(), right.rend() - i, nums[n - 1 - i]) - right.rbegin();\n    }\n    int result = n;\n    for (int i = 1; i < n - 1; ++i)\n        result = min(result, n - (left[i] + 1) - (right[i] + 1));\n\n    return result;\n}\n```\n    \n    1. Initialize two arrays `left` and `right` of the same size as the input array `nums`. These arrays will store the length of the increasing subarray at each index for the left and right side respectively.\n2. Iterate through the input array from left to right, putting the longest increasing subarray length for the left side at index `i` in the `left` array using binary search.\n3. Similarly, iterate through the input array from right to left, putting the longest increasing subarray length for the right side at index `i` in the `right` array.\n4. Initialize a variable `result` to store the minimum number of elements to remove. Assign the value of the length of the input array to it.\n5. Iterate through the input array, skipping the first and last elements, and update `result` as the minimum of the current value and the difference between the length of the input array and the sum of the longest subarrays for the left and right sides plus 1.\n6. Return the `result` variable.\n    ",
        "js": "\n    ```javascript\nfunction minimumMountainRemovals(nums) {\n    const n = nums.length;\n    const left = new Array(n), right = new Array(n);\n    for (let i = 0; i < n; ++i) {\n        left[i] = lowerBound(left.slice(0, i), nums[i]);\n        right[n - 1 - i] = lowerBound(right.slice(n - 1 - i, n).reverse(), nums[n - 1 - i]);\n    }\n    let result = n;\n    for (let i = 1; i < n - 1; ++i)\n        result = Math.min(result, n - (left[i] + 1) - (right[i] + 1));\n\n    return result;\n}\n```\n    \n    1. Initialize two arrays `left` and `right` of the same size as the input array `nums`. These arrays will store the length of the increasing subarray at each index for the left and right side respectively.\n2. Iterate through the input array from left to right, putting the longest increasing subarray length for the left side at index `i` in the `left` array using binary search.\n3. Similarly, iterate through the input array from right to left, putting the longest increasing subarray length for the right side at index `i` in the `right` array.\n4. Initialize a variable `result` to store the minimum number of elements to remove. Assign the value of the length of the input array to it.\n5. Iterate through the input array, skipping the first and last elements, and update `result` as the minimum of the current value and the difference between the length of the input array and the sum of the longest subarrays for the left and right sides plus 1.\n6. Return the `result` variable.\n    "
    },
    {
        "id": 290,
        "title": "Maximum Score from Performing Multiplication Operations",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `nums` and `multipliers` of size `n` and `m` respectively, where `n >= m`.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will:\n\n*   Choose one integer `x` from **either the start or the end** of the array `nums`.\n*   Add `multipliers[i] * x` to your score.\n    *   Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on.\n*   Remove `x` from `nums`.\n\nReturn _the **maximum** score after performing_ `m` _operations._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], multipliers = \\[3,2,1\\]\n**Output:** 14\n**Explanation:** An optimal solution is as follows:\n- Choose from the end, \\[1,2,**3**\\], adding 3 \\* 3 = 9 to the score.\n- Choose from the end, \\[1,**2**\\], adding 2 \\* 2 = 4 to the score.\n- Choose from the end, \\[**1**\\], adding 1 \\* 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-5,-3,-3,-2,7,1\\], multipliers = \\[-10,-5,3,4,6\\]\n**Output:** 102\n**Explanation:** An optimal solution is as follows:\n- Choose from the start, \\[**\\-5**,-3,-3,-2,7,1\\], adding -5 \\* -10 = 50 to the score.\n- Choose from the start, \\[**\\-3**,-3,-2,7,1\\], adding -3 \\* -5 = 15 to the score.\n- Choose from the start, \\[**\\-3**,-2,7,1\\], adding -3 \\* 3 = -9 to the score.\n- Choose from the end, \\[-2,7,**1**\\], adding 1 \\* 4 = 4 to the score.\n- Choose from the end, \\[-2,**7**\\], adding 7 \\* 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `m == multipliers.length`\n*   `1 <= m <= 300`\n*   `m <= n <= 105`\n*   `-1000 <= nums[i], multipliers[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,2,3],[3,2,1]",
                "output": "14"
            },
            {
                "input": "[-5,-3,-3,-2,7,1],[-10,-5,3,4,6]",
                "output": "102"
            }
        ],
        "java": "\n    ```java\npublic int minDeletions(String s) {\n    int[] freq = new int[26];\n    HashSet<Integer> used = new HashSet<>();\n    int deletions = 0;\n\n    for (char c : s.toCharArray()) {\n        freq[c - 'a']++;\n    }\n\n    for (int count : freq) {\n        while (used.contains(count) && count > 0) {\n            deletions++;\n            count--;\n        }\n        used.add(count);\n    }\n\n    return deletions;\n}\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    ",
        "python": "\n    ```python\ndef min_deletions(s):\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    ",
        "c++": "\n    ```cpp\nint minDeletions(string s) {\n    unordered_map<char, int> freq;\n    unordered_set<int> used;\n    int deletions = 0;\n\n    for (char c : s) {\n        freq[c]++;\n    }\n\n    for (auto const& [char, count] : freq) {\n        while (used.find(count) != used.end() && count > 0) {\n            deletions++;\n            count--;\n        }\n        used.insert(count);\n    }\n\n    return deletions;\n}\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    ",
        "js": "\n    ```javascript\nfunction minDeletions(s) {\n    const freq = {};\n    const used = new Set();\n    let deletions = 0;\n\n    for (const c of s) {\n        freq[c] = (freq[c] || 0) + 1;\n    }\n\n    for (const count in freq) {\n        let num = freq[count];\n        while (used.has(num) && num > 0) {\n            deletions++;\n            num--;\n        }\n        used.add(num);\n    }\n\n    return deletions;\n}\n```\n    \n    1. Count the frequency of each character in the string.\n2. Create a set to store the unique frequencies that have been used.\n3. Initialize a deletion counter to 0.\n4. Iterate through the frequency counts of each character.\n5. For each count, check if it is already in the used set. If it is and the count is greater than 0, increment the deletion counter, and decrement the count.\n6. After adjusting the count, add the count to the used set.\n7. Return the deletion counter after iterating through all character frequencies.\n    "
    },
    {
        "id": 291,
        "title": "Maximize Palindrome Length From Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:\n\n*   Choose some **non-empty** subsequence `subsequence1` from `word1`.\n*   Choose some **non-empty** subsequence `subsequence2` from `word2`.\n*   Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.\n\nReturn _the **length** of the longest **palindrome** that can be constructed in the described manner._ If no palindromes can be constructed, return `0`.\n\nA **subsequence** of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.\n\nA **palindrome** is a string that reads the same forward as well as backward.",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"cacb \", word2 =  \"cbba \"\n**Output:** 5\n**Explanation:** Choose  \"ab \" from word1 and  \"cba \" from word2 to make  \"abcba \", which is a palindrome.\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"ab \", word2 =  \"ab \"\n**Output:** 3\n**Explanation:** Choose  \"ab \" from word1 and  \"a \" from word2 to make  \"aba \", which is a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** word1 =  \"aa \", word2 =  \"bb \"\n**Output:** 0\n**Explanation:** You cannot construct a palindrome from the described method, so return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 1000`\n*   `word1` and `word2` consist of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"cacb\",\"cbba\"",
                "output": "5"
            },
            {
                "input": "\"ab\",\"ab\"",
                "output": "3"
            },
            {
                "input": "\"aa\",\"bb\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxProfit(int[] inventory, int orders) {\n    long mod = 1000000007;\n    Integer[] inv = Arrays.stream(inventory).boxed().toArray(Integer[]::new);\n    Arrays.sort(inv, Collections.reverseOrder());\n    List<Integer> invList = new ArrayList<>(Arrays.asList(inv));\n    invList.add(0);\n    int n = invList.size();\n    long ans = 0, count = 1;\n    for (int i = 0; i < n - 1; ++i, ++count) {\n        long diff = invList.get(i) - invList.get(i + 1);\n        if (count * diff < orders) {\n            orders -= count * diff;\n            ans = (ans + (((invList.get(i) + invList.get(i + 1) + 1) * diff) / 2) % mod * count) % mod;\n        } else {\n            long q = orders / count;\n            long r = orders % count;\n            ans = (ans + (((invList.get(i) + invList.get(i) - q + 1) * q) / 2) % mod * count) % mod;\n            ans = (ans + r * (invList.get(i) - q)) % mod;\n            break;\n        }\n    }\n    return (int)ans;\n}\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    ",
        "python": "\n    ```python\ndef maxProfit(inventory, orders):\n    mod = 10**9 + 7\n    inventory.sort(reverse=True)\n    inventory.append(0)\n    n, ans, count = len(inventory), 0, 1\n    for i in range(n - 1):\n        diff = inventory[i] - inventory[i + 1]\n        if count * diff < orders:\n            orders -= count * diff\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod\n        else:\n            q, r = divmod(orders, count)\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod\n            ans = (ans + r * (inventory[i] - q)) % mod\n            break\n        count += 1\n    return ans\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxProfit(std::vector<int>& inventory, int orders) {\n    long long mod = 1e9 + 7;\n    std::sort(inventory.begin(), inventory.end(), std::greater<>());\n    inventory.push_back(0);\n    long long n = inventory.size(), ans = 0, count = 1;\n    for (int i = 0; i < n - 1; ++i, ++count) {\n        long long diff = inventory[i] - inventory[i + 1];\n        if (count * diff < orders) {\n            orders -= count * diff;\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) / 2) % mod * count) % mod;\n        } else {\n            long long q = orders / count;\n            long long r = orders % count;\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) / 2) % mod * count) % mod;\n            ans = (ans + r * (inventory[i] - q)) % mod;\n            break;\n        }\n    }\n    return ans;\n}\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction maxProfit(inventory, orders) {\n    const mod = 1e9 + 7;\n    inventory.sort((a, b) => b - a).push(0);\n    let n = inventory.length, ans = 0n, count = 1n;\n    for (let i = 0; i < n - 1; ++i, ++count) {\n        const diff = BigInt(inventory[i] - inventory[i + 1]);\n        if (count * diff < orders) {\n            orders -= count * diff;\n            ans = (ans + (((BigInt(inventory[i]) + BigInt(inventory[i + 1]) + 1n) * diff) / 2n) % mod * count) % mod;\n        } else {\n            const q = BigInt(orders / count);\n            const r = BigInt(orders % count);\n            ans = (ans + (((BigInt(inventory[i]) + BigInt(inventory[i]) - q + 1n) * q) / 2n) % mod * count) % mod;\n            ans = (ans + r * (BigInt(inventory[i]) - q)) % mod;\n            break;\n        }\n    }\n    return parseInt(ans);\n}\n```\n    \n    1. Sort the inventory array in decreasing order and append 0 to the end.\n2. Initialize a variable `count` to 1. This variable represents the number of balls that have the same value.\n3. Iterate through the inventory.\n    - Calculate the difference between the current element and the next element.\n    - If `count * diff` is smaller than the remaining `orders`, update `orders` and the `ans` appropriately. Increment the `count` variable.\n    - If `count * diff` is greater than or equal to `orders`, calculate the multiples and remainders of the orders in the current batch. Update the answer and break the loop.\n4. Return the calculated answer mod 1e9 + 7.\n    "
    },
    {
        "id": 292,
        "title": "Car Fleet II",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:\n\n*   `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.\n*   `speedi` is the initial speed of the `ith` car in meters per second.\n\nFor simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the **slowest** car in the fleet.\n\nReturn an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** cars = \\[\\[1,2\\],\\[2,1\\],\\[4,3\\],\\[7,2\\]\\]\n**Output:** \\[1.00000,-1.00000,3.00000,-1.00000\\]\n**Explanation:** After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n\n",
                "**Example 2:**\n\n**Input:** cars = \\[\\[3,4\\],\\[5,4\\],\\[6,3\\],\\[9,1\\]\\]\n**Output:** \\[2.00000,1.00000,1.50000,-1.00000\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= cars.length <= 105`\n*   `1 <= positioni, speedi <= 106`\n*   `positioni < positioni+1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Stack",
            "Heap (Priority Queue)",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[[1,2],[2,1],[4,3],[7,2]]",
                "output": "[1.00000,-1.00000,3.00000,-1.00000]"
            },
            {
                "input": "[[3,4],[5,4],[6,3],[9,1]]",
                "output": "[2.00000,1.00000,1.50000,-1.00000]"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums, int x) {\n    int total = 0;\n    for (int num : nums) total += num;\n    int target = total - x;\n    if (target < 0) return -1;\n\n    int maxLength = -1;\n    int left = 0, sum = 0;\n    for (int right = 0; right < nums.length; ++right) {\n        sum += nums[right];\n\n        while (sum > target) {\n            sum -= nums[left++];\n        }\n\n        if (sum == target) {\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n    }\n\n    return maxLength == -1 ? -1 : nums.length - maxLength;\n}\n```\n\n    \n    The algorithm works by first calculating the total sum of the array and finding the target sum we need to achieve by subtracting x from the total sum. If the target sum is less than 0, return -1 since it's not possible to reduce x to 0.\n\nNext, initialize two pointers (left and right) to 0 and the sum variable to 0. Iterate through the array nums with the right pointer, updating the sum by adding the current element in the nums array.\n\nInside the loop, keep updating the left pointer by removing the leftmost element of the subarray and subtracting its value from the sum until the sum is less than or equal to target.\n\nIf the sum is equal to the target, update maxLength to the maximum value between maxLength and the difference between right and left pointers. \n\nOnce the whole nums array has been processed, return -1 when maxLength remains -1 or the difference between the size of nums and maxLength as a result.\n\nThe algorithm has a time complexity of O(n), where n is the size of the nums array.\n    ",
        "python": "\n    ```python\ndef minOperations(nums, x):\n    total = sum(nums)\n    target = total - x\n    if target < 0:\n        return -1\n\n    maxLength = -1\n    left = 0\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n\n        if current_sum == target:\n            maxLength = max(maxLength, right - left + 1)\n\n    return -1 if maxLength == -1 else len(nums) - maxLength\n```\n\n    \n    The algorithm works by first calculating the total sum of the array and finding the target sum we need to achieve by subtracting x from the total sum. If the target sum is less than 0, return -1 since it's not possible to reduce x to 0.\n\nNext, initialize two pointers (left and right) to 0 and the sum variable to 0. Iterate through the array nums with the right pointer, updating the sum by adding the current element in the nums array.\n\nInside the loop, keep updating the left pointer by removing the leftmost element of the subarray and subtracting its value from the sum until the sum is less than or equal to target.\n\nIf the sum is equal to the target, update maxLength to the maximum value between maxLength and the difference between right and left pointers. \n\nOnce the whole nums array has been processed, return -1 when maxLength remains -1 or the difference between the size of nums and maxLength as a result.\n\nThe algorithm has a time complexity of O(n), where n is the size of the nums array.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums, int x) {\n    int total = accumulate(nums.begin(), nums.end(), 0);\n    int target = total - x;\n    if (target < 0) return -1;\n\n    int maxLength = -1;\n    int left = 0, sum = 0;\n    for (int right = 0; right < nums.size(); ++right) {\n      sum += nums[right];\n\n      while (sum > target) {\n        sum -= nums[left++];\n      }\n\n      if (sum == target) {\n        maxLength = max(maxLength, right - left + 1);\n      }\n    }\n\n    return maxLength == -1 ? -1 : nums.size() - maxLength;\n}\n```\n\n    \n    The algorithm works by first calculating the total sum of the array and finding the target sum we need to achieve by subtracting x from the total sum. If the target sum is less than 0, return -1 since it's not possible to reduce x to 0.\n\nNext, initialize two pointers (left and right) to 0 and the sum variable to 0. Iterate through the array nums with the right pointer, updating the sum by adding the current element in the nums array.\n\nInside the loop, keep updating the left pointer by removing the leftmost element of the subarray and subtracting its value from the sum until the sum is less than or equal to target.\n\nIf the sum is equal to the target, update maxLength to the maximum value between maxLength and the difference between right and left pointers. \n\nOnce the whole nums array has been processed, return -1 when maxLength remains -1 or the difference between the size of nums and maxLength as a result.\n\nThe algorithm has a time complexity of O(n), where n is the size of the nums array.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums, x) {\n    const total = nums.reduce((accumulator, currentValue) => accumulator + currentValue);\n    const target = total - x;\n    if (target < 0) return -1;\n\n    let maxLength = -1;\n    let left = 0, sum = 0;\n\n    for (let right = 0; right < nums.length; ++right) {\n        sum += nums[right];\n\n        while (sum > target) {\n            sum -= nums[left++];\n        }\n\n        if (sum == target) {\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n    }\n\n    return maxLength == -1 ? -1 : nums.length - maxLength;\n}\n```\n\n    \n    The algorithm works by first calculating the total sum of the array and finding the target sum we need to achieve by subtracting x from the total sum. If the target sum is less than 0, return -1 since it's not possible to reduce x to 0.\n\nNext, initialize two pointers (left and right) to 0 and the sum variable to 0. Iterate through the array nums with the right pointer, updating the sum by adding the current element in the nums array.\n\nInside the loop, keep updating the left pointer by removing the leftmost element of the subarray and subtracting its value from the sum until the sum is less than or equal to target.\n\nIf the sum is equal to the target, update maxLength to the maximum value between maxLength and the difference between right and left pointers. \n\nOnce the whole nums array has been processed, return -1 when maxLength remains -1 or the difference between the size of nums and maxLength as a result.\n\nThe algorithm has a time complexity of O(n), where n is the size of the nums array.\n    "
    },
    {
        "id": 293,
        "title": "Count Pairs Of Nodes",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an undirected graph defined by an integer `n`, the number of nodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i] = [ui, vi]` indicates that there is an **undirected** edge between `ui` and `vi`. You are also given an integer array `queries`.\n\nLet `incident(a, b)` be defined as the **number of edges** that are connected to **either** node `a` or `b`.\n\nThe answer to the `jth` query is the **number of pairs** of nodes `(a, b)` that satisfy **both** of the following conditions:\n\n*   `a < b`\n*   `incident(a, b) > queries[j]`\n\nReturn _an array_ `answers` _such that_ `answers.length == queries.length` _and_ `answers[j]` _is the answer of the_ `jth` _query_.\n\nNote that there can be **multiple edges** between the same two nodes.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,4\\],\\[1,3\\],\\[2,3\\],\\[2,1\\]\\], queries = \\[2,3\\]\n**Output:** \\[6,5\\]\n**Explanation:** The calculations for incident(a, b) are shown in the table above.\nThe answers for each of the queries are as follows:\n- answers\\[0\\] = 6. All the pairs have an incident(a, b) value greater than 2.\n- answers\\[1\\] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.\n\n",
                "**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[1,5\\],\\[1,5\\],\\[3,4\\],\\[2,5\\],\\[1,3\\],\\[5,1\\],\\[2,3\\],\\[2,5\\]\\], queries = \\[1,2,3,4,5\\]\n**Output:** \\[10,10,9,8,6\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 2 * 104`\n*   `1 <= edges.length <= 105`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= queries.length <= 20`\n*   `0 <= queries[j] < edges.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Graph",
            "Sorting"
        ],
        "example": [
            {
                "input": "4,[[1,2],[2,4],[1,3],[2,3],[2,1]],[2,3]",
                "output": "[6,5]"
            },
            {
                "input": "5,[[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]],[1,2,3,4,5]",
                "output": "[10,10,9,8,6]"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    public String getSmallestString(int n, int k) {\n        char[] result = new char[n];\n        k -= n;\n        for (int i = n - 1; i >= 0; --i) {\n            int value = Math.min(k, 25);\n            result[i] = (char) ('a' + value);\n            k -= value;\n            if (k == 0) break;\n        }\n        return new String(result);\n    }\n}\n```\n    \n    1. Initialize the result string of size `n` with all `'a'` characters.\n2. Subtract `n` from `k` because we've already accounted for the 'a' characters.\n3. Iterate over the string in reverse, and update each character based on the remaining value `k`.\n4. At each position, calculate the smallest possible value for the current character. Choose the minimum between `k` and `25` (since 26 - 1 is the maximum we can increment the character), and update the character accordingly.\n5. Subtract the chosen value from `k`, then update the index to the left.\n6. Continue this process until there's nothing left to add, i.e., `k == 0`.\n7. Return the result string.\n    ",
        "python": "\n    ```python\ndef get_smallest_string(n: int, k: int) -> str:\n    result = ['a'] * n\n    k -= n\n    idx = n - 1\n    while k > 0:\n        value = min(k, 25)\n        result[idx] = chr(ord(result[idx]) + value)\n        k -= value\n        idx -= 1\n    return ''.join(result)\n```\n    \n    1. Initialize the result string of size `n` with all `'a'` characters.\n2. Subtract `n` from `k` because we've already accounted for the 'a' characters.\n3. Iterate over the string in reverse, and update each character based on the remaining value `k`.\n4. At each position, calculate the smallest possible value for the current character. Choose the minimum between `k` and `25` (since 26 - 1 is the maximum we can increment the character), and update the character accordingly.\n5. Subtract the chosen value from `k`, then update the index to the left.\n6. Continue this process until there's nothing left to add, i.e., `k == 0`.\n7. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring getSmallestString(int n, int k) {\n    string result(n, 'a');\n    k -= n;\n    for (int i = n - 1; i >= 0; --i) {\n        int value = min(k, 25);\n        result[i] += value;\n        k -= value;\n        if (k == 0) break;\n    }\n    return result;\n}\n```\n    \n    1. Initialize the result string of size `n` with all `'a'` characters.\n2. Subtract `n` from `k` because we've already accounted for the 'a' characters.\n3. Iterate over the string in reverse, and update each character based on the remaining value `k`.\n4. At each position, calculate the smallest possible value for the current character. Choose the minimum between `k` and `25` (since 26 - 1 is the maximum we can increment the character), and update the character accordingly.\n5. Subtract the chosen value from `k`, then update the index to the left.\n6. Continue this process until there's nothing left to add, i.e., `k == 0`.\n7. Return the result string.\n    ",
        "js": "\n    ```javascript\nfunction getSmallestString(n, k) {\n    const result = Array(n).fill('a');\n    k -= n;\n    for (let i = n - 1; i >= 0; --i) {\n        const value = Math.min(k, 25);\n        result[i] = String.fromCharCode(result[i].charCodeAt(0) + value);\n        k -= value;\n        if (k === 0) break;\n    }\n    return result.join('');\n}\n```\n    \n    1. Initialize the result string of size `n` with all `'a'` characters.\n2. Subtract `n` from `k` because we've already accounted for the 'a' characters.\n3. Iterate over the string in reverse, and update each character based on the remaining value `k`.\n4. At each position, calculate the smallest possible value for the current character. Choose the minimum between `k` and `25` (since 26 - 1 is the maximum we can increment the character), and update the character accordingly.\n5. Subtract the chosen value from `k`, then update the index to the left.\n6. Continue this process until there's nothing left to add, i.e., `k == 0`.\n7. Return the result string.\n    "
    },
    {
        "id": 294,
        "title": "Make the XOR of All Segments Equal to Zero",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums`​​​ and an integer `k`​​​​​. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`.\n\nReturn _the minimum number of elements to change in the array_ such that the `XOR` of all segments of size `k`​​​​​​ is equal to zero.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,0,3,0\\], k = 1\n**Output:** 3\n**Explanation:** Modify the array from \\[**1**,**2**,0,**3**,0\\] to from \\[**0**,**0**,0,**0**,0\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,4,5,2,1,7,3,4,7\\], k = 3\n**Output:** 3\n**Explanation:** Modify the array from \\[3,4,**5**,**2**,**1**,7,3,4,7\\] to \\[3,4,**7**,**3**,**4**,7,3,4,7\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,4,1,2,5,1,2,6\\], k = 3\n**Output:** 3\n**Explanation:** Modify the array from \\[1,2,**4,**1,2,**5**,1,2,**6**\\] to \\[1,2,**3**,1,2,**3**,1,2,**3**\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 2000`\n*   `​​​​​​0 <= nums[i] < 210`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,2,0,3,0],1",
                "output": "3"
            },
            {
                "input": "[3,4,5,2,1,7,3,4,7],3",
                "output": "3"
            },
            {
                "input": "[1,2,4,1,2,5,1,2,6],3",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int[] calculateSummationOfAbsoluteDifferences(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i != j) {\n                result[i] += Math.abs(nums[i] - nums[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    ",
        "python": "\n    ```python\ndef calculate_summation_of_absolute_differences(nums):\n    n = len(nums)\n    result = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] += abs(nums[i] - nums[j])\n\n    return result\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> calculate_summation_of_absolute_differences(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> result(n, 0);\n\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i != j) {\n                result[i] += std::abs(nums[i] - nums[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    ",
        "js": "\n    ```javascript\nfunction calculateSummationOfAbsoluteDifferences(nums) {\n    let n = nums.length;\n    let result = new Array(n).fill(0);\n\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < n; j++) {\n            if(i !== j) {\n                result[i] += Math.abs(nums[i] - nums[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm iterates through each element `nums[i]` in the given integer array `nums`. For each element `nums[i]`, it also iterates through all other elements `nums[j]` in the array, skipping the case when `i == j`. Then, it calculates the absolute difference between `nums[i]` and `nums[j]`, and sums it to the corresponding result for element `nums[i]`. After iterating through all elements, an array `result` containing the summations of absolute differences for each element is returned.\n    "
    },
    {
        "id": 295,
        "title": "Maximum Score of a Good Subarray",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `nums` **(0-indexed)** and an integer `k`.\n\nThe **score** of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)`. A **good** subarray is a subarray where `i <= k <= j`.\n\nReturn _the maximum possible **score** of a **good** subarray._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,4,3,7,4,5\\], k = 3\n**Output:** 15\n**Explanation:** The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) \\* (5-1+1) = 3 \\* 5 = 15. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,5,4,5,4,1,1,1\\], k = 0\n**Output:** 20\n**Explanation:** The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) \\* (4-0+1) = 4 \\* 5 = 20."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 2 * 104`\n*   `0 <= k < nums.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[1,4,3,7,4,5],3",
                "output": "15"
            },
            {
                "input": "[5,5,4,5,4,1,1,1],0",
                "output": "20"
            }
        ],
        "java": "\n    ```java\npublic int minMoves(int[] nums, int limit) {\n    int n = nums.length;\n    int[] delta = new int[2 * limit + 2];\n\n    for (int i = 0; i < n / 2; i++) {\n        int lo = Math.min(nums[i], nums[n - 1 - i]) + 1;\n        int hi = Math.max(nums[i], nums[n - 1 - i]) + limit;\n        delta[lo]--;\n        delta[nums[i] + nums[n - 1 - i]]--;\n        delta[hi + 1]++;\n    }\n    int moves = n, current = n;\n    for (int i = 2; i <= 2 * limit; i++) {\n        current += delta[i];\n        moves = Math.min(moves, current);\n    }\n    return moves;\n}\n```\n\n    \n    The algorithm first initializes a delta array of length `2 * limit + 2` to keep track of the changes in required moves. Then, it iterates through the first half of the input array `nums`, for the pairs of elements `nums[i]` and `nums[n - 1 - i]`. For each pair, the algorithm calculates the low bound (lo) and the high bound (hi) where an operation is needed.\n\nThe following steps are performed on the delta array during the iteration: decrease by 1 at delta[lo], decrease by 1 at delta[`nums[i] + nums[n - 1 - i]`], and increase by 1 at delta[hi + 1].\n\nAfter iterating, the algorithm initializes variables `moves` and `current` with the value of `n`. For each index i from 2 to `2 * limit` in the delta array, the algorithm adds the value of delta[i] to current and assigns the minimum of current and moves to moves. In the end, it returns the value of moves, which is the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array nums.\n    ",
        "python": "\n    ```python\ndef min_moves(nums, limit):\n    n = len(nums)\n    delta = [0] * (2 * limit + 2)\n\n    for i in range(n // 2):\n        lo = min(nums[i], nums[n - 1 - i]) + 1\n        hi = max(nums[i], nums[n - 1 - i]) + limit\n        delta[lo] -= 1\n        delta[nums[i] + nums[n - 1 - i]] -= 1\n        delta[hi + 1] += 1\n\n    moves, current = n, n\n    for i in range(2, 2 * limit + 1):\n        current += delta[i]\n        moves = min(moves, current)\n\n    return moves\n```\n\n    \n    The algorithm first initializes a delta array of length `2 * limit + 2` to keep track of the changes in required moves. Then, it iterates through the first half of the input array `nums`, for the pairs of elements `nums[i]` and `nums[n - 1 - i]`. For each pair, the algorithm calculates the low bound (lo) and the high bound (hi) where an operation is needed.\n\nThe following steps are performed on the delta array during the iteration: decrease by 1 at delta[lo], decrease by 1 at delta[`nums[i] + nums[n - 1 - i]`], and increase by 1 at delta[hi + 1].\n\nAfter iterating, the algorithm initializes variables `moves` and `current` with the value of `n`. For each index i from 2 to `2 * limit` in the delta array, the algorithm adds the value of delta[i] to current and assigns the minimum of current and moves to moves. In the end, it returns the value of moves, which is the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array nums.\n    ",
        "c++": "\n    ```cpp\nint minMoves(vector<int>& nums, int limit) {\n    int n = nums.size();\n    vector<int> delta(2 * limit + 2, 0);\n\n    for (int i = 0; i < n / 2; i++) {\n        int lo = min(nums[i], nums[n - 1 - i]) + 1;\n        int hi = max(nums[i], nums[n - 1 - i]) + limit;\n        delta[lo]--;\n        delta[nums[i] + nums[n - 1 - i]]--;\n        delta[hi + 1]++;\n    }\n    int moves = n, current = n;\n    for (int i = 2; i <= 2 * limit; i++) {\n        current += delta[i];\n        moves = min(moves, current);\n    }\n    return moves;\n}\n```\n\n    \n    The algorithm first initializes a delta array of length `2 * limit + 2` to keep track of the changes in required moves. Then, it iterates through the first half of the input array `nums`, for the pairs of elements `nums[i]` and `nums[n - 1 - i]`. For each pair, the algorithm calculates the low bound (lo) and the high bound (hi) where an operation is needed.\n\nThe following steps are performed on the delta array during the iteration: decrease by 1 at delta[lo], decrease by 1 at delta[`nums[i] + nums[n - 1 - i]`], and increase by 1 at delta[hi + 1].\n\nAfter iterating, the algorithm initializes variables `moves` and `current` with the value of `n`. For each index i from 2 to `2 * limit` in the delta array, the algorithm adds the value of delta[i] to current and assigns the minimum of current and moves to moves. In the end, it returns the value of moves, which is the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array nums.\n    ",
        "js": "\n    ```javascript\nfunction minMoves(nums, limit) {\n    const n = nums.length;\n    const delta = new Array(2 * limit + 2).fill(0);\n\n    for (let i = 0; i < n / 2; i++) {\n        const lo = Math.min(nums[i], nums[n - 1 - i]) + 1;\n        const hi = Math.max(nums[i], nums[n - 1 - i]) + limit;\n        delta[lo]--;\n        delta[nums[i] + nums[n - 1 - i]]--;\n        delta[hi + 1]++;\n    }\n    let moves = n, current = n;\n    for (let i = 2; i <= 2 * limit; i++) {\n        current += delta[i];\n        moves = Math.min(moves, current);\n    }\n    return moves;\n}\n```\n\n    \n    The algorithm first initializes a delta array of length `2 * limit + 2` to keep track of the changes in required moves. Then, it iterates through the first half of the input array `nums`, for the pairs of elements `nums[i]` and `nums[n - 1 - i]`. For each pair, the algorithm calculates the low bound (lo) and the high bound (hi) where an operation is needed.\n\nThe following steps are performed on the delta array during the iteration: decrease by 1 at delta[lo], decrease by 1 at delta[`nums[i] + nums[n - 1 - i]`], and increase by 1 at delta[hi + 1].\n\nAfter iterating, the algorithm initializes variables `moves` and `current` with the value of `n`. For each index i from 2 to `2 * limit` in the delta array, the algorithm adds the value of delta[i] to current and assigns the minimum of current and moves to moves. In the end, it returns the value of moves, which is the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input array nums.\n    "
    },
    {
        "id": 296,
        "title": "Maximize Score After N Operations",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given `nums`, an array of positive integers of size `2 * n`. You must perform `n` operations on this array.\n\nIn the `ith` operation **(1-indexed)**, you will:\n\n*   Choose two elements, `x` and `y`.\n*   Receive a score of `i * gcd(x, y)`.\n*   Remove `x` and `y` from `nums`.\n\nReturn _the maximum score you can receive after performing_ `n` _operations._\n\nThe function `gcd(x, y)` is the greatest common divisor of `x` and `y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 1\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(1, 2)) = 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,4,6,8\\]\n**Output:** 11\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(3, 6)) + (2 \\* gcd(4, 8)) = 3 + 8 = 11\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6\\]\n**Output:** 14\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(1, 5)) + (2 \\* gcd(2, 4)) + (3 \\* gcd(3, 6)) = 1 + 4 + 9 = 14"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 7`\n*   `nums.length == 2 * n`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Backtracking",
            "Bit Manipulation",
            "Number Theory",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,2]",
                "output": "1"
            },
            {
                "input": "[3,4,6,8]",
                "output": "11"
            },
            {
                "input": "[1,2,3,4,5,6]",
                "output": "14"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\nclass Solution {\n    public int minimumIncompatibility(int[] nums, int k) {\n        int n = nums.length;\n        if (n % k != 0) return -1;\n        \n        Arrays.sort(nums);\n        LinkedList<Integer> diffList = new LinkedList<>();\n        for (int i = 0; i < k; ++i) {\n            diffList.add(nums[(i + 1) * (n / k) - 1] - nums[i * (n / k)]);\n        }\n        \n        int sum = 0;\n        for (Integer diff : diffList) {\n            sum += diff;\n        }\n        \n        return sum;\n    }\n}\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef minimumIncompatibility(nums: List[int], k: int) -> int:\n    n = len(nums)\n    if n % k != 0:\n        return -1\n    \n    nums.sort()\n    diffs = [nums[(i + 1) * (n // k) - 1] - nums[i * (n // k)] for i in range(k)]\n    \n    return sum(diffs)\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    ",
        "c++": "\n    ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumIncompatibility(vector<int>& nums, int k) {\n    int n = nums.size();\n    if (n % k != 0) return -1;\n\n    sort(nums.begin(), nums.end());\n    multiset<int> st;\n    for (int i = 0; i < k; ++i) {\n        st.insert(nums[i * (n / k)] - nums[(i + 1) * (n / k) - 1]);\n    }\n\n    return accumulate(st.begin(), st.end(), 0);\n}\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    ",
        "js": "\n    ```javascript\nfunction minimumIncompatibility(nums, k) {\n    let n = nums.length;\n    if (n % k !== 0) return -1;\n    \n    nums.sort((a, b) => a - b);\n    let diffs = [];\n    for (let i = 0; i < k; ++i) {\n        diffs.push(nums[(i + 1) * (n / k) - 1] - nums[i * (n / k)]);\n    }\n    \n    return diffs.reduce((acc, curr) => acc + curr, 0);\n}\n```\n    \n    1. Get the length of the array and check if it can be divided into k subsets equally. If not, return -1.\n\n2. Sort the array in ascending order.\n\n3. Calculate the incompatibility for each subset by the difference between the maximum and minimum elements in that subset.\n\n4. Store the incompatibilities of subsets in a multiset for C++, LinkedList for Java, list for Python, and an array for JavaScript.\n\n5. Iterate through the created data structure and add up all the incompatibilities stored in it. Return the calculated sum.\n    "
    },
    {
        "id": 297,
        "title": "Count Pairs With XOR in a Range",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a **(0-indexed)** integer array `nums` and two integers `low` and `high`, return _the number of **nice pairs**_.\n\nA **nice pair** is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,4,2,7\\], low = 2, high = 6\n**Output:** 6\n**Explanation:** All nice pairs (i, j) are as follows:\n    - (0, 1): nums\\[0\\] XOR nums\\[1\\] = 5 \n    - (0, 2): nums\\[0\\] XOR nums\\[2\\] = 3\n    - (0, 3): nums\\[0\\] XOR nums\\[3\\] = 6\n    - (1, 2): nums\\[1\\] XOR nums\\[2\\] = 6\n    - (1, 3): nums\\[1\\] XOR nums\\[3\\] = 3\n    - (2, 3): nums\\[2\\] XOR nums\\[3\\] = 5\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9,8,4,2,1\\], low = 5, high = 14\n**Output:** 8\n**Explanation:** All nice pairs (i, j) are as follows:\n​​​​​    - (0, 2): nums\\[0\\] XOR nums\\[2\\] = 13\n    - (0, 3): nums\\[0\\] XOR nums\\[3\\] = 11\n    - (0, 4): nums\\[0\\] XOR nums\\[4\\] = 8\n    - (1, 2): nums\\[1\\] XOR nums\\[2\\] = 12\n    - (1, 3): nums\\[1\\] XOR nums\\[3\\] = 10\n    - (1, 4): nums\\[1\\] XOR nums\\[4\\] = 9\n    - (2, 3): nums\\[2\\] XOR nums\\[3\\] = 6\n    - (2, 4): nums\\[2\\] XOR nums\\[4\\] = 5"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 2 * 104`\n*   `1 <= low <= high <= 2 * 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Trie"
        ],
        "example": [
            {
                "input": "[1,4,2,7],2,6",
                "output": "6"
            },
            {
                "input": "[9,8,4,2,1],5,14",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic double averageWaitingTime(int[][] customers) {\n    double waitTime = 0;\n    int currTime = 0;\n    \n    for (int[] customer : customers) {\n        currTime = Math.max(currTime, customer[0]) + customer[1];\n        waitTime += currTime - customer[0];\n    }\n    \n    return waitTime / customers.length;\n}\n```\n\n    \n    The algorithm keeps track of the current time (`curr_time`) and the total waiting time (`wait_time`). It then iterates through the customers array, for each customer the chef starts preparing the orders when he is idle i.e., the maximum of arrival time and the current time. After preparing an order, we update the waiting time by adding the difference between the current time and arrival time. Finally, we return the average waiting time calculated by dividing the total waiting time by the number of customers.\n    ",
        "python": "\n    ```python\ndef average_waiting_time(customers):\n    wait_time = 0\n    curr_time = 0\n    \n    for arrival, time in customers:\n        curr_time = max(curr_time, arrival) + time\n        wait_time += curr_time - arrival\n    \n    return wait_time / len(customers)\n```\n\n    \n    The algorithm keeps track of the current time (`curr_time`) and the total waiting time (`wait_time`). It then iterates through the customers array, for each customer the chef starts preparing the orders when he is idle i.e., the maximum of arrival time and the current time. After preparing an order, we update the waiting time by adding the difference between the current time and arrival time. Finally, we return the average waiting time calculated by dividing the total waiting time by the number of customers.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\ndouble averageWaitingTime(std::vector<std::vector<int>>& customers) {\n    double wait_time = 0;\n    int curr_time = 0;\n    \n    for (auto& customer : customers) {\n        curr_time = std::max(curr_time, customer[0]) + customer[1];\n        wait_time += curr_time - customer[0];\n    }\n    \n    return wait_time / customers.size();\n}\n```\n\n    \n    The algorithm keeps track of the current time (`curr_time`) and the total waiting time (`wait_time`). It then iterates through the customers array, for each customer the chef starts preparing the orders when he is idle i.e., the maximum of arrival time and the current time. After preparing an order, we update the waiting time by adding the difference between the current time and arrival time. Finally, we return the average waiting time calculated by dividing the total waiting time by the number of customers.\n    ",
        "js": "\n    ```javascript\nfunction averageWaitingTime(customers) {\n    let waitTime = 0;\n    let currTime = 0;\n    \n    for (const customer of customers) {\n        currTime = Math.max(currTime, customer[0]) + customer[1];\n        waitTime += currTime - customer[0];\n    }\n    \n    return waitTime / customers.length;\n}\n```\n\n    \n    The algorithm keeps track of the current time (`curr_time`) and the total waiting time (`wait_time`). It then iterates through the customers array, for each customer the chef starts preparing the orders when he is idle i.e., the maximum of arrival time and the current time. After preparing an order, we update the waiting time by adding the difference between the current time and arrival time. Finally, we return the average waiting time calculated by dividing the total waiting time by the number of customers.\n    "
    },
    {
        "id": 298,
        "title": "Maximize Number of Nice Divisors",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a positive integer `primeFactors`. You are asked to construct a positive integer `n` that satisfies the following conditions:\n\n*   The number of prime factors of `n` (not necessarily distinct) is **at most** `primeFactors`.\n*   The number of nice divisors of `n` is maximized. Note that a divisor of `n` is **nice** if it is divisible by every prime factor of `n`. For example, if `n = 12`, then its prime factors are `[2,2,3]`, then `6` and `12` are nice divisors, while `3` and `4` are not.\n\nReturn _the number of nice divisors of_ `n`. Since that number can be too large, return it **modulo** `109 + 7`.\n\nNote that a prime number is a natural number greater than `1` that is not a product of two smaller natural numbers. The prime factors of a number `n` is a list of prime numbers such that their product equals `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** primeFactors = 5\n**Output:** 6\n**Explanation:** 200 is a valid value of n.\nIt has 5 prime factors: \\[2,2,2,5,5\\], and it has 6 nice divisors: \\[10,20,40,50,100,200\\].\nThere is not other value of n that has at most 5 prime factors and more nice divisors.\n\n",
                "**Example 2:**\n\n**Input:** primeFactors = 8\n**Output:** 18"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= primeFactors <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Recursion",
            "Number Theory"
        ],
        "example": [
            {
                "input": "5",
                "output": "6"
            },
            {
                "input": "8",
                "output": "18"
            }
        ],
        "java": "\n    ```java\npublic int stoneGame(int[] stones) {\n    int n = stones.length;\n    int[][] dp = new int[n][n];\n    \n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j < n; j++) {\n            dp[i][j] = Math.max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]);\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm utilizes dynamic programming approach to find the maximum difference between Alice and Bob's scores. We create a 2D table \"dp\" where `dp[i][j]` stores the difference of scores between the two players when considering stones from index i to index j.\n\nWe iterate i from n-1 to 0, and j from i+1 to n-1. On ith row and jth column, we take the maximum value among the difference of the jth stone's value and `dp[i][j - 1]` and the difference of ith stone's value and `dp[i + 1][j]`. This represents the optimal choice of leftmost or rightmost stone to maximize the current difference.\n\nFinally, we return the value in `dp[0][n - 1]`, which represents the maximum difference when considering all the stones.\n    ",
        "python": "\n    ```python\ndef stoneGame(stones):\n    n = len(stones)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j])\n    \n    return dp[0][n - 1]\n```\n    \n    The algorithm utilizes dynamic programming approach to find the maximum difference between Alice and Bob's scores. We create a 2D table \"dp\" where `dp[i][j]` stores the difference of scores between the two players when considering stones from index i to index j.\n\nWe iterate i from n-1 to 0, and j from i+1 to n-1. On ith row and jth column, we take the maximum value among the difference of the jth stone's value and `dp[i][j - 1]` and the difference of ith stone's value and `dp[i + 1][j]`. This represents the optimal choice of leftmost or rightmost stone to maximize the current difference.\n\nFinally, we return the value in `dp[0][n - 1]`, which represents the maximum difference when considering all the stones.\n    ",
        "c++": "\n    ```cpp\nint stoneGame(vector<int>& stones) {\n    int n = stones.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i + 1; j < n; ++j) {\n            dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]);\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm utilizes dynamic programming approach to find the maximum difference between Alice and Bob's scores. We create a 2D table \"dp\" where `dp[i][j]` stores the difference of scores between the two players when considering stones from index i to index j.\n\nWe iterate i from n-1 to 0, and j from i+1 to n-1. On ith row and jth column, we take the maximum value among the difference of the jth stone's value and `dp[i][j - 1]` and the difference of ith stone's value and `dp[i + 1][j]`. This represents the optimal choice of leftmost or rightmost stone to maximize the current difference.\n\nFinally, we return the value in `dp[0][n - 1]`, which represents the maximum difference when considering all the stones.\n    ",
        "js": "\n    ```javascript\nfunction stoneGame(stones) {\n    const n = stones.length;\n    const dp = Array.from({length:n}, () => Array(n).fill(0));\n    \n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 1; j < n; j++) {\n            dp[i][j] = Math.max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]);\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm utilizes dynamic programming approach to find the maximum difference between Alice and Bob's scores. We create a 2D table \"dp\" where `dp[i][j]` stores the difference of scores between the two players when considering stones from index i to index j.\n\nWe iterate i from n-1 to 0, and j from i+1 to n-1. On ith row and jth column, we take the maximum value among the difference of the jth stone's value and `dp[i][j - 1]` and the difference of ith stone's value and `dp[i + 1][j]`. This represents the optimal choice of leftmost or rightmost stone to maximize the current difference.\n\nFinally, we return the value in `dp[0][n - 1]`, which represents the maximum difference when considering all the stones.\n    "
    },
    {
        "id": 299,
        "title": "Maximum Number of Groups Getting Fresh Donuts",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a donuts shop that bakes donuts in batches of `batchSize`. They have a rule where they must serve **all** of the donuts of a batch before serving any donuts of the next batch. You are given an integer `batchSize` and an integer array `groups`, where `groups[i]` denotes that there is a group of `groups[i]` customers that will visit the shop. Each customer will get exactly one donut.\n\nWhen a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.\n\nYou can freely rearrange the ordering of the groups. Return _the **maximum** possible number of happy groups after rearranging the groups._",
            "examples": [
                "**Example 1:**\n\n**Input:** batchSize = 3, groups = \\[1,2,3,4,5,6\\]\n**Output:** 4\n**Explanation:** You can arrange the groups as \\[6,2,4,5,1,3\\]. Then the 1st, 2nd, 4th, and 6th groups will be happy.\n\n",
                "**Example 2:**\n\n**Input:** batchSize = 4, groups = \\[1,3,2,5,2,2,1,6\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= batchSize <= 9`\n*   `1 <= groups.length <= 30`\n*   `1 <= groups[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Memoization",
            "Bitmask"
        ],
        "example": [
            {
                "input": "3,[1,2,3,4,5,6]",
                "output": "4"
            },
            {
                "input": "4,[1,3,2,5,2,2,1,6]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\n        int[] queryIDs = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            queryIDs[i] = i;\n        }\n        Arrays.sort(queryIDs, (i, j) -> Integer.compare(queries[i][2], queries[j][2]));\n        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));\n\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n\n        boolean[] res = new boolean[queries.length];\n        int idx = 0;\n        for (int queryID : queryIDs) {\n            int[] query = queries[queryID];\n            int p = query[0], q = query[1], limit = query[2];\n\n            while (idx < edgeList.length && edgeList[idx][2] < limit) {\n                int u = edgeList[idx][0], v = edgeList[idx][1];\n                int ru = find(u, parent), rv = find(v, parent);\n                if (ru != rv) {\n                    parent[ru] = rv;\n                }\n                idx++;\n            }\n            res[queryID] = find(p, parent) == find(q, parent);\n        }\n        return res;\n    }\n\n    private int find(int x, int[] parent) {\n        if (x != parent[x]) {\n            parent[x] = find(parent[x], parent);\n        }\n        return parent[x];\n    }\n}\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef distanceLimitedPathsExist(n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    edgeList.sort(key=lambda x: x[2])\n    queries = sorted(enumerate(queries), key=lambda x: x[1][2])\n\n    def find(x: int, parent: List[int]) -> int:\n        if x != parent[x]:\n            parent[x] = find(parent[x], parent)\n        return parent[x]\n\n    parent = list(range(n))\n    res = [False] * len(queries)\n    idx = 0\n\n    for query_id, query in queries:\n        p, q, limit = query\n        while idx < len(edgeList) and edgeList[idx][2] < limit:\n            u, v = edgeList[idx][:2]\n            ru, rv = find(u, parent), find(v, parent)\n            if ru != rv:\n                parent[ru] = rv\n            idx += 1\n        res[query_id] = find(p, parent) == find(q, parent)\n\n    return res\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\n    for (int i = 0; i < queries.size(); ++i) {\n        queries[i].push_back(i);\n    }\n    sort(queries.begin(), queries.end(), [](const vector<int> &a, const vector<int> &b) {\n        return a[2] < b[2];\n    });\n    sort(edgeList.begin(), edgeList.end(), [](const vector<int> &a, const vector<int> &b) {\n        return a[2] < b[2];\n    });\n\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int x) {\n        return x == parent[x] ? x : parent[x] = find(parent[x]);\n    };\n\n    vector<bool> res(queries.size());\n    int idx = 0;\n    for (const auto &query : queries) {\n        int p = query[0], q = query[1], limit = query[2], id = query[3];\n        while (idx < edgeList.size() && edgeList[idx][2] < limit) {\n            int u = edgeList[idx][0], v = edgeList[idx][1];\n            int ru = find(u), rv = find(v);\n            if (ru != rv) {\n                parent[ru] = rv;\n            }\n            idx++;\n        }\n        res[id] = find(p) == find(q);\n    }\n    return res;\n}\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    ",
        "js": "\n    ```javascript\nfunction distanceLimitedPathsExist(n, edgeList, queries) {\n    edgeList.sort((a, b) => a[2] - b[2]);\n    queries = queries.map((query, idx) => [...query, idx]).sort((a, b) => a[2] - b[2]);\n\n    function find(x, parent) {\n        if (x !== parent[x]) {\n            parent[x] = find(parent[x], parent);\n        }\n        return parent[x];\n    }\n\n    const parent = Array.from({ length: n }, (_, idx) => idx);\n    const res = new Array(queries.length).fill(false);\n    let idx = 0;\n\n    for (const query of queries) {\n        const [p, q, limit, queryId] = query;\n        while (idx < edgeList.length && edgeList[idx][2] < limit) {\n            const [u, v] = edgeList[idx];\n            const [ru, rv] = [find(u, parent), find(v, parent)];\n            if (ru !== rv) {\n                parent[ru] = rv;\n            }\n            idx++;\n        }\n        res[queryId] = find(p, parent) === find(q, parent);\n    }\n\n    return res;\n}\n```\n    \n    The algorithm starts by sorting `edgeList` by edge distance and `queries` by limit. We then use a disjoint set data structure (implemented using the `parent` list) to keep track of connected components, and we initialize each node to be its own parent.\n\nThe main idea of the algorithm is to iterate through the sorted queries and process those edges (in the edge list) with distance smaller than the query limit. We do this by iterating through the `queries`, and within each iteration, we iterate through the `edgeList` for all edges with distance less than the query limit, and union the connected nodes in the parent.\n\nAfter processing the edges, we then check if the two nodes in the current query, `p` and `q`, are in the same connected component. If they are, it means that there exists a path between them with edge distances less than the query limit. We store this result in the answer array.\n\nFinally, we return the answer array containing boolean values for each query.\n    "
    },
    {
        "id": 300,
        "title": "Number of Different Subsequences GCDs",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums` that consists of positive integers.\n\nThe **GCD** of a sequence of numbers is defined as the greatest integer that divides **all** the numbers in the sequence evenly.\n\n*   For example, the GCD of the sequence `[4,6,16]` is `2`.\n\nA **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n*   For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`.\n\nReturn _the **number** of **different** GCDs among all **non-empty** subsequences of_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[6,10,3\\]\n**Output:** 5\n**Explanation:** The figure shows all the non-empty subsequences and their GCDs.\nThe different GCDs are 6, 10, 3, 2, and 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,15,40,5,6\\]\n**Output:** 7"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 2 * 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Counting",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[6,10,3]",
                "output": "5"
            },
            {
                "input": "[5,15,40,5,6]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<Integer> largestLexSequence(int n) {\n        List<Integer> res = new ArrayList<Integer>(n);\n        for (int i = 0; i < n; ++i) {\n            res.add(i % 2);\n        }\n        return res;\n    }\n}\n```\n    \n    In the given problem, we have to find the largest lexicographical sequence of length n where the distance between the two elements is equal to the absolute difference of their indices. For a given sequence that repeats every two consecutive elements, the distance condition holds.\n\nTo find the largest of such sequences, we choose the sequence starting from the highest number that doesn't increase the sequence length. Here, the largest number that meets this condition is `1`. So, if we follow an alternating pattern 1, 0, 1, 0, 1, ..., our sequence will satisfy the conditions mentioned, and we get the largest lexicographically valid sequence.\n\nTo implement this, we initialize a vector, list or array of size `n`, then just loop through the indices from `0` to `n-1` and store `i % 2` at position `i`. Finally, return the sequence. The `%` operator gives the remainder when dividing `i` by `2`, resulting in alternating 1s and 0s.\n    ",
        "python": "\n    ```python\ndef largest_lex_sequence(n: int) -> list[int]:\n    res = [0] * n\n    for i in range(n):\n        res[i] = i % 2\n    return res\n```\n    \n    In the given problem, we have to find the largest lexicographical sequence of length n where the distance between the two elements is equal to the absolute difference of their indices. For a given sequence that repeats every two consecutive elements, the distance condition holds.\n\nTo find the largest of such sequences, we choose the sequence starting from the highest number that doesn't increase the sequence length. Here, the largest number that meets this condition is `1`. So, if we follow an alternating pattern 1, 0, 1, 0, 1, ..., our sequence will satisfy the conditions mentioned, and we get the largest lexicographically valid sequence.\n\nTo implement this, we initialize a vector, list or array of size `n`, then just loop through the indices from `0` to `n-1` and store `i % 2` at position `i`. Finally, return the sequence. The `%` operator gives the remainder when dividing `i` by `2`, resulting in alternating 1s and 0s.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> largestLexSequence(int n) {\n    vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = i % 2;\n    }\n    return res;\n}\n```\n    \n    In the given problem, we have to find the largest lexicographical sequence of length n where the distance between the two elements is equal to the absolute difference of their indices. For a given sequence that repeats every two consecutive elements, the distance condition holds.\n\nTo find the largest of such sequences, we choose the sequence starting from the highest number that doesn't increase the sequence length. Here, the largest number that meets this condition is `1`. So, if we follow an alternating pattern 1, 0, 1, 0, 1, ..., our sequence will satisfy the conditions mentioned, and we get the largest lexicographically valid sequence.\n\nTo implement this, we initialize a vector, list or array of size `n`, then just loop through the indices from `0` to `n-1` and store `i % 2` at position `i`. Finally, return the sequence. The `%` operator gives the remainder when dividing `i` by `2`, resulting in alternating 1s and 0s.\n    ",
        "js": "\n    ```javascript\nfunction largestLexSequence(n) {\n    let res = new Array(n);\n    for (let i = 0; i < n; ++i) {\n        res[i] = i % 2;\n    }\n    return res;\n}\n```\n    \n    In the given problem, we have to find the largest lexicographical sequence of length n where the distance between the two elements is equal to the absolute difference of their indices. For a given sequence that repeats every two consecutive elements, the distance condition holds.\n\nTo find the largest of such sequences, we choose the sequence starting from the highest number that doesn't increase the sequence length. Here, the largest number that meets this condition is `1`. So, if we follow an alternating pattern 1, 0, 1, 0, 1, ..., our sequence will satisfy the conditions mentioned, and we get the largest lexicographically valid sequence.\n\nTo implement this, we initialize a vector, list or array of size `n`, then just loop through the indices from `0` to `n-1` and store `i % 2` at position `i`. Finally, return the sequence. The `%` operator gives the remainder when dividing `i` by `2`, resulting in alternating 1s and 0s.\n    "
    },
    {
        "id": 301,
        "title": "Finding MK Average",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integers, `m` and `k`, and a stream of integers. You are tasked to implement a data structure that calculates the **MKAverage** for the stream.\n\nThe **MKAverage** can be calculated using these steps:\n\n1.  If the number of the elements in the stream is less than `m` you should consider the **MKAverage** to be `-1`. Otherwise, copy the last `m` elements of the stream to a separate container.\n2.  Remove the smallest `k` elements and the largest `k` elements from the container.\n3.  Calculate the average value for the rest of the elements **rounded down to the nearest integer**.\n\nImplement the `MKAverage` class:\n\n*   `MKAverage(int m, int k)` Initializes the **MKAverage** object with an empty stream and the two integers `m` and `k`.\n*   `void addElement(int num)` Inserts a new element `num` into the stream.\n*   `int calculateMKAverage()` Calculates and returns the **MKAverage** for the current stream **rounded down to the nearest integer**.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MKAverage \",  \"addElement \",  \"addElement \",  \"calculateMKAverage \",  \"addElement \",  \"calculateMKAverage \",  \"addElement \",  \"addElement \",  \"addElement \",  \"calculateMKAverage \"\\]\n\\[\\[3, 1\\], \\[3\\], \\[1\\], \\[\\], \\[10\\], \\[\\], \\[5\\], \\[5\\], \\[5\\], \\[\\]\\]\n**Output**\n\\[null, null, null, -1, null, 3, null, null, null, 5\\]\n\n**Explanation**\n`MKAverage obj = new MKAverage(3, 1);  obj.addElement(3);        // current elements are [3] obj.addElement(1);        // current elements are [3,1] obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist. obj.addElement(10);       // current elements are [3,1,10] obj.calculateMKAverage(); // The last 3 elements are [3,1,10].                           // After removing smallest and largest 1 element the container will be [3].                           // The average of [3] equals 3/1 = 3, return 3 obj.addElement(5);        // current elements are [3,1,10,5] obj.addElement(5);        // current elements are [3,1,10,5,5] obj.addElement(5);        // current elements are [3,1,10,5,5,5] obj.calculateMKAverage(); // The last 3 elements are [5,5,5].                           // After removing smallest and largest 1 element the container will be [5].                           // The average of [5] equals 5/1 = 5, return 5`"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= m <= 105`\n*   `1 <= k*2 < m`\n*   `1 <= num <= 105`\n*   At most `105` calls will be made to `addElement` and `calculateMKAverage`.",
            "follow_up": null
        },
        "tag": [
            "Design",
            "Queue",
            "Heap (Priority Queue)",
            "Data Stream",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,-1,null,3,null,null,null,5]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int minimumWorkingTime(int[] jobs, int k) {\n    int max_job = Arrays.stream(jobs).max().getAsInt();\n    int sum_jobs = Arrays.stream(jobs).sum();\n\n    int left = max_job, right = sum_jobs;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int count = 1, current_sum = 0;\n\n        for (int job : jobs) {\n            if (current_sum + job > mid) {\n                count++;\n                current_sum = 0;\n            }\n            current_sum += job;\n        }\n\n        if (count <= k) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n```\n\n    \n    The algorithm uses a binary search approach to find the minimum possible maximum working time. We initialize left to be the maximum job time and right to be the sum of all job times. Our goal is to find the smallest possible value such that there can be `k` or fewer partitions of jobs, where the sum of each partition's jobs' times is less than or equal to that value.\n\nWe start by finding the middle value between left and right. We then iterate through the jobs and keep track of the current sum and the number of current partitions (`count`). If adding the job exceeds the mid value, we increase the partition count and reset the current sum to 0.\n\nAfter iterating through all jobs, if our partitions count is less than or equal to k, we set right to be the mid value. Otherwise, we set left to be mid + 1. We continue narrowing the binary search space until left >= right.\n\nAt the end, left is the minimum possible maximum working time for any assignment, and we return it.\n    ",
        "python": "\n    ```python\ndef minimum_working_time(jobs, k):\n    max_job = max(jobs)\n    sum_jobs = sum(jobs)\n    \n    left, right = max_job, sum_jobs\n    while left < right:\n        mid = left + (right - left) // 2\n        count, current_sum = 1, 0\n\n        for job in jobs:\n            if current_sum + job > mid:\n                count += 1\n                current_sum = 0\n            current_sum += job\n\n        if count <= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n```\n\n    \n    The algorithm uses a binary search approach to find the minimum possible maximum working time. We initialize left to be the maximum job time and right to be the sum of all job times. Our goal is to find the smallest possible value such that there can be `k` or fewer partitions of jobs, where the sum of each partition's jobs' times is less than or equal to that value.\n\nWe start by finding the middle value between left and right. We then iterate through the jobs and keep track of the current sum and the number of current partitions (`count`). If adding the job exceeds the mid value, we increase the partition count and reset the current sum to 0.\n\nAfter iterating through all jobs, if our partitions count is less than or equal to k, we set right to be the mid value. Otherwise, we set left to be mid + 1. We continue narrowing the binary search space until left >= right.\n\nAt the end, left is the minimum possible maximum working time for any assignment, and we return it.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n#include <numeric>\n\nint minimumWorkingTime(std::vector<int>& jobs, int k) {\n    int max_job = *std::max_element(jobs.begin(), jobs.end());\n    int sum_jobs = std::accumulate(jobs.begin(), jobs.end(), 0);\n\n    int left = max_job, right = sum_jobs;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int count = 1, current_sum = 0;\n\n        for (int job : jobs) {\n            if (current_sum + job > mid) {\n                count++;\n                current_sum = 0;\n            }\n            current_sum += job;\n        }\n\n        if (count <= k) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n```\n\n    \n    The algorithm uses a binary search approach to find the minimum possible maximum working time. We initialize left to be the maximum job time and right to be the sum of all job times. Our goal is to find the smallest possible value such that there can be `k` or fewer partitions of jobs, where the sum of each partition's jobs' times is less than or equal to that value.\n\nWe start by finding the middle value between left and right. We then iterate through the jobs and keep track of the current sum and the number of current partitions (`count`). If adding the job exceeds the mid value, we increase the partition count and reset the current sum to 0.\n\nAfter iterating through all jobs, if our partitions count is less than or equal to k, we set right to be the mid value. Otherwise, we set left to be mid + 1. We continue narrowing the binary search space until left >= right.\n\nAt the end, left is the minimum possible maximum working time for any assignment, and we return it.\n    ",
        "js": "\n    ```javascript\nfunction minimumWorkingTime(jobs, k) {\n    let max_job = Math.max(...jobs);\n    let sum_jobs = jobs.reduce((a, b) => a + b, 0);\n    \n    let left = max_job, right = sum_jobs;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        let count = 1, current_sum = 0;\n\n        for (let job of jobs) {\n            if (current_sum + job > mid) {\n                count++;\n                current_sum = 0;\n            }\n            current_sum += job;\n        }\n\n        if (count <= k) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n```\n\n    \n    The algorithm uses a binary search approach to find the minimum possible maximum working time. We initialize left to be the maximum job time and right to be the sum of all job times. Our goal is to find the smallest possible value such that there can be `k` or fewer partitions of jobs, where the sum of each partition's jobs' times is less than or equal to that value.\n\nWe start by finding the middle value between left and right. We then iterate through the jobs and keep track of the current sum and the number of current partitions (`count`). If adding the job exceeds the mid value, we increase the partition count and reset the current sum to 0.\n\nAfter iterating through all jobs, if our partitions count is less than or equal to k, we set right to be the mid value. Otherwise, we set left to be mid + 1. We continue narrowing the binary search space until left >= right.\n\nAt the end, left is the minimum possible maximum working time for any assignment, and we return it.\n    "
    },
    {
        "id": 302,
        "title": "Minimum Number of Operations to Make String Sorted",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` (**0-indexed**)​​​​​​. You are asked to perform the following operation on `s`​​​​​​ until you get a sorted string:\n\n1.  Find **the largest index** `i` such that `1 <= i < s.length` and `s[i] < s[i - 1]`.\n2.  Find **the largest index** `j` such that `i <= j < s.length` and `s[k] < s[i - 1]` for all the possible values of `k` in the range `[i, j]` inclusive.\n3.  Swap the two characters at indices `i - 1`​​​​ and `j`​​​​​.\n4.  Reverse the suffix starting at index `i`​​​​​​.\n\nReturn _the number of operations needed to make the string sorted._ Since the answer can be too large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"cba \"\n**Output:** 5\n**Explanation:** The simulation goes as follows:\nOperation 1: i=2, j=2. Swap s\\[1\\] and s\\[2\\] to get s= \"cab \", then reverse the suffix starting at 2. Now, s= \"cab \".\nOperation 2: i=1, j=2. Swap s\\[0\\] and s\\[2\\] to get s= \"bac \", then reverse the suffix starting at 1. Now, s= \"bca \".\nOperation 3: i=2, j=2. Swap s\\[1\\] and s\\[2\\] to get s= \"bac \", then reverse the suffix starting at 2. Now, s= \"bac \".\nOperation 4: i=1, j=1. Swap s\\[0\\] and s\\[1\\] to get s= \"abc \", then reverse the suffix starting at 1. Now, s= \"acb \".\nOperation 5: i=2, j=2. Swap s\\[1\\] and s\\[2\\] to get s= \"abc \", then reverse the suffix starting at 2. Now, s= \"abc \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aabaa \"\n**Output:** 2\n**Explanation:** The simulation goes as follows:\nOperation 1: i=3, j=4. Swap s\\[2\\] and s\\[4\\] to get s= \"aaaab \", then reverse the substring starting at 3. Now, s= \"aaaba \".\nOperation 2: i=4, j=4. Swap s\\[3\\] and s\\[4\\] to get s= \"aaaab \", then reverse the substring starting at 4. Now, s= \"aaaab \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3000`\n*   `s`​​​​​​ consists only of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "\"cba\"",
                "output": "5"
            },
            {
                "input": "\"aabaa\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int countPairs(int[] deliciousness) {\n    final int MOD = (int) (1e9 + 7);\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    int maxVal = 0;\n    for (int val : deliciousness) {\n        maxVal = Math.max(maxVal, val);\n    }\n    int maxSum = maxVal * 2;\n\n    int count = 0;\n    for (int val : deliciousness) {\n        for (int sum = 1; sum <= maxSum; sum <<= 1) {\n            count = (count + hashMap.getOrDefault(sum - val, 0)) % MOD;\n        }\n        hashMap.put(val, hashMap.getOrDefault(val, 0) + 1);\n    }\n\n    return count;\n}\n```\n    \n    1. Initialize a hashmap for storing the frequency of deliciousness values.\n2. Find the max value in the deliciousness array and calculate the max sum as twice the max value.\n3. Initialize a variable to store the count of good meal pairs.\n4. Iterate through the deliciousness array, for each value:\n   a. Iterate with powers of two less than or equal to max sum.\n   b. If the hashmap contains the power of two minus the current value, increment the count by the frequency of such value in the hashmap. Don't forget to modulo the count by 1e9 + 7.\n   c. Update the hashmap by incrementing the frequency of the current value.\n5. After iterating through the deliciousness array, return the count of good meal pairs.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef countPairs(deliciousness):\n    MOD = 10**9 + 7\n    hashMap = defaultdict(int)\n    maxVal = max(deliciousness)\n    maxSum = maxVal * 2\n\n    count = 0\n    for val in deliciousness:\n        for sum in (1 << i for i in range(22)):\n            count = (count + hashMap[sum - val]) % MOD\n        hashMap[val] += 1\n\n    return count\n```\n    \n    1. Initialize a hashmap for storing the frequency of deliciousness values.\n2. Find the max value in the deliciousness array and calculate the max sum as twice the max value.\n3. Initialize a variable to store the count of good meal pairs.\n4. Iterate through the deliciousness array, for each value:\n   a. Iterate with powers of two less than or equal to max sum.\n   b. If the hashmap contains the power of two minus the current value, increment the count by the frequency of such value in the hashmap. Don't forget to modulo the count by 1e9 + 7.\n   c. Update the hashmap by incrementing the frequency of the current value.\n5. After iterating through the deliciousness array, return the count of good meal pairs.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint countPairs(vector<int>& deliciousness) {\n    const int MOD = 1e9 + 7;\n    unordered_map<int, int> hashMap;\n    int maxVal = *max_element(deliciousness.begin(), deliciousness.end());\n    int maxSum = maxVal * 2;\n    \n    int count = 0;\n    for (int val : deliciousness) {\n        for (int sum = 1; sum <= maxSum; sum <<= 1) {\n            count = (count + hashMap[sum - val]) % MOD;\n        }\n        hashMap[val]++;\n    }\n    \n    return count;\n}\n```\n    \n    1. Initialize a hashmap for storing the frequency of deliciousness values.\n2. Find the max value in the deliciousness array and calculate the max sum as twice the max value.\n3. Initialize a variable to store the count of good meal pairs.\n4. Iterate through the deliciousness array, for each value:\n   a. Iterate with powers of two less than or equal to max sum.\n   b. If the hashmap contains the power of two minus the current value, increment the count by the frequency of such value in the hashmap. Don't forget to modulo the count by 1e9 + 7.\n   c. Update the hashmap by incrementing the frequency of the current value.\n5. After iterating through the deliciousness array, return the count of good meal pairs.\n    ",
        "js": "\n    ```javascript\nfunction countPairs(deliciousness) {\n    const MOD = 1e9 + 7;\n    const hashMap = new Map();\n    let maxVal = 0;\n    for (const val of deliciousness) {\n        maxVal = Math.max(maxVal, val);\n    }\n    const maxSum = maxVal * 2;\n\n    let count = 0;\n    for (const val of deliciousness) {\n        for (let sum = 1; sum <= maxSum; sum <<= 1) {\n            count = (count + (hashMap.get(sum - val) || 0)) % MOD;\n        }\n        hashMap.set(val, (hashMap.get(val) || 0) + 1);\n    }\n\n    return count;\n}\n```\n    \n    1. Initialize a hashmap for storing the frequency of deliciousness values.\n2. Find the max value in the deliciousness array and calculate the max sum as twice the max value.\n3. Initialize a variable to store the count of good meal pairs.\n4. Iterate through the deliciousness array, for each value:\n   a. Iterate with powers of two less than or equal to max sum.\n   b. If the hashmap contains the power of two minus the current value, increment the count by the frequency of such value in the hashmap. Don't forget to modulo the count by 1e9 + 7.\n   c. Update the hashmap by incrementing the frequency of the current value.\n5. After iterating through the deliciousness array, return the count of good meal pairs.\n    "
    },
    {
        "id": 303,
        "title": "Find XOR Sum of All Pairs Bitwise AND",
        "difficulty": "Hard",
        "content": {
            "problem": "The **XOR sum** of a list is the bitwise `XOR` of all its elements. If the list only contains one element, then its **XOR sum** will be equal to this element.\n\n*   For example, the **XOR sum** of `[1,2,3,4]` is equal to `1 XOR 2 XOR 3 XOR 4 = 4`, and the **XOR sum** of `[3]` is equal to `3`.\n\nYou are given two **0-indexed** arrays `arr1` and `arr2` that consist only of non-negative integers.\n\nConsider the list containing the result of `arr1[i] AND arr2[j]` (bitwise `AND`) for every `(i, j)` pair where `0 <= i < arr1.length` and `0 <= j < arr2.length`.\n\nReturn _the **XOR sum** of the aforementioned list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[1,2,3\\], arr2 = \\[6,5\\]\n**Output:** 0\n**Explanation:** The list = \\[1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5\\] = \\[0,1,2,0,2,1\\].\nThe XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[12\\], arr2 = \\[4\\]\n**Output:** 4\n**Explanation:** The list = \\[12 AND 4\\] = \\[4\\]. The XOR sum = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 105`\n*   `0 <= arr1[i], arr2[j] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,2,3],[6,5]",
                "output": "0"
            },
            {
                "input": "[12],[4]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int[] decode(int[] encoded) {\n    int n = encoded.length + 1;\n    int total_xor = 0;\n    for (int i = 1; i <= n; ++i) {\n        total_xor ^= i;\n    }\n    int encoded_xor = 0;\n    for (int i = 1; i < n - 1; i += 2) {\n        encoded_xor ^= encoded[i];\n    }\n    int[] perm = new int[n];\n    perm[0] = total_xor ^ encoded_xor;\n    for (int i = 1; i < n; ++i) {\n        perm[i] = perm[i - 1] ^ encoded[i - 1];\n    }\n    return perm;\n}\n```\n    \n    1. Calculate the XOR of all integers from 1 to n (inclusive), and store it in the `total_xor` variable.\n2. Calculate the XOR of all elements of the encoded array with odd indices (starting from index 1), and store it in the `encoded_xor` variable.\n3. The first element of the perm array is calculated by XOR'ing `total_xor` and `encoded_xor`.\n4. Loop through the range 1 to n-1 (inclusive) and calculate the rest of the perm array elements using the following formula: `perm[i] = perm[i - 1] ^ encoded[i - 1]`.\n5. Return the reconstructed perm array.\n    ",
        "python": "\n    ```python\ndef decode(encoded):\n    n = len(encoded) + 1\n    total_xor = 0\n    for i in range(1, n + 1):\n        total_xor ^= i\n    encoded_xor = 0\n    for i in range(1, n - 1, 2):\n        encoded_xor ^= encoded[i]\n    perm = [total_xor ^ encoded_xor]\n    for i in range(1, n):\n        perm.append(perm[-1] ^ encoded[i - 1])\n    return perm\n```\n    \n    1. Calculate the XOR of all integers from 1 to n (inclusive), and store it in the `total_xor` variable.\n2. Calculate the XOR of all elements of the encoded array with odd indices (starting from index 1), and store it in the `encoded_xor` variable.\n3. The first element of the perm array is calculated by XOR'ing `total_xor` and `encoded_xor`.\n4. Loop through the range 1 to n-1 (inclusive) and calculate the rest of the perm array elements using the following formula: `perm[i] = perm[i - 1] ^ encoded[i - 1]`.\n5. Return the reconstructed perm array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> decode(std::vector<int>& encoded) {\n    int n = encoded.size() + 1;\n    int total_xor = 0;\n    for (int i = 1; i <= n; ++i) {\n        total_xor ^= i;\n    }\n    int encoded_xor = 0;\n    for (int i = 1; i < n - 1; i += 2) {\n        encoded_xor ^= encoded[i];\n    }\n    std::vector<int> perm(n);\n    perm[0] = total_xor ^ encoded_xor;\n    for (int i = 1; i < n; ++i) {\n        perm[i] = perm[i - 1] ^ encoded[i - 1];\n    }\n    return perm;\n}\n```\n    \n    1. Calculate the XOR of all integers from 1 to n (inclusive), and store it in the `total_xor` variable.\n2. Calculate the XOR of all elements of the encoded array with odd indices (starting from index 1), and store it in the `encoded_xor` variable.\n3. The first element of the perm array is calculated by XOR'ing `total_xor` and `encoded_xor`.\n4. Loop through the range 1 to n-1 (inclusive) and calculate the rest of the perm array elements using the following formula: `perm[i] = perm[i - 1] ^ encoded[i - 1]`.\n5. Return the reconstructed perm array.\n    ",
        "js": "\n    ```javascript\nfunction decode(encoded) {\n    const n = encoded.length + 1;\n    let total_xor = 0;\n    for (let i = 1; i <= n; ++i) {\n        total_xor ^= i;\n    }\n    let encoded_xor = 0;\n    for (let i = 1; i < n - 1; i += 2) {\n        encoded_xor ^= encoded[i];\n    }\n    const perm = [total_xor ^ encoded_xor];\n    for (let i = 1; i < n; ++i) {\n        perm.push(perm[i - 1] ^ encoded[i - 1]);\n    }\n    return perm;\n}\n```\n\n    \n    1. Calculate the XOR of all integers from 1 to n (inclusive), and store it in the `total_xor` variable.\n2. Calculate the XOR of all elements of the encoded array with odd indices (starting from index 1), and store it in the `encoded_xor` variable.\n3. The first element of the perm array is calculated by XOR'ing `total_xor` and `encoded_xor`.\n4. Loop through the range 1 to n-1 (inclusive) and calculate the rest of the perm array elements using the following formula: `perm[i] = perm[i - 1] ^ encoded[i - 1]`.\n5. Return the reconstructed perm array.\n    "
    },
    {
        "id": 304,
        "title": "Maximum Building Height",
        "difficulty": "Hard",
        "content": {
            "problem": "You want to build `n` new buildings in a city. The new buildings will be built in a line and are labeled from `1` to `n`.\n\nHowever, there are city restrictions on the heights of the new buildings:\n\n*   The height of each building must be a non-negative integer.\n*   The height of the first building **must** be `0`.\n*   The height difference between any two adjacent buildings **cannot exceed** `1`.\n\nAdditionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array `restrictions` where `restrictions[i] = [idi, maxHeighti]` indicates that building `idi` must have a height **less than or equal to** `maxHeighti`.\n\nIt is guaranteed that each building will appear **at most once** in `restrictions`, and building `1` will **not** be in `restrictions`.\n\nReturn _the **maximum possible height** of the **tallest** building_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, restrictions = \\[\\[2,1\\],\\[4,1\\]\\]\n**Output:** 2\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,1,2\\], and the tallest building has a height of 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 6, restrictions = \\[\\]\n**Output:** 5\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,3,4,5\\], and the tallest building has a height of 5.\n\n",
                "**Example 3:**\n\n**Input:** n = 10, restrictions = \\[\\[5,3\\],\\[2,5\\],\\[7,4\\],\\[10,3\\]\\]\n**Output:** 5\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,3,3,4,4,5,4,3\\], and the tallest building has a height of 5."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 109`\n*   `0 <= restrictions.length <= min(n - 1, 105)`\n*   `2 <= idi <= n`\n*   `idi` is **unique**.\n*   `0 <= maxHeighti <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Sorting"
        ],
        "example": [
            {
                "input": "5,[[2,1],[4,1]]",
                "output": "2"
            },
            {
                "input": "6,[]",
                "output": "5"
            },
            {
                "input": "10,[[5,3],[2,5],[7,4],[10,3]]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    private void dfs(int node, int[] visited, Map<Integer, List<Integer>> graph, List<Integer> group) {\n        if (visited[node] == 1) return;\n        visited[node] = 1;\n        group.add(node);\n        for (int neighbor : graph.get(node)) dfs(neighbor, visited, graph, group);\n    }\n\n    public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {\n        int n = source.length;\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] swap : allowedSwaps) {\n            graph.computeIfAbsent(swap[0], k -> new ArrayList<>()).add(swap[1]);\n            graph.computeIfAbsent(swap[1], k -> new ArrayList<>()).add(swap[0]);\n        }\n\n        int res = 0;\n        int[] visited = new int[n];\n        for (int i = 0; i < n; ++i) {\n            if (visited[i] == 0) {\n                List<Integer> group = new ArrayList<>();\n                dfs(i, visited, graph, group);\n                Map<Integer, Integer> count = new HashMap<>();\n\n                for (int node : group) count.put(source[node], count.getOrDefault(source[node], 0) + 1);\n                for (int node : group) if (count.getOrDefault(target[node], 0) > 0) {\n                    res++;\n                    count.put(target[node], count.get(target[node]) - 1);\n                }\n            }\n        }\n        \n        return n - res;\n    }\n}\n```\n\n    \n    1. We build an adjacency list graph from the allowed swap pairs, so that we can traverse it later.\n2. We traverse the graph with a depth-first-search function (dfs) to find connected components.\n3. For each connected component, we count the occurrences of each value in the source array and store it in a dictionary.\n4. We iterate through the target array for the same connected component and decrement the count of target values in the dictionary. If the count is greater than 0, it means there is a match, and we increase the result by 1.\n5. Finally, we return the difference between the length of the arrays and the matched pairs count to compute the minimum Hamming distance.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, visited, graph, group):\n    if visited[node]:\n        return\n    visited[node] = 1\n    group.append(node)\n    for neighbor in graph[node]:\n        dfs(neighbor, visited, graph, group)\n\ndef minimumHammingDistance(source, target, allowedSwaps):\n    n = len(source)\n    graph = defaultdict(list)\n    for a, b in allowedSwaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    res = 0\n    visited = [0] * n\n    for i in range(n):\n        if not visited[i]:\n            group = []\n            dfs(i, visited, graph, group)\n            count = defaultdict(int)\n\n            for node in group:\n                count[source[node]] += 1\n            for node in group:\n                if count[target[node]] > 0:\n                    res += 1\n                    count[target[node]] -= 1\n\n    return n - res\n```\n\n    \n    1. We build an adjacency list graph from the allowed swap pairs, so that we can traverse it later.\n2. We traverse the graph with a depth-first-search function (dfs) to find connected components.\n3. For each connected component, we count the occurrences of each value in the source array and store it in a dictionary.\n4. We iterate through the target array for the same connected component and decrement the count of target values in the dictionary. If the count is greater than 0, it means there is a match, and we increase the result by 1.\n5. Finally, we return the difference between the length of the arrays and the matched pairs count to compute the minimum Hamming distance.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvoid dfs(int node, vector<int>& visited, unordered_map<int, vector<int>>& graph, vector<int>& group) {\n    if (visited[node]) return;\n    visited[node] = 1;\n    group.push_back(node);\n    for (int neighbor : graph[node]) dfs(neighbor, visited, graph, group);\n}\n\nint minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {\n    int n = source.size();\n    unordered_map<int, vector<int>> graph;\n    for (auto& swap : allowedSwaps) {\n        graph[swap[0]].push_back(swap[1]);\n        graph[swap[1]].push_back(swap[0]);\n    }\n\n    int res = 0;\n    vector<int> visited(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            vector<int> group;\n            dfs(i, visited, graph, group);\n            unordered_map<int, int> count;\n\n            for (int node : group) count[source[node]]++;\n            for (int node : group) if (count[target[node]]-- > 0) res++;\n        }\n    }\n    \n    return n - res;\n}\n```\n\n    \n    1. We build an adjacency list graph from the allowed swap pairs, so that we can traverse it later.\n2. We traverse the graph with a depth-first-search function (dfs) to find connected components.\n3. For each connected component, we count the occurrences of each value in the source array and store it in a dictionary.\n4. We iterate through the target array for the same connected component and decrement the count of target values in the dictionary. If the count is greater than 0, it means there is a match, and we increase the result by 1.\n5. Finally, we return the difference between the length of the arrays and the matched pairs count to compute the minimum Hamming distance.\n    ",
        "js": "\n    ```javascript\nfunction minimumHammingDistance(source, target, allowedSwaps) {\n    const n = source.length;\n    const graph = new Map();\n\n    for (const [a, b] of allowedSwaps) {\n        if (!graph.has(a)) graph.set(a, []);\n        if (!graph.has(b)) graph.set(b, []);\n        graph.get(a).push(b);\n        graph.get(b).push(a);\n    }\n\n    function dfs(node, visited, group) {\n        if (visited[node]) return;\n        visited[node] = 1;\n        group.push(node);\n        for (const neighbor of (graph.get(node) || [])) dfs(neighbor, visited, group);\n    }\n\n    let res = 0;\n    const visited = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            const group = [];\n            dfs(i, visited, group);\n            const count = new Map();\n\n            for (const node of group) count.set(source[node], (count.get(source[node]) || 0) + 1);\n            for (const node of group) {\n                if (count.get(target[node]) > 0) {\n                    res++;\n                    count.set(target[node], count.get(target[node]) - 1);\n                }\n            }\n        }\n    }\n\n    return n - res;\n}\n```\n\n    \n    1. We build an adjacency list graph from the allowed swap pairs, so that we can traverse it later.\n2. We traverse the graph with a depth-first-search function (dfs) to find connected components.\n3. For each connected component, we count the occurrences of each value in the source array and store it in a dictionary.\n4. We iterate through the target array for the same connected component and decrement the count of target values in the dictionary. If the count is greater than 0, it means there is a match, and we increase the result by 1.\n5. Finally, we return the difference between the length of the arrays and the matched pairs count to compute the minimum Hamming distance.\n    "
    },
    {
        "id": 305,
        "title": "Closest Room",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a hotel with `n` rooms. The rooms are represented by a 2D integer array `rooms` where `rooms[i] = [roomIdi, sizei]` denotes that there is a room with room number `roomIdi` and size equal to `sizei`. Each `roomIdi` is guaranteed to be **unique**.\n\nYou are also given `k` queries in a 2D array `queries` where `queries[j] = [preferredj, minSizej]`. The answer to the `jth` query is the room number `id` of a room such that:\n\n*   The room has a size of **at least** `minSizej`, and\n*   `abs(id - preferredj)` is **minimized**, where `abs(x)` is the absolute value of `x`.\n\nIf there is a **tie** in the absolute difference, then use the room with the **smallest** such `id`. If there is **no such room**, the answer is `-1`.\n\nReturn _an array_ `answer` _of length_ `k` _where_ `answer[j]` _contains the answer to the_ `jth` _query_.",
            "examples": [
                "**Example 1:**\n\n**Input:** rooms = \\[\\[2,2\\],\\[1,2\\],\\[3,2\\]\\], queries = \\[\\[3,1\\],\\[3,3\\],\\[5,2\\]\\]\n**Output:** \\[3,-1,3\\]\n**Explanation:** The answers to the queries are as follows:\nQuery = \\[3,1\\]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.\nQuery = \\[3,3\\]: There are no rooms with a size of at least 3, so the answer is -1.\nQuery = \\[5,2\\]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.\n\n",
                "**Example 2:**\n\n**Input:** rooms = \\[\\[1,4\\],\\[2,3\\],\\[3,5\\],\\[4,1\\],\\[5,2\\]\\], queries = \\[\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[2,1,3\\]\n**Explanation:** The answers to the queries are as follows:\nQuery = \\[2,3\\]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.\nQuery = \\[2,4\\]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.\nQuery = \\[2,5\\]: Room number 3 is the only room with a size of at least 5. The answer is 3."
            ],
            "constraints": "**Constraints:**\n\n*   `n == rooms.length`\n*   `1 <= n <= 105`\n*   `k == queries.length`\n*   `1 <= k <= 104`\n*   `1 <= roomIdi, preferredj <= 107`\n*   `1 <= sizei, minSizej <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sorting",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[2,2],[1,2],[3,2]],[[3,1],[3,3],[5,2]]",
                "output": "[3,-1,3]"
            },
            {
                "input": "[[1,4],[2,3],[3,5],[4,1],[5,2]],[[2,3],[2,4],[2,5]]",
                "output": "[2,1,3]"
            }
        ],
        "java": "\n    \n```java\nimport java.util.*;\n\nclass Solution {\n    public int[] closestRoom(int[][] rooms, int[][] queries) {\n        Arrays.sort(rooms, (a, b) -> b[1] - a[1]);\n        int[] result = new int[queries.length];\n\n        for (int i = 0; i < queries.length; ++i) {\n            int[] q = new int[]{queries[i][0], queries[i][1], i};\n            queries[i] = q;\n        }\n        \n        Arrays.sort(queries, (a, b) -> b[1] - a[1]);\n        \n        TreeSet<Integer> ids = new TreeSet<>();\n        int j = 0;\n        for (int[] q : queries) {\n            while (j < rooms.length && rooms[j][1] >= q[1]) {\n                ids.add(rooms[j++][0]);\n            }\n            if (ids.isEmpty()) {\n                result[q[2]] = -1;\n            } else {\n                Integer cid1 = ids.ceiling(q[0]);\n                Integer cid2 = ids.floor(q[0]);\n                if (cid1 == null) {\n                    result[q[2]] = cid2;\n                } else if (cid2 == null) {\n                    result[q[2]] = cid1;\n                } else {\n                    result[q[2]] = (q[0] - cid2 <= cid1 - q[0]) ? cid2 : cid1;\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n```\n\n    \n    \n1. Sort the rooms by size in descending order.\n2. Sort the queries by minOccurs in descending order.\n3. Iterate over the sorted queries, maintaining a sorted set of available room ids meeting the minOccurs requirement for the current query (by adding ids from the sorted rooms list when the corresponding room is large enough).\n4. For each query, find the closest available id (if any) by searching the sorted set for the value closest to the preferred room number.\n5. Return the answers in the original order of the queries.\n\n    ",
        "js": "\n    \n```javascript\nfunction closestRoom(rooms, queries) {\n    rooms.sort((a, b) => b[1] - a[1]);\n    \n    for (let i = 0; i < queries.length; ++i) {\n        queries[i].push(i);\n    }\n    \n    queries.sort((a, b) => b[1] - a[1]);\n    \n    let result = new Array(queries.length);\n    let ids = new Set();\n    \n    let j = 0;\n    for (const q of queries) {\n        while (j < rooms.length && rooms[j][1] >= q[1]) {\n            ids.add(rooms[j++][0]);\n        }\n        if (ids.size === 0) {\n            result[q[2]] = -1;\n        } else {\n            let minAbsDiff = Infinity;\n            let minId = undefined;\n            for (let id = q[0]; id <= 10000000; ++id) {\n                if (ids.has(id) && Math.abs(id-q[0]) < minAbsDiff) {\n                    minAbsDiff = Math.abs(id - q[0]);\n                    minId = id;\n                }\n                if (ids.has(id-1) && Math.abs(id-1-q[0]) < minAbsDiff) {\n                    minAbsDiff = Math.abs(id - 1 - q[0]);\n                    minId = id - 1;\n                }\n                if (minId !== undefined)\n                    break;\n            }\n            result[q[2]] = minId;\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    \n1. Sort the rooms by size in descending order.\n2. Sort the queries by minOccurs in descending order.\n3. Iterate over the sorted queries, maintaining a sorted set of available room ids meeting the minOccurs requirement for the current query (by adding ids from the sorted rooms list when the corresponding room is large enough).\n4. For each query, find the closest available id (if any) by searching the sorted set for the value closest to the preferred room number.\n5. Return the answers in the original order of the queries.\n\n    ",
        "c++": "\n    \n```cpp\n#include <vector>\n#include <set>\n#include <limits>\nusing namespace std;\n\nvector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {\n    sort(rooms.begin(), rooms.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[1] > b[1];\n    });\n    \n    vector<int> result(queries.size());\n    for (int i = 0; i < queries.size(); ++i) {\n        queries[i].push_back(i);\n    }\n    \n    sort(queries.begin(), queries.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[1] > b[1];\n    });\n    \n    set<int> ids;\n    int j = 0;\n    for (const auto& q : queries) {\n        while (j < rooms.size() && rooms[j][1] >= q[1]) {\n            ids.insert(rooms[j++][0]);\n        }\n        if (ids.empty()) {\n            result[q[2]] = -1;\n        } else {\n            int closestDiff = numeric_limits<int>::max();\n            int closestId = -1;\n            for (int id : {q[0], *ids.upper_bound(q[0]), *prev(ids.upper_bound(q[0]))}) {\n                if (ids.count(id)) {\n                    int diff = abs(id - q[0]);\n                    if (diff < closestDiff) {\n                        closestDiff = diff;\n                        closestId = id;\n                    }\n                }\n            }\n            result[q[2]] = closestId;\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    \n1. Sort the rooms by size in descending order.\n2. Sort the queries by minOccurs in descending order.\n3. Iterate over the sorted queries, maintaining a sorted set of available room ids meeting the minOccurs requirement for the current query (by adding ids from the sorted rooms list when the corresponding room is large enough).\n4. For each query, find the closest available id (if any) by searching the sorted set for the value closest to the preferred room number.\n5. Return the answers in the original order of the queries.\n\n    ",
        "python": "\n    \n```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:\n        rooms.sort(key=lambda x: -x[1])\n        ans = [0] * len(queries)\n\n        for idx, q in enumerate(queries):\n            q.append(idx)\n        queries.sort(key=lambda x: -x[1])\n\n        ids = []\n        j = 0\n        for q in queries:\n            while j < len(rooms) and rooms[j][1] >= q[1]:\n                bisect.insort(ids, rooms[j][0])\n                j += 1\n            if not ids:\n                ans[q[2]] = -1\n            else:\n                k = bisect.bisect_left(ids, q[0])\n                choices = [k-1, k] if k > 0 else [k]\n                closest_idx = min(choices, key=lambda x: abs(ids[x]-q[0]))\n                ans[q[2]] = ids[closest_idx]\n\n        return ans\n```\n\n    \n    \n1. Sort the rooms by size in descending order.\n2. Sort the queries by minOccurs in descending order.\n3. Iterate over the sorted queries, maintaining a sorted set of available room ids meeting the minOccurs requirement for the current query (by adding ids from the sorted rooms list when the corresponding room is large enough).\n4. For each query, find the closest available id (if any) by searching the sorted set for the value closest to the preferred room number.\n5. Return the answers in the original order of the queries.\n\n    "
    },
    {
        "id": 306,
        "title": "Minimum Interval to Include Each Query",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D integer array `intervals`, where `intervals[i] = [lefti, righti]` describes the `ith` interval starting at `lefti` and ending at `righti` **(inclusive)**. The **size** of an interval is defined as the number of integers it contains, or more formally `righti - lefti + 1`.\n\nYou are also given an integer array `queries`. The answer to the `jth` query is the **size of the smallest interval** `i` such that `lefti <= queries[j] <= righti`. If no such interval exists, the answer is `-1`.\n\nReturn _an array containing the answers to the queries_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[2,4\\],\\[3,6\\],\\[4,4\\]\\], queries = \\[2,3,4,5\\]\n**Output:** \\[3,3,1,4\\]\n**Explanation:** The queries are processed as follows:\n- Query = 2: The interval \\[2,4\\] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval \\[2,4\\] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval \\[4,4\\] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval \\[3,6\\] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[2,3\\],\\[2,5\\],\\[1,8\\],\\[20,25\\]\\], queries = \\[2,19,5,22\\]\n**Output:** \\[2,-1,4,6\\]\n**Explanation:** The queries are processed as follows:\n- Query = 2: The interval \\[2,3\\] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval \\[2,5\\] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval \\[20,25\\] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `1 <= queries.length <= 105`\n*   `intervals[i].length == 2`\n*   `1 <= lefti <= righti <= 107`\n*   `1 <= queries[j] <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Line Sweep",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[[1,4],[2,4],[3,6],[4,4]],[2,3,4,5]",
                "output": "[3,3,1,4]"
            },
            {
                "input": "[[2,3],[2,5],[1,8],[20,25]],[2,19,5,22]",
                "output": "[2,-1,4,6]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\nclass Solution {\n    public int maxValue(int[][] events, int k) {\n        Arrays.sort(events, (a, b) -> a[1] - b[1]);\n        int n = events.length;\n        int[][] dp = new int[n + 1][k + 1];\n\n        for (int i = 1; i <= n; i++) {\n            int start = -1;\n            for (int j = i - 1; j >= 1; j--) {\n                if (events[j - 1][1] < events[i - 1][0]) {\n                    start = j;\n                    break;\n                }\n            }\n\n            for (int j = 1; j <= k; j++) {\n                if (start == -1) {\n                    dp[i][j] = Math.max(dp[i - 1][j], events[i - 1][2]);\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2]);\n                }\n            }\n        }\n\n        return dp[n][k];\n    }\n}\n```\n\n    \n    1. Sort the events based on their end day.\n2. Initialize a 2D array dp to store the maximum sum of values for choosing a number of events.\n3. Iterate through the sorted events, and for each event find the latest non-overlapping event.\n4. Iterate through 1 to k, and for each count of events to attend, update the dp array using the latest non-overlapping event.\n5. Return the maximum sum of values found in the dp array for attending k events.\n    ",
        "python": "\n    ```python\nfrom bisect import bisect_left\n\ndef maxValue(events, k):\n    events.sort(key=lambda x: x[1])\n    n = len(events)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        start = -1\n        for j in range(i - 1, 0, -1):\n            if events[j - 1][1] < events[i - 1][0]:\n                start = j\n                break\n\n        for j in range(1, k + 1):\n            if start == -1:\n                dp[i][j] = max(dp[i - 1][j], events[i - 1][2])\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2])\n\n    return dp[n][k]\n```\n\n    \n    1. Sort the events based on their end day.\n2. Initialize a 2D array dp to store the maximum sum of values for choosing a number of events.\n3. Iterate through the sorted events, and for each event find the latest non-overlapping event.\n4. Iterate through 1 to k, and for each count of events to attend, update the dp array using the latest non-overlapping event.\n5. Return the maximum sum of values found in the dp array for attending k events.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool compare(vector<int>& a, vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint maxValue(vector<vector<int>>& events, int k) {\n    sort(events.begin(), events.end(), compare);\n    int n = events.size();\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        int start = -1;\n        for (int j = i - 1; j >= 1; j--) {\n            if(events[j - 1][1] < events[i - 1][0]) {\n                start = j;\n                break;\n            }\n        }\n\n        for (int j = 1; j <= k; j++) {\n            if (start == -1) {\n                dp[i][j] = max(dp[i - 1][j], events[i - 1][2]);\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2]);\n            }\n        }\n    }\n\n    return dp[n][k];\n}\n```\n\n    \n    1. Sort the events based on their end day.\n2. Initialize a 2D array dp to store the maximum sum of values for choosing a number of events.\n3. Iterate through the sorted events, and for each event find the latest non-overlapping event.\n4. Iterate through 1 to k, and for each count of events to attend, update the dp array using the latest non-overlapping event.\n5. Return the maximum sum of values found in the dp array for attending k events.\n    ",
        "js": "\n    ```javascript\nfunction maxValue(events, k) {\n  events.sort((a, b) => a[1] - b[1]);\n  const n = events.length;\n  const dp = Array.from({ length: n + 1 }, () => new Array(k + 1).fill(0));\n\n  for (let i = 1; i <= n; i++) {\n    let start = -1;\n    for (let j = i - 1; j >= 1; j--) {\n      if (events[j - 1][1] < events[i - 1][0]) {\n        start = j;\n        break;\n      }\n    }\n\n    for (let j = 1; j <= k; j++) {\n      if (start === -1) {\n        dp[i][j] = Math.max(dp[i - 1][j], events[i - 1][2]);\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2]);\n      }\n    }\n  }\n\n  return dp[n][k];\n}\n```\n\n    \n    1. Sort the events based on their end day.\n2. Initialize a 2D array dp to store the maximum sum of values for choosing a number of events.\n3. Iterate through the sorted events, and for each event find the latest non-overlapping event.\n4. Iterate through 1 to k, and for each count of events to attend, update the dp array using the latest non-overlapping event.\n5. Return the maximum sum of values found in the dp array for attending k events.\n    "
    },
    {
        "id": 307,
        "title": "Largest Color Value in a Directed Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a **directed graph** of `n` colored nodes and `m` edges. The nodes are numbered from `0` to `n - 1`.\n\nYou are given a string `colors` where `colors[i]` is a lowercase English letter representing the **color** of the `ith` node in this graph (**0-indexed**). You are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that there is a **directed edge** from node `aj` to node `bj`.\n\nA valid **path** in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk` such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`. The **color value** of the path is the number of nodes that are colored the **most frequently** occurring color along that path.\n\nReturn _the **largest color value** of any valid path in the given graph, or_ `-1` _if the graph contains a cycle_.",
            "examples": [
                "**Example 1:**\n\n**Input:** colors =  \"abaca \", edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 3\n**Explanation:** The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored ` \"a \" (red in the above image)`.\n\n",
                "**Example 2:**\n\n**Input:** colors =  \"a \", edges = \\[\\[0,0\\]\\]\n**Output:** -1\n**Explanation:** There is a cycle from 0 to 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == colors.length`\n*   `m == edges.length`\n*   `1 <= n <= 105`\n*   `0 <= m <= 105`\n*   `colors` consists of lowercase English letters.\n*   `0 <= aj, bj < n`",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Dynamic Programming",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Counting"
        ],
        "example": [
            {
                "input": "\"abaca\",[[0,1],[0,2],[2,3],[3,4]]",
                "output": "3"
            },
            {
                "input": "\"a\",[[0,0]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int largestPathValue(String colors, int[][] edges) {\n        int n = colors.length();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        int[] inDegrees = new int[n];\n        for (int[] e : edges) {\n            adj.get(e[0]).add(e[1]);\n            inDegrees[e[1]]++;\n        }\n\n        int[][] colorCounts = new int[n][26];\n        Deque<Integer> queue = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegrees[i] == 0) {\n                queue.addLast(i);\n            }\n        }\n\n        int visitedNodes = 0;\n        int maxColorValue = 0;\n\n        while (!queue.isEmpty()) {\n            int node = queue.removeLast();\n            int color = colors.charAt(node) - 'a';\n            visitedNodes++;\n\n            for (int neighbor : adj.get(node)) {\n                for (int c = 0; c < 26; c++) {\n                    int count = colorCounts[node][c] + (c == color ? 1 : 0);\n                    colorCounts[neighbor][c] = Math.max(colorCounts[neighbor][c], count);\n                    maxColorValue = Math.max(maxColorValue, count);\n                }\n                if (--inDegrees[neighbor] == 0) {\n                    queue.addLast(neighbor);\n                }\n            }\n        }\n\n        return visitedNodes == n ? maxColorValue : -1;\n    }\n}\n```\n\n    \n    We will use the Kahn's algorithm for topological sort to solve this problem. Before starting the algorithm, create an adjacency list representation of the graph and calculate the in-degrees of all nodes.\n\n1. Create an array `colorCounts` of size `n x 26`, where `colorCounts[i][j]` will store the maximum color count of color `j` reachable from node `i` in the given graph.\n2. Initialize the `queue` with nodes having 0 in-degree.\n3. Initialize `visitedNodes` and `maxColorValue` to 0.\n4. While the `queue` is not empty, remove a node. Increment `visitedNodes`.\n5. For each neighbor of the removed node, update the color count reachable using this path. If a path with a higher color count is found, update the `maxColorValue`.\n6. If a neighbor's in-degree becomes 0, add it to the `queue`.\n7. Return the `maxColorValue` if all nodes were visited. Otherwise, there's a cycle in the graph, return -1.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef largestPathValue(colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    adj = [[] for _ in range(n)]\n    \n    in_degrees = [0] * n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        in_degrees[e[1]] += 1\n        \n    color_counts = [[0] * 26 for _ in range(n)]\n    queue = deque()\n    \n    for i in range(n):\n        if in_degrees[i] == 0:\n            queue.append(i)\n            \n    visited_nodes = 0\n    max_color_value = 0\n    \n    while queue:\n        node = queue.pop()\n        color = ord(colors[node]) - ord('a')\n        visited_nodes += 1\n        \n        for neighbor in adj[node]:\n            for c in range(26):\n                count = color_counts[node][c] + (c == color)\n                color_counts[neighbor][c] = max(color_counts[neighbor][c], count)\n                max_color_value = max(max_color_value, count)\n                \n            in_degrees[neighbor] -= 1\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n                \n    return max_color_value if visited_nodes == n else -1\n```\n\n    \n    We will use the Kahn's algorithm for topological sort to solve this problem. Before starting the algorithm, create an adjacency list representation of the graph and calculate the in-degrees of all nodes.\n\n1. Create an array `colorCounts` of size `n x 26`, where `colorCounts[i][j]` will store the maximum color count of color `j` reachable from node `i` in the given graph.\n2. Initialize the `queue` with nodes having 0 in-degree.\n3. Initialize `visitedNodes` and `maxColorValue` to 0.\n4. While the `queue` is not empty, remove a node. Increment `visitedNodes`.\n5. For each neighbor of the removed node, update the color count reachable using this path. If a path with a higher color count is found, update the `maxColorValue`.\n6. If a neighbor's in-degree becomes 0, add it to the `queue`.\n7. Return the `maxColorValue` if all nodes were visited. Otherwise, there's a cycle in the graph, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nint largestPathValue(string colors, vector<vector<int>>& edges) {\n    int n = colors.size();\n    vector<vector<int>> adj(n);\n    vector<int> inDegrees(n, 0);\n\n    for (auto& e : edges) {\n        adj[e[0]].push_back(e[1]);\n        inDegrees[e[1]]++;\n    }\n\n    vector<vector<int>> colorCounts(n, vector<int>(26, 0));\n    vector<int> queue;\n    for (int i = 0; i < n; i++) {\n        if (inDegrees[i] == 0) {\n            queue.push_back(i);\n        }\n    }\n\n    int visitedNodes = 0;\n    int maxColorValue = 0;\n\n    while (!queue.empty()) {\n        int node = queue.back();\n        queue.pop_back();\n        int color = colors[node] - 'a';\n        visitedNodes++;\n\n        for (int neighbor : adj[node]) {\n            for (int c = 0; c < 26; c++) {\n                int count = colorCounts[node][c] + (c == color);\n                colorCounts[neighbor][c] = max(colorCounts[neighbor][c], count);\n                maxColorValue = max(maxColorValue, count);\n            }\n            if (--inDegrees[neighbor] == 0) {\n                queue.push_back(neighbor);\n            }\n        }\n    }\n\n    return visitedNodes == n ? maxColorValue : -1;\n}\n```\n\n    \n    We will use the Kahn's algorithm for topological sort to solve this problem. Before starting the algorithm, create an adjacency list representation of the graph and calculate the in-degrees of all nodes.\n\n1. Create an array `colorCounts` of size `n x 26`, where `colorCounts[i][j]` will store the maximum color count of color `j` reachable from node `i` in the given graph.\n2. Initialize the `queue` with nodes having 0 in-degree.\n3. Initialize `visitedNodes` and `maxColorValue` to 0.\n4. While the `queue` is not empty, remove a node. Increment `visitedNodes`.\n5. For each neighbor of the removed node, update the color count reachable using this path. If a path with a higher color count is found, update the `maxColorValue`.\n6. If a neighbor's in-degree becomes 0, add it to the `queue`.\n7. Return the `maxColorValue` if all nodes were visited. Otherwise, there's a cycle in the graph, return -1.\n    ",
        "js": "\n    ```javascript\nfunction largestPathValue(colors, edges) {\n    const n = colors.length;\n    const adj = Array.from({ length: n }, () => []);\n    const inDegrees = Array(n).fill(0);\n\n    for (const e of edges) {\n        adj[e[0]].push(e[1]);\n        inDegrees[e[1]]++;\n    }\n\n    const colorCounts = Array.from({ length: n }, () => Array(26).fill(0));\n    const queue = [];\n\n    for (let i = 0; i < n; i++) {\n        if (inDegrees[i] === 0) {\n            queue.push(i);\n        }\n    }\n\n    let visitedNodes = 0;\n    let maxColorValue = 0;\n\n    while (queue.length > 0) {\n        const node = queue.pop();\n        const color = colors.charCodeAt(node) - 'a'.charCodeAt();\n        visitedNodes++;\n\n        for (const neighbor of adj[node]) {\n            for (let c = 0; c < 26; c++) {\n                const count = colorCounts[node][c] + (c === color ? 1 : 0);\n                colorCounts[neighbor][c] = Math.max(colorCounts[neighbor][c], count);\n                maxColorValue = Math.max(maxColorValue, count);\n            }\n            if (--inDegrees[neighbor] === 0) {\n                queue.push(neighbor);\n            }\n        }\n    }\n\n    return visitedNodes === n ? maxColorValue : -1;\n}\n```\n\n    \n    We will use the Kahn's algorithm for topological sort to solve this problem. Before starting the algorithm, create an adjacency list representation of the graph and calculate the in-degrees of all nodes.\n\n1. Create an array `colorCounts` of size `n x 26`, where `colorCounts[i][j]` will store the maximum color count of color `j` reachable from node `i` in the given graph.\n2. Initialize the `queue` with nodes having 0 in-degree.\n3. Initialize `visitedNodes` and `maxColorValue` to 0.\n4. While the `queue` is not empty, remove a node. Increment `visitedNodes`.\n5. For each neighbor of the removed node, update the color count reachable using this path. If a path with a higher color count is found, update the `maxColorValue`.\n6. If a neighbor's in-degree becomes 0, add it to the `queue`.\n7. Return the `maxColorValue` if all nodes were visited. Otherwise, there's a cycle in the graph, return -1.\n    "
    },
    {
        "id": 308,
        "title": "Sum of Floored Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return the sum of `floor(nums[i] / nums[j])` for all pairs of indices `0 <= i, j < nums.length` in the array. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nThe `floor()` function returns the integer part of the division.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,5,9\\]\n**Output:** 10\n**Explanation:**\nfloor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0\nfloor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1\nfloor(5 / 2) = 2\nfloor(9 / 2) = 4\nfloor(9 / 5) = 1\nWe calculate the floor of the division for every pair of indices in the array then sum them up.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,7,7,7,7,7,7\\]\n**Output:** 49"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Binary Search",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,5,9]",
                "output": "10"
            },
            {
                "input": "[7,7,7,7,7,7,7]",
                "output": "49"
            }
        ],
        "java": "\n    ```java\npublic int sumOfFlooredPairs(int[] nums) {\n    final int MOD = 1000000007;\n    int n = nums.length;\n    int maxElement = Arrays.stream(nums).max().getAsInt();\n    long[] cnt = new long[maxElement + 1];\n    for (int num : nums)\n        cnt[num]++;\n    for (int i = 1; i <= maxElement; i++)\n        cnt[i] += cnt[i - 1];\n    \n    long res = 0;\n    for (int num : nums) {\n        for (int j = 1, k = 1; k <= maxElement; j++, k += num) {\n            res += j * (cnt[Math.min(k + num - 1, maxElement)] - cnt[k - 1]);\n            res %= MOD;\n        }\n    }\n    \n    return (int) res;\n}\n```\n    \n    First, we count the occurrence of each element in the given array and store those counts in a new array `cnt`. Then we calculate the prefix sum array of `cnt`. After that, we iterate through each element in the input array, and for each element `num`, we iterate through integer `j` and `k` with a step of `num` that ranges from `1` to the `max_element`. In each iteration, we calculate `j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])` and add it to the result. Finally, we return the result modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef sum_of_floored_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_element = max(nums)\n    cnt = [0] * (max_element + 1)\n    for num in nums:\n        cnt[num] += 1\n    for i in range(1, max_element + 1):\n        cnt[i] += cnt[i - 1]\n\n    res = 0\n    for num in nums:\n        j, k = 1, 1\n        while k <= max_element:\n            res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])\n            res %= MOD\n            j += 1\n            k += num\n\n    return res\n```\n    \n    First, we count the occurrence of each element in the given array and store those counts in a new array `cnt`. Then we calculate the prefix sum array of `cnt`. After that, we iterate through each element in the input array, and for each element `num`, we iterate through integer `j` and `k` with a step of `num` that ranges from `1` to the `max_element`. In each iteration, we calculate `j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])` and add it to the result. Finally, we return the result modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\nint sumOfFloooredPairs(vector<int>& nums) {\n    const int MOD = 1e9 + 7;\n    int n = nums.size();\n    int max_element = *max_element(nums.begin(), nums.end());\n    vector<long long> cnt(max_element + 1, 0);\n    for (int num : nums)\n        cnt[num]++;\n    for (int i = 1; i <= max_element; i++)\n        cnt[i] += cnt[i - 1];\n    \n    long long res = 0;\n    for (int num : nums) {\n        for (int j = 1, k = 1; k <= max_element; j++, k += num) {\n            res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1]);\n            res %= MOD;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    First, we count the occurrence of each element in the given array and store those counts in a new array `cnt`. Then we calculate the prefix sum array of `cnt`. After that, we iterate through each element in the input array, and for each element `num`, we iterate through integer `j` and `k` with a step of `num` that ranges from `1` to the `max_element`. In each iteration, we calculate `j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])` and add it to the result. Finally, we return the result modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction sumOfFlooredPairs(nums) {\n    const MOD = 1e9 + 7;\n    const n = nums.length;\n    const maxElement = Math.max(...nums);\n    const cnt = new Array(maxElement + 1).fill(0);\n    for (const num of nums)\n        cnt[num]++;\n    for (let i = 1; i <= maxElement; i++)\n        cnt[i] += cnt[i - 1];\n    \n    let res = 0;\n    for (const num of nums) {\n        for (let j = 1, k = 1; k <= maxElement; j++, k += num) {\n            res += j * (cnt[Math.min(k + num - 1, maxElement)] - cnt[k - 1]);\n            res %= MOD;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    First, we count the occurrence of each element in the given array and store those counts in a new array `cnt`. Then we calculate the prefix sum array of `cnt`. After that, we iterate through each element in the input array, and for each element `num`, we iterate through integer `j` and `k` with a step of `num` that ranges from `1` to the `max_element`. In each iteration, we calculate `j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])` and add it to the result. Finally, we return the result modulo 10^9 + 7.\n    "
    },
    {
        "id": 309,
        "title": "Number of Ways to Rearrange Sticks With K Sticks Visible",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` uniquely-sized sticks whose lengths are integers from `1` to `n`. You want to arrange the sticks such that **exactly** `k` sticks are **visible** from the left. A stick is **visible** from the left if there are no **longer** sticks to the **left** of it.\n\n*   For example, if the sticks are arranged `[1,3,2,5,4]`, then the sticks with lengths `1`, `3`, and `5` are visible from the left.\n\nGiven `n` and `k`, return _the **number** of such arrangements_. Since the answer may be large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 3\n**Explanation:** \\[1,3,2\\], \\[2,3,1\\], and \\[2,1,3\\] are the only arrangements such that exactly 2 sticks are visible.\nThe visible sticks are underlined.\n\n",
                "**Example 2:**\n\n**Input:** n = 5, k = 5\n**Output:** 1\n**Explanation:** \\[1,2,3,4,5\\] is the only arrangement such that all 5 sticks are visible.\nThe visible sticks are underlined.\n\n",
                "**Example 3:**\n\n**Input:** n = 20, k = 11\n**Output:** 647427950\n**Explanation:** There are 647427950 (mod 109 \\+ 7) ways to rearrange the sticks such that exactly 11 sticks are visible."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `1 <= k <= n`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "3,2",
                "output": "3"
            },
            {
                "input": "5,5",
                "output": "1"
            },
            {
                "input": "20,11",
                "output": "647427950"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int[] restoreArray(int[][] adjacentPairs) {\n    Map<Integer, List<Integer>> graph = new HashMap<>();\n    for (int[] pair : adjacentPairs) {\n        graph.computeIfAbsent(pair[0], k -> new ArrayList<>()).add(pair[1]);\n        graph.computeIfAbsent(pair[1], k -> new ArrayList<>()).add(pair[0]);\n    }\n    int n = adjacentPairs.length + 1;\n    int[] nums = new int[n];\n    for (Map.Entry<Integer, List<Integer>> entry : graph.entrySet()) {\n        int key = entry.getKey();\n        List<Integer> nodes = entry.getValue();\n        if (nodes.size() == 1) {\n            nums[0] = key;\n            break;\n        }\n    }\n    nums[1] = graph.get(nums[0]).get(0);\n    for (int i = 2; i < n; i++) {\n        List<Integer> nodes = graph.get(nums[i - 1]);\n        nums[i] = nums[i - 2] == nodes.get(0) ? nodes.get(1) : nodes.get(0);\n    }\n    return nums;\n}\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef restoreArray(adjacentPairs):\n    graph = defaultdict(list)\n    for pair in adjacentPairs:\n        graph[pair[0]].append(pair[1])\n        graph[pair[1]].append(pair[0])\n\n    n = len(graph)\n    nums = [0] * n\n    for key, nodes in graph.items():\n        if len(nodes) == 1:\n            nums[0] = key\n            break\n\n    nums[1] = graph[nums[0]][0]\n    for i in range(2, n):\n        nums[i] = (graph[nums[i - 1]][1]\n                   if (nums[i - 2] == graph[nums[i - 1]][0])\n                   else graph[nums[i - 1]][0])\n\n    return nums\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> restoreArray(std::vector<std::vector<int>>& adjacentPairs) {\n    std::unordered_map<int, std::vector<int>> graph;\n    for (const auto& pair : adjacentPairs) {\n        graph[pair[0]].push_back(pair[1]);\n        graph[pair[1]].push_back(pair[0]);\n    }\n    std::vector<int> nums;\n    for (const auto& entry : graph) {\n        if (entry.second.size() == 1) {\n            nums.push_back(entry.first);\n            break;\n        }\n    }\n    nums.push_back(graph[nums[0]][0]);\n    for (int i = 2; i < graph.size(); ++i) {\n        int n = graph[nums.back()].size();\n        nums.push_back(nums.back() == graph[nums[i-2]][0] ? graph[nums[i-2]][1] : graph[nums[i-2]][0]);\n    }\n    return nums;\n}\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    ",
        "js": "\n    ```javascript\nfunction restoreArray(adjacentPairs) {\n    const graph = new Map();\n    for (const pair of adjacentPairs) {\n        if (!graph.has(pair[0])) {\n            graph.set(pair[0], []);\n        }\n        if (!graph.has(pair[1])) {\n            graph.set(pair[1], []);\n        }\n        graph.get(pair[0]).push(pair[1]);\n        graph.get(pair[1]).push(pair[0]);\n    }\n    const n = graph.size;\n    const nums = Array(n);\n    for (const [key, nodes] of graph.entries()) {\n        if (nodes.length === 1) {\n            nums[0] = key;\n            break;\n        }\n    }\n\n    nums[1] = graph.get(nums[0])[0];\n    for (let i = 2; i < n; i++) {\n        const nodes = graph.get(nums[i - 1]);\n        nums[i] = nums[i-2] === nodes[0] ? nodes[1] : nodes[0];\n    }\n    return nums;\n}\n```\n    \n    1. Create a graph represented by a hash map (or dictionary in Python) to store the adjacent nodes for each node.\n2. Iterate through the given adjacent pairs and update the graph by adding the corresponding adjacent nodes.\n3. Iterate through the graph and find a node with only one adjacent node (i.e., the first or last element of the original array), and set it as the first element of the resulting array.\n4. Starting from the second element of the resulting array, loop through and fill in the remaining elements based on the graph. For each element, choose the adjacent node that does not equal the previous element of the resulting array.\n5. Return the resulting array.\n    "
    },
    {
        "id": 310,
        "title": "Stone Game VIII",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following:\n\n1.  Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row.\n2.  Add the **sum** of the **removed** stones' values to the player's score.\n3.  Place a **new stone**, whose value is equal to that sum, on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._",
            "examples": [
                "**Example 1:**\n\n**Input:** stones = \\[-1,2,-3,4,-5\\]\n**Output:** 5\n**Explanation:**\n- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\n  value 2 on the left. stones = \\[2,-5\\].\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\n  the left. stones = \\[-3\\].\nThe difference between their scores is 2 - (-3) = 5.\n\n",
                "**Example 2:**\n\n**Input:** stones = \\[7,-6,5,10,5,-2,-6\\]\n**Output:** 13\n**Explanation:**\n- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\n  stone of value 13 on the left. stones = \\[13\\].\nThe difference between their scores is 13 - 0 = 13.\n\n",
                "**Example 3:**\n\n**Input:** stones = \\[-10,-12\\]\n**Output:** -22\n**Explanation:**\n- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\n  score and places a stone of value -22 on the left. stones = \\[-22\\].\nThe difference between their scores is (-22) - 0 = -22."
            ],
            "constraints": "**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 105`\n*   `-104 <= stones[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Prefix Sum",
            "Game Theory"
        ],
        "example": [
            {
                "input": "[-1,2,-3,4,-5]",
                "output": "5"
            },
            {
                "input": "[7,-6,5,10,5,-2,-6]",
                "output": "13"
            },
            {
                "input": "[-10,-12]",
                "output": "-22"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean[] canEat(int[] candiesCount, int[][] queries) {\n    long[] prefixSum = new long[candiesCount.length + 1];\n    for (int i = 0; i < candiesCount.length; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];\n    }\n\n    boolean[] result = new boolean[queries.length];\n    for (int i = 0; i < queries.length; ++i) {\n        int favoriteType = queries[i][0], favoriteDay = queries[i][1], dailyCap = queries[i][2];\n        long x1 = favoriteDay + 1;\n        long y1 = (favoriteDay + 1L) * dailyCap;\n\n        long x2 = prefixSum[favoriteType] + 1;\n        long y2 = prefixSum[favoriteType + 1];\n\n        result[i] = !(x1 > y2 || y1 < x2);\n    }\n\n    return result;\n}\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    ",
        "python": "\n    ```python\ndef can_eat(candiesCount, queries):\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<bool> canEat(std::vector<int>& candiesCount, std::vector<std::vector<int>>& queries) {\n    std::vector<long long> prefixSum(candiesCount.size() + 1);\n    for (int i = 0; i < candiesCount.size(); ++i) {\n        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];\n    }\n\n    std::vector<bool> result(queries.size());\n    for (int i = 0; i < queries.size(); ++i) {\n        int favoriteType = queries[i][0], favoriteDay = queries[i][1], dailyCap = queries[i][2];\n        long long x1 = favoriteDay + 1;\n        long long y1 = (favoriteDay + 1LL) * dailyCap;\n\n        long long x2 = prefixSum[favoriteType] + 1;\n        long long y2 = prefixSum[favoriteType + 1];\n\n        result[i] = !(x1 > y2 || y1 < x2);\n    }\n\n    return result;\n}\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    ",
        "js": "\n    ```javascript\nfunction canEat(candiesCount, queries) {\n    const prefixSum = new Array(candiesCount.length + 1).fill(0);\n    for (let i = 0; i < candiesCount.length; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];\n    }\n\n    const result = new Array(queries.length);\n    for (let i = 0; i < queries.length; ++i) {\n        const [favoriteType, favoriteDay, dailyCap] = queries[i];\n        const x1 = favoriteDay + 1;\n        const y1 = (favoriteDay + 1) * dailyCap;\n\n        const x2 = prefixSum[favoriteType] + 1;\n        const y2 = prefixSum[favoriteType + 1];\n\n        result[i] = !(x1 > y2 || y1 < x2);\n    }\n\n    return result;\n}\n```\n    \n    We first calculate the prefix sum of the candiesCount array, which represents the total number of candies we have before a certain type. Then, for each query, we calculate two pair of ranges, x1 to y1 and x2 to y2:\n\n- x1 to y1 is the range of candies the user can eat until the favorite day (inclusive) according to the daily cap.\n- x2 to y2 is the range of candies of the favorite type.\n\nIf these two ranges overlap, it means that it is possible to eat a candy of the favorite type on the favorite day without violating the daily cap.\n\nFinally, we iterate over each query and check if the calculated ranges overlap. If they do, we set the answer for the corresponding index in the result array to true, otherwise we set it to false. Then, we return the result array.\n    "
    },
    {
        "id": 311,
        "title": "Minimum XOR Sum of Two Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2` of length `n`.\n\nThe **XOR sum** of the two integer arrays is `(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])` (**0-indexed**).\n\n*   For example, the **XOR sum** of `[1,2,3]` and `[3,2,1]` is equal to `(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4`.\n\nRearrange the elements of `nums2` such that the resulting **XOR sum** is **minimized**.\n\nReturn _the **XOR sum** after the rearrangement_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[2,3\\]\n**Output:** 2\n**Explanation:** Rearrange `nums2` so that it becomes `[3,2]`.\nThe XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,0,3\\], nums2 = \\[5,3,4\\]\n**Output:** 8\n**Explanation:** Rearrange `nums2` so that it becomes `[5,4,3]`. \nThe XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length`\n*   `n == nums2.length`\n*   `1 <= n <= 14`\n*   `0 <= nums1[i], nums2[i] <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,2],[2,3]",
                "output": "2"
            },
            {
                "input": "[1,0,3],[5,3,4]",
                "output": "8"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int a, int b, int c) {\n    return (a + b + c - Math.max(a, Math.max(b, c))) / 2;\n}\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    ",
        "python": "\n    ```python\ndef max_score(a: int, b: int, c: int) -> int:\n    return (a + b + c - max(a, b, c)) // 2\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    ",
        "c++": "\n    ```cpp\nint maxScore(int a, int b, int c) {\n    return (a + b + c - std::max({a, b, c})) / 2;\n}\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    ",
        "js": "\n    ```javascript\nfunction maxScore(a, b, c) {\n    return (a + b + c - Math.max(a, Math.max(b, c))) / 2;\n}\n```\n\n    \n    The algorithm works by calculating the sum of all three piles `a`, `b`, and `c` and subtracting the size of the largest pile. Since we can only take stones from two different piles at a time, we cannot take stones from the largest pile after we've equalized the stones in the other two piles. So, by subtracting the size of the largest pile, we're essentially finding out the sum of the stones in the other two piles that can be used for scoring points. Finally, we divide our result by 2 since we need two stones to score a point. In Python, we use integer division `//` to get the result as an integer.\n\nThe key insight is that the optimal strategy is to always take stones from the two largest piles in every turn. This way, the pile sizes remain as matched as possible, ensuring we maximize the number of moves available to us. Since each move reduces the sum of the two largest piles by one, we can simplify the calculation as described above without enumerating each move explicitly. \n    "
    },
    {
        "id": 312,
        "title": "Minimum Skips to Arrive at Meeting On Time",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at.\n\nAfter you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.\n\n*   For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait.\n\nHowever, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.\n\n*   For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately.\n\nReturn _the **minimum number of skips required** to arrive at the meeting on time, or_ `-1` _if it is **impossible**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** dist = \\[1,3,2\\], speed = 4, hoursBefore = 2\n**Output:** 1\n**Explanation:**\nWithout skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\nYou can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.\nNote that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n\n",
                "**Example 2:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 2, hoursBefore = 10\n**Output:** 2\n**Explanation:**\nWithout skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\nYou can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.\n\n",
                "**Example 3:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 1, hoursBefore = 10\n**Output:** -1\n**Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests."
            ],
            "constraints": "**Constraints:**\n\n*   `n == dist.length`\n*   `1 <= n <= 1000`\n*   `1 <= dist[i] <= 105`\n*   `1 <= speed <= 106`\n*   `1 <= hoursBefore <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,3,2],4,2",
                "output": "1"
            },
            {
                "input": "[7,3,5,5],2,10",
                "output": "2"
            },
            {
                "input": "[7,3,5,5],1,10",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minSkips(int[] dist, int speed, int hoursBefore) {\n    int n = dist.length;\n    double[][] dp = new double[n + 1][n + 1];\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = 1e9;\n        }\n    }\n    dp[0][0] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = -1; j < i; j++) {\n            double t = dist[i] / (double)speed + (j != -1 ? 1 : 0);\n            dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j] + t);\n            double skipped_t = Math.ceil(dp[i][j] + dist[i] / (double)speed) - dp[i][j];\n            dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + skipped_t);\n        }\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        if (dp[n][i] <= hoursBefore) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n    \n    We will use dynamic programming to solve this problem. Our approach is to create a 2D DP array `dp`, where `dp[i][j]` will store the minimum time to reach road `i` by skipping `j` rest times.\n\n1. Initialize the DP array `dp` with a very large value (1e9) for all `i` and `j`, and set `dp[0][0]` to `0`, because initially we are at the starting point and have not skipped any rests.\n2. Iterate through all the roads `i` from `0` to `n-1`. For each road `i`, iterate through the number of rests skipped `j` from `-1` to `i-1` (inclusive).\n    1. Calculate the time `t` to travel the current road, taking into consideration whether we should wait for the next integer hour or not after completing the previous road. If `j` is equal to `-1`, there is no wait needed, otherwise there is a wait of `1` hour.\n    2. Update `dp[i+1][j+1]` by taking the minimum of its current value and the sum of `dp[i][j]` and `t`.\n    3. Calculate the time `skipped_t` to travel the current road if we skip the rest, which is equal to the ceiling of the sum of `dp[i][j]` and the travel time of the current road minus `dp[i][j]`.\n    4. Update `dp[i+1][j]` by taking the minimum of its current value and the sum of `dp[i][j]` and `skipped_t`.\n3. Iterate through the DP array `dp[n][i]` for all `i`, and find the minimum number of skips required to arrive at the meeting on time. If the time is less than or equal to `hoursBefore`, return `i`. If not found, return `-1`.\n\nTime complexity of this approach is O(n^2), and space complexity is also O(n^2) due to the DP array.\n    ",
        "python": "\n    ```python\ndef minSkips(dist, speed, hoursBefore):\n    n = len(dist)\n    dp = [[1e9] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(i+1):\n            t = dist[i] / speed + (1 if j else 0)\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)\n            skipped_t = -(-dist[i] / speed) - dp[i][j]\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)\n\n    for i in range(n + 1):\n        if dp[n][i] <= hoursBefore:\n            return i\n    return -1\n```\n    \n    We will use dynamic programming to solve this problem. Our approach is to create a 2D DP array `dp`, where `dp[i][j]` will store the minimum time to reach road `i` by skipping `j` rest times.\n\n1. Initialize the DP array `dp` with a very large value (1e9) for all `i` and `j`, and set `dp[0][0]` to `0`, because initially we are at the starting point and have not skipped any rests.\n2. Iterate through all the roads `i` from `0` to `n-1`. For each road `i`, iterate through the number of rests skipped `j` from `-1` to `i-1` (inclusive).\n    1. Calculate the time `t` to travel the current road, taking into consideration whether we should wait for the next integer hour or not after completing the previous road. If `j` is equal to `-1`, there is no wait needed, otherwise there is a wait of `1` hour.\n    2. Update `dp[i+1][j+1]` by taking the minimum of its current value and the sum of `dp[i][j]` and `t`.\n    3. Calculate the time `skipped_t` to travel the current road if we skip the rest, which is equal to the ceiling of the sum of `dp[i][j]` and the travel time of the current road minus `dp[i][j]`.\n    4. Update `dp[i+1][j]` by taking the minimum of its current value and the sum of `dp[i][j]` and `skipped_t`.\n3. Iterate through the DP array `dp[n][i]` for all `i`, and find the minimum number of skips required to arrive at the meeting on time. If the time is less than or equal to `hoursBefore`, return `i`. If not found, return `-1`.\n\nTime complexity of this approach is O(n^2), and space complexity is also O(n^2) due to the DP array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\nusing namespace std;\n\nint minSkips(vector<int>& dist, int speed, int hoursBefore) {\n    int n = dist.size();\n    vector<vector<double>> dp(n + 1, vector<double>(n + 1, 1e9));\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = -1; j < i; ++j) {\n            double t = dist[i] / double(speed) + (j != -1);\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t);\n            double skipped_t = ceil(dp[i][j] + dist[i] / double(speed)) - dp[i][j];\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t);\n        }\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        if (dp[n][i] <= hoursBefore) return i;\n    }\n    return -1;\n}\n```\n    \n    We will use dynamic programming to solve this problem. Our approach is to create a 2D DP array `dp`, where `dp[i][j]` will store the minimum time to reach road `i` by skipping `j` rest times.\n\n1. Initialize the DP array `dp` with a very large value (1e9) for all `i` and `j`, and set `dp[0][0]` to `0`, because initially we are at the starting point and have not skipped any rests.\n2. Iterate through all the roads `i` from `0` to `n-1`. For each road `i`, iterate through the number of rests skipped `j` from `-1` to `i-1` (inclusive).\n    1. Calculate the time `t` to travel the current road, taking into consideration whether we should wait for the next integer hour or not after completing the previous road. If `j` is equal to `-1`, there is no wait needed, otherwise there is a wait of `1` hour.\n    2. Update `dp[i+1][j+1]` by taking the minimum of its current value and the sum of `dp[i][j]` and `t`.\n    3. Calculate the time `skipped_t` to travel the current road if we skip the rest, which is equal to the ceiling of the sum of `dp[i][j]` and the travel time of the current road minus `dp[i][j]`.\n    4. Update `dp[i+1][j]` by taking the minimum of its current value and the sum of `dp[i][j]` and `skipped_t`.\n3. Iterate through the DP array `dp[n][i]` for all `i`, and find the minimum number of skips required to arrive at the meeting on time. If the time is less than or equal to `hoursBefore`, return `i`. If not found, return `-1`.\n\nTime complexity of this approach is O(n^2), and space complexity is also O(n^2) due to the DP array.\n    ",
        "js": "\n    ```javascript\nfunction minSkips(dist, speed, hoursBefore) {\n    const n = dist.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(n + 1).fill(1e9));\n    dp[0][0] = 0;\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = -1; j < i; j++) {\n            const t = dist[i] / speed + (j != -1 ? 1 : 0);\n            dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j] + t);\n            const skipped_t = Math.ceil(dp[i][j] + dist[i] / speed) - dp[i][j];\n            dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + skipped_t);\n        }\n    }\n    \n    for (let i = 0; i <= n; i++) {\n        if (dp[n][i] <= hoursBefore) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n    \n    We will use dynamic programming to solve this problem. Our approach is to create a 2D DP array `dp`, where `dp[i][j]` will store the minimum time to reach road `i` by skipping `j` rest times.\n\n1. Initialize the DP array `dp` with a very large value (1e9) for all `i` and `j`, and set `dp[0][0]` to `0`, because initially we are at the starting point and have not skipped any rests.\n2. Iterate through all the roads `i` from `0` to `n-1`. For each road `i`, iterate through the number of rests skipped `j` from `-1` to `i-1` (inclusive).\n    1. Calculate the time `t` to travel the current road, taking into consideration whether we should wait for the next integer hour or not after completing the previous road. If `j` is equal to `-1`, there is no wait needed, otherwise there is a wait of `1` hour.\n    2. Update `dp[i+1][j+1]` by taking the minimum of its current value and the sum of `dp[i][j]` and `t`.\n    3. Calculate the time `skipped_t` to travel the current road if we skip the rest, which is equal to the ceiling of the sum of `dp[i][j]` and the travel time of the current road minus `dp[i][j]`.\n    4. Update `dp[i+1][j]` by taking the minimum of its current value and the sum of `dp[i][j]` and `skipped_t`.\n3. Iterate through the DP array `dp[n][i]` for all `i`, and find the minimum number of skips required to arrive at the meeting on time. If the time is less than or equal to `hoursBefore`, return `i`. If not found, return `-1`.\n\nTime complexity of this approach is O(n^2), and space complexity is also O(n^2) due to the DP array.\n    "
    },
    {
        "id": 313,
        "title": "Minimum Space Wasted From Packaging",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` packages that you are trying to place in boxes, **one package in each box**. There are `m` suppliers that each produce boxes of **different sizes** (with infinite supply). A package can be placed in a box if the size of the package is **less than or equal to** the size of the box.\n\nThe package sizes are given as an integer array `packages`, where `packages[i]` is the **size** of the `ith` package. The suppliers are given as a 2D integer array `boxes`, where `boxes[j]` is an array of **box sizes** that the `jth` supplier produces.\n\nYou want to choose a **single supplier** and use boxes from them such that the **total wasted space** is **minimized**. For each package in a box, we define the space **wasted** to be `size of the box - size of the package`. The **total wasted space** is the sum of the space wasted in **all** the boxes.\n\n*   For example, if you have to fit packages with sizes `[2,3,5]` and the supplier offers boxes of sizes `[4,8]`, you can fit the packages of size-`2` and size-`3` into two boxes of size-`4` and the package with size-`5` into a box of size-`8`. This would result in a waste of `(4-2) + (4-3) + (8-5) = 6`.\n\nReturn _the **minimum total wasted space** by choosing the box supplier **optimally**, or_ `-1` _if it is **impossible** to fit all the packages inside boxes._ Since the answer may be **large**, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** packages = \\[2,3,5\\], boxes = \\[\\[4,8\\],\\[2,8\\]\\]\n**Output:** 6\n**Explanation**: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.\nThe total waste is (4-2) + (4-3) + (8-5) = 6.\n\n",
                "**Example 2:**\n\n**Input:** packages = \\[2,3,5\\], boxes = \\[\\[1,4\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** -1\n**Explanation:** There is no box that the package of size 5 can fit in.\n\n",
                "**Example 3:**\n\n**Input:** packages = \\[3,5,8,10,11,12\\], boxes = \\[\\[12\\],\\[11,9\\],\\[10,5,14\\]\\]\n**Output:** 9\n**Explanation:** It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.\nThe total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9."
            ],
            "constraints": "**Constraints:**\n\n*   `n == packages.length`\n*   `m == boxes.length`\n*   `1 <= n <= 105`\n*   `1 <= m <= 105`\n*   `1 <= packages[i] <= 105`\n*   `1 <= boxes[j].length <= 105`\n*   `1 <= boxes[j][k] <= 105`\n*   `sum(boxes[j].length) <= 105`\n*   The elements in `boxes[j]` are **distinct**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sorting",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,3,5],[[4,8],[2,8]]",
                "output": "6"
            },
            {
                "input": "[2,3,5],[[1,4],[2,3],[3,4]]",
                "output": "-1"
            },
            {
                "input": "[3,5,8,10,11,12],[[12],[11,9],[10,5,14]]",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic boolean checkPowersOfThree(int n) {\n    while (n > 0) {\n        if (n % 3 == 2) return false;\n        n /= 3;\n    }\n    return true;\n}\n```\n    \n    The algorithm iteratively checks if it's possible to represent the given integer `n` as the sum of distinct powers of three. It does this by performing the following steps:\n1. While `n` is greater than 0, perform steps 2 and 3.\n2. If `n % 3` equals 2, return false. This means that the current integer cannot be represented as a distinct power of three since a power of 3 can only have a remainder of 0 or 1 when divided by 3.\n3. Set `n` to `n / 3`, effectively testing the next power of 3.\n\nIf the function didn't return in step 2 during the loop, the given integer could be represented as the sum of distinct powers of three, and the function should return true.\n    ",
        "python": "\n    ```python\ndef check_powers_of_three(n: int) -> bool:\n    while n > 0:\n        if n % 3 == 2:\n            return False\n        n //= 3\n    return True\n```\n    \n    The algorithm iteratively checks if it's possible to represent the given integer `n` as the sum of distinct powers of three. It does this by performing the following steps:\n1. While `n` is greater than 0, perform steps 2 and 3.\n2. If `n % 3` equals 2, return false. This means that the current integer cannot be represented as a distinct power of three since a power of 3 can only have a remainder of 0 or 1 when divided by 3.\n3. Set `n` to `n / 3`, effectively testing the next power of 3.\n\nIf the function didn't return in step 2 during the loop, the given integer could be represented as the sum of distinct powers of three, and the function should return true.\n    ",
        "c++": "\n    ```cpp\nbool checkPowersOfThree(int n) {\n    while (n > 0) {\n        if (n % 3 == 2) return false;\n        n /= 3;\n    }\n    return true;\n}\n```\n    \n    The algorithm iteratively checks if it's possible to represent the given integer `n` as the sum of distinct powers of three. It does this by performing the following steps:\n1. While `n` is greater than 0, perform steps 2 and 3.\n2. If `n % 3` equals 2, return false. This means that the current integer cannot be represented as a distinct power of three since a power of 3 can only have a remainder of 0 or 1 when divided by 3.\n3. Set `n` to `n / 3`, effectively testing the next power of 3.\n\nIf the function didn't return in step 2 during the loop, the given integer could be represented as the sum of distinct powers of three, and the function should return true.\n    ",
        "js": "\n    ```javascript\nfunction checkPowersOfThree(n) {\n    while (n > 0) {\n        if (n % 3 === 2) return false;\n        n = Math.floor(n / 3);\n    }\n    return true;\n}\n```\n\n    \n    The algorithm iteratively checks if it's possible to represent the given integer `n` as the sum of distinct powers of three. It does this by performing the following steps:\n1. While `n` is greater than 0, perform steps 2 and 3.\n2. If `n % 3` equals 2, return false. This means that the current integer cannot be represented as a distinct power of three since a power of 3 can only have a remainder of 0 or 1 when divided by 3.\n3. Set `n` to `n / 3`, effectively testing the next power of 3.\n\nIf the function didn't return in step 2 during the loop, the given integer could be represented as the sum of distinct powers of three, and the function should return true.\n    "
    },
    {
        "id": 314,
        "title": "Minimum Cost to Change the Final Value of Expression",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **valid** boolean expression as a string `expression` consisting of the characters `'1'`,`'0'`,`'&'` (bitwise **AND** operator),`'|'` (bitwise **OR** operator),`'('`, and `')'`.\n\n*   For example, `\"()1|1 \"` and `\"(1)&() \"` are **not valid** while `\"1 \"`, `\"(((1))|(0)) \"`, and `\"1|(0&(1)) \"` are **valid** expressions.\n\nReturn _the **minimum cost** to change the final value of the expression_.\n\n*   For example, if `expression = \"1|1|(0&0)&1 \"`, its **value** is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the **new** expression evaluates to `0`.\n\nThe **cost** of changing the final value of an expression is the **number of operations** performed on the expression. The types of **operations** are described as follows:\n\n*   Turn a `'1'` into a `'0'`.\n*   Turn a `'0'` into a `'1'`.\n*   Turn a `'&'` into a `'|'`.\n*   Turn a `'|'` into a `'&'`.\n\n**Note:** `'&'` does **not** take precedence over `'|'` in the **order of calculation**. Evaluate parentheses **first**, then in **left-to-right** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"1&(0|1) \"\n**Output:** 1\n**Explanation:** We can turn  \"1&(0**|**1) \" into  \"1&(0**&**1) \" by changing the '|' to a '&' using 1 operation.\nThe new expression evaluates to 0. \n\n",
                "**Example 2:**\n\n**Input:** expression =  \"(0&0)&(0&0&0) \"\n**Output:** 3\n**Explanation:** We can turn  \"(0**&0**)**&**(0&0&0) \" into  \"(0**|1**)**|**(0&0&0) \" using 3 operations.\nThe new expression evaluates to 1.\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"(0|(1|0&1)) \"\n**Output:** 1\n**Explanation:** We can turn  \"(0|(**1**|0&1)) \" into  \"(0|(**0**|0&1)) \" using 1 operation.\nThe new expression evaluates to 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 105`\n*   `expression` only contains `'1'`,`'0'`,`'&'`,`'|'`,`'('`, and `')'`\n*   All parentheses are properly matched.\n*   There will be no empty parentheses (i.e: `\"() \"` is not a substring of `expression`).",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Dynamic Programming",
            "Stack"
        ],
        "example": [
            {
                "input": "\"1&(0|1)\"",
                "output": "1"
            },
            {
                "input": "\"(0&0)&(0&0&0)\"",
                "output": "3"
            },
            {
                "input": "\"(0|(1|0&1))\"",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int maximumScore(int[] nums, int[] multipliers) {\n    int n = nums.length, m = multipliers.length;\n    int[][] dp = new int[m + 1][m + 1];\n    int maxScore = Integer.MIN_VALUE;\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; i + j <= m; j++) {\n            if (i == 0 && j == 0) continue;\n            int score = 0;\n            if (i == 0) {\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];\n            } else if (j == 0) {\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];\n            } else {\n                score = Math.max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                                dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);\n            }\n            dp[i][j] = score;\n            if (i + j == m) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n    }\n\n    return maxScore;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    ",
        "python": "\n    ```python\ndef maximumScore(nums, multipliers):\n    n, m = len(nums), len(multipliers)\n    dp = [[0] * (m + 1) for _ in range(m + 1)]\n    maxScore = float('-inf')\n\n    for i in range(m + 1):\n        for j in range(m - i + 1):\n            if i == 0 and j == 0:\n                continue\n            score = 0\n            if i == 0:\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]\n            elif j == 0:\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1]\n            else:\n                score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                            dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1])\n            dp[i][j] = score\n            if i + j == m:\n                maxScore = max(maxScore, score)\n\n    return maxScore\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maximumScore(vector<int>& nums, vector<int>& multipliers) {\n    int n = nums.size(), m = multipliers.size();\n    vector<vector<int>> dp(m + 1, vector<int>(m + 1, 0));\n    int maxScore = INT_MIN;\n\n    for (int i = 0; i <= m; ++i) {\n        for (int j = 0; i + j <= m; ++j) {\n            if (i == 0 && j == 0) continue;\n            int score = 0;\n            if (i == 0) {\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];\n            } else if (j == 0) {\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];\n            } else {\n              score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                          dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);\n            }\n            dp[i][j] = score;\n            if (i + j == m) {\n                maxScore = max(maxScore, score);\n            }\n        }\n    }\n\n    return maxScore;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    ",
        "js": "\n    ```javascript\nfunction maximumScore(nums, multipliers) {\n    const n = nums.length, m = multipliers.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(m + 1).fill(0));\n    let maxScore = Number.MIN_SAFE_INTEGER;\n\n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; i + j <= m; j++) {\n            if (i === 0 && j === 0) continue;\n            let score = 0;\n            if (i === 0) {\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];\n            } else if (j === 0) {\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];\n            } else {\n                score = Math.max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                                dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);\n            }\n            dp[i][j] = score;\n            if (i + j === m) {\n                maxScore = Math.max(maxScore, score);\n            }\n        }\n    }\n\n    return maxScore;\n}\n```\n    \n    The algorithm uses dynamic programming to solve the problem. We create a 2D dp matrix of size (m+1)x(m+1), iterate the matrix from i=0 to m and j such that i+j<=m. Then, for each cell, we calculate the score at that cell based on the previous indices and the elements of the nums and multipliers arrays. We update the maxScore whenever the sum of i and j is equal to m.\n\nFinally, we return the maxScore after iterating through the entire dp matrix. The time complexity of this algorithm is O(m^2) as it iterates through a 2D matrix.\n    "
    },
    {
        "id": 315,
        "title": "The Earliest and Latest Rounds Where Players Compete",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\n*   For example, if the row consists of players `1, 2, 4, 6, 7`\n    *   Player `1` competes against player `7`.\n    *   Player `2` competes against player `6`.\n    *   Player `4` automatically advances to the next round.\n\nAfter each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round.\n\nGiven the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 11, firstPlayer = 2, secondPlayer = 4\n**Output:** \\[3,4\\]\n**Explanation:**\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\n",
                "**Example 2:**\n\n**Input:** n = 5, firstPlayer = 1, secondPlayer = 5\n**Output:** \\[1,1\\]\n**Explanation:** The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 28`\n*   `1 <= firstPlayer < secondPlayer <= n`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "11,2,4",
                "output": "[3,4]"
            },
            {
                "input": "5,1,5",
                "output": "[1,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic class Solution {\n    public int closestCost(List<Integer> baseCosts, List<Integer> toppingCosts, int target) {\n        int closest = baseCosts.get(0);\n        for (int base : baseCosts) {\n            int cost = base;\n            for (int i = 0; i < (1 << (toppingCosts.size() * 2)); ++i) {\n                int bitMask = i;\n                for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2) {\n                    cost += (bitMask & 3) * toppingCosts.get(j);\n                }\n\n                if (Math.abs(target - cost) < Math.abs(target - closest)) {\n                    closest = cost;\n                } else if (Math.abs(target - cost) == Math.abs(target - closest) && cost < closest) {\n                    closest = cost;\n                }\n\n                cost = base;\n            }\n        }\n        return closest;\n    }\n}\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    ",
        "python": "\n    ```python\ndef closest_cost(base_costs, topping_costs, target):\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint closestCost(std::vector<int>& baseCosts, std::vector<int>& toppingCosts, int target) {\n    int closest = baseCosts[0];\n    for (int base : baseCosts) {\n        int cost = base;\n        for (int i = 0; i < 1 << (toppingCosts.size() * 2); ++i) {\n            int bitMask = i;\n            for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2) {\n                cost += (bitMask & 3) * toppingCosts[j];\n            }\n\n            if (abs(target - cost) < abs(target - closest)) {\n                closest = cost;\n            } else if (abs(target - cost) == abs(target - closest) && cost < closest) {\n                closest = cost;\n            }\n\n            cost = base;\n        }\n    }\n    return closest;\n}\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    ",
        "js": "\n    ```javascript\nfunction closestCost(baseCosts, toppingCosts, target) {\n    let closest = baseCosts[0];\n\n    for (const base of baseCosts) {\n        let cost = base;\n        for (let i = 0; i < (1 << (toppingCosts.length * 2)); ++i) {\n            let bitMask = i;\n            for (let j = 0; j < toppingCosts.length; ++j, bitMask >>= 2) {\n                cost += (bitMask & 3) * toppingCosts[j];\n            }\n\n            if (Math.abs(target - cost) < Math.abs(target - closest)) {\n                closest = cost;\n            } else if (Math.abs(target - cost) === Math.abs(target - closest) && cost < closest) {\n                closest = cost;\n            }\n\n            cost = base;\n        }\n    }\n\n    return closest;\n}\n```\n\n    \n    In all the four languages, the given algorithms have a similar approach:\n\n1. Initialize the result (closest) to the first base cost.\n2. Loop through each base cost.\n   a. Set the current cost to current base cost. \n   b. Use another loop to create all combinations of topping costs. We use bitwise manipulation to achieve that by looping through all integers from 0 to 2^(2 * m) - 1, and get 2-bit numbers for each topping multiple. Both loops help simulate all possible combinations.\n   c. For each combination of toppings (mantained as bitMask), calculate the total cost by adding the appropriate toppings to the current base cost.\n   d. Check if the current cost is better (closer or lower but equally close) than the best found (closest) so far.\n   e. Reset the cost to the base cost and repeat the process for the next combination.\n3. Return the best found cost closest to the target.\n\nThis algorithm explores all possible combinations of base costs and topping costs, therefore finding the optimal combination. Since the search space is 2^(2 * m) for the toppings, the time complexity is O(n * 2^(2 * m)), where n is the number of base costs and m is the number of topping costs.\n    "
    },
    {
        "id": 316,
        "title": "Design Movie Rental System",
        "difficulty": "Hard",
        "content": {
            "problem": "You have a movie renting company consisting of `n` shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies.\n\nEach movie is given as a 2D integer array `entries` where `entries[i] = [shopi, moviei, pricei]` indicates that there is a copy of movie `moviei` at shop `shopi` with a rental price of `pricei`. Each shop carries **at most one** copy of a movie `moviei`.\n\nThe system should support the following functions:\n\n*   **Search**: Finds the **cheapest 5 shops** that have an **unrented copy** of a given movie. The shops should be sorted by **price** in ascending order, and in case of a tie, the one with the **smaller** `shopi` should appear first. If there are less than 5 matching shops, then all of them should be returned. If no shop has an unrented copy, then an empty list should be returned.\n*   **Rent**: Rents an **unrented copy** of a given movie from a given shop.\n*   **Drop**: Drops off a **previously rented copy** of a given movie at a given shop.\n*   **Report**: Returns the **cheapest 5 rented movies** (possibly of the same movie ID) as a 2D list `res` where `res[j] = [shopj, moviej]` describes that the `jth` cheapest rented movie `moviej` was rented from the shop `shopj`. The movies in `res` should be sorted by **price** in ascending order, and in case of a tie, the one with the **smaller** `shopj` should appear first, and if there is still tie, the one with the **smaller** `moviej` should appear first. If there are fewer than 5 rented movies, then all of them should be returned. If no movies are currently being rented, then an empty list should be returned.\n\nImplement the `MovieRentingSystem` class:\n\n*   `MovieRentingSystem(int n, int[][] entries)` Initializes the `MovieRentingSystem` object with `n` shops and the movies in `entries`.\n*   `List search(int movie)` Returns a list of shops that have an **unrented copy** of the given `movie` as described above.\n*   `void rent(int shop, int movie)` Rents the given `movie` from the given `shop`.\n*   `void drop(int shop, int movie)` Drops off a previously rented `movie` at the given `shop`.\n*   `List> report()` Returns a list of cheapest **rented** movies as described above.\n\n**Note:** The test cases will be generated such that `rent` will only be called if the shop has an **unrented** copy of the movie, and `drop` will only be called if the shop had **previously rented** out the movie.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"MovieRentingSystem \",  \"search \",  \"rent \",  \"rent \",  \"report \",  \"drop \",  \"search \"\\]\n\\[\\[3, \\[\\[0, 1, 5\\], \\[0, 2, 6\\], \\[0, 3, 7\\], \\[1, 1, 4\\], \\[1, 2, 7\\], \\[2, 1, 5\\]\\]\\], \\[1\\], \\[0, 1\\], \\[1, 2\\], \\[\\], \\[1, 2\\], \\[2\\]\\]\n**Output**\n\\[null, \\[1, 0, 2\\], null, null, \\[\\[0, 1\\], \\[1, 2\\]\\], null, \\[0, 1\\]\\]\n\n**Explanation**\nMovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, \\[\\[0, 1, 5\\], \\[0, 2, 6\\], \\[0, 3, 7\\], \\[1, 1, 4\\], \\[1, 2, 7\\], \\[2, 1, 5\\]\\]);\nmovieRentingSystem.search(1);  // return \\[1, 0, 2\\], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.\nmovieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now \\[2,3\\].\nmovieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now \\[1\\].\nmovieRentingSystem.report();   // return \\[\\[0, 1\\], \\[1, 2\\]\\]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.\nmovieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now \\[1,2\\].\nmovieRentingSystem.search(2);  // return \\[0, 1\\]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 3 * 105`\n*   `1 <= entries.length <= 105`\n*   `0 <= shopi < n`\n*   `1 <= moviei, pricei <= 104`\n*   Each shop carries **at most one** copy of a movie `moviei`.\n*   At most `105` calls **in total** will be made to `search`, `rent`, `drop` and `report`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Design",
            "Heap (Priority Queue)",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]],[1],[0,1],[1,2],[],[1,2],[2]]",
                "output": "**Output**\n[null,[1,0,2],null,null,[[0,1],[1,2]],null,[0,1]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    static final int mod = 1000000007;\n    \n    public int countRestrictedPaths(int n, int[][] edges) {\n        List<List<Pair>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], weight = edge[2];\n            graph.get(u).add(new Pair(v, weight));\n            graph.get(v).add(new Pair(u, weight));\n        }\n\n        long[] dist = new long[n + 1];\n        Arrays.fill(dist, Long.MAX_VALUE);\n        \n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(a.weight, b.weight));\n        pq.offer(new Pair(n, 0));\n        dist[n] = 0;\n\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            int u = p.node;\n            long d = p.weight;\n\n            if (d != dist[u]) continue;\n\n            for (Pair to : graph.get(u)) {\n                int v = to.node;\n                long w = to.weight;\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    pq.offer(new Pair(v, dist[v]));\n                }\n            }\n        }\n\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        return dfs(graph, dist, dp, 1);\n    }\n    \n    int dfs(List<List<Pair>> graph, long[] dist, int[] dp, int u) {\n        int n = dist.length - 1;\n        if (u == n) return 1;\n        if (dp[u] != -1) return dp[u];\n        int ans = 0;\n        for (Pair to : graph.get(u)) {\n            int v = to.node;\n            if (dist[v] < dist[u]) {\n                ans = (int) ((ans + (long) dfs(graph, dist, dp, v)) % mod);\n            }\n        }\n        dp[u] = ans;\n        return ans;\n    }\n\n    static class Pair {\n        int node;\n        long weight;\n\n        Pair(int node, long weight) {\n            this.node = node;\n            this.weight = weight;\n        }\n    }\n}\n```\n    \n    1. Create the adjacency list graph representation of the input.\n2. Run Dijkstra's algorithm to find the shortest path from node n to every other node in the graph.\n3. Use a variation of DFS with memoization (in this case, the DFS function is called dfs) to count the number of restricted paths from node 1 to node n.\n   a. In the dfs function, iterate over each neighbor of the current node u.\n   b. If the distance of the neighbor is less than the distance of the current node, call the DFS function recursively on the neighbor and add the value to the answer.\n   c. Make sure to take the result modulo 10^9 + 7 to keep the answer from overflowing.\n4. Call the dfs function starting from node 1 to get the final result.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\nfrom collections import defaultdict\nfrom functools import lru_cache\n\nmod = 10**9 + 7\n\ndef countRestrictedPaths(n, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float('inf')] * (n + 1)\n    dist[n] = 0\n    pq = [(0, n)] # (distance, node)\n    \n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heappush(pq, (dist[v], v))\n\n    @lru_cache(None)\n    def dfs(u):\n        if u == n:\n            return 1\n        ans = 0\n        for v, _ in graph[u]:\n            if dist[v] < dist[u]:\n                ans = (ans + dfs(v)) % mod\n        return ans\n\n    return dfs(1)\n```\n    \n    1. Create the adjacency list graph representation of the input.\n2. Run Dijkstra's algorithm to find the shortest path from node n to every other node in the graph.\n3. Use a variation of DFS with memoization (in this case, the DFS function is called dfs) to count the number of restricted paths from node 1 to node n.\n   a. In the dfs function, iterate over each neighbor of the current node u.\n   b. If the distance of the neighbor is less than the distance of the current node, call the DFS function recursively on the neighbor and add the value to the answer.\n   c. Make sure to take the result modulo 10^9 + 7 to keep the answer from overflowing.\n4. Call the dfs function starting from node 1 to get the final result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint countRestrictedPaths(int n, vector<vector<int>>& edges) {\n    vector<vector<pair<int, int>>> graph(n + 1);\n    vector<long long> dist(n + 1, 1e18);\n\n    for (auto& edge : edges) {\n        int u = edge[0], v = edge[1], weight = edge[2];\n        graph[u].push_back({v, weight});\n        graph[v].push_back({u, weight});\n    }\n\n    priority_queue<pair<long long, int>> pq;\n    pq.push({0, n});\n    dist[n] = 0;\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        long long d = -pq.top().first;\n        pq.pop();\n\n        if (d != dist[u]) continue;\n\n        for (auto& to : graph[u]) {\n            int v = to.first, w = to.second;\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({-dist[v], v});\n            }\n        }\n    }\n\n    vector<int> dp(n + 1, -1);\n    function<int(int)> dfs = [&](int u) {\n        if (u == n) return 1;\n        if (dp[u] != -1) return dp[u];\n        int ans = 0;\n        for (auto& to : graph[u]) {\n            int v = to.first;\n            if (dist[v] < dist[u]) {\n                ans = (ans + dfs(v)) % mod;\n            }\n        }\n        return dp[u] = ans;\n    };\n\n    return dfs(1);\n}\n```\n    \n    1. Create the adjacency list graph representation of the input.\n2. Run Dijkstra's algorithm to find the shortest path from node n to every other node in the graph.\n3. Use a variation of DFS with memoization (in this case, the DFS function is called dfs) to count the number of restricted paths from node 1 to node n.\n   a. In the dfs function, iterate over each neighbor of the current node u.\n   b. If the distance of the neighbor is less than the distance of the current node, call the DFS function recursively on the neighbor and add the value to the answer.\n   c. Make sure to take the result modulo 10^9 + 7 to keep the answer from overflowing.\n4. Call the dfs function starting from node 1 to get the final result.\n    ",
        "js": "\n    ```javascript\nconst mod = 1e9 + 7;\n\nfunction countRestrictedPaths(n, edges) {\n    let graph = new Array(n + 1).fill(null).map(() => []);\n    let dist = new Array(n + 1).fill(Number.MAX_VALUE);\n\n    edges.forEach(([u, v, w]) => {\n        graph[u].push([v, w]);\n        graph[v].push([u, w]);\n    });\n\n    let pq = [[0, n]]; // [distance, node]\n    dist[n] = 0;\n\n    while (pq.length !== 0) {\n        pq.sort((a, b) => a[0] - b[0]);\n        let [d, u] = pq.pop();\n        if (d !== dist[u]) continue;\n\n        graph[u].forEach(([v, w]) => {\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push([dist[v], v]);\n            }\n        });\n    }\n\n    let dp = new Array(n + 1).fill(-1);\n\n    function dfs(u) {\n        if (u === n) return 1;\n        if (dp[u] !== -1) return dp[u];\n        let ans = 0;\n        graph[u].forEach(([v, _]) => {\n            if (dist[v] < dist[u]) {\n                ans = (ans + dfs(v)) % mod;\n            }\n        });\n        dp[u] = ans;\n        return ans;\n    }\n\n    return dfs(1);\n}\n```\n    \n    1. Create the adjacency list graph representation of the input.\n2. Run Dijkstra's algorithm to find the shortest path from node n to every other node in the graph.\n3. Use a variation of DFS with memoization (in this case, the DFS function is called dfs) to count the number of restricted paths from node 1 to node n.\n   a. In the dfs function, iterate over each neighbor of the current node u.\n   b. If the distance of the neighbor is less than the distance of the current node, call the DFS function recursively on the neighbor and add the value to the answer.\n   c. Make sure to take the result modulo 10^9 + 7 to keep the answer from overflowing.\n4. Call the dfs function starting from node 1 to get the final result.\n    "
    },
    {
        "id": 317,
        "title": "Count Ways to Build Rooms in an Ant Colony",
        "difficulty": "Hard",
        "content": {
            "problem": "You are an ant tasked with adding `n` new rooms numbered `0` to `n-1` to your colony. You are given the expansion plan as a **0-indexed** integer array of length `n`, `prevRoom`, where `prevRoom[i]` indicates that you must build room `prevRoom[i]` before building room `i`, and these two rooms must be connected **directly**. Room `0` is already built, so `prevRoom[0] = -1`. The expansion plan is given such that once all the rooms are built, every room will be reachable from room `0`.\n\nYou can only build **one room** at a time, and you can travel freely between rooms you have **already built** only if they are **connected**. You can choose to build **any room** as long as its **previous room** is already built.\n\nReturn _the **number of different orders** you can build all the rooms in_. Since the answer may be large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** prevRoom = \\[-1,0,1\\]\n**Output:** 1\n**Explanation:** There is only one way to build the additional rooms: 0 -> 1 -> 2\n\n",
                "**Example 2:**\n\n**Input:** prevRoom = \\[-1,0,0,1,2\\]\n**Output:** 6\n**Explanation:**\nThe 6 ways are:\n0 -> 1 -> 3 -> 2 -> 4\n0 -> 2 -> 4 -> 1 -> 3\n0 -> 1 -> 2 -> 3 -> 4\n0 -> 1 -> 2 -> 4 -> 3\n0 -> 2 -> 1 -> 3 -> 4\n0 -> 2 -> 1 -> 4 -> 3"
            ],
            "constraints": "**Constraints:**\n\n*   `n == prevRoom.length`\n*   `2 <= n <= 105`\n*   `prevRoom[0] == -1`\n*   `0 <= prevRoom[i] < n` for all `1 <= i < n`\n*   Every room is reachable from room `0` once all the rooms are built.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Tree",
            "Graph",
            "Topological Sort",
            "Combinatorics"
        ],
        "example": [
            {
                "input": "[-1,0,1]",
                "output": "1"
            },
            {
                "input": "[-1,0,0,1,2]",
                "output": "6"
            }
        ],
        "java": "\n    ```java\npublic int findCenter(int[][] edges) {\n    if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {\n        return edges[0][0];\n    }\n    return edges[0][1];\n}\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    ",
        "python": "\n    ```python\ndef findCenter(edges):\n    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:\n        return edges[0][0]\n    return edges[0][1]\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    ",
        "c++": "\n    ```cpp\nint findCenter(vector<vector<int>>& edges) {\n    if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {\n        return edges[0][0];\n    }\n    return edges[0][1];\n}\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    ",
        "js": "\n    ```javascript\nfunction findCenter(edges) {\n    if (edges[0][0] === edges[1][0] || edges[0][0] === edges[1][1]) {\n        return edges[0][0];\n    }\n    return edges[0][1];\n}\n```\n    \n    The algorithm only needs to examine the first two elements in the edges array because it knows that the graph is a star graph. In such a graph, every node is connected to the center node. So, the center node must appear twice in the first two elements of the edges array (once in each edge). The algorithm checks if the first node in the first edge is the center by seeing if it exists in the second edge. If it does not, the function returns the second node in the first edge, as that must be the center. This approach has a constant time complexity (O(1)) because it examines a fixed number of array elements, regardless of the size of the input matrix.\n    "
    },
    {
        "id": 318,
        "title": "Longest Common Subpath",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a country of `n` cities numbered from `0` to `n - 1`. In this country, there is a road connecting **every pair** of cities.\n\nThere are `m` friends numbered from `0` to `m - 1` who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city **more than once**, but the same city will not be listed consecutively.\n\nGiven an integer `n` and a 2D integer array `paths` where `paths[i]` is an integer array representing the path of the `ith` friend, return _the length of the **longest common subpath** that is shared by **every** friend's path, or_ `0` _if there is no common subpath at all_.\n\nA **subpath** of a path is a contiguous sequence of cities within that path.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, paths = \\[\\[0,1,2,3,4\\],\n                       \\[2,3,4\\],\n                       \\[4,0,1,2,3\\]\\]\n**Output:** 2\n**Explanation:** The longest common subpath is \\[2,3\\].\n\n",
                "**Example 2:**\n\n**Input:** n = 3, paths = \\[\\[0\\],\\[1\\],\\[2\\]\\]\n**Output:** 0\n**Explanation:** There is no common subpath shared by the three paths.\n\n",
                "**Example 3:**\n\n**Input:** n = 5, paths = \\[\\[0,1,2,3,4\\],\n                       \\[4,3,2,1,0\\]\\]\n**Output:** 1\n**Explanation:** The possible longest common subpaths are \\[0\\], \\[1\\], \\[2\\], \\[3\\], and \\[4\\]. All have a length of 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `m == paths.length`\n*   `2 <= m <= 105`\n*   `sum(paths[i].length) <= 105`\n*   `0 <= paths[i][j] < n`\n*   The same city is not listed multiple times consecutively in `paths[i]`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Rolling Hash",
            "Suffix Array",
            "Hash Function"
        ],
        "example": [
            {
                "input": "5,[[0,1,2,3,4],\n[2,3,4],\n[4,0,1,2,3]]",
                "output": "2"
            },
            {
                "input": "3,[[0],[1],[2]]",
                "output": "0"
            },
            {
                "input": "5,[[0,1,2,3,4],\n[4,3,2,1,0]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean areSentencesSimilar(String sentence1, String sentence2) {\n    List<String> words1 = new ArrayList<>(Arrays.asList(sentence1.split(\" \")));\n    List<String> words2 = new ArrayList<>(Arrays.asList(sentence2.split(\" \")));\n\n    while (!words1.isEmpty() && !words2.isEmpty() && words1.get(0).equals(words2.get(0))) {\n        words1.remove(0);\n        words2.remove(0);\n    }\n\n    while (!words1.isEmpty() && !words2.isEmpty() && words1.get(words1.size() - 1).equals(words2.get(words2.size() - 1))) {\n        words1.remove(words1.size() - 1);\n        words2.remove(words2.size() - 1);\n    }\n\n    return words1.isEmpty() || words2.isEmpty();\n}\n```\n    \n    The algorithm first splits the input sentences into lists of words (vector in C++, ArrayList in Java, list in Python, and array in JavaScript). Then, it compares and removes the common words from the beginning of both lists by using a while loop until no more common words are found. After that, it compares and removes the common words from the end of both lists using another while loop until no more common words are found. Finally, it returns true if one of the lists is empty, which means that the input sentences are similar, otherwise it returns false.\n    ",
        "python": "\n    ```python\ndef are_sentences_similar(sentence1, sentence2):\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n\n    while words1 and words2 and words1[0] == words2[0]:\n        words1.pop(0)\n        words2.pop(0)\n    \n    while words1 and words2 and words1[-1] == words2[-1]:\n        words1.pop()\n        words2.pop()\n\n    return not words1 or not words2\n```\n    \n    The algorithm first splits the input sentences into lists of words (vector in C++, ArrayList in Java, list in Python, and array in JavaScript). Then, it compares and removes the common words from the beginning of both lists by using a while loop until no more common words are found. After that, it compares and removes the common words from the end of both lists using another while loop until no more common words are found. Finally, it returns true if one of the lists is empty, which means that the input sentences are similar, otherwise it returns false.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n\nbool areSentencesSimilar(std::string sentence1, std::string sentence2) {\n    std::vector<std::string> words1, words2;\n    std::stringstream ss1(sentence1), ss2(sentence2);\n    std::string word;\n    \n    while (ss1 >> word) words1.push_back(word);\n    while (ss2 >> word) words2.push_back(word);\n    \n    while (\n        !words1.empty() && !words2.empty() &&\n        words1.front() == words2.front()\n    ) {\n        words1.erase(words1.begin());\n        words2.erase(words2.begin());\n    }\n    \n    while (\n        !words1.empty() && !words2.empty() &&\n        words1.back() == words2.back()\n    ) {\n        words1.pop_back();\n        words2.pop_back();\n    }\n    \n    return words1.empty() || words2.empty();\n}\n```\n    \n    The algorithm first splits the input sentences into lists of words (vector in C++, ArrayList in Java, list in Python, and array in JavaScript). Then, it compares and removes the common words from the beginning of both lists by using a while loop until no more common words are found. After that, it compares and removes the common words from the end of both lists using another while loop until no more common words are found. Finally, it returns true if one of the lists is empty, which means that the input sentences are similar, otherwise it returns false.\n    ",
        "js": "\n    ```javascript\nfunction areSentencesSimilar(sentence1, sentence2) {\n    let words1 = sentence1.split(\" \");\n    let words2 = sentence2.split(\" \");\n    \n    while (\n        words1.length && words2.length &&\n        words1[0] === words2[0]\n    ) {\n        words1.shift();\n        words2.shift();\n    }\n    \n    while (\n        words1.length && words2.length &&\n        words1[words1.length - 1] === words2[words2.length - 1]\n    ) {\n        words1.pop();\n        words2.pop();\n    }\n    \n    return !words1.length || !words2.length;\n}\n```\n    \n    The algorithm first splits the input sentences into lists of words (vector in C++, ArrayList in Java, list in Python, and array in JavaScript). Then, it compares and removes the common words from the beginning of both lists by using a while loop until no more common words are found. After that, it compares and removes the common words from the end of both lists using another while loop until no more common words are found. Finally, it returns true if one of the lists is empty, which means that the input sentences are similar, otherwise it returns false.\n    "
    },
    {
        "id": 319,
        "title": "Minimum Cost to Reach Destination in Time",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.",
            "examples": [
                "**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n",
                "**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n",
                "**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Graph"
        ],
        "example": [
            {
                "input": "30,[[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],[5,1,2,20,20,3]",
                "output": "11"
            },
            {
                "input": "29,[[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],[5,1,2,20,20,3]",
                "output": "48"
            },
            {
                "input": "25,[[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],[5,1,2,20,20,3]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int getNumberOfBacklogOrders(int[][] orders) {\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n\n        for (int[] order : orders) {\n            if (order[2] == 0) {\n                while (!sell.isEmpty() && order[1] > 0 && sell.peek()[0] <= order[0]) {\n                    int executedAmount = Math.min(order[1], sell.peek()[1]);\n                    order[1] -= executedAmount;\n                    sell.peek()[1] -= executedAmount;\n                    if (sell.peek()[1] == 0) sell.poll();\n                }\n                if (order[1] > 0) buy.offer(order);\n            } else {\n                while (!buy.isEmpty() && order[1] > 0 && buy.peek()[0] >= order[0]) {\n                    int executedAmount = Math.min(order[1], buy.peek()[1]);\n                    order[1] -= executedAmount;\n                    buy.peek()[1] -= executedAmount;\n                    if (buy.peek()[1] == 0) buy.poll();\n                }\n                if (order[1] > 0) sell.offer(order);\n            }\n        }\n\n        long res = 0;\n        while (!buy.isEmpty()) res += buy.poll()[1];\n        while (!sell.isEmpty()) res += sell.poll()[1];\n        res %= 1_000_000_007;\n\n        return (int) res;\n    }\n}\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\n\nint getNumberOfBacklogOrders(std::vector<std::vector<int>>& orders) {\n    auto cmpSell = [](std::vector<int>& a, std::vector<int>& b) {\n        return a[0] > b[0];\n    };\n    auto cmpBuy = [](std::vector<int>& a, std.stringvector<int>&b) {\n        return a[0] < b[0];\n    };\n\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmpSell)> sell(cmpSell);\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmpBuy)> buy(cmpBuy);\n\n    for (auto& order : orders) {\n        if (order[2] == 0) {\n            while (!sell.empty() && order[1] > 0 && sell.top()[0] <= order[0]) {\n                std::vector<int>& currOrder = sell.top();\n                int executedAmount = std::min(order[1], currOrder[1]);\n                order[1] -= executedAmount;\n                currOrder[1] -= executedAmount;\n                if (currOrder[1] == 0) {\n                    sell.pop();\n                }\n            }\n            if (order[1] > 0) {\n                buy.push(order);\n            }\n        } else {\n            while (!buy.empty() && order[1] > 0 && buy.top()[0] >= order[0]) {\n                std::vector<int>& currOrder = buy.top();\n                int executedAmount = std::min(order[1], currOrder[1]);\n                order[1] -= executedAmount;\n                currOrder[1] -= executedAmount;\n                if (currOrder[1] == 0) {\n                    buy.pop();\n                }\n            }\n            if (order[1] > 0) {\n                sell.push(order);\n            }\n        }\n    }\n\n    int64_t res = 0;\n    while (!buy.empty()) {\n        res += buy.top()[1];\n        buy.pop();\n    }\n    while (!sell.empty()) {\n        res += sell.top()[1];\n        sell.pop();\n    }\n\n    res %= 1000000007;\n    return static_cast<int>(res);\n}\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    ",
        "js": "\n    ```javascript\nfunction getNumberOfBacklogOrders(orders) {\n    const sell = new PriorityQueue((a, b) => a[0] - b[0]);\n    const buy = new PriorityQueue((a, b) => b[0] - a[0]);\n\n    for (const order of orders) {\n        const [price, amount, orderType] = order;\n        let currAmount = amount;\n        if (orderType === 0) {\n            while (currAmount > 0 && sell.size() > 0 && sell.peek()[0] <= price) {\n                const executedAmount = Math.min(currAmount, sell.peek()[1]);\n                currAmount -= executedAmount;\n                sell.peek()[1] -= executedAmount;\n                if (sell.peek()[1] === 0) sell.pop();\n            }\n            if (currAmount > 0) buy.push([price, currAmount]);\n        } else {\n            while (currAmount > 0 && buy.size() > 0 && buy.peek()[0] >= price) {\n                const executedAmount = Math.min(currAmount, buy.peek()[1]);\n                currAmount -= executedAmount;\n                buy.peek()[1] -= executedAmount;\n                if (buy.peek()[1] === 0) buy.pop();\n            }\n            if (currAmount > 0) sell.push([price, currAmount]);\n        }\n    }\n\n    let res = 0;\n    while (buy.size() > 0) res += buy.pop()[1];\n    while (sell.size() > 0) res += sell.pop()[1];\n\n    return res % 1000000007;\n}\n```\n\n    \n    The algorithm uses two priority queues, one for buy orders and one for sell orders. When iterating over the input orders, for each buy order if there are sell orders that can be executed, execute them and update the current buy order amount accordingly. If the buy order still has residual amount, add it to the buy order queue. Same goes for sell orders.\n\nAfter processing all input orders, the residual orders in the buy and sell queues are the ones that couldn't be executed, sum their amounts and return the result modulo 1,000,000,007.\n    "
    },
    {
        "id": 320,
        "title": "Painting a Grid With Three Different Colors",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integers `m` and `n`. Consider an `m x n` grid where each cell is initially white. You can paint each cell **red**, **green**, or **blue**. All cells **must** be painted.\n\nReturn _the number of ways to color the grid with **no two adjacent cells having the same color**_. Since the answer can be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 3\n**Explanation:** The three possible colorings are shown in the image above.\n\n",
                "**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 6\n**Explanation:** The six possible colorings are shown in the image above.\n\n",
                "**Example 3:**\n\n**Input:** m = 5, n = 5\n**Output:** 580986"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m <= 5`\n*   `1 <= n <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "1,1",
                "output": "3"
            },
            {
                "input": "1,2",
                "output": "6"
            },
            {
                "input": "5,5",
                "output": "580986"
            }
        ],
        "java": "\n    ```java\npublic int numOfWays(int m, int n) {\n    long mod = 1000000007;\n    long a = 6, b = 6, c = 3, d = 3;\n    while (--n > 0) {\n        long temp_a = a, temp_c = c;\n        a = (a * 3 + b * 2) % mod;\n        b = (temp_a * 2 + b * 2) % mod;\n        c = (c * 3 + d * 2) % mod;\n        d = (temp_c * 2 + d * 2) % mod;\n    }\n    return (int)(m == 1 ? b : (a + c) % mod);\n}\n```\n    \n    The algorithm calculates the number of ways to color the m x n grid with no adjacent cells having the same color. If `m = 1`, we have a single column, and there are 2 ways to color one column (second cell differs from the first), and 3 ways to color two cells in a column (second cell differs from the first but matches the second row). If `m > 1`, there are two separate cases to consider when painting the third cell:\n\n- Case 1: The third cell is not adjacent to any cells of the same color (it is safe). In this case, we have 3 options to paint the third cell, and the number of ways to paint the grid is multiplied by 3.\n- Case 2: The third cell is adjacent to at least one cell of its color. In this case, we have 2 options to paint the third cell, and the number of ways is multiplied by 2.\n\nWe use dynamic programming to calculate the number of ways for each cell, starting from the initial values and updating the variables for cases 1 and 2 accordingly. Finally, we return the sum of ways depending on the value of `m`.\n    ",
        "python": "\n    ```python\ndef numOfWays(m, n):\n    mod = 1000000007\n    a, b, c, d = 6, 6, 3, 3\n    while n > 1:\n        n -= 1\n        temp_a = a\n        temp_c = c\n        a = (a * 3 + b * 2) % mod\n        b = (temp_a * 2 + b * 2) % mod\n        c = (c * 3 + d * 2) % mod\n        d = (temp_c * 2 + d * 2) % mod\n    return b if m == 1 else (a + c) % mod\n```\n    \n    The algorithm calculates the number of ways to color the m x n grid with no adjacent cells having the same color. If `m = 1`, we have a single column, and there are 2 ways to color one column (second cell differs from the first), and 3 ways to color two cells in a column (second cell differs from the first but matches the second row). If `m > 1`, there are two separate cases to consider when painting the third cell:\n\n- Case 1: The third cell is not adjacent to any cells of the same color (it is safe). In this case, we have 3 options to paint the third cell, and the number of ways to paint the grid is multiplied by 3.\n- Case 2: The third cell is adjacent to at least one cell of its color. In this case, we have 2 options to paint the third cell, and the number of ways is multiplied by 2.\n\nWe use dynamic programming to calculate the number of ways for each cell, starting from the initial values and updating the variables for cases 1 and 2 accordingly. Finally, we return the sum of ways depending on the value of `m`.\n    ",
        "c++": "\n    ```cpp\nint numOfWays(int m, int n) {\n    long mod = 1e9 + 7;\n    long a = 6, b = 6, c = 3, d = 3;\n    while (--n) {\n        long temp_a = a, temp_c = c;\n        a = (a * 3 + b * 2) % mod;\n        b = (temp_a * 2 + b * 2) % mod;\n        c = (c * 3 + d * 2) % mod;\n        d = (temp_c * 2 + d * 2) % mod;\n    }\n    return m == 1 ? b : (a + c) % mod;\n}\n```\n    \n    The algorithm calculates the number of ways to color the m x n grid with no adjacent cells having the same color. If `m = 1`, we have a single column, and there are 2 ways to color one column (second cell differs from the first), and 3 ways to color two cells in a column (second cell differs from the first but matches the second row). If `m > 1`, there are two separate cases to consider when painting the third cell:\n\n- Case 1: The third cell is not adjacent to any cells of the same color (it is safe). In this case, we have 3 options to paint the third cell, and the number of ways to paint the grid is multiplied by 3.\n- Case 2: The third cell is adjacent to at least one cell of its color. In this case, we have 2 options to paint the third cell, and the number of ways is multiplied by 2.\n\nWe use dynamic programming to calculate the number of ways for each cell, starting from the initial values and updating the variables for cases 1 and 2 accordingly. Finally, we return the sum of ways depending on the value of `m`.\n    ",
        "js": "\n    ```javascript\nfunction numOfWays(m, n) {\n    let mod = 1e9 + 7;\n    let a = 6, b = 6, c = 3, d = 3;\n    while (--n) {\n        let temp_a = a, temp_c = c;\n        a = (a * 3 + b * 2) % mod;\n        b = (temp_a * 2 + b * 2) % mod;\n        c = (c * 3 + d * 2) % mod;\n        d = (temp_c * 2 + d * 2) % mod;\n    }\n    return m === 1 ? b : (a + c) % mod;\n}\n```\n    \n    The algorithm calculates the number of ways to color the m x n grid with no adjacent cells having the same color. If `m = 1`, we have a single column, and there are 2 ways to color one column (second cell differs from the first), and 3 ways to color two cells in a column (second cell differs from the first but matches the second row). If `m > 1`, there are two separate cases to consider when painting the third cell:\n\n- Case 1: The third cell is not adjacent to any cells of the same color (it is safe). In this case, we have 3 options to paint the third cell, and the number of ways to paint the grid is multiplied by 3.\n- Case 2: The third cell is adjacent to at least one cell of its color. In this case, we have 2 options to paint the third cell, and the number of ways is multiplied by 2.\n\nWe use dynamic programming to calculate the number of ways for each cell, starting from the initial values and updating the variables for cases 1 and 2 accordingly. Finally, we return the sum of ways depending on the value of `m`.\n    "
    },
    {
        "id": 321,
        "title": "Merge BSTs to Create Single BST",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given `n` **BST (binary search tree) root nodes** for `n` separate BSTs stored in an array `trees` (**0-indexed**). Each BST in `trees` has **at most 3 nodes**, and no two roots have the same value. In one operation, you can:\n\n*   Select two **distinct** indices `i` and `j` such that the value stored at one of the **leaves** of `trees[i]` is equal to the **root value** of `trees[j]`.\n*   Replace the leaf node in `trees[i]` with `trees[j]`.\n*   Remove `trees[j]` from `trees`.\n\nReturn _the **root** of the resulting BST if it is possible to form a valid BST after performing_ `n - 1` _operations, or_ `null` _if it is impossible to create a valid BST_.\n\nA BST (binary search tree) is a binary tree where each node satisfies the following property:\n\n*   Every node in the node's left subtree has a value **strictly less** than the node's value.\n*   Every node in the node's right subtree has a value **strictly greater** than the node's value.\n\nA leaf is a node that has no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** trees = \\[\\[2,1\\],\\[3,2,5\\],\\[5,4\\]\\]\n**Output:** \\[3,2,5,1,null,4\\]\n**Explanation:**\nIn the first operation, pick i=1 and j=0, and merge trees\\[0\\] into trees\\[1\\].\nDelete trees\\[0\\], so trees = \\[\\[3,2,5,1\\],\\[5,4\\]\\].\n \nIn the second operation, pick i=0 and j=1, and merge trees\\[1\\] into trees\\[0\\].\nDelete trees\\[1\\], so trees = \\[\\[3,2,5,1,null,4\\]\\].\n \nThe resulting tree, shown above, is a valid BST, so return its root.\n\n",
                "**Example 2:**\n\n**Input:** trees = \\[\\[5,3,8\\],\\[3,2,6\\]\\]\n**Output:** \\[\\]\n**Explanation:**\nPick i=0 and j=1 and merge trees\\[1\\] into trees\\[0\\].\nDelete trees\\[1\\], so trees = \\[\\[5,3,8,2,6\\]\\].\n \nThe resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.\n\n",
                "**Example 3:**\n\n**Input:** trees = \\[\\[5,4\\],\\[3\\]\\]\n**Output:** \\[\\]\n**Explanation:** It is impossible to perform any operations."
            ],
            "constraints": "**Constraints:**\n\n*   `n == trees.length`\n*   `1 <= n <= 5 * 104`\n*   The number of nodes in each tree is in the range `[1, 3]`.\n*   Each node in the input may have children but no grandchildren.\n*   No two roots of `trees` have the same value.\n*   All the trees in the input are **valid BSTs**.\n*   `1 <= TreeNode.val <= 5 * 104`.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Binary Search",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[[2,1],[3,2,5],[5,4]]",
                "output": "[3,2,5,1,null,4]"
            },
            {
                "input": "[[5,3,8],[3,2,6]]",
                "output": "[]"
            },
            {
                "input": "[[5,4],[3]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic TreeNode canMerge(List<TreeNode> trees) {\n    Map<Integer, Integer> leafCount = new HashMap<>();\n    Map<Integer, TreeNode> rootMap = new HashMap<>();\n    \n    for (TreeNode tree : trees) {\n        if (tree.left != null) {\n            leafCount.put(tree.left.val, leafCount.getOrDefault(tree.left.val, 0) + 1);\n        }\n        if (tree.right != null) {\n            leafCount.put(tree.right.val, leafCount.getOrDefault(tree.right.val, 0) + 1);\n        }\n        rootMap.put(tree.val, tree);\n    }\n    \n    for (TreeNode tree : trees) {\n        if (leafCount.getOrDefault(tree.val, 0) == 0) {\n            if (isValidBST(tree, 0, 5 * (int)Math.pow(10, 4) + 1, rootMap, leafCount)) {\n                return tree;\n            }\n            break;\n        }\n    }\n    return null;\n}\n\nprivate boolean isValidBST(TreeNode node, int minVal, int maxVal, Map<Integer, TreeNode> rootMap, Map<Integer, Integer> leafCount) {\n    if (node == null) {\n        return true;\n    }\n    if (node.val <= minVal || node.val >= maxVal) {\n        return false;\n    }\n    if (rootMap.containsKey(node.left == null ? -1 : node.left.val)) {\n        TreeNode leftChild = rootMap.remove(node.left.val);\n        leafCount.put(node.left.val, leafCount.get(node.left.val) - 1);\n        node.left = leftChild;\n    }\n    if (rootMap.containsKey(node.right == null ? -1 : node.right.val)) {\n        TreeNode rightChild = rootMap.remove(node.right.val);\n        leafCount.put(node.right.val, leafCount.get(node.right.val) - 1);\n        node.right = rightChild;\n    }\n    return isValidBST(node.left, minVal, node.val, rootMap, leafCount) && isValidBST(node.right, node.val, maxVal, rootMap, leafCount);\n}\n```\n    \n    The algorithm begins by creating two hash maps, one for counting the occurrence of each leaf value, and another one to map the root values to their corresponding trees.\n\nNext, we define a helper function, `isValidBST`, that will recursively check if the tree is a valid binary search tree, given a specific minimum and maximum value. If a leaf node has a matching root node in the `rootMap`, we replace the leaf node with the matching tree and decrement the leaf count.\n\nThe next step is to loop through each tree in the input array `trees`. If a tree's root value has a leaf count of 0, that means it's a candidate for being the main root node of the final, merged tree. For each candidate, we then call our `isValidBST` function to check if it's possible to create a valid BST by performing `n - 1` operations.\n\nIf the `isValidBST` function returns true, we return the current tree's root node, as it's the final, merged tree. If no such tree exists, we return `null`, indicating that it's not possible to create a valid BST.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef canMerge(trees):\n    leaf_count = {}\n    root_map = {}\n    \n    for tree in trees:\n        if tree.left:\n            leaf_count[tree.left.val] = leaf_count.get(tree.left.val, 0) + 1\n        if tree.right:\n            leaf_count[tree.right.val] = leaf_count.get(tree.right.val, 0) + 1\n        root_map[tree.val] = tree\n\n    def is_valid_bst(node, min_val, max_val):\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        if node.left and node.left.val in root_map:\n            left_child = root_map.pop(node.left.val)\n            leaf_count[tree.left.val] -= 1\n            tree.left = left_child\n        if node.right and node.right.val in root_map:\n            right_child = root_map.pop(node.right.val)\n            leaf_count[tree.right.val] -= 1\n            tree.right = right_child\n        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n            \n\n    for tree in trees:\n        if leaf_count.get(tree.val, 0) == 0:\n            if is_valid_bst(tree, 0, 5e4 + 1):\n                return tree\n            break\n\n    return None\n```\n    \n    The algorithm begins by creating two hash maps, one for counting the occurrence of each leaf value, and another one to map the root values to their corresponding trees.\n\nNext, we define a helper function, `isValidBST`, that will recursively check if the tree is a valid binary search tree, given a specific minimum and maximum value. If a leaf node has a matching root node in the `rootMap`, we replace the leaf node with the matching tree and decrement the leaf count.\n\nThe next step is to loop through each tree in the input array `trees`. If a tree's root value has a leaf count of 0, that means it's a candidate for being the main root node of the final, merged tree. For each candidate, we then call our `isValidBST` function to check if it's possible to create a valid BST by performing `n - 1` operations.\n\nIf the `isValidBST` function returns true, we return the current tree's root node, as it's the final, merged tree. If no such tree exists, we return `null`, indicating that it's not possible to create a valid BST.\n    ",
        "c++": "\n    ```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* canMerge(vector<TreeNode*>& trees) {\n    unordered_map<int, int> leafCount;\n    unordered_map<int, TreeNode*> rootMap;\n    for (TreeNode* tree : trees) {\n        if (tree->left) {\n            leafCount[tree->left->val]++;\n        }\n        if (tree->right) {\n            leafCount[tree->right->val]++;\n        }\n        rootMap[tree->val] = tree;\n    }\n\n    function<bool(TreeNode*, int, int)> isValidBST = [&](TreeNode* node, int minVal, int maxVal) {\n        if (!node) {\n            return true;\n        }\n        if (node->val <= minVal || node->val >= maxVal) {\n            return false;\n        }\n        return isValidBST(node->left, minVal, node->val) && isValidBST(node->right, node->val, maxVal);\n    };\n\n    for (TreeNode* tree : trees) {\n        if (leafCount[tree->val] == 0) {\n            if (isValidBST(tree, 0, 5e4 + 1)) {\n                return tree;\n            }\n            break;\n        }\n    }\n    return NULL;\n}\n```\n    \n    The algorithm begins by creating two hash maps, one for counting the occurrence of each leaf value, and another one to map the root values to their corresponding trees.\n\nNext, we define a helper function, `isValidBST`, that will recursively check if the tree is a valid binary search tree, given a specific minimum and maximum value. If a leaf node has a matching root node in the `rootMap`, we replace the leaf node with the matching tree and decrement the leaf count.\n\nThe next step is to loop through each tree in the input array `trees`. If a tree's root value has a leaf count of 0, that means it's a candidate for being the main root node of the final, merged tree. For each candidate, we then call our `isValidBST` function to check if it's possible to create a valid BST by performing `n - 1` operations.\n\nIf the `isValidBST` function returns true, we return the current tree's root node, as it's the final, merged tree. If no such tree exists, we return `null`, indicating that it's not possible to create a valid BST.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction canMerge(trees) {\n    const leafCount = new Map();\n    const rootMap = new Map();\n    \n    for (const tree of trees) {\n        if (tree.left) {\n            leafCount.set(tree.left.val, (leafCount.get(tree.left.val) || 0) + 1);\n        }\n        if (tree.right) {\n            leafCount.set(tree.right.val, (leafCount.get(tree.right.val) || 0) + 1);\n        }\n        rootMap.set(tree.val, tree);\n    }\n    \n    function isValidBST(node, minVal, maxVal) {\n        if (!node) {\n            return true;\n        }\n        if (node.val <= minVal || node.val >= maxVal) {\n            return false;\n        }\n        if (node.left && rootMap.has(node.left.val)) {\n            const leftChild = rootMap.get(node.left.val);\n            leafCount.set(node.left.val, leafCount.get(node.left.val) - 1);\n            rootMap.delete(node.left.val);\n            node.left = leftChild;\n        }\n        if (node.right && rootMap.has(node.right.val)) {\n            const rightChild = rootMap.get(node.right.val);\n            leafCount.set(node.right.val, leafCount.get(node.right.val) - 1);\n            rootMap.delete(node.right.val);\n            node.right = rightChild;\n        }\n        return isValidBST(node.left, minVal, node.val) && isValidBST(node.right, node.val, maxVal);\n    }\n    \n    for (const tree of trees) {\n        if ((leafCount.get(tree.val) || 0) === 0) {\n            if (isValidBST(tree, 0, 5e4 + 1)) {\n                return tree;\n            }\n            break;\n        }\n    }\n    \n    return null;\n}\n```\n    \n    The algorithm begins by creating two hash maps, one for counting the occurrence of each leaf value, and another one to map the root values to their corresponding trees.\n\nNext, we define a helper function, `isValidBST`, that will recursively check if the tree is a valid binary search tree, given a specific minimum and maximum value. If a leaf node has a matching root node in the `rootMap`, we replace the leaf node with the matching tree and decrement the leaf count.\n\nThe next step is to loop through each tree in the input array `trees`. If a tree's root value has a leaf count of 0, that means it's a candidate for being the main root node of the final, merged tree. For each candidate, we then call our `isValidBST` function to check if it's possible to create a valid BST by performing `n - 1` operations.\n\nIf the `isValidBST` function returns true, we return the current tree's root node, as it's the final, merged tree. If no such tree exists, we return `null`, indicating that it's not possible to create a valid BST.\n    "
    },
    {
        "id": 322,
        "title": "Maximum Genetic Difference Query",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each node's number denotes its **unique genetic value** (i.e. the genetic value of node `x` is `x`). The **genetic difference** between two genetic values is defined as the **bitwise-****XOR** of their values. You are given the integer array `parents`, where `parents[i]` is the parent for node `i`. If node `x` is the **root** of the tree, then `parents[x] == -1`.\n\nYou are also given the array `queries` where `queries[i] = [nodei, vali]`. For each query `i`, find the **maximum genetic difference** between `vali` and `pi`, where `pi` is the genetic value of any node that is on the path between `nodei` and the root (including `nodei` and the root). More formally, you want to maximize `vali XOR pi`.\n\nReturn _an array_ `ans` _where_ `ans[i]` _is the answer to the_ `ith` _query_.",
            "examples": [
                "**Example 1:**\n\n**Input:** parents = \\[-1,0,1,1\\], queries = \\[\\[0,2\\],\\[3,2\\],\\[2,5\\]\\]\n**Output:** \\[2,3,7\\]\n**Explanation:** The queries are processed as follows:\n- \\[0,2\\]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.\n- \\[3,2\\]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.\n- \\[2,5\\]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n\n",
                "**Example 2:**\n\n**Input:** parents = \\[3,7,-1,2,0,7,0,2\\], queries = \\[\\[4,6\\],\\[1,15\\],\\[0,5\\]\\]\n**Output:** \\[6,14,7\\]\n**Explanation:** The queries are processed as follows:\n- \\[4,6\\]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.\n- \\[1,15\\]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.\n- \\[0,5\\]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= parents.length <= 105`\n*   `0 <= parents[i] <= parents.length - 1` for every node `i` that is **not** the root.\n*   `parents[root] == -1`\n*   `1 <= queries.length <= 3 * 104`\n*   `0 <= nodei <= parents.length - 1`\n*   `0 <= vali <= 2 * 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Bit Manipulation",
            "Depth-First Search",
            "Trie"
        ],
        "example": [
            {
                "input": "[-1,0,1,1],[[0,2],[3,2],[2,5]]",
                "output": "[2,3,7]"
            },
            {
                "input": "[3,7,-1,2,0,7,0,2],[[4,6],[1,15],[0,5]]",
                "output": "[6,14,7]"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    We iterate through the array starting from the second element. For each element, we check if it's smaller or equal to the previous one. If it is, we calculate the difference in value between the current and previous elements, add 1 to this difference, and accumulate it into a variable that keeps track of the operations needed to make the array strictly increasing. After that, we update the current element by adding 1 to the previous element, making them strictly increasing. We do this for all elements in the array, and finally return the accumulated operations needed. This approach has a time complexity of O(n) where n is the length of the array.\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += nums[i - 1] - nums[i] + 1\n            nums[i] = nums[i - 1] + 1\n    return operations\n```\n    \n    We iterate through the array starting from the second element. For each element, we check if it's smaller or equal to the previous one. If it is, we calculate the difference in value between the current and previous elements, add 1 to this difference, and accumulate it into a variable that keeps track of the operations needed to make the array strictly increasing. After that, we update the current element by adding 1 to the previous element, making them strictly increasing. We do this for all elements in the array, and finally return the accumulated operations needed. This approach has a time complexity of O(n) where n is the length of the array.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    We iterate through the array starting from the second element. For each element, we check if it's smaller or equal to the previous one. If it is, we calculate the difference in value between the current and previous elements, add 1 to this difference, and accumulate it into a variable that keeps track of the operations needed to make the array strictly increasing. After that, we update the current element by adding 1 to the previous element, making them strictly increasing. We do this for all elements in the array, and finally return the accumulated operations needed. This approach has a time complexity of O(n) where n is the length of the array.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    let operations = 0;\n    for (let i = 1; i < nums.length; ++i) {\n        if (nums[i] <= nums[i - 1]) {\n            operations += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    We iterate through the array starting from the second element. For each element, we check if it's smaller or equal to the previous one. If it is, we calculate the difference in value between the current and previous elements, add 1 to this difference, and accumulate it into a variable that keeps track of the operations needed to make the array strictly increasing. After that, we update the current element by adding 1 to the previous element, making them strictly increasing. We do this for all elements in the array, and finally return the accumulated operations needed. This approach has a time complexity of O(n) where n is the length of the array.\n    "
    },
    {
        "id": 323,
        "title": "Number of Visible People in a Queue",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in **left to right** order. You are given an array `heights` of **distinct** integers where `heights[i]` represents the height of the `ith` person.\n\nA person can **see** another person to their right in the queue if everybody in between is **shorter** than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`.\n\nReturn _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the **number of people** the_ `ith` _person can **see** to their right in the queue_.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[10,6,8,5,11,9\\]\n**Output:** \\[3,1,2,1,1,0\\]\n**Explanation:**\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[5,1,2,3,10\\]\n**Output:** \\[4,1,1,1,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == heights.length`\n*   `1 <= n <= 105`\n*   `1 <= heights[i] <= 105`\n*   All the values of `heights` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[10,6,8,5,11,9]",
                "output": "[3,1,2,1,1,0]"
            },
            {
                "input": "[5,1,2,3,10]",
                "output": "[4,1,1,1,0]"
            }
        ],
        "java": "\n    ```java\npublic String truncateSentence(String s, int k) {\n    String[] words = s.split(\" \");\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < k; i++) {\n        result.append(words[i]);\n        if (i < k - 1) {\n            result.append(\" \");\n        }\n    }\n    return result.toString();\n}\n```\n    \n    1. We start by splitting the given sentence (s) into a list of words.\n2. We then iterate through the list of words (or use slicing in some languages) to form the result, but only up to the k-th word.\n3. When the iterations are done or we formed the k-th word, we append the words with space as a delimiter.\n4. Finally, return the truncated sentence as a string.\n\nPlease note that some languages have slightly different syntax but the overall algorithm remains the same.\n    ",
        "python": "\n    ```python\ndef truncate_sentence(s, k):\n    words = s.split(' ')\n    return ' '.join(words[:k])\n```\n    \n    1. We start by splitting the given sentence (s) into a list of words.\n2. We then iterate through the list of words (or use slicing in some languages) to form the result, but only up to the k-th word.\n3. When the iterations are done or we formed the k-th word, we append the words with space as a delimiter.\n4. Finally, return the truncated sentence as a string.\n\nPlease note that some languages have slightly different syntax but the overall algorithm remains the same.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring truncateSentence(string s, int k) {\n    istringstream iss(s);\n    string word, result;\n    while (k > 0 && iss >> word) {\n        result += word;\n        k--;\n        if (k > 0) result += \" \";\n    }\n    return result;\n}\n```\n    \n    1. We start by splitting the given sentence (s) into a list of words.\n2. We then iterate through the list of words (or use slicing in some languages) to form the result, but only up to the k-th word.\n3. When the iterations are done or we formed the k-th word, we append the words with space as a delimiter.\n4. Finally, return the truncated sentence as a string.\n\nPlease note that some languages have slightly different syntax but the overall algorithm remains the same.\n    ",
        "js": "\n    ```javascript\nfunction truncateSentence(s, k) {\n    let words = s.split(' ');\n    return words.slice(0, k).join(' ');\n}\n```\n    \n    1. We start by splitting the given sentence (s) into a list of words.\n2. We then iterate through the list of words (or use slicing in some languages) to form the result, but only up to the k-th word.\n3. When the iterations are done or we formed the k-th word, we append the words with space as a delimiter.\n4. Finally, return the truncated sentence as a string.\n\nPlease note that some languages have slightly different syntax but the overall algorithm remains the same.\n    "
    },
    {
        "id": 324,
        "title": "Delete Duplicate Folders in System",
        "difficulty": "Hard",
        "content": {
            "problem": "Due to a bug, there are many duplicate folders in a file system. You are given a 2D array `paths`, where `paths[i]` is an array representing an absolute path to the `ith` folder in the file system.\n\n*   For example, `[ \"one \", \"two \", \"three \"]` represents the path `\"/one/two/three \"`.\n\nTwo folders (not necessarily on the same level) are **identical** if they contain the **same non-empty** set of identical subfolders and underlying subfolder structure. The folders **do not** need to be at the root level to be identical. If two or more folders are **identical**, then **mark** the folders as well as all their subfolders.\n\n*   For example, folders `\"/a \"` and `\"/b \"` in the file structure below are identical. They (as well as their subfolders) should **all** be marked:\n    *   `/a`\n    *   `/a/x`\n    *   `/a/x/y`\n    *   `/a/z`\n    *   `/b`\n    *   `/b/x`\n    *   `/b/x/y`\n    *   `/b/z`\n*   However, if the file structure also included the path `\"/b/w \"`, then the folders `\"/a \"` and `\"/b \"` would not be identical. Note that `\"/a/x \"` and `\"/b/x \"` would still be considered identical even with the added folder.\n\nOnce all the identical folders and their subfolders have been marked, the file system will **delete** all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.\n\nReturn _the 2D array_ `ans` _containing the paths of the **remaining** folders after deleting all the marked folders. The paths may be returned in **any** order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** paths = \\[\\[ \"a \"\\],\\[ \"c \"\\],\\[ \"d \"\\],\\[ \"a \", \"b \"\\],\\[ \"c \", \"b \"\\],\\[ \"d \", \"a \"\\]\\]\n**Output:** \\[\\[ \"d \"\\],\\[ \"d \", \"a \"\\]\\]\n**Explanation:** The file structure is as shown.\nFolders  \"/a \" and  \"/c \" (and their subfolders) are marked for deletion because they both contain an empty\nfolder named  \"b \".\n\n",
                "**Example 2:**\n\n**Input:** paths = \\[\\[ \"a \"\\],\\[ \"c \"\\],\\[ \"a \", \"b \"\\],\\[ \"c \", \"b \"\\],\\[ \"a \", \"b \", \"x \"\\],\\[ \"a \", \"b \", \"x \", \"y \"\\],\\[ \"w \"\\],\\[ \"w \", \"y \"\\]\\]\n**Output:** \\[\\[ \"c \"\\],\\[ \"c \", \"b \"\\],\\[ \"a \"\\],\\[ \"a \", \"b \"\\]\\]\n**Explanation:** The file structure is as shown. \nFolders  \"/a/b/x \" and  \"/w \" (and their subfolders) are marked for deletion because they both contain an empty folder named  \"y \".\nNote that folders  \"/a \" and  \"/c \" are identical after the deletion, but they are not deleted because they were not marked beforehand.\n\n",
                "**Example 3:**\n\n**Input:** paths = \\[\\[ \"a \", \"b \"\\],\\[ \"c \", \"d \"\\],\\[ \"c \"\\],\\[ \"a \"\\]\\]\n**Output:** \\[\\[ \"c \"\\],\\[ \"c \", \"d \"\\],\\[ \"a \"\\],\\[ \"a \", \"b \"\\]\\]\n**Explanation:** All folders are unique in the file system.\nNote that the returned array can be in a different order as the order does not matter."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= paths.length <= 2 * 104`\n*   `1 <= paths[i].length <= 500`\n*   `1 <= paths[i][j].length <= 10`\n*   `1 <= sum(paths[i][j].length) <= 2 * 105`\n*   `path[i][j]` consists of lowercase English letters.\n*   No two paths lead to the same folder.\n*   For any folder not at the root level, its parent folder will also be in the input.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Trie",
            "Hash Function"
        ],
        "example": [
            {
                "input": "[[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]",
                "output": "[[\"d\"],[\"d\",\"a\"]]"
            },
            {
                "input": "[[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]",
                "output": "[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]"
            },
            {
                "input": "[[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]",
                "output": "[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {\n    Map<String, Integer> folderCounts = new HashMap<>();\n\n    for (List<String> path : paths) {\n        StringBuilder pathString = new StringBuilder(\"/\" + path.get(0));\n        for (int i = 1; i < path.size(); i++) {\n            pathString.append(\"/\").append(path.get(i));\n        }\n        folderCounts.put(pathString.toString(), folderCounts.getOrDefault(pathString.toString(), 0) + 1);\n    }\n\n    List<List<String>> remainingPaths = new ArrayList<>();\n\n    for (List<String> path : paths) {\n        StringBuilder pathString = new StringBuilder(\"/\" + path.get(0));\n        boolean notDuplicate = folderCounts.get(pathString.toString()) == 1;\n        for (int i = 1; notDuplicate && i < path.size(); i++) {\n            pathString.append(\"/\").append(path.get(i));\n            if (folderCounts.get(pathString.toString()) > 1) {\n                notDuplicate = false;\n            }\n        }\n        if (notDuplicate) {\n            remainingPaths.add(path);\n        }\n    }\n\n    return remainingPaths;\n}\n```\n\n    \n    1. Build folder string paths from the input and count their occurrences in `folder_counts`.\n2. For each folder in `paths`, check if it is not a duplicate by checking if all subfolders in its full path have a count of 1 in `folder_counts`.\n   - If it is not a duplicate, add it to the `remaining_paths` list.\n3. Return the final list of `remaining_paths`.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef delete_duplicate_folder(paths):\n    folder_counts = defaultdict(int)\n    \n    for path in paths:\n        path_string = '/' + '/'.join(path)\n        folder_counts[path_string] += 1\n\n    remaining_paths = []\n\n    for path in paths:\n        path_string = '/' + path[0]\n        not_duplicate = folder_counts[path_string] == 1\n        for i in range(1, len(path)):\n            path_string += '/' + path[i]\n            if folder_counts[path_string] > 1:\n                not_duplicate = False\n                break\n        if not_duplicate:\n            remaining_paths.append(path)\n\n    return remaining_paths\n```\n\n    \n    1. Build folder string paths from the input and count their occurrences in `folder_counts`.\n2. For each folder in `paths`, check if it is not a duplicate by checking if all subfolders in its full path have a count of 1 in `folder_counts`.\n   - If it is not a duplicate, add it to the `remaining_paths` list.\n3. Return the final list of `remaining_paths`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <map>\n\nstd::vector<std::vector<std::string>> deleteDuplicateFolder(std::vector<std::vector<std::string>>& paths) {\n    std::map<std::string, int> folder_counts;\n    \n    for (auto& path : paths) {\n        std::string path_string = \"/\" + path[0];\n        for (int i = 1; i < path.size(); i++) {\n            path_string += \"/\" + path[i];\n        }\n        folder_counts[path_string]++;\n    }\n\n    std::vector<std::vector<std::string>> remaining_paths;\n    \n    for (auto& path : paths) {\n        std::string path_string = \"/\" + path[0];\n        bool not_duplicate = folder_counts[path_string] == 1;\n        for (int i = 1; not_duplicate && i < path.size(); i++) {\n            path_string += \"/\" + path[i];\n            if (folder_counts[path_string] > 1) {\n                not_duplicate = false;\n            }\n        }\n        if (not_duplicate) {\n            remaining_paths.push_back(path);\n        }\n    }\n\n    return remaining_paths;\n}\n```\n\n    \n    1. Build folder string paths from the input and count their occurrences in `folder_counts`.\n2. For each folder in `paths`, check if it is not a duplicate by checking if all subfolders in its full path have a count of 1 in `folder_counts`.\n   - If it is not a duplicate, add it to the `remaining_paths` list.\n3. Return the final list of `remaining_paths`.\n    ",
        "js": "\n    ```javascript\nfunction deleteDuplicateFolder(paths) {\n    const folderCounts = new Map();\n\n    for (const path of paths) {\n        const pathString = '/' + path.join('/');\n        folderCounts.set(pathString, (folderCounts.get(pathString) || 0) + 1);\n    }\n\n    const remainingPaths = [];\n\n    for (const path of paths) {\n        let pathString = '/' + path[0];\n        let notDuplicate = folderCounts.get(pathString) === 1;\n        for (let i = 1; notDuplicate && i < path.length; i++) {\n            pathString += '/' + path[i];\n            if (folderCounts.get(pathString) > 1) {\n                notDuplicate = false;\n            }\n        }\n        if (notDuplicate) {\n            remainingPaths.push(path);\n        }\n    }\n\n    return remainingPaths;\n}\n```\n\n    \n    1. Build folder string paths from the input and count their occurrences in `folder_counts`.\n2. For each folder in `paths`, check if it is not a duplicate by checking if all subfolders in its full path have a count of 1 in `folder_counts`.\n   - If it is not a duplicate, add it to the `remaining_paths` list.\n3. Return the final list of `remaining_paths`.\n    "
    },
    {
        "id": 325,
        "title": "Count Number of Special Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "A sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s.\n\n*   For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special.\n*   In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special.\n\nGiven an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return _the **number of different subsequences** that are special_. Since the answer may be very large, **return it modulo** `109 + 7`.\n\nA **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** The special subsequences are bolded \\[**0**,**1**,**2**,2\\], \\[**0**,**1**,2,**2**\\], and \\[**0**,**1**,**2**,**2**\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,0,0\\]\n**Output:** 0\n**Explanation:** There are no special subsequences in \\[2,2,0,0\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,1,2,0,1,2\\]\n**Output:** 7\n**Explanation:** The special subsequences are bolded:\n- \\[**0**,**1**,**2**,0,1,2\\]\n- \\[**0**,**1**,2,0,1,**2**\\]\n- \\[**0**,**1**,**2**,0,1,**2**\\]\n- \\[**0**,**1**,2,0,**1**,**2**\\]\n- \\[**0**,1,2,**0**,**1**,**2**\\]\n- \\[**0**,1,2,0,**1**,**2**\\]\n- \\[0,1,2,**0**,**1**,**2**\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 2`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[0,1,2,2]",
                "output": "3"
            },
            {
                "input": "[2,2,0,0]",
                "output": "0"
            },
            {
                "input": "[0,1,2,0,1,2]",
                "output": "7"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\nclass SeatManager {\n    private PriorityQueue<Integer> availableSeats;\n\n    public SeatManager(int n) {\n        availableSeats = new PriorityQueue<>();\n        for (int i = 1; i <= n; i++) {\n            availableSeats.add(i);\n        }\n    }\n\n    public int reserve() {\n        return availableSeats.poll();\n    }\n\n    public void unreserve(int seatNumber) {\n        availableSeats.add(seatNumber);\n    }\n}\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    ",
        "python": "\n    ```python\nimport heapq\n\nclass SeatManager:\n    def __init__(self, n: int):\n        self.available_seats = [i for i in range(1, n + 1)]\n        heapq.heapify(self.available_seats)\n\n    def reserve(self) -> int:\n        return heapq.heappop(self.available_seats)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heapq.heappush(self.available_seats, seatNumber)\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n\nclass SeatManager {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> available_seats;\npublic:\n    SeatManager(int n) {\n        for (int i = 1; i <= n; ++i) {\n            available_seats.push(i);\n        }\n    }\n\n    int reserve() {\n        int seat = available_seats.top();\n        available_seats.pop();\n        return seat;\n    }\n\n    void unreserve(int seatNumber) {\n        available_seats.push(seatNumber);\n    }\n};\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    ",
        "js": "\n    ```javascript\nclass SeatManager {\n    constructor(n) {\n        this.availableSeats = [];\n        for (let i = 1; i <= n; i++) {\n            this.availableSeats.push(i);\n        }\n        this.availableSeats.sort((a, b) => a - b);\n    }\n\n    reserve() {\n        return this.availableSeats.shift();\n    }\n\n    unreserve(seatNumber) {\n        this.availableSeats.push(seatNumber);\n        this.availableSeats.sort((a, b) => a - b);\n    }\n}\n```\n    \n    The SeatManager class manages the reservation state of n seats numbered from 1 to n. To implement this, we use a priority queue data structure to represent available seats. The priority queue allows us to efficiently fetch the lowest available seat number and maintain an ordered list when a seat is unreserved.\n\nThe constructor initializes the available_seats priority queue with seat numbers ranging from 1 to n.\n\nThe reserve() function reserves the seat by returning the lowest available seat number and removing it from the priority queue.\n\nThe unreserve(int seatNumber) function accepts a seat number as an argument and returns the seat to the priority queue of available seats.\n\nIn all languages, we use the built-in priority queue implementation (min-heap in case of Python, PriorityQueue in Java, and custom implementation using array and sort functions in JavaScript).\n    "
    },
    {
        "id": 326,
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** string `s` and are tasked with finding two **non-intersecting palindromic** substrings of **odd** length such that the product of their lengths is maximized.\n\nMore formally, you want to choose four integers `i`, `j`, `k`, `l` such that `0 <= i <= j < k <= l < s.length` and both the substrings `s[i...j]` and `s[k...l]` are palindromes and have odd lengths. `s[i...j]` denotes a substring from index `i` to index `j` **inclusive**.\n\nReturn _the **maximum** possible product of the lengths of the two non-intersecting palindromic substrings._\n\nA **palindrome** is a string that is the same forward and backward. A **substring** is a contiguous sequence of characters in a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ababbb \"\n**Output:** 9\n**Explanation:** Substrings  \"aba \" and  \"bbb \" are palindromes with odd length. product = 3 \\* 3 = 9.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"zaaaxbbby \"\n**Output:** 9\n**Explanation:** Substrings  \"aaa \" and  \"bbb \" are palindromes with odd length. product = 3 \\* 3 = 9."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Rolling Hash",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"ababbb\"",
                "output": "9"
            },
            {
                "input": "\"zaaaxbbby\"",
                "output": "9"
            }
        ],
        "java": "\n    ```java\npublic boolean isPangram(String sentence) {\n    boolean[] alphabet = new boolean[26];\n    for (char c : sentence.toCharArray()) {\n        alphabet[c - 'a'] = true;\n    }\n    for (boolean flag : alphabet) {\n        if (!flag) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm starts by creating an array called `alphabet`, which contains 26 boolean elements, initially all set to false. This array represents the English alphabet from 'a' to 'z', where each false value means the corresponding letter hasn't been found yet in the sentence, and true indicates that the letter has been found.\n\nNext, we iterate through each character in the input sentence. For each character, we update the corresponding index in the `alphabet` array by setting its value to true. The index is calculated by subtracting the ASCII code of the character 'a' from the ASCII code of the current character.\n\nFinally, we iterate through the boolean elements in the `alphabet` array. If any of the elements are still set to false, it means that the corresponding letter hasn't appeared in the sentence, and so we return false. If all elements are true, it means that each letter of the alphabet appeared at least once in the sentence, making it a pangram, so we return true.\n    ",
        "python": "\n    ```python\ndef is_pangram(sentence):\n    alphabet = [False] * 26\n    for c in sentence:\n        alphabet[ord(c) - ord('a')] = True\n    return all(alphabet)\n```\n    \n    The algorithm starts by creating an array called `alphabet`, which contains 26 boolean elements, initially all set to false. This array represents the English alphabet from 'a' to 'z', where each false value means the corresponding letter hasn't been found yet in the sentence, and true indicates that the letter has been found.\n\nNext, we iterate through each character in the input sentence. For each character, we update the corresponding index in the `alphabet` array by setting its value to true. The index is calculated by subtracting the ASCII code of the character 'a' from the ASCII code of the current character.\n\nFinally, we iterate through the boolean elements in the `alphabet` array. If any of the elements are still set to false, it means that the corresponding letter hasn't appeared in the sentence, and so we return false. If all elements are true, it means that each letter of the alphabet appeared at least once in the sentence, making it a pangram, so we return true.\n    ",
        "c++": "\n    ```cpp\nbool is_pangram(const std::string& sentence) {\n    std::vector<bool> alphabet(26, false);\n    for (const char& c : sentence) {\n        alphabet[c - 'a'] = true;\n    }\n    for (bool flag : alphabet) {\n        if (!flag) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm starts by creating an array called `alphabet`, which contains 26 boolean elements, initially all set to false. This array represents the English alphabet from 'a' to 'z', where each false value means the corresponding letter hasn't been found yet in the sentence, and true indicates that the letter has been found.\n\nNext, we iterate through each character in the input sentence. For each character, we update the corresponding index in the `alphabet` array by setting its value to true. The index is calculated by subtracting the ASCII code of the character 'a' from the ASCII code of the current character.\n\nFinally, we iterate through the boolean elements in the `alphabet` array. If any of the elements are still set to false, it means that the corresponding letter hasn't appeared in the sentence, and so we return false. If all elements are true, it means that each letter of the alphabet appeared at least once in the sentence, making it a pangram, so we return true.\n    ",
        "js": "\n    ```javascript\nfunction isPangram(sentence) {\n    const alphabet = new Array(26).fill(false);\n    for (const c of sentence) {\n        alphabet[c.charCodeAt(0) - 'a'.charCodeAt(0)] = true;\n    }\n    return alphabet.every(flag => flag);\n}\n```\n    \n    The algorithm starts by creating an array called `alphabet`, which contains 26 boolean elements, initially all set to false. This array represents the English alphabet from 'a' to 'z', where each false value means the corresponding letter hasn't been found yet in the sentence, and true indicates that the letter has been found.\n\nNext, we iterate through each character in the input sentence. For each character, we update the corresponding index in the `alphabet` array by setting its value to true. The index is calculated by subtracting the ASCII code of the character 'a' from the ASCII code of the current character.\n\nFinally, we iterate through the boolean elements in the `alphabet` array. If any of the elements are still set to false, it means that the corresponding letter hasn't appeared in the sentence, and so we return false. If all elements are true, it means that each letter of the alphabet appeared at least once in the sentence, making it a pangram, so we return true.\n    "
    },
    {
        "id": 327,
        "title": "Find the Longest Valid Obstacle Course at Each Position",
        "difficulty": "Hard",
        "content": {
            "problem": "You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that:\n\n*   You choose any number of obstacles between `0` and `i` **inclusive**.\n*   You must include the `ith` obstacle in the course.\n*   You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n*   Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i` _as described above_.",
            "examples": [
                "**Example 1:**\n\n**Input:** obstacles = \\[1,2,3,2\\]\n**Output:** \\[1,2,3,3\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[1\\], \\[1\\] has length 1.\n- i = 1: \\[1,2\\], \\[1,2\\] has length 2.\n- i = 2: \\[1,2,3\\], \\[1,2,3\\] has length 3.\n- i = 3: \\[1,2,3,2\\], \\[1,2,2\\] has length 3.\n\n",
                "**Example 2:**\n\n**Input:** obstacles = \\[2,2,1\\]\n**Output:** \\[1,2,1\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[2\\], \\[2\\] has length 1.\n- i = 1: \\[2,2\\], \\[2,2\\] has length 2.\n- i = 2: \\[2,2,1\\], \\[1\\] has length 1.\n\n",
                "**Example 3:**\n\n**Input:** obstacles = \\[3,1,5,6,4,2\\]\n**Output:** \\[1,1,2,3,2,2\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[3\\], \\[3\\] has length 1.\n- i = 1: \\[3,1\\], \\[1\\] has length 1.\n- i = 2: \\[3,1,5\\], \\[3,5\\] has length 2. \\[1,5\\] is also valid.\n- i = 3: \\[3,1,5,6\\], \\[3,5,6\\] has length 3. \\[1,5,6\\] is also valid.\n- i = 4: \\[3,1,5,6,4\\], \\[3,4\\] has length 2. \\[1,4\\] is also valid.\n- i = 5: \\[3,1,5,6,4,2\\], \\[1,2\\] has length 2."
            ],
            "constraints": "**Constraints:**\n\n*   `n == obstacles.length`\n*   `1 <= n <= 105`\n*   `1 <= obstacles[i] <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Binary Indexed Tree"
        ],
        "example": [
            {
                "input": "[1,2,3,2]",
                "output": "[1,2,3,3]"
            },
            {
                "input": "[2,2,1]",
                "output": "[1,2,1]"
            },
            {
                "input": "[3,1,5,6,4,2]",
                "output": "[1,1,2,3,2,2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] longestObstacleCourse(int[] obstacles) {\n    int[] dp = new int[obstacles.length];\n    int len = 0;\n\n    for (int obstacle : obstacles) {\n        int i = Arrays.binarySearch(dp, 0, len, obstacle);\n        if (i < 0) {\n            i = -(i + 1);\n        }\n        dp[i] = obstacle;\n        if (i == len) {\n            len++;\n        }\n    }\n\n    return dp;\n}\n```\n    \n    The main idea of the algorithm is to use dynamic programming to build a list of subproblems (dp), where dp[i] represents the smallest height of the i-th obstacle in a valid course of length i+1.\n\nFor each obstacle, we do a binary search in our dp list to find the index where the current obstacle should be put, updating the dp list accordingly. We save the index + 1 in our ans list, since this represents the length of the longest obstacle course including the current obstacle.\n\nFinally, the dynamic programming table is updated with the index found, and we return ans.\n    ",
        "python": "\n    ```python\ndef longest_obstacle_course(obstacles):\n    dp = []\n    ans = [0] * len(obstacles)\n\n    for obstacle in obstacles:\n        index = bisect_left(dp, obstacle)\n        ans[index] = index + 1\n        if index == len(dp):\n            dp.append(obstacle)\n        else:\n            dp[index] = obstacle\n\n    return ans\n```\n    \n    The main idea of the algorithm is to use dynamic programming to build a list of subproblems (dp), where dp[i] represents the smallest height of the i-th obstacle in a valid course of length i+1.\n\nFor each obstacle, we do a binary search in our dp list to find the index where the current obstacle should be put, updating the dp list accordingly. We save the index + 1 in our ans list, since this represents the length of the longest obstacle course including the current obstacle.\n\nFinally, the dynamic programming table is updated with the index found, and we return ans.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> longestObstacleCourse(std::vector<int>& obstacles) {\n    std::vector<int> dp;\n    std::vector<int> ans(obstacles.size());\n\n    for (int i = 0; i < obstacles.size(); ++i) {\n        auto it = std::lower_bound(dp.begin(), dp.end(), obstacles[i]);\n        ans[i] = std::distance(dp.begin(), it) + 1;\n        if (it == dp.end()) {\n            dp.push_back(obstacles[i]);\n        } else {\n            *it = obstacles[i];\n        }\n    }\n\n    return ans;\n}\n```\n    \n    The main idea of the algorithm is to use dynamic programming to build a list of subproblems (dp), where dp[i] represents the smallest height of the i-th obstacle in a valid course of length i+1.\n\nFor each obstacle, we do a binary search in our dp list to find the index where the current obstacle should be put, updating the dp list accordingly. We save the index + 1 in our ans list, since this represents the length of the longest obstacle course including the current obstacle.\n\nFinally, the dynamic programming table is updated with the index found, and we return ans.\n    ",
        "js": "\n    ```javascript\nfunction longestObstacleCourse(obstacles) {\n    const dp = [];\n    const ans = new Array(obstacles.length).fill(0);\n\n    for (let obstacle of obstacles) {\n        let index = binarySearch(dp, obstacle);\n        ans[index] = index + 1;\n        if (index === dp.length) {\n            dp.push(obstacle);\n        } else {\n            dp[index] = obstacle;\n        }\n    }\n\n    return ans;\n}\n\nfunction binarySearch(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n\n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The main idea of the algorithm is to use dynamic programming to build a list of subproblems (dp), where dp[i] represents the smallest height of the i-th obstacle in a valid course of length i+1.\n\nFor each obstacle, we do a binary search in our dp list to find the index where the current obstacle should be put, updating the dp list accordingly. We save the index + 1 in our ans list, since this represents the length of the longest obstacle course including the current obstacle.\n\nFinally, the dynamic programming table is updated with the index found, and we return ans.\n    "
    },
    {
        "id": 328,
        "title": "Last Day Where You Can Still Cross",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively.\n\nInitially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`).\n\nYou want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down).\n\nReturn _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_.",
            "examples": [
                "**Example 1:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[2,1\\],\\[1,2\\],\\[2,2\\]\\]\n**Output:** 2\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n",
                "**Example 2:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[1,2\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:** 1\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n",
                "**Example 3:**\n\n**Input:** row = 3, col = 3, cells = \\[\\[1,2\\],\\[2,1\\],\\[3,3\\],\\[2,2\\],\\[1,1\\],\\[1,3\\],\\[2,3\\],\\[3,2\\],\\[3,1\\]\\]\n**Output:** 3\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= row, col <= 2 * 104`\n*   `4 <= row * col <= 2 * 104`\n*   `cells.length == row * col`\n*   `1 <= ri <= row`\n*   `1 <= ci <= col`\n*   All the values of `cells` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Matrix"
        ],
        "example": [
            {
                "input": "2,2,[[1,1],[2,1],[1,2],[2,2]]",
                "output": "2"
            },
            {
                "input": "2,2,[[1,1],[1,2],[2,1],[2,2]]",
                "output": "1"
            },
            {
                "input": "3,3,[[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String sortSentence(String s) {\n    String[] tokens = s.split(\" \");\n    String[] words = new String[tokens.length];\n    \n    for (String token : tokens) {\n        int pos = Integer.parseInt(token.substring(token.length() - 1)) - 1;\n        words[pos] = token.substring(0, token.length() - 1);\n    }\n    \n    return String.join(\" \", words);\n}\n```\n    \n    1. First, we split the input string into an array of words or tokens.\n2. We create a new array called 'words' of equal length as tokens.\n3. Then, we iterate through each token in the tokens array.\n4. For each token, we parse its last character as the 1-indexed position and calculate the 0-indexed position by subtracting 1.\n5. We then use slicing or substring methods to remove the last character of the token and store the result in the corresponding 0-indexed position in the 'words' array.\n6. Finally, after processing all tokens, we join the words array back into a single string separated by spaces and return it as the original sentence.\n    ",
        "python": "\n    ```python\ndef sort_sentence(s: str) -> str:\n    tokens = s.split()\n    words = [''] * len(tokens)\n    \n    for token in tokens:\n        pos = int(token[-1]) - 1\n        words[pos] = token[:-1]\n    \n    return ' '.join(words)\n```\n    \n    1. First, we split the input string into an array of words or tokens.\n2. We create a new array called 'words' of equal length as tokens.\n3. Then, we iterate through each token in the tokens array.\n4. For each token, we parse its last character as the 1-indexed position and calculate the 0-indexed position by subtracting 1.\n5. We then use slicing or substring methods to remove the last character of the token and store the result in the corresponding 0-indexed position in the 'words' array.\n6. Finally, after processing all tokens, we join the words array back into a single string separated by spaces and return it as the original sentence.\n    ",
        "c++": "\n    ```cpp\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string sortSentence(const std::string& s) {\n    std::istringstream iss(s);\n    std::vector<std::pair<int, std::string>> words;\n    std::string word;\n    \n    while (iss >> word) {\n        int pos = word.back() - '0';\n        word.pop_back();\n        words.emplace_back(pos, word);\n    }\n    \n    std::sort(words.begin(), words.end());\n    \n    std::string result;\n    for (const auto& pair : words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += pair.second;\n    }\n    \n    return result;\n}\n```\n    \n    1. First, we split the input string into an array of words or tokens.\n2. We create a new array called 'words' of equal length as tokens.\n3. Then, we iterate through each token in the tokens array.\n4. For each token, we parse its last character as the 1-indexed position and calculate the 0-indexed position by subtracting 1.\n5. We then use slicing or substring methods to remove the last character of the token and store the result in the corresponding 0-indexed position in the 'words' array.\n6. Finally, after processing all tokens, we join the words array back into a single string separated by spaces and return it as the original sentence.\n    ",
        "js": "\n    ```javascript\nfunction sortSentence(s) {\n    const tokens = s.split(\" \");\n    const words = Array(tokens.length);\n    \n    for (const token of tokens) {\n        const pos = parseInt(token.slice(-1)) - 1;\n        words[pos] = token.slice(0, -1);\n    }\n    \n    return words.join(\" \");\n}\n```\n    \n    1. First, we split the input string into an array of words or tokens.\n2. We create a new array called 'words' of equal length as tokens.\n3. Then, we iterate through each token in the tokens array.\n4. For each token, we parse its last character as the 1-indexed position and calculate the 0-indexed position by subtracting 1.\n5. We then use slicing or substring methods to remove the last character of the token and store the result in the corresponding 0-indexed position in the 'words' array.\n6. Finally, after processing all tokens, we join the words array back into a single string separated by spaces and return it as the original sentence.\n    "
    },
    {
        "id": 329,
        "title": "Number of Ways to Separate Numbers",
        "difficulty": "Hard",
        "content": {
            "problem": "You wrote down many **positive** integers in a string called `num`. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was **non-decreasing** and that **no** integer had leading zeros.\n\nReturn _the **number of possible lists of integers** that you could have written down to get the string_ `num`. Since the answer may be large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"327 \"\n**Output:** 2\n**Explanation:** You could have written down the numbers:\n3, 27\n327\n\n",
                "**Example 2:**\n\n**Input:** num =  \"094 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"0 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 3500`\n*   `num` consists of digits `'0'` through `'9'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Suffix Array"
        ],
        "example": [
            {
                "input": "\"327\"",
                "output": "2"
            },
            {
                "input": "\"094\"",
                "output": "0"
            },
            {
                "input": "\"0\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic int[] intervalFinding(int[][] intervals, int[] queries) {\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n    int[] ans = new int[queries.length];\n    for (int i = 0; i < queries.length; i++) {\n        int q = queries[i];\n        int min_size = Integer.MAX_VALUE;\n        for (int[] interval : intervals) {\n            if (interval[0] <= q && q <= interval[1]) {\n                min_size = Math.min(min_size, interval[1] - interval[0] + 1);\n            }\n        }\n        ans[i] = min_size == Integer.MAX_VALUE ? -1 : min_size;\n    }\n    return ans;\n}\n```\n\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    ",
        "python": "\n    ```python\ndef intervalFinding(intervals, queries):\n    intervals.sort(key=lambda x: x[0])\n    ans = []\n    for q in queries:\n        min_size = float('inf')\n        for interval in intervals:\n            if interval[0] <= q <= interval[1]:\n                min_size = min(min_size, interval[1] - interval[0] + 1)\n        ans.append(-1 if min_size == float('inf') else min_size)\n    return ans\n```\n\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> intervalFinding(vector<vector<int>>& intervals, vector<int>& queries) {\n    sort(intervals.begin(), intervals.end());\n    vector<int> ans;\n    for (int q : queries) {\n        int min_size = INT_MAX;\n        for (vector<int> &interval : intervals) {\n            if (interval[0] <= q && q <= interval[1]) {\n                min_size = min(min_size, interval[1] - interval[0] + 1);\n            }\n        }\n        ans.push_back(min_size == INT_MAX ? -1 : min_size);\n    }\n    return ans;\n}\n```\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    ",
        "js": "\n    ```javascript\nfunction intervalFinding(intervals, queries) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    const ans = [];\n    for (const q of queries) {\n        let min_size = Infinity;\n        for (const interval of intervals) {\n            if (interval[0] <= q && q <= interval[1]) {\n                min_size = Math.min(min_size, interval[1] - interval[0] + 1);\n            }\n        }\n        ans.push(min_size === Infinity ? -1 : min_size);\n    }\n    return ans;\n}\n```\n\n    \n    1. Sort the intervals based on their starting point (lefti) in ascending order, so we can have a quicker check while iterating through the intervals. This can be done with standard sorting function and custom compare function in each programming language.\n2. Initialize an empty answer array `ans` that will store the answer of each query.\n3. Iterate through the `queries` array.\n4. For each query `q`, initialize a `min_size` variable with maximum possible value for that language. Here we use `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, and `Infinity` for C++, Java, Python, and JavaScript, respectively.\n5. For each `interval` in the sorted `intervals`, if the query `q` lies within the given interval (lefti <= q <= righti), calculate the size of the interval (righti - lefti + 1) and update the `min_size` with the minimum value of the current interval size.\n6. After iterating through all the intervals, check if the `min_size` is still equal to the initial maximum value. If it is, the query didn't match any interval, so append `-1` to the answer array. Otherwise, append the `min_size`.\n7. Repeat these steps for all queries in the `queries` array.\n8. Finally, return the `ans` array.\n    "
    },
    {
        "id": 330,
        "title": "Find Array Given Subset Sums",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n` representing the length of an unknown array that you are trying to recover. You are also given an array `sums` containing the values of all `2n` **subset sums** of the unknown array (in no particular order).\n\nReturn _the array_ `ans` _of length_ `n` _representing the unknown array. If **multiple** answers exist, return **any** of them_.\n\nAn array `sub` is a **subset** of an array `arr` if `sub` can be obtained from `arr` by deleting some (possibly zero or all) elements of `arr`. The sum of the elements in `sub` is one possible **subset sum** of `arr`. The sum of an empty array is considered to be `0`.\n\n**Note:** Test cases are generated such that there will **always** be at least one correct answer.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, sums = \\[-3,-2,-1,0,0,1,2,3\\]\n**Output:** \\[1,2,-3\\]\n**Explanation:** \\[1,2,-3\\] is able to achieve the given subset sums:\n- \\[\\]: sum is 0\n- \\[1\\]: sum is 1\n- \\[2\\]: sum is 2\n- \\[1,2\\]: sum is 3\n- \\[-3\\]: sum is -3\n- \\[1,-3\\]: sum is -2\n- \\[2,-3\\]: sum is -1\n- \\[1,2,-3\\]: sum is 0\nNote that any permutation of \\[1,2,-3\\] and also any permutation of \\[-1,-2,3\\] will also be accepted.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, sums = \\[0,0,0,0\\]\n**Output:** \\[0,0\\]\n**Explanation:** The only correct answer is \\[0,0\\].\n\n",
                "**Example 3:**\n\n**Input:** n = 4, sums = \\[0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8\\]\n**Output:** \\[0,-1,4,5\\]\n**Explanation:** \\[0,-1,4,5\\] is able to achieve the given subset sums."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 15`\n*   `sums.length == 2n`\n*   `-104 <= sums[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer"
        ],
        "example": [
            {
                "input": "3,[-3,-2,-1,0,0,1,2,3]",
                "output": "[1,2,-3]"
            },
            {
                "input": "2,[0,0,0,0]",
                "output": "[0,0]"
            },
            {
                "input": "4,[0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]",
                "output": "[0,-1,4,5]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] recoverArray(int n, int[] sums) {\n        TreeSet<Integer> ms = new TreeSet<>();\n        for (int sum : sums) {\n            ms.add(sum);\n        }\n\n        ArrayList<Integer> ans = new ArrayList<>();\n        while (ans.size() < n) {\n            ms.pollFirst();\n            int cur = ms.first();\n            TreeSet<Integer> tmp = new TreeSet<>(ms);\n            for (int i : ans) {\n                tmp.remove(cur - i);\n            }\n            ans.add(cur);\n            ms = tmp;\n        }\n\n        return ans.stream().mapToInt(i -> i).toArray();\n    }\n}\n```\n    \n    Inside the algorithm, we start by creating a multiset with sums. For each iteration (up to `n`), we do the following steps:\n\n1. Delete the smallest element of `sums`, which is always zero.\n2. Get the next smallest element and append it to our result array `ans`.\n3. Remove the sums obtained by adding this element to the previous elements of the array `ans`.\n4. Update our `sums` with the removed sums.\n\nIn the end, we'll have the array `ans` with the desired result.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef recoverArray(n, sums):\n    sums = Counter(sums)\n    ans = []\n\n    while len(ans) < n:\n        # remove the 0 sum\n        sums[0] -= 1\n        if sums[0] == 0: del sums[0]\n\n        # selected next value\n        cur = next(iter(sums))\n        sums[cur] -= 1\n        if sums[cur] == 0: del sums[cur]\n\n        # update sums\n        tmp = Counter()\n        for k, v in sums.items():\n            cnt = v - Ans.count(k - cur)\n            if cnt > 0:\n                tmp[k] = cnt\n        sums = tmp\n        ans.append(cur)\n    return ans\n```\n    \n    Inside the algorithm, we start by creating a multiset with sums. For each iteration (up to `n`), we do the following steps:\n\n1. Delete the smallest element of `sums`, which is always zero.\n2. Get the next smallest element and append it to our result array `ans`.\n3. Remove the sums obtained by adding this element to the previous elements of the array `ans`.\n4. Update our `sums` with the removed sums.\n\nIn the end, we'll have the array `ans` with the desired result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <algorithm>\n\nstd::vector<int> recoverArray(int n, std::vector<int>& sums) {\n    std::multiset<int> ms(sums.begin(), sums.end());\n    std::vector<int> ans;\n\n    while (ans.size() < n) {\n        ms.erase(ms.begin());\n        int cur = *ms.begin();\n        std::multiset<int> tmp = ms;\n        for (int i : ans) {\n            tmp.erase(tmp.find(cur - i));\n        }\n        ans.push_back(cur);\n        ms = tmp;\n    }\n\n    return ans;\n}\n```\n    \n    Inside the algorithm, we start by creating a multiset with sums. For each iteration (up to `n`), we do the following steps:\n\n1. Delete the smallest element of `sums`, which is always zero.\n2. Get the next smallest element and append it to our result array `ans`.\n3. Remove the sums obtained by adding this element to the previous elements of the array `ans`.\n4. Update our `sums` with the removed sums.\n\nIn the end, we'll have the array `ans` with the desired result.\n    ",
        "js": "\n    ```javascript\nfunction recoverArray(n, sums) {\n    let ms = new Set(sums.sort((a, b) => a - b));\n    let ans = [];\n\n    while (ans.length < n) {\n        ms.delete(ms.values().next().value);\n        let cur = ms.values().next().value;\n\n        let tmp = new Set(ms);\n        for (let i of ans) {\n            tmp.delete(cur - i);\n        }\n\n        ans.push(cur);\n        ms = tmp;\n    }\n\n    return ans;\n}\n```\n    \n    Inside the algorithm, we start by creating a multiset with sums. For each iteration (up to `n`), we do the following steps:\n\n1. Delete the smallest element of `sums`, which is always zero.\n2. Get the next smallest element and append it to our result array `ans`.\n3. Remove the sums obtained by adding this element to the previous elements of the array `ans`.\n4. Update our `sums` with the removed sums.\n\nIn the end, we'll have the array `ans` with the desired result.\n    "
    },
    {
        "id": 331,
        "title": "Number of Unique Good Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0 \"`).\n\nFind the number of **unique good subsequences** of `binary`.\n\n*   For example, if `binary = \"001 \"`, then all the **good** subsequences are `[ \"0 \", \"0 \", \"1 \"]`, so the **unique** good subsequences are `\"0 \"` and `\"1 \"`. Note that subsequences `\"00 \"`, `\"01 \"`, and `\"001 \"` are not good because they have leading zeros.\n\nReturn _the number of **unique good subsequences** of_ `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** binary =  \"001 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"0 \",  \"0 \",  \"1 \"\\].\nThe unique good subsequences are  \"0 \" and  \"1 \".\n\n",
                "**Example 2:**\n\n**Input:** binary =  \"11 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"1 \",  \"11 \"\\].\nThe unique good subsequences are  \"1 \" and  \"11 \".\n\n",
                "**Example 3:**\n\n**Input:** binary =  \"101 \"\n**Output:** 5\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"0 \",  \"1 \",  \"10 \",  \"11 \",  \"101 \"\\]. \nThe unique good subsequences are  \"0 \",  \"1 \",  \"10 \",  \"11 \", and  \"101 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= binary.length <= 105`\n*   `binary` consists of only `'0'`s and `'1'`s.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"001\"",
                "output": "2"
            },
            {
                "input": "\"11\"",
                "output": "2"
            },
            {
                "input": "\"101\"",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int countGoodSubstrings(String s) {\n    int count = 0;\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s.charAt(i) != s.charAt(i + 1) && s.charAt(i) != s.charAt(i + 2) && s.charAt(i + 1) != s.charAt(i + 2))\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ",
        "python": "\n    ```python\ndef count_good_substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            count += 1\n    return count\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ",
        "c++": "\n    ```cpp\nint countGoodSubstrings(const std::string &s) {\n    int count = 0;\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (s[i] != s[i + 1] && s[i] != s[i + 2] && s[i + 1] != s[i + 2])\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ",
        "js": "\n    ```javascript\nfunction countGoodSubstrings(s) {\n    let count = 0;\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s[i] !== s[i + 1] && s[i] !== s[i + 2] && s[i + 1] !== s[i + 2])\n            count++;\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    "
    },
    {
        "id": 332,
        "title": "The Number of Good Subsets",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums`. We call a subset of `nums` **good** if its product can be represented as a product of one or more **distinct prime** numbers.\n\n*   For example, if `nums = [1, 2, 3, 4]`:\n    *   `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are **good** subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively.\n    *   `[1, 4]` and `[4]` are not **good** subsets with products `4 = 2*2` and `4 = 2*2` respectively.\n\nReturn _the number of different **good** subsets in_ `nums` _**modulo**_ `109 + 7`.\n\nA **subset** of `nums` is any array that can be obtained by deleting some (possibly none or all) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 6\n**Explanation:** The good subsets are:\n- \\[1,2\\]: product is 2, which is the product of distinct prime 2.\n- \\[1,2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[1,3\\]: product is 3, which is the product of distinct prime 3.\n- \\[2\\]: product is 2, which is the product of distinct prime 2.\n- \\[2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[3\\]: product is 3, which is the product of distinct prime 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,2,3,15\\]\n**Output:** 5\n**Explanation:** The good subsets are:\n- \\[2\\]: product is 2, which is the product of distinct prime 2.\n- \\[2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[2,15\\]: product is 30, which is the product of distinct primes 2, 3, and 5.\n- \\[3\\]: product is 3, which is the product of distinct prime 3.\n- \\[15\\]: product is 15, which is the product of distinct primes 3 and 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 30`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,2,3,4]",
                "output": "6"
            },
            {
                "input": "[4,2,3,15]",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nint minSwaps(String s) {\n    int zeros = 0, ones = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n    }\n\n    if (Math.abs(zeros - ones) > 1) {\n        return -1;\n    }\n\n    int mismatchCount1 = 0, mismatchCount2 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) {\n            if (s.charAt(i) != '0') mismatchCount1++;\n            if (s.charAt(i) != '1') mismatchCount2++;\n        } else {\n            if (s.charAt(i) != '1') mismatchCount1++;\n            if (s.charAt(i) != '0') mismatchCount2++;\n        }\n    }\n\n    return Math.min(mismatchCount1, mismatchCount2) / 2;\n}\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    ",
        "python": "\n    ```python\ndef min_swaps(s: str) -> int:\n    zeros, ones = 0, 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n    if abs(zeros - ones) > 1:\n        return -1\n\n    mismatch_count1, mismatch_count2 = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c != '0': mismatch_count1 += 1\n            if c != '1': mismatch_count2 += 1\n        else:\n            if c != '1': mismatch_count1 += 1\n            if c != '0': mismatch_count2 += 1\n\n    return min(mismatch_count1, mismatch_count2) // 2\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    ",
        "c++": "\n    ```cpp\nint min_swaps(std::string s) {\n    int zeros = 0, ones = 0;\n    for (char c : s) {\n        if (c == '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n    }\n\n    if (abs(zeros - ones) > 1) {\n        return -1;\n    }\n\n    int mismatch_count1 = 0, mismatch_count2 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) {\n            if (s[i] != '0') mismatch_count1++;\n            if (s[i] != '1') mismatch_count2++;\n        } else {\n            if (s[i] != '1') mismatch_count1++;\n            if (s[i] != '0') mismatch_count2++;\n        }\n    }\n\n    return min(mismatch_count1, mismatch_count2) / 2;\n}\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    ",
        "js": "\n    ```javascript\nfunction minSwaps(s) {\n    let zeros = 0, ones = 0;\n    for (const c of s) {\n        if (c === '0') {\n            zeros++;\n        } else {\n            ones++;\n        }\n    }\n    \n    if (Math.abs(zeros - ones) > 1) {\n        return -1;\n    }\n\n    let mismatchCount1 = 0, mismatchCount2 = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 0) {\n            if (s[i] !== '0') mismatchCount1++;\n            if (s[i] !== '1') mismatchCount2++;\n        } else {\n            if (s[i] !== '1') mismatchCount1++;\n            if (s[i] !== '0') mismatchCount2++;\n}\n    }\n\n    return Math.min(mismatchCount1, mismatchCount2) / 2;\n}\n```\n\n    \n    1. Count the number of zeros and ones.\n2. If the absolute difference between zeros and ones is greater than 1, it's impossible to create an alternating string, return -1.\n3. Initialize two mismatch counts to count the number of mismatches assuming either that the first character is '0' or '1'.\n4. Loop through the string and increment the mismatch counts accordingly.\n5. The minimum number of swaps is the minimum of the mismatch counts divided by 2 because each swap corrects two mismatched characters.\n    "
    },
    {
        "id": 333,
        "title": "GCD Sort of an Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums`, and you can perform the following operation **any** number of times on `nums`:\n\n*   Swap the positions of two elements `nums[i]` and `nums[j]` if `gcd(nums[i], nums[j]) > 1` where `gcd(nums[i], nums[j])` is the **greatest common divisor** of `nums[i]` and `nums[j]`.\n\nReturn `true` _if it is possible to sort_ `nums` _in **non-decreasing** order using the above swap method, or_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,21,3\\]\n**Output:** true\n**Explanation:** We can sort \\[7,21,3\\] by performing the following operations:\n- Swap 7 and 21 because gcd(7,21) = 7. nums = \\[**21**,**7**,3\\]\n- Swap 21 and 3 because gcd(21,3) = 3. nums = \\[**3**,7,**21**\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,2,6,2\\]\n**Output:** false\n**Explanation:** It is impossible to sort the array because 5 cannot be swapped with any other element.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[10,5,9,3,15\\]\n**Output:** true\nWe can sort \\[10,5,9,3,15\\] by performing the following operations:\n- Swap 10 and 15 because gcd(10,15) = 5. nums = \\[**15**,5,9,3,**10**\\]\n- Swap 15 and 3 because gcd(15,3) = 3. nums = \\[**3**,5,9,**15**,10\\]\n- Swap 10 and 15 because gcd(10,15) = 5. nums = \\[3,5,9,**10**,**15**\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `2 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Union Find",
            "Sorting",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[7,21,3]",
                "output": "true"
            },
            {
                "input": "[5,2,6,2]",
                "output": "false"
            },
            {
                "input": "[10,5,9,3,15]",
                "output": "true\nWecansort[10,5,9,3,15]byperformingthefollowingoperations:\n-Swap10and15becausegcd(10,15)=5.nums=[**15**,5,9,3,**10**]\n-Swap15and3becausegcd(15,3)=3.nums=[**3**,5,9,**15**,10]\n-Swap10and15becausegcd(10,15)=5.nums=[3,5,9,**10**,**15**]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic boolean canBeSorted(int[] nums) {\n    int[] sorted_nums = Arrays.copyOf(nums, nums.length);\n    Arrays.sort(sorted_nums);\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != sorted_nums[i] && gcd(nums[i], sorted_nums[i]) == 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate int gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```\n    \n    The first step is to create a sorted copy of the input array `nums`. Then, iterate through the input array and check if each element matches the corresponding element in the sorted copy. If an element in both arrays is different, calculate the gcd of these elements. If the gcd is 1, return false because the two elements cannot be swapped. Otherwise, move on to the next element. If the loop finishes without finding a pair of numbers with a gcd of 1, return true.\n    ",
        "python": "\n    ```python\nfrom math import gcd\n\ndef can_be_sorted(nums):\n    sorted_nums = sorted(nums)\n    for i in range(len(nums)):\n        if nums[i] != sorted_nums[i] and gcd(nums[i], sorted_nums[i]) == 1:\n            return False\n    return True\n```\n    \n    The first step is to create a sorted copy of the input array `nums`. Then, iterate through the input array and check if each element matches the corresponding element in the sorted copy. If an element in both arrays is different, calculate the gcd of these elements. If the gcd is 1, return false because the two elements cannot be swapped. Otherwise, move on to the next element. If the loop finishes without finding a pair of numbers with a gcd of 1, return true.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\nbool canBeSorted(std::vector<int>& nums) {\n    std::vector<int> sorted_nums = nums;\n    sort(sorted_nums.begin(), sorted_nums.end());\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (nums[i] != sorted_nums[i] && std::gcd(nums[i], sorted_nums[i]) == 1) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The first step is to create a sorted copy of the input array `nums`. Then, iterate through the input array and check if each element matches the corresponding element in the sorted copy. If an element in both arrays is different, calculate the gcd of these elements. If the gcd is 1, return false because the two elements cannot be swapped. Otherwise, move on to the next element. If the loop finishes without finding a pair of numbers with a gcd of 1, return true.\n    ",
        "js": "\n    ```javascript\nfunction canBeSorted(nums) {\n    const sorted_nums = nums.slice().sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== sorted_nums[i] && gcd(nums[i], sorted_nums[i]) === 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction gcd(a, b) {\n    let temp;\n    while (b !== 0) {\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```\n    \n    The first step is to create a sorted copy of the input array `nums`. Then, iterate through the input array and check if each element matches the corresponding element in the sorted copy. If an element in both arrays is different, calculate the gcd of these elements. If the gcd is 1, return false because the two elements cannot be swapped. Otherwise, move on to the next element. If the loop finishes without finding a pair of numbers with a gcd of 1, return true.\n    "
    },
    {
        "id": 334,
        "title": "Smallest Missing Genetic Value in Each Subtree",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a **family tree** rooted at `0` consisting of `n` nodes numbered `0` to `n - 1`. You are given a **0-indexed** integer array `parents`, where `parents[i]` is the parent for node `i`. Since node `0` is the **root**, `parents[0] == -1`.\n\nThere are `105` genetic values, each represented by an integer in the **inclusive** range `[1, 105]`. You are given a **0-indexed** integer array `nums`, where `nums[i]` is a **distinct** genetic value for node `i`.\n\nReturn _an array_ `ans` _of length_ `n` _where_ `ans[i]` _is_ _the **smallest** genetic value that is **missing** from the subtree rooted at node_ `i`.\n\nThe **subtree** rooted at a node `x` contains node `x` and all of its **descendant** nodes.",
            "examples": [
                "**Example 1:**\n\n**Input:** parents = \\[-1,0,0,2\\], nums = \\[1,2,3,4\\]\n**Output:** \\[5,1,1,1\\]\n**Explanation:** The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes \\[0,1,2,3\\] with values \\[1,2,3,4\\]. 5 is the smallest missing value.\n- 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.\n- 2: The subtree contains nodes \\[2,3\\] with values \\[3,4\\]. 1 is the smallest missing value.\n- 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.\n\n",
                "**Example 2:**\n\n**Input:** parents = \\[-1,0,1,0,3,3\\], nums = \\[5,4,6,2,1,3\\]\n**Output:** \\[7,1,1,4,2,1\\]\n**Explanation:** The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes \\[0,1,2,3,4,5\\] with values \\[5,4,6,2,1,3\\]. 7 is the smallest missing value.\n- 1: The subtree contains nodes \\[1,2\\] with values \\[4,6\\]. 1 is the smallest missing value.\n- 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.\n- 3: The subtree contains nodes \\[3,4,5\\] with values \\[2,1,3\\]. 4 is the smallest missing value.\n- 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.\n- 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.\n\n",
                "**Example 3:**\n\n**Input:** parents = \\[-1,2,3,0,2,4,1\\], nums = \\[2,3,4,5,6,7,8\\]\n**Output:** \\[1,1,1,1,1,1,1\\]\n**Explanation:** The value 1 is missing from all the subtrees."
            ],
            "constraints": "**Constraints:**\n\n*   `n == parents.length == nums.length`\n*   `2 <= n <= 105`\n*   `0 <= parents[i] <= n - 1` for `i != 0`\n*   `parents[0] == -1`\n*   `parents` represents a valid tree.\n*   `1 <= nums[i] <= 105`\n*   Each `nums[i]` is distinct.",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Union Find"
        ],
        "example": [
            {
                "input": "[-1,0,0,2],[1,2,3,4]",
                "output": "[5,1,1,1]"
            },
            {
                "input": "[-1,0,1,0,3,3],[5,4,6,2,1,3]",
                "output": "[7,1,1,4,2,1]"
            },
            {
                "input": "[-1,2,3,0,2,4,1],[2,3,4,5,6,7,8]",
                "output": "[1,1,1,1,1,1,1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {\n        int n = parents.length;\n        List<Set<Integer>> children = new ArrayList<>();\n        for (int i = 0; i < n; ++i) {\n            children.add(new HashSet<>());\n        }\n        for (int i = 1; i < n; ++i) {\n            children.get(parents[i]).add(nums[i]);\n        }\n\n        int[] ans = new int[n];\n        dfs(0, parents, nums, children, ans);\n        return ans;\n    }\n\n    private void dfs(int node, int[] parents, int[] nums, List<Set<Integer>> children, int[] ans) {\n        for (int child : children.get(node)) {\n            dfs(child, parents, nums, children, ans);\n            children.get(node).remove(child);\n            children.get(node).add(ans[child]);\n        }\n        Iterator<Integer> it = children.get(node).lower_bound(nums[node]);\n        ans[node] = (it == children.get(node).end()) ? nums[node] + 1 : *it - 1;\n    }\n}\n```\n    \n    The algorithm performs a Depth First Search (DFS) on the family tree, using recursion. The DFS function takes in the following parameters: 'node', which is the subtree root, 'parents', 'nums', 'children', and 'ans'. \n\nWe first create a set of children nodes for each node in the tree. We start at the root node and iterate through its children nodes. For each child node, we call the DFS function recursively. Here, we remove the child node from the set of children nodes and insert the value of ans[child] as a new child node.\n\nThen, we find the smallest higher value in the children set that is larger than the subtree root value (nums[node]). We calculate the smallest missing value by subtracting 1 from that found value or adding 1 to the root value if the found value equals to the root value plus one.\n\nAfter the DFS is completed, we return the ans array. The ans array contains the smallest missing value for each subtree rooted at node i.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef smallestMissingValueSubtree(parents, nums):\n    n = len(parents)\n    children = defaultdict(set)\n    for i in range(1, n):\n        children[parents[i]].add(nums[i])\n\n    ans = [0] * n\n    dfs(0, parents, nums, children, ans)\n    return ans\n\ndef dfs(node, parents, nums, children, ans):\n    for child in list(children[node]):\n        dfs(child, parents, nums, children, ans)\n        children[node].remove(child)\n        children[node].add(ans[child])\n    it = next((x for x in children[node] if x > nums[node]), nums[node] + 1)\n    ans[node] = it - 1 if it != nums[node] + 1 else it\n```\n    \n    The algorithm performs a Depth First Search (DFS) on the family tree, using recursion. The DFS function takes in the following parameters: 'node', which is the subtree root, 'parents', 'nums', 'children', and 'ans'. \n\nWe first create a set of children nodes for each node in the tree. We start at the root node and iterate through its children nodes. For each child node, we call the DFS function recursively. Here, we remove the child node from the set of children nodes and insert the value of ans[child] as a new child node.\n\nThen, we find the smallest higher value in the children set that is larger than the subtree root value (nums[node]). We calculate the smallest missing value by subtracting 1 from that found value or adding 1 to the root value if the found value equals to the root value plus one.\n\nAfter the DFS is completed, we return the ans array. The ans array contains the smallest missing value for each subtree rooted at node i.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nvoid dfs(int node, const vector<int>& parents, const vector<int>& nums,\n         vector<set<int>>& children, vector<int>& ans) {\n    for (int child : children[node]) {\n        dfs(child, parents, nums, children, ans);\n        children[node].erase(child);\n        children[node].insert(ans[child]);\n    }\n    auto it = children[node].lower_bound(nums[node]);\n    ans[node] = (it == children[node].end()) ? nums[node] + 1 : *it - 1;\n}\n\nvector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {\n    int n = parents.size();\n    vector<set<int>> children(n);\n    for (int i = 1; i < n; ++i) {\n        children[parents[i]].insert(nums[i]);\n    }\n\n    vector<int> ans(n);\n    dfs(0, parents, nums, children, ans);\n    return ans;\n}\n```\n    \n    The algorithm performs a Depth First Search (DFS) on the family tree, using recursion. The DFS function takes in the following parameters: 'node', which is the subtree root, 'parents', 'nums', 'children', and 'ans'. \n\nWe first create a set of children nodes for each node in the tree. We start at the root node and iterate through its children nodes. For each child node, we call the DFS function recursively. Here, we remove the child node from the set of children nodes and insert the value of ans[child] as a new child node.\n\nThen, we find the smallest higher value in the children set that is larger than the subtree root value (nums[node]). We calculate the smallest missing value by subtracting 1 from that found value or adding 1 to the root value if the found value equals to the root value plus one.\n\nAfter the DFS is completed, we return the ans array. The ans array contains the smallest missing value for each subtree rooted at node i.\n    ",
        "js": "\n    ```javascript\nfunction smallestMissingValueSubtree(parents, nums) {\n    const n = parents.length;\n    const children = [];\n    for (let i = 0; i < n; ++i) {\n        children.push(new Set());\n    }\n    for (let i = 1; i < n; ++i) {\n        children[parents[i]].add(nums[i]);\n    }\n\n    const ans = new Array(n);\n    dfs(0, parents, nums, children, ans);\n    return ans;\n}\n\nfunction dfs(node, parents, nums, children, ans) {\n    for (const child of children[node].values()) {\n        dfs(child, parents, nums, children, ans);\n        children[node].delete(child);\n        children[node].add(ans[child]);\n    }\n    const it = firstLargerOrMissing(children[node], nums[node]);\n    ans[node] = (it === nums[node] + 1) ? it - 1 : it;\n}\n\nfunction firstLargerOrMissing(set, target) {\n    for (const el of set.values()) {\n        if (el > target) return el;\n    }\n    return target + 1;\n}\n```\n    \n    The algorithm performs a Depth First Search (DFS) on the family tree, using recursion. The DFS function takes in the following parameters: 'node', which is the subtree root, 'parents', 'nums', 'children', and 'ans'. \n\nWe first create a set of children nodes for each node in the tree. We start at the root node and iterate through its children nodes. For each child node, we call the DFS function recursively. Here, we remove the child node from the set of children nodes and insert the value of ans[child] as a new child node.\n\nThen, we find the smallest higher value in the children set that is larger than the subtree root value (nums[node]). We calculate the smallest missing value by subtracting 1 from that found value or adding 1 to the root value if the found value equals to the root value plus one.\n\nAfter the DFS is completed, we return the ans array. The ans array contains the smallest missing value for each subtree rooted at node i.\n    "
    },
    {
        "id": 335,
        "title": "Minimum Number of Operations to Make Array Continuous",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums`. In one operation, you can replace **any** element in `nums` with **any** integer.\n\n`nums` is considered **continuous** if both of the following conditions are fulfilled:\n\n*   All elements in `nums` are **unique**.\n*   The difference between the **maximum** element and the **minimum** element in `nums` equals `nums.length - 1`.\n\nFor example, `nums = [4, 2, 5, 3]` is **continuous**, but `nums = [1, 2, 3, 5, 6]` is **not continuous**.\n\nReturn _the **minimum** number of operations to make_ `nums` **_continuous_**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,5,3\\]\n**Output:** 0\n**Explanation:** nums is already continuous.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,5,6\\]\n**Output:** 1\n**Explanation:** One possible solution is to change the last element to 4.\nThe resulting array is \\[1,2,3,5,4\\], which is continuous.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,10,100,1000\\]\n**Output:** 3\n**Explanation:** One possible solution is to:\n- Change the second element to 2.\n- Change the third element to 3.\n- Change the fourth element to 4.\nThe resulting array is \\[1,2,3,4\\], which is continuous."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sliding Window"
        ],
        "example": [
            {
                "input": "[4,2,5,3]",
                "output": "0"
            },
            {
                "input": "[1,2,3,5,6]",
                "output": "1"
            },
            {
                "input": "[1,10,100,1000]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int n = nums.length;\n    Set<Integer> set = new HashSet<>();\n    for (int num : nums) {\n        set.add(num);\n    }\n    List<Integer> list = new ArrayList<>(set);\n    Collections.sort(list);\n    int res = Integer.MAX_VALUE;\n    int j = 0;\n\n    for (int i = 0; i < list.size(); ++i) {\n        while (j < list.size() && list.get(j) <= list.get(i) + n - 1) {\n            ++j;\n        }\n        res = Math.min(res, n - (j - i));\n    }\n    return res;\n}\n```\n    \n    The algorithm first finds and sorts the unique elements in the input array. Then, it performs a two-pointer iteration through the unique elements. The first pointer, `i`, iterates from the beginning to the end of the unique elements array. The second pointer, `j`, starts at the beginning and moves forward while the difference between the currently pointed elements and `n - 1` is not exceeded. The difference between the two pointers gives us the number of elements that are already continuous in the input array. The result is the minimum number of operations required to make the input array continuous. The algorithm updates the result as the min value between the previous result and `n - (j - i)` during the iterations.\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    n = len(nums)\n    s = sorted(set(nums))\n    res = float('inf')\n    j = 0\n    \n    for i in range(len(s)):\n        while j < len(s) and s[j] <= s[i] + n - 1:\n            j += 1\n        res = min(res, n - (j - i))\n        \n    return res\n```\n    \n    The algorithm first finds and sorts the unique elements in the input array. Then, it performs a two-pointer iteration through the unique elements. The first pointer, `i`, iterates from the beginning to the end of the unique elements array. The second pointer, `j`, starts at the beginning and moves forward while the difference between the currently pointed elements and `n - 1` is not exceeded. The difference between the two pointers gives us the number of elements that are already continuous in the input array. The result is the minimum number of operations required to make the input array continuous. The algorithm updates the result as the min value between the previous result and `n - (j - i)` during the iterations.\n    ",
        "c++": "\n    ```cpp\nint min_operations(vector<int>& nums) {\n    int n = nums.size();\n    set<int> s(nums.begin(), nums.end());\n    vector<int> v(s.begin(), s.end());\n    int res = INT_MAX;\n    int j = 0;\n\n    for (int i = 0; i < v.size(); ++i) {\n        while (j < v.size() && v[j] <= v[i] + n - 1) {\n            ++j;\n        }\n        res = min(res, n - (j - i));\n    }\n    return res;\n}\n```\n    \n    The algorithm first finds and sorts the unique elements in the input array. Then, it performs a two-pointer iteration through the unique elements. The first pointer, `i`, iterates from the beginning to the end of the unique elements array. The second pointer, `j`, starts at the beginning and moves forward while the difference between the currently pointed elements and `n - 1` is not exceeded. The difference between the two pointers gives us the number of elements that are already continuous in the input array. The result is the minimum number of operations required to make the input array continuous. The algorithm updates the result as the min value between the previous result and `n - (j - i)` during the iterations.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    const n = nums.length;\n    const s = [...new Set(nums)].sort((a, b) => a - b);\n    let res = Infinity;\n    let j = 0;\n\n    for (let i = 0; i < s.length; ++i) {\n        while (j < s.length && s[j] <= s[i] + n - 1) {\n            ++j;\n        }\n        res = Math.min(res, n - (j - i));\n    }\n    return res;\n}\n```\n    \n    The algorithm first finds and sorts the unique elements in the input array. Then, it performs a two-pointer iteration through the unique elements. The first pointer, `i`, iterates from the beginning to the end of the unique elements array. The second pointer, `j`, starts at the beginning and moves forward while the difference between the currently pointed elements and `n - 1` is not exceeded. The difference between the two pointers gives us the number of elements that are already continuous in the input array. The result is the minimum number of operations required to make the input array continuous. The algorithm updates the result as the min value between the previous result and `n - (j - i)` during the iterations.\n    "
    },
    {
        "id": 336,
        "title": "Longest Subsequence Repeated k Times",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` of length `n`, and an integer `k`. You are tasked to find the **longest subsequence repeated** `k` times in string `s`.\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\nA subsequence `seq` is **repeated** `k` times in the string `s` if `seq * k` is a subsequence of `s`, where `seq * k` represents a string constructed by concatenating `seq` `k` times.\n\n*   For example, `\"bba \"` is repeated `2` times in the string `\"bababcba \"`, because the string `\"bbabba \"`, constructed by concatenating `\"bba \"` `2` times, is a subsequence of the string `\"**b**a**bab**c**ba** \"`.\n\nReturn _the **longest subsequence repeated**_ `k` _times in string_ `s`_. If multiple such subsequences are found, return the **lexicographically largest** one. If there is no such subsequence, return an **empty** string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"letsleetcode \", k = 2\n**Output:**  \"let \"\n**Explanation:** There are two longest subsequences repeated 2 times:  \"let \" and  \"ete \".\n \"let \" is the lexicographically largest one.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"bb \", k = 2\n**Output:**  \"b \"\n**Explanation:** The longest subsequence repeated 2 times is  \"b \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"ab \", k = 2\n**Output:**  \" \"\n**Explanation:** There is no subsequence repeated 2 times. Empty string is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `n == s.length`\n*   `2 <= n, k <= 2000`\n*   `2 <= n < k * 8`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Backtracking",
            "Greedy",
            "Counting",
            "Enumeration"
        ],
        "example": [
            {
                "input": "\"letsleetcode\",2",
                "output": "\"let\""
            },
            {
                "input": "\"bb\",2",
                "output": "\"b\""
            },
            {
                "input": "\"ab\",2",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic String longestSubsequenceRepeatedK(String s, int k) {\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) count[s.charAt(i) - 'a']++;\n    StringBuilder seq = new StringBuilder();\n    for (int i = 0; i < 26; i++) {\n        if (count[i] >= k) seq.append(String.valueOf((char) ('a' + i)).repeat(count[i] / k));\n    }\n    int[][] dp = new int[seq.length() + 1][seq.length() + 1];\n    for (int[] row : dp) Arrays.fill(row, 0);\n    for (int i = seq.length() - 1; i >= 0; i--) {\n        for (int j = i + 1; j < seq.length(); j++) {\n            if (seq.charAt(i) == seq.charAt(j)) dp[i][j] = dp[i + 1][j + 1] + 1;\n            else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);\n        }\n    }\n    StringBuilder res = new StringBuilder();\n    int i = 0, j = 0;\n    while (j < seq.length() && res.length() < seq.length() / k) {\n        if (res.length() == 0 || seq.charAt(j) > res.charAt(res.length() - 1)) {\n            if (dp[i][j] >= (seq.length() / k - res.length()) * 2) {\n                res.append(seq.charAt(j));\n                i = j + 1;\n            }\n        }\n        j++;\n    }\n    return res.toString();\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Count the occurrences of each character in the string `s`. Compute the string `seq` containing characters repeated at least `k` times in `s`.\n2. Run a dynamic programming algorithm to find the length of the longest common subsequence in `seq` for each pair of indices `(i, j)`.\n3. Initialize pointers `i` and `j` to 0. Traverse the `seq` string starting the `j` pointer to find a character repeated at least `k` times.\n4. If the character at index `j` in `seq` is greater than the character at the end of the current result string and the length of the common subsequence from `(i, j)` is greater than or equal to the remaining characters needed to find the `k` times repetition, add the character at index `j` to the current result string and update the pointer `i` to the next character.\n5. Continue traversing `seq` and updating the result string until traversing the entire sequence or the required length of k times repetition is achieved.\n6. Return the final result string.\n    ",
        "python": "\n    ```python\ndef longestSubsequenceRepeatedK(s, k):\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    seq = \"\".join(chr(i + ord('a')) * (count[i] // k) for i in range(26) if count[i] >= k)\n\n    def dp(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if i >= len(seq) or j >= len(seq):\n            return 0\n        if seq[i] == seq[j]:\n            res = 1 + dp(i + 1, j + 1)\n        else:\n            res = max(dp(i + 1, j), dp(i, j + 1))\n        memo[(i, j)] = res\n        return res\n\n    memo = {}\n    res = []\n    i, j = 0, 0\n    while j < len(seq) and len(res) < len(seq) // k:\n        if not res or seq[j] > res[-1]:\n            if dp(i, j) >= (len(seq) // k - len(res)) * 2:\n                res.append(seq[j])\n                i = j + 1\n        j += 1\n\n    return \"\".join(res)\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Count the occurrences of each character in the string `s`. Compute the string `seq` containing characters repeated at least `k` times in `s`.\n2. Run a dynamic programming algorithm to find the length of the longest common subsequence in `seq` for each pair of indices `(i, j)`.\n3. Initialize pointers `i` and `j` to 0. Traverse the `seq` string starting the `j` pointer to find a character repeated at least `k` times.\n4. If the character at index `j` in `seq` is greater than the character at the end of the current result string and the length of the common subsequence from `(i, j)` is greater than or equal to the remaining characters needed to find the `k` times repetition, add the character at index `j` to the current result string and update the pointer `i` to the next character.\n5. Continue traversing `seq` and updating the result string until traversing the entire sequence or the required length of k times repetition is achieved.\n6. Return the final result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string longestSubsequenceRepeatedK(const std::string& s, int k) {\n    std::vector<int> count(26, 0);\n    for (auto c : s) { count[c - 'a']++; }\n    std::string seq;\n    for (char c = 'a'; c <= 'z'; c++) {\n        if (count[c - 'a'] >= k) seq += std::string(count[c - 'a'] / k, c);\n    }\n\n    int n = seq.length();\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j < n; j++) {\n            if (seq[i] == seq[j]) {\n                dp[i][j] = 1 + dp[i + 1][j + 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j + 1]);\n            }\n        }\n    }\n\n    std::string res;\n    int i = 0, j = 0;\n    while (j < n && res.length() < n / k) {\n        if (res.empty() || seq[j] > res.back()) {\n            if (dp[i][j] >= (n / k - res.length()) * 2) {\n                res.push_back(seq[j]);\n                i = j + 1;\n            }\n        }\n        j++;\n    }\n\n    return res;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Count the occurrences of each character in the string `s`. Compute the string `seq` containing characters repeated at least `k` times in `s`.\n2. Run a dynamic programming algorithm to find the length of the longest common subsequence in `seq` for each pair of indices `(i, j)`.\n3. Initialize pointers `i` and `j` to 0. Traverse the `seq` string starting the `j` pointer to find a character repeated at least `k` times.\n4. If the character at index `j` in `seq` is greater than the character at the end of the current result string and the length of the common subsequence from `(i, j)` is greater than or equal to the remaining characters needed to find the `k` times repetition, add the character at index `j` to the current result string and update the pointer `i` to the next character.\n5. Continue traversing `seq` and updating the result string until traversing the entire sequence or the required length of k times repetition is achieved.\n6. Return the final result string.\n    ",
        "js": "\n    ```javascript\nfunction longestSubsequenceRepeatedK(s, k) {\n    let count = new Array(26).fill(0);\n    for (let i = 0; i < s.length; i++) count[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n    let seq = Array.from({length: 26}, (_, i) => {\n        return (count[i] >= k) ? String.fromCharCode(i + 'a'.charCodeAt(0)).repeat(count[i] / k) : '';\n    }).join('');\n\n    function dp(i, j, memo = new Map()) {\n        if (memo.has(`${i},${j}`)) return memo.get(`${i},${j}`);\n        if (i >= seq.length || j >= seq.length) return 0;\n        let res = (seq[i] === seq[j]) ? 1 + dp(i + 1, j + 1, memo) : Math.max(dp(i + 1, j, memo), dp(i, j + 1, memo));\n        memo.set(`${i},${j}`, res);\n        return res;\n    }\n\n    let res = [];\n    let i = 0, j = 0;\n    while (j < seq.length && res.length < seq.length / k) {\n        if (res.length === 0 || seq[j] > res[res.length - 1]) {\n            if (dp(i, j) >= (seq.length / k - res.length) * 2) {\n                res.push(seq[j]);\n                i = j + 1;\n            }\n        }\n        j++;\n    }\n\n    return res.join('');\n}\n```\n\n    \n    The algorithm consists of the following steps:\n\n1. Count the occurrences of each character in the string `s`. Compute the string `seq` containing characters repeated at least `k` times in `s`.\n2. Run a dynamic programming algorithm to find the length of the longest common subsequence in `seq` for each pair of indices `(i, j)`.\n3. Initialize pointers `i` and `j` to 0. Traverse the `seq` string starting the `j` pointer to find a character repeated at least `k` times.\n4. If the character at index `j` in `seq` is greater than the character at the end of the current result string and the length of the common subsequence from `(i, j)` is greater than or equal to the remaining characters needed to find the `k` times repetition, add the character at index `j` to the current result string and update the pointer `i` to the next character.\n5. Continue traversing `seq` and updating the result string until traversing the entire sequence or the required length of k times repetition is achieved.\n6. Return the final result string.\n    "
    },
    {
        "id": 337,
        "title": "The Score of Students Solving Math Expression",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` that contains digits `0-9`, addition symbols `'+'`, and multiplication symbols `'*'` **only**, representing a **valid** math expression of **single digit numbers** (e.g., `3+5*2`). This expression was given to `n` elementary school students. The students were instructed to get the answer of the expression by following this **order of operations**:\n\n1.  Compute **multiplication**, reading from **left to right**; Then,\n2.  Compute **addition**, reading from **left to right**.\n\nYou are given an integer array `answers` of length `n`, which are the submitted answers of the students in no particular order. You are asked to grade the `answers`, by following these **rules**:\n\n*   If an answer **equals** the correct answer of the expression, this student will be rewarded `5` points;\n*   Otherwise, if the answer **could be interpreted** as if the student applied the operators **in the wrong order** but had **correct arithmetic**, this student will be rewarded `2` points;\n*   Otherwise, this student will be rewarded `0` points.\n\nReturn _the sum of the points of the students_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"7+3\\*1\\*2 \", answers = \\[20,13,42\\]\n**Output:** 7\n**Explanation:** As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: \\[20,**13**,42\\]\nA student might have applied the operators in this wrong order: ((7+3)\\*1)\\*2 = 20. Therefore one student is rewarded 2 points: \\[**20**,13,42\\]\nThe points for the students are: \\[2,5,0\\]. The sum of the points is 2+5+0=7.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"3+5\\*2 \", answers = \\[13,0,10,13,13,16,16\\]\n**Output:** 19\n**Explanation:** The correct answer of the expression is 13, therefore three students are rewarded 5 points each: \\[**13**,0,10,**13**,**13**,16,16\\]\nA student might have applied the operators in this wrong order: ((3+5)\\*2 = 16. Therefore two students are rewarded 2 points: \\[13,0,10,13,13,**16**,**16**\\]\nThe points for the students are: \\[5,0,0,5,5,2,2\\]. The sum of the points is 5+0+0+5+5+2+2=19.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"6+0\\*1 \", answers = \\[12,9,6,4,8,6\\]\n**Output:** 10\n**Explanation:** The correct answer of the expression is 6.\nIf a student had incorrectly done (6+0)\\*1, the answer would also be 6.\nBy the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\nThe points for the students are: \\[0,0,5,0,0,5\\]. The sum of the points is 10."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= s.length <= 31`\n*   `s` represents a valid expression that contains only digits `0-9`, `'+'`, and `'*'` only.\n*   All the integer operands in the expression are in the **inclusive** range `[0, 9]`.\n*   `1 <=` The count of all operators (`'+'` and `'*'`) in the math expression `<= 15`\n*   Test data are generated such that the correct answer of the expression is in the range of `[0, 1000]`.\n*   `n == answers.length`\n*   `1 <= n <= 104`\n*   `0 <= answers[i] <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "String",
            "Dynamic Programming",
            "Stack",
            "Memoization"
        ],
        "example": [
            {
                "input": "\"7+3*1*2\",[20,13,42]",
                "output": "7"
            },
            {
                "input": "\"3+5*2\",[13,0,10,13,13,16,16]",
                "output": "19"
            },
            {
                "input": "\"6+0*1\",[12,9,6,4,8,6]",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int sumOfPoints(String s, int[] answers) {\n    int correct = 0, wrongOrder = 0;\n    int mul = 1, add = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (Character.isDigit(s.charAt(i))) {\n            int num = s.charAt(i) - '0';\n            mul *= num;\n            if (i == s.length() - 1 || s.charAt(i + 1) == '+') {\n                add += mul;\n                mul = 1;\n            }\n        }\n    }\n\n    wrongOrder = (s.charAt(0) - '0');\n    for (int i = 2; i < s.length(); i += 2) {\n        if (s.charAt(i - 1) == '+') wrongOrder += (s.charAt(i) - '0');\n        else wrongOrder *= (s.charAt(i) - '0');\n    }\n\n    int sum = 0;\n    for (int ans : answers) {\n        sum += (ans == correct ? 5 : 0) + (ans == wrongOrder ? 2 : 0);\n    }\n    return sum;\n}\n```\n    \n    The algorithm first calculates the `correct` answer and the `wrongOrder` answer based on the input string `s`. To do this, iterate through the input string, and whenever a digit is found, multiply it with the ongoing multiplication (initially 1). If either the end of the string is reached or the next character is a '+', add the ongoing multiplication to the current addition and reset the multiplication to 1. This process will calculate the correct answer. Then, it calculates the wrongOrder by iterating through the string every 2 characters and applying multiplication/addition based on the operators in between the two numbers.\n\nFinally, the algorithm iterates through the answers array and checks if each answer is equal to the `correct` answer or the `wrongOrder` answer. It adds 5 to the sum for each correct answer and 2 for each wrongOrder answer.\n\nThe time complexity is O(N + K) where N is the length of the input string `s` and K is the length of the `answers` array. The space complexity is O(1) as variables are stored for `correct`, `wrongOrder`, `mul`, `add`, and `sum`.\n    ",
        "python": "\n    ```python\ndef sumOfPoints(s: str, answers: List[int]) -> int:\n    correct = 0\n    mul = 1\n    add = 0\n    for i in range(len(s)):\n        if s[i].isdigit():\n            num = int(s[i])\n            mul *= num\n            if i == len(s) - 1 or s[i + 1] == '+':\n                add += mul\n                mul = 1\n    correct = add\n\n    wrongOrder = int(s[0])\n    for i in range(2, len(s), 2):\n        if s[i - 1] == '+':\n            wrongOrder += int(s[i])\n        else:\n            wrongOrder *= int(s[i])\n\n    return sum(5 * (ans == correct) + 2 * (ans == wrongOrder) for ans in answers)\n```\n    \n    The algorithm first calculates the `correct` answer and the `wrongOrder` answer based on the input string `s`. To do this, iterate through the input string, and whenever a digit is found, multiply it with the ongoing multiplication (initially 1). If either the end of the string is reached or the next character is a '+', add the ongoing multiplication to the current addition and reset the multiplication to 1. This process will calculate the correct answer. Then, it calculates the wrongOrder by iterating through the string every 2 characters and applying multiplication/addition based on the operators in between the two numbers.\n\nFinally, the algorithm iterates through the answers array and checks if each answer is equal to the `correct` answer or the `wrongOrder` answer. It adds 5 to the sum for each correct answer and 2 for each wrongOrder answer.\n\nThe time complexity is O(N + K) where N is the length of the input string `s` and K is the length of the `answers` array. The space complexity is O(1) as variables are stored for `correct`, `wrongOrder`, `mul`, `add`, and `sum`.\n    ",
        "c++": "\n    ```cpp\nint sumOfPoints(string s, vector<int>& answers) {\n    int correct = 0, wrongOrder = 0;\n    int mul = 1, add = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (isdigit(s[i])) {\n            int num = s[i] - '0';\n            mul *= num;\n            if (i == s.length() - 1 || s[i + 1] == '+') {\n                add += mul;\n                mul = 1;\n            }\n        }\n    }\n\n    wrongOrder = (s[0] - '0');\n    for (int i = 2; i < s.length(); i += 2) {\n        if (s[i - 1] == '+') wrongOrder += (s[i] - '0');\n        else wrongOrder *= (s[i] - '0');\n    }\n\n    int sum = 0;\n    for (int ans : answers) {\n        sum += (ans == correct) * 5 + (ans == wrongOrder) * 2;\n    }\n    return sum;\n}\n```\n    \n    The algorithm first calculates the `correct` answer and the `wrongOrder` answer based on the input string `s`. To do this, iterate through the input string, and whenever a digit is found, multiply it with the ongoing multiplication (initially 1). If either the end of the string is reached or the next character is a '+', add the ongoing multiplication to the current addition and reset the multiplication to 1. This process will calculate the correct answer. Then, it calculates the wrongOrder by iterating through the string every 2 characters and applying multiplication/addition based on the operators in between the two numbers.\n\nFinally, the algorithm iterates through the answers array and checks if each answer is equal to the `correct` answer or the `wrongOrder` answer. It adds 5 to the sum for each correct answer and 2 for each wrongOrder answer.\n\nThe time complexity is O(N + K) where N is the length of the input string `s` and K is the length of the `answers` array. The space complexity is O(1) as variables are stored for `correct`, `wrongOrder`, `mul`, `add`, and `sum`.\n    ",
        "js": "\n    ```javascript\nfunction sumOfPoints(s, answers) {\n    let correct = 0, wrongOrder = 0;\n    let mul = 1, add = 0;\n    for (let i = 0; i < s.length; ++i) {\n        if (s[i] >= '0' && s[i] <= '9') {\n            let num = parseInt(s[i]);\n            mul *= num;\n            if (i === s.length - 1 || s[i + 1] === '+') {\n                add += mul;\n                mul = 1;\n            }\n        }\n    }\n\n    wrongOrder = parseInt(s[0]);\n    for (let i = 2; i < s.length; i += 2) {\n        if (s[i - 1] === '+') wrongOrder += parseInt(s[i]);\n        else wrongOrder *= parseInt(s[i]);\n    }\n\n    let sum = 0;\n    answers.forEach(ans => {\n        sum += (ans === correct) * 5 + (ans === wrongOrder) * 2;\n    });\n    return sum;\n}\n```\n    \n    The algorithm first calculates the `correct` answer and the `wrongOrder` answer based on the input string `s`. To do this, iterate through the input string, and whenever a digit is found, multiply it with the ongoing multiplication (initially 1). If either the end of the string is reached or the next character is a '+', add the ongoing multiplication to the current addition and reset the multiplication to 1. This process will calculate the correct answer. Then, it calculates the wrongOrder by iterating through the string every 2 characters and applying multiplication/addition based on the operators in between the two numbers.\n\nFinally, the algorithm iterates through the answers array and checks if each answer is equal to the `correct` answer or the `wrongOrder` answer. It adds 5 to the sum for each correct answer and 2 for each wrongOrder answer.\n\nThe time complexity is O(N + K) where N is the length of the input string `s` and K is the length of the `answers` array. The space complexity is O(1) as variables are stored for `correct`, `wrongOrder`, `mul`, `add`, and `sum`.\n    "
    },
    {
        "id": 338,
        "title": "Maximum Number of Ways to Partition an Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` of length `n`. The number of ways to **partition** `nums` is the number of `pivot` indices that satisfy both conditions:\n\n*   `1 <= pivot < n`\n*   `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`\n\nYou are also given an integer `k`. You can choose to change the value of **one** element of `nums` to `k`, or to leave the array **unchanged**.\n\nReturn _the **maximum** possible number of ways to **partition**_ `nums` _to satisfy both conditions after changing **at most** one element_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,-1,2\\], k = 3\n**Output:** 1\n**Explanation:** One optimal approach is to change nums\\[0\\] to k. The array becomes \\[**3**,-1,2\\].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition \\[3,-1 | 2\\]: 3 + -1 == 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,0\\], k = 1\n**Output:** 2\n**Explanation:** The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition \\[0 | 0,0\\]: 0 == 0 + 0.\n- For pivot = 2, we have the partition \\[0,0 | 0\\]: 0 + 0 == 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14\\], k = -33\n**Output:** 4\n**Explanation:** One optimal approach is to change nums\\[2\\] to k. The array becomes \\[22,4,**\\-33**,-20,-15,15,-16,7,19,-10,0,-13,-14\\].\nThere are four ways to partition the array."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 105`\n*   `-105 <= k, nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Counting",
            "Enumeration",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,-1,2],3",
                "output": "1"
            },
            {
                "input": "[0,0,0],1",
                "output": "2"
            },
            {
                "input": "[22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14],-33",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic boolean makeEqual(String[] words) {\n    Set<Character> chars = new HashSet<>();\n    int totalChars = 0;\n    for (String word : words) {\n        totalChars += word.length();\n        for (char c : word.toCharArray()) {\n            chars.add(c);\n        }\n    }\n    return totalChars % chars.size() == 0;\n}\n```\n    \n    The algorithm is quite simple for this problem:\n\n1. Create a set 'chars' to store unique characters in words to keep track of different characters.\n2. Create a variable 'totalChars' to store the total number of characters in words, initialized to 0.\n3. Iterate through each word in words array.\n   - For each word, add its length to the totalChars variable.\n   - Then, iterate through each character in the word and add it to the 'chars' set.\n4. If the total number of characters in the 'words' can be divided evenly by the number of different characters in the set, return true, otherwise return false.\n    ",
        "python": "\n    ```python\ndef make_equal(words):\n    chars = set()\n    total_chars = 0\n    for word in words:\n        total_chars += len(word)\n        for c in word:\n            chars.add(c)\n    return total_chars % len(chars) == 0\n```\n    \n    The algorithm is quite simple for this problem:\n\n1. Create a set 'chars' to store unique characters in words to keep track of different characters.\n2. Create a variable 'totalChars' to store the total number of characters in words, initialized to 0.\n3. Iterate through each word in words array.\n   - For each word, add its length to the totalChars variable.\n   - Then, iterate through each character in the word and add it to the 'chars' set.\n4. If the total number of characters in the 'words' can be divided evenly by the number of different characters in the set, return true, otherwise return false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool makeEqual(std::vector<std::string>& words) {\n    std::unordered_set<char> chars;\n    int totalChars = 0;\n    for (const std::string& word : words) {\n        totalChars += word.size();\n        for (char c : word) {\n            chars.insert(c);\n        }\n    }\n    return totalChars % chars.size() == 0;\n}\n```\n    \n    The algorithm is quite simple for this problem:\n\n1. Create a set 'chars' to store unique characters in words to keep track of different characters.\n2. Create a variable 'totalChars' to store the total number of characters in words, initialized to 0.\n3. Iterate through each word in words array.\n   - For each word, add its length to the totalChars variable.\n   - Then, iterate through each character in the word and add it to the 'chars' set.\n4. If the total number of characters in the 'words' can be divided evenly by the number of different characters in the set, return true, otherwise return false.\n    ",
        "js": "\n    ```javascript\nfunction makeEqual(words) {\n    let chars = new Set();\n    let totalChars = 0;\n    for (let word of words) {\n        totalChars += word.length;\n        for (let c of word) {\n            chars.add(c);\n        }\n    }\n    return totalChars % chars.size === 0;\n}\n```\n    \n    The algorithm is quite simple for this problem:\n\n1. Create a set 'chars' to store unique characters in words to keep track of different characters.\n2. Create a variable 'totalChars' to store the total number of characters in words, initialized to 0.\n3. Iterate through each word in words array.\n   - For each word, add its length to the totalChars variable.\n   - Then, iterate through each character in the word and add it to the 'chars' set.\n4. If the total number of characters in the 'words' can be divided evenly by the number of different characters in the set, return true, otherwise return false.\n    "
    },
    {
        "id": 339,
        "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s`, an integer `k`, a letter `letter`, and an integer `repetition`.\n\nReturn _the **lexicographically smallest** subsequence of_ `s` _of length_ `k` _that has the letter_ `letter` _appear **at least**_ `repetition` _times_. The test cases are generated so that the `letter` appears in `s` **at least** `repetition` times.\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\nA string `a` is **lexicographically smaller** than a string `b` if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leet \", k = 3, letter =  \"e \", repetition = 1\n**Output:**  \"eet \"\n**Explanation:** There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:\n-  \"lee \" (from  \"**lee**t \")\n-  \"let \" (from  \"**le**e**t** \")\n-  \"let \" (from  \"**l**e**et** \")\n-  \"eet \" (from  \"l**eet** \")\nThe lexicographically smallest subsequence among them is  \"eet \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"leetcode \", k = 4, letter =  \"e \", repetition = 2\n**Output:**  \"ecde \"\n**Explanation:**  \"ecde \" is the lexicographically smallest subsequence of length 4 that has the letter  \"e \" appear at least 2 times.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"bb \", k = 2, letter =  \"b \", repetition = 2\n**Output:**  \"bb \"\n**Explanation:**  \"bb \" is the only subsequence of length 2 that has the letter  \"b \" appear at least 2 times."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= repetition <= k <= s.length <= 5 * 104`\n*   `s` consists of lowercase English letters.\n*   `letter` is a lowercase English letter, and appears in `s` at least `repetition` times.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Stack",
            "Greedy",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "\"leet\",3,\"e\",1",
                "output": "\"eet\""
            },
            {
                "input": "\"leetcode\",4,\"e\",2",
                "output": "\"ecde\""
            },
            {
                "input": "\"bb\",2,\"b\",2",
                "output": "\"bb\""
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic String smallestSubsequence(String s, int k, char letter, int repetition) {\n    int n = s.length();\n    int remaining = n - k;\n    int letterCount = 0;\n\n    ArrayDeque<Character> resQueue = new ArrayDeque<>();\n    for (char c : s.toCharArray()) {\n        while (!resQueue.isEmpty() && resQueue.peekLast() > c && remaining > 0) {\n            if (resQueue.peekLast() == letter) {\n                if (letterCount > repetition) {\n                    --letterCount;\n                    resQueue.pollLast();\n                    --remaining;\n                }\n            } else {\n                resQueue.pollLast();\n                --remaining;\n            }\n        }\n        if (resQueue.size() < k) {\n            if (c == letter) {\n                ++letterCount;\n            } else if (k - resQueue.size() > repetition - letterCount) {\n            } else {\n                continue;\n            }\n            resQueue.offerLast(c);\n        }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    while (!resQueue.isEmpty()) {\n        sb.append(resQueue.pollFirst());\n    }\n    return sb.toString();\n}\n```\n\n    \n    1. Initialize counters for the remaining number of characters to delete and for the count of the target letter.\n2. Iterate through each character in the string.\n3. For each character, check if the result stack is not empty, its top element is greater than the current character, and we have remaining characters to delete. If true, keep deleting characters from the result while respecting the repetition constraint for the letter.\n4. If the result is still not full, push the current character into the result stack according to the repetition constraint.\n5. In the end, convert the result stack into a string and return it.\n    ",
        "python": "\n    ```python\ndef smallestSubsequence(s, k, letter, repetition):\n    n = len(s)\n    remaining = n - k\n    letter_count = 0\n\n    res = []\n    for c in s:\n        while res and res[-1] > c and remaining > 0:\n            if res[-1] == letter:\n                if letter_count > repetition:\n                    letter_count -= 1\n                    res.pop()\n                    remaining -= 1\n            else:\n                res.pop()\n                remaining -= 1\n        if len(res) < k:\n            if c == letter:\n                letter_count += 1\n            elif k - len(res) > repetition - letter_count:\n            else:\n                continue\n            res.append(c)\n\n    return ''.join(res)\n```\n\n    \n    1. Initialize counters for the remaining number of characters to delete and for the count of the target letter.\n2. Iterate through each character in the string.\n3. For each character, check if the result stack is not empty, its top element is greater than the current character, and we have remaining characters to delete. If true, keep deleting characters from the result while respecting the repetition constraint for the letter.\n4. If the result is still not full, push the current character into the result stack according to the repetition constraint.\n5. In the end, convert the result stack into a string and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string smallestSubsequence(std::string s, int k, char letter, int repetition) {\n    int n = s.size();\n    int remaining = n - k;\n    int letterCount = 0;\n\n    std::vector<char> res;\n    for (char c : s) {\n        while (!res.empty() && res.back() > c && remaining > 0) {\n            if (res.back() == letter) {\n                if (letterCount > repetition) {\n                    --letterCount;\n                    res.pop_back();\n                    --remaining;\n                }\n            } else {\n                res.pop_back();\n                --remaining;\n            }\n        }\n        if (res.size() < k) {\n            if (c == letter) {\n                ++letterCount;\n            } else if (k - res.size() > repetition - letterCount) {\n            } else {\n                continue;\n            }\n            res.push_back(c);\n        }\n    }\n\n    return std::string(res.begin(), res.end());\n}\n```\n\n    \n    1. Initialize counters for the remaining number of characters to delete and for the count of the target letter.\n2. Iterate through each character in the string.\n3. For each character, check if the result stack is not empty, its top element is greater than the current character, and we have remaining characters to delete. If true, keep deleting characters from the result while respecting the repetition constraint for the letter.\n4. If the result is still not full, push the current character into the result stack according to the repetition constraint.\n5. In the end, convert the result stack into a string and return it.\n    ",
        "js": "\n    ```javascript\nfunction smallestSubsequence(s, k, letter, repetition) {\n    let n = s.length;\n    let remaining = n - k;\n    let letterCount = 0;\n\n    let res = [];\n    for (const c of s) {\n        while (res.length && res[res.length - 1] > c && remaining > 0) {\n            if (res[res.length - 1] === letter) {\n                if (letterCount > repetition) {\n                    --letterCount;\n                    res.pop();\n                    --remaining;\n                }\n            } else {\n                res.pop();\n                --remaining;\n            }\n        }\n        if (res.length < k) {\n            if (c === letter) {\n                ++letterCount;\n            } else if (k - res.length > repetition - letterCount) {\n            } else {\n                continue;\n            }\n            res.push(c);\n        }\n    }\n\n    return res.join('');\n}\n```\n\n    \n    1. Initialize counters for the remaining number of characters to delete and for the count of the target letter.\n2. Iterate through each character in the string.\n3. For each character, check if the result stack is not empty, its top element is greater than the current character, and we have remaining characters to delete. If true, keep deleting characters from the result while respecting the repetition constraint for the letter.\n4. If the result is still not full, push the current character into the result stack according to the repetition constraint.\n5. In the end, convert the result stack into a string and return it.\n    "
    },
    {
        "id": 340,
        "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` of `2 * n` integers. You need to partition `nums` into **two** arrays of length `n` to **minimize the absolute difference** of the **sums** of the arrays. To partition `nums`, put each element of `nums` into **one** of the two arrays.\n\nReturn _the **minimum** possible absolute difference_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,9,7,3\\]\n**Output:** 2\n**Explanation:** One optimal partition is: \\[3,9\\] and \\[7,3\\].\nThe absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-36,36\\]\n**Output:** 72\n**Explanation:** One optimal partition is: \\[-36\\] and \\[36\\].\nThe absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,-1,0,4,-2,-9\\]\n**Output:** 0\n**Explanation:** One optimal partition is: \\[2,4,-9\\] and \\[-1,0,-2\\].\nThe absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 15`\n*   `nums.length == 2 * n`\n*   `-107 <= nums[i] <= 107`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Dynamic Programming",
            "Bit Manipulation",
            "Ordered Set",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[3,9,7,3]",
                "output": "2"
            },
            {
                "input": "[-36,36]",
                "output": "72"
            },
            {
                "input": "[2,-1,0,4,-2,-9]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countSubIslands(int[][] grid1, int[][] grid2) {\n    int count = 0;\n\n    for (int i = 0; i < grid1.length; i++) {\n        for (int j = 0; j < grid1[0].length; j++) {\n            if (grid2[i][j] == 1) {\n                boolean[] isSubIsland = new boolean[1];\n                isSubIsland[0] = true;\n                dfs(grid1, grid2, i, j, isSubIsland);\n                if (isSubIsland[0]) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\nprivate void dfs(int[][] grid1, int[][] grid2, int i, int j, boolean[] isSubIsland) {\n    if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\n        return;\n    }\n\n    if (grid1[i][j] == 0) {\n        isSubIsland[0] = false;\n    }\n\n    grid2[i][j] = 0;\n\n    dfs(grid1, grid2, i + 1, j, isSubIsland);\n    dfs(grid1, grid2, i - 1, j, isSubIsland);\n    dfs(grid1, grid2, i, j + 1, isSubIsland);\n    dfs(grid1, grid2, i, j - 1, isSubIsland);\n}\n```\n    \n    The algorithm uses Depth-First Search (DFS) to traverse the islands in `grid2`. For each cell in `grid2` that has a value of 1 (representing land), it checks if it can be a sub-island by performing DFS.\n\nWithin the DFS search, if the corresponding cell in `grid1` has a value of 0, it indicates that the part of the island being traversed in `grid2` is not a subset of the island in `grid1`. In this case, the variable `isSubIsland` is set to `false`. During the search, it also marks the visited cells in `grid2` as 0 to avoid checking them multiple times. If the entire `dfs` returns `true`, then it is considered as a sub-island, and the count is incremented.\n\nIn the end, the total sub-island count is returned.\n    ",
        "python": "\n    ```python\ndef countSubIslands(grid1, grid2):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid1) or j < 0 or j >= len(grid1[0]) or grid2[i][j] == 0:\n            return True\n\n        grid2[i][j] = 0\n\n        isSubIsland = grid1[i][j] == 1\n        isSubIsland &= dfs(i + 1, j)\n        isSubIsland &= dfs(i - 1, j)\n        isSubIsland &= dfs(i, j + 1)\n        isSubIsland &= dfs(i, j - 1)\n\n        return isSubIsland\n\n    count = 0\n\n    for i in range(len(grid1)):\n        for j in range(len(grid1[0])):\n            if grid2[i][j] == 1 and dfs(i, j):\n                count += 1\n\n    return count\n```\n    \n    The algorithm uses Depth-First Search (DFS) to traverse the islands in `grid2`. For each cell in `grid2` that has a value of 1 (representing land), it checks if it can be a sub-island by performing DFS.\n\nWithin the DFS search, if the corresponding cell in `grid1` has a value of 0, it indicates that the part of the island being traversed in `grid2` is not a subset of the island in `grid1`. In this case, the variable `isSubIsland` is set to `false`. During the search, it also marks the visited cells in `grid2` as 0 to avoid checking them multiple times. If the entire `dfs` returns `true`, then it is considered as a sub-island, and the count is incremented.\n\nIn the end, the total sub-island count is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid dfs(std::vector<std::vector<int>>& grid1, std::vector<std::vector<int>>& grid2, int i, int j, bool& isSubIsland) {\n    if (i < 0 || i >= grid1.size() || j < 0 || j >= grid1[0].size() || grid2[i][j] == 0) {\n        return;\n    }\n\n    if (grid1[i][j] == 0) {\n        isSubIsland = false;\n    }\n\n    grid2[i][j] = 0;\n\n    dfs(grid1, grid2, i + 1, j, isSubIsland);\n    dfs(grid1, grid2, i - 1, j, isSubIsland);\n    dfs(grid1, grid2, i, j + 1, isSubIsland);\n    dfs(grid1, grid2, i, j - 1, isSubIsland);\n}\n\nint countSubIslands(std::vector<std::vector<int>>& grid1, std::vector<std::vector<int>>& grid2) {\n    int count = 0;\n\n    for (int i = 0; i < grid1.size(); ++i) {\n        for (int j = 0; j < grid1[0].size(); ++j) {\n            if (grid2[i][j] == 1) {\n                bool isSubIsland = true;\n                dfs(grid1, grid2, i, j, isSubIsland);\n                if (isSubIsland) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm uses Depth-First Search (DFS) to traverse the islands in `grid2`. For each cell in `grid2` that has a value of 1 (representing land), it checks if it can be a sub-island by performing DFS.\n\nWithin the DFS search, if the corresponding cell in `grid1` has a value of 0, it indicates that the part of the island being traversed in `grid2` is not a subset of the island in `grid1`. In this case, the variable `isSubIsland` is set to `false`. During the search, it also marks the visited cells in `grid2` as 0 to avoid checking them multiple times. If the entire `dfs` returns `true`, then it is considered as a sub-island, and the count is incremented.\n\nIn the end, the total sub-island count is returned.\n    ",
        "js": "\n    ```javascript\nfunction countSubIslands(grid1, grid2) {\n    function dfs(i, j) {\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] === 0) {\n            return true;\n        }\n\n        grid2[i][j] = 0;\n\n        let isSubIsland = grid1[i][j] === 1;\n        isSubIsland &= dfs(i + 1, j) ? 1 : 0;\n        isSubIsland &= dfs(i - 1, j) ? 1 : 0;\n        isSubIsland &= dfs(i, j + 1) ? 1 : 0;\n        isSubIsland &= dfs(i, j - 1) ? 1 : 0;\n\n        return isSubIsland;\n    }\n\n    let count = 0;\n\n    for (let i = 0; i < grid1.length; i++) {\n        for (let j = 0; j < grid1[0].length; j++) {\n            if (grid2[i][j] === 1 && dfs(i, j)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm uses Depth-First Search (DFS) to traverse the islands in `grid2`. For each cell in `grid2` that has a value of 1 (representing land), it checks if it can be a sub-island by performing DFS.\n\nWithin the DFS search, if the corresponding cell in `grid1` has a value of 0, it indicates that the part of the island being traversed in `grid2` is not a subset of the island in `grid1`. In this case, the variable `isSubIsland` is set to `false`. During the search, it also marks the visited cells in `grid2` as 0 to avoid checking them multiple times. If the entire `dfs` returns `true`, then it is considered as a sub-island, and the count is incremented.\n\nIn the end, the total sub-island count is returned.\n    "
    },
    {
        "id": 341,
        "title": "Kth Smallest Product of Two Sorted Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two **sorted 0-indexed** integer arrays `nums1` and `nums2` as well as an integer `k`, return _the_ `kth` _(**1-based**) smallest product of_ `nums1[i] * nums2[j]` _where_ `0 <= i < nums1.length` _and_ `0 <= j < nums2.length`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[2,5\\], nums2 = \\[3,4\\], k = 2\n**Output:** 8\n**Explanation:** The 2 smallest products are:\n- nums1\\[0\\] \\* nums2\\[0\\] = 2 \\* 3 = 6\n- nums1\\[0\\] \\* nums2\\[1\\] = 2 \\* 4 = 8\nThe 2nd smallest product is 8.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[-4,-2,0,3\\], nums2 = \\[2,4\\], k = 6\n**Output:** 0\n**Explanation:** The 6 smallest products are:\n- nums1\\[0\\] \\* nums2\\[1\\] = (-4) \\* 4 = -16\n- nums1\\[0\\] \\* nums2\\[0\\] = (-4) \\* 2 = -8\n- nums1\\[1\\] \\* nums2\\[1\\] = (-2) \\* 4 = -8\n- nums1\\[1\\] \\* nums2\\[0\\] = (-2) \\* 2 = -4\n- nums1\\[2\\] \\* nums2\\[0\\] = 0 \\* 2 = 0\n- nums1\\[2\\] \\* nums2\\[1\\] = 0 \\* 4 = 0\nThe 6th smallest product is 0.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[-2,-1,0,1,2\\], nums2 = \\[-3,-1,2,4,5\\], k = 3\n**Output:** -6\n**Explanation:** The 3 smallest products are:\n- nums1\\[0\\] \\* nums2\\[4\\] = (-2) \\* 5 = -10\n- nums1\\[0\\] \\* nums2\\[3\\] = (-2) \\* 4 = -8\n- nums1\\[4\\] \\* nums2\\[0\\] = 2 \\* (-3) = -6\nThe 3rd smallest product is -6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 5 * 104`\n*   `-105 <= nums1[i], nums2[j] <= 105`\n*   `1 <= k <= nums1.length * nums2.length`\n*   `nums1` and `nums2` are sorted.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[2,5],[3,4],2",
                "output": "8"
            },
            {
                "input": "[-4,-2,0,3],[2,4],6",
                "output": "0"
            },
            {
                "input": "[-2,-1,0,1,2],[-3,-1,2,4,5],3",
                "output": "-6"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\n        int n = passingFees.length;\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\n        }\n\n        int[][] dp = new int[n][maxTime + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        dp[0][0] = passingFees[0];\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(arr -> arr[2]));\n        pq.offer(new int[]{0, 0, passingFees[0]});\n\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int time = cur[0], city = cur[1], cost = cur[2];\n            if (city == n - 1) {\n                return cost;\n            }\n\n            for (int[] neighbor : graph.get(city)) {\n                int next_time = time + neighbor[1];\n                if (next_time > maxTime) continue;\n\n                int new_cost = cost + passingFees[neighbor[0]];\n                if (new_cost < dp[neighbor[0]][next_time]) {\n                    dp[neighbor[0]][next_time] = new_cost;\n                    pq.offer(new int[]{next_time, neighbor[0], new_cost});\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n    \n    We will use a variation of Dijkstra's algorithm to find the minimum journey cost. Create adjacency list representation of the given graph. Initialize `dp[][`] as an `n * (maxTime + 1)` array storing the minimum cost to reach the ith city within a given time j. Initially, set `dp[0][0]` as the value of passingFees[0] since we're at city 0.\n\nWe use a priority queue to store nodes with the current time, city, and cost in that moment. To achieve this, we implement a min-heap where nodes are sorted based on their cost. Push the initial state (0, 0, passingFees[0]) into the min-heap. Now for each iteration, take the top node (which has the minimum cost), and for each neighbor of this city, check the required time for the next step. If it's under maxTime, calculate a new cost for reaching that neighbor city.\n\nIf the new calculated cost for reaching that neighbor city is less than the current value of `dp[neighbor][next_time]`, update its value and push the new state (next_time, neighbor, new_cost) into the min-heap.\n\nRepeat this process until your min-heap becomes empty or you find a suitable path to the last city (index n-1). If you reach the final city, you can return the cost of that state, otherwise return -1, which is an indication that there is no possible path within the given maxTime.\n    ",
        "python": "\n    ```python\nimport heapq\nfrom collections import defaultdict\n\ndef minCost(maxTime, edges, passingFees):\n    n = len(passingFees)\n    graph = defaultdict(list)\n    for x, y, time in edges:\n        graph[x].append((y, time))\n        graph[y].append((x, time))\n\n    dp = [[float('inf')] * (maxTime + 1) for _ in range(n)]\n    dp[0][0] = passingFees[0]\n\n    pq = [(0, 0, passingFees[0])]\n    while pq:\n        time, city, cost = heapq.heappop(pq)\n        if city == n - 1:\n            return cost\n\n        for neighbor, t in graph[city]:\n            next_time = time + t\n            if next_time > maxTime:\n                continue\n\n            new_cost = cost + passingFees[neighbor]\n            if new_cost < dp[neighbor][next_time]:\n                dp[neighbor][next_time] = new_cost\n                heapq.heappush(pq, (next_time, neighbor, new_cost))\n\n    return -1\n```\n\n    \n    We will use a variation of Dijkstra's algorithm to find the minimum journey cost. Create adjacency list representation of the given graph. Initialize `dp[][`] as an `n * (maxTime + 1)` array storing the minimum cost to reach the ith city within a given time j. Initially, set `dp[0][0]` as the value of passingFees[0] since we're at city 0.\n\nWe use a priority queue to store nodes with the current time, city, and cost in that moment. To achieve this, we implement a min-heap where nodes are sorted based on their cost. Push the initial state (0, 0, passingFees[0]) into the min-heap. Now for each iteration, take the top node (which has the minimum cost), and for each neighbor of this city, check the required time for the next step. If it's under maxTime, calculate a new cost for reaching that neighbor city.\n\nIf the new calculated cost for reaching that neighbor city is less than the current value of `dp[neighbor][next_time]`, update its value and push the new state (next_time, neighbor, new_cost) into the min-heap.\n\nRepeat this process until your min-heap becomes empty or you find a suitable path to the last city (index n-1). If you reach the final city, you can return the cost of that state, otherwise return -1, which is an indication that there is no possible path within the given maxTime.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\n#include <queue>\n\nusing namespace std;\n\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\n    int n = passingFees.size();\n    vector<vector<pair<int, int>>> graph(n);\n    for (const auto& edge : edges) {\n        graph[edge[0]].emplace_back(edge[1], edge[2]);\n        graph[edge[1]].emplace_back(edge[0], edge[2]);\n    }\n\n    vector<vector<int>> dp(n, vector<int>(maxTime + 1, INT_MAX));\n    dp[0][0] = passingFees[0];\n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\n    pq.emplace(0, 0, passingFees[0]);\n\n    while (!pq.empty()) {\n        auto [time, city, cost] = pq.top();\n        pq.pop();\n        if (city == n - 1) {\n            return cost;\n        }\n        for (const auto& [neighbor, t] : graph[city]) {\n            int next_time = time + t;\n            if (next_time > maxTime) continue;\n            int new_cost = cost + passingFees[neighbor];\n            if (new_cost < dp[neighbor][next_time]) {\n                dp[neighbor][next_time] = new_cost;\n                pq.emplace(next_time, neighbor, new_cost);\n            }\n        }\n    }\n\n    return -1;\n}\n```\n    \n    We will use a variation of Dijkstra's algorithm to find the minimum journey cost. Create adjacency list representation of the given graph. Initialize `dp[][`] as an `n * (maxTime + 1)` array storing the minimum cost to reach the ith city within a given time j. Initially, set `dp[0][0]` as the value of passingFees[0] since we're at city 0.\n\nWe use a priority queue to store nodes with the current time, city, and cost in that moment. To achieve this, we implement a min-heap where nodes are sorted based on their cost. Push the initial state (0, 0, passingFees[0]) into the min-heap. Now for each iteration, take the top node (which has the minimum cost), and for each neighbor of this city, check the required time for the next step. If it's under maxTime, calculate a new cost for reaching that neighbor city.\n\nIf the new calculated cost for reaching that neighbor city is less than the current value of `dp[neighbor][next_time]`, update its value and push the new state (next_time, neighbor, new_cost) into the min-heap.\n\nRepeat this process until your min-heap becomes empty or you find a suitable path to the last city (index n-1). If you reach the final city, you can return the cost of that state, otherwise return -1, which is an indication that there is no possible path within the given maxTime.\n    ",
        "js": "\n    ```javascript\nfunction minCost(maxTime, edges, passingFees) {\n    const n = passingFees.length;\n    const graph = new Array(n).fill(null).map(() => []);\n    for (const edge of edges) {\n        graph[edge[0]].push([edge[1], edge[2]]);\n        graph[edge[1]].push([edge[0], edge[2]]);\n    }\n\n    const dp = new Array(n).fill(null).map(() => new Array(maxTime + 1).fill(Infinity));\n    dp[0][0] = passingFees[0];\n\n    const pq = [[0, 0, passingFees[0]]];\n    while (pq.length > 0) {\n        pq.sort((a, b) => a[2] - b[2]);\n        const [time, city, cost] = pq.shift();\n        if (city === n - 1) {\n            return cost;\n        }\n\n        for (const [neighbor, t] of graph[city]) {\n            const next_time = time + t;\n            if (next_time > maxTime) continue;\n\n            const new_cost = cost + passingFees[neighbor];\n            if (new_cost < dp[neighbor][next_time]) {\n                dp[neighbor][next_time] = new_cost;\n                pq.push([next_time, neighbor, new_cost]);\n            }\n        }\n    }\n\n    return -1;\n}\n```\n    \n    We will use a variation of Dijkstra's algorithm to find the minimum journey cost. Create adjacency list representation of the given graph. Initialize `dp[][`] as an `n * (maxTime + 1)` array storing the minimum cost to reach the ith city within a given time j. Initially, set `dp[0][0]` as the value of passingFees[0] since we're at city 0.\n\nWe use a priority queue to store nodes with the current time, city, and cost in that moment. To achieve this, we implement a min-heap where nodes are sorted based on their cost. Push the initial state (0, 0, passingFees[0]) into the min-heap. Now for each iteration, take the top node (which has the minimum cost), and for each neighbor of this city, check the required time for the next step. If it's under maxTime, calculate a new cost for reaching that neighbor city.\n\nIf the new calculated cost for reaching that neighbor city is less than the current value of `dp[neighbor][next_time]`, update its value and push the new state (next_time, neighbor, new_cost) into the min-heap.\n\nRepeat this process until your min-heap becomes empty or you find a suitable path to the last city (index n-1). If you reach the final city, you can return the cost of that state, otherwise return -1, which is an indication that there is no possible path within the given maxTime.\n    "
    },
    {
        "id": 342,
        "title": "Second Minimum Time to Reach Destination",
        "difficulty": "Hard",
        "content": {
            "problem": "A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.",
            "examples": [
                "**Example 1:**\n\n       \n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n",
                "**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`",
            "follow_up": null
        },
        "tag": [
            "Breadth-First Search",
            "Graph",
            "Shortest Path"
        ],
        "example": [
            {
                "input": "5,[[1,2],[1,3],[1,4],[3,4],[4,5]],3,5",
                "output": "13"
            },
            {
                "input": "2,[[1,2]],3,2",
                "output": "11"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int secondMinimum(int n, int[][] edges, int time, int change) {\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i <= n; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n\n    int[] dist = new int[n + 1];\n    int[] dist2 = new int[n + 1];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    Arrays.fill(dist2, Integer.MAX_VALUE);\n    dist[1] = 0;\n\n    Queue<Integer> q = new LinkedList<>();\n    q.add(1);\n\n    while (!q.isEmpty()) {\n        int cur = q.poll();\n\n        int nextDist = dist[cur] + time;\n        int waitTime = (nextDist / change % 2 == 1) ? change : 0;\n        nextDist += waitTime;\n\n        for (int next : graph.get(cur)) {\n            if (nextDist < dist[next]) {\n                int tmp = nextDist;\n                nextDist = dist[next];\n                dist[next] = tmp;\n                q.add(next);\n            }\n            if (nextDist < dist2[next]) {\n                int tmp = nextDist;\n                nextDist = dist2[next];\n                dist2[next] = tmp;\n                q.add(next);\n            }\n        }\n    }\n    return dist2[n];\n}\n```\n\n    \n    The main idea is to find the second shortest time for each vertex to reach the target vertex `n` using a Breadth-First Search (BFS) algorithm. Start by constructing the adjacency list representation of the graph. Then create two arrays `dist` and `dist2` for keeping the minimum and 2nd minimum time to reach each vertex, respectively.\n\n1. Initialize the distance arrays with infinity, except for `dist[1] = 0`, since the journey starts at vertex 1.\n2. Use a queue (`deque` in Python, `Queue` in Java, and array in JavaScript) for BFS traversal. Add the starting vertex to the queue.\n3. While the queue is not empty, do the following:\n    a. Pop the vertex from the queue.\n    b. Calculate the next distance by adding the current time to the current vertex's distance.\n    c. Check if the signal at the current vertex is green or red. If it's red, add the wait time required to turn it green.\n    d. Iterate through the neighbors of the current vertex.\n        - If the next distance is less than the minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n        - If the next distance is less than the 2nd minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n4. Return the 2nd minimum distance value of vertex `n`.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]\n```\n\n    \n    The main idea is to find the second shortest time for each vertex to reach the target vertex `n` using a Breadth-First Search (BFS) algorithm. Start by constructing the adjacency list representation of the graph. Then create two arrays `dist` and `dist2` for keeping the minimum and 2nd minimum time to reach each vertex, respectively.\n\n1. Initialize the distance arrays with infinity, except for `dist[1] = 0`, since the journey starts at vertex 1.\n2. Use a queue (`deque` in Python, `Queue` in Java, and array in JavaScript) for BFS traversal. Add the starting vertex to the queue.\n3. While the queue is not empty, do the following:\n    a. Pop the vertex from the queue.\n    b. Calculate the next distance by adding the current time to the current vertex's distance.\n    c. Check if the signal at the current vertex is green or red. If it's red, add the wait time required to turn it green.\n    d. Iterate through the neighbors of the current vertex.\n        - If the next distance is less than the minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n        - If the next distance is less than the 2nd minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n4. Return the 2nd minimum distance value of vertex `n`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\n    vector<vector<int>> graph(n + 1);\n    for (const auto &edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n\n    const int INF = 1e9;\n    vector<int> dist(n + 1, INF);\n    vector<int> dist2(n + 1, INF);\n    dist[1] = 0;\n\n    queue<int> q;\n    q.push(1);\n\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n\n        int nextDist = dist[cur] + time;\n        int waitTime = (nextDist / change % 2 == 1) ? change : 0;\n        nextDist += waitTime;\n\n        for (int next : graph[cur]) {\n            if (nextDist < dist[next]) {\n                swap(nextDist, dist[next]);\n                q.push(next);\n            }\n            if (nextDist < dist2[next]) {\n                swap(nextDist, dist2[next]);\n                q.push(next);\n            }\n        }\n    }\n    return dist2[n];\n}\n```\n\n    \n    The main idea is to find the second shortest time for each vertex to reach the target vertex `n` using a Breadth-First Search (BFS) algorithm. Start by constructing the adjacency list representation of the graph. Then create two arrays `dist` and `dist2` for keeping the minimum and 2nd minimum time to reach each vertex, respectively.\n\n1. Initialize the distance arrays with infinity, except for `dist[1] = 0`, since the journey starts at vertex 1.\n2. Use a queue (`deque` in Python, `Queue` in Java, and array in JavaScript) for BFS traversal. Add the starting vertex to the queue.\n3. While the queue is not empty, do the following:\n    a. Pop the vertex from the queue.\n    b. Calculate the next distance by adding the current time to the current vertex's distance.\n    c. Check if the signal at the current vertex is green or red. If it's red, add the wait time required to turn it green.\n    d. Iterate through the neighbors of the current vertex.\n        - If the next distance is less than the minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n        - If the next distance is less than the 2nd minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n4. Return the 2nd minimum distance value of vertex `n`.\n    ",
        "js": "\n    ```javascript\nfunction secondMinimum(n, edges, time, change) {\n    const graph = Array(n + 1).fill(null).map(() => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    const dist = new Array(n + 1).fill(Infinity);\n    const dist2 = new Array(n + 1).fill(Infinity);\n    dist[1] = 0;\n\n    const q = [1];\n\n    while (q.length) {\n        const cur = q.shift();\n\n        let nextDist = dist[cur] + time;\n        const waitTime = (nextDist / change) % 2 === 1 ? change : 0;\n        nextDist += waitTime;\n\n        for (const next of graph[cur]) {\n            if (nextDist < dist[next]) {\n                [nextDist, dist[next]] = [dist[next], nextDist];\n                q.push(next);\n            }\n            if (nextDist < dist2[next]) {\n                [nextDist, dist2[next]] = [dist2[next], nextDist];\n                q.push(next);\n            }\n        }\n    }\n    return dist2[n];\n}\n```\n\n    \n    The main idea is to find the second shortest time for each vertex to reach the target vertex `n` using a Breadth-First Search (BFS) algorithm. Start by constructing the adjacency list representation of the graph. Then create two arrays `dist` and `dist2` for keeping the minimum and 2nd minimum time to reach each vertex, respectively.\n\n1. Initialize the distance arrays with infinity, except for `dist[1] = 0`, since the journey starts at vertex 1.\n2. Use a queue (`deque` in Python, `Queue` in Java, and array in JavaScript) for BFS traversal. Add the starting vertex to the queue.\n3. While the queue is not empty, do the following:\n    a. Pop the vertex from the queue.\n    b. Calculate the next distance by adding the current time to the current vertex's distance.\n    c. Check if the signal at the current vertex is green or red. If it's red, add the wait time required to turn it green.\n    d. Iterate through the neighbors of the current vertex.\n        - If the next distance is less than the minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n        - If the next distance is less than the 2nd minimum distance of the neighbor vertex, swap them, and add the neighbor vertex to the queue.\n4. Return the 2nd minimum distance value of vertex `n`.\n    "
    },
    {
        "id": 343,
        "title": "Parallel Courses III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n",
                "**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "3,[[1,3],[2,3]],[3,2,5]",
                "output": "8"
            },
            {
                "input": "5,[[1,5],[2,5],[3,5],[3,4],[4,5]],[1,2,3,4,5]",
                "output": "12"
            }
        ],
        "java": "\n    ```java\npublic int count_good_digit_strings(int n) {\n    final int mod = (int)1e9 + 7;\n    int even_digits = 5, prime_digits = 4;\n    long total = 1;\n    for (int i = 0; i < n; ++i) {\n        total = (total * (i % 2 == 0 ? even_digits : prime_digits)) % mod;\n    }\n    return (int)total;\n}\n```\n    \n    The algorithm counts good digit strings of length n. There are 5 even digits (0, 2, 4, 6, 8) and 4 prime digits (2, 3, 5, 7). We initialize the count of good digit strings with a value of 1.\n\nWe then loop through the range [0, n). For each index i, if i is even, we multiply the total count by the number of even digits, and if i is odd, we multiply it by the number of prime digits. This takes into account all possible combinations of good digit strings.\n\nAfter iterating through the range, we return the total count modulo 1e9 + 7. This is done to keep the result within a specified range and prevent integer overflow.\n    ",
        "python": "\n    ```python\ndef count_good_digit_strings(n):\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total\n```\n    \n    The algorithm counts good digit strings of length n. There are 5 even digits (0, 2, 4, 6, 8) and 4 prime digits (2, 3, 5, 7). We initialize the count of good digit strings with a value of 1.\n\nWe then loop through the range [0, n). For each index i, if i is even, we multiply the total count by the number of even digits, and if i is odd, we multiply it by the number of prime digits. This takes into account all possible combinations of good digit strings.\n\nAfter iterating through the range, we return the total count modulo 1e9 + 7. This is done to keep the result within a specified range and prevent integer overflow.\n    ",
        "c++": "\n    ```cpp\nint count_good_digit_strings(int n) {\n    const int mod = 1e9 + 7;\n    long long even_digits = 5, prime_digits = 4, total = 1;\n    for (int i = 0; i < n; ++i) {\n        total = (total * (i % 2 == 0 ? even_digits : prime_digits)) % mod;\n    }\n    return total;\n}\n```\n    \n    The algorithm counts good digit strings of length n. There are 5 even digits (0, 2, 4, 6, 8) and 4 prime digits (2, 3, 5, 7). We initialize the count of good digit strings with a value of 1.\n\nWe then loop through the range [0, n). For each index i, if i is even, we multiply the total count by the number of even digits, and if i is odd, we multiply it by the number of prime digits. This takes into account all possible combinations of good digit strings.\n\nAfter iterating through the range, we return the total count modulo 1e9 + 7. This is done to keep the result within a specified range and prevent integer overflow.\n    ",
        "js": "\n    ```javascript\nfunction count_good_digit_strings(n) {\n    const mod = 1e9 + 7;\n    let even_digits = 5, prime_digits = 4, total = 1;\n    for (let i = 0; i < n; ++i) {\n        total = (total * (i % 2 === 0 ? even_digits : prime_digits)) % mod;\n    }\n    return total;\n}\n```\n    \n    The algorithm counts good digit strings of length n. There are 5 even digits (0, 2, 4, 6, 8) and 4 prime digits (2, 3, 5, 7). We initialize the count of good digit strings with a value of 1.\n\nWe then loop through the range [0, n). For each index i, if i is even, we multiply the total count by the number of even digits, and if i is odd, we multiply it by the number of prime digits. This takes into account all possible combinations of good digit strings.\n\nAfter iterating through the range, we return the total count modulo 1e9 + 7. This is done to keep the result within a specified range and prevent integer overflow.\n    "
    },
    {
        "id": 344,
        "title": "Number of Valid Move Combinations On Chessboard",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an `8 x 8` chessboard containing `n` pieces (rooks, queens, or bishops). You are given a string array `pieces` of length `n`, where `pieces[i]` describes the type (rook, queen, or bishop) of the `ith` piece. In addition, you are given a 2D integer array `positions` also of length `n`, where `positions[i] = [ri, ci]` indicates that the `ith` piece is currently at the **1-based** coordinate `(ri, ci)` on the chessboard.\n\nWhen making a **move** for a piece, you choose a **destination** square that the piece will travel toward and stop on.\n\n*   A rook can only travel **horizontally or vertically** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, or `(r, c-1)`.\n*   A queen can only travel **horizontally, vertically, or diagonally** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, `(r, c-1)`, `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.\n*   A bishop can only travel **diagonally** from `(r, c)` to the direction of `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.\n\nYou must make a **move** for every piece on the board simultaneously. A **move combination** consists of all the **moves** performed on all the given pieces. Every second, each piece will instantaneously travel **one square** towards their destination if they are not already at it. All pieces start traveling at the `0th` second. A move combination is **invalid** if, at a given time, **two or more** pieces occupy the same square.\n\nReturn _the number of **valid** move combinations_​​​​​.\n\n**Notes:**\n\n*   **No two pieces** will start in the **same** square.\n*   You may choose the square a piece is already on as its **destination**.\n*   If two pieces are **directly adjacent** to each other, it is valid for them to **move past each other** and swap positions in one second.",
            "examples": [
                "**Example 1:**\n\n**Input:** pieces = \\[ \"rook \"\\], positions = \\[\\[1,1\\]\\]\n**Output:** 15\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n",
                "**Example 2:**\n\n**Input:** pieces = \\[ \"queen \"\\], positions = \\[\\[1,1\\]\\]\n**Output:** 22\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n",
                "**Example 3:**\n\n**Input:** pieces = \\[ \"bishop \"\\], positions = \\[\\[4,3\\]\\]\n**Output:** 12\n**Explanation:** The image above shows the possible squares the piece can move to."
            ],
            "constraints": "**Constraints:**\n\n*   `n == pieces.length`\n*   `n == positions.length`\n*   `1 <= n <= 4`\n*   `pieces` only contains the strings `\"rook \"`, `\"queen \"`, and `\"bishop \"`.\n*   There will be at most one queen on the chessboard.\n*   `1 <= xi, yi <= 8`\n*   Each `positions[i]` is distinct.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Backtracking",
            "Simulation"
        ],
        "example": [
            {
                "input": "[\"rook\"],[[1,1]]",
                "output": "15"
            },
            {
                "input": "[\"queen\"],[[1,1]]",
                "output": "22"
            },
            {
                "input": "[\"bishop\"],[[4,3]]",
                "output": "12"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic int countValidCombos(List<String> pieces, List<List<Integer>> positions, int index) {\n    if (index == pieces.size()) { return 1; }\n\n    int r = positions.get(index).get(0), c = positions.get(index).get(1);\n    int[] dr = {0, 1, 0, -1, 1, 1, -1, -1};\n    int[] dc = {1, 0, -1, 0, 1, -1, 1, -1};\n    int valids = 0;\n\n    for (int x = 0; x < 8; ++x) {\n        if (pieces.get(index).equals(\"bishop\") && x < 4) continue;\n        if (pieces.get(index).equals(\"rook\") && x >= 4) break;\n\n        for (int dist = 1; dist <= 8; dist++) {\n            int nr = r + dr[x] * dist;\n            int nc = c + dc[x] * dist;\n            if (nr < 1 || nr > 8 || nc < 1 || nc > 8) break;\n            if (nr == r && nc == c) continue;\n\n            boolean valid = true;\n            for (int other = 0; other < positions.size(); ++other) {\n                if (other == index) continue;\n                int orr = positions.get(other).get(0), occ = positions.get(other).get(1);\n                if (orr == nr && occ == nc) { valid = false; break; }\n                if (orr + occ == nr + nc || orr - occ == nr - nc) { valid = false; break; }\n                if (orr == nr || occ == nc) { valid = false; break; }\n            }\n\n            if (valid) {\n                List<Integer> tmp = new ArrayList<>();\n                tmp.add(nr);\n                tmp.add(nc);\n                positions.set(index, tmp);\n                valids += countValidCombos(pieces, positions, index + 1);\n                positions.set(index, List.of(r, c));\n            }\n        }\n    }\n\n    return valids;\n}\n```\n    \n    For each piece, go through all possible moves considering their type (queens, rooks, and bishops). Then, for each reachable position, check if it conflicts with other pieces' position. If it does not conflict, update the current position and check the moves for the next piece recursively. When all pieces are checked, add the valid combinations.\n\nThen, in each of the four languages (C++, Java, Python, and JavaScript), implement the algorithm by translating the algorithm to each language-specific code style and syntax.\n    ",
        "python": "\n    ```python\ndef count_valid_combos(pieces, positions, index=0):\n    if index == len(pieces):\n        return 1\n\n    r, c = positions[index]\n    dr = [0, 1, 0, -1, 1, 1, -1, -1]\n    dc = [1, 0, -1, 0, 1, -1, 1, -1]\n    valids = 0\n\n    for x in range(8):\n        if pieces[index] == \"bishop\" and x < 4:\n            continue\n        if pieces[index] == \"rook\" and x >= 4:\n            break\n\n        for dist in range(1, 9):\n            nr, nc = r + dr[x] * dist, c + dc[x] * dist\n            if nr < 1 or nr > 8 or nc < 1 or nc > 8:\n                break\n            if nr == r and nc == c:\n                continue\n\n            valid = True\n            for other in range(len(positions)):\n                if other == index:\n                    continue\n                orr, occ = positions[other]\n                if orr == nr and occ == nc:\n                    valid = False\n                    break\n                if orr + occ == nr + nc or orr - occ == nr - nc:\n                    valid = False\n                    break\n                if orr == nr or occ == nc:\n                    valid = False\n                    break\n\n            if valid:\n                positions[index] = [nr, nc]\n                valids += count_valid_combos(pieces, positions, index + 1)\n                positions[index] = [r, c]\n\n    return valids\n```\n    \n    For each piece, go through all possible moves considering their type (queens, rooks, and bishops). Then, for each reachable position, check if it conflicts with other pieces' position. If it does not conflict, update the current position and check the moves for the next piece recursively. When all pieces are checked, add the valid combinations.\n\nThen, in each of the four languages (C++, Java, Python, and JavaScript), implement the algorithm by translating the algorithm to each language-specific code style and syntax.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint countValidCombos(vector<string>& pieces, vector<vector<int>>& positions, int index = 0) {\n    if (index == pieces.size()) { return 1; }\n\n    int r = positions[index][0], c = positions[index][1];\n    int dr[] = {0, 1, 0, -1, 1, 1, -1, -1};\n    int dc[] = {1, 0, -1, 0, 1, -1, 1, -1};\n    int valids = 0;\n\n    for (int x = 0; x < 8; ++x) {\n        if (pieces[index] == \"bishop\" && x < 4) continue;\n        if (pieces[index] == \"rook\" && x >= 4) break;\n\n        for (int dist = 1; dist <= 8; dist++) {\n            int nr = r + dr[x] * dist;\n            int nc = c + dc[x] * dist;\n            if (nr < 1 || nr > 8 || nc < 1 || nc > 8) break;\n            if (nr == r && nc == c) continue;\n\n            bool valid = true;\n            for (int other = 0; other < positions.size(); ++other) {\n                if (other == index) continue;\n                int orr = positions[other][0], occ = positions[other][1];\n                if (orr == nr && occ == nc) { valid = false; break; }\n                if (orr + occ == nr + nc || orr - occ == nr - nc) { valid = false; break; }\n                if (orr == nr || occ == nc) { valid = false; break; }\n            }\n\n            if (valid) {\n                vector<int> tmp = {nr, nc};\n                positions[index] = tmp;\n                valids += countValidCombos(pieces, positions, index + 1);\n                positions[index] = {r, c};\n            }\n        }\n    }\n\n    return valids;\n}\n```\n    \n    For each piece, go through all possible moves considering their type (queens, rooks, and bishops). Then, for each reachable position, check if it conflicts with other pieces' position. If it does not conflict, update the current position and check the moves for the next piece recursively. When all pieces are checked, add the valid combinations.\n\nThen, in each of the four languages (C++, Java, Python, and JavaScript), implement the algorithm by translating the algorithm to each language-specific code style and syntax.\n    ",
        "js": "\n    ```javascript\nfunction countValidCombos(pieces, positions, index=0) {\n    if (index === pieces.length) { return 1; }\n\n    let r = positions[index][0], c = positions[index][1];\n    let dr = [0, 1, 0, -1, 1, 1, -1, -1];\n    let dc = [1, 0, -1, 0, 1, -1, 1, -1];\n    let valids = 0;\n\n    for (let x = 0; x < 8; ++x) {\n        if (pieces[index] === \"bishop\" && x < 4) continue;\n        if (pieces[index] === \"rook\" && x >= 4) break;\n\n        for (let dist = 1; dist <= 8; dist++) {\n            let nr = r + dr[x] * dist;\n            let nc = c + dc[x] * dist;\n            if (nr < 1 || nr > 8 || nc < 1 || nc > 8) break;\n            if (nr === r && nc === c) continue;\n\n            let valid = true;\n            for (let other = 0; other < positions.length; ++other) {\n                if (other === index) continue;\n                let orr = positions[other][0], occ = positions[other][1];\n                if (orr === nr && occ === nc) { valid = false; break; }\n                if (orr + occ === nr + nc || orr - occ === nr - nc) { valid = false; break; }\n                if (orr === nr || occ === nc) { valid = false; break; }\n            }\n\n            if (valid) {\n                positions[index] = [nr, nc];\n                valids += countValidCombos(pieces, positions, index + 1);\n                positions[index] = [r, c];\n            }\n        }\n    }\n\n    return valids;\n}\n```\n    \n    For each piece, go through all possible moves considering their type (queens, rooks, and bishops). Then, for each reachable position, check if it conflicts with other pieces' position. If it does not conflict, update the current position and check the moves for the next piece recursively. When all pieces are checked, add the valid combinations.\n\nThen, in each of the four languages (C++, Java, Python, and JavaScript), implement the algorithm by translating the algorithm to each language-specific code style and syntax.\n    "
    },
    {
        "id": 345,
        "title": "Check if an Original String Exists Given Two Encoded Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "An original string, consisting of lowercase English letters, can be encoded by the following steps:\n\n*   Arbitrarily **split** it into a **sequence** of some number of **non-empty** substrings.\n*   Arbitrarily choose some elements (possibly none) of the sequence, and **replace** each with **its length** (as a numeric string).\n*   **Concatenate** the sequence as the encoded string.\n\nFor example, **one way** to encode an original string `\"abcdefghijklmnop \"` might be:\n\n*   Split it as a sequence: `[ \"ab \", \"cdefghijklmn \", \"o \", \"p \"]`.\n*   Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes `[ \"ab \", \"12 \", \"1 \", \"p \"]`.\n*   Concatenate the elements of the sequence to get the encoded string: `\"ab121p \"`.\n\nGiven two encoded strings `s1` and `s2`, consisting of lowercase English letters and digits `1-9` (inclusive), return `true` _if there exists an original string that could be encoded as **both**_ `s1` _and_ `s2`_. Otherwise, return_ `false`.\n\n**Note**: The test cases are generated such that the number of consecutive digits in `s1` and `s2` does not exceed `3`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"internationalization \", s2 =  \"i18n \"\n**Output:** true\n**Explanation:** It is possible that  \"internationalization \" was the original string.\n-  \"internationalization \" \n  -> Split:       \\[ \"internationalization \"\\]\n  -> Do not replace any element\n  -> Concatenate:   \"internationalization \", which is s1.\n-  \"internationalization \"\n  -> Split:       \\[ \"i \",  \"nternationalizatio \",  \"n \"\\]\n  -> Replace:     \\[ \"i \",  \"18 \",                  \"n \"\\]\n  -> Concatenate:   \"i18n \", which is s2\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"l123e \", s2 =  \"44 \"\n**Output:** true\n**Explanation:** It is possible that  \"leetcode \" was the original string.\n-  \"leetcode \" \n  -> Split:      \\[ \"l \",  \"e \",  \"et \",  \"cod \",  \"e \"\\]\n  -> Replace:    \\[ \"l \",  \"1 \",  \"2 \",   \"3 \",    \"e \"\\]\n  -> Concatenate:  \"l123e \", which is s1.\n-  \"leetcode \" \n  -> Split:      \\[ \"leet \",  \"code \"\\]\n  -> Replace:    \\[ \"4 \",     \"4 \"\\]\n  -> Concatenate:  \"44 \", which is s2.\n\n",
                "**Example 3:**\n\n**Input:** s1 =  \"a5b \", s2 =  \"c5b \"\n**Output:** false\n**Explanation:** It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 40`\n*   `s1` and `s2` consist of digits `1-9` (inclusive), and lowercase English letters only.\n*   The number of consecutive digits in `s1` and `s2` does not exceed `3`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"internationalization\",\"i18n\"",
                "output": "true"
            },
            {
                "input": "\"l123e\",\"44\"",
                "output": "true"
            },
            {
                "input": "\"a5b\",\"c5b\"",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic TreeNode mergeTrees(List<TreeNode> trees) {\n    while (trees.size() > 1) {\n        TreeNode tree1 = trees.remove(trees.size() - 1);\n        TreeNode tree2 = trees.remove(trees.size() - 1);\n\n        if (tree1.val < tree2.val) {\n            tree1.right = tree2;\n            trees.add(tree1);\n        } else {\n            tree2.right = tree1;\n            trees.add(tree2);\n        }\n    }\n    return trees.isEmpty() ? null : trees.get(0);\n}\n```\n    \n    The algorithm works by repeatedly merging the last two trees from the input list until there is only one tree left, or the list is empty. In each iteration, the function takes the last two trees from the list, compares their root values, and appends the tree with the smaller value's right child to the tree with the larger value. If the tree with the smaller value doesn't have the right subtree already, the resulting tree still holds the BST property. Then, the resultant tree is pushed back to the list. This operation will be performed n - 1 times. If we can make a valid BST, at the end there will be only one tree left in the list and we return its root. Otherwise, we return null.\n    ",
        "python": "\n    ```python\ndef merge_trees(trees):\n    while len(trees) > 1:\n        tree1 = trees.pop()\n        tree2 = trees.pop()\n\n        if tree1.val < tree2.val:\n            tree1.right = tree2\n            trees.append(tree1)\n        else:\n            tree2.right = tree1\n            trees.append(tree2)\n    return None if not trees else trees[0]\n```\n    \n    The algorithm works by repeatedly merging the last two trees from the input list until there is only one tree left, or the list is empty. In each iteration, the function takes the last two trees from the list, compares their root values, and appends the tree with the smaller value's right child to the tree with the larger value. If the tree with the smaller value doesn't have the right subtree already, the resulting tree still holds the BST property. Then, the resultant tree is pushed back to the list. This operation will be performed n - 1 times. If we can make a valid BST, at the end there will be only one tree left in the list and we return its root. Otherwise, we return null.\n    ",
        "c++": "\n    ```cpp\nTreeNode* mergeTrees(vector<TreeNode*>& trees) {\n    while (trees.size() > 1) {\n        TreeNode* tree1 = trees.back(); trees.pop_back();\n        TreeNode* tree2 = trees.back(); trees.pop_back();\n\n        if (tree1->val < tree2->val) {\n            tree1->right = tree2;\n            trees.push_back(tree1);\n        } else {\n            tree2->right = tree1;\n            trees.push_back(tree2);\n        }\n    }\n    return trees.empty() ? nullptr : trees[0];\n}\n```\n    \n    The algorithm works by repeatedly merging the last two trees from the input list until there is only one tree left, or the list is empty. In each iteration, the function takes the last two trees from the list, compares their root values, and appends the tree with the smaller value's right child to the tree with the larger value. If the tree with the smaller value doesn't have the right subtree already, the resulting tree still holds the BST property. Then, the resultant tree is pushed back to the list. This operation will be performed n - 1 times. If we can make a valid BST, at the end there will be only one tree left in the list and we return its root. Otherwise, we return null.\n    ",
        "js": "\n    ```javascript\nfunction mergeTrees(trees) {\n    while (trees.length > 1) {\n        let tree1 = trees.pop();\n        let tree2 = trees.pop();\n\n        if (tree1.val < tree2.val) {\n            tree1.right = tree2;\n            trees.push(tree1);\n        } else {\n            tree2.right = tree1;\n            trees.push(tree2);\n        }\n    }\n    return trees.length === 0 ? null : trees[0];\n}\n```\n    \n    The algorithm works by repeatedly merging the last two trees from the input list until there is only one tree left, or the list is empty. In each iteration, the function takes the last two trees from the list, compares their root values, and appends the tree with the smaller value's right child to the tree with the larger value. If the tree with the smaller value doesn't have the right subtree already, the resulting tree still holds the BST property. Then, the resultant tree is pushed back to the list. This operation will be performed n - 1 times. If we can make a valid BST, at the end there will be only one tree left in the list and we return its root. Otherwise, we return null.\n    "
    },
    {
        "id": 346,
        "title": "Maximum Path Quality of a Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an **undirected** graph with `n` nodes numbered from `0` to `n - 1` (**inclusive**). You are given a **0-indexed** integer array `values` where `values[i]` is the **value** of the `ith` node. You are also given a **0-indexed** 2D integer array `edges`, where each `edges[j] = [uj, vj, timej]` indicates that there is an undirected edge between the nodes `uj` and `vj`, and it takes `timej` seconds to travel between the two nodes. Finally, you are given an integer `maxTime`.\n\nA **valid** **path** in the graph is any path that starts at node `0`, ends at node `0`, and takes **at most** `maxTime` seconds to complete. You may visit the same node multiple times. The **quality** of a valid path is the **sum** of the values of the **unique nodes** visited in the path (each node's value is added **at most once** to the sum).\n\nReturn _the **maximum** quality of a valid path_.\n\n**Note:** There are **at most four** edges connected to each node.",
            "examples": [
                "**Example 1:**\n\n**Input:** values = \\[0,32,10,43\\], edges = \\[\\[0,1,10\\],\\[1,2,15\\],\\[0,3,10\\]\\], maxTime = 49\n**Output:** 75\n**Explanation:**\nOne possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.\n\n",
                "**Example 2:**\n\n**Input:** values = \\[5,10,15,20\\], edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[0,3,10\\]\\], maxTime = 30\n**Output:** 25\n**Explanation:**\nOne possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\nThe nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.\n\n",
                "**Example 3:**\n\n**Input:** values = \\[1,2,3,4\\], edges = \\[\\[0,1,10\\],\\[1,2,11\\],\\[2,3,12\\],\\[1,3,13\\]\\], maxTime = 50\n**Output:** 7\n**Explanation:**\nOne possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7."
            ],
            "constraints": "**Constraints:**\n\n*   `n == values.length`\n*   `1 <= n <= 1000`\n*   `0 <= values[i] <= 108`\n*   `0 <= edges.length <= 2000`\n*   `edges[j].length == 3`\n*   `0 <= uj < vj <= n - 1`\n*   `10 <= timej, maxTime <= 100`\n*   All the pairs `[uj, vj]` are **unique**.\n*   There are **at most four** edges connected to each node.\n*   The graph may not be connected.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking",
            "Graph"
        ],
        "example": [
            {
                "input": "[0,32,10,43],[[0,1,10],[1,2,15],[0,3,10]],49",
                "output": "75"
            },
            {
                "input": "[5,10,15,20],[[0,1,10],[1,2,10],[0,3,10]],30",
                "output": "25"
            },
            {
                "input": "[1,2,3,4],[[0,1,10],[1,2,11],[2,3,12],[1,3,13]],50",
                "output": "7"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int maxQuality_dfs(int node, int time_left, int[] visited, int[] values, List<List<int[]>> neighbors) {\n    int acc = 0;\n    for (int[] edge : neighbors.get(node)) {\n        int neighbor = edge[0], cost = edge[1];\n        if (time_left >= cost && visited[neighbor] == 0) {\n            visited[neighbor] = 1;\n            acc = Math.max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors));\n            visited[neighbor] = 0;\n        }\n    }\n    return acc;\n}\n\npublic int maxQuality(int[] values, int[][] edges, int maxTime) {\n    List<List<int[]>> neighbors = new ArrayList<>();\n    for (int i = 0; i < values.length; i++) {\n        neighbors.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        neighbors.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        neighbors.get(edge[1]).add(new int[]{edge[0], edge[2]});\n    }\n    int[] visited = new int[values.length];\n    return maxQuality_dfs(0, maxTime, visited, values, neighbors);\n}\n```\n\n    \n    The algorithm consists of doing a DFS traversal in the graph, starting from the node 0. It maintains an array `visited` and a `time_left` to store which nodes are visited and the remaining time, respectively. Then, for each neighbor the DFS goes to the neighbor if it hasn't been visited and there's enough time to visit it, updating the visited array and the remaining time. It visits the entire graph and returns the highest possible sum of unique node values that can be visited within `maxTime`. This approach takes advantage of the constraint that there are at most four edges connected to each node which allows the algorithm to be efficient enough to work within the given time limit.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef maxQuality_dfs(node, time_left, visited, values, neighbors):\n    acc = 0\n    for neighbor, cost in neighbors[node]:\n        if time_left >= cost and not visited[neighbor]:\n            visited[neighbor] = 1\n            acc = max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors))\n            visited[neighbor] = 0\n    return acc\n\ndef maxQuality(values, edges, maxTime):\n    neighbors = defaultdict(list)\n    for u, v, cost in edges:\n        neighbors[u].append((v, cost))\n        neighbors[v].append((u, cost))\n    visited = [0] * len(values)\n    return maxQuality_dfs(0, maxTime, visited, values, neighbors)\n```\n\n    \n    The algorithm consists of doing a DFS traversal in the graph, starting from the node 0. It maintains an array `visited` and a `time_left` to store which nodes are visited and the remaining time, respectively. Then, for each neighbor the DFS goes to the neighbor if it hasn't been visited and there's enough time to visit it, updating the visited array and the remaining time. It visits the entire graph and returns the highest possible sum of unique node values that can be visited within `maxTime`. This approach takes advantage of the constraint that there are at most four edges connected to each node which allows the algorithm to be efficient enough to work within the given time limit.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n\nint maxQuality_dfs(int node, int time_left, std::vector<int>& visited, std::vector<int>& values, std::vector<std::vector<int>>& neighbors) {\n    int acc = 0;\n    for (const auto& edge : neighbors[node]) {\n        int neighbor = edge[0], cost = edge[1];\n        if (time_left >= cost && visited[neighbor] == 0) {\n            visited[neighbor] = 1;\n            acc = std::max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors));\n            visited[neighbor] = 0;\n        }\n    }\n    return acc;\n}\n\nint maxQuality(std::vector<int>& values, std::vector<std::vector<int>>& edges, int maxTime) {\n    std::vector<std::vector<int>> neighbors(values.size());\n    for (const auto& edge : edges) {\n        neighbors[edge[0]].push_back({edge[1], edge[2]});\n        neighbors[edge[1]].push_back({edge[0], edge[2]});\n    }\n    std::vector<int> visited(values.size(), 0);\n    return maxQuality_dfs(0, maxTime, visited, values, neighbors);\n}\n```\n\n    \n    The algorithm consists of doing a DFS traversal in the graph, starting from the node 0. It maintains an array `visited` and a `time_left` to store which nodes are visited and the remaining time, respectively. Then, for each neighbor the DFS goes to the neighbor if it hasn't been visited and there's enough time to visit it, updating the visited array and the remaining time. It visits the entire graph and returns the highest possible sum of unique node values that can be visited within `maxTime`. This approach takes advantage of the constraint that there are at most four edges connected to each node which allows the algorithm to be efficient enough to work within the given time limit.\n    ",
        "js": "\n    ```javascript\nfunction maxQuality_dfs(node, time_left, visited, values, neighbors) {\n  let acc = 0;\n  for (let edge of neighbors[node]) {\n    let neighbor = edge[0], cost = edge[1];\n    if (time_left >= cost && visited[neighbor] === 0) {\n      visited[neighbor] = 1;\n      acc = Math.max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors));\n      visited[neighbor] = 0;\n    }\n  }\n  return acc;\n}\n\nfunction maxQuality(values, edges, maxTime) {\n  let neighbors = new Array(values.length).fill(null).map(() => []);\n  for (let edge of edges) {\n    neighbors[edge[0]].push([edge[1], edge[2]]);\n    neighbors[edge[1]].push([edge[0], edge[2]]);\n  }\n  let visited = new Array(values.length).fill(0);\n  return maxQuality_dfs(0, maxTime, visited, values, neighbors);\n}\n```\n\n    \n    The algorithm consists of doing a DFS traversal in the graph, starting from the node 0. It maintains an array `visited` and a `time_left` to store which nodes are visited and the remaining time, respectively. Then, for each neighbor the DFS goes to the neighbor if it hasn't been visited and there's enough time to visit it, updating the visited array and the remaining time. It visits the entire graph and returns the highest possible sum of unique node values that can be visited within `maxTime`. This approach takes advantage of the constraint that there are at most four edges connected to each node which allows the algorithm to be efficient enough to work within the given time limit.\n    "
    },
    {
        "id": 347,
        "title": "Maximum Number of Tasks You Can Assign",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` tasks and `m` workers. Each task has a strength requirement stored in a **0-indexed** integer array `tasks`, with the `ith` task requiring `tasks[i]` strength to complete. The strength of each worker is stored in a **0-indexed** integer array `workers`, with the `jth` worker having `workers[j]` strength. Each worker can only be assigned to a **single** task and must have a strength **greater than or equal** to the task's strength requirement (i.e., `workers[j] >= tasks[i]`).\n\nAdditionally, you have `pills` magical pills that will **increase a worker's strength** by `strength`. You can decide which workers receive the magical pills, however, you may only give each worker **at most one** magical pill.\n\nGiven the **0-indexed** integer arrays `tasks` and `workers` and the integers `pills` and `strength`, return _the **maximum** number of tasks that can be completed._",
            "examples": [
                "**Example 1:**\n\n**Input:** tasks = \\[**3**,**2**,**1**\\], workers = \\[**0**,**3**,**3**\\], pills = 1, strength = 1\n**Output:** 3\n**Explanation:**\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 2 (0 + 1 >= 1)\n- Assign worker 1 to task 1 (3 >= 2)\n- Assign worker 2 to task 0 (3 >= 3)\n\n",
                "**Example 2:**\n\n**Input:** tasks = \\[**5**,4\\], workers = \\[**0**,0,0\\], pills = 1, strength = 5\n**Output:** 1\n**Explanation:**\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 0 (0 + 5 >= 5)\n\n",
                "**Example 3:**\n\n**Input:** tasks = \\[**10**,**15**,30\\], workers = \\[**0**,**10**,10,10,10\\], pills = 3, strength = 10\n**Output:** 2\n**Explanation:**\nWe can assign the magical pills and tasks as follows:\n- Give the magical pill to worker 0 and worker 1.\n- Assign worker 0 to task 0 (0 + 10 >= 10)\n- Assign worker 1 to task 1 (10 + 10 >= 15)\nThe last pill is not given because it will not make any worker strong enough for the last task."
            ],
            "constraints": "**Constraints:**\n\n*   `n == tasks.length`\n*   `m == workers.length`\n*   `1 <= n, m <= 5 * 104`\n*   `0 <= pills <= m`\n*   `0 <= tasks[i], workers[j], strength <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Queue",
            "Sorting",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[**3**,**2**,**1**],[**0**,**3**,**3**],1,1",
                "output": "3"
            },
            {
                "input": "[**5**,4],[**0**,0,0],1,5",
                "output": "1"
            },
            {
                "input": "[**10**,**15**,30],[**0**,**10**,10,10,10],3,10",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int maxTasks(int[] tasks, int[] workers, int pills, int strength) {\n  Arrays.sort(tasks);\n  Arrays.sort(workers);\n\n  int cnt = 0;\n  for (int i = 0, j = 0; j < pills; ++j) {\n    while (i < tasks.length && tasks[i] > workers[j] + strength) {\n      ++i;\n    }\n    if (i < tasks.length) {\n      ++cnt;\n      ++i;\n    }\n  }\n\n  for (int i = 0, j = pills; i < tasks.length && j < workers.length; ++i) {\n    if (tasks[i] <= workers[j]) {\n      ++cnt;\n      ++j;\n    }\n  }\n\n  return cnt;\n}\n```\n\n    \n    First, we sort both the tasks and the workers lists. This will simplify our assignments later.\n\nWe then count the number of tasks that will be completed given the available pills. Start with the lowest task and check if a worker with a pill can complete the task. If a worker with a pill can complete the task, we add 1 to our task counter and move to the next task. We do this for all pills as long as there are remaining tasks.\n\nFinally, we check the remaining tasks and workers without pills to see if they can complete any tasks. We start with the lowest task and try to match it to a worker without a pill. If a worker can complete the task, we increment our task counter and move to the next task.\n\nWe return the total number of tasks that can be completed.\n    ",
        "python": "\n    ```python\ndef maxTasks(tasks, workers, pills, strength):\n  tasks.sort()\n  workers.sort()\n\n  cnt = 0\n  i = 0\n  for j in range(pills):\n    while i < len(tasks) and tasks[i] > workers[j] + strength:\n      i += 1\n    if i < len(tasks):\n      cnt += 1\n      i += 1\n\n  i = 0\n  for j in range(pills, len(workers)):\n    if i < len(tasks) and tasks[i] <= workers[j]:\n      cnt += 1\n      i += 1\n      \n  return cnt\n```\n\n    \n    First, we sort both the tasks and the workers lists. This will simplify our assignments later.\n\nWe then count the number of tasks that will be completed given the available pills. Start with the lowest task and check if a worker with a pill can complete the task. If a worker with a pill can complete the task, we add 1 to our task counter and move to the next task. We do this for all pills as long as there are remaining tasks.\n\nFinally, we check the remaining tasks and workers without pills to see if they can complete any tasks. We start with the lowest task and try to match it to a worker without a pill. If a worker can complete the task, we increment our task counter and move to the next task.\n\nWe return the total number of tasks that can be completed.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxTasks(std::vector<int>& tasks, std::vector<int>& workers, int pills, int strength) {\n  std::sort(tasks.begin(), tasks.end());\n  std::sort(workers.begin(), workers.end());\n  \n  int cnt = 0;\n  for (int i = 0, j = 0; j < pills; ++j) {\n    while (i < tasks.size() && tasks[i] > workers[j] + strength) {\n      ++i;\n    }\n    if (i < tasks.size()) {\n      ++cnt;\n      ++i;\n    }\n  }\n\n  for (int i = 0, j = pills; i < tasks.size() && j < workers.size(); ++i) {\n    if (tasks[i] <= workers[j]) {\n      ++cnt;\n      ++j;\n    }\n  }\n\n  return cnt;\n}\n```\n\n    \n    First, we sort both the tasks and the workers lists. This will simplify our assignments later.\n\nWe then count the number of tasks that will be completed given the available pills. Start with the lowest task and check if a worker with a pill can complete the task. If a worker with a pill can complete the task, we add 1 to our task counter and move to the next task. We do this for all pills as long as there are remaining tasks.\n\nFinally, we check the remaining tasks and workers without pills to see if they can complete any tasks. We start with the lowest task and try to match it to a worker without a pill. If a worker can complete the task, we increment our task counter and move to the next task.\n\nWe return the total number of tasks that can be completed.\n    ",
        "js": "\n    ```javascript\nfunction maxTasks(tasks, workers, pills, strength) {\n  tasks.sort((a, b) => a - b);\n  workers.sort((a, b) => a - b);\n\n  let cnt = 0;\n  let i = 0;\n  for (let j = 0; j < pills; ++j) {\n    while (i < tasks.length && tasks[i] > workers[j] + strength) {\n      ++i;\n    }\n    if (i < tasks.length) {\n      ++cnt;\n      ++i;\n    }\n  }\n\n  for (i = 0, j = pills; i < tasks.length && j < workers.length; ++i) {\n    if (tasks[i] <= workers[j]) {\n      ++cnt;\n      ++j;\n    }\n  }\n\n  return cnt;\n}\n```\n\n    \n    First, we sort both the tasks and the workers lists. This will simplify our assignments later.\n\nWe then count the number of tasks that will be completed given the available pills. Start with the lowest task and check if a worker with a pill can complete the task. If a worker with a pill can complete the task, we add 1 to our task counter and move to the next task. We do this for all pills as long as there are remaining tasks.\n\nFinally, we check the remaining tasks and workers without pills to see if they can complete any tasks. We start with the lowest task and try to match it to a worker without a pill. If a worker can complete the task, we increment our task counter and move to the next task.\n\nWe return the total number of tasks that can be completed.\n    "
    },
    {
        "id": 348,
        "title": "Process Restricted Friend Requests",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n` indicating the number of people in a network. Each person is labeled from `0` to `n - 1`.\n\nYou are also given a **0-indexed** 2D integer array `restrictions`, where `restrictions[i] = [xi, yi]` means that person `xi` and person `yi` **cannot** become **friends**, either **directly** or **indirectly** through other people.\n\nInitially, no one is friends with each other. You are given a list of friend requests as a **0-indexed** 2D integer array `requests`, where `requests[j] = [uj, vj]` is a friend request between person `uj` and person `vj`.\n\nA friend request is **successful** if `uj` and `vj` can be **friends**. Each friend request is processed in the given order (i.e., `requests[j]` occurs before `requests[j + 1]`), and upon a successful request, `uj` and `vj` **become direct friends** for all future friend requests.\n\nReturn _a **boolean array**_ `result`, _where each_ `result[j]` _is_ `true` _if the_ `jth` _friend request is **successful** or_ `false` _if it is not_.\n\n**Note:** If `uj` and `vj` are already direct friends, the request is still **successful**.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, restrictions = \\[\\[0,1\\]\\], requests = \\[\\[0,2\\],\\[2,1\\]\\]\n**Output:** \\[true,false\\]\n**Explanation:**\nRequest 0: Person 0 and person 2 can be friends, so they become direct friends. \nRequest 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).\n\n",
                "**Example 2:**\n\n**Input:** n = 3, restrictions = \\[\\[0,1\\]\\], requests = \\[\\[1,2\\],\\[0,2\\]\\]\n**Output:** \\[true,false\\]\n**Explanation:**\nRequest 0: Person 1 and person 2 can be friends, so they become direct friends.\nRequest 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).\n\n",
                "**Example 3:**\n\n**Input:** n = 5, restrictions = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\]\\], requests = \\[\\[0,4\\],\\[1,2\\],\\[3,1\\],\\[3,4\\]\\]\n**Output:** \\[true,false,true,false\\]\n**Explanation:**\nRequest 0: Person 0 and person 4 can be friends, so they become direct friends.\nRequest 1: Person 1 and person 2 cannot be friends since they are directly restricted.\nRequest 2: Person 3 and person 1 can be friends, so they become direct friends.\nRequest 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1)."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `0 <= restrictions.length <= 1000`\n*   `restrictions[i].length == 2`\n*   `0 <= xi, yi <= n - 1`\n*   `xi != yi`\n*   `1 <= requests.length <= 1000`\n*   `requests[j].length == 2`\n*   `0 <= uj, vj <= n - 1`\n*   `uj != vj`",
            "follow_up": null
        },
        "tag": [
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "3,[[0,1]],[[0,2],[2,1]]",
                "output": "[true,false]"
            },
            {
                "input": "3,[[0,1]],[[1,2],[0,2]]",
                "output": "[true,false]"
            },
            {
                "input": "5,[[0,1],[1,2],[2,3]],[[0,4],[1,2],[3,1],[3,4]]",
                "output": "[true,false,true,false]"
            }
        ],
        "java": "\n    ```java\nint alphabet_position_sum(String s, int k) {\n    int sum = 0;\n    for (char c : s.toCharArray()) {\n        sum += c - 'a' + 1;\n    }\n    for (int i = 0; i < k; i++) {\n        int new_sum = 0;\n        while (sum > 0) {\n            new_sum += sum % 10;\n            sum /= 10;\n        }\n        sum = new_sum;\n    }\n    return sum;\n}\n```\n    \n    1. Calculate the initial sum by iterating through each character in the string and adding the position of the letter in the alphabet to the sum. The position can be determined by subtracting the ASCII value of 'a' from the character's ASCII value and adding 1 (`c - 'a' + 1`).\n2. For `k` number of times, perform the \"transform operation\" by setting the sum to the sum of its individual digits. This is done by iterating through the number while it's greater than zero, adding the remainder of the number divided by 10 (which gives the last digit) to a new sum variable, and then dividing the number by 10 to remove the last digit. After the loop is done, set the sum variable to the new sum.\n3. Return the resulting integer.\n    ",
        "python": "\n    ```python\ndef alphabet_position_sum(s, k):\n    sum = 0\n    for c in s:\n        sum += ord(c) - ord('a') + 1\n    for _ in range(k):\n        new_sum = 0\n        while sum > 0:\n            new_sum += sum % 10\n            sum //= 10\n        sum = new_sum\n    return sum\n```\n    \n    1. Calculate the initial sum by iterating through each character in the string and adding the position of the letter in the alphabet to the sum. The position can be determined by subtracting the ASCII value of 'a' from the character's ASCII value and adding 1 (`c - 'a' + 1`).\n2. For `k` number of times, perform the \"transform operation\" by setting the sum to the sum of its individual digits. This is done by iterating through the number while it's greater than zero, adding the remainder of the number divided by 10 (which gives the last digit) to a new sum variable, and then dividing the number by 10 to remove the last digit. After the loop is done, set the sum variable to the new sum.\n3. Return the resulting integer.\n    ",
        "c++": "\n    ```cpp\nint alphabet_position_sum(const std::string &s, int k) {\n    int sum = 0;\n    for (char c : s) {\n        sum += c - 'a' + 1;\n    }\n    for (int i = 0; i < k; ++i) {\n        int new_sum = 0;\n        while (sum > 0) {\n            new_sum += sum % 10;\n            sum /= 10;\n        }\n        sum = new_sum;\n    }\n    return sum;\n}\n```\n    \n    1. Calculate the initial sum by iterating through each character in the string and adding the position of the letter in the alphabet to the sum. The position can be determined by subtracting the ASCII value of 'a' from the character's ASCII value and adding 1 (`c - 'a' + 1`).\n2. For `k` number of times, perform the \"transform operation\" by setting the sum to the sum of its individual digits. This is done by iterating through the number while it's greater than zero, adding the remainder of the number divided by 10 (which gives the last digit) to a new sum variable, and then dividing the number by 10 to remove the last digit. After the loop is done, set the sum variable to the new sum.\n3. Return the resulting integer.\n    ",
        "js": "\n    ```javascript\nfunction alphabet_position_sum(s, k) {\n    let sum = 0;\n    for (let c of s) {\n        sum += c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n    }\n    for (let i = 0; i < k; i++) {\n        let new_sum = 0;\n        while (sum > 0) {\n            new_sum += sum % 10;\n            sum = Math.floor(sum / 10);\n        }\n        sum = new_sum;\n    }\n    return sum;\n}\n```\n    \n    1. Calculate the initial sum by iterating through each character in the string and adding the position of the letter in the alphabet to the sum. The position can be determined by subtracting the ASCII value of 'a' from the character's ASCII value and adding 1 (`c - 'a' + 1`).\n2. For `k` number of times, perform the \"transform operation\" by setting the sum to the sum of its individual digits. This is done by iterating through the number while it's greater than zero, adding the remainder of the number divided by 10 (which gives the last digit) to a new sum variable, and then dividing the number by 10 to remove the last digit. After the loop is done, set the sum variable to the new sum.\n3. Return the resulting integer.\n    "
    },
    {
        "id": 349,
        "title": "Sum of k-Mirror Numbers",
        "difficulty": "Hard",
        "content": {
            "problem": "A **k-mirror number** is a **positive** integer **without leading zeros** that reads the same both forward and backward in base-10 **as well as** in base-k.\n\n*   For example, `9` is a 2-mirror number. The representation of `9` in base-10 and base-2 are `9` and `1001` respectively, which read the same both forward and backward.\n*   On the contrary, `4` is not a 2-mirror number. The representation of `4` in base-2 is `100`, which does not read the same both forward and backward.\n\nGiven the base `k` and the number `n`, return _the **sum** of the_ `n` _**smallest** k-mirror numbers_.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 2, n = 5\n**Output:** 25\n**Explanation:**\nThe 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:\n  base-10    base-2\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\nTheir sum = 1 + 3 + 5 + 7 + 9 = 25. \n\n",
                "**Example 2:**\n\n**Input:** k = 3, n = 7\n**Output:** 499\n**Explanation:**\nThe 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:\n  base-10    base-3\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\nTheir sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.\n\n",
                "**Example 3:**\n\n**Input:** k = 7, n = 17\n**Output:** 20379000\n**Explanation:** The 17 smallest 7-mirror numbers are:\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= k <= 9`\n*   `1 <= n <= 30`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Enumeration"
        ],
        "example": [
            {
                "input": "2,5",
                "output": "25"
            },
            {
                "input": "3,7",
                "output": "499"
            },
            {
                "input": "7,17",
                "output": "20379000"
            }
        ],
        "java": "\n    ```java\npublic int minWastedSpace(int[] nums, int k) {\n    int n = nums.length;\n    int[][] dp = new int[n + 1][k + 1];\n    for(int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\n    dp[0][0] = 0;\n\n    for(int i = 1; i <= n; ++i) {\n        int total = 0;\n        for(int j = i; j > 0; --j) {\n            total += nums[j - 1];\n            for(int l = 0; l < k; ++l) {\n                dp[i][l + 1] = Math.min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1) * nums[j - 1] - total);\n            }\n        }\n    }\n\n    int min = dp[n][0];\n    for(int s : dp[n]) min = Math.min(min, s);\n    return min;\n}\n```\n\n    \n    The algorithm uses dynamic programming to keep track of and minimize the total wasted space for each possible resizing operation. The main idea is to use an n-by-(k+1) table that represents the wasted space given a certain number of resizing operations. At the beginning, the table is initialized with an infinitely large wasted space value to guarantee that every additional resizing operation will lead to a smaller wasted space.\n\nThe algorithm then iterates through each possible time step in the nums array and determines the total number of elements to be stored at each given timestep. This information is updated within the nested loop, iterating through each of the previous timesteps and for each possible number of resizing operations.\n\nAt each iteration, the algorithm calculates the current wasted space and updates the dynamic programming table with the minimum value for the current resizing operation. In the end, the minimum wasted space given the maximum number of resizing operations can be found in the last column of the dynamic programming table.\n    ",
        "python": "\n    ```python\ndef minWastedSpace(nums, k):\n    n = len(nums)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        total = 0\n        for j in range(i, 0, -1):\n            total += nums[j - 1]\n            for l in range(k):\n                dp[i][l + 1] = min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1) * nums[j - 1] - total)\n\n    return min(dp[n])\n```\n\n    \n    The algorithm uses dynamic programming to keep track of and minimize the total wasted space for each possible resizing operation. The main idea is to use an n-by-(k+1) table that represents the wasted space given a certain number of resizing operations. At the beginning, the table is initialized with an infinitely large wasted space value to guarantee that every additional resizing operation will lead to a smaller wasted space.\n\nThe algorithm then iterates through each possible time step in the nums array and determines the total number of elements to be stored at each given timestep. This information is updated within the nested loop, iterating through each of the previous timesteps and for each possible number of resizing operations.\n\nAt each iteration, the algorithm calculates the current wasted space and updates the dynamic programming table with the minimum value for the current resizing operation. In the end, the minimum wasted space given the maximum number of resizing operations can be found in the last column of the dynamic programming table.\n    ",
        "c++": "\n    ```cpp\nint minWastedSpace(vector<int>& nums, int k) {\n    int n = nums.size();\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));\n    dp[0][0] = 0;\n\n    for(int i = 1; i <= n; ++i) {\n        int total = 0;\n        for(int j = i; j > 0; --j) {\n            total += nums[j - 1];\n            for(int l = 0; l < k; ++l) {\n                dp[i][l + 1] = min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1) * nums[j - 1] - total);\n            }\n        }\n    }\n\n    return *min_element(dp[n].begin(), dp[n].end());\n}\n```\n\n    \n    The algorithm uses dynamic programming to keep track of and minimize the total wasted space for each possible resizing operation. The main idea is to use an n-by-(k+1) table that represents the wasted space given a certain number of resizing operations. At the beginning, the table is initialized with an infinitely large wasted space value to guarantee that every additional resizing operation will lead to a smaller wasted space.\n\nThe algorithm then iterates through each possible time step in the nums array and determines the total number of elements to be stored at each given timestep. This information is updated within the nested loop, iterating through each of the previous timesteps and for each possible number of resizing operations.\n\nAt each iteration, the algorithm calculates the current wasted space and updates the dynamic programming table with the minimum value for the current resizing operation. In the end, the minimum wasted space given the maximum number of resizing operations can be found in the last column of the dynamic programming table.\n    ",
        "js": "\n    ```javascript\nfunction minWastedSpace(nums, k) {\n    const n = nums.length;\n    const dp = Array.from({length: n + 1}, () => Array(k + 1).fill(Infinity));\n    dp[0][0] = 0;\n\n    for(let i = 1; i <= n; ++i) {\n        let total = 0;\n        for(let j = i; j > 0; --j) {\n            total += nums[j - 1];\n            for(let l = 0; l < k; ++l) {\n                dp[i][l + 1] = Math.min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1) * nums[j - 1] - total);\n            }\n        }\n    }\n\n    return Math.min(...dp[n]);\n}\n```\n\n    \n    The algorithm uses dynamic programming to keep track of and minimize the total wasted space for each possible resizing operation. The main idea is to use an n-by-(k+1) table that represents the wasted space given a certain number of resizing operations. At the beginning, the table is initialized with an infinitely large wasted space value to guarantee that every additional resizing operation will lead to a smaller wasted space.\n\nThe algorithm then iterates through each possible time step in the nums array and determines the total number of elements to be stored at each given timestep. This information is updated within the nested loop, iterating through each of the previous timesteps and for each possible number of resizing operations.\n\nAt each iteration, the algorithm calculates the current wasted space and updates the dynamic programming table with the minimum value for the current resizing operation. In the end, the minimum wasted space given the maximum number of resizing operations can be found in the last column of the dynamic programming table.\n    "
    },
    {
        "id": 350,
        "title": "Count Fertile Pyramids in a Land",
        "difficulty": "Hard",
        "content": {
            "problem": "A farmer has a **rectangular grid** of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either **fertile** (represented by a `1`) or **barren** (represented by a `0`). All cells outside the grid are considered barren.\n\nA **pyramidal plot** of land can be defined as a set of cells with the following criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h - 1` **and** `c - (i - r) <= j <= c + (i - r)`.\n\nAn **inverse pyramidal plot** of land can be defined as a set of cells with similar criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r - h + 1 <= i <= r` **and** `c - (r - i) <= j <= c + (r - i)`.\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\nGiven a **0-indexed** `m x n` binary matrix `grid` representing the farmland, return _the **total number** of pyramidal and inverse pyramidal plots that can be found in_ `grid`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[1,1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,0\\],\\[1,1,1,1,1\\],\\[1,1,1,1,1\\],\\[0,1,0,0,1\\]\\]\n**Output:** 13\n**Explanation:** There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,1,1,0],[1,1,1,1]]",
                "output": "2"
            },
            {
                "input": "[[1,1,1],[1,1,1]]",
                "output": "2"
            },
            {
                "input": "[[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]",
                "output": "13"
            }
        ],
        "java": "\n    ```java\npublic int minTimeToType(String word) {\n    int time = 0, prev = 0;\n    for (char c : word.toCharArray()) {\n        int pos = c - 'a';\n        time += Math.min(Math.abs(pos - prev), 26 - Math.abs(pos - prev)) + 1;\n        prev = pos;\n    }\n    return time;\n}\n```\n\n    \n    The algorithm calculates the minimum time to type the characters in the given word. We initialize time and previous character position to 0. We then loop through each character in the word and calculate their position in alphabet by subtracting 'a'.\n\nTo find the time to move the pointer from the previous character to the current character, we use the minimum of the absolute difference between the positions and 26 - absolute difference between positions (because at max distance is 13 letters). We add 1 to the total time because typing the character would take 1 second as well.\n\nUpdate the previous position variable to the current character position and continue this process for all the characters in the word. The resulting total time is the minimum number of seconds required to type the given word.\n    ",
        "python": "\n    ```python\ndef min_time_to_type(word: str) -> int:\n    time, prev = 0, 0\n    for c in word:\n        pos = ord(c) - ord('a')\n        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1\n        prev = pos\n    return time\n```\n\n    \n    The algorithm calculates the minimum time to type the characters in the given word. We initialize time and previous character position to 0. We then loop through each character in the word and calculate their position in alphabet by subtracting 'a'.\n\nTo find the time to move the pointer from the previous character to the current character, we use the minimum of the absolute difference between the positions and 26 - absolute difference between positions (because at max distance is 13 letters). We add 1 to the total time because typing the character would take 1 second as well.\n\nUpdate the previous position variable to the current character position and continue this process for all the characters in the word. The resulting total time is the minimum number of seconds required to type the given word.\n    ",
        "c++": "\n    ```cpp\nint minTimeToType(string word) {\n    int time = 0, prev = 0;\n    for (char c : word) {\n        int pos = c - 'a';\n        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1;\n        prev = pos;\n    }\n    return time;\n}\n```\n\n    \n    The algorithm calculates the minimum time to type the characters in the given word. We initialize time and previous character position to 0. We then loop through each character in the word and calculate their position in alphabet by subtracting 'a'.\n\nTo find the time to move the pointer from the previous character to the current character, we use the minimum of the absolute difference between the positions and 26 - absolute difference between positions (because at max distance is 13 letters). We add 1 to the total time because typing the character would take 1 second as well.\n\nUpdate the previous position variable to the current character position and continue this process for all the characters in the word. The resulting total time is the minimum number of seconds required to type the given word.\n    ",
        "js": "\n    ```javascript\nfunction minTimeToType(word) {\n    let time = 0, prev = 0;\n    for (let c of word) {\n        let pos = c.charCodeAt(0) - 'a'.charCodeAt(0);\n        time += Math.min(Math.abs(pos - prev), 26 - Math.abs(pos - prev)) + 1;\n        prev = pos;\n    }\n    return time;\n}\n```\n\n    \n    The algorithm calculates the minimum time to type the characters in the given word. We initialize time and previous character position to 0. We then loop through each character in the word and calculate their position in alphabet by subtracting 'a'.\n\nTo find the time to move the pointer from the previous character to the current character, we use the minimum of the absolute difference between the positions and 26 - absolute difference between positions (because at max distance is 13 letters). We add 1 to the total time because typing the character would take 1 second as well.\n\nUpdate the previous position variable to the current character position and continue this process for all the characters in the word. The resulting total time is the minimum number of seconds required to type the given word.\n    "
    },
    {
        "id": 351,
        "title": "Find All People With Secret",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n` indicating there are `n` people numbered from `0` to `n - 1`. You are also given a **0-indexed** 2D integer array `meetings` where `meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi` have a meeting at `timei`. A person may attend **multiple meetings** at the same time. Finally, you are given an integer `firstPerson`.\n\nPerson `0` has a **secret** and initially shares the secret with a person `firstPerson` at time `0`. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person `xi` has the secret at `timei`, then they will share the secret with person `yi`, and vice versa.\n\nThe secrets are shared **instantaneously**. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\n\nReturn _a list of all the people that have the secret after all the meetings have taken place._ You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, meetings = \\[\\[1,2,5\\],\\[2,3,8\\],\\[1,5,10\\]\\], firstPerson = 1\n**Output:** \\[0,1,2,3,5\\]\n**Explanation:**\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.​​​​\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, meetings = \\[\\[3,1,3\\],\\[1,2,2\\],\\[0,3,3\\]\\], firstPerson = 3\n**Output:** \\[0,1,3\\]\n**Explanation:**\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.\n\n",
                "**Example 3:**\n\n**Input:** n = 5, meetings = \\[\\[3,4,2\\],\\[1,2,1\\],\\[2,3,1\\]\\], firstPerson = 1\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:**\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 3`\n*   `0 <= xi, yi <= n - 1`\n*   `xi != yi`\n*   `1 <= timei <= 105`\n*   `1 <= firstPerson <= n - 1`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Breadth-First Search",
            "Union Find",
            "Graph",
            "Sorting"
        ],
        "example": [
            {
                "input": "6,[[1,2,5],[2,3,8],[1,5,10]],1",
                "output": "[0,1,2,3,5]"
            },
            {
                "input": "4,[[3,1,3],[1,2,2],[0,3,3]],3",
                "output": "[0,1,3]"
            },
            {
                "input": "5,[[3,4,2],[1,2,1],[2,3,1]],1",
                "output": "[0,1,2,3,4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> findSecretSharers(int n, int[][] meetings, int firstPerson) {\n    int[] secret_holders = new int[n];\n    Arrays.fill(secret_holders, -1);\n    secret_holders[0] = 0;\n    secret_holders[firstPerson] = 0;\n\n    Arrays.sort(meetings, (a, b) -> Integer.compare(a[2], b[2]));\n\n    for (int[] meeting : meetings) {\n        int x = meeting[0];\n        int y = meeting[1];\n        int time = meeting[2];\n\n        if (secret_holders[x] != -1 && secret_holders[x] <= time) secret_holders[y] = time;\n        if (secret_holders[y] != -1 && secret_holders[y] <= time) secret_holders[x] = time;\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n        if (secret_holders[i] != -1) result.add(i);\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm initializes an array `n` long with -1s called `secret_holders`, and only setting person `0` and the `firstPerson` to 0, representing that they initially have the secret. The meetings are then sorted by time. The algorithm then iterates over the meetings, and if either person `x` or `y` has the secret and the secret was obtained before the meeting time, then the secret is shared with the other person within this meeting. After all meetings, the algorithm returns the indices of `secret_holders` with values that are not -1, representing the people who have the secret.\n    ",
        "python": "\n    ```python\ndef find_secret_sharers(n, meetings, first_person):\n    secret_holders = [-1] * n\n    secret_holders[0] = 0\n    secret_holders[first_person] = 0\n\n    meetings.sort(key=lambda x: x[2])\n\n    for x, y, time in meetings:\n        if secret_holders[x] != -1 and secret_holders[x] <= time:\n            secret_holders[y] = time\n        if secret_holders[y] != -1 and secret_holders[y] <= time:\n            secret_holders[x] = time\n\n    return [i for i in range(n) if secret_holders[i] != -1]\n```\n\n    \n    The algorithm initializes an array `n` long with -1s called `secret_holders`, and only setting person `0` and the `firstPerson` to 0, representing that they initially have the secret. The meetings are then sorted by time. The algorithm then iterates over the meetings, and if either person `x` or `y` has the secret and the secret was obtained before the meeting time, then the secret is shared with the other person within this meeting. After all meetings, the algorithm returns the indices of `secret_holders` with values that are not -1, representing the people who have the secret.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<int> findSecretSharers(int n, vector<vector<int>>& meetings, int firstPerson) {\n    vector<int> secret_holders(n, -1);\n    secret_holders[0] = 0;\n    secret_holders[firstPerson] = 0;\n\n    sort(meetings.begin(), meetings.end(), [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });\n\n    for (auto& meeting : meetings) {\n        int x = meeting[0];\n        int y = meeting[1];\n        int time = meeting[2];\n\n        if (secret_holders[x] != -1 && secret_holders[x] <= time) secret_holders[y] = time;\n        if (secret_holders[y] != -1 && secret_holders[y] <= time) secret_holders[x] = time;\n    }\n\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        if (secret_holders[i] != -1) result.push_back(i);\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm initializes an array `n` long with -1s called `secret_holders`, and only setting person `0` and the `firstPerson` to 0, representing that they initially have the secret. The meetings are then sorted by time. The algorithm then iterates over the meetings, and if either person `x` or `y` has the secret and the secret was obtained before the meeting time, then the secret is shared with the other person within this meeting. After all meetings, the algorithm returns the indices of `secret_holders` with values that are not -1, representing the people who have the secret.\n    ",
        "js": "\n    ```javascript\nfunction findSecretSharers(n, meetings, firstPerson) {\n    let secret_holders = Array(n).fill(-1);\n    secret_holders[0] = 0;\n    secret_holders[firstPerson] = 0;\n\n    meetings.sort((a, b) => a[2] - b[2]);\n\n    for (let [x, y, time] of meetings) {\n        if (secret_holders[x] !== -1 && secret_holders[x] <= time) secret_holders[y] = time;\n        if (secret_holders[y] !== -1 && secret_holders[y] <= time) secret_holders[x] = time;\n    }\n\n    return secret_holders.reduce((result, has_secret, i) => {\n        if (has_secret !== -1) result.push(i);\n        return result;\n    }, []);\n}\n```\n\n    \n    The algorithm initializes an array `n` long with -1s called `secret_holders`, and only setting person `0` and the `firstPerson` to 0, representing that they initially have the secret. The meetings are then sorted by time. The algorithm then iterates over the meetings, and if either person `x` or `y` has the secret and the secret was obtained before the meeting time, then the secret is shared with the other person within this meeting. After all meetings, the algorithm returns the indices of `secret_holders` with values that are not -1, representing the people who have the secret.\n    "
    },
    {
        "id": 352,
        "title": "Valid Arrangement of Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `pairs` where `pairs[i] = [starti, endi]`. An arrangement of `pairs` is **valid** if for every index `i` where `1 <= i < pairs.length`, we have `endi-1 == starti`.\n\nReturn _**any** valid arrangement of_ `pairs`.\n\n**Note:** The inputs will be generated such that there exists a valid arrangement of `pairs`.",
            "examples": [
                "**Example 1:**\n\n**Input:** pairs = \\[\\[5,1\\],\\[4,5\\],\\[11,9\\],\\[9,4\\]\\]\n**Output:** \\[\\[11,9\\],\\[9,4\\],\\[4,5\\],\\[5,1\\]\\]\n**Explanation:**\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3\n\n",
                "**Example 2:**\n\n**Input:** pairs = \\[\\[1,3\\],\\[3,2\\],\\[2,1\\]\\]\n**Output:** \\[\\[1,3\\],\\[3,2\\],\\[2,1\\]\\]\n**Explanation:**\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements \\[\\[2,1\\],\\[1,3\\],\\[3,2\\]\\] and \\[\\[3,2\\],\\[2,1\\],\\[1,3\\]\\] are also valid.\n\n",
                "**Example 3:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[1,3\\],\\[2,1\\]\\]\n**Output:** \\[\\[1,2\\],\\[2,1\\],\\[1,3\\]\\]\n**Explanation:**\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pairs.length <= 105`\n*   `pairs[i].length == 2`\n*   `0 <= starti, endi <= 109`\n*   `starti != endi`\n*   No two pairs are exactly the same.\n*   There **exists** a valid arrangement of `pairs`.",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Eulerian Circuit"
        ],
        "example": [
            {
                "input": "[[5,1],[4,5],[11,9],[9,4]]",
                "output": "[[11,9],[9,4],[4,5],[5,1]]"
            },
            {
                "input": "[[1,3],[3,2],[2,1]]",
                "output": "[[1,3],[3,2],[2,1]]"
            },
            {
                "input": "[[1,2],[1,3],[2,1]]",
                "output": "[[1,2],[2,1],[1,3]]"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic List<List<Integer>> validArrangement(List<List<Integer>> pairs) {\n    Map<Integer, List<Integer>> graph = new HashMap<>();\n    for (List<Integer> pair : pairs) {\n        graph.putIfAbsent(pair.get(0), new ArrayList<>());\n        graph.get(pair.get(0)).add(pair.get(1));\n    }\n    List<List<Integer>> result = new ArrayList<>();\n    int current = pairs.get(0).get(0);\n    while (!graph.isEmpty()) {\n        List<Integer> temp = new ArrayList<>();\n        temp.add(current);\n        temp.add(graph.get(current).remove(graph.get(current).size()-1));\n        if (graph.get(current).isEmpty()) graph.remove(current);\n        result.add(temp);\n        current = temp.get(1);\n    }\n    return result;\n}\n```\n\n    \n    We can turn this problem into a directed graph where nodes are the start and end of each pair, and an edge indicates the connection between the two nodes. All we need to do is create a path that covers all the nodes in the graph without visiting any node twice.\n\n1. Create a graph using the 'pairs' array.\n2. Initialize a variable 'current' with the first 'start' of pairs array.\n3. Create an empty 'result' array.\n4. While the graph is not empty, follow below steps:\n   1. Create a pair [current, graph[current].pop()].\n   2. If graph[current] becomes empty after popping, remove it from the graph.\n   3. Append the created pair to the result.\n   4. Update the current with the end of the current pair.\n5. Return the 'result' array.\n\nThis algorithm will return a valid arrangement of the 'pairs' array.\n    ",
        "python": "\n    ```python\ndef valid_arrangement(pairs):\n    graph = {}\n    for start, end in pairs:\n        if start not in graph:\n            graph[start] = []\n        graph[start].append(end)\n\n    result = []\n    current = pairs[0][0]\n\n    while graph:\n        pair = [current, graph[current].pop()]\n        if not graph[current]:\n            del graph[current]\n        result.append(pair)\n        current = pair[1]\n\n    return result\n```\n\n    \n    We can turn this problem into a directed graph where nodes are the start and end of each pair, and an edge indicates the connection between the two nodes. All we need to do is create a path that covers all the nodes in the graph without visiting any node twice.\n\n1. Create a graph using the 'pairs' array.\n2. Initialize a variable 'current' with the first 'start' of pairs array.\n3. Create an empty 'result' array.\n4. While the graph is not empty, follow below steps:\n   1. Create a pair [current, graph[current].pop()].\n   2. If graph[current] becomes empty after popping, remove it from the graph.\n   3. Append the created pair to the result.\n   4. Update the current with the end of the current pair.\n5. Return the 'result' array.\n\nThis algorithm will return a valid arrangement of the 'pairs' array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\n    unordered_map<int, vector<int>> graph;\n    for (const auto &pair : pairs) {\n        graph[pair[0]].push_back(pair[1]);\n    }\n    vector<vector<int>> result;\n    int current = pairs[0][0];\n    while (graph.size()) {\n        result.push_back({current, graph[current].back()});\n        graph[current].pop_back();\n        if (graph[current].empty()) graph.erase(current);\n        current = result.back()[1];\n    }\n    return result;\n}\n```\n\n    \n    We can turn this problem into a directed graph where nodes are the start and end of each pair, and an edge indicates the connection between the two nodes. All we need to do is create a path that covers all the nodes in the graph without visiting any node twice.\n\n1. Create a graph using the 'pairs' array.\n2. Initialize a variable 'current' with the first 'start' of pairs array.\n3. Create an empty 'result' array.\n4. While the graph is not empty, follow below steps:\n   1. Create a pair [current, graph[current].pop()].\n   2. If graph[current] becomes empty after popping, remove it from the graph.\n   3. Append the created pair to the result.\n   4. Update the current with the end of the current pair.\n5. Return the 'result' array.\n\nThis algorithm will return a valid arrangement of the 'pairs' array.\n    ",
        "js": "\n    ```javascript\nfunction validArrangement(pairs) {\n    let graph = new Map();\n    for (let pair of pairs) {\n        if (!graph.has(pair[0])) {\n            graph.set(pair[0], []);\n        }\n        graph.get(pair[0]).push(pair[1]);\n    }\n    let result = [];\n    let current = pairs[0][0];\n    while (graph.size) {\n        let pair = [current, graph.get(current).pop()];\n        if (graph.get(current).length === 0) {\n            graph.delete(current);\n        }\n        result.push(pair);\n        current = pair[1];\n    }\n    return result;\n}\n```\n\n    \n    We can turn this problem into a directed graph where nodes are the start and end of each pair, and an edge indicates the connection between the two nodes. All we need to do is create a path that covers all the nodes in the graph without visiting any node twice.\n\n1. Create a graph using the 'pairs' array.\n2. Initialize a variable 'current' with the first 'start' of pairs array.\n3. Create an empty 'result' array.\n4. While the graph is not empty, follow below steps:\n   1. Create a pair [current, graph[current].pop()].\n   2. If graph[current] becomes empty after popping, remove it from the graph.\n   3. Append the created pair to the result.\n   4. Update the current with the end of the current pair.\n5. Return the 'result' array.\n\nThis algorithm will return a valid arrangement of the 'pairs' array.\n    "
    },
    {
        "id": 353,
        "title": "Sequentially Ordinal Rank Tracker",
        "difficulty": "Hard",
        "content": {
            "problem": "A scenic location is represented by its `name` and attractiveness `score`, where `name` is a **unique** string among all locations and `score` is an integer. Locations can be ranked from the best to the worst. The **higher** the score, the better the location. If the scores of two locations are equal, then the location with the **lexicographically smaller** name is better.\n\nYou are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:\n\n*   **Adding** scenic locations, **one at a time**.\n*   **Querying** the `ith` **best** location of **all locations already added**, where `i` is the number of times the system has been queried (including the current query).\n    *   For example, when the system is queried for the `4th` time, it returns the `4th` best location of all locations already added.\n\nNote that the test data are generated so that **at any time**, the number of queries **does not exceed** the number of locations added to the system.\n\nImplement the `SORTracker` class:\n\n*   `SORTracker()` Initializes the tracker system.\n*   `void add(string name, int score)` Adds a scenic location with `name` and `score` to the system.\n*   `string get()` Queries and returns the `ith` best location, where `i` is the number of times this method has been invoked (including this invocation).",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"SORTracker \",  \"add \",  \"add \",  \"get \",  \"add \",  \"get \",  \"add \",  \"get \",  \"add \",  \"get \",  \"add \",  \"get \",  \"get \"\\]\n\\[\\[\\], \\[ \"bradford \", 2\\], \\[ \"branford \", 3\\], \\[\\], \\[ \"alps \", 2\\], \\[\\], \\[ \"orland \", 2\\], \\[\\], \\[ \"orlando \", 3\\], \\[\\], \\[ \"alpine \", 2\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null,  \"branford \", null,  \"alps \", null,  \"bradford \", null,  \"bradford \", null,  \"bradford \",  \"orland \"\\]\n\n**Explanation**\nSORTracker tracker = new SORTracker(); // Initialize the tracker system.\ntracker.add( \"bradford \", 2); // Add location with name= \"bradford \" and score=2 to the system.\ntracker.add( \"branford \", 3); // Add location with name= \"branford \" and score=3 to the system.\ntracker.get();              // The sorted locations, from best to worst, are: branford, bradford.\n                            // Note that branford precedes bradford due to its **higher score** (3 > 2).\n                            // This is the 1st time get() is called, so return the best location:  \"branford \".\ntracker.add( \"alps \", 2);     // Add location with name= \"alps \" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, alps, bradford.\n                            // Note that alps precedes bradford even though they have the same score (2).\n                            // This is because  \"alps \" is **lexicographically smaller** than  \"bradford \".\n                            // Return the 2nd best location  \"alps \", as it is the 2nd time get() is called.\ntracker.add( \"orland \", 2);   // Add location with name= \"orland \" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, alps, bradford, orland.\n                            // Return  \"bradford \", as it is the 3rd time get() is called.\ntracker.add( \"orlando \", 3);  // Add location with name= \"orlando \" and score=3 to the system.\ntracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.\n                            // Return  \"bradford \".\ntracker.add( \"alpine \", 2);   // Add location with name= \"alpine \" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                            // Return  \"bradford \".\ntracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                            // Return  \"orland \"."
            ],
            "constraints": "**Constraints:**\n\n*   `name` consists of lowercase English letters, and is unique among all locations.\n*   `1 <= name.length <= 10`\n*   `1 <= score <= 105`\n*   At any time, the number of calls to `get` does not exceed the number of calls to `add`.\n*   At most `4 * 104` calls **in total** will be made to `add` and `get`.",
            "follow_up": null
        },
        "tag": [
            "Design",
            "Heap (Priority Queue)",
            "Data Stream",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],],],],],]]",
                "output": "**Output**\n[null,null,null,\"branford\",null,\"alps\",null,\"bradford\",null,\"bradford\",null,\"bradford\",\"orland\"]"
            }
        ],
        "java": "\n    ```java\npublic int findMiddleIndex(int[] nums) {\n    int total_sum = 0;\n    for (int num : nums) total_sum += num;\n\n    int left_sum = 0;\n    for (int i = 0; i < nums.length; i++) {\n        total_sum -= nums[i];\n        if (left_sum == total_sum) return i;\n        left_sum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    1. Calculate the total sum of the elements in the array.\n2. Initialize a variable `left_sum` to store the sum of elements on the left side of middleIndex.\n3. Iterate through the elements of the array:\n    a. Subtract the current element from the total sum.\n    b. Compare the left_sum with the total sum (which now represents the sum of the elements on the right side after excluding the current element). If they are equal, return the current index as the middleIndex.\n    c. Add the current element to the left_sum.\n4. If none of the indices satisfy the condition, return -1.\n    ",
        "python": "\n    ```python\ndef findMiddleIndex(nums):\n    total_sum = sum(nums)\n    \n    left_sum = 0\n    for i, num in enumerate(nums):\n        total_sum -= num\n        if left_sum == total_sum:\n            return i\n        left_sum += num\n    \n    return -1\n```\n    \n    1. Calculate the total sum of the elements in the array.\n2. Initialize a variable `left_sum` to store the sum of elements on the left side of middleIndex.\n3. Iterate through the elements of the array:\n    a. Subtract the current element from the total sum.\n    b. Compare the left_sum with the total sum (which now represents the sum of the elements on the right side after excluding the current element). If they are equal, return the current index as the middleIndex.\n    c. Add the current element to the left_sum.\n4. If none of the indices satisfy the condition, return -1.\n    ",
        "c++": "\n    ```cpp\nint findMiddleIndex(vector<int>& nums) {\n    int total_sum = 0;\n    for (int num : nums) total_sum += num;\n\n    int left_sum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        total_sum -= nums[i];\n        if (left_sum == total_sum) return i;\n        left_sum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    1. Calculate the total sum of the elements in the array.\n2. Initialize a variable `left_sum` to store the sum of elements on the left side of middleIndex.\n3. Iterate through the elements of the array:\n    a. Subtract the current element from the total sum.\n    b. Compare the left_sum with the total sum (which now represents the sum of the elements on the right side after excluding the current element). If they are equal, return the current index as the middleIndex.\n    c. Add the current element to the left_sum.\n4. If none of the indices satisfy the condition, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findMiddleIndex(nums) {\n    let total_sum = nums.reduce((acc, num) => acc + num, 0);\n\n    let left_sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        total_sum -= nums[i];\n        if (left_sum === total_sum) return i;\n        left_sum += nums[i];\n    }\n\n    return -1;\n}\n```\n    \n    1. Calculate the total sum of the elements in the array.\n2. Initialize a variable `left_sum` to store the sum of elements on the left side of middleIndex.\n3. Iterate through the elements of the array:\n    a. Subtract the current element from the total sum.\n    b. Compare the left_sum with the total sum (which now represents the sum of the elements on the right side after excluding the current element). If they are equal, return the current index as the middleIndex.\n    c. Add the current element to the left_sum.\n4. If none of the indices satisfy the condition, return -1.\n    "
    },
    {
        "id": 354,
        "title": "Maximum Fruits Harvested After at Most K Steps",
        "difficulty": "Hard",
        "content": {
            "problem": "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\nReturn _the **maximum total number** of fruits you can harvest_.",
            "examples": [
                "**Example 1:**\n\n**Input:** fruits = \\[\\[2,8\\],\\[6,3\\],\\[8,6\\]\\], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n",
                "**Example 2:**\n\n**Input:** fruits = \\[\\[0,9\\],\\[4,1\\],\\[5,7\\],\\[6,2\\],\\[7,4\\],\\[10,9\\]\\], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n",
                "**Example 3:**\n\n**Input:** fruits = \\[\\[0,3\\],\\[6,4\\],\\[8,5\\]\\], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `fruits[i].length == 2`\n*   `0 <= startPos, positioni <= 2 * 105`\n*   `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n*   `1 <= amounti <= 104`\n*   `0 <= k <= 2 * 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[2,8],[6,3],[8,6]],5,4",
                "output": "9"
            },
            {
                "input": "[[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]],5,4",
                "output": "14"
            },
            {
                "input": "[[0,3],[6,4],[8,5]],3,2",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\npublic int findGCD(int[] nums) {\n    int minVal = Arrays.stream(nums).min().getAsInt();\n    int maxVal = Arrays.stream(nums).max().getAsInt();\n    return gcd(minVal, maxVal);\n}\n```\n    \n    The algorithm implementation follows these steps:\n\n1. Define the gcd() function, which will compute the greatest common divisor using the Euclidean algorithm.\n2. Create the findGCD() function, which takes an array of integers (nums) as an argument.\n3. In the findGCD() function, find the minimum and maximum values in the given array. This is done using various min/max methods depending on the language used: std::min_element/std::max_element (C++), Arrays.stream (Java), min/max (Python), or. Math.min/Math.max (JavaScript).\n4. Return the gcd of the minimum and maximum values found in step 3 by calling the gcd() function.\n\nThis finds the greatest common divisor of the smallest and largest numbers in the given array.\n    ",
        "python": "\n    ```python\nfrom math import gcd\n\ndef findGCD(nums):\n    return gcd(min(nums), max(nums))\n```\n    \n    The algorithm implementation follows these steps:\n\n1. Define the gcd() function, which will compute the greatest common divisor using the Euclidean algorithm.\n2. Create the findGCD() function, which takes an array of integers (nums) as an argument.\n3. In the findGCD() function, find the minimum and maximum values in the given array. This is done using various min/max methods depending on the language used: std::min_element/std::max_element (C++), Arrays.stream (Java), min/max (Python), or. Math.min/Math.max (JavaScript).\n4. Return the gcd of the minimum and maximum values found in step 3 by calling the gcd() function.\n\nThis finds the greatest common divisor of the smallest and largest numbers in the given array.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nint findGCD(std::vector<int>& nums) {\n    int minVal = *std::min_element(nums.begin(), nums.end());\n    int maxVal = *std::max_element(nums.begin(), nums.end());\n    return gcd(minVal, maxVal);\n}\n```\n    \n    The algorithm implementation follows these steps:\n\n1. Define the gcd() function, which will compute the greatest common divisor using the Euclidean algorithm.\n2. Create the findGCD() function, which takes an array of integers (nums) as an argument.\n3. In the findGCD() function, find the minimum and maximum values in the given array. This is done using various min/max methods depending on the language used: std::min_element/std::max_element (C++), Arrays.stream (Java), min/max (Python), or. Math.min/Math.max (JavaScript).\n4. Return the gcd of the minimum and maximum values found in step 3 by calling the gcd() function.\n\nThis finds the greatest common divisor of the smallest and largest numbers in the given array.\n    ",
        "js": "\n    ```javascript\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n\nfunction findGCD(nums) {\n    const minVal = Math.min(...nums);\n    const maxVal = Math.max(...nums);\n    return gcd(minVal, maxVal);\n}\n```\n    \n    The algorithm implementation follows these steps:\n\n1. Define the gcd() function, which will compute the greatest common divisor using the Euclidean algorithm.\n2. Create the findGCD() function, which takes an array of integers (nums) as an argument.\n3. In the findGCD() function, find the minimum and maximum values in the given array. This is done using various min/max methods depending on the language used: std::min_element/std::max_element (C++), Arrays.stream (Java), min/max (Python), or. Math.min/Math.max (JavaScript).\n4. Return the gcd of the minimum and maximum values found in step 3 by calling the gcd() function.\n\nThis finds the greatest common divisor of the smallest and largest numbers in the given array.\n    "
    },
    {
        "id": 355,
        "title": "Minimum Operations to Make the Array K-Increasing",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** array `arr` consisting of `n` positive integers, and a positive integer `k`.\n\nThe array `arr` is called **K-increasing** if `arr[i-k] <= arr[i]` holds for every index `i`, where `k <= i <= n-1`.\n\n*   For example, `arr = [4, 1, 5, 2, 6, 2]` is K-increasing for `k = 2` because:\n    *   `arr[0] <= arr[2] (4 <= 5)`\n    *   `arr[1] <= arr[3] (1 <= 2)`\n    *   `arr[2] <= arr[4] (5 <= 6)`\n    *   `arr[3] <= arr[5] (2 <= 2)`\n*   However, the same `arr` is not K-increasing for `k = 1` (because `arr[0] > arr[1]`) or `k = 3` (because `arr[0] > arr[3]`).\n\nIn one **operation**, you can choose an index `i` and **change** `arr[i]` into **any** positive integer.\n\nReturn _the **minimum number of operations** required to make the array K-increasing for the given_ `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[5,4,3,2,1\\], k = 1\n**Output:** 4\n**Explanation:**\nFor k = 1, the resultant array has to be non-decreasing.\nSome of the K-increasing arrays that can be formed are \\[5,**6**,**7**,**8**,**9**\\], \\[**1**,**1**,**1**,**1**,1\\], \\[**2**,**2**,3,**4**,**4**\\]. All of them require 4 operations.\nIt is suboptimal to change the array to, for example, \\[**6**,**7**,**8**,**9**,**10**\\] because it would take 5 operations.\nIt can be shown that we cannot make the array K-increasing in less than 4 operations.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[4,1,5,2,6,2\\], k = 2\n**Output:** 0\n**Explanation:**\nThis is the same example as the one in the problem description.\nHere, for every index i where 2 <= i <= 5, arr\\[i-2\\] <= arr\\[i\\].\nSince the given array is already K-increasing, we do not need to perform any operations.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[4,1,5,2,6,2\\], k = 3\n**Output:** 2\n**Explanation:**\nIndices 3 and 5 are the only ones not satisfying arr\\[i-3\\] <= arr\\[i\\] for 3 <= i <= 5.\nOne of the ways we can make the array K-increasing is by changing arr\\[3\\] to 4 and arr\\[5\\] to 5.\nThe array will now be \\[4,1,5,**4**,6,**5**\\].\nNote that there can be other ways to make the array K-increasing, but none of them require less than 2 operations."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i], k <= arr.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search"
        ],
        "example": [
            {
                "input": "[5,4,3,2,1],1",
                "output": "4"
            },
            {
                "input": "[4,1,5,2,6,2],2",
                "output": "0"
            },
            {
                "input": "[4,1,5,2,6,2],3",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] arr, int k) {\n    int[] dp = new int[arr.length];\n    for (int i = k; i < arr.length; i++) {\n        dp[i] = Math.max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0);\n    }\n    return Arrays.stream(dp).sum();\n}\n```\n\n    \n    First, initialize an array called `dp` with the same length as `arr`. This array will store the minimum number of operations needed for every element `arr[i]` to satisfy the K-increasing requirement.\n\nIterate from `k` to `n-1` (inclusive) through the array. In each step, update the `dp[i]` with the minimum number of operations needed to change `arr[i]` to be K-increasing. Calculate this as the maximum between (`dp[i - k]` plus `1`, minus the difference between `arr[i]` and `arr[i - k]`) and `0`. Using the maximum function ensures that we don't end up with negative values for the number of operations.\n\nFinally, return the sum of all the values in the `dp` array. This will provide the minimum number of operations required to make the entire array K-increasing.\n    ",
        "python": "\n    ```python\ndef minOperations(arr, k):\n    dp = [0] * len(arr)\n    for i in range(k, len(arr)):\n        dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0)\n    return sum(dp)\n```\n\n    \n    First, initialize an array called `dp` with the same length as `arr`. This array will store the minimum number of operations needed for every element `arr[i]` to satisfy the K-increasing requirement.\n\nIterate from `k` to `n-1` (inclusive) through the array. In each step, update the `dp[i]` with the minimum number of operations needed to change `arr[i]` to be K-increasing. Calculate this as the maximum between (`dp[i - k]` plus `1`, minus the difference between `arr[i]` and `arr[i - k]`) and `0`. Using the maximum function ensures that we don't end up with negative values for the number of operations.\n\nFinally, return the sum of all the values in the `dp` array. This will provide the minimum number of operations required to make the entire array K-increasing.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& arr, int k) {\n    vector<int> dp(arr.size(), 0);\n    for (int i = k; i < arr.size(); i++) {\n        dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0);\n    }\n    return accumulate(dp.begin(), dp.end(), 0);\n}\n```\n\n    \n    First, initialize an array called `dp` with the same length as `arr`. This array will store the minimum number of operations needed for every element `arr[i]` to satisfy the K-increasing requirement.\n\nIterate from `k` to `n-1` (inclusive) through the array. In each step, update the `dp[i]` with the minimum number of operations needed to change `arr[i]` to be K-increasing. Calculate this as the maximum between (`dp[i - k]` plus `1`, minus the difference between `arr[i]` and `arr[i - k]`) and `0`. Using the maximum function ensures that we don't end up with negative values for the number of operations.\n\nFinally, return the sum of all the values in the `dp` array. This will provide the minimum number of operations required to make the entire array K-increasing.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(arr, k) {\n    const dp = new Array(arr.length).fill(0);\n    for (let i = k; i < arr.length; i++) {\n        dp[i] = Math.max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0);\n    }\n    return dp.reduce((a, b) => a + b, 0);\n}\n```\n\n    \n    First, initialize an array called `dp` with the same length as `arr`. This array will store the minimum number of operations needed for every element `arr[i]` to satisfy the K-increasing requirement.\n\nIterate from `k` to `n-1` (inclusive) through the array. In each step, update the `dp[i]` with the minimum number of operations needed to change `arr[i]` to be K-increasing. Calculate this as the maximum between (`dp[i - k]` plus `1`, minus the difference between `arr[i]` and `arr[i - k]`) and `0`. Using the maximum function ensures that we don't end up with negative values for the number of operations.\n\nFinally, return the sum of all the values in the `dp` array. This will provide the minimum number of operations required to make the entire array K-increasing.\n    "
    },
    {
        "id": 356,
        "title": "Abbreviating the Product of a Range",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two positive integers `left` and `right` with `left <= right`. Calculate the **product** of all integers in the **inclusive** range `[left, right]`.\n\nSince the product may be very large, you will **abbreviate** it following these steps:\n\n1.  Count all **trailing** zeros in the product and **remove** them. Let us denote this count as `C`.\n    *   For example, there are `3` trailing zeros in `1000`, and there are `0` trailing zeros in `546`.\n2.  Denote the remaining number of digits in the product as `d`. If `d > 10`, then express the product as\n    \n        ...\n    \n3.  Finally, represent the product as a **string** `\"`\n    \n        ...eC \"\n    \n\nReturn _a string denoting the **abbreviated product** of all integers in the **inclusive** range_ `[left, right]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 1, right = 4\n**Output:**  \"24e0 \"\n**Explanation:** The product is 1 \\* 2 \\* 3 \\* 4 = 24.\nThere are no trailing zeros, so 24 remains the same. The abbreviation will end with  \"e0 \".\nSince the number of digits is 2, which is less than 10, we do not have to abbreviate it further.\nThus, the final representation is  \"24e0 \".\n\n",
                "**Example 2:**\n\n**Input:** left = 2, right = 11\n**Output:**  \"399168e2 \"\n**Explanation:** The product is 39916800.\nThere are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with  \"e2 \".\nThe number of digits after removing the trailing zeros is 6, so we do not abbreviate it further.\nHence, the abbreviated product is  \"399168e2 \".\n\n",
                "**Example 3:**\n\n**Input:** left = 371, right = 375\n**Output:**  \"7219856259e3 \"\n**Explanation:** The product is 7219856259000."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left <= right <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math"
        ],
        "example": [
            {
                "input": "1,4",
                "output": "\"24e0\""
            },
            {
                "input": "2,11",
                "output": "\"399168e2\""
            },
            {
                "input": "371,375",
                "output": "\"7219856259e3\""
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int[] findOriginalArray(int[] changed) {\n    Map<Integer, Integer> count = new HashMap<>();\n    for (int num : changed)\n        count.put(num, count.getOrDefault(num, 0) + 1);\n\n    List<Integer> sorted_values = new ArrayList<>(count.keySet());\n    Collections.sort(sorted_values);\n\n    List<Integer> original = new ArrayList<>();\n    for (int num : sorted_values) {\n        while (count.get(num) != null && count.get(num) > 0 && count.get(num * 2) != null && count.get(num * 2) > 0) {\n            original.add(num);\n            count.put(num, count.get(num) - 1);\n            count.put(num * 2, count.get(num * 2) - 1);\n        }\n        if (count.get(num) != null && count.get(num) > 0)\n            return new int[0];\n    }\n    return original.stream().mapToInt(Integer::intValue).toArray();\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. Create a `count` map to store the frequency of each number in the `changed` array.\n2. Add all unique keys from the `count` map into an array `sorted_values` and sort it.\n3. Create an empty result `original` array.\n4. Iterate through the sorted_values:\n    - While the current number `num` and its double (`num * 2`) have positive counts in the map:\n        - Add the current `num` to the `original` array.\n        - Decrement the count of `num` and its double.\n    - If the count of `num` is positive after processing its double, return an empty array as it means the given array is not a valid doubled array.\n5. Return the `original` array.\n    ",
        "python": "\n    ```python\ndef findOriginalArray(changed):\n    count = {}\n    for num in changed:\n        count[num] = count.get(num, 0) + 1\n\n    sorted_values = sorted(count.keys())\n\n    original = []\n    for num in sorted_values:\n        while count[num] > 0 and count.get(num * 2, 0) > 0:\n            original.append(num)\n            count[num] -= 1\n            count[num * 2] -= 1\n        if count[num] > 0:\n            return []\n\n    return original\n```\n\n    \n    The algorithm works as follows:\n\n1. Create a `count` map to store the frequency of each number in the `changed` array.\n2. Add all unique keys from the `count` map into an array `sorted_values` and sort it.\n3. Create an empty result `original` array.\n4. Iterate through the sorted_values:\n    - While the current number `num` and its double (`num * 2`) have positive counts in the map:\n        - Add the current `num` to the `original` array.\n        - Decrement the count of `num` and its double.\n    - If the count of `num` is positive after processing its double, return an empty array as it means the given array is not a valid doubled array.\n5. Return the `original` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> findOriginalArray(vector<int>& changed) {\n    unordered_map<int, int> count;\n    for (const int& num : changed)\n        count[num]++;\n\n    vector<int> sorted_values;\n    for (const auto& c : count)\n        sorted_values.push_back(c.first);\n    sort(sorted_values.begin(), sorted_values.end());\n\n    vector<int> original;\n    for (const int& num : sorted_values) {\n        while (count[num] > 0 && count[num * 2] > 0) {\n            original.push_back(num);\n            count[num]--;\n            count[num * 2]--;\n        }\n        if (count[num] > 0)\n            return {};\n    }\n    return original;\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. Create a `count` map to store the frequency of each number in the `changed` array.\n2. Add all unique keys from the `count` map into an array `sorted_values` and sort it.\n3. Create an empty result `original` array.\n4. Iterate through the sorted_values:\n    - While the current number `num` and its double (`num * 2`) have positive counts in the map:\n        - Add the current `num` to the `original` array.\n        - Decrement the count of `num` and its double.\n    - If the count of `num` is positive after processing its double, return an empty array as it means the given array is not a valid doubled array.\n5. Return the `original` array.\n    ",
        "js": "\n    ```javascript\nfunction findOriginalArray(changed) {\n    const count = new Map();\n    for (const num of changed)\n        count.set(num, (count.get(num) || 0) + 1);\n\n    const sorted_values = Array.from(count.keys()).sort((a, b) => a - b);\n\n    const original = [];\n    for (const num of sorted_values) {\n        while (count.get(num) > 0 && count.get(num * 2) > 0) {\n            original.push(num);\n            count.set(num, count.get(num) - 1);\n            count.set(num * 2, count.get(num * 2) - 1);\n        }\n        if (count.get(num) > 0)\n            return [];\n    }\n    return original;\n}\n```\n\n    \n    The algorithm works as follows:\n\n1. Create a `count` map to store the frequency of each number in the `changed` array.\n2. Add all unique keys from the `count` map into an array `sorted_values` and sort it.\n3. Create an empty result `original` array.\n4. Iterate through the sorted_values:\n    - While the current number `num` and its double (`num * 2`) have positive counts in the map:\n        - Add the current `num` to the `original` array.\n        - Decrement the count of `num` and its double.\n    - If the count of `num` is positive after processing its double, return an empty array as it means the given array is not a valid doubled array.\n5. Return the `original` array.\n    "
    },
    {
        "id": 357,
        "title": "Maximum Employees to Be Invited to a Meeting",
        "difficulty": "Hard",
        "content": {
            "problem": "A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large **circular** table, capable of seating **any number** of employees.\n\nThe employees are numbered from `0` to `n - 1`. Each employee has a **favorite** person and they will attend the meeting **only if** they can sit next to their favorite person at the table. The favorite person of an employee is **not** themself.\n\nGiven a **0-indexed** integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the **maximum number of employees** that can be invited to the meeting_.",
            "examples": [
                "**Example 1:**\n\n**Input:** favorite = \\[2,2,1,2\\]\n**Output:** 3\n**Explanation:**\nThe above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3. \n\n",
                "**Example 2:**\n\n**Input:** favorite = \\[1,2,0\\]\n**Output:** 3\n**Explanation:** \nEach employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3.\n\n",
                "**Example 3:**\n\n**Input:** favorite = \\[3,0,1,4,1\\]\n**Output:** 4\n**Explanation:**\nThe above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `n == favorite.length`\n*   `2 <= n <= 105`\n*   `0 <= favorite[i] <= n - 1`\n*   `favorite[i] != i`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "[2,2,1,2]",
                "output": "3"
            },
            {
                "input": "[1,2,0]",
                "output": "3"
            },
            {
                "input": "[3,0,1,4,1]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxInvited(int[] favorite) {\n    int[] inDegree = new int[favorite.length];\n    for (int fav : favorite) {\n        inDegree[fav]++;\n    }\n    int result = 0;\n    for (int degree : inDegree) {\n        result += Math.max(degree - 1, 0);\n    }\n    return Math.min(result + 2, favorite.length);\n}\n```\n    \n    The algorithm works by calculating in-degrees, which represent the number of times a person is favored by others. For each person `i`, we add all in-degrees minus one to the result (since a person only needs to be favored by one other person to be included at the table). Finally, we return the minimum of `result + 2` (to account for the first and last person added to the circle) and the total number of people. This ensures we do not invite more people than there are in the input array even if there are enough favorite relationships to do so.\n    ",
        "python": "\n    ```python\ndef max_invited(favorite):\n    in_degree = [0] * len(favorite)\n    for fav in favorite:\n        in_degree[fav] += 1\n    result = 0\n    for degree in in_degree:\n        result += max(degree - 1, 0)\n    return min(result + 2, len(favorite))\n```\n    \n    The algorithm works by calculating in-degrees, which represent the number of times a person is favored by others. For each person `i`, we add all in-degrees minus one to the result (since a person only needs to be favored by one other person to be included at the table). Finally, we return the minimum of `result + 2` (to account for the first and last person added to the circle) and the total number of people. This ensures we do not invite more people than there are in the input array even if there are enough favorite relationships to do so.\n    ",
        "c++": "\n    ```cpp\nint maxInvited(vector<int>& favorite) {\n    vector<int> in_degree(favorite.size(), 0);\n    for (int fav : favorite) {\n        in_degree[fav]++;\n    }\n    int result = 0;\n    for (int degree : in_degree) {\n        result += max(degree - 1, 0);\n    }\n    return min(result + 2, (int)favorite.size());\n}\n```\n    \n    The algorithm works by calculating in-degrees, which represent the number of times a person is favored by others. For each person `i`, we add all in-degrees minus one to the result (since a person only needs to be favored by one other person to be included at the table). Finally, we return the minimum of `result + 2` (to account for the first and last person added to the circle) and the total number of people. This ensures we do not invite more people than there are in the input array even if there are enough favorite relationships to do so.\n    ",
        "js": "\n    ```javascript\nfunction maxInvited(favorite) {\n    let inDegree = new Array(favorite.length).fill(0);\n    for (let fav of favorite) {\n        inDegree[fav]++;\n    }\n    let result = 0;\n    for (let degree of inDegree) {\n        result += Math.max(degree - 1, 0);\n    }\n    return Math.min(result + 2, favorite.length);\n}\n```\n    \n    The algorithm works by calculating in-degrees, which represent the number of times a person is favored by others. For each person `i`, we add all in-degrees minus one to the result (since a person only needs to be favored by one other person to be included at the table). Finally, we return the minimum of `result + 2` (to account for the first and last person added to the circle) and the total number of people. This ensures we do not invite more people than there are in the input array even if there are enough favorite relationships to do so.\n    "
    },
    {
        "id": 358,
        "title": "Stamping the Grid",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` binary matrix `grid` where each cell is either `0` (empty) or `1` (occupied).\n\nYou are then given stamps of size `stampHeight x stampWidth`. We want to fit the stamps such that they follow the given **restrictions** and **requirements**:\n\n1.  Cover all the **empty** cells.\n2.  Do not cover any of the **occupied** cells.\n3.  We can put as **many** stamps as we want.\n4.  Stamps can **overlap** with each other.\n5.  Stamps are not allowed to be **rotated**.\n6.  Stamps must stay completely **inside** the grid.\n\nReturn `true` _if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[1,0,0,0\\],\\[1,0,0,0\\],\\[1,0,0,0\\],\\[1,0,0,0\\]\\], stampHeight = 4, stampWidth = 3\n**Output:** true\n**Explanation:** We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,1,0,0\\],\\[0,0,1,0\\],\\[0,0,0,1\\]\\], stampHeight = 2, stampWidth = 2 \n**Output:** false \n**Explanation:** There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[r].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 2 * 105`\n*   `grid[r][c]` is either `0` or `1`.\n*   `1 <= stampHeight, stampWidth <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Matrix",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]],4,3",
                "output": "true"
            },
            {
                "input": "[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],2,2",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int[][] construct2DArray(int[] original, int m, int n) {\n    if (m * n != original.length) return new int[][]{};\n    int[][] res = new int[m][n];\n    for (int i = 0; i < original.length; ++i) {\n        res[i / n][i % n] = original[i];\n    }\n    return res;\n}\n```\n    \n    1. Check if the dimensions (m * n) match the size of the input array. If not, return an empty 2D array.\n2. Create an m x n 2D array initialized with zeros.\n3. Iterate through the input array elements and assign them to the corresponding row and column of the 2D array using integer division and modulo operations. \n4. Return the constructed 2D array.\n    ",
        "python": "\n    ```python\ndef construct2DArray(original, m, n):\n    if m * n != len(original): return []\n    res = [[0] * n for _ in range(m)]\n    for i in range(len(original)):\n        res[i // n][i % n] = original[i]\n    return res\n```\n    \n    1. Check if the dimensions (m * n) match the size of the input array. If not, return an empty 2D array.\n2. Create an m x n 2D array initialized with zeros.\n3. Iterate through the input array elements and assign them to the corresponding row and column of the 2D array using integer division and modulo operations. \n4. Return the constructed 2D array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {\n    if (m * n != original.size()) return {};\n    vector<vector<int>> res(m, vector<int>(n));\n    for (int i = 0; i < original.size(); ++i) {\n        res[i / n][i % n] = original[i];\n    }\n    return res;\n}\n```\n    \n    1. Check if the dimensions (m * n) match the size of the input array. If not, return an empty 2D array.\n2. Create an m x n 2D array initialized with zeros.\n3. Iterate through the input array elements and assign them to the corresponding row and column of the 2D array using integer division and modulo operations. \n4. Return the constructed 2D array.\n    ",
        "js": "\n    ```javascript\nfunction construct2DArray(original, m, n) {\n    if (m * n !== original.length) return [];\n    const res = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < original.length; ++i) {\n        res[Math.floor(i / n)][i % n] = original[i];\n    }\n    return res;\n}\n```\n    \n    1. Check if the dimensions (m * n) match the size of the input array. If not, return an empty 2D array.\n2. Create an m x n 2D array initialized with zeros.\n3. Iterate through the input array elements and assign them to the corresponding row and column of the 2D array using integer division and modulo operations. \n4. Return the constructed 2D array.\n    "
    },
    {
        "id": 359,
        "title": "Earliest Possible Day of Full Bloom",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two **0-indexed** integer arrays `plantTime` and `growTime`, of length `n` each:\n\n*   `plantTime[i]` is the number of **full days** it takes you to **plant** the `ith` seed. Every day, you can work on planting exactly one seed. You **do not** have to work on planting the same seed on consecutive days, but the planting of a seed is not complete **until** you have worked `plantTime[i]` days on planting it in total.\n*   `growTime[i]` is the number of **full days** it takes the `ith` seed to grow after being completely planted. **After** the last day of its growth, the flower **blooms** and stays bloomed forever.\n\nFrom the beginning of day `0`, you can plant the seeds in **any** order.\n\nReturn _the **earliest** possible day where **all** seeds are blooming_.",
            "examples": [
                "**Example 1:**\n\n**Input:** plantTime = \\[1,4,3\\], growTime = \\[2,3,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n",
                "**Example 2:**\n\n**Input:** plantTime = \\[1,2,3,2\\], growTime = \\[2,1,2,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n",
                "**Example 3:**\n\n**Input:** plantTime = \\[1\\], growTime = \\[1\\]\n**Output:** 2\n**Explanation:** On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming."
            ],
            "constraints": "**Constraints:**\n\n*   `n == plantTime.length == growTime.length`\n*   `1 <= n <= 105`\n*   `1 <= plantTime[i], growTime[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,4,3],[2,3,1]",
                "output": "9"
            },
            {
                "input": "[1,2,3,2],[2,1,2,1]",
                "output": "9"
            },
            {
                "input": "[1],[1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int earliestBlooms(int[] plantTime, int[] growTime) {\n    int n = plantTime.length;\n    int[][] processTime = new int[n][2];\n    for (int i = 0; i < n; ++i) {\n        processTime[i][0] = plantTime[i];\n        processTime[i][1] = growTime[i];\n    }\n    Arrays.sort(processTime, (a, b) -> a[0] - b[0]);\n\n    int day = 0;\n    int blooms = 0;\n    for (int[] p : processTime) {\n        day += p[0];\n        blooms = Math.max(blooms, day + p[1]);\n    }\n    return blooms;\n}\n```\n    \n    1. Create a new list/array, `processTime`, containing pairs/tuples of (plantTime, growTime) for each seed.\n2. Sort `processTime` in ascending order based on plantTime.\n3. Iterate through the sorted `processTime` pairs/tuples. For each pair/tuple, increment the `day` counter by the plantTime, and compare the sum of `day` and growTime with the current `blooms` value. If the sum is greater, update `blooms` with the new value.\n4. Return the final `blooms` value as the earliest day when all seeds have bloomed.\n    ",
        "python": "\n    ```python\ndef earliestBlooms(plantTime, growTime):\n    n = len(plantTime)\n    processTime = list(zip(plantTime, growTime))\n    processTime.sort()\n\n    day = 0\n    blooms = 0\n    for p in processTime:\n        day += p[0]\n        blooms = max(blooms, day + p[1])\n    return blooms\n```\n    \n    1. Create a new list/array, `processTime`, containing pairs/tuples of (plantTime, growTime) for each seed.\n2. Sort `processTime` in ascending order based on plantTime.\n3. Iterate through the sorted `processTime` pairs/tuples. For each pair/tuple, increment the `day` counter by the plantTime, and compare the sum of `day` and growTime with the current `blooms` value. If the sum is greater, update `blooms` with the new value.\n4. Return the final `blooms` value as the earliest day when all seeds have bloomed.\n    ",
        "c++": "\n    ```cpp\nint earliestBlooms(vector<int>& plantTime, vector<int>& growTime) {\n    int n = plantTime.size();\n    vector<pair<int, int>> processTime;\n    for (int i = 0; i < n; ++i) {\n        processTime.push_back({plantTime[i], growTime[i]});\n    }\n    sort(processTime.begin(), processTime.end());\n\n    int day = 0;\n    int blooms = 0;\n    for (auto& p : processTime) {\n        day += p.first;\n        blooms = max(blooms, day + p.second);\n    }\n    return blooms;\n}\n```\n    \n    1. Create a new list/array, `processTime`, containing pairs/tuples of (plantTime, growTime) for each seed.\n2. Sort `processTime` in ascending order based on plantTime.\n3. Iterate through the sorted `processTime` pairs/tuples. For each pair/tuple, increment the `day` counter by the plantTime, and compare the sum of `day` and growTime with the current `blooms` value. If the sum is greater, update `blooms` with the new value.\n4. Return the final `blooms` value as the earliest day when all seeds have bloomed.\n    ",
        "js": "\n    ```javascript\nfunction earliestBlooms(plantTime, growTime) {\n    let n = plantTime.length;\n    let processTime = plantTime.map((val, i) => ([val, growTime[i]]));\n    processTime.sort((a, b) => a[0] - b[0]);\n\n    let day = 0;\n    let blooms = 0;\n    for (let p of processTime) {\n        day += p[0];\n        blooms = Math.max(blooms, day + p[1]);\n    }\n    return blooms;\n}\n```\n    \n    1. Create a new list/array, `processTime`, containing pairs/tuples of (plantTime, growTime) for each seed.\n2. Sort `processTime` in ascending order based on plantTime.\n3. Iterate through the sorted `processTime` pairs/tuples. For each pair/tuple, increment the `day` counter by the plantTime, and compare the sum of `day` and growTime with the current `blooms` value. If the sum is greater, update `blooms` with the new value.\n4. Return the final `blooms` value as the earliest day when all seeds have bloomed.\n    "
    },
    {
        "id": 360,
        "title": "Maximum Running Time of N Computers",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "2,[3,3,3]",
                "output": "4"
            },
            {
                "input": "2,[1,1,1,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int max_computer_runtime(int n, int[] batteries) {\n    Arrays.sort(batteries);\n    int result = 0;\n    for (int i = 0; i < batteries.length; i++) {\n        result = Math.max(result, Math.min(n, batteries.length - i) * batteries[i]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    ",
        "python": "\n    ```python\ndef max_computer_runtime(n, batteries):\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    ",
        "c++": "\n    ```cpp\nint max_computer_runtime(int n, vector<int>& batteries) {\n    sort(batteries.begin(), batteries.end());\n    int result = 0;\n    for (int i = 0; i < batteries.size(); ++i) {\n        result = max(result, min(n, int(batteries.size()) - i) * batteries[i]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    ",
        "js": "\n    ```javascript\nfunction max_computer_runtime(n, batteries) {\n    batteries.sort((a, b) => a - b);\n    let result = 0;\n    for (let i = 0; i < batteries.length; i++) {\n        result = Math.max(result, Math.min(n, batteries.length - i) * batteries[i]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm sorts the input `batteries` in ascending order. Then, it iterates through the sorted batteries and calculates the maximum possible runtime for every possible combination of batteries, by taking into account that each computer can have at most one battery at a time. The maximum runtime is calculated as the minimum of `n` (number of computers) and the remaining batteries count, multiplied by the battery's runtime. Finally, the algorithm returns the maximum obtained runtime from all the possible combinations.\n    "
    },
    {
        "id": 361,
        "title": "Number of Ways to Divide a Long Corridor",
        "difficulty": "Hard",
        "content": {
            "problem": "Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.\n\nOne room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way.\n\nReturn _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** corridor =  \"SSPPSPS \"\n**Output:** 3\n**Explanation:** There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, **each** section has exactly **two** seats.\n\n",
                "**Example 2:**\n\n**Input:** corridor =  \"PPSPSP \"\n**Output:** 1\n**Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n",
                "**Example 3:**\n\n**Input:** corridor =  \"S \"\n**Output:** 0\n**Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats."
            ],
            "constraints": "**Constraints:**\n\n*   `n == corridor.length`\n*   `1 <= n <= 105`\n*   `corridor[i]` is either `'S'` or `'P'`.",
            "follow_up": null
        },
        "tag": [
            "Math",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"SSPPSPS\"",
                "output": "3"
            },
            {
                "input": "\"PPSPSP\"",
                "output": "1"
            },
            {
                "input": "\"S\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int sumOfPoints(String s, int[] answers) {\n    int total_points = 0;\n    int result = 0, term = 1;\n    char sign = '+';\n\n    for (int i = 0; i < s.length(); i++) {\n        if (Character.isDigit(s.charAt(i))) {\n            int number = s.charAt(i) - '0';\n            if (sign == '+') {\n                result += term;\n                term = number;\n            } else if (sign == '*') {\n                term *= number;\n            }\n        } else {\n            sign = s.charAt(i);\n        }\n    }\n    result += term;\n\n    for (int ans : answers) {\n        total_points += (ans == result) ? 1 : 0;\n    }\n\n    return total_points;\n}\n```\n\n    \n    1. Initialize `total_points` variable to hold the sum of points, and `result` variable to store the calculated result of the expression. `term` variable to store the current term in expression and character `sign`.\n2. Loop through the string `s`. Check whether the character is a digit or not.\n3. If the character is a digit, perform the operation depending on the `sign` variable. If `sign` is '+', add the `term` to the `result`, and update the `term`. If `sign` is '*', multiply the `term` by the number.\n4. If the character is not a digit, update the `sign` variable.\n5. At the end of the loop, add the remaining `term` to the `result`.\n6. Now, iterate through the `answers` array and increment `total_points` if the answer is equal to the calculated `result`.\n7. Finally, return the `total_points` which represents the sum of the points of the students.\n    ",
        "python": "\n    ```python\ndef sum_of_points(s, answers):\n    total_points = 0\n    result = 0\n    term = 1\n    sign = \"+\"\n\n    for char in s:\n        if char.isdigit():\n            number = int(char)\n            if sign == \"+\":\n                result += term\n                term = number\n            elif sign == \"*\":\n                term *= number\n        else:\n            sign = char\n\n    result += term\n\n    for ans in answers:\n        total_points += (ans == result)\n\n    return total_points\n```\n\n    \n    1. Initialize `total_points` variable to hold the sum of points, and `result` variable to store the calculated result of the expression. `term` variable to store the current term in expression and character `sign`.\n2. Loop through the string `s`. Check whether the character is a digit or not.\n3. If the character is a digit, perform the operation depending on the `sign` variable. If `sign` is '+', add the `term` to the `result`, and update the `term`. If `sign` is '*', multiply the `term` by the number.\n4. If the character is not a digit, update the `sign` variable.\n5. At the end of the loop, add the remaining `term` to the `result`.\n6. Now, iterate through the `answers` array and increment `total_points` if the answer is equal to the calculated `result`.\n7. Finally, return the `total_points` which represents the sum of the points of the students.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint sumOfPoints(const std::string &s, const std::vector<int> &answers) {\n    int total_points = 0;\n    int result = 0, term = 1;\n    char sign = '+';\n    \n    for (size_t i = 0; i < s.size(); i++) {\n        if (isdigit(s[i])) {\n            int number = s[i] - '0';\n            if (sign == '+') {\n                result += term;\n                term = number;\n            } else if (sign == '*') {\n                term *= number;\n            }\n        } else {\n            sign = s[i];\n        }\n    }\n    result += term;\n\n    for (int ans : answers) {\n        total_points += (ans == result);\n    }\n\n    return total_points;\n}\n```\n\n    \n    1. Initialize `total_points` variable to hold the sum of points, and `result` variable to store the calculated result of the expression. `term` variable to store the current term in expression and character `sign`.\n2. Loop through the string `s`. Check whether the character is a digit or not.\n3. If the character is a digit, perform the operation depending on the `sign` variable. If `sign` is '+', add the `term` to the `result`, and update the `term`. If `sign` is '*', multiply the `term` by the number.\n4. If the character is not a digit, update the `sign` variable.\n5. At the end of the loop, add the remaining `term` to the `result`.\n6. Now, iterate through the `answers` array and increment `total_points` if the answer is equal to the calculated `result`.\n7. Finally, return the `total_points` which represents the sum of the points of the students.\n    ",
        "js": "\n    ```javascript\nfunction sumOfPoints(s, answers) {\n    let total_points = 0;\n    let result = 0, term = 1;\n    let sign = '+';\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i].charCodeAt(0) >= '0'.charCodeAt(0) && s[i].charCodeAt(0) <= '9'.charCodeAt(0)) {\n            let number = s[i].charCodeAt(0) - '0'.charCodeAt(0);\n            if (sign === '+') {\n                result += term;\n                term = number;\n            } else if (sign === '*') {\n                term *= number;\n            }\n        } else {\n           sign = s[i];\n        }\n    }\n\n    result += term;\n\n    for (let ans of answers) {\n        total_points += (ans === result) ? 1 : 0;\n    }\n\n    return total_points;\n}\n```\n\n    \n    1. Initialize `total_points` variable to hold the sum of points, and `result` variable to store the calculated result of the expression. `term` variable to store the current term in expression and character `sign`.\n2. Loop through the string `s`. Check whether the character is a digit or not.\n3. If the character is a digit, perform the operation depending on the `sign` variable. If `sign` is '+', add the `term` to the `result`, and update the `term`. If `sign` is '*', multiply the `term` by the number.\n4. If the character is not a digit, update the `sign` variable.\n5. At the end of the loop, add the remaining `term` to the `result`.\n6. Now, iterate through the `answers` array and increment `total_points` if the answer is equal to the calculated `result`.\n7. Finally, return the `total_points` which represents the sum of the points of the students.\n    "
    },
    {
        "id": 362,
        "title": "Maximum Good People Based on Statements",
        "difficulty": "Hard",
        "content": {
            "problem": "There are two types of persons:\n\n*   The **good person**: The person who always tells the truth.\n*   The **bad person**: The person who might tell the truth and might lie.\n\nYou are given a **0-indexed** 2D integer array `statements` of size `n x n` that represents the statements made by `n` people about each other. More specifically, `statements[i][j]` could be one of the following:\n\n*   `0` which represents a statement made by person `i` that person `j` is a **bad** person.\n*   `1` which represents a statement made by person `i` that person `j` is a **good** person.\n*   `2` represents that **no statement** is made by person `i` about person `j`.\n\nAdditionally, no person ever makes a statement about themselves. Formally, we have that `statements[i][i] = 2` for all `0 <= i < n`.\n\nReturn _the **maximum** number of people who can be **good** based on the statements made by the_ `n` _people_.",
            "examples": [
                "**Example 1:**\n\n**Input:** statements = \\[\\[2,1,2\\],\\[1,2,2\\],\\[2,0,2\\]\\]\n**Output:** 2\n**Explanation:** Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet's take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - **Following that person 2 is a good person, there will be only one good person in the group**.\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - **Following that person 2 is bad but told the truth, there will be no good persons in the group**.\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - **Following that person 2 is bad and lied, there will be two good persons in the group**.\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion.\n\n",
                "**Example 2:**\n\n**Input:** statements = \\[\\[2,0\\],\\[0,2\\]\\]\n**Output:** 1\n**Explanation:** Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet's take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - **Following that person 0 is a good person, there will be only one good person in the group**.\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - **Following that person 0 is bad but told the truth, there will be no good persons in the group**.\n        - lying. In this case person 1 is a good person.\n            - **Following that person 0 is bad and lied, there will be only one good person in the group**.\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion."
            ],
            "constraints": "**Constraints:**\n\n*   `n == statements.length == statements[i].length`\n*   `2 <= n <= 15`\n*   `statements[i][j]` is either `0`, `1`, or `2`.\n*   `statements[i][i] == 2`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Backtracking",
            "Bit Manipulation",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[[2,1,2],[1,2,2],[2,0,2]]",
                "output": "2"
            },
            {
                "input": "[[2,0],[0,2]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\n        int n = patience.length;\n        List<List<Integer>> graph = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n        dist[0] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        \n        while (!q.isEmpty()) {\n            int node = q.poll();\n            \n            for (int neighbor : graph.get(node)) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    q.add(neighbor);\n                }\n            }\n        }\n\n        int max_time = 0;\n        for (int i = 1; i < n; i++) {\n            int time = ((2 * dist[i] - 1) / patience[i]) * patience[i] + 2 * dist[i];\n            max_time = Math.max(max_time, time);\n        }\n        \n        return max_time + 1;\n    }\n}\n```\n    \n    1. Build a graph with the given edges.\n2. Use BFS to calculate the shortest distance from server 0 to each other server.\n3. For each data server, calculate the time it takes for the messages to be sent and replied (use patience to compute the message waiting time).\n4. Find the maximum time among all data servers.\n5. Return the maximum time + 1 as the earliest second the network becomes idle.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef network_becomes_idle(edges, patience):\n    n = len(patience)\n    graph = defaultdict(list)\n    \n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    dist = [-1] * n\n    dist[0] = 0\n    q = deque([0])\n    \n    while q:\n        node = q.popleft()\n        \n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n\n    max_time = 0\n    for i in range(1, n):\n        time = ((2 * dist[i] - 1) // patience[i]) * patience[i] + 2 * dist[i]\n        max_time = max(max_time, time)\n    \n    return max_time + 1\n```\n    \n    1. Build a graph with the given edges.\n2. Use BFS to calculate the shortest distance from server 0 to each other server.\n3. For each data server, calculate the time it takes for the messages to be sent and replied (use patience to compute the message waiting time).\n4. Find the maximum time among all data servers.\n5. Return the maximum time + 1 as the earliest second the network becomes idle.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\n    int n = patience.size();\n    vector<vector<int>> graph(n);\n    \n    for (auto& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> dist(n, -1);\n    dist[0] = 0;\n    queue<int> q;\n    q.push(0);\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : graph[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    int max_time = 0;\n    for (int i = 1; i < n; i++) {\n        int time = ((2 * dist[i] - 1) / patience[i]) * patience[i] + 2 * dist[i];\n        max_time = max(max_time, time);\n    }\n    \n    return max_time + 1;\n}\n```\n    \n    1. Build a graph with the given edges.\n2. Use BFS to calculate the shortest distance from server 0 to each other server.\n3. For each data server, calculate the time it takes for the messages to be sent and replied (use patience to compute the message waiting time).\n4. Find the maximum time among all data servers.\n5. Return the maximum time + 1 as the earliest second the network becomes idle.\n    ",
        "js": "\n    ```javascript\nfunction networkBecomesIdle(edges, patience) {\n    const n = patience.length;\n    const graph = new Array(n).fill(null).map(() => []);\n\n    for (const edge of edges) {\n        graph[edge[0]].push(edge[1]);\n        graph[edge[1]].push(edge[0]);\n    }\n\n    const dist = new Array(n).fill(-1);\n    dist[0] = 0;\n    const q = [0];\n\n    while (q.length > 0) {\n        const node = q.shift();\n\n        for (const neighbor of graph[node]) {\n            if (dist[neighbor] === -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    let max_time = 0;\n    for (let i = 1; i < n; i++) {\n        const time = Math.floor((2 * dist[i] - 1) / patience[i]) * patience[i] + 2 * dist[i];\n        max_time = Math.max(max_time, time);\n    }\n\n    return max_time + 1;\n}\n```\n    \n    1. Build a graph with the given edges.\n2. Use BFS to calculate the shortest distance from server 0 to each other server.\n3. For each data server, calculate the time it takes for the messages to be sent and replied (use patience to compute the message waiting time).\n4. Find the maximum time among all data servers.\n5. Return the maximum time + 1 as the earliest second the network becomes idle.\n    "
    },
    {
        "id": 363,
        "title": "Find Substring With Given Hash Value",
        "difficulty": "Hard",
        "content": {
            "problem": "The hash of a **0-indexed** string `s` of length `k`, given integers `p` and `m`, is computed using the following function:\n\n*   `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`.\n\nWhere `val(s[i])` represents the index of `s[i]` in the alphabet from `val('a') = 1` to `val('z') = 26`.\n\nYou are given a string `s` and the integers `power`, `modulo`, `k`, and `hashValue.` Return `sub`, _the **first** **substring** of_ `s` _of length_ `k` _such that_ `hash(sub, power, modulo) == hashValue`.\n\nThe test cases will be generated such that an answer always **exists**.\n\nA **substring** is a contiguous non-empty sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leetcode \", power = 7, modulo = 20, k = 2, hashValue = 0\n**Output:**  \"ee \"\n**Explanation:** The hash of  \"ee \" can be computed to be hash( \"ee \", 7, 20) = (5 \\* 1 + 5 \\* 7) mod 20 = 40 mod 20 = 0. \n \"ee \" is the first substring of length 2 with hashValue 0. Hence, we return  \"ee \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"fbxzaad \", power = 31, modulo = 100, k = 3, hashValue = 32\n**Output:**  \"fbx \"\n**Explanation:** The hash of  \"fbx \" can be computed to be hash( \"fbx \", 31, 100) = (6 \\* 1 + 2 \\* 31 + 24 \\* 312) mod 100 = 23132 mod 100 = 32. \nThe hash of  \"bxz \" can be computed to be hash( \"bxz \", 31, 100) = (2 \\* 1 + 24 \\* 31 + 26 \\* 312) mod 100 = 25732 mod 100 = 32. \n \"fbx \" is the first substring of length 3 with hashValue 32. Hence, we return  \"fbx \".\nNote that  \"bxz \" also has a hash of 32 but it appears later than  \"fbx \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= s.length <= 2 * 104`\n*   `1 <= power, modulo <= 109`\n*   `0 <= hashValue < modulo`\n*   `s` consists of lowercase English letters only.\n*   The test cases are generated such that an answer always **exists**.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Sliding Window",
            "Rolling Hash",
            "Hash Function"
        ],
        "example": [
            {
                "input": "\"leetcode\",7,20,2,0",
                "output": "\"ee\""
            },
            {
                "input": "\"fbxzaad\",31,100,3,32",
                "output": "\"fbx\""
            }
        ],
        "java": "\n    ```java\npublic boolean aliceWins(int[] stones) {\n    int sum = 0, count[] = new int[3];\n    for (int stone : stones) {\n        sum += stone;\n        count[stone % 3]++;\n    }\n    if (sum % 3 != 0) {\n        return count[sum % 3] % 2 == 1;\n    }\n    return count[1] % 2 == 0 || count[2] % 2 == 0 || count[1] == 0 || count[2] == 0;\n}\n```\n    \n    1. Calculate the sum of values of all stones and counts of stones with values 1, 2 modulo 3.\n2. If the sum is not divisible by 3, Alice will try to maintain it. In this case, Alice wins if the count of stones with the sum modulo 3 is odd.\n3. If the sum is divisible by 3, Alice will try to prevent it from being divisible by 3. In this case, Alice wins if there are an even number of 1s and 2s modulo 3.\n    ",
        "python": "\n    ```python\ndef alice_wins(stones):\n    sum_, count = 0, [0] * 3\n    for stone in stones:\n        sum_ += stone\n        count[stone % 3] += 1\n    if sum_ % 3:\n        return count[sum_ % 3] % 2 == 1\n    return count[1] % 2 == 0 or count[2] % 2 == 0 or count[1] == 0 or count[2] == 0\n```\n    \n    1. Calculate the sum of values of all stones and counts of stones with values 1, 2 modulo 3.\n2. If the sum is not divisible by 3, Alice will try to maintain it. In this case, Alice wins if the count of stones with the sum modulo 3 is odd.\n3. If the sum is divisible by 3, Alice will try to prevent it from being divisible by 3. In this case, Alice wins if there are an even number of 1s and 2s modulo 3.\n    ",
        "c++": "\n    ```cpp\nbool aliceWins(std::vector<int> &stones) {\n    int sum = 0, count[3] = {0};\n    for (int stone : stones) {\n        sum += stone;\n        count[stone % 3]++;\n    }\n    if (sum % 3) {\n        return count[sum % 3] % 2 == 1;\n    }\n    return count[1] % 2 == 0 || count[2] % 2 == 0 || count[1] == 0 || count[2] == 0;\n}\n```\n    \n    1. Calculate the sum of values of all stones and counts of stones with values 1, 2 modulo 3.\n2. If the sum is not divisible by 3, Alice will try to maintain it. In this case, Alice wins if the count of stones with the sum modulo 3 is odd.\n3. If the sum is divisible by 3, Alice will try to prevent it from being divisible by 3. In this case, Alice wins if there are an even number of 1s and 2s modulo 3.\n    ",
        "js": "\n    ```javascript\nfunction aliceWins(stones) {\n    let sum = 0, count = [0, 0, 0];\n    for (let stone of stones) {\n        sum += stone;\n        count[stone % 3]++;\n    }\n    if (sum % 3 !== 0) {\n        return count[sum % 3] % 2 === 1;\n    }\n    return count[1] % 2 === 0 || count[2] % 2 === 0 || count[1] === 0 || count[2] === 0;\n}\n```\n    \n    1. Calculate the sum of values of all stones and counts of stones with values 1, 2 modulo 3.\n2. If the sum is not divisible by 3, Alice will try to maintain it. In this case, Alice wins if the count of stones with the sum modulo 3 is odd.\n3. If the sum is divisible by 3, Alice will try to prevent it from being divisible by 3. In this case, Alice wins if there are an even number of 1s and 2s modulo 3.\n    "
    },
    {
        "id": 364,
        "title": "Groups of Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** array of strings `words`. Each string consists of **lowercase English letters** only. No letter occurs more than once in any string of `words`.\n\nTwo strings `s1` and `s2` are said to be **connected** if the set of letters of `s2` can be obtained from the set of letters of `s1` by any **one** of the following operations:\n\n*   Adding exactly one letter to the set of the letters of `s1`.\n*   Deleting exactly one letter from the set of the letters of `s1`.\n*   Replacing exactly one letter from the set of the letters of `s1` with any letter, **including** itself.\n\nThe array `words` can be divided into one or more non-intersecting **groups**. A string belongs to a group if any **one** of the following is true:\n\n*   It is connected to **at least one** other string of the group.\n*   It is the **only** string present in the group.\n\nNote that the strings in `words` should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\n\nReturn _an array_ `ans` _of size_ `2` _where:_\n\n*   `ans[0]` _is the **maximum number** of groups_ `words` _can be divided into, and_\n*   `ans[1]` _is the **size of the largest** group_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"a \", \"b \", \"ab \", \"cde \"\\]\n**Output:** \\[2,3\\]\n**Explanation:**\n- words\\[0\\] can be used to obtain words\\[1\\] (by replacing 'a' with 'b'), and words\\[2\\] (by adding 'b'). So words\\[0\\] is connected to words\\[1\\] and words\\[2\\].\n- words\\[1\\] can be used to obtain words\\[0\\] (by replacing 'b' with 'a'), and words\\[2\\] (by adding 'a'). So words\\[1\\] is connected to words\\[0\\] and words\\[2\\].\n- words\\[2\\] can be used to obtain words\\[0\\] (by deleting 'b'), and words\\[1\\] (by deleting 'a'). So words\\[2\\] is connected to words\\[0\\] and words\\[1\\].\n- words\\[3\\] is not connected to any string in words.\nThus, words can be divided into 2 groups \\[ \"a \", \"b \", \"ab \"\\] and \\[ \"cde \"\\]. The size of the largest group is 3.  \n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"ab \", \"abc \"\\]\n**Output:** \\[1,3\\]\n**Explanation:**\n- words\\[0\\] is connected to words\\[1\\].\n- words\\[1\\] is connected to words\\[0\\] and words\\[2\\].\n- words\\[2\\] is connected to words\\[1\\].\nSince all strings are connected to each other, they should be grouped together.\nThus, the size of the largest group is 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 2 * 104`\n*   `1 <= words[i].length <= 26`\n*   `words[i]` consists of lowercase English letters only.\n*   No letter occurs more than once in `words[i]`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Bit Manipulation",
            "Union Find"
        ],
        "example": [
            {
                "input": "[\"a\",\"b\",\"ab\",\"cde\"]",
                "output": "[2,3]"
            },
            {
                "input": "[\"a\",\"ab\",\"abc\"]",
                "output": "[1,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic String smallestSubsequence(String s, int k, char letter, int repetition) {\n    StringBuilder result = new StringBuilder();\n    int letterCount = 0, n = s.length();\n    for (char c : s.toCharArray()) if (c == letter) letterCount++;\n\n    PriorityQueue<Character> pq = new PriorityQueue<>();\n    for (int i = 0; i < n; i++) {\n        if (s.charAt(i) <= letter || letterCount > repetition) {\n            while (!pq.isEmpty() && pq.peek() > s.charAt(i)) {\n                if (pq.poll() == letter) letterCount--;\n            }\n            pq.add(s.charAt(i));\n            if (pq.size() > k) pq.poll();\n        }\n        if (k - pq.size() == repetition) letterCount--;\n        repetition = Math.max(0, repetition);\n    }\n\n    while (!pq.isEmpty()) {\n        result.append(pq.poll());\n    }\n    return result.toString();\n}\n```\n    \n    1. Initialize a priority queue (min-heap in Python and JS) `pq`, a result string (a StringBuilder in Java), and count the number of occurrences of the letter in the string s.\n2. Iterate through the string s with index i:\n   a. If the current character `s[i]` is smaller than or equal to the letter, or the letter count is greater than the repetition, enter the loop.\n   b. While `pq` is not empty and the top element is greater than the current character `s[i]`, pop the top element. (In JS, pop the first element of sorted pq). Decrease the letter count if a popped element equals the given letter.\n   c. Push `s[i]` to `pq` and sort the pq in JavaScript.\n   d. If the size of `pq` is larger than k, pop the top element.\n   e. If the difference between k and pq's size equals the repetition, decrement letter count (letter count should not be less than desired repetitions).\n   f. Update repetition by taking the maximum of 0 and the current repetition.\n3. Append elements from the priority queue to the result string (in reverse order in C++).\n4. Return the result string.\n\nThis algorithm ensures that lex order is maintained using a priority queue that stores elements in ascending order, and the desired repetition is achieved by keeping track of the letter count while traversing the string s.\n    ",
        "python": "\n    ```python\nfrom heapq import heappop, heappush\n\ndef smallest_subsequence(s, k, letter, repetition):\n    result = []\n    letter_count = s.count(letter)\n\n    pq = []\n    for c in s:\n        if c <= letter or letter_count > repetition:\n            while pq and pq[0] > c:\n                if heappop(pq) == letter:\n                    letter_count -= 1\n            heappush(pq, c)\n            if len(pq) > k:\n                heappop(pq)\n        if k - len(pq) == repetition:\n            letter_count -= 1\n        repetition = max(0, repetition)\n\n    return \"\".join(pq)\n```\n    \n    1. Initialize a priority queue (min-heap in Python and JS) `pq`, a result string (a StringBuilder in Java), and count the number of occurrences of the letter in the string s.\n2. Iterate through the string s with index i:\n   a. If the current character `s[i]` is smaller than or equal to the letter, or the letter count is greater than the repetition, enter the loop.\n   b. While `pq` is not empty and the top element is greater than the current character `s[i]`, pop the top element. (In JS, pop the first element of sorted pq). Decrease the letter count if a popped element equals the given letter.\n   c. Push `s[i]` to `pq` and sort the pq in JavaScript.\n   d. If the size of `pq` is larger than k, pop the top element.\n   e. If the difference between k and pq's size equals the repetition, decrement letter count (letter count should not be less than desired repetitions).\n   f. Update repetition by taking the maximum of 0 and the current repetition.\n3. Append elements from the priority queue to the result string (in reverse order in C++).\n4. Return the result string.\n\nThis algorithm ensures that lex order is maintained using a priority queue that stores elements in ascending order, and the desired repetition is achieved by keeping track of the letter count while traversing the string s.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <queue>\n\nstd::string smallestSubsequence(std::string s, int k, char letter, int repetition) {\n    std::string result;\n    int letter_count = 0, n = s.length();\n    for (char c : s) if (c == letter) letter_count++;\n\n    std::priority_queue<char, std::vector<char>, std::greater<char>> pq;\n    for (int i = 0; i < n; i++) {\n        if (s[i] <= letter || letter_count > repetition) {\n            while (!pq.empty() && pq.top() > s[i]) {\n                if (pq.top() == letter) letter_count--;\n                pq.pop();\n            }\n            pq.push(s[i]);\n            if (pq.size() > k) pq.pop();\n        }\n        if (k - pq.size() == repetition) letter_count--;\n        repetition = std::max(0, repetition);\n    }\n\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\n```\n    \n    1. Initialize a priority queue (min-heap in Python and JS) `pq`, a result string (a StringBuilder in Java), and count the number of occurrences of the letter in the string s.\n2. Iterate through the string s with index i:\n   a. If the current character `s[i]` is smaller than or equal to the letter, or the letter count is greater than the repetition, enter the loop.\n   b. While `pq` is not empty and the top element is greater than the current character `s[i]`, pop the top element. (In JS, pop the first element of sorted pq). Decrease the letter count if a popped element equals the given letter.\n   c. Push `s[i]` to `pq` and sort the pq in JavaScript.\n   d. If the size of `pq` is larger than k, pop the top element.\n   e. If the difference between k and pq's size equals the repetition, decrement letter count (letter count should not be less than desired repetitions).\n   f. Update repetition by taking the maximum of 0 and the current repetition.\n3. Append elements from the priority queue to the result string (in reverse order in C++).\n4. Return the result string.\n\nThis algorithm ensures that lex order is maintained using a priority queue that stores elements in ascending order, and the desired repetition is achieved by keeping track of the letter count while traversing the string s.\n    ",
        "js": "\n    ```javascript\nfunction smallestSubsequence(s, k, letter, repetition) {\n    let result = \"\";\n    let letterCount = 0, n = s.length;\n    for (let c of s) if (c === letter) letterCount++;\n\n    let pq = [];\n    for (let i = 0; i < n; i++) {\n        if (s[i] <= letter || letterCount > repetition) {\n            while (pq.length > 0 && pq[0] > s[i]) {\n                if (pq.shift() === letter) letterCount--;\n            }\n            pq.push(s[i]);\n            pq.sort();\n            if (pq.length > k) pq.shift();\n        }\n        if (k - pq.length === repetition) letterCount--;\n        repetition = Math.max(0, repetition);\n    }\n\n    return pq.join(\"\");\n}\n```\n    \n    1. Initialize a priority queue (min-heap in Python and JS) `pq`, a result string (a StringBuilder in Java), and count the number of occurrences of the letter in the string s.\n2. Iterate through the string s with index i:\n   a. If the current character `s[i]` is smaller than or equal to the letter, or the letter count is greater than the repetition, enter the loop.\n   b. While `pq` is not empty and the top element is greater than the current character `s[i]`, pop the top element. (In JS, pop the first element of sorted pq). Decrease the letter count if a popped element equals the given letter.\n   c. Push `s[i]` to `pq` and sort the pq in JavaScript.\n   d. If the size of `pq` is larger than k, pop the top element.\n   e. If the difference between k and pq's size equals the repetition, decrement letter count (letter count should not be less than desired repetitions).\n   f. Update repetition by taking the maximum of 0 and the current repetition.\n3. Append elements from the priority queue to the result string (in reverse order in C++).\n4. Return the result string.\n\nThis algorithm ensures that lex order is maintained using a priority queue that stores elements in ascending order, and the desired repetition is achieved by keeping track of the letter count while traversing the string s.\n    "
    },
    {
        "id": 365,
        "title": "Minimum Difference in Sums After Removal of Elements",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` consisting of `3 * n` elements.\n\nYou are allowed to remove any **subsequence** of elements of size **exactly** `n` from `nums`. The remaining `2 * n` elements will be divided into two **equal** parts:\n\n*   The first `n` elements belonging to the first part and their sum is `sumfirst`.\n*   The next `n` elements belonging to the second part and their sum is `sumsecond`.\n\nThe **difference in sums** of the two parts is denoted as `sumfirst - sumsecond`.\n\n*   For example, if `sumfirst = 3` and `sumsecond = 2`, their difference is `1`.\n*   Similarly, if `sumfirst = 2` and `sumsecond = 3`, their difference is `-1`.\n\nReturn _the **minimum difference** possible between the sums of the two parts after the removal of_ `n` _elements_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,2\\]\n**Output:** -1\n**Explanation:** Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums\\[0\\] = 3, the array will be \\[1,2\\]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums\\[1\\] = 1, the array will be \\[3,2\\]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums\\[2\\] = 2, the array will be \\[3,1\\]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1. \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,9,5,8,1,3\\]\n**Output:** 1\n**Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums\\[2\\] = 5 and nums\\[3\\] = 8, the resultant array will be \\[7,9,1,3\\]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums\\[1\\] = 9 and nums\\[4\\] = 1. The resultant array becomes \\[7,5,8,3\\]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1."
            ],
            "constraints": "**Constraints:**\n\n*   `nums.length == 3 * n`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[3,1,2]",
                "output": "-1"
            },
            {
                "input": "[7,9,5,8,1,3]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic String kthDistinctString(String[] arr, int k) {\n    Map<String, Integer> frequency = new HashMap<>();\n    for (String s : arr) {\n        frequency.put(s, frequency.getOrDefault(s, 0) + 1);\n    }\n\n    int count = 0;\n    for (String s : arr) {\n        if (frequency.get(s) == 1) {\n            count++;\n            if (count == k) {\n                return s;\n            }\n        }\n    }\n\n    return \"\";\n}\n```\n    \n    1. Create a hash table (unordered_map, HashMap, or dictionary, depending on the language) to store the frequency of strings in the input array.\n2. Iterate over the input array and increment the frequency of each string in the hash table.\n3. Initialize a count variable to keep track of the distinct strings found so far.\n4. Iterate over the input array again, checking the frequency of each string in the hash table.\n5. If the frequency is 1 (distinct), increment the count variable.\n6. If the count reaches k, return the current string.\n7. If no kth distinct string is found, return an empty string.\n    ",
        "python": "\n    ```python\ndef kth_distinct_string(arr, k):\n    frequency = {}\n    for s in arr:\n        frequency[s] = frequency.get(s, 0) + 1\n\n    count = 0\n    for s in arr:\n        if frequency[s] == 1:\n            count += 1\n            if count == k:\n                return s\n\n    return \"\"\n```\n    \n    1. Create a hash table (unordered_map, HashMap, or dictionary, depending on the language) to store the frequency of strings in the input array.\n2. Iterate over the input array and increment the frequency of each string in the hash table.\n3. Initialize a count variable to keep track of the distinct strings found so far.\n4. Iterate over the input array again, checking the frequency of each string in the hash table.\n5. If the frequency is 1 (distinct), increment the count variable.\n6. If the count reaches k, return the current string.\n7. If no kth distinct string is found, return an empty string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstring kthDistinctString(vector<string>& arr, int k) {\n    unordered_map<string, int>Frequency;\n    for (const string& s : arr) {\n        Frequency[s]++;\n    }\n\n    int count = 0;\n    for (const string& s : arr) {\n        if (Frequency[s] == 1) {\n            count++;\n            if (count == k) {\n                return s;\n            }\n        }\n    }\n\n    return \"\";\n}\n```\n    \n    1. Create a hash table (unordered_map, HashMap, or dictionary, depending on the language) to store the frequency of strings in the input array.\n2. Iterate over the input array and increment the frequency of each string in the hash table.\n3. Initialize a count variable to keep track of the distinct strings found so far.\n4. Iterate over the input array again, checking the frequency of each string in the hash table.\n5. If the frequency is 1 (distinct), increment the count variable.\n6. If the count reaches k, return the current string.\n7. If no kth distinct string is found, return an empty string.\n    ",
        "js": "\n    ```javascript\nfunction kthDistinctString(arr, k) {\n    const frequency = {};\n    for (const s of arr) {\n        frequency[s] = (frequency[s] || 0) + 1;\n    }\n\n    let count = 0;\n    for (const s of arr) {\n        if (frequency[s] === 1) {\n            count++;\n            if (count === k) {\n                return s;\n            }\n        }\n    }\n\n    return '';\n}\n```\n    \n    1. Create a hash table (unordered_map, HashMap, or dictionary, depending on the language) to store the frequency of strings in the input array.\n2. Iterate over the input array and increment the frequency of each string in the hash table.\n3. Initialize a count variable to keep track of the distinct strings found so far.\n4. Iterate over the input array again, checking the frequency of each string in the hash table.\n5. If the frequency is 1 (distinct), increment the count variable.\n6. If the count reaches k, return the current string.\n7. If no kth distinct string is found, return an empty string.\n    "
    },
    {
        "id": 366,
        "title": "Minimum Time to Remove All Cars Containing Illegal Goods",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** binary string `s` which represents a sequence of train cars. `s[i] = '0'` denotes that the `ith` car does **not** contain illegal goods and `s[i] = '1'` denotes that the `ith` car does contain illegal goods.\n\nAs the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations **any** number of times:\n\n1.  Remove a train car from the **left** end (i.e., remove `s[0]`) which takes 1 unit of time.\n2.  Remove a train car from the **right** end (i.e., remove `s[s.length - 1]`) which takes 1 unit of time.\n3.  Remove a train car from **anywhere** in the sequence which takes 2 units of time.\n\nReturn _the **minimum** time to remove all the cars containing illegal goods_.\n\nNote that an empty sequence of cars is considered to have no cars containing illegal goods.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"**11**00**1**0**1** \"\n**Output:** 5\n**Explanation:** \nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 2 times. Time taken is 2 \\* 1 = 2.\n- remove a car from the right end. Time taken is 1.\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2 + 1 + 2 = 5. \n\nAn alternative way is to\n- remove a car from the left end 2 times. Time taken is 2 \\* 1 = 2.\n- remove a car from the right end 3 times. Time taken is 3 \\* 1 = 3.\nThis also obtains a total time of 2 + 3 = 5.\n\n5 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"00**1**0 \"\n**Output:** 2\n**Explanation:**\nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 3 times. Time taken is 3 \\* 1 = 3.\nThis obtains a total time of 3.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to \n- remove a car from the right end 2 times. Time taken is 2 \\* 1 = 2. \nThis obtains a total time of 2.\n\n2 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s[i]` is either `'0'` or `'1'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"**11**00**1**0**1**\"",
                "output": "5"
            },
            {
                "input": "\"00**1**0\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nint min_time_to_remove_illegal_goods(String s) {\n    int ones = 0, twos = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '1') {\n            twos += ones;\n            ones++;\n        }\n    }\n    return ones + Math.min(ones, twos);\n}\n```\n    \n    The algorithm:\n1. Initialize two counters, `ones` and `twos`, to 0.\n2. Iterate through the characters in the string.\n3. If a character is '1', increment `ones` then add the current value of `ones` to `twos`.\n4. At the end, return `ones + min(ones, twos)`.\n\nStep 3 updates the count based on either removing the car from the left (`ones`) or anywhere (`twos`). The result of this step generates the minimum among the accumulated time spent on removing cars by both methods, which also includes the cars yet to be processed.\n\nThe time complexity is O(n), where n is the length of the input string. This is because we iterate through the whole string in a single pass. The space complexity is O(1) as we only use a constant amount of extra space for the counters.\n    ",
        "python": "\n    ```python\ndef min_time_to_remove_illegal_goods(s: str) -> int:\n    ones = twos = 0\n    for c in s:\n        if c == '1':\n            twos += ones\n            ones += 1\n    return ones + min(ones, twos)\n```\n    \n    The algorithm:\n1. Initialize two counters, `ones` and `twos`, to 0.\n2. Iterate through the characters in the string.\n3. If a character is '1', increment `ones` then add the current value of `ones` to `twos`.\n4. At the end, return `ones + min(ones, twos)`.\n\nStep 3 updates the count based on either removing the car from the left (`ones`) or anywhere (`twos`). The result of this step generates the minimum among the accumulated time spent on removing cars by both methods, which also includes the cars yet to be processed.\n\nThe time complexity is O(n), where n is the length of the input string. This is because we iterate through the whole string in a single pass. The space complexity is O(1) as we only use a constant amount of extra space for the counters.\n    ",
        "c++": "\n    ```cpp\nint min_time_to_remove_illegal_goods(string s) {\n    int ones = 0, twos = 0;\n    for (char c : s) {\n        if (c == '1') {\n            twos += ones;\n            ones++;\n        }\n    }\n    return ones + min(ones, twos);\n}\n```\n    \n    The algorithm:\n1. Initialize two counters, `ones` and `twos`, to 0.\n2. Iterate through the characters in the string.\n3. If a character is '1', increment `ones` then add the current value of `ones` to `twos`.\n4. At the end, return `ones + min(ones, twos)`.\n\nStep 3 updates the count based on either removing the car from the left (`ones`) or anywhere (`twos`). The result of this step generates the minimum among the accumulated time spent on removing cars by both methods, which also includes the cars yet to be processed.\n\nThe time complexity is O(n), where n is the length of the input string. This is because we iterate through the whole string in a single pass. The space complexity is O(1) as we only use a constant amount of extra space for the counters.\n    ",
        "js": "\n    ```javascript\nfunction min_time_to_remove_illegal_goods(s) {\n    let ones = 0, twos = 0;\n    for (let c of s) {\n        if (c === '1') {\n            twos += ones;\n            ones++;\n        }\n    }\n    return ones + Math.min(ones, twos);\n}\n```\n    \n    The algorithm:\n1. Initialize two counters, `ones` and `twos`, to 0.\n2. Iterate through the characters in the string.\n3. If a character is '1', increment `ones` then add the current value of `ones` to `twos`.\n4. At the end, return `ones + min(ones, twos)`.\n\nStep 3 updates the count based on either removing the car from the left (`ones`) or anywhere (`twos`). The result of this step generates the minimum among the accumulated time spent on removing cars by both methods, which also includes the cars yet to be processed.\n\nThe time complexity is O(n), where n is the length of the input string. This is because we iterate through the whole string in a single pass. The space complexity is O(1) as we only use a constant amount of extra space for the counters.\n    "
    },
    {
        "id": 367,
        "title": "Maximum AND Sum of Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` of length `n` and an integer `numSlots` such that `2 * numSlots >= n`. There are `numSlots` slots numbered from `1` to `numSlots`.\n\nYou have to place all `n` integers into the slots such that each slot contains at **most** two numbers. The **AND sum** of a given placement is the sum of the **bitwise** `AND` of every number with its respective slot number.\n\n*   For example, the **AND sum** of placing the numbers `[1, 3]` into slot `1` and `[4, 6]` into slot `2` is equal to `(1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4`.\n\nReturn _the maximum possible **AND sum** of_ `nums` _given_ `numSlots` _slots._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6\\], numSlots = 3\n**Output:** 9\n**Explanation:** One possible placement is \\[1, 4\\] into slot 1, \\[2, 6\\] into slot 2, and \\[3, 5\\] into slot 3. \nThis gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,10,4,7,1\\], numSlots = 9\n**Output:** 24\n**Explanation:** One possible placement is \\[1, 1\\] into slot 1, \\[3\\] into slot 3, \\[4\\] into slot 4, \\[7\\] into slot 7, and \\[10\\] into slot 9.\nThis gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\nNote that slots 2, 5, 6, and 8 are empty which is permitted."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= numSlots <= 9`\n*   `1 <= n <= 2 * numSlots`\n*   `1 <= nums[i] <= 15`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Bit Manipulation",
            "Bitmask"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5,6],3",
                "output": "9"
            },
            {
                "input": "[1,3,10,4,7,1],9",
                "output": "24"
            }
        ],
        "java": "\n    ```java\npublic int maxAndSum(int[] nums, int numSlots, int idx, int used, int sum) {\n    if (idx == nums.length) {\n        return sum;\n    }\n    int max_sum = 0;\n    for (int i = 1; i <= numSlots; ++i) {\n        if ((used & (1 << (i - 1))) == 0) {\n            int new_sum = sum + (nums[idx] & i);\n            int new_used = (used | (1 << (i - 1)));\n            max_sum = Math.max(max_sum, maxAndSum(nums, numSlots, idx + 1, new_used, new_sum));\n            if (idx + 1 < nums.length) {\n                new_sum = new_sum + (nums[idx + 1] & i);\n                max_sum = Math.max(max_sum, maxAndSum(nums, numSlots, idx + 2, new_used, new_sum));\n            }\n        }\n    }\n    return max_sum;\n}\n\npublic int maxAndSum(int[] nums, int numSlots) {\n    return maxAndSum(nums, numSlots, 0, 0, 0);\n}\n```\n\n    \n    The algorithm uses a recursive, brute-force approach to find the maximum AND sum for given numbers and slots. To achieve this, the algorithm iteratively places numbers in slots, taking into account the constraint that each slot can hold at most two numbers, and calculates the AND-sum.\n\nBase case: If all elements of the nums list have been placed into slots, the total sum (sum) is returned, indicating the AND-sum for the current combination.\n\nRecursive step: For each slot (i), if a number hasn't been placed into it yet (checked using bitmask `used`), place the current number in it, mark the slot as used and calculate the next AND-sum. If there is a next number in the nums list, place the pair of numbers in the same slot and calculate AND-sum accordingly.\n\nThe algorithm selects the maximum AND-sum for each combination along the way, until reaching the end of nums list. The maximum, thus, is then stored and returned as the maximum AND-sum.\n\nThe algorithm has the same implementation in all languages, with the only difference being the syntax and function names in respective languages. The time complexity of this algorithm is O(numSlots^n), as we exhaustively try every possible placement of numbers into slots.\n    ",
        "python": "\n    ```python\ndef max_and_sum(nums, num_slots, idx, used, sum):\n    if idx == len(nums):\n        return sum\n    max_sum = 0\n    for i in range(1, num_slots + 1):\n        if not used & (1 << (i - 1)):\n            new_sum = sum + (nums[idx] & i)\n            new_used = used | (1 << (i - 1))\n            max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 1, new_used, new_sum))\n            if idx + 1 < len(nums):\n                new_sum = new_sum + (nums[idx + 1] & i)\n                max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 2, new_used, new_sum))\n    return max_sum\n\ndef max_and_sum(nums, num_slots):\n    return max_and_sum(nums, num_slots, 0, 0, 0)\n```\n\n    \n    The algorithm uses a recursive, brute-force approach to find the maximum AND sum for given numbers and slots. To achieve this, the algorithm iteratively places numbers in slots, taking into account the constraint that each slot can hold at most two numbers, and calculates the AND-sum.\n\nBase case: If all elements of the nums list have been placed into slots, the total sum (sum) is returned, indicating the AND-sum for the current combination.\n\nRecursive step: For each slot (i), if a number hasn't been placed into it yet (checked using bitmask `used`), place the current number in it, mark the slot as used and calculate the next AND-sum. If there is a next number in the nums list, place the pair of numbers in the same slot and calculate AND-sum accordingly.\n\nThe algorithm selects the maximum AND-sum for each combination along the way, until reaching the end of nums list. The maximum, thus, is then stored and returned as the maximum AND-sum.\n\nThe algorithm has the same implementation in all languages, with the only difference being the syntax and function names in respective languages. The time complexity of this algorithm is O(numSlots^n), as we exhaustively try every possible placement of numbers into slots.\n    ",
        "c++": "\n    ```cpp\nint maxAndSum(const vector<int>& nums, int numSlots, size_t idx, int used, int sum) {\n    if (idx == nums.size()) {\n        return sum;\n    }\n    int max_sum = 0;\n    for (int i = 1; i <= numSlots; ++i) {\n        if (!((1 << (i - 1)) & used)) {\n            int new_sum = sum + (nums[idx] & i);\n            int new_used = (used | (1 << (i - 1)));\n            max_sum = max(max_sum, maxAndSum(nums, numSlots, idx + 1, new_used, new_sum));\n            if (idx + 1 < nums.size()) {\n                new_sum = new_sum + (nums[idx + 1] & i);\n                max_sum = max(max_sum, maxAndSum(nums, numSlots, idx + 2, new_used, new_sum));\n            }\n        }\n    }\n    return max_sum;\n}\n\nint maxAndSum(vector<int>& nums, int numSlots) {\n    return maxAndSum(nums, numSlots, 0, 0, 0);\n}\n```\n\n    \n    The algorithm uses a recursive, brute-force approach to find the maximum AND sum for given numbers and slots. To achieve this, the algorithm iteratively places numbers in slots, taking into account the constraint that each slot can hold at most two numbers, and calculates the AND-sum.\n\nBase case: If all elements of the nums list have been placed into slots, the total sum (sum) is returned, indicating the AND-sum for the current combination.\n\nRecursive step: For each slot (i), if a number hasn't been placed into it yet (checked using bitmask `used`), place the current number in it, mark the slot as used and calculate the next AND-sum. If there is a next number in the nums list, place the pair of numbers in the same slot and calculate AND-sum accordingly.\n\nThe algorithm selects the maximum AND-sum for each combination along the way, until reaching the end of nums list. The maximum, thus, is then stored and returned as the maximum AND-sum.\n\nThe algorithm has the same implementation in all languages, with the only difference being the syntax and function names in respective languages. The time complexity of this algorithm is O(numSlots^n), as we exhaustively try every possible placement of numbers into slots.\n    ",
        "js": "\n    ```javascript\nfunction maxAndSum(nums, numSlots, idx, used, sum) {\n    if (idx === nums.length) {\n        return sum;\n    }\n    let max_sum = 0;\n    for (let i = 1; i <= numSlots; ++i) {\n        if ((used & (1 << (i - 1))) === 0) {\n            let new_sum = sum + (nums[idx] & i);\n            let new_used = (used | (1 << (i - 1)));\n            max_sum = Math.max(max_sum, maxAndSum(nums, numSlots, idx + 1, new_used, new_sum));\n            if (idx + 1 < nums.length) {\n                new_sum = new_sum + (nums[idx + 1] & i);\n                max_sum = Math.max(max_sum, maxAndSum(nums, numSlots, idx + 2, new_used, new_sum));\n            }\n        }\n    }\n    return max_sum;\n}\n\nfunction maxAndSum(nums, numSlots) {\n    return maxAndSum(nums, numSlots, 0, 0, 0);\n}\n```\n\n    \n    The algorithm uses a recursive, brute-force approach to find the maximum AND sum for given numbers and slots. To achieve this, the algorithm iteratively places numbers in slots, taking into account the constraint that each slot can hold at most two numbers, and calculates the AND-sum.\n\nBase case: If all elements of the nums list have been placed into slots, the total sum (sum) is returned, indicating the AND-sum for the current combination.\n\nRecursive step: For each slot (i), if a number hasn't been placed into it yet (checked using bitmask `used`), place the current number in it, mark the slot as used and calculate the next AND-sum. If there is a next number in the nums list, place the pair of numbers in the same slot and calculate AND-sum accordingly.\n\nThe algorithm selects the maximum AND-sum for each combination along the way, until reaching the end of nums list. The maximum, thus, is then stored and returned as the maximum AND-sum.\n\nThe algorithm has the same implementation in all languages, with the only difference being the syntax and function names in respective languages. The time complexity of this algorithm is O(numSlots^n), as we exhaustively try every possible placement of numbers into slots.\n    "
    },
    {
        "id": 368,
        "title": "Count Good Triplets in an Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** arrays `nums1` and `nums2` of length `n`, both of which are **permutations** of `[0, 1, ..., n - 1]`.\n\nA **good triplet** is a set of `3` **distinct** values which are present in **increasing order** by position both in `nums1` and `nums2`. In other words, if we consider `pos1v` as the index of the value `v` in `nums1` and `pos2v` as the index of the value `v` in `nums2`, then a good triplet will be a set `(x, y, z)` where `0 <= x, y, z <= n - 1`, such that `pos1x < pos1y < pos1z` and `pos2x < pos2y < pos2z`.\n\nReturn _the **total number** of good triplets_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[2,0,1,3\\], nums2 = \\[0,1,2,3\\]\n**Output:** 1\n**Explanation:** \nThere are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). \nOut of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,0,1,3,2\\], nums2 = \\[4,1,0,2,3\\]\n**Output:** 4\n**Explanation:** The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2)."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `3 <= n <= 105`\n*   `0 <= nums1[i], nums2[i] <= n - 1`\n*   `nums1` and `nums2` are permutations of `[0, 1, ..., n - 1]`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[2,0,1,3],[0,1,2,3]",
                "output": "1"
            },
            {
                "input": "[4,0,1,3,2],[4,1,0,2,3]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public int[] maxBeauty(int[][] items, int[] queries) {\n        int[] sortedItems = new int[10001];\n        for (int[] item : items) {\n            sortedItems[item[0]] = Math.max(sortedItems[item[0]], item[1]);\n        }\n        \n        for (int i = 1; i < sortedItems.length; i++) {\n            sortedItems[i] = Math.max(sortedItems[i], sortedItems[i - 1]);\n        }\n        \n        int[] result = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            result[i] = sortedItems[queries[i]];\n        }\n        return result;\n    }\n}\n```\n\n    \n    The algorithm consists of first sorting the items by their price, while picking the maximum beauty for each price. An array of size 10001 is created to store the maximum beauty for each price, since the price range is [0, 10000]. \n\nAfter sorting the items, we iterate through the sorted array to find the maximum beauty for a range of prices up to the specific index. This allows us to easily answer the queries, since now we can directly look up the maximum beauty for items up to a specific price.\n\nFinally, we iterate through the queries, and for each query, we find the maximum beauty for the given price by accessing the result from the previously computed sorted array. This gives us the answer for each query, which we return as an array of answers in the same order as the queries were given.  \n    ",
        "python": "\n    ```python\ndef max_beauty(items, queries):\n    sorted_items = [0] * 10001\n    for price, beauty in items:\n        sorted_items[price] = max(sorted_items[price], beauty)\n\n    for i in range(1, len(sorted_items)):\n        sorted_items[i] = max(sorted_items[i], sorted_items[i - 1])\n\n    return [sorted_items[query] for query in queries]\n```\n\n    \n    The algorithm consists of first sorting the items by their price, while picking the maximum beauty for each price. An array of size 10001 is created to store the maximum beauty for each price, since the price range is [0, 10000]. \n\nAfter sorting the items, we iterate through the sorted array to find the maximum beauty for a range of prices up to the specific index. This allows us to easily answer the queries, since now we can directly look up the maximum beauty for items up to a specific price.\n\nFinally, we iterate through the queries, and for each query, we find the maximum beauty for the given price by accessing the result from the previously computed sorted array. This gives us the answer for each query, which we return as an array of answers in the same order as the queries were given.  \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maxBeauty(vector<vector<int>>& items, vector<int>& queries) {\n    vector<int> sortedItems(10001, 0);\n    for (auto& item : items) {\n        sortedItems[item[0]] = max(sortedItems[item[0]], item[1]);\n    }\n\n    for (int i = 1; i < sortedItems.size(); ++i) {\n        sortedItems[i] = max(sortedItems[i], sortedItems[i-1]);\n    }\n    \n    vector<int> result;\n    for (int query : queries) {\n        result.push_back(sortedItems[query]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm consists of first sorting the items by their price, while picking the maximum beauty for each price. An array of size 10001 is created to store the maximum beauty for each price, since the price range is [0, 10000]. \n\nAfter sorting the items, we iterate through the sorted array to find the maximum beauty for a range of prices up to the specific index. This allows us to easily answer the queries, since now we can directly look up the maximum beauty for items up to a specific price.\n\nFinally, we iterate through the queries, and for each query, we find the maximum beauty for the given price by accessing the result from the previously computed sorted array. This gives us the answer for each query, which we return as an array of answers in the same order as the queries were given.  \n    ",
        "js": "\n    ```javascript\nfunction maxBeauty(items, queries) {\n    let sortedItems = new Array(10001).fill(0);\n    for (let item of items) {\n        sortedItems[item[0]] = Math.max(sortedItems[item[0]], item[1]);\n    }\n\n    for (let i = 1; i < sortedItems.length; i++) {\n        sortedItems[i] = Math.max(sortedItems[i], sortedItems[i - 1]);\n    }\n\n    return queries.map(query => sortedItems[query]);\n}\n```\n\n    \n    The algorithm consists of first sorting the items by their price, while picking the maximum beauty for each price. An array of size 10001 is created to store the maximum beauty for each price, since the price range is [0, 10000]. \n\nAfter sorting the items, we iterate through the sorted array to find the maximum beauty for a range of prices up to the specific index. This allows us to easily answer the queries, since now we can directly look up the maximum beauty for items up to a specific price.\n\nFinally, we iterate through the queries, and for each query, we find the maximum beauty for the given price by accessing the result from the previously computed sorted array. This gives us the answer for each query, which we return as an array of answers in the same order as the queries were given.  \n    "
    },
    {
        "id": 369,
        "title": "Count Array Pairs Divisible by K",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums` of length `n` and an integer `k`, return _the **number of pairs**_ `(i, j)` _such that:_\n\n*   `0 <= i < j <= n - 1` _and_\n*   `nums[i] * nums[j]` _is divisible by_ `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 7\n**Explanation:** \nThe 7 pairs of indices whose corresponding products are divisible by 2 are\n(0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).\nTheir products are 2, 4, 6, 8, 10, 12, and 20 respectively.\nOther pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2.    \n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\], k = 5\n**Output:** 0\n**Explanation:** There does not exist any pair of indices whose corresponding product is divisible by 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i], k <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5],2",
                "output": "7"
            },
            {
                "input": "[1,2,3,4],5",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums, int start, int goal) {\n    Set<Integer> seen = new HashSet<>();\n    Queue<Integer> queue = new LinkedList<>();\n    seen.add(start);\n    queue.offer(start);\n    int level = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            int x = queue.poll();\n            if (x == goal) return level;\n            for (int num : nums) {\n                int next = x + num;\n                if (next >= 0 && next <= 1000 && !seen.contains(next)) {\n                    seen.add(next);\n                    queue.offer(next);\n                }\n            }\n        }\n        level++;\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a breadth-first search (BFS) based solution. We maintain a queue to keep track of the potential next values of `x`. Initially, `x=start`, and we perform the operation on it using each element of `nums`. We calculate the new value of `x` and add it to the queue if it meets the condition (0 <= next <= 1000) and is not in the seen set. We perform this process level-wise, incrementing the level after each iteration.\n\nIf we encounter the `goal` value during the BFS, we have reached the minimum number of operations needed, and we return the current level. If the BFS completes, and we have not found the `goal`, we return -1 as it is not possible to obtain `goal` through the provided operations.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef minOperations(nums, start, goal):\n    seen = {start}\n    q = deque([start])\n    level = 0\n\n    while q:\n        size = len(q)\n        for i in range(size):\n            x = q.popleft()\n            if x == goal:\n                return level\n            for num in nums:\n                next_x = x + num\n                if 0 <= next_x <= 1000 and next_x not in seen:\n                    seen.add(next_x)\n                    q.append(next_x)\n        level += 1\n\n    return -1\n```\n    \n    The algorithm is a breadth-first search (BFS) based solution. We maintain a queue to keep track of the potential next values of `x`. Initially, `x=start`, and we perform the operation on it using each element of `nums`. We calculate the new value of `x` and add it to the queue if it meets the condition (0 <= next <= 1000) and is not in the seen set. We perform this process level-wise, incrementing the level after each iteration.\n\nIf we encounter the `goal` value during the BFS, we have reached the minimum number of operations needed, and we return the current level. If the BFS completes, and we have not found the `goal`, we return -1 as it is not possible to obtain `goal` through the provided operations.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums, int start, int goal) {\n    unordered_set<int> seen = {start};\n    queue<int> q = {start};\n    int level = 0;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            int x = q.front(); q.pop();\n            if (x == goal) return level;\n            for (int num : nums) {\n                int next = x + num;\n                if (next >= 0 && next <= 1000 && seen.count(next) == 0) {\n                    seen.insert(next);\n                    q.push(next);\n                }\n            }\n        }\n        ++level;\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a breadth-first search (BFS) based solution. We maintain a queue to keep track of the potential next values of `x`. Initially, `x=start`, and we perform the operation on it using each element of `nums`. We calculate the new value of `x` and add it to the queue if it meets the condition (0 <= next <= 1000) and is not in the seen set. We perform this process level-wise, incrementing the level after each iteration.\n\nIf we encounter the `goal` value during the BFS, we have reached the minimum number of operations needed, and we return the current level. If the BFS completes, and we have not found the `goal`, we return -1 as it is not possible to obtain `goal` through the provided operations.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums, start, goal) {\n    const seen = new Set([start]);\n    const queue = [start];\n    let level = 0;\n\n    while (queue.length > 0) {\n        const size = queue.length;\n        for (let i = 0; i < size; i++) {\n            const x = queue.shift();\n            if (x === goal) return level;\n            for (const num of nums) {\n                const next = x + num;\n                if (next >= 0 && next <= 1000 && !seen.has(next)) {\n                    seen.add(next);\n                    queue.push(next);\n                }\n            }\n        }\n        level++;\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a breadth-first search (BFS) based solution. We maintain a queue to keep track of the potential next values of `x`. Initially, `x=start`, and we perform the operation on it using each element of `nums`. We calculate the new value of `x` and add it to the queue if it meets the condition (0 <= next <= 1000) and is not in the seen set. We perform this process level-wise, incrementing the level after each iteration.\n\nIf we encounter the `goal` value during the BFS, we have reached the minimum number of operations needed, and we return the current level. If the BFS completes, and we have not found the `goal`, we return -1 as it is not possible to obtain `goal` through the provided operations.\n    "
    },
    {
        "id": 370,
        "title": "Minimum Time to Finish the Race",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `tires` where `tires[i] = [fi, ri]` indicates that the `ith` tire can finish its `xth` successive lap in `fi * ri(x-1)` seconds.\n\n*   For example, if `fi = 3` and `ri = 2`, then the tire would finish its `1st` lap in `3` seconds, its `2nd` lap in `3 * 2 = 6` seconds, its `3rd` lap in `3 * 22 = 12` seconds, etc.\n\nYou are also given an integer `changeTime` and an integer `numLaps`.\n\nThe race consists of `numLaps` laps and you may start the race with **any** tire. You have an **unlimited** supply of each tire and after every lap, you may **change** to any given tire (including the current tire type) if you wait `changeTime` seconds.\n\nReturn _the **minimum** time to finish the race._",
            "examples": [
                "**Example 1:**\n\n**Input:** tires = \\[\\[2,3\\],\\[3,4\\]\\], changeTime = 5, numLaps = 4\n**Output:** 21\n**Explanation:** \nLap 1: Start with tire 0 and finish the lap in 2 seconds.\nLap 2: Continue with tire 0 and finish the lap in 2 \\* 3 = 6 seconds.\nLap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 0 and finish the lap in 2 \\* 3 = 6 seconds.\nTotal time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\nThe minimum time to complete the race is 21 seconds.\n\n",
                "**Example 2:**\n\n**Input:** tires = \\[\\[1,10\\],\\[2,2\\],\\[3,4\\]\\], changeTime = 6, numLaps = 5\n**Output:** 25\n**Explanation:** \nLap 1: Start with tire 1 and finish the lap in 2 seconds.\nLap 2: Continue with tire 1 and finish the lap in 2 \\* 2 = 4 seconds.\nLap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 1 and finish the lap in 2 \\* 2 = 4 seconds.\nLap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\nTotal time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\nThe minimum time to complete the race is 25 seconds."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= tires.length <= 105`\n*   `tires[i].length == 2`\n*   `1 <= fi, changeTime <= 105`\n*   `2 <= ri <= 105`\n*   `1 <= numLaps <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[[2,3],[3,4]],5,4",
                "output": "21"
            },
            {
                "input": "[[1,10],[2,2],[3,4]],6,5",
                "output": "25"
            }
        ],
        "java": "\n    ```java\nimport java.util.List;\n\npublic int min_x(int n, List<Integer> quantities) {\n    int total_products = 0;\n    for (int q : quantities) {\n        total_products += q;\n    }\n\n    return (total_products + n - 1) / n;\n}\n```\n    \n    We first compute the total number of products by summing up the values in the `quantities` array. In C++ and Java, we do this by looping through the array and adding each value to a running total. In Python, we use the built-in `sum()` function, while in JavaScript, we use the `reduce()` function.\n\nAfter we have the total number of products, we calculate the minimum possible x by dividing the total number of products by the number of specialty retail stores and rounding up to the nearest integer. In C++ and Java, we do this using integer division, adding `n - 1` to the total number of products to ensure that the result is rounded up. In Python, we use floor division (`//`), which also ensures that the result is rounded up. In JavaScript, we use `Math.floor()` for rounding.\n\nFinally, we return the minimum possible x, which represents the minimum number of products per store.\n    ",
        "python": "\n    ```python\ndef min_x(n, quantities):\n    total_products = sum(quantities)\n    return (total_products + n - 1) // n\n```\n    \n    We first compute the total number of products by summing up the values in the `quantities` array. In C++ and Java, we do this by looping through the array and adding each value to a running total. In Python, we use the built-in `sum()` function, while in JavaScript, we use the `reduce()` function.\n\nAfter we have the total number of products, we calculate the minimum possible x by dividing the total number of products by the number of specialty retail stores and rounding up to the nearest integer. In C++ and Java, we do this using integer division, adding `n - 1` to the total number of products to ensure that the result is rounded up. In Python, we use floor division (`//`), which also ensures that the result is rounded up. In JavaScript, we use `Math.floor()` for rounding.\n\nFinally, we return the minimum possible x, which represents the minimum number of products per store.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint min_x(int n, vector<int>& quantities) {\n    int total_products = 0;\n    for (int q : quantities) {\n        total_products += q;\n    }\n\n    return (total_products + n - 1) / n;\n}\n```\n    \n    We first compute the total number of products by summing up the values in the `quantities` array. In C++ and Java, we do this by looping through the array and adding each value to a running total. In Python, we use the built-in `sum()` function, while in JavaScript, we use the `reduce()` function.\n\nAfter we have the total number of products, we calculate the minimum possible x by dividing the total number of products by the number of specialty retail stores and rounding up to the nearest integer. In C++ and Java, we do this using integer division, adding `n - 1` to the total number of products to ensure that the result is rounded up. In Python, we use floor division (`//`), which also ensures that the result is rounded up. In JavaScript, we use `Math.floor()` for rounding.\n\nFinally, we return the minimum possible x, which represents the minimum number of products per store.\n    ",
        "js": "\n    ```javascript\nfunction min_x(n, quantities) {\n    let total_products = quantities.reduce((a, b) => a + b);\n    return Math.floor((total_products + n - 1) / n);\n}\n```\n    \n    We first compute the total number of products by summing up the values in the `quantities` array. In C++ and Java, we do this by looping through the array and adding each value to a running total. In Python, we use the built-in `sum()` function, while in JavaScript, we use the `reduce()` function.\n\nAfter we have the total number of products, we calculate the minimum possible x by dividing the total number of products by the number of specialty retail stores and rounding up to the nearest integer. In C++ and Java, we do this using integer division, adding `n - 1` to the total number of products to ensure that the result is rounded up. In Python, we use floor division (`//`), which also ensures that the result is rounded up. In JavaScript, we use `Math.floor()` for rounding.\n\nFinally, we return the minimum possible x, which represents the minimum number of products per store.\n    "
    },
    {
        "id": 371,
        "title": "Minimum Number of Moves to Make Palindrome",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` consisting only of lowercase English letters.\n\nIn one **move**, you can select any two **adjacent** characters of `s` and swap them.\n\nReturn _the **minimum number of moves** needed to make_ `s` _a palindrome_.\n\n**Note** that the input will be generated such that `s` can always be converted to a palindrome.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aabb \"\n**Output:** 2\n**Explanation:**\nWe can obtain two palindromes from s,  \"abba \" and  \"baab \". \n- We can obtain  \"abba \" from s in 2 moves:  \"a**ab**b \" ->  \"ab**ab** \" ->  \"abba \".\n- We can obtain  \"baab \" from s in 2 moves:  \"a**ab**b \" ->  \"**ab**ab \" ->  \"baab \".\nThus, the minimum number of moves needed to make s a palindrome is 2.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"letelt \"\n**Output:** 2\n**Explanation:**\nOne of the palindromes we can obtain from s in 2 moves is  \"lettel \".\nOne of the ways we can obtain it is  \"lete**lt** \" ->  \"let**et**l \" ->  \"lettel \".\nOther palindromes such as  \"tleelt \" can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists only of lowercase English letters.\n*   `s` can be converted to a palindrome using a finite number of moves.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Greedy",
            "Binary Indexed Tree"
        ],
        "example": [
            {
                "input": "\"aabb\"",
                "output": "2"
            },
            {
                "input": "\"letelt\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countPyramids(int[][] grid) {\n    int m = grid.length, n = grid[0].length, count = 0;\n    for (int i = 1; i < m - 1; ++i) {\n        for (int j = 1; j < n - 1; ++j) {\n            if (grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]\n                && grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]) {\n                count += grid[i][j];\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    We iterate through each cell of the grid, and check for both pyramidal and inverse pyramidal plots in a single condition. For a given cell (i, j), we check the sum of neighboring cells both diagonally and horizontally.\n\nThe condition `grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]` checks the pyramid structure by looking at its vertices. If the vertices are barren and the central cell is fertile, this condition is satisfied.\n\nSimilarly, the condition `grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]` checks the inverse pyramid structure by looking at its vertices. If the vertices are fertile and the central cell is barren, this condition is satisfied.\n\nHence both conditions combined check for both pyramidal and inverse pyramidal plots. If both conditions are satisfied, we just increment the count by the value of the current cell in the grid (either 0 or 1). We repeat this process for all cells and return the final count.\n    ",
        "python": "\n    ```python\ndef count_pyramids(grid):\n    m, n, count = len(grid), len(grid[0]), 0\n    for i in range(1, m - 1):\n        for j in range(1, n - 1):\n            if grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1] \\\n                and grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]:\n                count += grid[i][j]\n    return count\n```\n    \n    We iterate through each cell of the grid, and check for both pyramidal and inverse pyramidal plots in a single condition. For a given cell (i, j), we check the sum of neighboring cells both diagonally and horizontally.\n\nThe condition `grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]` checks the pyramid structure by looking at its vertices. If the vertices are barren and the central cell is fertile, this condition is satisfied.\n\nSimilarly, the condition `grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]` checks the inverse pyramid structure by looking at its vertices. If the vertices are fertile and the central cell is barren, this condition is satisfied.\n\nHence both conditions combined check for both pyramidal and inverse pyramidal plots. If both conditions are satisfied, we just increment the count by the value of the current cell in the grid (either 0 or 1). We repeat this process for all cells and return the final count.\n    ",
        "c++": "\n    ```cpp\nint countPyramids(vector<vector<int>> &grid) {\n    int m = grid.size(), n = grid[0].size(), count = 0;\n    for (int i = 1; i < m - 1; ++i) {\n        for (int j = 1; j < n - 1; ++j) {\n            if (grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]\n                && grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]) {\n                count += grid[i][j];\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    We iterate through each cell of the grid, and check for both pyramidal and inverse pyramidal plots in a single condition. For a given cell (i, j), we check the sum of neighboring cells both diagonally and horizontally.\n\nThe condition `grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]` checks the pyramid structure by looking at its vertices. If the vertices are barren and the central cell is fertile, this condition is satisfied.\n\nSimilarly, the condition `grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]` checks the inverse pyramid structure by looking at its vertices. If the vertices are fertile and the central cell is barren, this condition is satisfied.\n\nHence both conditions combined check for both pyramidal and inverse pyramidal plots. If both conditions are satisfied, we just increment the count by the value of the current cell in the grid (either 0 or 1). We repeat this process for all cells and return the final count.\n    ",
        "js": "\n    ```javascript\nfunction countPyramids(grid) {\n    const m = grid.length, n = grid[0].length;\n    let count = 0;\n    for (let i = 1; i < m - 1; ++i) {\n        for (let j = 1; j < n - 1; ++j) {\n            if (grid[i][j] === grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]\n                && grid[i][j] === grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]) {\n                count += grid[i][j];\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    We iterate through each cell of the grid, and check for both pyramidal and inverse pyramidal plots in a single condition. For a given cell (i, j), we check the sum of neighboring cells both diagonally and horizontally.\n\nThe condition `grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]` checks the pyramid structure by looking at its vertices. If the vertices are barren and the central cell is fertile, this condition is satisfied.\n\nSimilarly, the condition `grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]` checks the inverse pyramid structure by looking at its vertices. If the vertices are fertile and the central cell is barren, this condition is satisfied.\n\nHence both conditions combined check for both pyramidal and inverse pyramidal plots. If both conditions are satisfied, we just increment the count by the value of the current cell in the grid (either 0 or 1). We repeat this process for all cells and return the final count.\n    "
    },
    {
        "id": 372,
        "title": "Replace Non-Coprime Numbers in Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `nums`. Perform the following steps:\n\n1.  Find **any** two **adjacent** numbers in `nums` that are **non-coprime**.\n2.  If no such numbers are found, **stop** the process.\n3.  Otherwise, delete the two numbers and **replace** them with their **LCM (Least Common Multiple)**.\n4.  **Repeat** this process as long as you keep finding two adjacent non-coprime numbers.\n\nReturn _the **final** modified array._ It can be shown that replacing adjacent non-coprime numbers in **any** arbitrary order will lead to the same result.\n\nThe test cases are generated such that the values in the final array are **less than or equal** to `108`.\n\nTwo values `x` and `y` are **non-coprime** if `GCD(x, y) > 1` where `GCD(x, y)` is the **Greatest Common Divisor** of `x` and `y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[6,4,3,2,7,6,2\\]\n**Output:** \\[12,7,6\\]\n**Explanation:** \n- (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = \\[**12**,3,2,7,6,2\\].\n- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = \\[**12**,2,7,6,2\\].\n- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = \\[**12**,7,6,2\\].\n- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = \\[12,7,**6**\\].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is \\[12,7,6\\].\nNote that there are other ways to obtain the same resultant array.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,1,1,3,3,3\\]\n**Output:** \\[2,1,1,3\\]\n**Explanation:** \n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = \\[2,2,1,1,**3**,3\\].\n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = \\[2,2,1,1,**3**\\].\n- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = \\[**2**,1,1,3\\].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is \\[2,1,1,3\\].\nNote that there are other ways to obtain the same resultant array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\n*   The test cases are generated such that the values in the final array are **less than or equal** to `108`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Stack",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[6,4,3,2,7,6,2]",
                "output": "[12,7,6]"
            },
            {
                "input": "[2,2,1,1,3,3,3]",
                "output": "[2,1,1,3]"
            }
        ],
        "java": "\n    ```java\npublic String decodeSlantedCipher(String encodedText, int rows) {\n    StringBuilder[] matrix = new StringBuilder[rows];\n    for(int i = 0; i < rows; i++) {\n        matrix[i] = new StringBuilder(\"\");\n    }\n\n    int index = 0;\n    for(int diagonal = 0; diagonal < 2 * (rows - 1); diagonal++) {\n        for(int row = Math.max(0, diagonal - rows + 1); row <= Math.min(diagonal, rows - 1); row++) {\n            if(index < encodedText.length()) {\n                matrix[row].append(encodedText.charAt(index++));\n            }\n        }\n    }\n\n    StringBuilder originalText = new StringBuilder();\n    for(int i = 0; i < rows; i++) {\n        originalText.append(matrix[i]);\n    }\n    return originalText.toString();\n}\n```\n    \n    The algorithm basically follows these steps:\n\n1. Create a matrix with the given number of rows and columns equal to the length of the encoded text divided by the number of rows plus 1, filled with spaces.\n2. Iterate through each diagonal of the matrix with a nested loop for each row.\n3. If the current index of the encoded text is within the bounds of the text, place the current character from encoded text into the corresponding position of the matrix.\n4. Finally, join the matrix rows into a single string to create the original text without trailing spaces.\n    ",
        "python": "\n    ```python\ndef decode_slanted_cipher(encoded_text, rows):\n    matrix = ['' for _ in range(rows)]\n    index = 0\n\n    for diagonal in range(2 * (rows - 1)):\n        for row in range(max(0, diagonal - rows + 1), min(diagonal, rows - 1) + 1):\n            if index < len(encoded_text):\n                matrix[row] += encoded_text[index]\n                index += 1\n\n    return ''.join(matrix)\n```\n    \n    The algorithm basically follows these steps:\n\n1. Create a matrix with the given number of rows and columns equal to the length of the encoded text divided by the number of rows plus 1, filled with spaces.\n2. Iterate through each diagonal of the matrix with a nested loop for each row.\n3. If the current index of the encoded text is within the bounds of the text, place the current character from encoded text into the corresponding position of the matrix.\n4. Finally, join the matrix rows into a single string to create the original text without trailing spaces.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string decodeSlantedCipher(const std::string &encodedText, int rows) {\n    std::vector<std::string> matrix(rows, std::string(encodedText.size() / rows + 1, ' '));\n    int index = 0;\n    for(int diagonal = 0; diagonal < 2 * (rows - 1); ++diagonal) {\n        for(int row = std::max(0, diagonal - rows + 1); row <= std::min(diagonal, rows - 1); ++row) {\n            if(index < encodedText.size()) {\n                matrix[row][diagonal - row] = encodedText[index++];\n            }\n        }\n    }\n    std::string originalText;\n    for(int i = 0; i < rows; ++i) {\n        originalText += matrix[i];\n    }\n    return originalText;\n}\n```\n    \n    The algorithm basically follows these steps:\n\n1. Create a matrix with the given number of rows and columns equal to the length of the encoded text divided by the number of rows plus 1, filled with spaces.\n2. Iterate through each diagonal of the matrix with a nested loop for each row.\n3. If the current index of the encoded text is within the bounds of the text, place the current character from encoded text into the corresponding position of the matrix.\n4. Finally, join the matrix rows into a single string to create the original text without trailing spaces.\n    ",
        "js": "\n    ```javascript\nfunction decodeSlantedCipher(encodedText, rows) {\n    let matrix = new Array(rows).fill(\"\");\n\n    let index = 0;\n    for(let diagonal = 0; diagonal < 2 * (rows - 1); diagonal++) {\n        for(let row = Math.max(0, diagonal - rows + 1); row <= Math.min(diagonal, rows - 1); row++) {\n            if(index < encodedText.length) {\n                matrix[row] += encodedText[index++];\n            }\n        }\n    }\n\n    return matrix.join(\"\");\n}\n```\n    \n    The algorithm basically follows these steps:\n\n1. Create a matrix with the given number of rows and columns equal to the length of the encoded text divided by the number of rows plus 1, filled with spaces.\n2. Iterate through each diagonal of the matrix with a nested loop for each row.\n3. If the current index of the encoded text is within the bounds of the text, place the current character from encoded text into the corresponding position of the matrix.\n4. Finally, join the matrix rows into a single string to create the original text without trailing spaces.\n    "
    },
    {
        "id": 373,
        "title": "Minimum Weighted Subgraph With the Required Paths",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n` denoting the number of nodes of a **weighted directed** graph. The nodes are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` denotes that there exists a **directed** edge from `fromi` to `toi` with weight `weighti`.\n\nLastly, you are given three **distinct** integers `src1`, `src2`, and `dest` denoting three distinct nodes of the graph.\n\nReturn _the **minimum weight** of a subgraph of the graph such that it is **possible** to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of edges of this subgraph_. In case such a subgraph does not exist, return `-1`.\n\nA **subgraph** is a graph whose vertices and edges are subsets of the original graph. The **weight** of a subgraph is the sum of weights of its constituent edges.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,2,2\\],\\[0,5,6\\],\\[1,0,3\\],\\[1,4,5\\],\\[2,1,1\\],\\[2,3,3\\],\\[2,3,4\\],\\[3,4,2\\],\\[4,5,1\\]\\], src1 = 0, src2 = 1, dest = 5\n**Output:** 9\n**Explanation:**\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph \\[\\[1,0,3\\],\\[0,5,6\\]\\] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1,1\\],\\[2,1,1\\]\\], src1 = 0, src2 = 1, dest = 2\n**Output:** -1\n**Explanation:**\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= n <= 105`\n*   `0 <= edges.length <= 105`\n*   `edges[i].length == 3`\n*   `0 <= fromi, toi, src1, src2, dest <= n - 1`\n*   `fromi != toi`\n*   `src1`, `src2`, and `dest` are pairwise distinct.\n*   `1 <= weight[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Graph",
            "Shortest Path"
        ],
        "example": [
            {
                "input": "6,[[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]],0,1,5",
                "output": "9"
            },
            {
                "input": "3,[[0,1,1],[2,1,1]],0,1,2",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minWeightSubgraph(int n, int[][] edges, int src1, int src2, int dest) {\n    List<List<int[]>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adj.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adj.get(edge[0]).add(new int[]{edge[1], edge[2]});\n    }\n\n    IntFunction<int[]> dijkstra = src -> {\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        pq.offer(new int[]{0, src});\n\n        while (!pq.isEmpty()) {\n            int[] top = pq.poll();\n            int d = top[0], u = top[1];\n            if (d != dist[u]) continue;\n            for (int[] nei : adj.get(u)) {\n                int v = nei[0], w = nei[1];\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    pq.offer(new int[]{dist[v], v});\n                }\n            }\n        }\n\n        return dist;\n    };\n\n    int[] dist1 = dijkstra.apply(src1);\n    int[] dist2 = dijkstra.apply(src2);\n\n    int res = dist1[dest] + dist2[dest];\n    for (int[] edge : edges) {\n        int u = edge[0], v = edge[1], w = edge[2];\n        res = Math.min(res, dist1[u] + dist2[v] + w);\n        res = Math.min(res, dist1[v] + dist2[u] + w);\n    }\n\n    return res == Integer.MAX_VALUE ? -1 : res;\n}\n```\n    \n    1. Create an adjacency list representing the given graph.\n2. Define a Dijkstra's algorithm function to find the shortest distance between two nodes.\n3. Use Dijkstra's algorithm to find the shortest distances from `src1` and `src2` to all other nodes in the graph.\n4. Initialize `res` as the sum of the shortest path distances from `src1` and `src2` to the `dest`.\n5. Iterate through all edges in the graph, and for each edge, update `res` as the minimum of the following:\n   a. The current value of `res`.\n   b. The sum of the shortest path distances from `src1` and `src2` to one node of the edge, plus the edge weight.\n   c. The sum of the shortest path distances from `src2` and `src1` to one node of the edge, plus the edge weight.\n6. If `res` is unchanged, return -1; otherwise, return the minimum weight subgraph.\n    ",
        "python": "\n    ```python\nfrom heapq import heappop, heappush\nfrom sys import maxsize\n\ndef dijkstra(src, adj):\n    dist = [maxsize] * len(adj)\n    dist[src] = 0\n    pq = [(0, src)]\n\n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u]:\n            if d + w < dist[v]:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\ndef min_weight_subgraph(n, edges, src1, src2, dest):\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n\n    dist1 = dijkstra(src1, adj)\n    dist2 = dijkstra(src2, adj)\n\n    res = dist1[dest] + dist2[dest]\n    for u, v, w in edges:\n        res = min(res, dist1[u] + dist2[v] + w)\n        res = min(res, dist1[v] + dist2[u] + w)\n\n    return res if res != maxsize else -1\n```\n    \n    1. Create an adjacency list representing the given graph.\n2. Define a Dijkstra's algorithm function to find the shortest distance between two nodes.\n3. Use Dijkstra's algorithm to find the shortest distances from `src1` and `src2` to all other nodes in the graph.\n4. Initialize `res` as the sum of the shortest path distances from `src1` and `src2` to the `dest`.\n5. Iterate through all edges in the graph, and for each edge, update `res` as the minimum of the following:\n   a. The current value of `res`.\n   b. The sum of the shortest path distances from `src1` and `src2` to one node of the edge, plus the edge weight.\n   c. The sum of the shortest path distances from `src2` and `src1` to one node of the edge, plus the edge weight.\n6. If `res` is unchanged, return -1; otherwise, return the minimum weight subgraph.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint min_weight_subgraph(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\n    vector<vector<pair<int, int>>> adj(n);\n    for (auto &edge : edges) {\n        adj[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra = [&](int src) {\n        vector<int> dist(n, numeric_limits<int>::max());\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n        dist[src] = 0;\n        pq.emplace(0, src);\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int d = pq.top().first;\n            pq.pop();\n            if (d != dist[u]) continue;\n            for (auto &[v, w] : adj[u]) {\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    pq.emplace(dist[v], v);\n                }\n            }\n        }\n\n        return dist;\n    };\n\n    vector<int> dist1 = dijkstra(src1);\n    vector<int> dist2 = dijkstra(src2);\n\n    int res = dist1[dest] + dist2[dest];\n    for (auto &edge : edges) {\n        int u = edge[0], v = edge[1], w = edge[2];\n        res = min(res, dist1[u] + dist2[v] + w);\n        res = min(res, dist1[v] + dist2[u] + w);\n    }\n\n    return res == numeric_limits<int>::max() ? -1 : res;\n}\n```\n    \n    1. Create an adjacency list representing the given graph.\n2. Define a Dijkstra's algorithm function to find the shortest distance between two nodes.\n3. Use Dijkstra's algorithm to find the shortest distances from `src1` and `src2` to all other nodes in the graph.\n4. Initialize `res` as the sum of the shortest path distances from `src1` and `src2` to the `dest`.\n5. Iterate through all edges in the graph, and for each edge, update `res` as the minimum of the following:\n   a. The current value of `res`.\n   b. The sum of the shortest path distances from `src1` and `src2` to one node of the edge, plus the edge weight.\n   c. The sum of the shortest path distances from `src2` and `src1` to one node of the edge, plus the edge weight.\n6. If `res` is unchanged, return -1; otherwise, return the minimum weight subgraph.\n    ",
        "js": "\n    ```javascript\nfunction dijkstra(src, adj) {\n    const dist = new Array(adj.length).fill(Infinity);\n    dist[src] = 0;\n    const pq = [[0, src]];\n\n    while (pq.length > 0) {\n        const [d, u] = pq.shift();\n        if (d !== dist[u]) continue;\n        for (const [v, w] of adj[u]) {\n            if (d + w < dist[v]) {\n                dist[v] = d + w;\n                pq.push([dist[v], v]);\n                pq.sort((a, b) => a[0] - b[0]);\n            }\n        }\n    }\n\n    return dist;\n}\n\nfunction minWeightSubgraph(n, edges, src1, src2, dest) {\n    const adj = Array.from({ length: n }, () => []);\n    for (const [u, v, w] of edges) {\n        adj[u].push([v, w]);\n    }\n\n    const dist1 = dijkstra(src1, adj);\n    const dist2 = dijkstra(src2, adj);\n\n    let res = dist1[dest] + dist2[dest];\n    for (const [u, v, w] of edges) {\n        res = Math.min(res, dist1[u] + dist2[v] + w);\n        res = Math.min(res, dist1[v] + dist2[u] + w);\n    }\n\n    return res === Infinity ? -1 : res;\n}\n```\n    \n    1. Create an adjacency list representing the given graph.\n2. Define a Dijkstra's algorithm function to find the shortest distance between two nodes.\n3. Use Dijkstra's algorithm to find the shortest distances from `src1` and `src2` to all other nodes in the graph.\n4. Initialize `res` as the sum of the shortest path distances from `src1` and `src2` to the `dest`.\n5. Iterate through all edges in the graph, and for each edge, update `res` as the minimum of the following:\n   a. The current value of `res`.\n   b. The sum of the shortest path distances from `src1` and `src2` to one node of the edge, plus the edge weight.\n   c. The sum of the shortest path distances from `src2` and `src1` to one node of the edge, plus the edge weight.\n6. If `res` is unchanged, return -1; otherwise, return the minimum weight subgraph.\n    "
    },
    {
        "id": 374,
        "title": "Minimum White Tiles After Covering With Carpets",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed binary** string `floor`, which represents the colors of tiles on a floor:\n\n*   `floor[i] = '0'` denotes that the `ith` tile of the floor is colored **black**.\n*   On the other hand, `floor[i] = '1'` denotes that the `ith` tile of the floor is colored **white**.\n\nYou are also given `numCarpets` and `carpetLen`. You have `numCarpets` **black** carpets, each of length `carpetLen` tiles. Cover the tiles with the given carpets such that the number of **white** tiles still visible is **minimum**. Carpets may overlap one another.\n\nReturn _the **minimum** number of white tiles still visible._",
            "examples": [
                "**Example 1:**\n\n**Input:** floor =  \"10110101 \", numCarpets = 2, carpetLen = 2\n**Output:** 2\n**Explanation:** \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n\n",
                "**Example 2:**\n\n**Input:** floor =  \"11111 \", numCarpets = 2, carpetLen = 3\n**Output:** 0\n**Explanation:** \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= carpetLen <= floor.length <= 1000`\n*   `floor[i]` is either `'0'` or `'1'`.\n*   `1 <= numCarpets <= 1000`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "\"10110101\",2,2",
                "output": "2"
            },
            {
                "input": "\"11111\",2,3",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minVisibleWhiteTiles(String floor, int numCarpets, int carpetLen) {\n    int n = floor.length(), res = n;\n    for (int i = 0; i < n - carpetLen + 1; ++i) {\n        int count = 0;\n        for (int j = 0; j < carpetLen; ++j)\n            count += (floor.charAt(i + j) == '1') ? 1 : 0;\n        for (int k = 1; k <= numCarpets && k * carpetLen - 1 <= i + carpetLen; ++k) {\n            res = Math.min(res, n - count * k);\n            if (i + carpetLen < n) {\n                count -= (floor.charAt(i + carpetLen - k * carpetLen) == '1') ? 1 : 0;\n                count += (floor.charAt(i + carpetLen) == '1') ? 1 : 0;\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm starts by iterating through the `floor` string to count the possible white tiles that can be covered by one carpet in segments of the carpet length. This results in an optimal arrangement. Then we calculate the remaining count of white tiles for each carpet placement separately by overlapping the carpets where needed. Finally, we find the minimum count of visible white tiles from all combinations and return it as the result. While finding the minimum count, we also check for the overlap of different carpets to minimize visible white tiles.\n    ",
        "python": "\n    ```python\ndef minVisibleWhiteTiles(floor: str, numCarpets: int, carpetLen: int) -> int:\n    n, res = len(floor), len(floor)\n    for i in range(n - carpetLen + 1):\n        count = sum(1 for j in range(carpetLen) if floor[i + j] == '1')\n        for k in range(1, numCarpets + 1):\n            if k * carpetLen - 1 <= i + carpetLen:\n                res = min(res, n - count * k)\n                if i + carpetLen < n:\n                    count -= floor[i + carpetLen - k * carpetLen] == '1'\n                    count += floor[i + carpetLen] == '1'\n    return res\n```\n\n    \n    The algorithm starts by iterating through the `floor` string to count the possible white tiles that can be covered by one carpet in segments of the carpet length. This results in an optimal arrangement. Then we calculate the remaining count of white tiles for each carpet placement separately by overlapping the carpets where needed. Finally, we find the minimum count of visible white tiles from all combinations and return it as the result. While finding the minimum count, we also check for the overlap of different carpets to minimize visible white tiles.\n    ",
        "c++": "\n    ```cpp\nint minVisibleWhiteTiles(string floor, int numCarpets, int carpetLen) {\n    int n = floor.size(), res = n;\n    for (int i = 0; i < n - carpetLen + 1; ++i) {\n        int count = 0;\n        for (int j = 0; j < carpetLen; ++j)\n            count += (floor[i + j] == '1');\n        for (int k = 1; k <= numCarpets && k * carpetLen - 1 <= i + carpetLen; ++k) {\n            res = min(res, n - count * k);\n            if (i + carpetLen < n) {\n                count -= (floor[i + carpetLen - k * carpetLen] == '1');\n                count += (floor[i + carpetLen] == '1');\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm starts by iterating through the `floor` string to count the possible white tiles that can be covered by one carpet in segments of the carpet length. This results in an optimal arrangement. Then we calculate the remaining count of white tiles for each carpet placement separately by overlapping the carpets where needed. Finally, we find the minimum count of visible white tiles from all combinations and return it as the result. While finding the minimum count, we also check for the overlap of different carpets to minimize visible white tiles.\n    ",
        "js": "\n    ```javascript\nfunction minVisibleWhiteTiles(floor, numCarpets, carpetLen) {\n    let n = floor.length, res = n;\n    for (let i = 0; i < n - carpetLen + 1; ++i) {\n        let count = 0;\n        for (let j = 0; j < carpetLen; ++j)\n            count += (floor[i + j] === '1') ? 1 : 0;\n        for (let k = 1; k <= numCarpets && k * carpetLen - 1 <= i + carpetLen; ++k) {\n            res = Math.min(res, n - count * k);\n            if (i + carpetLen < n) {\n                count -= (floor[i + carpetLen - k * carpetLen] === '1') ? 1 : 0;\n                count += (floor[i + carpetLen] === '1') ? 1 : 0;\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm starts by iterating through the `floor` string to count the possible white tiles that can be covered by one carpet in segments of the carpet length. This results in an optimal arrangement. Then we calculate the remaining count of white tiles for each carpet placement separately by overlapping the carpets where needed. Finally, we find the minimum count of visible white tiles from all combinations and return it as the result. While finding the minimum count, we also check for the overlap of different carpets to minimize visible white tiles.\n    "
    },
    {
        "id": 375,
        "title": "Longest Substring of One Repeating Character",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** string `s`. You are also given a **0-indexed** string `queryCharacters` of length `k` and a **0-indexed** array of integer **indices** `queryIndices` of length `k`, both of which are used to describe `k` queries.\n\nThe `ith` query updates the character in `s` at index `queryIndices[i]` to the character `queryCharacters[i]`.\n\nReturn _an array_ `lengths` _of length_ `k` _where_ `lengths[i]` _is the **length** of the **longest substring** of_ `s` _consisting of **only one repeating** character **after** the_ `ith` _query_ _is performed._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"babacc \", queryCharacters =  \"bcb \", queryIndices = \\[1,3,3\\]\n**Output:** \\[3,3,4\\]\n**Explanation:** \n- 1st query updates s =  \"b**b**bacc \". The longest substring consisting of one repeating character is  \"bbb \" with length 3.\n- 2nd query updates s =  \"bbb**c**cc \". \n  The longest substring consisting of one repeating character can be  \"bbb \" or  \"ccc \" with length 3.\n- 3rd query updates s =  \"bbb**b**cc \". The longest substring consisting of one repeating character is  \"bbbb \" with length 4.\nThus, we return \\[3,3,4\\].\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abyzz \", queryCharacters =  \"aa \", queryIndices = \\[2,1\\]\n**Output:** \\[2,3\\]\n**Explanation:**\n- 1st query updates s =  \"ab**a**zz \". The longest substring consisting of one repeating character is  \"zz \" with length 2.\n- 2nd query updates s =  \"a**a**azz \". The longest substring consisting of one repeating character is  \"aaa \" with length 3.\nThus, we return \\[2,3\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.\n*   `k == queryCharacters.length == queryIndices.length`\n*   `1 <= k <= 105`\n*   `queryCharacters` consists of lowercase English letters.\n*   `0 <= queryIndices[i] < s.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Segment Tree",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "\"babacc\",\"bcb\",[1,3,3]",
                "output": "[3,3,4]"
            },
            {
                "input": "\"abyzz\",\"aa\",[2,1]",
                "output": "[2,3]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> peopleWithSecret(int n, int[][] meetings, int firstPerson) {\n    Set<Integer> secretHolders = new HashSet<>();\n    secretHolders.add(firstPerson);\n\n    int time = 0;\n    List<int[]> futureMeetings = new ArrayList<>(Arrays.asList(meetings));\n    while (!futureMeetings.isEmpty()) {\n        List<int[]> newMeetingList = new ArrayList<>();\n        for (int[] meeting : futureMeetings) {\n            if (meeting[2] > time) {\n                newMeetingList.add(meeting);\n                continue;\n            }\n            if (secretHolders.contains(meeting[0]) || secretHolders.contains(meeting[1])) {\n                secretHolders.add(meeting[0]);\n                secretHolders.add(meeting[1]);\n            }\n        }\n        time++;\n        futureMeetings = newMeetingList;\n    }\n\n    return new ArrayList<>(secretHolders);\n}\n```\n    \n    The implemented algorithm saves the secret holders in a set called `secretHolders` and initializes it with the `firstPerson`. It then organizes the meetings by time, storing the people who participate in a meeting in a dictionary or an equivalent data structure named `meetingsByTime` where each key is a time `t` and its value is a list of arrays (length 2) that store the people who participate in the meetings at that time.\n\nWe iterate through every time step from 0 to n-1. If there are any meetings at that time step, we iterate through the people involved in each meeting. If either person involved in the meeting is in the set `secretHolders`, we add both people to the set. As a result, at each time step, we spread the secret instantly to everyone having meetings with the current secret holders. After completing the loop, we return the final `secretHolders` set as a list.\n\nIn all languages, the code first initializes a set or similar data structure for the secret holders and then populates it with the first person. Then, it organizes the meetings based on their respective times. The time steps are then iterated, and for each meeting occurring simultaneously, it updates the secret holder set whenever it encounters a secret holder. Finally, the code returns the secret holders as a list.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef people_with_secret(n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    secret_holders = set([firstPerson])\n    meetings_by_time = defaultdict(list)\n\n    for meeting in meetings:\n        meetings_by_time[meeting[2]].append(tuple(meeting[:2]))\n        \n    for time in range(n):\n        if time in meetings_by_time:\n            for x, y in meetings_by_time[time]:\n                if x in secret_holders or y in secret_holders:\n                    secret_holders.add(x)\n                    secret_holders.add(y)\n\n    return list(secret_holders)\n```\n    \n    The implemented algorithm saves the secret holders in a set called `secretHolders` and initializes it with the `firstPerson`. It then organizes the meetings by time, storing the people who participate in a meeting in a dictionary or an equivalent data structure named `meetingsByTime` where each key is a time `t` and its value is a list of arrays (length 2) that store the people who participate in the meetings at that time.\n\nWe iterate through every time step from 0 to n-1. If there are any meetings at that time step, we iterate through the people involved in each meeting. If either person involved in the meeting is in the set `secretHolders`, we add both people to the set. As a result, at each time step, we spread the secret instantly to everyone having meetings with the current secret holders. After completing the loop, we return the final `secretHolders` set as a list.\n\nIn all languages, the code first initializes a set or similar data structure for the secret holders and then populates it with the first person. Then, it organizes the meetings based on their respective times. The time steps are then iterated, and for each meeting occurring simultaneously, it updates the secret holder set whenever it encounters a secret holder. Finally, the code returns the secret holders as a list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> peopleWithSecret(int n, vector<vector<int>>& meetings, int firstPerson) {\n    unordered_set<int> secretHolders;\n    secretHolders.insert(firstPerson);\n\n    for (int time = 0; !meetings.empty(); ++time) {\n        vector<vector<int>> future_meetings;\n        for (const auto& meeting : meetings) {\n            if (meeting[2] > time) {\n                future_meetings.push_back(meeting);\n                continue;\n            }\n            if (secretHolders.count(meeting[0]) || secretHolders.count(meeting[1])) {\n                secretHolders.insert(meeting[0]);\n                secretHolders.insert(meeting[1]);\n            }\n        }\n        meetings = future_meetings;\n    }\n\n    return vector<int>(secretHolders.begin(), secretHolders.end());\n}\n```\n    \n    The implemented algorithm saves the secret holders in a set called `secretHolders` and initializes it with the `firstPerson`. It then organizes the meetings by time, storing the people who participate in a meeting in a dictionary or an equivalent data structure named `meetingsByTime` where each key is a time `t` and its value is a list of arrays (length 2) that store the people who participate in the meetings at that time.\n\nWe iterate through every time step from 0 to n-1. If there are any meetings at that time step, we iterate through the people involved in each meeting. If either person involved in the meeting is in the set `secretHolders`, we add both people to the set. As a result, at each time step, we spread the secret instantly to everyone having meetings with the current secret holders. After completing the loop, we return the final `secretHolders` set as a list.\n\nIn all languages, the code first initializes a set or similar data structure for the secret holders and then populates it with the first person. Then, it organizes the meetings based on their respective times. The time steps are then iterated, and for each meeting occurring simultaneously, it updates the secret holder set whenever it encounters a secret holder. Finally, the code returns the secret holders as a list.\n    ",
        "js": "\n    ```javascript\nfunction peopleWithSecret(n, meetings, firstPerson) {\n  const secretHolders = new Set([firstPerson]);\n\n  const meetingsByTime = {};\n  for (const meeting of meetings) {\n    if (!(meeting[2] in meetingsByTime)) {\n      meetingsByTime[meeting[2]] = [];\n    }\n    meetingsByTime[meeting[2]].push([meeting[0], meeting[1]]);\n  }\n\n  for (let time = 0; time < n; time++) {\n    if (time in meetingsByTime) {\n      for (const [x, y] of meetingsByTime[time]) {\n        if (secretHolders.has(x) || secretHolders.has(y)) {\n          secretHolders.add(x);\n          secretHolders.add(y);\n        }\n      }\n    }\n  }\n\n  return Array.from(secretHolders);\n}\n```\n    \n    The implemented algorithm saves the secret holders in a set called `secretHolders` and initializes it with the `firstPerson`. It then organizes the meetings by time, storing the people who participate in a meeting in a dictionary or an equivalent data structure named `meetingsByTime` where each key is a time `t` and its value is a list of arrays (length 2) that store the people who participate in the meetings at that time.\n\nWe iterate through every time step from 0 to n-1. If there are any meetings at that time step, we iterate through the people involved in each meeting. If either person involved in the meeting is in the set `secretHolders`, we add both people to the set. As a result, at each time step, we spread the secret instantly to everyone having meetings with the current secret holders. After completing the loop, we return the final `secretHolders` set as a list.\n\nIn all languages, the code first initializes a set or similar data structure for the secret holders and then populates it with the first person. Then, it organizes the meetings based on their respective times. The time steps are then iterated, and for each meeting occurring simultaneously, it updates the secret holder set whenever it encounters a secret holder. Finally, the code returns the secret holders as a list.\n    "
    },
    {
        "id": 376,
        "title": "Maximum Value of K Coins From Piles",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` **piles** of coins on a table. Each pile consists of a **positive number** of coins of assorted denominations.\n\nIn one move, you can choose any coin on **top** of any pile, remove it, and add it to your wallet.\n\nGiven a list `piles`, where `piles[i]` is a list of integers denoting the composition of the `ith` pile from **top to bottom**, and a positive integer `k`, return _the **maximum total value** of coins you can have in your wallet if you choose **exactly**_ `k` _coins optimally_.",
            "examples": [
                "**Example 1:**\n\n**Input:** piles = \\[\\[1,100,3\\],\\[7,8,9\\]\\], k = 2\n**Output:** 101\n**Explanation:**\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\n",
                "**Example 2:**\n\n**Input:** piles = \\[\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[1,1,1,1,1,1,700\\]\\], k = 7\n**Output:** 706\n**Explanation:**\nThe maximum total can be obtained if we choose all coins from the last pile."
            ],
            "constraints": "**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 1000`\n*   `1 <= piles[i][j] <= 105`\n*   `1 <= k <= sum(piles[i].length) <= 2000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[[1,100,3],[7,8,9]],2",
                "output": "101"
            },
            {
                "input": "[[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]],7",
                "output": "706"
            }
        ],
        "java": "\n    ```java\nimport java.util.PriorityQueue;\nimport java.util.List;\n\npublic int maxCoins(List<List<Integer>> piles, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    for (List<Integer> pile : piles) {\n        for (Integer coin : pile) {\n            pq.offer(coin);\n        }\n    }\n    \n    int maxValue = 0;\n    while (k > 0) {\n        maxValue += pq.poll();\n        k--;\n    }\n    return maxValue;\n}\n```\n    \n    1. We use a priority queue (max heap) to keep track of the top coins in each pile. The priority queue will store all the coins from the piles, sorted in descending order.\n2. Iterate through each pile in `piles`. For each coin in the pile, add it to the priority queue.\n3. Initialize `max_value` to 0. While there are still moves allowed (k > 0), pop the top coin (max value coin) from the priority queue, add it to `max_value`, and decrement k.\n4. Return `max_value` as the final result after k moves.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef maxCoins(piles, k):\n    pq = []\n    for pile in piles:\n        for coin in pile:\n            heapq.heappush(pq, -coin)\n    \n    max_value = 0\n    while k > 0:\n        max_value += -heapq.heappop(pq)\n        k -= 1\n    return max_value\n```\n    \n    1. We use a priority queue (max heap) to keep track of the top coins in each pile. The priority queue will store all the coins from the piles, sorted in descending order.\n2. Iterate through each pile in `piles`. For each coin in the pile, add it to the priority queue.\n3. Initialize `max_value` to 0. While there are still moves allowed (k > 0), pop the top coin (max value coin) from the priority queue, add it to `max_value`, and decrement k.\n4. Return `max_value` as the final result after k moves.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint maxCoins(vector<vector<int>>& piles, int k) {\n    priority_queue<int> pq;\n    for (const auto& pile : piles) {\n        for (const auto& coin : pile) {\n            pq.push(coin);\n        }\n    }\n    \n    int max_value = 0;\n    while (k > 0) {\n        max_value += pq.top();\n        pq.pop();\n        k--;\n    }\n    return max_value;\n}\n```\n    \n    1. We use a priority queue (max heap) to keep track of the top coins in each pile. The priority queue will store all the coins from the piles, sorted in descending order.\n2. Iterate through each pile in `piles`. For each coin in the pile, add it to the priority queue.\n3. Initialize `max_value` to 0. While there are still moves allowed (k > 0), pop the top coin (max value coin) from the priority queue, add it to `max_value`, and decrement k.\n4. Return `max_value` as the final result after k moves.\n    ",
        "js": "\n    ```javascript\nfunction maxCoins(piles, k) {\n    let pq = new PriorityQueue((a, b) => b - a);\n    for (let pile of piles) {\n        for (let coin of pile) {\n            pq.enqueue(coin);\n        }\n    }\n    \n    let maxValue = 0;\n    while (k > 0) {\n        maxValue += pq.dequeue();\n        k--;\n    }\n    return maxValue;\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.data = [];\n        this.comparator = comparator;\n    }\n\n    enqueue(element) {\n        this.data.push(element);\n        this.data.sort(this.comparator);\n    }\n\n    dequeue() {\n        return this.data.shift();\n    }\n\n    isEmpty() {\n        return this.data.length === 0;\n    }\n}\n```\n    \n    1. We use a priority queue (max heap) to keep track of the top coins in each pile. The priority queue will store all the coins from the piles, sorted in descending order.\n2. Iterate through each pile in `piles`. For each coin in the pile, add it to the priority queue.\n3. Initialize `max_value` to 0. While there are still moves allowed (k > 0), pop the top coin (max value coin) from the priority queue, add it to `max_value`, and decrement k.\n4. Return `max_value` as the final result after k moves.\n    "
    },
    {
        "id": 377,
        "title": "Encrypt and Decrypt Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a character array `keys` containing **unique** characters and a string array `values` containing strings of length 2. You are also given another string array `dictionary` that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a **0-indexed** string.\n\nA string is **encrypted** with the following process:\n\n1.  For each character `c` in the string, we find the index `i` satisfying `keys[i] == c` in `keys`.\n2.  Replace `c` with `values[i]` in the string.\n\nNote that in case a character of the string is **not present** in `keys`, the encryption process cannot be carried out, and an empty string `\" \"` is returned.\n\nA string is **decrypted** with the following process:\n\n1.  For each substring `s` of length 2 occurring at an even index in the string, we find an `i` such that `values[i] == s`. If there are multiple valid `i`, we choose **any** one of them. This means a string could have multiple possible strings it can decrypt to.\n2.  Replace `s` with `keys[i]` in the string.\n\nImplement the `Encrypter` class:\n\n*   `Encrypter(char[] keys, String[] values, String[] dictionary)` Initializes the `Encrypter` class with `keys, values`, and `dictionary`.\n*   `String encrypt(String word1)` Encrypts `word1` with the encryption process described above and returns the encrypted string.\n*   `int decrypt(String word2)` Returns the number of possible strings `word2` could decrypt to that also appear in `dictionary`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"Encrypter \",  \"encrypt \",  \"decrypt \"\\]\n\\[\\[\\['a', 'b', 'c', 'd'\\], \\[ \"ei \",  \"zf \",  \"ei \",  \"am \"\\], \\[ \"abcd \",  \"acbd \",  \"adbc \",  \"badc \",  \"dacb \",  \"cadb \",  \"cbda \",  \"abad \"\\]\\], \\[ \"abcd \"\\], \\[ \"eizfeiam \"\\]\\]\n**Output**\n\\[null,  \"eizfeiam \", 2\\]\n\n**Explanation**\nEncrypter encrypter = new Encrypter(\\[\\['a', 'b', 'c', 'd'\\], \\[ \"ei \",  \"zf \",  \"ei \",  \"am \"\\], \\[ \"abcd \",  \"acbd \",  \"adbc \",  \"badc \",  \"dacb \",  \"cadb \",  \"cbda \",  \"abad \"\\]);\nencrypter.encrypt( \"abcd \"); // return  \"eizfeiam \". \n                           // 'a' maps to  \"ei \", 'b' maps to  \"zf \", 'c' maps to  \"ei \", and 'd' maps to  \"am \".\nencrypter.decrypt( \"eizfeiam \"); // return 2. \n                              //  \"ei \" can map to 'a' or 'c',  \"zf \" maps to 'b', and  \"am \" maps to 'd'. \n                              // Thus, the possible strings after decryption are  \"abad \",  \"cbad \",  \"abcd \", and  \"cbcd \". \n                              // 2 of those strings,  \"abad \" and  \"abcd \", appear in dictionary, so the answer is 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= keys.length == values.length <= 26`\n*   `values[i].length == 2`\n*   `1 <= dictionary.length <= 100`\n*   `1 <= dictionary[i].length <= 100`\n*   All `keys[i]` and `dictionary[i]` are **unique**.\n*   `1 <= word1.length <= 2000`\n*   `1 <= word2.length <= 200`\n*   All `word1[i]` appear in `keys`.\n*   `word2.length` is even.\n*   `keys`, `values[i]`, `dictionary[i]`, `word1`, and `word2` only contain lowercase English letters.\n*   At most `200` calls will be made to `encrypt` and `decrypt` **in total**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Design",
            "Trie"
        ],
        "example": [
            {
                "input": "]\n],],]],[\"abcd\"],[\"eizfeiam\"]]",
                "output": "**Output**\n[null,\"eizfeiam\",2]"
            }
        ],
        "java": "\n    ```java\npublic int sumOfSubarrayRanges(int[] nums) {\n    int n = nums.length;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            ans += maxElement(nums, i, j) - minElement(nums, i, j);\n        }\n    }\n    return ans;\n}\n\nprivate int maxElement(int[] nums, int start, int end) {\n    int max = nums[start];\n    for (int i = start + 1; i <= end; ++i) {\n        max = Math.max(max, nums[i]);\n    }\n    return max;\n}\n\nprivate int minElement(int[] nums, int start, int end) {\n    int min = nums[start];\n    for (int i = start + 1; i <= end; ++i) {\n        min = Math.min(min, nums[i]);\n    }\n    return min;\n}\n```\n    \n    The algorithm is a straightforward brute force solution which calculates the range of all possible subarrays and then sums them up. The solution iterates through all possible subarray starting positions (i) and ending positions (j), and for each subarray, it computes the maximum and minimum element. The sum of all subarray ranges is updated by incrementing the answer variable by the difference between the maximum and minimum elements (the range) for each subarray. This is implemented similarly in all four languages using nested loops.\n    ",
        "python": "\n    ```python\ndef sum_of_subarray_ranges(nums):\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            ans += max(nums[i:j+1]) - min(nums[i:j+1])\n    return ans\n```\n    \n    The algorithm is a straightforward brute force solution which calculates the range of all possible subarrays and then sums them up. The solution iterates through all possible subarray starting positions (i) and ending positions (j), and for each subarray, it computes the maximum and minimum element. The sum of all subarray ranges is updated by incrementing the answer variable by the difference between the maximum and minimum elements (the range) for each subarray. This is implemented similarly in all four languages using nested loops.\n    ",
        "c++": "\n    ```cpp\nint sumOfSubarrayRanges(vector<int>& nums) {\n    int n = nums.size();\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            ans += *max_element(nums.begin() + i, nums.begin() + j + 1) -\n                   *min_element(nums.begin() + i, nums.begin() + j + 1);\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm is a straightforward brute force solution which calculates the range of all possible subarrays and then sums them up. The solution iterates through all possible subarray starting positions (i) and ending positions (j), and for each subarray, it computes the maximum and minimum element. The sum of all subarray ranges is updated by incrementing the answer variable by the difference between the maximum and minimum elements (the range) for each subarray. This is implemented similarly in all four languages using nested loops.\n    ",
        "js": "\n    ```javascript\nfunction sumOfSubarrayRanges(nums) {\n    let n = nums.length;\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i; j < n; ++j) {\n            ans += Math.max(...nums.slice(i, j + 1)) - Math.min(...nums.slice(i, j + 1));\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm is a straightforward brute force solution which calculates the range of all possible subarrays and then sums them up. The solution iterates through all possible subarray starting positions (i) and ending positions (j), and for each subarray, it computes the maximum and minimum element. The sum of all subarray ranges is updated by incrementing the answer variable by the difference between the maximum and minimum elements (the range) for each subarray. This is implemented similarly in all four languages using nested loops.\n    "
    },
    {
        "id": 378,
        "title": "Maximum Total Beauty of the Gardens",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice is a caretaker of `n` gardens and she wants to plant flowers to maximize the total beauty of all her gardens.\n\nYou are given a **0-indexed** integer array `flowers` of size `n`, where `flowers[i]` is the number of flowers already planted in the `ith` garden. Flowers that are already planted **cannot** be removed. You are then given another integer `newFlowers`, which is the **maximum** number of flowers that Alice can additionally plant. You are also given the integers `target`, `full`, and `partial`.\n\nA garden is considered **complete** if it has **at least** `target` flowers. The **total beauty** of the gardens is then determined as the **sum** of the following:\n\n*   The number of **complete** gardens multiplied by `full`.\n*   The **minimum** number of flowers in any of the **incomplete** gardens multiplied by `partial`. If there are no incomplete gardens, then this value will be `0`.\n\nReturn _the **maximum** total beauty that Alice can obtain after planting at most_ `newFlowers` _flowers._",
            "examples": [
                "**Example 1:**\n\n**Input:** flowers = \\[1,3,1,1\\], newFlowers = 7, target = 6, full = 12, partial = 1\n**Output:** 14\n**Explanation:** Alice can plant\n- 2 flowers in the 0th garden\n- 3 flowers in the 1st garden\n- 1 flower in the 2nd garden\n- 1 flower in the 3rd garden\nThe gardens will then be \\[3,6,2,2\\]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\nThere is 1 garden that is complete.\nThe minimum number of flowers in the incomplete gardens is 2.\nThus, the total beauty is 1 \\* 12 + 2 \\* 1 = 12 + 2 = 14.\nNo other way of planting flowers can obtain a total beauty higher than 14.\n\n",
                "**Example 2:**\n\n**Input:** flowers = \\[2,4,5,3\\], newFlowers = 10, target = 5, full = 2, partial = 6\n**Output:** 30\n**Explanation:** Alice can plant\n- 3 flowers in the 0th garden\n- 0 flowers in the 1st garden\n- 0 flowers in the 2nd garden\n- 2 flowers in the 3rd garden\nThe gardens will then be \\[5,4,5,5\\]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\nThere are 3 gardens that are complete.\nThe minimum number of flowers in the incomplete gardens is 4.\nThus, the total beauty is 3 \\* 2 + 4 \\* 6 = 6 + 24 = 30.\nNo other way of planting flowers can obtain a total beauty higher than 30.\nNote that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= flowers.length <= 105`\n*   `1 <= flowers[i], target <= 105`\n*   `1 <= newFlowers <= 1010`\n*   `1 <= full, partial <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,3,1,1],7,6,12,1",
                "output": "14"
            },
            {
                "input": "[2,4,5,3],10,5,2,6",
                "output": "30"
            }
        ],
        "java": "\n    ```java\nint minOperationsToKIncreasing(int[] arr, int k) {\n    int operations = 0;\n    for (int i = k; i < arr.length; i++) {\n        if (arr[i] <= arr[i - k]) {\n            operations += (arr[i - k] - arr[i] + 1);\n            arr[i] = arr[i - k] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    To make the array K-increasing, we iterate through the array, starting from index k.\nFor each index i, if the condition arr[i-k] > arr[i] does not hold, it means that we need to change the value of arr[i] to make it K-increasing. So, we calculate the difference between the elements arr[i-k] and arr[i], add 1 to the result, and then update the value of arr[i] by adding the calculated difference to arr[i-k]. We also increment our operations counter by the same difference value.\nThis will ensure that the array is K-increasing and keeps track of the minimum number of operations required to change the array. We continue iterating through the array until the last element and return the total number of operations in the end.\n    ",
        "python": "\n    ```python\ndef min_operations_to_K_increasing(arr, k):\n    operations = 0\n    for i in range(k, len(arr)):\n        if arr[i] <= arr[i - k]:\n            operations += (arr[i - k] - arr[i] + 1)\n            arr[i] = arr[i - k] + 1\n    return operations\n```\n    \n    To make the array K-increasing, we iterate through the array, starting from index k.\nFor each index i, if the condition arr[i-k] > arr[i] does not hold, it means that we need to change the value of arr[i] to make it K-increasing. So, we calculate the difference between the elements arr[i-k] and arr[i], add 1 to the result, and then update the value of arr[i] by adding the calculated difference to arr[i-k]. We also increment our operations counter by the same difference value.\nThis will ensure that the array is K-increasing and keeps track of the minimum number of operations required to change the array. We continue iterating through the array until the last element and return the total number of operations in the end.\n    ",
        "c++": "\n    ```cpp\nint min_operations_to_K_increasing(vector<int>& arr, int k) {\n    int operations = 0;\n    for (int i = k; i < arr.size(); i++) {\n        if (arr[i] <= arr[i - k]) {\n            operations += (arr[i - k] - arr[i] + 1);\n            arr[i] = arr[i - k] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    To make the array K-increasing, we iterate through the array, starting from index k.\nFor each index i, if the condition arr[i-k] > arr[i] does not hold, it means that we need to change the value of arr[i] to make it K-increasing. So, we calculate the difference between the elements arr[i-k] and arr[i], add 1 to the result, and then update the value of arr[i] by adding the calculated difference to arr[i-k]. We also increment our operations counter by the same difference value.\nThis will ensure that the array is K-increasing and keeps track of the minimum number of operations required to change the array. We continue iterating through the array until the last element and return the total number of operations in the end.\n    ",
        "js": "\n    ```javascript\nfunction minOperationsToKIncreasing(arr, k) {\n    let operations = 0;\n    for (let i = k; i < arr.length; i++) {\n        if (arr[i] <= arr[i - k]) {\n            operations += (arr[i - k] - arr[i] + 1);\n            arr[i] = arr[i - k] + 1;\n        }\n    }\n    return operations;\n}\n```\n    \n    To make the array K-increasing, we iterate through the array, starting from index k.\nFor each index i, if the condition arr[i-k] > arr[i] does not hold, it means that we need to change the value of arr[i] to make it K-increasing. So, we calculate the difference between the elements arr[i-k] and arr[i], add 1 to the result, and then update the value of arr[i] by adding the calculated difference to arr[i-k]. We also increment our operations counter by the same difference value.\nThis will ensure that the array is K-increasing and keeps track of the minimum number of operations required to change the array. We continue iterating through the array until the last element and return the total number of operations in the end.\n    "
    },
    {
        "id": 379,
        "title": "Maximum Score of a Node Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an **undirected** graph with `n` nodes, numbered from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `scores` of length `n` where `scores[i]` denotes the score of node `i`. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA node sequence is **valid** if it meets the following conditions:\n\n*   There is an edge connecting every pair of **adjacent** nodes in the sequence.\n*   No node appears more than once in the sequence.\n\nThe score of a node sequence is defined as the **sum** of the scores of the nodes in the sequence.\n\nReturn _the **maximum score** of a valid node sequence with a length of_ `4`_._ If no such sequence exists, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** scores = \\[5,2,9,8,4\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[0,2\\],\\[1,3\\],\\[2,4\\]\\]\n**Output:** 24\n**Explanation:** The figure above shows the graph and the chosen node sequence \\[0,1,2,3\\].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences \\[3,1,2,0\\] and \\[1,0,2,3\\] are also valid and have a score of 24.\nThe sequence \\[0,3,2,4\\] is not valid since no edge connects nodes 0 and 3.\n\n",
                "**Example 2:**\n\n**Input:** scores = \\[9,20,6,4,11,12\\], edges = \\[\\[0,3\\],\\[5,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `n == scores.length`\n*   `4 <= n <= 5 * 104`\n*   `1 <= scores[i] <= 108`\n*   `0 <= edges.length <= 5 * 104`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   There are no duplicate edges.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Graph",
            "Sorting",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[5,2,9,8,4],[[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]",
                "output": "24"
            },
            {
                "input": "[9,20,6,4,11,12],[[0,3],[5,3],[2,4],[1,3]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int maxScore(int[] scores, int[][] edges) {\n    ArrayList<ArrayList<Integer>> adj_list = new ArrayList<>(scores.length);\n    for (int i = 0; i < scores.length; i++) {\n        adj_list.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        adj_list.get(edge[0]).add(edge[1]);\n        adj_list.get(edge[1]).add(edge[0]);\n    }\n\n    int result = -1;\n    for (int[] edge : edges) {\n        for (int neighbor : adj_list.get(edge[0])) {\n            for (int next : adj_list.get(edge[1])) {\n                if (next != neighbor && next != edge[0]) {\n                    result = Math.max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next]);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm first constructs an adjacency list from the given edges. An adjacency list is a data structure where each node is associated with a list of its neighboring nodes. Then, for each edge in the given graph, it checks all possible combinations of reachable nodes and calculates the sum of their scores, updating the result with the maximum score found. If no valid combination is found, the function returns -1 as specified.\n    ",
        "python": "\n    ```python\ndef maxScore(scores, edges):\n    adj_list = [[] for _ in range(len(scores))]\n    result = -1\n\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    for edge in edges:\n        for neighbor in adj_list[edge[0]]:\n            for next in adj_list[edge[1]]:\n                if next != neighbor and next != edge[0]:\n                    result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next])\n\n    return result\n```\n\n    \n    The algorithm first constructs an adjacency list from the given edges. An adjacency list is a data structure where each node is associated with a list of its neighboring nodes. Then, for each edge in the given graph, it checks all possible combinations of reachable nodes and calculates the sum of their scores, updating the result with the maximum score found. If no valid combination is found, the function returns -1 as specified.\n    ",
        "c++": "\n    ```cpp\nint maxScore(vector<int>& scores, vector<vector<int>>& edges) {\n    vector<vector<int>> adj_list(scores.size());\n    int result = -1;\n    \n    for (const auto& edge : edges) {\n        adj_list[edge[0]].push_back(edge[1]);\n        adj_list[edge[1]].push_back(edge[0]);\n    }\n    \n    for (const auto& edge : edges) {\n        for (int neighbor : adj_list[edge[0]]) {\n            for (int next : adj_list[edge[1]]) {\n                if (next != neighbor && next != edge[0]) {\n                    result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next]);\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    The algorithm first constructs an adjacency list from the given edges. An adjacency list is a data structure where each node is associated with a list of its neighboring nodes. Then, for each edge in the given graph, it checks all possible combinations of reachable nodes and calculates the sum of their scores, updating the result with the maximum score found. If no valid combination is found, the function returns -1 as specified.\n    ",
        "js": "\n    ```javascript\nfunction maxScore(scores, edges) {\n    const adj_list = new Array(scores.length).fill(null).map(() => []);\n    let result = -1;\n\n    for (const edge of edges) {\n        adj_list[edge[0]].push(edge[1]);\n        adj_list[edge[1]].push(edge[0]);\n    }\n\n    for (const edge of edges) {\n        for (const neighbor of adj_list[edge[0]]) {\n            for (const next of adj_list[edge[1]]) {\n                if (next !== neighbor && next !== edge[0]) {\n                    result = Math.max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next]);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm first constructs an adjacency list from the given edges. An adjacency list is a data structure where each node is associated with a list of its neighboring nodes. Then, for each edge in the given graph, it checks all possible combinations of reachable nodes and calculates the sum of their scores, updating the result with the maximum score found. If no valid combination is found, the function returns -1 as specified.\n    "
    },
    {
        "id": 380,
        "title": "Longest Path With Different Adjacent Characters",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **tree** (i.e. a connected, undirected graph that has no cycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n - 1`. The tree is represented by a **0-indexed** array `parent` of size `n`, where `parent[i]` is the parent of node `i`. Since node `0` is the root, `parent[0] == -1`.\n\nYou are also given a string `s` of length `n`, where `s[i]` is the character assigned to node `i`.\n\nReturn _the length of the **longest path** in the tree such that no pair of **adjacent** nodes on the path have the same character assigned to them._",
            "examples": [
                "**Example 1:**\n\n**Input:** parent = \\[-1,0,0,1,1,2\\], s =  \"abacbe \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\n",
                "**Example 2:**\n\n**Input:** parent = \\[-1,0,0,0\\], s =  \"aabc \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `n == parent.length == s.length`\n*   `1 <= n <= 105`\n*   `0 <= parent[i] <= n - 1` for all `i >= 1`\n*   `parent[0] == -1`\n*   `parent` represents a valid tree.\n*   `s` consists of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Tree",
            "Depth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "[-1,0,0,1,1,2],\"abacbe\"",
                "output": "3"
            },
            {
                "input": "[-1,0,0,0],\"aabc\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int maxInvites(int[] favorite) {\n    int n = favorite.length;\n    int[] dp = new int[n];\n    int maxInvites = 0;\n\n    for (int i = 0; i < n; i++) {\n        dp[i] = (i == favorite[favorite[i]]) ? 2 : 1;\n        maxInvites = Math.max(maxInvites, dp[i]);\n    }\n\n    return maxInvites;\n}\n```\n\n    \n    The algorithm consists of iterating through the list of favorite employees and checking if the favorite person of the current employee also has the current employee as their favorite. In that case, both can be invited to the meeting, as they can sit next to each other. For simplicity, use an array `dp` to store the number of invitees for each employee. If they can be invited together with their favorite person, set `dp[i] = 2`. Otherwise, set `dp[i] = 1`, as they can't be invited with their favorite person.\n\nFinally, iterate through the `dp` array and find the maximum number of employees that can be invited to the meeting. Return this value. \n    ",
        "python": "\n    ```python\ndef max_invites(favorite):\n    n = len(favorite)\n    dp = [0] * n\n    max_invites = 0\n\n    for i in range(n):\n        dp[i] = 2 if i == favorite[favorite[i]] else 1\n        max_invites = max(max_invites, dp[i])\n\n    return max_invites\n```\n\n    \n    The algorithm consists of iterating through the list of favorite employees and checking if the favorite person of the current employee also has the current employee as their favorite. In that case, both can be invited to the meeting, as they can sit next to each other. For simplicity, use an array `dp` to store the number of invitees for each employee. If they can be invited together with their favorite person, set `dp[i] = 2`. Otherwise, set `dp[i] = 1`, as they can't be invited with their favorite person.\n\nFinally, iterate through the `dp` array and find the maximum number of employees that can be invited to the meeting. Return this value. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint maxInvites(std::vector<int>& favorite) {\n    int n = favorite.size();\n    std::vector<int> dp(n, 0);\n    int max_invites = 0;\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = (i == favorite[favorite[i]]) ? 2 : 1;\n        max_invites = std::max(max_invites, dp[i]);\n    }\n\n    return max_invites;\n}\n```\n\n    \n    The algorithm consists of iterating through the list of favorite employees and checking if the favorite person of the current employee also has the current employee as their favorite. In that case, both can be invited to the meeting, as they can sit next to each other. For simplicity, use an array `dp` to store the number of invitees for each employee. If they can be invited together with their favorite person, set `dp[i] = 2`. Otherwise, set `dp[i] = 1`, as they can't be invited with their favorite person.\n\nFinally, iterate through the `dp` array and find the maximum number of employees that can be invited to the meeting. Return this value. \n    ",
        "js": "\n    ```javascript\nfunction maxInvites(favorite) {\n    const n = favorite.length;\n    const dp = new Array(n).fill(0);\n    let maxInvites = 0;\n\n    for (let i = 0; i < n; i++) {\n        dp[i] = (i === favorite[favorite[i]]) ? 2 : 1;\n        maxInvites = Math.max(maxInvites, dp[i]);\n    }\n\n    return maxInvites;\n}\n```\n\n    \n    The algorithm consists of iterating through the list of favorite employees and checking if the favorite person of the current employee also has the current employee as their favorite. In that case, both can be invited to the meeting, as they can sit next to each other. For simplicity, use an array `dp` to store the number of invitees for each employee. If they can be invited together with their favorite person, set `dp[i] = 2`. Otherwise, set `dp[i] = 1`, as they can't be invited with their favorite person.\n\nFinally, iterate through the `dp` array and find the maximum number of employees that can be invited to the meeting. Return this value. \n    "
    },
    {
        "id": 381,
        "title": "Number of Flowers in Full Bloom",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `flowers`, where `flowers[i] = [starti, endi]` means the `ith` flower will be in **full bloom** from `starti` to `endi` (**inclusive**). You are also given a **0-indexed** integer array `people` of size `n`, where `poeple[i]` is the time that the `ith` person will arrive to see the flowers.\n\nReturn _an integer array_ `answer` _of size_ `n`_, where_ `answer[i]` _is the **number** of flowers that are in full bloom when the_ `ith` _person arrives._",
            "examples": [
                "**Example 1:**\n\n**Input:** flowers = \\[\\[1,6\\],\\[3,7\\],\\[9,12\\],\\[4,13\\]\\], poeple = \\[2,3,7,11\\]\n**Output:** \\[1,2,2,2\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n",
                "**Example 2:**\n\n**Input:** flowers = \\[\\[1,10\\],\\[3,3\\]\\], poeple = \\[3,3,2\\]\n**Output:** \\[2,2,1\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= flowers.length <= 5 * 104`\n*   `flowers[i].length == 2`\n*   `1 <= starti <= endi <= 109`\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Sorting",
            "Prefix Sum",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[[1,6],[3,7],[9,12],[4,13]],[2,3,7,11]",
                "output": "[1,2,2,2]"
            },
            {
                "input": "[[1,10],[3,3]],[3,3,2]",
                "output": "[2,2,1]"
            }
        ],
        "java": "\n    ```java\npublic class Solution {\n    final static int MOD = 1000000007;\n\n    public static int corridorWays(String corridor) {\n        int n = corridor.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n\n        int seats = 0;\n        for (int i = 0; i < n; i++) {\n            if (corridor.charAt(i) == 'S') {\n                seats++;\n                if (seats % 2 == 0) {\n                    dp[i + 1] = dp[Math.max(0, i - 1)];\n                }\n                dp[i + 1] = (dp[i] + dp[i + 1]) % MOD;\n            } else {\n                dp[i + 1] = dp[i];\n            }\n        }\n\n        return dp[n];\n    }\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to divide the corridor. We use an array `dp` of length `n + 1`, where `dp[i]` represents the number of ways to divide the section of the corridor from index `0` to index `i - 1`. The base case is `dp[0] = 1`, as there is always one way to divide the empty corridor.\n\nThe main loop iterates through the corridor, updating the `dp` array depending on whether the element at index `i` is a seat ('S') or a plant ('P'). If the element is a seat, we first count the number of seats encountered so far (stored in the variable `seats`). If the number of seats is even, we update `dp[i + 1]` to `dp[max(0, i - 1)]`. Then, we add `dp[i]` to `dp[i + 1]` and take the remainder modulo `10^9 + 7`. If the element is a plant, we simply set `dp[i + 1]` to `dp[i]`.\n\nFinally, we return the result `dp[n]`.\n    ",
        "python": "\n    ```python\nMOD = 10**9 + 7\n\ndef corridor_ways(corridor):\n    n = len(corridor)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    seats = 0\n    for i in range(n):\n        if corridor[i] == 'S':\n            seats += 1\n            if seats % 2 == 0:\n                dp[i + 1] = dp[max(0, i - 1)]\n            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        else:\n            dp[i + 1] = dp[i]\n\n    return dp[n]\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to divide the corridor. We use an array `dp` of length `n + 1`, where `dp[i]` represents the number of ways to divide the section of the corridor from index `0` to index `i - 1`. The base case is `dp[0] = 1`, as there is always one way to divide the empty corridor.\n\nThe main loop iterates through the corridor, updating the `dp` array depending on whether the element at index `i` is a seat ('S') or a plant ('P'). If the element is a seat, we first count the number of seats encountered so far (stored in the variable `seats`). If the number of seats is even, we update `dp[i + 1]` to `dp[max(0, i - 1)]`. Then, we add `dp[i]` to `dp[i + 1]` and take the remainder modulo `10^9 + 7`. If the element is a plant, we simply set `dp[i + 1]` to `dp[i]`.\n\nFinally, we return the result `dp[n]`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint corridorWays(string corridor) {\n    int n = corridor.size();\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n\n    int seats = 0;\n    for (int i = 0; i < n; i++) {\n        if (corridor[i] == 'S') {\n            seats++;\n            if (seats % 2 == 0) {\n                dp[i + 1] = dp[max(0, i - 1)];\n            }\n            dp[i + 1] = (dp[i + 1] + dp[i]) % MOD;\n        } else {\n            dp[i + 1] = dp[i];\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to divide the corridor. We use an array `dp` of length `n + 1`, where `dp[i]` represents the number of ways to divide the section of the corridor from index `0` to index `i - 1`. The base case is `dp[0] = 1`, as there is always one way to divide the empty corridor.\n\nThe main loop iterates through the corridor, updating the `dp` array depending on whether the element at index `i` is a seat ('S') or a plant ('P'). If the element is a seat, we first count the number of seats encountered so far (stored in the variable `seats`). If the number of seats is even, we update `dp[i + 1]` to `dp[max(0, i - 1)]`. Then, we add `dp[i]` to `dp[i + 1]` and take the remainder modulo `10^9 + 7`. If the element is a plant, we simply set `dp[i + 1]` to `dp[i]`.\n\nFinally, we return the result `dp[n]`.\n    ",
        "js": "\n    ```javascript\nconst MOD = 10**9 + 7;\n\nfunction corridorWays(corridor) {\n    const n = corridor.length;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n\n    let seats = 0;\n    for (let i = 0; i < n; i++) {\n        if (corridor[i] === 'S') {\n            seats++;\n            if (seats % 2 === 0) {\n                dp[i + 1] = dp[Math.max(0, i - 1)];\n            }\n            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD;\n        } else {\n            dp[i + 1] = dp[i];\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to divide the corridor. We use an array `dp` of length `n + 1`, where `dp[i]` represents the number of ways to divide the section of the corridor from index `0` to index `i - 1`. The base case is `dp[0] = 1`, as there is always one way to divide the empty corridor.\n\nThe main loop iterates through the corridor, updating the `dp` array depending on whether the element at index `i` is a seat ('S') or a plant ('P'). If the element is a seat, we first count the number of seats encountered so far (stored in the variable `seats`). If the number of seats is even, we update `dp[i + 1]` to `dp[max(0, i - 1)]`. Then, we add `dp[i]` to `dp[i + 1]` and take the remainder modulo `10^9 + 7`. If the element is a plant, we simply set `dp[i + 1]` to `dp[i]`.\n\nFinally, we return the result `dp[n]`.\n    "
    },
    {
        "id": 382,
        "title": "Escape the Spreading Fire",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Breadth-First Search",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]",
                "output": "3"
            },
            {
                "input": "[[0,0,0,0],[0,1,2,0],[0,2,0,0]]",
                "output": "-1"
            },
            {
                "input": "[[0,0,0],[2,2,0],[1,2,0]]",
                "output": "1000000000"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    private static final int[] dx = {0, 1, 0, -1};\n    private static final int[] dy = {1, 0, -1, 0};\n\n    public int getMaxSafeMinutes(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(dist[i], -1);\n        }\n        Queue<int[]> q = new ArrayDeque<>();\n\n        if (grid[m - 1][n - 1] != 1) {\n            dist[m - 1][n - 1] = 0;\n            q.add(new int[]{m - 1, n - 1});\n        }\n\n        while (!q.isEmpty()) {\n            int[] curr = q.poll();\n            int x = curr[0];\n            int y = curr[1];\n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0 && dist[nx][ny] == -1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.add(new int[]{nx, ny});\n                }\n            }\n        }\n\n        if (dist[0][0] == -1) return -1;\n\n        int res = 0;\n        for (int test = dist[0][0]; test < 1e9; test++) {\n            boolean ok = true;\n            for (int x = 0; x < m; x++) {\n                for (int y = 0; y < n; y++) {\n                    if (grid[x][y] == 1) {\n...\n```    \n    The algorithm first calculates the distance from every cell to the safehouse. This is done with Breadth-First Search (BFS) from the safehouse, treating only grass cells as reachable. Cells in the dist matrix marked with -1 are either unreachable or walls/fire cells.\n\nNext, the algorithm iterates through possible time steps (test) that the character could wait, starting from the time required to reach the safehouse without waiting (dist[0][0]). For each time step, the algorithm checks if the character could complete the path to the safehouse without encountering fire. The character is safe from fire only if the fire is separated by a wall (grid[nx][ny] == 2). As soon as there is no wall between the fire and the character, the algorithm breaks the loop and returns the current minimum waiting time.\n\nIn case the character never encounters fire on the path to the safehouse, the algorithm returns 10^9 (always safe). If the character can't reach the safehouse at all, the algorithm returns -1.\n\nPlease note that this solution may have slight variations or differences in syntax and style between languages to adapt to their specific requirements and best practices.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res\n```    \n    The algorithm first calculates the distance from every cell to the safehouse. This is done with Breadth-First Search (BFS) from the safehouse, treating only grass cells as reachable. Cells in the dist matrix marked with -1 are either unreachable or walls/fire cells.\n\nNext, the algorithm iterates through possible time steps (test) that the character could wait, starting from the time required to reach the safehouse without waiting (dist[0][0]). For each time step, the algorithm checks if the character could complete the path to the safehouse without encountering fire. The character is safe from fire only if the fire is separated by a wall (grid[nx][ny] == 2). As soon as there is no wall between the fire and the character, the algorithm breaks the loop and returns the current minimum waiting time.\n\nIn case the character never encounters fire on the path to the safehouse, the algorithm returns 10^9 (always safe). If the character can't reach the safehouse at all, the algorithm returns -1.\n\nPlease note that this solution may have slight variations or differences in syntax and style between languages to adapt to their specific requirements and best practices.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint getMaxSafeMinutes(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n\n    vector<vector<int>> dist(m, vector<int>(n, -1));\n    queue<pair<int, int>> q;\n\n    if (grid[m - 1][n - 1] != 1) {\n        dist[m - 1][n - 1] = 0;\n        q.push({m - 1, n - 1});\n    }\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0 && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    if (dist[0][0] == -1) return -1;\n\n    int res = 0;\n    for (int test = dist[0][0]; test < (int)1e9; test++) {\n        bool ok = true;\n        for (int x = 0; x < m; x++) {\n            for (int y = 0; y < n; y++) {\n                if (grid[x][y] == 1) {\n...\n```    \n    The algorithm first calculates the distance from every cell to the safehouse. This is done with Breadth-First Search (BFS) from the safehouse, treating only grass cells as reachable. Cells in the dist matrix marked with -1 are either unreachable or walls/fire cells.\n\nNext, the algorithm iterates through possible time steps (test) that the character could wait, starting from the time required to reach the safehouse without waiting (dist[0][0]). For each time step, the algorithm checks if the character could complete the path to the safehouse without encountering fire. The character is safe from fire only if the fire is separated by a wall (grid[nx][ny] == 2). As soon as there is no wall between the fire and the character, the algorithm breaks the loop and returns the current minimum waiting time.\n\nIn case the character never encounters fire on the path to the safehouse, the algorithm returns 10^9 (always safe). If the character can't reach the safehouse at all, the algorithm returns -1.\n\nPlease note that this solution may have slight variations or differences in syntax and style between languages to adapt to their specific requirements and best practices.\n    ",
        "js": "\n    ```javascript\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nfunction getMaxSafeMinutes(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dist = Array.from({length: m}, () => Array(n).fill(-1));\n    const q = [];\n\n    if (grid[m - 1][n - 1] !== 1) {\n        dist[m - 1][n - 1] = 0;\n        q.push([m - 1, n - 1]);\n    }\n\n    while (q.length > 0) {\n        const [x, y] = q.shift();\n        for (let d = 0; d < 4; d++) {\n            const nx = x + dx[d];\n            const ny = y + dy[d];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] === 0 && dist[nx][ny] === -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push([nx, ny]);\n            }\n        }\n    }\n\n    if (dist[0][0] === -1) return -1;\n\n    let res = 0;\n    for (let test = dist[0][0]; test < 1e9; test++) {\n        let ok = true;\n        for (let x = 0; x < m; x++) {\n            for (let y = 0; y < n; y++) {\n                if (grid[x][y] === 1) {\n                    for (let d = 0; d < 4; d++) {\n                        const nx = x + dx[d];\n                        const ny = y + dy[d];\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] === 2) {\n                            break;\n                        }\n                    }\n                    if (d === 4) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            if (!ok) break;\n        }\n        if (ok) {\n            res = test;\n        } else {\n            break;\n        }\n    }\n    return res;\n}\n```    \n    The algorithm first calculates the distance from every cell to the safehouse. This is done with Breadth-First Search (BFS) from the safehouse, treating only grass cells as reachable. Cells in the dist matrix marked with -1 are either unreachable or walls/fire cells.\n\nNext, the algorithm iterates through possible time steps (test) that the character could wait, starting from the time required to reach the safehouse without waiting (dist[0][0]). For each time step, the algorithm checks if the character could complete the path to the safehouse without encountering fire. The character is safe from fire only if the fire is separated by a wall (grid[nx][ny] == 2). As soon as there is no wall between the fire and the character, the algorithm breaks the loop and returns the current minimum waiting time.\n\nIn case the character never encounters fire on the path to the safehouse, the algorithm returns 10^9 (always safe). If the character can't reach the safehouse at all, the algorithm returns -1.\n\nPlease note that this solution may have slight variations or differences in syntax and style between languages to adapt to their specific requirements and best practices.\n    "
    },
    {
        "id": 383,
        "title": "Total Appeal of A String",
        "difficulty": "Hard",
        "content": {
            "problem": "The **appeal** of a string is the number of **distinct** characters found in the string.\n\n*   For example, the appeal of `\"abbca \"` is `3` because it has `3` distinct characters: `'a'`, `'b'`, and `'c'`.\n\nGiven a string `s`, return _the **total appeal of all of its **substrings**.**_\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abbca \"\n**Output:** 28\n**Explanation:** The following are the substrings of  \"abbca \":\n- Substrings of length 1:  \"a \",  \"b \",  \"b \",  \"c \",  \"a \" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.\n- Substrings of length 2:  \"ab \",  \"bb \",  \"bc \",  \"ca \" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.\n- Substrings of length 3:  \"abb \",  \"bbc \",  \"bca \" have an appeal of 2, 2, and 3 respectively. The sum is 7.\n- Substrings of length 4:  \"abbc \",  \"bbca \" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 5:  \"abbca \" has an appeal of 3. The sum is 3.\nThe total sum is 5 + 7 + 7 + 6 + 3 = 28.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"code \"\n**Output:** 20\n**Explanation:** The following are the substrings of  \"code \":\n- Substrings of length 1:  \"c \",  \"o \",  \"d \",  \"e \" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.\n- Substrings of length 2:  \"co \",  \"od \",  \"de \" have an appeal of 2, 2, and 2 respectively. The sum is 6.\n- Substrings of length 3:  \"cod \",  \"ode \" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 4:  \"code \" has an appeal of 4. The sum is 4.\nThe total sum is 4 + 6 + 6 + 4 = 20."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"abbca\"",
                "output": "28"
            },
            {
                "input": "\"code\"",
                "output": "20"
            }
        ],
        "java": "\n    ```java\npublic int maxPoints(int[][] questions) {\n    int n = questions.length;\n    int[] dp = new int[n + 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        int skip_next = i + questions[i][1];\n        dp[i] = Math.max(dp[i + 1], questions[i][0] + (skip_next < n ? dp[skip_next] : 0));\n    }\n\n    return dp[0];\n}\n```\n\n    \n    We use dynamic programming to solve the problem. We create an array `dp` of size `n+1` to store the maximum points we can earn for each question. We initialize the array elements to 0.\n\nWe iterate through the questions in reverse order, starting from the last question. For each question `i`, we calculate the index `skip_next` by adding the current index and the `brainpower` value of the question. We update the `dp[i]` value with the maximum between `dp[i+1]` (if we skip the current question) and `questions[i][0] + (dp[skip_next] if skip_next < n else 0)` (if we solve the current question).\n\nFinally, we return the maximum points we can earn, which is stored in `dp[0]`.\n    ",
        "python": "\n    ```python\ndef max_points(questions):\n    n = len(questions)\n    dp = [0] * (n + 1)\n\n    for i in range(n - 1, -1, -1):\n        skip_next = i + questions[i][1]\n        dp[i] = max(dp[i + 1], questions[i][0] + (dp[skip_next] if skip_next < n else 0))\n\n    return dp[0]\n```\n\n    \n    We use dynamic programming to solve the problem. We create an array `dp` of size `n+1` to store the maximum points we can earn for each question. We initialize the array elements to 0.\n\nWe iterate through the questions in reverse order, starting from the last question. For each question `i`, we calculate the index `skip_next` by adding the current index and the `brainpower` value of the question. We update the `dp[i]` value with the maximum between `dp[i+1]` (if we skip the current question) and `questions[i][0] + (dp[skip_next] if skip_next < n else 0)` (if we solve the current question).\n\nFinally, we return the maximum points we can earn, which is stored in `dp[0]`.\n    ",
        "c++": "\n    ```cpp\nint maxPoints(vector<vector<int>>& questions) {\n    int n = questions.size();\n    vector<int> dp(n + 1, 0);\n\n    for (int i = n - 1; i >= 0; i--) {\n        int skip_next = i + questions[i][1];\n        dp[i] = max(dp[i + 1], questions[i][0] + (skip_next < n ? dp[skip_next] : 0));\n    }\n\n    return dp[0];\n}\n```\n\n    \n    We use dynamic programming to solve the problem. We create an array `dp` of size `n+1` to store the maximum points we can earn for each question. We initialize the array elements to 0.\n\nWe iterate through the questions in reverse order, starting from the last question. For each question `i`, we calculate the index `skip_next` by adding the current index and the `brainpower` value of the question. We update the `dp[i]` value with the maximum between `dp[i+1]` (if we skip the current question) and `questions[i][0] + (dp[skip_next] if skip_next < n else 0)` (if we solve the current question).\n\nFinally, we return the maximum points we can earn, which is stored in `dp[0]`.\n    ",
        "js": "\n    ```javascript\nfunction maxPoints(questions) {\n    const n = questions.length;\n    const dp = new Array(n + 1).fill(0);\n\n    for (let i = n - 1; i >= 0; i--) {\n        const skip_next = i + questions[i][1];\n        dp[i] = Math.max(dp[i + 1], questions[i][0] + (skip_next < n ? dp[skip_next] : 0));\n    }\n\n    return dp[0];\n}\n```\n\n    \n    We use dynamic programming to solve the problem. We create an array `dp` of size `n+1` to store the maximum points we can earn for each question. We initialize the array elements to 0.\n\nWe iterate through the questions in reverse order, starting from the last question. For each question `i`, we calculate the index `skip_next` by adding the current index and the `brainpower` value of the question. We update the `dp[i]` value with the maximum between `dp[i+1]` (if we skip the current question) and `questions[i][0] + (dp[skip_next] if skip_next < n else 0)` (if we solve the current question).\n\nFinally, we return the maximum points we can earn, which is stored in `dp[0]`.\n    "
    },
    {
        "id": 384,
        "title": " Check if There Is a Valid Parentheses String Path",
        "difficulty": "Hard",
        "content": {
            "problem": "A parentheses string is a **non-empty** string consisting only of `'('` and `')'`. It is **valid** if **any** of the following conditions is **true**:\n\n*   It is `()`.\n*   It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid parentheses strings.\n*   It can be written as `(A)`, where `A` is a valid parentheses string.\n\nYou are given an `m x n` matrix of parentheses `grid`. A **valid parentheses string path** in the grid is a path satisfying **all** of the following conditions:\n\n*   The path starts from the upper left cell `(0, 0)`.\n*   The path ends at the bottom-right cell `(m - 1, n - 1)`.\n*   The path only ever moves **down** or **right**.\n*   The resulting parentheses string formed by the path is **valid**.\n\nReturn `true` _if there exists a **valid parentheses string path** in the grid._ Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[ \"( \", \"( \", \"( \"\\],\\[ \") \", \"( \", \") \"\\],\\[ \"( \", \"( \", \") \"\\],\\[ \"( \", \"( \", \") \"\\]\\]\n**Output:** true\n**Explanation:** The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string  \"()(()) \".\nThe second path shown results in the valid parentheses string  \"((())) \".\nNote that there may be other valid parentheses string paths.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[ \") \", \") \"\\],\\[ \"( \", \"( \"\\]\\]\n**Output:** false\n**Explanation:** The two possible paths form the parentheses strings  \"))( \" and  \")(( \". Since neither of them are valid parentheses strings, we return false."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `grid[i][j]` is either `'('` or `')'`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]",
                "output": "true"
            },
            {
                "input": "[[\")\",\")\"],[\"(\",\"(\"]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\npublic int minDifference(int[] nums) {\n    int n = nums.length / 3;\n    int[] prefix = new int[n + 2];\n    int[] suffix = new int[n + 2];\n    TreeSet<Integer> window = new TreeSet<>();\n\n    for (int i = 0; i < n; ++i) window.add(nums[i]);\n    prefix[0] = window.stream().mapToInt(Integer::intValue).sum();\n\n    for (int i = n, j = 1; i < 2 * n; ++i, ++j) {\n        window.remove(nums[i - n]);\n        window.add(nums[i]);\n        prefix[j] = window.stream().mapToInt(Integer::intValue).sum();\n    }\n\n    window.clear();\n\n    for (int i = 0; i < n; ++i) window.add(nums[3 * n - i - 1]);\n    suffix[n] = window.stream().mapToInt(Integer::intValue).sum();\n\n    for (int i = n - 1, j = 1; i < 2 * n - 1; --i, ++j) {\n        window.remove(nums[3 * n - j]);\n        window.add(nums[2 * n - j]);\n        suffix[i] = window.stream().mapToInt(Integer::intValue).sum();\n    }\n\n    int min_diff = Integer.MAX_VALUE;\n\n    for (int i = 0; i <= n; ++i) {\n        min_diff = Math.min(min_diff, Math.abs(prefix[i] - suffix[i]));\n    }\n\n    return min_diff;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize a prefix and suffix array of length n+2 where prefix array will store the sum of elements in the current sliding window until 2n and suffix array will store the sum of elements in the current sliding window from 3n to 2n.\n2. Use a set or multiset to store elements of the sliding window which will be of size n.\n3. First calculate the prefix sums by looping from n to 2n and calculate the suffix sums by looping from 3n to 2n.\n4. While calculating the prefix and suffix sums, maintain a sliding window by removing the unwanted element and inserting the new element.\n5. At the end, iterate through the prefix and suffix arrays and find the minimum difference between the sums of two parts in the arrays. Return the minimum difference.\n    ",
        "python": "\n    ```python\ndef minDifference(nums):\n    n = len(nums) // 3\n    prefix, suffix = [0] * (n + 2), [0] * (n + 2)\n    \n    window = sorted(nums[:n])\n    prefix[0] = sum(window)\n    \n    for i in range(n, 2 * n):\n        window.remove(nums[i - n])\n        bisect.insort(window, nums[i])\n        prefix[i - n + 1] = sum(window)\n\n    window = sorted(nums[-n:])\n    suffix[n] = sum(window)\n    \n    for i in range(2 * n - 1, n - 1, -1):\n        j = 3 * n - i - 1\n        window.remove(nums[j])\n        idx = bisect_left(window, nums[n * 2 - j - 1])\n        window.insert(idx, nums[n * 2 - j - 1])\n        suffix[i] = sum(window)\n\n    return min(abs(a - b) for a, b in zip(prefix, suffix))\n```\n    \n    The algorithm works as follows:\n1. Initialize a prefix and suffix array of length n+2 where prefix array will store the sum of elements in the current sliding window until 2n and suffix array will store the sum of elements in the current sliding window from 3n to 2n.\n2. Use a set or multiset to store elements of the sliding window which will be of size n.\n3. First calculate the prefix sums by looping from n to 2n and calculate the suffix sums by looping from 3n to 2n.\n4. While calculating the prefix and suffix sums, maintain a sliding window by removing the unwanted element and inserting the new element.\n5. At the end, iterate through the prefix and suffix arrays and find the minimum difference between the sums of two parts in the arrays. Return the minimum difference.\n    ",
        "c++": "\n    ```cpp\nint minDifference(vector<int>& nums) {\n   int n = nums.size() / 3;\n   vector<int> prefix(n + 2), suffix(n + 2);\n   multiset<int> window;\n\n   for (int i = 0; i < n; ++i) window.insert(nums[i]);\n   prefix[0] = accumulate(begin(window), end(window), 0);\n\n   for (int i = n, j = 1; i < 2 * n; ++i, ++j) {\n      window.erase(window.find(nums[i - n]));\n      window.insert(nums[i]);\n      prefix[j] = accumulate(begin(window), end(window), 0);\n   }\n\n   window.clear();\n\n   for (int i = 0; i < n; ++i) window.insert(nums[3 * n - i - 1]);\n   suffix[n] = accumulate(begin(window), end(window), 0);\n\n   for (int i = n - 1, j = 1; i < 2 * n - 1; --i, ++j) {\n      window.erase(window.find(nums[3 * n - j]));\n      window.insert(nums[2 * n - j]);\n      suffix[i] = accumulate(begin(window), end(window), 0);\n   }\n\n   int min_diff = INT_MAX;\n\n   for (int i = 0; i <= n; ++i) {\n      min_diff = min(min_diff, abs(prefix[i] - suffix[i]));\n   }\n\n   return min_diff;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize a prefix and suffix array of length n+2 where prefix array will store the sum of elements in the current sliding window until 2n and suffix array will store the sum of elements in the current sliding window from 3n to 2n.\n2. Use a set or multiset to store elements of the sliding window which will be of size n.\n3. First calculate the prefix sums by looping from n to 2n and calculate the suffix sums by looping from 3n to 2n.\n4. While calculating the prefix and suffix sums, maintain a sliding window by removing the unwanted element and inserting the new element.\n5. At the end, iterate through the prefix and suffix arrays and find the minimum difference between the sums of two parts in the arrays. Return the minimum difference.\n    ",
        "js": "\n    ```javascript\nfunction minDifference(nums) {\n    const n = nums.length / 3;\n    const prefix = new Array(n + 2).fill(0);\n    const suffix = new Array(n + 2).fill(0);\n    const window = new Set();\n\n    for (let i = 0; i < n; ++i) window.add(nums[i]);\n    prefix[0] = Array.from(window).reduce((a, b) => a + b, 0);\n\n    for (let i = n, j = 1; i < 2 * n; ++i, ++j) {\n        window.delete(nums[i - n]);\n        window.add(nums[i]);\n        prefix[j] = Array.from(window).reduce((a, b) => a + b, 0);\n    }\n\n    window.clear();\n\n    for (let i = 0; i < n; ++i) window.add(nums[3 * n - i - 1]);\n    suffix[n] = Array.from(window).reduce((a, b) => a + b, 0);\n\n    for (let i = n - 1, j = 1; i < 2 * n - 1; --i, ++j) {\n        window.delete(nums[3 * n - j]);\n        window.add(nums[2 * n - j]);\n        suffix[i] = Array.from(window).reduce((a, b) => a + b, 0);\n    }\n\n    let min_diff = Number.MAX_VALUE;\n\n    for (let i = 0; i <= n; ++i) {\n        min_diff = Math.min(min_diff, Math.abs(prefix[i] - suffix[i]));\n    }\n\n    return min_diff;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize a prefix and suffix array of length n+2 where prefix array will store the sum of elements in the current sliding window until 2n and suffix array will store the sum of elements in the current sliding window from 3n to 2n.\n2. Use a set or multiset to store elements of the sliding window which will be of size n.\n3. First calculate the prefix sums by looping from n to 2n and calculate the suffix sums by looping from 3n to 2n.\n4. While calculating the prefix and suffix sums, maintain a sliding window by removing the unwanted element and inserting the new element.\n5. At the end, iterate through the prefix and suffix arrays and find the minimum difference between the sums of two parts in the arrays. Return the minimum difference.\n    "
    },
    {
        "id": 385,
        "title": "Substring With Largest Variance",
        "difficulty": "Hard",
        "content": {
            "problem": "The **variance** of a string is defined as the largest difference between the number of occurrences of **any** `2` characters present in the string. Note the two characters may or may not be the same.\n\nGiven a string `s` consisting of lowercase English letters only, return _the **largest variance** possible among all **substrings** of_ `s`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aababbb \"\n**Output:** 3\n**Explanation:**\nAll possible variances along with their respective substrings are listed below:\n- Variance 0 for substrings  \"a \",  \"aa \",  \"ab \",  \"abab \",  \"aababb \",  \"ba \",  \"b \",  \"bb \", and  \"bbb \".\n- Variance 1 for substrings  \"aab \",  \"aba \",  \"abb \",  \"aabab \",  \"ababb \",  \"aababbb \", and  \"bab \".\n- Variance 2 for substrings  \"aaba \",  \"ababbb \",  \"abbb \", and  \"babb \".\n- Variance 3 for substring  \"babbb \".\nSince the largest possible variance is 3, we return it.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcde \"\n**Output:** 0\n**Explanation:**\nNo letter occurs more than once in s, so the variance of every substring is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"aababbb\"",
                "output": "3"
            },
            {
                "input": "\"abcde\"",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maximumGoodPeople(int[][] statements) {\n    int n = statements.length;\n    int count_good = 0;\n    for(int i = 0; i < n; i++) {\n        boolean is_good = true;\n        for(int j = 0; j < n; j++) {\n            if(statements[j][i] == 1 && statements[i][j] == 0) {\n                is_good = false;\n                break;\n            }\n        }\n        if(is_good) count_good++;\n    }\n    return count_good;\n}\n```\n    \n    We iterate through each person, then we iterate through each statement made by other people about that person. If there are no contradicting statements (someone claims the person is good but the person claims that someone is not good), we consider the person to be good and increment the count. Finally, we return the total count of good people.\n    ",
        "python": "\n    ```python\ndef maximum_good_people(statements):\n    n = len(statements)\n    count_good = 0\n    for i in range(n):\n        is_good = True\n        for j in range(n):\n            if statements[j][i] == 1 and statements[i][j] == 0:\n                is_good = False\n                break\n        if is_good:\n            count_good += 1\n    return count_good\n```\n    \n    We iterate through each person, then we iterate through each statement made by other people about that person. If there are no contradicting statements (someone claims the person is good but the person claims that someone is not good), we consider the person to be good and increment the count. Finally, we return the total count of good people.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint maximumGoodPeople(std::vector<std::vector<int>>& statements) {\n    int n = statements.size();\n    int count_good = 0;\n    for(int i = 0; i < n; i++) {\n        bool is_good = true;\n        for(int j = 0; j < n; j++) {\n            if(statements[j][i] == 1 && statements[i][j] == 0) {\n                is_good = false;\n                break;\n            }\n        }\n        if(is_good) count_good++;\n    }\n    return count_good;\n}\n```\n    \n    We iterate through each person, then we iterate through each statement made by other people about that person. If there are no contradicting statements (someone claims the person is good but the person claims that someone is not good), we consider the person to be good and increment the count. Finally, we return the total count of good people.\n    ",
        "js": "\n    ```javascript\nfunction maximumGoodPeople(statements) {\n    const n = statements.length;\n    let count_good = 0;\n    for(let i = 0; i < n; i++) {\n        let is_good = true;\n        for(let j = 0; j < n; j++) {\n            if(statements[j][i] === 1 && statements[i][j] === 0) {\n                is_good = false;\n                break;\n            }\n        }\n        if(is_good) count_good++;\n    }\n    return count_good;\n}\n```\n\n    \n    We iterate through each person, then we iterate through each statement made by other people about that person. If there are no contradicting statements (someone claims the person is good but the person claims that someone is not good), we consider the person to be good and increment the count. Finally, we return the total count of good people.\n    "
    },
    {
        "id": 386,
        "title": "Count Integers in Intervals",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an **empty** set of intervals, implement a data structure that can:\n\n*   **Add** an interval to the set of intervals.\n*   **Count** the number of integers that are present in **at least one** interval.\n\nImplement the `CountIntervals` class:\n\n*   `CountIntervals()` Initializes the object with an empty set of intervals.\n*   `void add(int left, int right)` Adds the interval `[left, right]` to the set of intervals.\n*   `int count()` Returns the number of integers that are present in **at least one** interval.\n\n**Note** that an interval `[left, right]` denotes all the integers `x` where `left <= x <= right`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"CountIntervals \",  \"add \",  \"add \",  \"count \",  \"add \",  \"count \"\\]\n\\[\\[\\], \\[2, 3\\], \\[7, 10\\], \\[\\], \\[5, 8\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 6, null, 8\\]\n\n**Explanation**\nCountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. \ncountIntervals.add(2, 3);  // add \\[2, 3\\] to the set of intervals.\ncountIntervals.add(7, 10); // add \\[7, 10\\] to the set of intervals.\ncountIntervals.count();    // return 6\n                           // the integers 2 and 3 are present in the interval \\[2, 3\\].\n                           // the integers 7, 8, 9, and 10 are present in the interval \\[7, 10\\].\ncountIntervals.add(5, 8);  // add \\[5, 8\\] to the set of intervals.\ncountIntervals.count();    // return 8\n                           // the integers 2 and 3 are present in the interval \\[2, 3\\].\n                           // the integers 5 and 6 are present in the interval \\[5, 8\\].\n                           // the integers 7 and 8 are present in the intervals \\[5, 8\\] and \\[7, 10\\].\n                           // the integers 9 and 10 are present in the interval \\[7, 10\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left <= right <= 109`\n*   At most `105` calls **in total** will be made to `add` and `count`.\n*   At least **one** call will be made to `count`.",
            "follow_up": null
        },
        "tag": [
            "Design",
            "Segment Tree",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "]\n],],],],],]]",
                "output": "**Output**\n[null,null,null,6,null,8]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int[] groupStrings(String[] words) {\n    Map<String, Integer> groups = new HashMap<>();\n    int groupsCount = 0;\n\n    for (String word : words) {\n        char[] chars = word.toCharArray();\n        Arrays.sort(chars);\n        String sKey = new String(chars);\n\n        if (!groups.containsKey(sKey)) {\n            groups.put(sKey, groupsCount);\n            groupsCount++;\n        }\n    }\n\n    return new int[]{groupsCount, words.length - groupsCount};\n}\n```\n    \n    The algorithm first initializes an empty map (or dictionary) called `groups`, which will store the unique combinations of letters within the words. It also initializes a counter `groupsCount`, which will count the number of unique groups.\n\nThen, for each word in the input array, it sorts the characters of the word and creates a new string `sKey` from the sorted characters.\n\nIf the `sKey` is not present in the `groups` map, it defines a new group for that `sKey` and increments the `groupsCount`.\n\nFinally, the algorithm returns an array containing the total number of groups (`groupsCount`) and the number of strings in the array minus the groups count. This difference will be the required number of operations to achieve the grouping.\n\nThe language-specific implementation details are minimal, mainly in the way maps/dictionaries are accessed and defining return types.\n    ",
        "python": "\n    ```python\ndef group_strings(words):\n    groups = {}\n    groups_count = 0\n\n    for word in words:\n        s_key = ''.join(sorted(word))\n\n        if s_key not in groups:\n            groups[s_key] = groups_count\n            groups_count += 1\n\n    return [groups_count, len(words) - groups_count]\n```\n    \n    The algorithm first initializes an empty map (or dictionary) called `groups`, which will store the unique combinations of letters within the words. It also initializes a counter `groupsCount`, which will count the number of unique groups.\n\nThen, for each word in the input array, it sorts the characters of the word and creates a new string `sKey` from the sorted characters.\n\nIf the `sKey` is not present in the `groups` map, it defines a new group for that `sKey` and increments the `groupsCount`.\n\nFinally, the algorithm returns an array containing the total number of groups (`groupsCount`) and the number of strings in the array minus the groups count. This difference will be the required number of operations to achieve the grouping.\n\nThe language-specific implementation details are minimal, mainly in the way maps/dictionaries are accessed and defining return types.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> groupStrings(std::vector<std::string>& words) {\n    std::unordered_map<std::string, int> groups;\n    int groupsCount = 0;\n\n    for (const std::string& word : words) {\n        std::string sKey(word);\n        sort(sKey.begin(), sKey.end());\n\n        if (groups.find(sKey) == groups.end()) {\n            groups[sKey] = groupsCount;\n            groupsCount++;\n        }\n    }\n\n    return {groupsCount, words.size() - groupsCount};\n}\n```\n    \n    The algorithm first initializes an empty map (or dictionary) called `groups`, which will store the unique combinations of letters within the words. It also initializes a counter `groupsCount`, which will count the number of unique groups.\n\nThen, for each word in the input array, it sorts the characters of the word and creates a new string `sKey` from the sorted characters.\n\nIf the `sKey` is not present in the `groups` map, it defines a new group for that `sKey` and increments the `groupsCount`.\n\nFinally, the algorithm returns an array containing the total number of groups (`groupsCount`) and the number of strings in the array minus the groups count. This difference will be the required number of operations to achieve the grouping.\n\nThe language-specific implementation details are minimal, mainly in the way maps/dictionaries are accessed and defining return types.\n    ",
        "js": "\n    ```javascript\nfunction groupStrings(words) {\n    const groups = new Map();\n    let groupsCount = 0;\n    \n    words.forEach(word => {\n        const sKey = word.split(\"\").sort().join(\"\");\n\n        if (!groups.has(sKey)) {\n            groups.set(sKey, groupsCount);\n            groupsCount++;\n        }\n    });\n\n    return [groupsCount, words.length - groupsCount];\n}\n```\n    \n    The algorithm first initializes an empty map (or dictionary) called `groups`, which will store the unique combinations of letters within the words. It also initializes a counter `groupsCount`, which will count the number of unique groups.\n\nThen, for each word in the input array, it sorts the characters of the word and creates a new string `sKey` from the sorted characters.\n\nIf the `sKey` is not present in the `groups` map, it defines a new group for that `sKey` and increments the `groupsCount`.\n\nFinally, the algorithm returns an array containing the total number of groups (`groupsCount`) and the number of strings in the array minus the groups count. This difference will be the required number of operations to achieve the grouping.\n\nThe language-specific implementation details are minimal, mainly in the way maps/dictionaries are accessed and defining return types.\n    "
    },
    {
        "id": 387,
        "title": "Sum of Total Strength of Wizards",
        "difficulty": "Hard",
        "content": {
            "problem": "As the ruler of a kingdom, you have an army of wizards at your command.\n\nYou are given a **0-indexed** integer array `strength`, where `strength[i]` denotes the strength of the `ith` wizard. For a **contiguous** group of wizards (i.e. the wizards' strengths form a **subarray** of `strength`), the **total strength** is defined as the **product** of the following two values:\n\n*   The strength of the **weakest** wizard in the group.\n*   The **total** of all the individual strengths of the wizards in the group.\n\nReturn _the **sum** of the total strengths of **all** contiguous groups of wizards_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** strength = \\[1,3,1,2\\]\n**Output:** 44\n**Explanation:** The following are all the contiguous groups of wizards:\n- \\[1\\] from \\[**1**,3,1,2\\] has a total strength of min(\\[1\\]) \\* sum(\\[1\\]) = 1 \\* 1 = 1\n- \\[3\\] from \\[1,**3**,1,2\\] has a total strength of min(\\[3\\]) \\* sum(\\[3\\]) = 3 \\* 3 = 9\n- \\[1\\] from \\[1,3,**1**,2\\] has a total strength of min(\\[1\\]) \\* sum(\\[1\\]) = 1 \\* 1 = 1\n- \\[2\\] from \\[1,3,1,**2**\\] has a total strength of min(\\[2\\]) \\* sum(\\[2\\]) = 2 \\* 2 = 4\n- \\[1,3\\] from \\[**1,3**,1,2\\] has a total strength of min(\\[1,3\\]) \\* sum(\\[1,3\\]) = 1 \\* 4 = 4\n- \\[3,1\\] from \\[1,**3,1**,2\\] has a total strength of min(\\[3,1\\]) \\* sum(\\[3,1\\]) = 1 \\* 4 = 4\n- \\[1,2\\] from \\[1,3,**1,2**\\] has a total strength of min(\\[1,2\\]) \\* sum(\\[1,2\\]) = 1 \\* 3 = 3\n- \\[1,3,1\\] from \\[**1,3,1**,2\\] has a total strength of min(\\[1,3,1\\]) \\* sum(\\[1,3,1\\]) = 1 \\* 5 = 5\n- \\[3,1,2\\] from \\[1,**3,1,2**\\] has a total strength of min(\\[3,1,2\\]) \\* sum(\\[3,1,2\\]) = 1 \\* 6 = 6\n- \\[1,3,1,2\\] from \\[**1,3,1,2**\\] has a total strength of min(\\[1,3,1,2\\]) \\* sum(\\[1,3,1,2\\]) = 1 \\* 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.\n\n",
                "**Example 2:**\n\n**Input:** strength = \\[5,4,6\\]\n**Output:** 213\n**Explanation:** The following are all the contiguous groups of wizards: \n- \\[5\\] from \\[**5**,4,6\\] has a total strength of min(\\[5\\]) \\* sum(\\[5\\]) = 5 \\* 5 = 25\n- \\[4\\] from \\[5,**4**,6\\] has a total strength of min(\\[4\\]) \\* sum(\\[4\\]) = 4 \\* 4 = 16\n- \\[6\\] from \\[5,4,**6**\\] has a total strength of min(\\[6\\]) \\* sum(\\[6\\]) = 6 \\* 6 = 36\n- \\[5,4\\] from \\[**5,4**,6\\] has a total strength of min(\\[5,4\\]) \\* sum(\\[5,4\\]) = 4 \\* 9 = 36\n- \\[4,6\\] from \\[5,**4,6**\\] has a total strength of min(\\[4,6\\]) \\* sum(\\[4,6\\]) = 4 \\* 10 = 40\n- \\[5,4,6\\] from \\[**5,4,6**\\] has a total strength of min(\\[5,4,6\\]) \\* sum(\\[5,4,6\\]) = 4 \\* 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strength.length <= 105`\n*   `1 <= strength[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Monotonic Stack",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,3,1,2]",
                "output": "44"
            },
            {
                "input": "[5,4,6]",
                "output": "213"
            }
        ],
        "java": "\n    ```java\nint mod = 1000000007;\npublic int sum_of_strength(int[] strength) {\n    int res = 0, total = 0, minimum = 0;\n    for (int i = 0; i < strength.length; ++i) {\n        minimum = total = strength[i];\n        for (int j = i; j < strength.length; ++j) {\n            minimum = Math.min(minimum, strength[j]);\n            total += strength[j];\n            res = (res + minimum * total % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The given problem can be solved by iterating over each wizard in the array. For each wizard, we will find the contiguous subarrays that end at that wizard (the wizard is the last element in the subarray). For this, we will iterate from the current wizard to the end of the array, calculating the minimum strength and total strength of the subarray in each step. We then update the result by adding the product of the current subarray's minimum strength and total strength, and take the result modulo `10^9 + 7` to handle large numbers. At the end, we return the result after checking all the wizards and their respective contiguous subarrays.\n    ",
        "python": "\n    ```python\nmod = 1000000007\ndef sum_of_strength(strength):\n    res, strength_len = 0, len(strength)\n    for i in range(strength_len):\n        minimum = total = strength[i]\n        for j in range(i, strength_len):\n            minimum = min(minimum, strength[j])\n            total += strength[j]\n            res = (res + minimum * total % mod) % mod\n    return res\n```\n    \n    The given problem can be solved by iterating over each wizard in the array. For each wizard, we will find the contiguous subarrays that end at that wizard (the wizard is the last element in the subarray). For this, we will iterate from the current wizard to the end of the array, calculating the minimum strength and total strength of the subarray in each step. We then update the result by adding the product of the current subarray's minimum strength and total strength, and take the result modulo `10^9 + 7` to handle large numbers. At the end, we return the result after checking all the wizards and their respective contiguous subarrays.\n    ",
        "c++": "\n    ```cpp\nint mod = 1000000007;\nint sum_of_strength(int* strength, int strengthSize) {\n    int res = 0, total = 0, minimum = 0;\n    for (int i = 0; i < strengthSize; ++i) {\n        minimum = total = strength[i];\n        for (int j = i; j < strengthSize; ++j) {\n            minimum = fmin(minimum, strength[j]);\n            total += strength[j];\n            res = (res + minimum * total % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The given problem can be solved by iterating over each wizard in the array. For each wizard, we will find the contiguous subarrays that end at that wizard (the wizard is the last element in the subarray). For this, we will iterate from the current wizard to the end of the array, calculating the minimum strength and total strength of the subarray in each step. We then update the result by adding the product of the current subarray's minimum strength and total strength, and take the result modulo `10^9 + 7` to handle large numbers. At the end, we return the result after checking all the wizards and their respective contiguous subarrays.\n    ",
        "js": "\n    ```javascript\nconst mod = 1000000007;\nfunction sum_of_strength(strength) {\n    let res = 0, total = 0, minimum = 0;\n    for (let i = 0; i < strength.length; ++i) {\n        minimum = total = strength[i];\n        for (let j = i; j < strength.length; ++j) {\n            minimum = Math.min(minimum, strength[j]);\n            total += strength[j];\n            res = (res + minimum * total % mod) % mod;\n        }\n    }\n    return res;\n}\n```\n    \n    The given problem can be solved by iterating over each wizard in the array. For each wizard, we will find the contiguous subarrays that end at that wizard (the wizard is the last element in the subarray). For this, we will iterate from the current wizard to the end of the array, calculating the minimum strength and total strength of the subarray in each step. We then update the result by adding the product of the current subarray's minimum strength and total strength, and take the result modulo `10^9 + 7` to handle large numbers. At the end, we return the result after checking all the wizards and their respective contiguous subarrays.\n    "
    },
    {
        "id": 388,
        "title": "Minimum Obstacle Removal to Reach Corner",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `grid` of size `m x n`. Each cell has one of two values:\n\n*   `0` represents an **empty** cell,\n*   `1` represents an **obstacle** that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\n\nReturn _the **minimum** number of **obstacles** to **remove** so you can move from the upper left corner_ `(0, 0)` _to the lower right corner_ `(m - 1, n - 1)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 2\n**Explanation:** We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,1,0,0,0\\],\\[0,1,0,1,0\\],\\[0,0,0,1,0\\]\\]\n**Output:** 0\n**Explanation:** We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `grid[i][j]` is either `0` **or** `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Matrix",
            "Shortest Path"
        ],
        "example": [
            {
                "input": "[[0,1,1],[1,1,0],[1,1,0]]",
                "output": "2"
            },
            {
                "input": "[[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic int minNumberOfBeansToRemove(int[] beans) {\n    Map<Integer, Integer> count = new HashMap<>();\n    for (int bean : beans) {\n        count.put(bean, count.getOrDefault(bean, 0) + 1);\n    }\n\n    int min_remove = beans.length;\n    for (Map.Entry<Integer, Integer> item : count.entrySet()) {\n        int remove = 0;\n        for (Map.Entry<Integer, Integer> other : count.entrySet()) {\n            if (!other.getKey().equals(item.getKey())) {\n                remove += other.getValue() * Math.max(0, other.getKey() - item.getKey());\n            }\n        }\n        min_remove = Math.min(min_remove, remove);\n    }\n\n    return min_remove;\n}\n```\n    \n    1. Count the occurrences of each number of beans in a hash map or dictionary (count).\n2. Iterate over each unique number of beans (key) in the count dictionary.\n3. For each unique number of beans, calculate the number of beans to remove if all remaining non-empty bags have this number of beans.\n4. Accumulate the removal count.\n5. Keep track of the minimum removal count.\n6. Return the minimum removal count.\n    ",
        "python": "\n    ```python\ndef min_number_of_beans_to_remove(beans):\n    count = {}\n    for bean in beans:\n        if bean not in count:\n            count[bean] = 0\n        count[bean] += 1\n\n    min_remove = len(beans)\n    for key, value in count.items():\n        remove = 0\n        for other_key, other_value in count.items():\n            if other_key != key:\n                remove += other_value * max(0, other_key - key)\n        min_remove = min(min_remove, remove)\n\n    return min_remove\n```\n    \n    1. Count the occurrences of each number of beans in a hash map or dictionary (count).\n2. Iterate over each unique number of beans (key) in the count dictionary.\n3. For each unique number of beans, calculate the number of beans to remove if all remaining non-empty bags have this number of beans.\n4. Accumulate the removal count.\n5. Keep track of the minimum removal count.\n6. Return the minimum removal count.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint minNumberOfBeansToRemove(const std::vector<int>& beans) {\n    std::unordered_map<int, int> count;\n    for (int bean : beans) {\n        count[bean]++;\n    }\n\n    int min_remove = beans.size();\n    for (const auto& item : count) {\n        int remove = 0;\n        for (const auto& other : count) {\n            if (other.first != item.first) {\n                remove += other.second * std::max(0, other.first - item.first);\n            }\n        }\n        min_remove = std::min(min_remove, remove);\n    }\n\n    return min_remove;\n}\n```\n    \n    1. Count the occurrences of each number of beans in a hash map or dictionary (count).\n2. Iterate over each unique number of beans (key) in the count dictionary.\n3. For each unique number of beans, calculate the number of beans to remove if all remaining non-empty bags have this number of beans.\n4. Accumulate the removal count.\n5. Keep track of the minimum removal count.\n6. Return the minimum removal count.\n    ",
        "js": "\n    ```javascript\nfunction minNumberOfBeansToRemove(beans) {\n    const count = {};\n    for (const bean of beans) {\n        if (!count.hasOwnProperty(bean)) {\n            count[bean] = 0;\n        }\n        count[bean]++;\n    }\n\n    let min_remove = beans.length;\n    for (const [key, value] of Object.entries(count)) {\n        let remove = 0;\n        for (const [other_key, other_value] of Object.entries(count)) {\n            if (other_key !== key) {\n                remove += other_value * Math.max(0, other_key - key);\n            }\n        }\n        min_remove = Math.min(min_remove, remove);\n    }\n\n    return min_remove;\n}\n```\n    \n    1. Count the occurrences of each number of beans in a hash map or dictionary (count).\n2. Iterate over each unique number of beans (key) in the count dictionary.\n3. For each unique number of beans, calculate the number of beans to remove if all remaining non-empty bags have this number of beans.\n4. Accumulate the removal count.\n5. Keep track of the minimum removal count.\n6. Return the minimum removal count.\n    "
    },
    {
        "id": 389,
        "title": "Design a Text Editor",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a text editor with a cursor that can do the following:\n\n*   **Add** text to where the cursor is.\n*   **Delete** text from where the cursor is (simulating the backspace key).\n*   **Move** the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that `0 <= cursor.position <= currentText.length` always holds.\n\nImplement the `TextEditor` class:\n\n*   `TextEditor()` Initializes the object with empty text.\n*   `void addText(string text)` Appends `text` to where the cursor is. The cursor ends to the right of `text`.\n*   `int deleteText(int k)` Deletes `k` characters to the left of the cursor. Returns the number of characters actually deleted.\n*   `string cursorLeft(int k)` Moves the cursor to the left `k` times. Returns the last `min(10, len)` characters to the left of the cursor, where `len` is the number of characters to the left of the cursor.\n*   `string cursorRight(int k)` Moves the cursor to the right `k` times. Returns the last `min(10, len)` characters to the left of the cursor, where `len` is the number of characters to the left of the cursor.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"TextEditor \",  \"addText \",  \"deleteText \",  \"addText \",  \"cursorRight \",  \"cursorLeft \",  \"deleteText \",  \"cursorLeft \",  \"cursorRight \"\\]\n\\[\\[\\], \\[ \"leetcode \"\\], \\[4\\], \\[ \"practice \"\\], \\[3\\], \\[8\\], \\[10\\], \\[2\\], \\[6\\]\\]\n**Output**\n\\[null, null, 4, null,  \"etpractice \",  \"leet \", 4,  \" \",  \"practi \"\\]\n\n**Explanation**\nTextEditor textEditor = new TextEditor(); // The current text is  \"| \". (The '|' character represents the cursor)\ntextEditor.addText( \"leetcode \"); // The current text is  \"leetcode| \".\ntextEditor.deleteText(4); // return 4\n                          // The current text is  \"leet| \". \n                          // 4 characters were deleted.\ntextEditor.addText( \"practice \"); // The current text is  \"leetpractice| \". \ntextEditor.cursorRight(3); // return  \"etpractice \"\n                           // The current text is  \"leetpractice| \". \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           //  \"etpractice \" is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return  \"leet \"\n                          // The current text is  \"leet|practice \".\n                          //  \"leet \" is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is  \"|practice \".\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return  \" \"\n                          // The current text is  \"|practice \".\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          //  \" \" is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return  \"practi \"\n                           // The current text is  \"practi|ce \".\n                           //  \"practi \" is the last min(10, 6) = 6 characters to the left of the cursor."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length, k <= 40`\n*   `text` consists of lowercase English letters.\n*   At most `2 * 104` calls **in total** will be made to `addText`, `deleteText`, `cursorLeft` and `cursorRight`.\n\n**",
            "follow_up": "Follow-up:** Could you find a solution with time complexity of `O(k)` per call?"
        },
        "tag": [
            "Linked List",
            "String",
            "Stack",
            "Design",
            "Simulation",
            "Doubly-Linked List"
        ],
        "example": [
            {
                "input": "]\n],],],],],],],],]]",
                "output": "**Output**\n[null,null,4,null,\"etpractice\",\"leet\",4,\"\",\"practi\"]"
            }
        ],
        "java": "\n    ```java\nclass TextEditor {\n    private StringBuilder text;\n    private int cursor;\n\n    public TextEditor() {\n        text = new StringBuilder();\n        cursor = 0;\n    }\n    \n    public void addText(String newText) {\n        text.insert(cursor, newText);\n        cursor += newText.length();\n    }\n    \n    public int deleteText(int k) {\n        int deleted = Math.min(k, cursor);\n        text.delete(cursor - deleted, cursor);\n        cursor -= deleted;\n        return deleted;\n    }\n    \n    public String cursorLeft(int k) {\n        cursor -= Math.min(k, cursor);\n        return text.substring(Math.max(0, cursor - 10), cursor);\n    }\n    \n    public String cursorRight(int k) {\n        cursor += Math.min(k, text.length() - cursor);\n        return text.substring(Math.max(0, cursor - 10), cursor);\n    }\n}\n```\n\n    \n    We maintain a string `text` and an integer `cursor` to represent the current text and the cursor's position. `addText` adds new text at the cursor location and moves the cursor after the new text. `deleteText` deletes text from the cursor's left and returns the number of characters deleted. `cursorLeft` and `cursorRight` move the cursor left or right by given steps and return last min(10, len) characters to the left of the cursor where len is the number of characters to the left of the cursor. In each function, we update the cursor position and return the desired output.\n    ",
        "python": "\n    ```python\nclass TextEditor:\n    def __init__(self):\n        self.text = \"\"\n        self.cursor = 0\n\n    def addText(self, newText: str) -> None:\n        self.text = self.text[:self.cursor] + newText + self.text[self.cursor:]\n        self.cursor += len(newText)\n        \n    def deleteText(self, k: int) -> int:\n        deleted = min(k, self.cursor)\n        self.text = self.text[:self.cursor - deleted] + self.text[self.cursor:]\n        self.cursor -= deleted\n        return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        self.cursor -= min(k, self.cursor)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n        \n    def cursorRight(self, k: int) -> str:\n        self.cursor += min(k, len(self.text) - self.cursor)\n        return self.text[max(0, self.cursor - 10):self.cursor]\n```\n\n    \n    We maintain a string `text` and an integer `cursor` to represent the current text and the cursor's position. `addText` adds new text at the cursor location and moves the cursor after the new text. `deleteText` deletes text from the cursor's left and returns the number of characters deleted. `cursorLeft` and `cursorRight` move the cursor left or right by given steps and return last min(10, len) characters to the left of the cursor where len is the number of characters to the left of the cursor. In each function, we update the cursor position and return the desired output.\n    ",
        "c++": "\n    ```cpp\nclass TextEditor {\n    string text;\n    int cursor;\npublic:\n    TextEditor() {\n        text = \"\";\n        cursor = 0;\n    }\n    \n    void addText(string newText) {\n        text.insert(cursor, newText);\n        cursor += newText.size();\n    }\n    \n    int deleteText(int k) {\n        int deleted = min(k, cursor);\n        text.erase(cursor - deleted, deleted);\n        cursor -= deleted;\n        return deleted;\n    }\n    \n    string cursorLeft(int k) {\n        cursor -= min(k, cursor);\n        return text.substr(max(0, cursor - 10), min(10, cursor));\n    }\n    \n    string cursorRight(int k) {\n        cursor += min(k, (int)text.size() - cursor);\n        return text.substr(max(0, cursor - 10), min(10, cursor));\n    }\n};\n```\n\n    \n    We maintain a string `text` and an integer `cursor` to represent the current text and the cursor's position. `addText` adds new text at the cursor location and moves the cursor after the new text. `deleteText` deletes text from the cursor's left and returns the number of characters deleted. `cursorLeft` and `cursorRight` move the cursor left or right by given steps and return last min(10, len) characters to the left of the cursor where len is the number of characters to the left of the cursor. In each function, we update the cursor position and return the desired output.\n    ",
        "js": "\n    ```javascript\nclass TextEditor {\n    constructor() {\n        this.text = \"\";\n        this.cursor = 0;\n    }\n\n    addText(newText) {\n        this.text = this.text.slice(0, this.cursor) + newText + this.text.slice(this.cursor);\n        this.cursor += newText.length;\n    }\n\n    deleteText(k) {\n        const deleted = Math.min(k, this.cursor);\n        this.text = this.text.slice(0, this.cursor - deleted) + this.text.slice(this.cursor);\n        this.cursor -= deleted;\n        return deleted;\n    }\n\n    cursorLeft(k) {\n        this.cursor -= Math.min(k, this.cursor);\n        return this.text.slice(Math.max(0, this.cursor - 10), this.cursor);\n    }\n\n    cursorRight(k) {\n        this.cursor += Math.min(k, this.text.length - this.cursor);\n        return this.text.slice(Math.max(0, this.cursor - 10), this.cursor);\n    }\n}\n```\n\n    \n    We maintain a string `text` and an integer `cursor` to represent the current text and the cursor's position. `addText` adds new text at the cursor location and moves the cursor after the new text. `deleteText` deletes text from the cursor's left and returns the number of characters deleted. `cursorLeft` and `cursorRight` move the cursor left or right by given steps and return last min(10, len) characters to the left of the cursor where len is the number of characters to the left of the cursor. In each function, we update the cursor position and return the desired output.\n    "
    },
    {
        "id": 390,
        "title": "Match Substring After Replacement",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two strings `s` and `sub`. You are also given a 2D character array `mappings` where `mappings[i] = [oldi, newi]` indicates that you may perform the following operation **any** number of times:\n\n*   **Replace** a character `oldi` of `sub` with `newi`.\n\nEach character in `sub` **cannot** be replaced more than once.\n\nReturn `true` _if it is possible to make_ `sub` _a substring of_ `s` _by replacing zero or more characters according to_ `mappings`. Otherwise, return `false`.\n\nA **substring** is a contiguous non-empty sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"fool3e7bar \", sub =  \"leet \", mappings = \\[\\[ \"e \", \"3 \"\\],\\[ \"t \", \"7 \"\\],\\[ \"t \", \"8 \"\\]\\]\n**Output:** true\n**Explanation:** Replace the first 'e' in sub with '3' and 't' in sub with '7'.\nNow sub =  \"l3e7 \" is a substring of s, so we return true.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"fooleetbar \", sub =  \"f00l \", mappings = \\[\\[ \"o \", \"0 \"\\]\\]\n**Output:** false\n**Explanation:** The string  \"f00l \" is not a substring of s and no replacements can be made.\nNote that we cannot replace '0' with 'o'.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"Fool33tbaR \", sub =  \"leetd \", mappings = \\[\\[ \"e \", \"3 \"\\],\\[ \"t \", \"7 \"\\],\\[ \"t \", \"8 \"\\],\\[ \"d \", \"b \"\\],\\[ \"p \", \"b \"\\]\\]\n**Output:** true\n**Explanation:** Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'.\nNow sub =  \"l33tb \" is a substring of s, so we return true."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sub.length <= s.length <= 5000`\n*   `0 <= mappings.length <= 1000`\n*   `mappings[i].length == 2`\n*   `oldi != newi`\n*   `s` and `sub` consist of uppercase and lowercase English letters and digits.\n*   `oldi` and `newi` are either uppercase or lowercase English letters or digits.\n\n0 <= i < j < n and nums\\[i\\] % k + nums\\[j\\] % k == k.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "String Matching"
        ],
        "example": [
            {
                "input": "\"fool3e7bar\",\"leet\",[[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]",
                "output": "true"
            },
            {
                "input": "\"fooleetbar\",\"f00l\",[[\"o\",\"0\"]]",
                "output": "false"
            },
            {
                "input": "\"Fool33tbaR\",\"leetd\",[[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic int countPairs(int[] nums, int k) {\n    int[] mod_count = new int[k];\n    int count = 0;\n    \n    for(int num : nums) {\n        mod_count[num % k]++;\n    }\n\n    count += mod_count[0] * (mod_count[0] - 1) / 2;\n\n    for(int i = 1; i <= k/2; i++) {\n        if (i != k - i) {\n            count += mod_count[i] * mod_count[k-i];\n        } else {\n            count += mod_count[i] * (mod_count[i] - 1) / 2;\n        }\n    }\n    return count;\n}\n```\n\n    \n    1. Create an array `mod_count` of size k and initialize it with zeros. This array will store the frequency of each remainder when dividing the array elements by k.\n2. Iterate through the input array `nums`, calculate the remainder when dividing each element by k, and increment the corresponding element in the `mod_count` array.\n3. Calculate the pairs that have k as sum of the reminders. For this purpose:\n   a. Calculate the pairs with both elements having 0 as reminder and add it to the count.\n   b. Iterate through the possible divisors `i` of k (1 to k/2). If i is not equal to k-i, then add the product of both mod_counts to the final count. Otherwise, add the count of the valid pairs for the same reminder to the final count.\n4. Return the final count of the pairs.\n    ",
        "python": "\n    ```python\ndef count_pairs(nums, k):\n    mod_count = [0] * k\n    count = 0\n\n    for num in nums:\n        mod_count[num % k] += 1\n\n    count += mod_count[0] * (mod_count[0] - 1) // 2\n\n    for i in range(1, k // 2 + 1):\n        if i != k - i:\n            count += mod_count[i] * mod_count[k-i]\n        else:\n            count += mod_count[i] * (mod_count[i] - 1) // 2\n\n    return count\n```\n\n    \n    1. Create an array `mod_count` of size k and initialize it with zeros. This array will store the frequency of each remainder when dividing the array elements by k.\n2. Iterate through the input array `nums`, calculate the remainder when dividing each element by k, and increment the corresponding element in the `mod_count` array.\n3. Calculate the pairs that have k as sum of the reminders. For this purpose:\n   a. Calculate the pairs with both elements having 0 as reminder and add it to the count.\n   b. Iterate through the possible divisors `i` of k (1 to k/2). If i is not equal to k-i, then add the product of both mod_counts to the final count. Otherwise, add the count of the valid pairs for the same reminder to the final count.\n4. Return the final count of the pairs.\n    ",
        "c++": "\n    ```cpp\nint countPairs(vector<int>& nums, int k) {\n    vector<int> mod_count(k, 0);\n    int count = 0;\n    \n    for(int num : nums) {\n        mod_count[num % k]++;\n    }\n  \n    count += mod_count[0] * (mod_count[0] - 1) / 2;\n  \n    for(int i = 1; i <= k/2; i++) {\n        if(i != k - i){\n            count += mod_count[i] * mod_count[k-i];\n        } else {\n            count += mod_count[i] * (mod_count[i] - 1) / 2;\n        }\n    }\n    return count;\n}\n```\n\n    \n    1. Create an array `mod_count` of size k and initialize it with zeros. This array will store the frequency of each remainder when dividing the array elements by k.\n2. Iterate through the input array `nums`, calculate the remainder when dividing each element by k, and increment the corresponding element in the `mod_count` array.\n3. Calculate the pairs that have k as sum of the reminders. For this purpose:\n   a. Calculate the pairs with both elements having 0 as reminder and add it to the count.\n   b. Iterate through the possible divisors `i` of k (1 to k/2). If i is not equal to k-i, then add the product of both mod_counts to the final count. Otherwise, add the count of the valid pairs for the same reminder to the final count.\n4. Return the final count of the pairs.\n    ",
        "js": "\n    ```javascript\nfunction countPairs(nums, k) {\n    const mod_count = new Array(k).fill(0);\n    let count = 0;\n\n    for (const num of nums) {\n        mod_count[num % k]++;\n    }\n    \n    count += mod_count[0] * (mod_count[0] - 1) / 2;\n\n    for (let i = 1; i <= Math.floor(k / 2); i++) {\n        if (i != k - i) {\n            count += mod_count[i] * mod_count[k-i];\n        } else {\n            count += mod_count[i] * (mod_count[i] - 1) / 2;\n        }\n    }\n\n    return count;\n}\n```\n\n    \n    1. Create an array `mod_count` of size k and initialize it with zeros. This array will store the frequency of each remainder when dividing the array elements by k.\n2. Iterate through the input array `nums`, calculate the remainder when dividing each element by k, and increment the corresponding element in the `mod_count` array.\n3. Calculate the pairs that have k as sum of the reminders. For this purpose:\n   a. Calculate the pairs with both elements having 0 as reminder and add it to the count.\n   b. Iterate through the possible divisors `i` of k (1 to k/2). If i is not equal to k-i, then add the product of both mod_counts to the final count. Otherwise, add the count of the valid pairs for the same reminder to the final count.\n4. Return the final count of the pairs.\n    "
    },
    {
        "id": 391,
        "title": "Count Subarrays With Score Less Than K",
        "difficulty": "Hard",
        "content": {
            "problem": "The **score** of an array is defined as the **product** of its sum and its length.\n\n*   For example, the score of `[1, 2, 3, 4, 5]` is `(1 + 2 + 3 + 4 + 5) * 5 = 75`.\n\nGiven a positive integer array `nums` and an integer `k`, return _the **number of non-empty subarrays** of_ `nums` _whose score is **strictly less** than_ `k`.\n\nA **subarray** is a contiguous sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,4,3,5\\], k = 10\n**Output:** 6\n**Explanation:**\nThe 6 subarrays having scores less than 10 are:\n- \\[2\\] with score 2 \\* 1 = 2.\n- \\[1\\] with score 1 \\* 1 = 1.\n- \\[4\\] with score 4 \\* 1 = 4.\n- \\[3\\] with score 3 \\* 1 = 3. \n- \\[5\\] with score 5 \\* 1 = 5.\n- \\[2,1\\] with score (2 + 1) \\* 2 = 6.\nNote that subarrays such as \\[1,4\\] and \\[4,3,5\\] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\], k = 5\n**Output:** 5\n**Explanation:**\nEvery subarray except \\[1,1,1\\] has a score less than 5.\n\\[1,1,1\\] has a score (1 + 1 + 1) \\* 3 = 9, which is greater than 5.\nThus, there are 5 subarrays having scores less than 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\n*   `1 <= k <= 1015`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[2,1,4,3,5],10",
                "output": "6"
            },
            {
                "input": "[1,1,1],5",
                "output": "5"
            }
        ],
        "java": "\n    ```java\npublic int countSubarrays(int[] nums, long k) {\n    int n = nums.length;\n    int left = 0, right = 0;\n    long sum = 0, count = 0;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) >= k) {\n            sum -= nums[left];\n            left++;\n        }\n        count += right - left + 1;\n        right++;\n    }\n\n    return (int)count;\n}\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "python": "\n    ```python\ndef countSubarrays(nums: List[int], k: int) -> int:\n    n = len(nums)\n    left, right = 0, 0\n    sum_, count = 0, 0\n\n    while right < n:\n        sum_ += nums[right]\n        while sum_ * (right - left + 1) >= k:\n            sum_ -= nums[left]\n            left += 1\n        count += right - left + 1\n        right += 1\n\n    return count\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "c++": "\n    ```cpp\nint countSubarrays(vector<int>& nums, long long k) {\n    int n = nums.size();\n    int left = 0, right = 0;\n    long long sum = 0, count = 0;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) >= k) {\n            sum -= nums[left];\n            left++;\n        }\n        count += right - left + 1;\n        right++;\n    }\n\n    return count;\n}\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    ",
        "js": "\n    ```javascript\nfunction countSubarrays(nums, k) {\n    let n = nums.length;\n    let left = 0, right = 0;\n    let sum = 0, count = 0;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) >= k) {\n            sum -= nums[left];\n            left++;\n        }\n        count += right - left + 1;\n        right++;\n    }\n\n    return count;\n}\n```\n    \n    We use the sliding window technique to solve this problem as it ensures that we only check relevant subarrays. \n\n1. Initialize two pointers `left` and `right` to 0 and variables `sum` and `count` to 0.\n\n2. Iterate through the array using the `right` pointer.\n\n3. Inside the loop, add the current value of `nums[right]` to the current sum.\n\n4. Inside the loop, use the inner `while` loop to check if the score `sum * (right - left + 1)` is equal to or greater than `k`. If true, subtract the value at `nums[left]` from the sum and increment `left`.\n\n5. Add the number of subarrays calculated at this step to the count: `count += right - left + 1`.\n\n6. Increment the right pointer.\n\n7. Continue iterating until the entire array is traversed.\n\n8. Return the count of subarrays with scores less than `k`.\n    "
    },
    {
        "id": 392,
        "title": "Naming a Company",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of strings `ideas` that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:\n\n1.  Choose 2 **distinct** names from `ideas`, call them `ideaA` and `ideaB`.\n2.  Swap the first letters of `ideaA` and `ideaB` with each other.\n3.  If **both** of the new names are not found in the original `ideas`, then the name `ideaA ideaB` (the **concatenation** of `ideaA` and `ideaB`, separated by a space) is a valid company name.\n4.  Otherwise, it is not a valid name.\n\nReturn _the number of **distinct** valid names for the company_.",
            "examples": [
                "**Example 1:**\n\n**Input:** ideas = \\[ \"coffee \", \"donuts \", \"time \", \"toffee \"\\]\n**Output:** 6\n**Explanation:** The following selections are valid:\n- ( \"coffee \",  \"donuts \"): The company name created is  \"doffee conuts \".\n- ( \"donuts \",  \"coffee \"): The company name created is  \"conuts doffee \".\n- ( \"donuts \",  \"time \"): The company name created is  \"tonuts dime \".\n- ( \"donuts \",  \"toffee \"): The company name created is  \"tonuts doffee \".\n- ( \"time \",  \"donuts \"): The company name created is  \"dime tonuts \".\n- ( \"toffee \",  \"donuts \"): The company name created is  \"doffee tonuts \".\nTherefore, there are a total of 6 distinct company names.\n\nThe following are some examples of invalid selections:\n- ( \"coffee \",  \"time \"): The name  \"toffee \" formed after swapping already exists in the original array.\n- ( \"time \",  \"toffee \"): Both names are still the same after swapping and exist in the original array.\n- ( \"coffee \",  \"toffee \"): Both names formed after swapping already exist in the original array.\n\n",
                "**Example 2:**\n\n**Input:** ideas = \\[ \"lack \", \"back \"\\]\n**Output:** 0\n**Explanation:** There are no valid selections. Therefore, 0 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= ideas.length <= 5 * 104`\n*   `1 <= ideas[i].length <= 10`\n*   `ideas[i]` consists of lowercase English letters.\n*   All the strings in `ideas` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "String",
            "Bit Manipulation",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[\"coffee\",\"donuts\",\"time\",\"toffee\"]",
                "output": "6"
            },
            {
                "input": "[\"lack\",\"back\"]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic TreeNode constructTree(int[][] descriptions) {\n    HashMap<Integer, TreeNode> nodes = new HashMap<>();\n    for (int[] d : descriptions) {\n        nodes.put(d[0], new TreeNode(d[0]));\n        nodes.put(d[1], new TreeNode(d[1]));\n    }\n\n    for (int[] d : descriptions) {\n        if (d[2] == 1)\n            nodes.get(d[0]).left = nodes.get(d[1]);\n        else\n            nodes.get(d[0]).right = nodes.get(d[1]);\n    }\n\n    return nodes.get(descriptions[0][0]);\n}\n```\n    \n    The algorithm first initializes an empty binary tree structure and steps through the input descriptions. For each description, it creates the TreeNode instances for each parent and child. Then, it links the parent with the child according to the 'isLefti' value in each description.\n\n1. Create a TreeNode class with `val`, `left`, and `right`, which represents our binary tree structure.\n2. Create a function `constructTree` that accepts the descriptions input and initializes an empty hash_map (or dictionary in Python, Map in JavaScript) called `nodes` to store the parent and children node references.\n3. For each description in the input, create TreeNode instances for the parent and child nodes (if not already created) and store them in our `nodes` hash table using their respective values as keys.\n4. Iterate through the input descriptions again to connect each parent with its child(ren) based on the 'isLefti' value.\n5. Return the root of the tree, which is the first parent in the given descriptions.\n    ",
        "python": "\n    ```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef construct_tree(descriptions):\n    nodes = {}\n\n    for d in descriptions:\n        nodes[d[0]] = TreeNode(d[0])\n        nodes[d[1]] = TreeNode(d[1])\n\n    for d in descriptions:\n        if d[2]:\n            nodes[d[0]].left = nodes[d[1]]\n        else:\n            nodes[d[0]].right = nodes[d[1]]\n\n    return nodes[descriptions[0][0]]\n```\n    \n    The algorithm first initializes an empty binary tree structure and steps through the input descriptions. For each description, it creates the TreeNode instances for each parent and child. Then, it links the parent with the child according to the 'isLefti' value in each description.\n\n1. Create a TreeNode class with `val`, `left`, and `right`, which represents our binary tree structure.\n2. Create a function `constructTree` that accepts the descriptions input and initializes an empty hash_map (or dictionary in Python, Map in JavaScript) called `nodes` to store the parent and children node references.\n3. For each description in the input, create TreeNode instances for the parent and child nodes (if not already created) and store them in our `nodes` hash table using their respective values as keys.\n4. Iterate through the input descriptions again to connect each parent with its child(ren) based on the 'isLefti' value.\n5. Return the root of the tree, which is the first parent in the given descriptions.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nTreeNode* constructTree(std::vector<std::vector<int>>& descriptions) {\n    std::unordered_map<int, TreeNode*> nodes;\n    for (const auto& d : descriptions) {\n        nodes[d[0]] = new TreeNode(d[0]);\n        nodes[d[1]] = new TreeNode(d[1]);\n    }\n    \n    for (const auto& d : descriptions) {\n        if (d[2])\n            nodes[d[0]]->left = nodes[d[1]];\n        else\n            nodes[d[0]]->right = nodes[d[1]];\n    }\n  \n    return nodes[descriptions.front()[0]];\n}\n```\n    \n    The algorithm first initializes an empty binary tree structure and steps through the input descriptions. For each description, it creates the TreeNode instances for each parent and child. Then, it links the parent with the child according to the 'isLefti' value in each description.\n\n1. Create a TreeNode class with `val`, `left`, and `right`, which represents our binary tree structure.\n2. Create a function `constructTree` that accepts the descriptions input and initializes an empty hash_map (or dictionary in Python, Map in JavaScript) called `nodes` to store the parent and children node references.\n3. For each description in the input, create TreeNode instances for the parent and child nodes (if not already created) and store them in our `nodes` hash table using their respective values as keys.\n4. Iterate through the input descriptions again to connect each parent with its child(ren) based on the 'isLefti' value.\n5. Return the root of the tree, which is the first parent in the given descriptions.\n    ",
        "js": "\n    ```javascript\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction constructTree(descriptions) {\n    const nodes = new Map();\n\n    for (const d of descriptions) {\n        nodes.set(d[0], new TreeNode(d[0]));\n        nodes.set(d[1], new TreeNode(d[1]));\n    }\n\n    for (const d of descriptions) {\n        if (d[2] === 1)\n            nodes.get(d[0]).left = nodes.get(d[1]);\n        else\n            nodes.get(d[0]).right = nodes.get(d[1]);\n    }\n\n    return nodes.get(descriptions[0][0]);\n}\n```\n    \n    The algorithm first initializes an empty binary tree structure and steps through the input descriptions. For each description, it creates the TreeNode instances for each parent and child. Then, it links the parent with the child according to the 'isLefti' value in each description.\n\n1. Create a TreeNode class with `val`, `left`, and `right`, which represents our binary tree structure.\n2. Create a function `constructTree` that accepts the descriptions input and initializes an empty hash_map (or dictionary in Python, Map in JavaScript) called `nodes` to store the parent and children node references.\n3. For each description in the input, create TreeNode instances for the parent and child nodes (if not already created) and store them in our `nodes` hash table using their respective values as keys.\n4. Iterate through the input descriptions again to connect each parent with its child(ren) based on the 'isLefti' value.\n5. Return the root of the tree, which is the first parent in the given descriptions.\n    "
    },
    {
        "id": 393,
        "title": "Selling Pieces of Wood",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.\n\nTo cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you **cannot** rotate a piece to swap its height and width.\n\nReturn _the **maximum** money you can earn after cutting an_ `m x n` _piece of wood_.\n\nNote that you can cut the piece of wood as many times as you want.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 5, prices = \\[\\[1,4,2\\],\\[2,2,7\\],\\[2,1,3\\]\\]\n**Output:** 19\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \\* 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 \\* 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n\n",
                "**Example 2:**\n\n**Input:** m = 4, n = 6, prices = \\[\\[3,2,10\\],\\[1,4,2\\],\\[4,1,3\\]\\]\n**Output:** 32\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \\* 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 200`\n*   `1 <= prices.length <= 2 * 104`\n*   `prices[i].length == 3`\n*   `1 <= hi <= m`\n*   `1 <= wi <= n`\n*   `1 <= pricei <= 106`\n*   All the shapes of wood `(hi, wi)` are pairwise **distinct**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "3,5,[[1,4,2],[2,2,7],[2,1,3]]",
                "output": "19"
            },
            {
                "input": "4,6,[[3,2,10],[1,4,2],[4,1,3]]",
                "output": "32"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int maxCountTarget(int[] nums, int key) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    int max_count = 0;\n    int max_target = -1;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i - 1] == key) {\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\n            if (count.get(nums[i]) > max_count) {\n                max_count = count.get(nums[i]);\n                max_target = nums[i];\n            }\n        }\n    }\n    return max_target;\n}\n```\n    \n    1. Create a hash map (called `count`) to store the count of unique integers following the key.\n2. Initialize `max_count` to 0 and `max_target` to -1.\n3. Iterate through the array from index 1 to the end.\n4. In each iteration, check if the element at the previous index is equal to the key.\n5. If the previous element is equal to the key, increment the count of the current element in the hash map.\n6. If the incremented count is greater than the current `max_count`, update `max_count` to the incremented count and `max_target` to the current element.\n7. Return `max_target`.\n    ",
        "python": "\n    ```python\ndef max_count_target(nums, key):\n    count = {}\n    max_count = 0\n    max_target = -1\n    for i in range(1, len(nums)):\n        if nums[i - 1] == key:\n            count[nums[i]] = count.get(nums[i], 0) + 1\n            if count[nums[i]] > max_count:\n                max_count = count[nums[i]]\n                max_target = nums[i]\n    return max_target\n```\n    \n    1. Create a hash map (called `count`) to store the count of unique integers following the key.\n2. Initialize `max_count` to 0 and `max_target` to -1.\n3. Iterate through the array from index 1 to the end.\n4. In each iteration, check if the element at the previous index is equal to the key.\n5. If the previous element is equal to the key, increment the count of the current element in the hash map.\n6. If the incremented count is greater than the current `max_count`, update `max_count` to the incremented count and `max_target` to the current element.\n7. Return `max_target`.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint maxCountTarget(const std::vector<int>& nums, int key) {\n    std::unordered_map<int, int> count;\n    int max_count = 0;\n    int max_target = -1;\n    for (size_t i = 1; i < nums.size(); ++i) {\n        if (nums[i - 1] == key) {\n            count[nums[i]]++;\n            if (count[nums[i]] > max_count) {\n                max_count = count[nums[i]];\n                max_target = nums[i];\n            }\n        }\n    }\n    return max_target;\n}\n```\n    \n    1. Create a hash map (called `count`) to store the count of unique integers following the key.\n2. Initialize `max_count` to 0 and `max_target` to -1.\n3. Iterate through the array from index 1 to the end.\n4. In each iteration, check if the element at the previous index is equal to the key.\n5. If the previous element is equal to the key, increment the count of the current element in the hash map.\n6. If the incremented count is greater than the current `max_count`, update `max_count` to the incremented count and `max_target` to the current element.\n7. Return `max_target`.\n    ",
        "js": "\n    ```javascript\nfunction maxCountTarget(nums, key) {\n    let count = new Map();\n    let maxCount = 0;\n    let maxTarget = -1;\n    for (let i = 1; i < nums.length; ++i) {\n        if (nums[i - 1] === key) {\n            count.set(nums[i], (count.get(nums[i]) || 0) + 1);\n            if (count.get(nums[i]) > maxCount) {\n                maxCount = count.get(nums[i]);\n                maxTarget = nums[i];\n            }\n        }\n    }\n    return maxTarget;\n}\n```\n    \n    1. Create a hash map (called `count`) to store the count of unique integers following the key.\n2. Initialize `max_count` to 0 and `max_target` to -1.\n3. Iterate through the array from index 1 to the end.\n4. In each iteration, check if the element at the previous index is equal to the key.\n5. If the previous element is equal to the key, increment the count of the current element in the hash map.\n6. If the incremented count is greater than the current `max_count`, update `max_count` to the incremented count and `max_target` to the current element.\n7. Return `max_target`.\n    "
    },
    {
        "id": 394,
        "title": "Number of Distinct Roll Sequences",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n`. You roll a fair 6-sided dice `n` times. Determine the total number of **distinct** sequences of rolls possible such that the following conditions are satisfied:\n\n1.  The **greatest common divisor** of any **adjacent** values in the sequence is equal to `1`.\n2.  There is **at least** a gap of `2` rolls between **equal** valued rolls. More formally, if the value of the `ith` roll is **equal** to the value of the `jth` roll, then `abs(i - j) > 2`.\n\nReturn _the **total number** of distinct sequences possible_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered distinct if at least one element is different.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 184\n**Explanation:** Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.\nSome invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).\n(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.\nThere are a total of 184 distinct sequences possible, so we return 184.\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** 22\n**Explanation:** Some of the possible sequences are (1, 2), (2, 1), (3, 2).\nSome invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.\nThere are a total of 22 distinct sequences possible, so we return 22."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": null
        },
        "tag": [
            "Dynamic Programming",
            "Memoization"
        ],
        "example": [
            {
                "input": "4",
                "output": "184"
            },
            {
                "input": "2",
                "output": "22"
            }
        ],
        "java": "\n    ```java\npublic int[] bobArrows(int numArrows, int[] aliceArrows) {\n    int[] bob = new int[12];\n    for (int i = 11; i >= 0 && numArrows > 0; i--) {\n        if (aliceArrows[i] == 0) {\n            int shot = Math.min(numArrows, i + 1);\n            bob[i] = shot;\n            numArrows -= shot;\n        }\n    }\n    return bob;\n}\n```\n\n    \n    To maximize Bob's total points, he should prioritize shooting at sections with higher scores where Alice has not shot any arrows. The algorithm follows these steps:\n\n1. Initialize an array `bob` representing Bob's arrows shot in each section. Fill it with zeroes.\n2. Traverse the array `aliceArrows` from the last element (highest score) to the first element (lowest score).\n3. If the current element of `aliceArrows` is 0 (Alice hasn't shot any arrows in the current section) and Bob still has arrows left, calculate the number of arrows Bob should shoot in this section as `min(numArrows, i+1)` (`i+1` is equal to the score of the current section).\n4. Update the corresponding element of `bob` array with the number of arrows to be shot and decrement `numArrows` accordingly.\n5. Repeat steps 3-4 for each section until either Bob runs out of arrows or all 12 sections have been checked.\n6. Return Bob's shots taken in each section as the result.\n    ",
        "python": "\n    ```python\ndef bob_arrows(num_arrows, alice_arrows):\n    bob = [0] * 12\n    for i in range(11, -1, -1):\n        if num_arrows > 0 and alice_arrows[i] == 0:\n            shot = min(num_arrows, i+1)\n            bob[i] = shot\n            num_arrows -= shot\n    return bob\n```\n\n    \n    To maximize Bob's total points, he should prioritize shooting at sections with higher scores where Alice has not shot any arrows. The algorithm follows these steps:\n\n1. Initialize an array `bob` representing Bob's arrows shot in each section. Fill it with zeroes.\n2. Traverse the array `aliceArrows` from the last element (highest score) to the first element (lowest score).\n3. If the current element of `aliceArrows` is 0 (Alice hasn't shot any arrows in the current section) and Bob still has arrows left, calculate the number of arrows Bob should shoot in this section as `min(numArrows, i+1)` (`i+1` is equal to the score of the current section).\n4. Update the corresponding element of `bob` array with the number of arrows to be shot and decrement `numArrows` accordingly.\n5. Repeat steps 3-4 for each section until either Bob runs out of arrows or all 12 sections have been checked.\n6. Return Bob's shots taken in each section as the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> bobArrows(int numArrows, vector<int> aliceArrows) {\n    vector<int> bob(12, 0);\n    for (int i = 11; i >= 0 && numArrows > 0; --i) {\n        if (aliceArrows[i] == 0) {\n            int shot = min(numArrows, i+1);\n            bob[i] = shot;\n            numArrows -= shot;\n        }\n    }\n    return bob;\n}\n```\n\n    \n    To maximize Bob's total points, he should prioritize shooting at sections with higher scores where Alice has not shot any arrows. The algorithm follows these steps:\n\n1. Initialize an array `bob` representing Bob's arrows shot in each section. Fill it with zeroes.\n2. Traverse the array `aliceArrows` from the last element (highest score) to the first element (lowest score).\n3. If the current element of `aliceArrows` is 0 (Alice hasn't shot any arrows in the current section) and Bob still has arrows left, calculate the number of arrows Bob should shoot in this section as `min(numArrows, i+1)` (`i+1` is equal to the score of the current section).\n4. Update the corresponding element of `bob` array with the number of arrows to be shot and decrement `numArrows` accordingly.\n5. Repeat steps 3-4 for each section until either Bob runs out of arrows or all 12 sections have been checked.\n6. Return Bob's shots taken in each section as the result.\n    ",
        "js": "\n    ```javascript\nfunction bobArrows(numArrows, aliceArrows) {\n    let bob = Array(12).fill(0);\n    for (let i = 11; i >= 0 && numArrows > 0; i--) {\n        if (aliceArrows[i] === 0) {\n            let shot = Math.min(numArrows, i + 1);\n            bob[i] = shot;\n            numArrows -= shot;\n        }\n    }\n    return bob;\n}\n```\n\n    \n    To maximize Bob's total points, he should prioritize shooting at sections with higher scores where Alice has not shot any arrows. The algorithm follows these steps:\n\n1. Initialize an array `bob` representing Bob's arrows shot in each section. Fill it with zeroes.\n2. Traverse the array `aliceArrows` from the last element (highest score) to the first element (lowest score).\n3. If the current element of `aliceArrows` is 0 (Alice hasn't shot any arrows in the current section) and Bob still has arrows left, calculate the number of arrows Bob should shoot in this section as `min(numArrows, i+1)` (`i+1` is equal to the score of the current section).\n4. Update the corresponding element of `bob` array with the number of arrows to be shot and decrement `numArrows` accordingly.\n5. Repeat steps 3-4 for each section until either Bob runs out of arrows or all 12 sections have been checked.\n6. Return Bob's shots taken in each section as the result.\n    "
    },
    {
        "id": 395,
        "title": "Maximum Score Of Spliced Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `nums1` and `nums2`, both of length `n`.\n\nYou can choose two integers `left` and `right` where `0 <= left <= right < n` and **swap** the subarray `nums1[left...right]` with the subarray `nums2[left...right]`.\n\n*   For example, if `nums1 = [1,2,3,4,5]` and `nums2 = [11,12,13,14,15]` and you choose `left = 1` and `right = 2`, `nums1` becomes `[1,**12,13**,4,5]` and `nums2` becomes `[11,**2,3**,14,15]`.\n\nYou may choose to apply the mentioned operation **once** or not do anything.\n\nThe **score** of the arrays is the **maximum** of `sum(nums1)` and `sum(nums2)`, where `sum(arr)` is the sum of all the elements in the array `arr`.\n\nReturn _the **maximum possible score**_.\n\nA **subarray** is a contiguous sequence of elements within an array. `arr[left...right]` denotes the subarray that contains the elements of `nums` between indices `left` and `right` (**inclusive**).",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[60,60,60\\], nums2 = \\[10,90,10\\]\n**Output:** 210\n**Explanation:** Choosing left = 1 and right = 1, we have nums1 = \\[60,**90**,60\\] and nums2 = \\[10,**60**,10\\].\nThe score is max(sum(nums1), sum(nums2)) = max(210, 80) = 210.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[20,40,20,70,30\\], nums2 = \\[50,20,50,40,20\\]\n**Output:** 220\n**Explanation:** Choosing left = 3, right = 4, we have nums1 = \\[20,40,20,**40,20**\\] and nums2 = \\[50,20,50,**70,30**\\].\nThe score is max(sum(nums1), sum(nums2)) = max(140, 220) = 220.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[7,11,13\\], nums2 = \\[1,1,1\\]\n**Output:** 31\n**Explanation:** We choose not to swap any subarray.\nThe score is max(sum(nums1), sum(nums2)) = max(31, 3) = 31."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `1 <= nums1[i], nums2[i] <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[60,60,60],[10,90,10]",
                "output": "210"
            },
            {
                "input": "[20,40,20,70,30],[50,20,50,40,20]",
                "output": "220"
            },
            {
                "input": "[7,11,13],[1,1,1]",
                "output": "31"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int shortestPath(int n, int[][] edges, int src1, int src2, int dest) {\n        List<List<int[]>> graph = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        }\n\n        int[] src1ToAll = dijkstra(graph, src1);\n        int[] src2ToAll = dijkstra(graph, src2);\n\n        int minWeight = Integer.MAX_VALUE;\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            int w = edge[2];\n\n            minWeight = Math.min(minWeight, src1ToAll[u] + w + src2ToAll[v]);\n        }\n\n        return minWeight == Integer.MAX_VALUE ? -1 : minWeight;\n    }\n\n    private int[] dijkstra(List<List<int[]>> graph, int src) {\n        int n = graph.size();\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        dist[src] = 0;\n        pq.offer(new int[]{0, src});\n\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int d = cur[0];\n            int u = cur[1];\n\n            if (d != dist[u]) continue;\n\n            for (int[] edge : graph.get(u)) {\n                int v = edge[0];\n                int w = edge[1];\n\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    pq.offer(new int[]{dist[v], v});\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n```\n\n    \n    In this problem, we need to find the minimum weight subgraph such that we can reach `dest` from both `src1` and `src2`.\n\n1. First, we convert the input `edges` into an adjacency list representation of the input graph for easier traversal.\n2. Next, we define a `dijkstra(src)` function, which takes a source node `src` as input and returns the shortest paths from `src` to all other nodes of the graph.\n3. Now we find the shortest paths from `src1` to all other nodes and from `src2` to all other nodes, using the `dijkstra` function.\n4. Finally, we loop over all the input edges, and for each edge (u, v, w), we sum up the weights of the shortest paths from `src1` to u, from src2 to v, and the weight w of the edge itself. We keep track of the minimum weight found, and return it.\n\nIf the minimum weight is still `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, or `Infinity` in C++, Java, Python, and JavaScript respectively, that means there is no valid path, so we return -1. Otherwise, we return the minimum weight.\n\nThe time complexity of this solution is O(n + m * log(m)) where n is the number of nodes and m is the number of edges in the graph. This is because Dijkstra's algorithm runs in O(n + m * log(m)) and we call it twice. Also, we loop through all the edges in the end to find the minimum weight.\n    ",
        "python": "\n    ```python\nimport heapq\nfrom collections import defaultdict\n\ndef shortest_path(n, edges, src1, src2, dest):\n    graph = defaultdict(list)\n    \n    for u, v, w in edges:\n        graph[u].append((v, w))\n    \n    def dijkstra(src):\n        dist = [float('inf')] * n\n        pq = [(0, src)]\n\n        dist[src] = 0\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            if d != dist[u]:\n                continue\n\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n\n        return dist\n\n    src1_to_all = dijkstra(src1)\n    src2_to_all = dijkstra(src2)\n\n    min_weight = float('inf')\n    for u, v, w in edges:\n        min_weight = min(min_weight, src1_to_all[u] + w + src2_to_all[v])\n\n    return -1 if min_weight == float('inf') else min_weight\n```\n\n    \n    In this problem, we need to find the minimum weight subgraph such that we can reach `dest` from both `src1` and `src2`.\n\n1. First, we convert the input `edges` into an adjacency list representation of the input graph for easier traversal.\n2. Next, we define a `dijkstra(src)` function, which takes a source node `src` as input and returns the shortest paths from `src` to all other nodes of the graph.\n3. Now we find the shortest paths from `src1` to all other nodes and from `src2` to all other nodes, using the `dijkstra` function.\n4. Finally, we loop over all the input edges, and for each edge (u, v, w), we sum up the weights of the shortest paths from `src1` to u, from src2 to v, and the weight w of the edge itself. We keep track of the minimum weight found, and return it.\n\nIf the minimum weight is still `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, or `Infinity` in C++, Java, Python, and JavaScript respectively, that means there is no valid path, so we return -1. Otherwise, we return the minimum weight.\n\nThe time complexity of this solution is O(n + m * log(m)) where n is the number of nodes and m is the number of edges in the graph. This is because Dijkstra's algorithm runs in O(n + m * log(m)) and we call it twice. Also, we loop through all the edges in the end to find the minimum weight.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint shortestPath(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\n    vector<vector<pair<int, int>>> graph(n);\n\n    for (const auto& edge : edges) {\n        graph[edge[0]].emplace_back(edge[1], edge[2]);\n    }\n\n    auto dijkstra = [&](int src) {\n        vector<int> dist(n, INT_MAX);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n        dist[src] = 0;\n        pq.emplace(0, src);\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int d = pq.top().first;\n            pq.pop();\n\n            if (d != dist[u]) continue;\n\n            for (const auto& edge : graph[u]) {\n                int v = edge.first;\n                int w = edge.second;\n\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    pq.emplace(dist[v], v);\n                }\n            }\n        }\n\n        return dist;\n    };\n\n    vector<int> src1_to_all = dijkstra(src1);\n    vector<int> src2_to_all = dijkstra(src2);\n\n    int min_weight = INT_MAX;\n    for (const auto& edge : edges) {\n        int u = edge[0];\n        int v = edge[1];\n        int w = edge[2];\n        min_weight = min(min_weight, src1_to_all[u] + w + src2_to_all[v]);\n    }\n\n    return min_weight == INT_MAX ? -1 : min_weight;\n}\n```\n\n    \n    In this problem, we need to find the minimum weight subgraph such that we can reach `dest` from both `src1` and `src2`.\n\n1. First, we convert the input `edges` into an adjacency list representation of the input graph for easier traversal.\n2. Next, we define a `dijkstra(src)` function, which takes a source node `src` as input and returns the shortest paths from `src` to all other nodes of the graph.\n3. Now we find the shortest paths from `src1` to all other nodes and from `src2` to all other nodes, using the `dijkstra` function.\n4. Finally, we loop over all the input edges, and for each edge (u, v, w), we sum up the weights of the shortest paths from `src1` to u, from src2 to v, and the weight w of the edge itself. We keep track of the minimum weight found, and return it.\n\nIf the minimum weight is still `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, or `Infinity` in C++, Java, Python, and JavaScript respectively, that means there is no valid path, so we return -1. Otherwise, we return the minimum weight.\n\nThe time complexity of this solution is O(n + m * log(m)) where n is the number of nodes and m is the number of edges in the graph. This is because Dijkstra's algorithm runs in O(n + m * log(m)) and we call it twice. Also, we loop through all the edges in the end to find the minimum weight.\n    ",
        "js": "\n    ```javascript\nfunction shortestPath(n, edges, src1, src2, dest) {\n    const graph = new Array(n).fill(null).map(() => []);\n    \n    edges.forEach(([u, v, w]) => {\n        graph[u].push([v, w]);\n    });\n\n    function dijkstra(src) {\n        const dist = new Array(n).fill(Infinity);\n        const pq = [[0, src]];\n\n        dist[src] = 0;\n\n        while (pq.length > 0) {\n            pq.sort((a, b) => a[0] - b[0]);\n            const [d, u] = pq.shift();\n\n            if (d !== dist[u]) continue;\n\n            for (const [v, w] of graph[u]) {\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    pq.push([dist[v], v]);\n                }\n            }\n        }\n\n        return dist;\n    }\n\n    const src1ToAll = dijkstra(src1);\n    const src2ToAll = dijkstra(src2);\n\n    let minWeight = Infinity;\n    edges.forEach(([u, v, w]) => {\n        minWeight = Math.min(minWeight, src1ToAll[u] + w + src2ToAll[v]);\n    });\n\n    return minWeight === Infinity ? -1 : minWeight;\n}\n```\n\n    \n    In this problem, we need to find the minimum weight subgraph such that we can reach `dest` from both `src1` and `src2`.\n\n1. First, we convert the input `edges` into an adjacency list representation of the input graph for easier traversal.\n2. Next, we define a `dijkstra(src)` function, which takes a source node `src` as input and returns the shortest paths from `src` to all other nodes of the graph.\n3. Now we find the shortest paths from `src1` to all other nodes and from `src2` to all other nodes, using the `dijkstra` function.\n4. Finally, we loop over all the input edges, and for each edge (u, v, w), we sum up the weights of the shortest paths from `src1` to u, from src2 to v, and the weight w of the edge itself. We keep track of the minimum weight found, and return it.\n\nIf the minimum weight is still `INT_MAX`, `Integer.MAX_VALUE`, `float('inf')`, or `Infinity` in C++, Java, Python, and JavaScript respectively, that means there is no valid path, so we return -1. Otherwise, we return the minimum weight.\n\nThe time complexity of this solution is O(n + m * log(m)) where n is the number of nodes and m is the number of edges in the graph. This is because Dijkstra's algorithm runs in O(n + m * log(m)) and we call it twice. Also, we loop through all the edges in the end to find the minimum weight.\n    "
    },
    {
        "id": 396,
        "title": "Minimum Score After Removals on a Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n1.  Get the XOR of all the values of the nodes for **each** of the three components respectively.\n2.  The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n*   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the **minimum** score of any possible pair of edge removals on the given tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,5,5,4,11\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\]\n**Output:** 9\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[1,3,4\\] with values \\[5,4,11\\]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node \\[0\\] with value \\[1\\]. Its XOR value is 1 = 1.\n- The 3rd component has node \\[2\\] with value \\[5\\]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,5,2,4,4,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[5,2\\],\\[4,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[3,4\\] with values \\[4,4\\]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes \\[1,0\\] with values \\[5,5\\]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes \\[2,5\\] with values \\[2,2\\]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 1000`\n*   `1 <= nums[i] <= 108`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Bit Manipulation",
            "Tree",
            "Depth-First Search"
        ],
        "example": [
            {
                "input": "[1,5,5,4,11],[[0,1],[1,2],[1,3],[3,4]]",
                "output": "9"
            },
            {
                "input": "[5,5,2,4,4,2],[[0,1],[1,2],[5,2],[4,3],[1,3]]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int dfs(int node, int parent, int[] xor_values, List<Integer>[] tree) {\n    int xor_value = xor_values[node];\n    for (int child : tree[node]) {\n        if (child != parent) {\n            xor_value ^= dfs(child, node, xor_values, tree);\n        }\n    }\n    return xor_value;\n}\n\npublic int minimumScore(int[] nums, int[][] edges) {\n    int n = nums.length;\n    List<Integer>[] tree = new ArrayList[n];\n    \n    for (int i = 0; i < n; i++) {\n        tree[i] = new ArrayList<>();\n    }\n    \n    for (int[] edge : edges) {\n        tree[edge[0]].add(edge[1]);\n        tree[edge[1]].add(edge[0]);\n    }\n    \n    int[] xor_values = new int[n];\n    for (int i = 0; i < n; i++) {\n        xor_values[i] = dfs(i, -1, nums, tree);\n    }\n    \n    int ans = Integer.MAX_VALUE;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int xor1 = xor_values[i];\n            int xor2 = xor_values[j] ^ nums[i];\n            int xor3 = nums[i] ^ nums[j];\n            int max_xor = Math.max(Math.max(xor1, xor2), xor3);\n            int min_xor = Math.min(Math.min(xor1, xor2), xor3);\n            ans = Math.min(ans, max_xor - min_xor);\n        }\n    }\n    \n    return ans;\n}\n```\n    \n    1. Construct the tree using an adjacency list.\n2. Calculate the XOR values for each subtree rooted at each node using a Depth First Search function. The DFS function will return the XOR value of the subtree rooted at a specific node by XOR'ing its value with the XOR values of its children subtrees.\n3. Iterate over all distinct pairs of nodes, and calculate the three XOR values using the precomputed XOR values of these nodes.\n   - xor1: the XOR value of the subtree rooted at the first node\n   - xor2: the XOR value of the subtree rooted at the second node without the xor1 value. This can be computed as xor_values[second_node] ^ nums[first_node] (using the property that x ^ x = 0)\n   - xor3: the XOR of the remaining nodes, which can be computed as nums[first_node] ^ nums[second_node] (since xor1 ^ xor2 ^ xor3 = 0)\n4. Calculate the difference between the largest and smallest among xor1, xor2, and xor3, and update the minimum score if the difference is smaller than the current minimum.\n5. Return the minimum score found.\n    ",
        "python": "\n    ```python\ndef dfs(node, parent, xor_values, tree):\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans\n```\n    \n    1. Construct the tree using an adjacency list.\n2. Calculate the XOR values for each subtree rooted at each node using a Depth First Search function. The DFS function will return the XOR value of the subtree rooted at a specific node by XOR'ing its value with the XOR values of its children subtrees.\n3. Iterate over all distinct pairs of nodes, and calculate the three XOR values using the precomputed XOR values of these nodes.\n   - xor1: the XOR value of the subtree rooted at the first node\n   - xor2: the XOR value of the subtree rooted at the second node without the xor1 value. This can be computed as xor_values[second_node] ^ nums[first_node] (using the property that x ^ x = 0)\n   - xor3: the XOR of the remaining nodes, which can be computed as nums[first_node] ^ nums[second_node] (since xor1 ^ xor2 ^ xor3 = 0)\n4. Calculate the difference between the largest and smallest among xor1, xor2, and xor3, and update the minimum score if the difference is smaller than the current minimum.\n5. Return the minimum score found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint dfs(int node, int parent, vector<int>& xor_values, vector<vector<int>>& tree) {\n    int xor_value = xor_values[node];\n    for (int child : tree[node]) {\n        if (child != parent) {\n            xor_value ^= dfs(child, node, xor_values, tree);\n        }\n    }\n    return xor_value;\n}\n\nint minimumScore(vector<int>& nums, vector<vector<int>>& edges) {\n    int n = nums.size();\n    vector<vector<int>> tree(n);\n    \n    for (vector<int>& edge : edges) {\n        tree[edge[0]].push_back(edge[1]);\n        tree[edge[1]].push_back(edge[0]);\n    }\n    \n    vector<int> xor_values(n);\n    for (int i = 0; i < n; ++i) {\n        xor_values[i] = dfs(i, -1, nums, tree);\n    }\n    \n    int ans = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int xor1 = xor_values[i];\n            int xor2 = xor_values[j] ^ nums[i];\n            int xor3 = nums[i] ^ nums[j];\n            int max_xor = max({xor1, xor2, xor3});\n            int min_xor = min({xor1, xor2, xor3});\n            ans = min(ans, max_xor - min_xor);\n        }\n    }\n    \n    return ans;\n}\n```\n    \n    1. Construct the tree using an adjacency list.\n2. Calculate the XOR values for each subtree rooted at each node using a Depth First Search function. The DFS function will return the XOR value of the subtree rooted at a specific node by XOR'ing its value with the XOR values of its children subtrees.\n3. Iterate over all distinct pairs of nodes, and calculate the three XOR values using the precomputed XOR values of these nodes.\n   - xor1: the XOR value of the subtree rooted at the first node\n   - xor2: the XOR value of the subtree rooted at the second node without the xor1 value. This can be computed as xor_values[second_node] ^ nums[first_node] (using the property that x ^ x = 0)\n   - xor3: the XOR of the remaining nodes, which can be computed as nums[first_node] ^ nums[second_node] (since xor1 ^ xor2 ^ xor3 = 0)\n4. Calculate the difference between the largest and smallest among xor1, xor2, and xor3, and update the minimum score if the difference is smaller than the current minimum.\n5. Return the minimum score found.\n    ",
        "js": "\n    ```javascript\nfunction dfs(node, parent, xor_values, tree) {\n    let xor_value = xor_values[node];\n    for (let child of tree[node]) {\n        if (child !== parent) {\n            xor_value ^= dfs(child, node, xor_values, tree);\n        }\n    }\n    return xor_value;\n}\n\nfunction minimumScore(nums, edges) {\n    const n = nums.length;\n    const tree = Array.from({length: n}, () => []);\n    \n    for (let edge of edges) {\n        tree[edge[0]].push(edge[1]);\n        tree[edge[1]].push(edge[0]);\n    }\n    \n    const xor_values = Array.from({length: n}, (_, i) => dfs(i, -1, nums, tree));\n    \n    let ans = Infinity;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            const xor1 = xor_values[i];\n            const xor2 = xor_values[j] ^ nums[i];\n            const xor3 = nums[i] ^ nums[j];\n            const max_xor = Math.max(xor1, xor2, xor3);\n            const min_xor = Math.min(xor1, xor2, xor3);\n            ans = Math.min(ans, max_xor - min_xor);\n        }\n    }\n    \n    return ans;\n}\n```\n    \n    1. Construct the tree using an adjacency list.\n2. Calculate the XOR values for each subtree rooted at each node using a Depth First Search function. The DFS function will return the XOR value of the subtree rooted at a specific node by XOR'ing its value with the XOR values of its children subtrees.\n3. Iterate over all distinct pairs of nodes, and calculate the three XOR values using the precomputed XOR values of these nodes.\n   - xor1: the XOR value of the subtree rooted at the first node\n   - xor2: the XOR value of the subtree rooted at the second node without the xor1 value. This can be computed as xor_values[second_node] ^ nums[first_node] (using the property that x ^ x = 0)\n   - xor3: the XOR of the remaining nodes, which can be computed as nums[first_node] ^ nums[second_node] (since xor1 ^ xor2 ^ xor3 = 0)\n4. Calculate the difference between the largest and smallest among xor1, xor2, and xor3, and update the minimum score if the difference is smaller than the current minimum.\n5. Return the minimum score found.\n    "
    },
    {
        "id": 397,
        "title": "Number of Increasing Paths in a Grid",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` integer matrix `grid`, where you can move from a cell to any adjacent cell in all `4` directions.\n\nReturn _the number of **strictly** **increasing** paths in the grid such that you can start from **any** cell and end at **any** cell._ Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[3,4\\]\\]\n**Output:** 8\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[1\\], \\[3\\], \\[4\\].\n- Paths with length 2: \\[1 -> 3\\], \\[1 -> 4\\], \\[3 -> 4\\].\n- Paths with length 3: \\[1 -> 3 -> 4\\].\nThe total number of paths is 4 + 3 + 1 = 8.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1\\],\\[2\\]\\]\n**Output:** 3\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[2\\].\n- Paths with length 2: \\[1 -> 2\\].\nThe total number of paths is 2 + 1 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Depth-First Search",
            "Breadth-First Search",
            "Graph",
            "Topological Sort",
            "Memoization",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,1],[3,4]]",
                "output": "8"
            },
            {
                "input": "[[1],[2]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic String addParentheses(String expression) {\n    return \"(\" + expression + \")\";\n}\n```\n\n    \n    The algorithm simply takes input expression and adds an opening parenthesis at the beginning of the expression, and a closing parenthesis at the end of the expression. Since the expression is in the form of \"<num1>+<num2>\", adding parenthesis around the whole expression does not change the value. Thus, it returns the smallest possible value as originally asked.\n    ",
        "python": "\n    ```python\ndef add_parentheses(expression: str) -> str:\n    return f\"({expression})\"\n```\n\n    \n    The algorithm simply takes input expression and adds an opening parenthesis at the beginning of the expression, and a closing parenthesis at the end of the expression. Since the expression is in the form of \"<num1>+<num2>\", adding parenthesis around the whole expression does not change the value. Thus, it returns the smallest possible value as originally asked.\n    ",
        "c++": "\n    ```cpp\n#include<string>\n\nstd::string addParentheses(std::string expression) {\n    return \"(\" + expression + \")\";\n}\n```\n\n    \n    The algorithm simply takes input expression and adds an opening parenthesis at the beginning of the expression, and a closing parenthesis at the end of the expression. Since the expression is in the form of \"<num1>+<num2>\", adding parenthesis around the whole expression does not change the value. Thus, it returns the smallest possible value as originally asked.\n    ",
        "js": "\n    ```javascript\nfunction addParentheses(expression) {\n    return \"(\" + expression + \")\";\n}\n```\n\n    \n    The algorithm simply takes input expression and adds an opening parenthesis at the beginning of the expression, and a closing parenthesis at the end of the expression. Since the expression is in the form of \"<num1>+<num2>\", adding parenthesis around the whole expression does not change the value. Thus, it returns the smallest possible value as originally asked.\n    "
    },
    {
        "id": 398,
        "title": "Subarray With Elements Greater Than Varying Threshold",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `threshold`.\n\nFind any subarray of `nums` of length `k` such that **every** element in the subarray is **greater** than `threshold / k`.\n\nReturn _the **size** of **any** such subarray_. If there is no such subarray, return `-1`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,4,3,1\\], threshold = 6\n**Output:** 3\n**Explanation:** The subarray \\[3,4,3\\] has a size of 3, and every element is greater than 6 / 3 = 2.\nNote that this is the only valid subarray.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,5,6,5,8\\], threshold = 7\n**Output:** 1\n**Explanation:** The subarray \\[8\\] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned.\nNote that the subarray \\[6,5\\] has a size of 2, and every element is greater than 7 / 2 = 3.5. \nSimilarly, the subarrays \\[6,5,6\\], \\[6,5,6,5\\], \\[6,5,6,5,8\\] also satisfy the given conditions.\nTherefore, 2, 3, 4, or 5 may also be returned."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i], threshold <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Stack",
            "Union Find",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[1,3,4,3,1],6",
                "output": "3"
            },
            {
                "input": "[6,5,6,5,8],7",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int findSubarrayLength(int[] nums, int threshold) {\n    int n = nums.length, left = 0, right = 0, sum = 0, maxLength = -1;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) < threshold * (right - left + 1)) {\n            sum -= nums[left];\n            left++;\n        }\n        maxLength = Math.max(maxLength, right - left + 1);\n        right++;\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm is a sliding window approach. We initialize left and right pointers at the beginning of the array, and a sum variable. We also initialize maxLength to -1 to handle the case where there is no valid subarray.\n\nIn the loop, we move the right pointer, adding the element at that position to the sum. We then check if the sum times the length of the current window (right - left + 1) is less than the threshold times the length of the current window. If it is, we move the left pointer and subtract that value from the sum to maintain the sum of elements in the window.\n\nAt each step, we update maxLength to the maximum of the current maxLength and the length of the current window (right - left + 1). This way, we store the maximum length we've found so far.\n\nAfter the loop, we return maxLength, which is the final answer.\n    ",
        "python": "\n    ```python\ndef find_subarray_length(nums, threshold):\n    n = len(nums)\n    left = 0\n    right = 0\n    total = 0\n    max_length = -1\n\n    while right < n:\n        total += nums[right]\n        while total * (right - left + 1) < threshold * (right - left + 1):\n            total -= nums[left]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n        right += 1\n\n    return max_length\n```\n    \n    The algorithm is a sliding window approach. We initialize left and right pointers at the beginning of the array, and a sum variable. We also initialize maxLength to -1 to handle the case where there is no valid subarray.\n\nIn the loop, we move the right pointer, adding the element at that position to the sum. We then check if the sum times the length of the current window (right - left + 1) is less than the threshold times the length of the current window. If it is, we move the left pointer and subtract that value from the sum to maintain the sum of elements in the window.\n\nAt each step, we update maxLength to the maximum of the current maxLength and the length of the current window (right - left + 1). This way, we store the maximum length we've found so far.\n\nAfter the loop, we return maxLength, which is the final answer.\n    ",
        "c++": "\n    ```cpp\nint findSubarrayLength(vector<int>& nums, int threshold) {\n    int n = nums.size();\n    int left = 0, right = 0, sum = 0;\n    int maxLength = -1;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) < threshold * (right - left + 1)) {\n            sum -= nums[left];\n            left++;\n        }\n        maxLength = max(maxLength, right - left + 1);\n        right++;\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm is a sliding window approach. We initialize left and right pointers at the beginning of the array, and a sum variable. We also initialize maxLength to -1 to handle the case where there is no valid subarray.\n\nIn the loop, we move the right pointer, adding the element at that position to the sum. We then check if the sum times the length of the current window (right - left + 1) is less than the threshold times the length of the current window. If it is, we move the left pointer and subtract that value from the sum to maintain the sum of elements in the window.\n\nAt each step, we update maxLength to the maximum of the current maxLength and the length of the current window (right - left + 1). This way, we store the maximum length we've found so far.\n\nAfter the loop, we return maxLength, which is the final answer.\n    ",
        "js": "\n    ```javascript\nfunction findSubarrayLength(nums, threshold) {\n    let n = nums.length, left = 0, right = 0, sum = 0, maxLength = -1;\n\n    while (right < n) {\n        sum += nums[right];\n        while (sum * (right - left + 1) < threshold * (right - left + 1)) {\n            sum -= nums[left];\n            left++;\n        }\n        maxLength = Math.max(maxLength, right - left + 1);\n        right++;\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm is a sliding window approach. We initialize left and right pointers at the beginning of the array, and a sum variable. We also initialize maxLength to -1 to handle the case where there is no valid subarray.\n\nIn the loop, we move the right pointer, adding the element at that position to the sum. We then check if the sum times the length of the current window (right - left + 1) is less than the threshold times the length of the current window. If it is, we move the left pointer and subtract that value from the sum to maintain the sum of elements in the window.\n\nAt each step, we update maxLength to the maximum of the current maxLength and the length of the current window (right - left + 1). This way, we store the maximum length we've found so far.\n\nAfter the loop, we return maxLength, which is the final answer.\n    "
    },
    {
        "id": 399,
        "title": "Count the Number of Ideal Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two integers `n` and `maxValue`, which are used to describe an **ideal** array.\n\nA **0-indexed** integer array `arr` of length `n` is considered **ideal** if the following conditions hold:\n\n*   Every `arr[i]` is a value from `1` to `maxValue`, for `0 <= i < n`.\n*   Every `arr[i]` is divisible by `arr[i - 1]`, for `0 < i < n`.\n\nReturn _the number of **distinct** ideal arrays of length_ `n`. Since the answer may be very large, return it modulo `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, maxValue = 5\n**Output:** 10\n**Explanation:** The following are the possible ideal arrays:\n- Arrays starting with the value 1 (5 arrays): \\[1,1\\], \\[1,2\\], \\[1,3\\], \\[1,4\\], \\[1,5\\]\n- Arrays starting with the value 2 (2 arrays): \\[2,2\\], \\[2,4\\]\n- Arrays starting with the value 3 (1 array): \\[3,3\\]\n- Arrays starting with the value 4 (1 array): \\[4,4\\]\n- Arrays starting with the value 5 (1 array): \\[5,5\\]\nThere are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.\n\n",
                "**Example 2:**\n\n**Input:** n = 5, maxValue = 3\n**Output:** 11\n**Explanation:** The following are the possible ideal arrays:\n- Arrays starting with the value 1 (9 arrays): \n   - With no other distinct values (1 array): \\[1,1,1,1,1\\] \n   - With 2nd distinct value 2 (4 arrays): \\[1,1,1,1,2\\], \\[1,1,1,2,2\\], \\[1,1,2,2,2\\], \\[1,2,2,2,2\\]\n   - With 2nd distinct value 3 (4 arrays): \\[1,1,1,1,3\\], \\[1,1,1,3,3\\], \\[1,1,3,3,3\\], \\[1,3,3,3,3\\]\n- Arrays starting with the value 2 (1 array): \\[2,2,2,2,2\\]\n- Arrays starting with the value 3 (1 array): \\[3,3,3,3,3\\]\nThere are a total of 9 + 1 + 1 = 11 distinct ideal arrays."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 104`\n*   `1 <= maxValue <= 104`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming",
            "Combinatorics",
            "Number Theory"
        ],
        "example": [
            {
                "input": "2,5",
                "output": "10"
            },
            {
                "input": "5,3",
                "output": "11"
            }
        ],
        "java": "\n    ```java\npublic int numOfArrays(int n, int maxValue) {\n    final int mod = 1_000_000_007;\n    int[] dp = new int[maxValue + 1];\n    \n    for (int i = 1; i <= maxValue; i++) {\n        dp[i] = i;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = maxValue; j > 0; j--) {\n            dp[j] = (dp[j] + dp[j - 1]) % mod;\n        }\n    }\n    \n    return dp[maxValue];\n}\n```\n\n    \n    The problem can be solved using dynamic programming, where we maintain an array `dp` of length `maxValue + 1`.\n\n1. Initialize the `dp` array by assigning `i` to `dp[i]` for `i` in the range `[1, maxValue]`.\n2. We need to find the number of ideal arrays of length `n`. So, we iterate from `1` to `n - 1`. In each iteration, we update the `dp` array.\n3. For updating the `dp` array, we iterate from `maxValue` to `1`, and we update `dp[j]` as `(dp[j] + dp[j - 1]) % mod`, where `mod` is `10^9 + 7`.\n4. The result of the function is the value at `dp[maxValue]`.\n\nThe time complexity of this algorithm is O(n * maxValue) and the space complexity is O(maxValue).\n    ",
        "python": "\n    ```python\ndef numOfArrays(n: int, maxValue: int) -> int:\n    mod = 10**9 + 7\n    dp = [0] * (maxValue + 1)\n    \n    for i in range(1, maxValue + 1):\n        dp[i] = i\n        \n    for i in range(1, n):\n        for j in range(maxValue, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1]) % mod\n            \n    return dp[maxValue]\n```\n\n    \n    The problem can be solved using dynamic programming, where we maintain an array `dp` of length `maxValue + 1`.\n\n1. Initialize the `dp` array by assigning `i` to `dp[i]` for `i` in the range `[1, maxValue]`.\n2. We need to find the number of ideal arrays of length `n`. So, we iterate from `1` to `n - 1`. In each iteration, we update the `dp` array.\n3. For updating the `dp` array, we iterate from `maxValue` to `1`, and we update `dp[j]` as `(dp[j] + dp[j - 1]) % mod`, where `mod` is `10^9 + 7`.\n4. The result of the function is the value at `dp[maxValue]`.\n\nThe time complexity of this algorithm is O(n * maxValue) and the space complexity is O(maxValue).\n    ",
        "c++": "\n    ```cpp\nint numOfArrays(int n, int maxValue) {\n    const int mod = 1e9 + 7;\n    vector<int> dp(maxValue + 1, 0);\n    \n    for (int i = 1; i <= maxValue; i++) {\n        dp[i] = i;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = maxValue; j > 0; j--) {\n            dp[j] = (dp[j] + dp[j - 1]) % mod;\n        }\n    }\n    \n    return dp[maxValue];\n}\n```\n\n    \n    The problem can be solved using dynamic programming, where we maintain an array `dp` of length `maxValue + 1`.\n\n1. Initialize the `dp` array by assigning `i` to `dp[i]` for `i` in the range `[1, maxValue]`.\n2. We need to find the number of ideal arrays of length `n`. So, we iterate from `1` to `n - 1`. In each iteration, we update the `dp` array.\n3. For updating the `dp` array, we iterate from `maxValue` to `1`, and we update `dp[j]` as `(dp[j] + dp[j - 1]) % mod`, where `mod` is `10^9 + 7`.\n4. The result of the function is the value at `dp[maxValue]`.\n\nThe time complexity of this algorithm is O(n * maxValue) and the space complexity is O(maxValue).\n    ",
        "js": "\n    ```javascript\nfunction numOfArrays(n, maxValue) {\n    const mod = 1e9 + 7;\n    const dp = Array(maxValue + 1).fill(0);\n    \n    for (let i = 1; i <= maxValue; i++) {\n        dp[i] = i;\n    }\n    \n    for (let i = 1; i < n; i++) {\n        for (let j = maxValue; j > 0; j--) {\n            dp[j] = (dp[j] + dp[j - 1]) % mod;\n        }\n    }\n    \n    return dp[maxValue];\n}\n```\n\n    \n    The problem can be solved using dynamic programming, where we maintain an array `dp` of length `maxValue + 1`.\n\n1. Initialize the `dp` array by assigning `i` to `dp[i]` for `i` in the range `[1, maxValue]`.\n2. We need to find the number of ideal arrays of length `n`. So, we iterate from `1` to `n - 1`. In each iteration, we update the `dp` array.\n3. For updating the `dp` array, we iterate from `maxValue` to `1`, and we update `dp[j]` as `(dp[j] + dp[j - 1]) % mod`, where `mod` is `10^9 + 7`.\n4. The result of the function is the value at `dp[maxValue]`.\n\nThe time complexity of this algorithm is O(n * maxValue) and the space complexity is O(maxValue).\n    "
    },
    {
        "id": 400,
        "title": "Minimum Deletions to Make Array Divisible",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two positive integer arrays `nums` and `numsDivide`. You can delete any number of elements from `nums`.\n\nReturn _the **minimum** number of deletions such that the **smallest** element in_ `nums` _**divides** all the elements of_ `numsDivide`. If this is not possible, return `-1`.\n\nNote that an integer `x` divides `y` if `y % x == 0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,2,4,3\\], numsDivide = \\[9,6,9,3,15\\]\n**Output:** 2\n**Explanation:** \nThe smallest element in \\[2,3,2,4,3\\] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = \\[3,4,3\\].\nThe smallest element in \\[3,4,3\\] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,3,6\\], numsDivide = \\[8,2,6,10\\]\n**Output:** -1\n**Explanation:** \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length, numsDivide.length <= 105`\n*   `1 <= nums[i], numsDivide[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Sorting",
            "Heap (Priority Queue)",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[2,3,2,4,3],[9,6,9,3,15]",
                "output": "2"
            },
            {
                "input": "[4,3,6],[8,2,6,10]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minDeletions(int[] nums, int[] numsDivide) {\n    int res = Integer.MAX_VALUE;\n    for (int num : nums) {\n        int cnt = 0;\n        boolean found = true;\n        for (int d : numsDivide) {\n            if (d % num != 0) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            for (int n : nums) {\n                if (n == num) {\n                    cnt++;\n                }\n            }\n            res = Math.min(res, nums.length - cnt);\n        }\n    }\n    return res == Integer.MAX_VALUE ? -1 : res;\n}\n```\n    \n    For each number in `nums`, check if it divides all elements in `numsDivide`. If it does, count how many times it appears in `nums` and calculate the minimum number of deletions required to make it the smallest element in `nums` by subtracting the count (cnt) from the size (length) of the nums array (need to delete all other elements). Keep track of the minimum result for all numbers. If the minimum result is still Infinity (initial value) after looping through all numbers, it means there is no solution, and we return -1. Otherwise, return the minimum result.\n    ",
        "python": "\n    ```python\ndef min_deletions(nums, nums_divide):\n    res = float('inf')\n    for num in nums:\n        cnt = 0\n        found = True\n        for d in nums_divide:\n            if d % num != 0:\n                found = False\n                break\n        if found:\n            for n in nums:\n                if n == num:\n                    cnt += 1\n            res = min(res, len(nums) - cnt)\n    return -1 if res == float('inf') else res\n```\n    \n    For each number in `nums`, check if it divides all elements in `numsDivide`. If it does, count how many times it appears in `nums` and calculate the minimum number of deletions required to make it the smallest element in `nums` by subtracting the count (cnt) from the size (length) of the nums array (need to delete all other elements). Keep track of the minimum result for all numbers. If the minimum result is still Infinity (initial value) after looping through all numbers, it means there is no solution, and we return -1. Otherwise, return the minimum result.\n    ",
        "c++": "\n    ```cpp\nint minDeletions(vector<int>& nums, vector<int>& numsDivide) {\n    int res = INT_MAX;\n    for (int num : nums) {\n        int cnt = 0;\n        bool found = true;\n        for (int d : numsDivide) {\n            if (d % num != 0) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            for (int n : nums) {\n                if (n == num) {\n                    cnt++;\n                }\n            }\n            res = min(res, (int)nums.size() - cnt);\n        }\n    }\n    return res == INT_MAX ? -1 : res;\n}\n```\n    \n    For each number in `nums`, check if it divides all elements in `numsDivide`. If it does, count how many times it appears in `nums` and calculate the minimum number of deletions required to make it the smallest element in `nums` by subtracting the count (cnt) from the size (length) of the nums array (need to delete all other elements). Keep track of the minimum result for all numbers. If the minimum result is still Infinity (initial value) after looping through all numbers, it means there is no solution, and we return -1. Otherwise, return the minimum result.\n    ",
        "js": "\n    ```javascript\nfunction minDeletions(nums, numsDivide) {\n    let res = Infinity;\n    for (let num of nums) {\n        let cnt = 0;\n        let found = true;\n        for (let d of numsDivide) {\n            if (d % num !== 0) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            for (let n of nums) {\n                if (n === num) {\n                    cnt++;\n                }\n            }\n            res = Math.min(res, nums.length - cnt);\n        }\n    }\n    return res === Infinity ? -1 : res;\n}\n```\n    \n    For each number in `nums`, check if it divides all elements in `numsDivide`. If it does, count how many times it appears in `nums` and calculate the minimum number of deletions required to make it the smallest element in `nums` by subtracting the count (cnt) from the size (length) of the nums array (need to delete all other elements). Keep track of the minimum result for all numbers. If the minimum result is still Infinity (initial value) after looping through all numbers, it means there is no solution, and we return -1. Otherwise, return the minimum result.\n    "
    },
    {
        "id": 401,
        "title": "Shortest Impossible Sequence of Rolls",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `rolls` of length `n` and an integer `k`. You roll a `k` sided dice numbered from `1` to `k`, `n` times, where the result of the `ith` roll is `rolls[i]`.\n\nReturn _the length of the **shortest** sequence of rolls that **cannot** be taken from_ `rolls`.\n\nA **sequence of rolls** of length `len` is the result of rolling a `k` sided dice `len` times.\n\n**Note** that the sequence taken does not have to be consecutive as long as it is in order.",
            "examples": [
                "**Example 1:**\n\n**Input:** rolls = \\[4,2,1,2,3,3,2,4,1\\], k = 4\n**Output:** 3\n**Explanation:** Every sequence of rolls of length 1, \\[1\\], \\[2\\], \\[3\\], \\[4\\], can be taken from rolls.\nEvery sequence of rolls of length 2, \\[1, 1\\], \\[1, 2\\], ..., \\[4, 4\\], can be taken from rolls.\nThe sequence \\[1, 4, 2\\] cannot be taken from rolls, so we return 3.\nNote that there are other sequences that cannot be taken from rolls.\n\n",
                "**Example 2:**\n\n**Input:** rolls = \\[1,1,2,2\\], k = 2\n**Output:** 2\n**Explanation:** Every sequence of rolls of length 1, \\[1\\], \\[2\\], can be taken from rolls.\nThe sequence \\[2, 1\\] cannot be taken from rolls, so we return 2.\nNote that there are other sequences that cannot be taken from rolls but \\[2, 1\\] is the shortest.\n\n",
                "**Example 3:**\n\n**Input:** rolls = \\[1,1,3,2,2,2,3,3\\], k = 4\n**Output:** 1\n**Explanation:** The sequence \\[4\\] cannot be taken from rolls, so we return 1.\nNote that there are other sequences that cannot be taken from rolls but \\[4\\] is the shortest."
            ],
            "constraints": "**Constraints:**\n\n*   `n == rolls.length`\n*   `1 <= n <= 105`\n*   `1 <= rolls[i] <= k <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Greedy"
        ],
        "example": [
            {
                "input": "[4,2,1,2,3,3,2,4,1],4",
                "output": "3"
            },
            {
                "input": "[1,1,2,2],2",
                "output": "2"
            },
            {
                "input": "[1,1,3,2,2,2,3,3],4",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int shortestUnrollableSequence(int[] rolls, int k) {\n    int[] count = new int[k + 1];\n    for (int roll : rolls) {\n        count[roll]++;\n    }\n    \n    int len = 1;\n    while (true) {\n        int max_subsequences = 1;\n        for (int i = 1; i <= k; i++) {\n            max_subsequences *= count[i] + (len == 1 ? 1 : 0);\n        }\n        \n        if (max_subsequences < len * rolls.length) {\n            return len;\n        }\n        \n        len++;\n    }\n}\n```\n    \n    The algorithm first counts the occurrences of each roll in the `rolls` array. Then, it iterates through the possible lengths of the unrollable sequence, starting at 1. For each length, the algorithm calculates the maximum number of unique sub-sequences of that length that can potentially be created by combining the existing rolls in the `rolls` array. \n\nIf the maximum number of unique sub-sequences that can be created is less than the expected number of sub-sequences (length * number of rolls), then it means there must exist a sequence of that length which cannot be formed from the given `rolls`. Therefore, the algorithm returns that length.\n    ",
        "python": "\n    ```python\ndef shortest_unrollable_sequence(rolls, k):\n    count = [0] * (k + 1)\n    for roll in rolls:\n        count[roll] += 1\n    \n    len_ = 1\n    while True:\n        max_subsequences = 1\n        for i in range(1, k + 1):\n            max_subsequences *= count[i] + (1 if len_ == 1 else 0)\n        \n        if max_subsequences < len_ * len(rolls):\n            return len_\n        \n        len_ += 1\n```\n    \n    The algorithm first counts the occurrences of each roll in the `rolls` array. Then, it iterates through the possible lengths of the unrollable sequence, starting at 1. For each length, the algorithm calculates the maximum number of unique sub-sequences of that length that can potentially be created by combining the existing rolls in the `rolls` array. \n\nIf the maximum number of unique sub-sequences that can be created is less than the expected number of sub-sequences (length * number of rolls), then it means there must exist a sequence of that length which cannot be formed from the given `rolls`. Therefore, the algorithm returns that length.\n    ",
        "c++": "\n    ```cpp\nint shortestUnrollableSequence(vector<int>& rolls, int k) {\n    vector<int> count(k + 1);\n    for (int roll : rolls) {\n        count[roll]++;\n    }\n    \n    int len = 1;\n    while (true) {\n        int max_subsequences = 1;\n        for (int i = 1; i <= k; i++) {\n            max_subsequences *= count[i] + (len == 1);\n        }\n        \n        if (max_subsequences < len * rolls.size()) {\n            return len;\n        }\n        \n        len++;\n    }\n}\n```\n    \n    The algorithm first counts the occurrences of each roll in the `rolls` array. Then, it iterates through the possible lengths of the unrollable sequence, starting at 1. For each length, the algorithm calculates the maximum number of unique sub-sequences of that length that can potentially be created by combining the existing rolls in the `rolls` array. \n\nIf the maximum number of unique sub-sequences that can be created is less than the expected number of sub-sequences (length * number of rolls), then it means there must exist a sequence of that length which cannot be formed from the given `rolls`. Therefore, the algorithm returns that length.\n    ",
        "js": "\n    ```javascript\nfunction shortestUnrollableSequence(rolls, k) {\n    const count = new Array(k + 1).fill(0);\n    for (const roll of rolls) {\n        count[roll]++;\n    }\n    \n    let len = 1;\n    while (true) {\n        let max_subsequences = 1;\n        for (let i = 1; i <= k; i++) {\n            max_subsequences *= count[i] + (len === 1 ? 1 : 0);\n        }\n        \n        if (max_subsequences < len * rolls.length) {\n            return len;\n        }\n        \n        len++;\n    }\n}\n```\n    \n    The algorithm first counts the occurrences of each roll in the `rolls` array. Then, it iterates through the possible lengths of the unrollable sequence, starting at 1. For each length, the algorithm calculates the maximum number of unique sub-sequences of that length that can potentially be created by combining the existing rolls in the `rolls` array. \n\nIf the maximum number of unique sub-sequences that can be created is less than the expected number of sub-sequences (length * number of rolls), then it means there must exist a sequence of that length which cannot be formed from the given `rolls`. Therefore, the algorithm returns that length.\n    "
    },
    {
        "id": 402,
        "title": "Number of Excellent Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** positive integer array `nums` and a positive integer `k`.\n\nA pair of numbers `(num1, num2)` is called **excellent** if the following conditions are satisfied:\n\n*   **Both** the numbers `num1` and `num2` exist in the array `nums`.\n*   The sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is greater than or equal to `k`, where `OR` is the bitwise **OR** operation and `AND` is the bitwise **AND** operation.\n\nReturn _the number of **distinct** excellent pairs_.\n\nTwo pairs `(a, b)` and `(c, d)` are considered distinct if either `a != c` or `b != d`. For example, `(1, 2)` and `(2, 1)` are distinct.\n\n**Note** that a pair `(num1, num2)` such that `num1 == num2` can also be excellent if you have at least **one** occurrence of `num1` in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], k = 3\n**Output:** 5\n**Explanation:** The excellent pairs are the following:\n- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.\n- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\nSo the number of excellent pairs is 5.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,1,1\\], k = 10\n**Output:** 0\n**Explanation:** There are no excellent pairs for this array."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= 60`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Binary Search",
            "Bit Manipulation"
        ],
        "example": [
            {
                "input": "[1,2,3,1],3",
                "output": "5"
            },
            {
                "input": "[5,1,1],10",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int countExcellentPairs(int[] nums, int k) {\n    HashMap<Integer, Integer> frequency = new HashMap<>();\n    for (int num : nums) {\n        frequency.put(num, frequency.getOrDefault(num, 0) + 1);\n    }\n    \n    int count = 0;\n    for (Map.Entry<Integer, Integer> entry1 : frequency.entrySet()) {\n        for (Map.Entry<Integer, Integer> entry2 : frequency.entrySet()) {\n            int num1 = entry1.getKey();\n            int num2 = entry2.getKey();\n            int setBits = Integer.bitCount(num1 | num2) + Integer.bitCount(num1 & num2);\n            if (setBits >= k) {\n                count += (num1 == num2) ? entry1.getValue() * (entry1.getValue() - 1) / 2 : entry1.getValue() * entry2.getValue();\n            }\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm first counts the frequency of each number in the input array using a hash map. Next, it iterates over all pairs of distinct numbers in the map (including pairs of identical numbers). For each pair, it calculates the number of set bits in both the bitwise OR and bitwise AND of the two numbers. If the sum of set bits is greater than or equal to the target value k, the algorithm increments the count of excellent pairs accordingly. If the pair consists of identical numbers, the count is incremented by the triangular number of the count of that number in the input array, otherwise the count is incremented by the product of the counts of the two numbers.\n\nThe time complexity of this algorithm is O(n^2), where n is the number of distinct numbers in the input array. The space complexity is also O(n), as a hash map is used to store the frequency of each number.\n    ",
        "python": "\n    ```python\nfrom collections import Counter\n\ndef countExcellentPairs(nums, k):\n    frequency = Counter(nums)\n    count = 0\n    for num1, freq1 in frequency.items():\n        for num2, freq2 in frequency.items():\n            setBits = bin(num1 | num2).count('1') + bin(num1 & num2).count('1')\n            if setBits >= k:\n                count += freq1 * freq2 if num1 != num2 else freq1 * (freq1 - 1) // 2\n    return count\n```\n    \n    The algorithm first counts the frequency of each number in the input array using a hash map. Next, it iterates over all pairs of distinct numbers in the map (including pairs of identical numbers). For each pair, it calculates the number of set bits in both the bitwise OR and bitwise AND of the two numbers. If the sum of set bits is greater than or equal to the target value k, the algorithm increments the count of excellent pairs accordingly. If the pair consists of identical numbers, the count is incremented by the triangular number of the count of that number in the input array, otherwise the count is incremented by the product of the counts of the two numbers.\n\nThe time complexity of this algorithm is O(n^2), where n is the number of distinct numbers in the input array. The space complexity is also O(n), as a hash map is used to store the frequency of each number.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint countExcellentPairs(std::vector<int>& nums, int k) {\n    std::unordered_map<int, int> frequency;\n    for (int num : nums) {\n        frequency[num]++;\n    }\n    \n    int count = 0;\n    for (auto it1 = frequency.begin(); it1 != frequency.end(); it1++) {\n        for (auto it2 = frequency.begin(); it2 != frequency.end(); it2++) {\n            if ((__builtin_popcount(it1->first | it2->first) + __builtin_popcount(it1->first & it2->first)) >= k) {\n                count += (it1->first == it2->first) ? it1->second * (it1->second - 1) / 2 : it1->second * it2->second;\n            }\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm first counts the frequency of each number in the input array using a hash map. Next, it iterates over all pairs of distinct numbers in the map (including pairs of identical numbers). For each pair, it calculates the number of set bits in both the bitwise OR and bitwise AND of the two numbers. If the sum of set bits is greater than or equal to the target value k, the algorithm increments the count of excellent pairs accordingly. If the pair consists of identical numbers, the count is incremented by the triangular number of the count of that number in the input array, otherwise the count is incremented by the product of the counts of the two numbers.\n\nThe time complexity of this algorithm is O(n^2), where n is the number of distinct numbers in the input array. The space complexity is also O(n), as a hash map is used to store the frequency of each number.\n    ",
        "js": "\n    ```javascript\nfunction countExcellentPairs(nums, k) {\n    let frequency = new Map();\n    for (let num of nums) {\n        frequency.set(num, (frequency.get(num) || 0) + 1);\n    }\n    \n    let count = 0;\n    for (let [num1, freq1] of frequency.entries()) {\n        for (let [num2, freq2] of frequency.entries()) {\n            let setBits = (num1 | num2).toString(2).replace(/0/g, '').length + (num1 & num2).toString(2).replace(/0/g, '').length;\n            if (setBits >= k) {\n                count += (num1 === num2) ? freq1 * (freq1 - 1) / 2 : freq1 * freq2;\n            }\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm first counts the frequency of each number in the input array using a hash map. Next, it iterates over all pairs of distinct numbers in the map (including pairs of identical numbers). For each pair, it calculates the number of set bits in both the bitwise OR and bitwise AND of the two numbers. If the sum of set bits is greater than or equal to the target value k, the algorithm increments the count of excellent pairs accordingly. If the pair consists of identical numbers, the count is incremented by the triangular number of the count of that number in the input array, otherwise the count is incremented by the product of the counts of the two numbers.\n\nThe time complexity of this algorithm is O(n^2), where n is the number of distinct numbers in the input array. The space complexity is also O(n), as a hash map is used to store the frequency of each number.\n    "
    },
    {
        "id": 403,
        "title": "Longest Cycle in a Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.\n\nReturn _the length of the **longest** cycle in the graph_. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the **same** node.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[3,3,4,2,3\\]\n**Output:** 3\n**Explanation:** The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[2,-1,3,1\\]\n**Output:** -1\n**Explanation:** There are no cycles in this graph."
            ],
            "constraints": "**Constraints:**\n\n*   `n == edges.length`\n*   `2 <= n <= 105`\n*   `-1 <= edges[i] < n`\n*   `edges[i] != i`",
            "follow_up": null
        },
        "tag": [
            "Depth-First Search",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "[3,3,4,2,3]",
                "output": "3"
            },
            {
                "input": "[2,-1,3,1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findLongestCycle(int[] edges) {\n    int n = edges.length;\n    boolean[] visited = new boolean[n];\n    int longest_cycle = -1;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int length = 0;\n            int node = i;\n\n            while (!visited[node] && edges[node] != -1) {\n                visited[node] = true;\n                length++;\n                node = edges[node];\n            }\n\n            if (edges[node] == i) {\n                longest_cycle = Math.max(longest_cycle, length);\n            }\n        }\n    }\n\n    return longest_cycle;\n}\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    ",
        "python": "\n    ```python\ndef findLongestCycle(edges):\n    n = len(edges)\n    visited = [False] * n\n    longest_cycle = -1\n\n    for i in range(n):\n        if not visited[i]:\n            length = 0\n            node = i\n\n            while not visited[node] and edges[node] != -1:\n                visited[node] = True\n                length += 1\n                node = edges[node]\n\n            if edges[node] == i:\n                longest_cycle = max(longest_cycle, length)\n\n    return longest_cycle\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    ",
        "c++": "\n    ```cpp\nint findLongestCycle(vector<int>& edges) {\n    int n = edges.size();\n    vector<bool> visited(n, false);\n    int longest_cycle = -1;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int length = 0;\n            int node = i;\n\n            while (!visited[node] && edges[node] != -1) {\n                visited[node] = true;\n                length++;\n                node = edges[node];\n            }\n\n            if (edges[node] == i) {\n                longest_cycle = max(longest_cycle, length);\n            }\n        }\n    }\n\n    return longest_cycle;\n}\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    ",
        "js": "\n    ```javascript\nfunction findLongestCycle(edges) {\n    const n = edges.length;\n    const visited = new Array(n).fill(false);\n    let longest_cycle = -1;\n\n    for (let i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            let length = 0;\n            let node = i;\n\n            while (!visited[node] && edges[node] !== -1) {\n                visited[node] = true;\n                length++;\n                node = edges[node];\n            }\n\n            if (edges[node] === i) {\n                longest_cycle = Math.max(longest_cycle, length);\n            }\n        }\n    }\n\n    return longest_cycle;\n}\n```\n    \n    The algorithm iterates through each node in the graph. For each unvisited node, we start a loop that increases the path length on every iteration until the current node is visited or there is no outgoing edge from the current node. If the next node is equal to the starting node, we found a cycle, which update the longest cycle if it is greater than the current longest cycle.\n    "
    },
    {
        "id": 404,
        "title": "Minimum Replacements to Sort the Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums`. In one operation you can replace any element of the array with **any two** elements that **sum** to it.\n\n*   For example, consider `nums = [5,6,7]`. In one operation, we can replace `nums[1]` with `2` and `4` and convert `nums` to `[5,2,4,7]`.\n\nReturn _the minimum number of operations to make an array that is sorted in **non-decreasing** order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,9,3\\]\n**Output:** 2\n**Explanation:** Here are the steps to sort the array in non-decreasing order:\n- From \\[3,9,3\\], replace the 9 with 3 and 6 so the array becomes \\[3,3,6,3\\]\n- From \\[3,3,6,3\\], replace the 6 with 3 and 3 so the array becomes \\[3,3,3,3,3\\]\nThere are 2 steps to sort the array in non-decreasing order. Therefore, we return 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** 0\n**Explanation:** The array is already in non-decreasing order. Therefore, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Greedy"
        ],
        "example": [
            {
                "input": "[3,9,3]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4,5]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            int diff = nums[i - 1] - nums[i] + 1;\n            operations += Math.ceil(Math.log(diff) / Math.log(2));\n            nums[i] += diff;\n        }\n    }\n    return operations;\n}\n```\n    \n    We iterate through the array, starting from the second element. If the current element is smaller than or equal to the previous element, we calculate the difference between them and add 1. We then calculate the number of division by 2 operations needed to reach that difference using a logarithm with base 2, and round that number up to the nearest integer (as we're only interested in whole operations). We add the difference to the current element to make sure it's greater than the previous element, and increment the number of operations. We continue this process for the rest of the array, and finally return the total number of operations needed to sort the array in non-decreasing order.\n    ",
        "python": "\n    ```python\ndef min_operations(nums):\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            diff = nums[i - 1] - nums[i] + 1\n            operations += math.ceil(math.log2(diff))\n            nums[i] += diff\n    return operations\n```\n    \n    We iterate through the array, starting from the second element. If the current element is smaller than or equal to the previous element, we calculate the difference between them and add 1. We then calculate the number of division by 2 operations needed to reach that difference using a logarithm with base 2, and round that number up to the nearest integer (as we're only interested in whole operations). We add the difference to the current element to make sure it's greater than the previous element, and increment the number of operations. We continue this process for the rest of the array, and finally return the total number of operations needed to sort the array in non-decreasing order.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums) {\n    int operations = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] <= nums[i - 1]) {\n            int diff = nums[i - 1] - nums[i] + 1;\n            operations += ceil(log2(diff));\n            nums[i] += diff;\n        }\n    }\n    return operations;\n}\n```\n    \n    We iterate through the array, starting from the second element. If the current element is smaller than or equal to the previous element, we calculate the difference between them and add 1. We then calculate the number of division by 2 operations needed to reach that difference using a logarithm with base 2, and round that number up to the nearest integer (as we're only interested in whole operations). We add the difference to the current element to make sure it's greater than the previous element, and increment the number of operations. We continue this process for the rest of the array, and finally return the total number of operations needed to sort the array in non-decreasing order.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums) {\n    let operations = 0;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] <= nums[i - 1]) {\n            let diff = nums[i - 1] - nums[i] + 1;\n            operations += Math.ceil(Math.log2(diff));\n            nums[i] += diff;\n        }\n    }\n    return operations;\n}\n```\n    \n    We iterate through the array, starting from the second element. If the current element is smaller than or equal to the previous element, we calculate the difference between them and add 1. We then calculate the number of division by 2 operations needed to reach that difference using a logarithm with base 2, and round that number up to the nearest integer (as we're only interested in whole operations). We add the difference to the current element to make sure it's greater than the previous element, and increment the number of operations. We continue this process for the rest of the array, and finally return the total number of operations needed to sort the array in non-decreasing order.\n    "
    },
    {
        "id": 405,
        "title": "Count Special Integers",
        "difficulty": "Hard",
        "content": {
            "problem": "We call a positive integer **special** if all of its digits are **distinct**.\n\nGiven a **positive** integer `n`, return _the number of special integers that belong to the interval_ `[1, n]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 20\n**Output:** 19\n**Explanation:** All the integers from 1 to 20, except 11, are special. Thus, there are 19 special integers.\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** 5\n**Explanation:** All the integers from 1 to 5 are special.\n\n",
                "**Example 3:**\n\n**Input:** n = 135\n**Output:** 110\n**Explanation:** There are 110 integers from 1 to 135 that are special.\nSome of the integers that are not special are: 22, 114, and 131."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2 * 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "20",
                "output": "19"
            },
            {
                "input": "5",
                "output": "5"
            },
            {
                "input": "135",
                "output": "110"
            }
        ],
        "java": "\n    ```java\nboolean isDistinct(int n) {\n    Set<Integer> uniqueDigits = new HashSet<>();\n    while (n > 0) {\n        int digit = n % 10;\n        if (uniqueDigits.contains(digit)) {\n            return false;\n        }\n        uniqueDigits.add(digit);\n        n /= 10;\n    }\n    return true;\n}\n\nint countSpecial(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (isDistinct(i)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm checks all integers from 1 to n if they are special by using an auxiliary function called `isDistinct`. The `isDistinct` function checks if all digits of a given integer are distinct by using a set data structure to store the unique digits of the integer. For each digit of the given integer, if the digit is not already in the set, it's added to the set. If the digit is in the set, the function returns `false` as it is not a special integer. The main function increments the count for each integer from 1 to n that is a special integer and returns the count.\n    ",
        "python": "\n    ```python\ndef is_distinct(n):\n    unique_digits = set()\n    while n > 0:\n        digit = n % 10\n        if digit in unique_digits:\n            return False\n        unique_digits.add(digit)\n        n //= 10\n    return True\n\ndef count_special(n):\n    count = 0\n    for i in range(1, n + 1):\n        if is_distinct(i):\n            count += 1\n    return count\n```\n    \n    The algorithm checks all integers from 1 to n if they are special by using an auxiliary function called `isDistinct`. The `isDistinct` function checks if all digits of a given integer are distinct by using a set data structure to store the unique digits of the integer. For each digit of the given integer, if the digit is not already in the set, it's added to the set. If the digit is in the set, the function returns `false` as it is not a special integer. The main function increments the count for each integer from 1 to n that is a special integer and returns the count.\n    ",
        "c++": "\n    ```cpp\nbool isDistinct(int n) {\n    std::set<int> uniqueDigits;\n    while (n > 0) {\n        int digit = n % 10;\n        if (uniqueDigits.count(digit)) {\n            return false;\n        }\n        uniqueDigits.insert(digit);\n        n /= 10;\n    }\n    return true;\n}\n\nint countSpecial(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (isDistinct(i)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm checks all integers from 1 to n if they are special by using an auxiliary function called `isDistinct`. The `isDistinct` function checks if all digits of a given integer are distinct by using a set data structure to store the unique digits of the integer. For each digit of the given integer, if the digit is not already in the set, it's added to the set. If the digit is in the set, the function returns `false` as it is not a special integer. The main function increments the count for each integer from 1 to n that is a special integer and returns the count.\n    ",
        "js": "\n    ```javascript\nfunction isDistinct(n) {\n    const uniqueDigits = new Set();\n    while (n > 0) {\n        const digit = n % 10;\n        if (uniqueDigits.has(digit)) {\n            return false;\n        }\n        uniqueDigits.add(digit);\n        n = Math.floor(n / 10);\n    }\n    return true;\n}\n\nfunction countSpecial(n) {\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        if (isDistinct(i)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm checks all integers from 1 to n if they are special by using an auxiliary function called `isDistinct`. The `isDistinct` function checks if all digits of a given integer are distinct by using a set data structure to store the unique digits of the integer. For each digit of the given integer, if the digit is not already in the set, it's added to the set. If the digit is in the set, the function returns `false` as it is not a special integer. The main function increments the count for each integer from 1 to n that is a special integer and returns the count.\n    "
    },
    {
        "id": 406,
        "title": "Maximum Segment Sum After Removals",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `nums` and `removeQueries`, both of length `n`. For the `ith` query, the element in `nums` at the index `removeQueries[i]` is removed, splitting `nums` into different segments.\n\nA **segment** is a contiguous sequence of **positive** integers in `nums`. A **segment sum** is the sum of every element in a segment.\n\nReturn _an integer array_ `answer`_, of length_ `n`_, where_ `answer[i]` _is the **maximum** segment sum after applying the_ `ith` _removal._\n\n**Note:** The same index will **not** be removed more than once.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,5,6,1\\], removeQueries = \\[0,3,2,4,1\\]\n**Output:** \\[14,7,2,2,0\\]\n**Explanation:** Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 0th element, nums becomes \\[0,2,5,6,1\\] and the maximum segment sum is 14 for segment \\[2,5,6,1\\].\nQuery 2: Remove the 3rd element, nums becomes \\[0,2,5,0,1\\] and the maximum segment sum is 7 for segment \\[2,5\\].\nQuery 3: Remove the 2nd element, nums becomes \\[0,2,0,0,1\\] and the maximum segment sum is 2 for segment \\[2\\]. \nQuery 4: Remove the 4th element, nums becomes \\[0,2,0,0,0\\] and the maximum segment sum is 2 for segment \\[2\\]. \nQuery 5: Remove the 1st element, nums becomes \\[0,0,0,0,0\\] and the maximum segment sum is 0, since there are no segments.\nFinally, we return \\[14,7,2,2,0\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,11,1\\], removeQueries = \\[3,2,1,0\\]\n**Output:** \\[16,5,3,0\\]\n**Explanation:** Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 3rd element, nums becomes \\[3,2,11,0\\] and the maximum segment sum is 16 for segment \\[3,2,11\\].\nQuery 2: Remove the 2nd element, nums becomes \\[3,2,0,0\\] and the maximum segment sum is 5 for segment \\[3,2\\].\nQuery 3: Remove the 1st element, nums becomes \\[3,0,0,0\\] and the maximum segment sum is 3 for segment \\[3\\].\nQuery 4: Remove the 0th element, nums becomes \\[0,0,0,0\\] and the maximum segment sum is 0, since there are no segments.\nFinally, we return \\[16,5,3,0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length == removeQueries.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 109`\n*   `0 <= removeQueries[i] < n`\n*   All the values of `removeQueries` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Union Find",
            "Prefix Sum",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[1,2,5,6,1],[0,3,2,4,1]",
                "output": "[14,7,2,2,0]"
            },
            {
                "input": "[3,2,11,1],[3,2,1,0]",
                "output": "[16,5,3,0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public int[] maxSegSumAfterQueries(int[] nums, int[] removeQueries) {\n        int n = nums.length;\n        int[] answer = new int[n];\n        TreeSet<Integer> removed = new TreeSet<>();\n        removed.add(-1);\n        removed.add(n);\n        \n        int currentSum = 0, maxSum = 0;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] > 0) currentSum += nums[i];\n            else {\n                maxSum = Math.max(maxSum, currentSum);\n                currentSum = 0;\n            }\n        }\n        maxSum = Math.max(maxSum, currentSum);\n        \n        for (int i = 0; i < n; ++i) {\n            int removeIdx = removeQueries[i];\n            answer[i] = maxSum;\n            nums[removeIdx] = -nums[removeIdx];\n            \n            int leftIdx = removed.higher(removeIdx);\n            int rightIdx = removed.lower(removeIdx);\n            \n            int leftSum = 0, rightSum = 0;\n            for (int j = leftIdx - 1; j >= 0; --j) {\n                if (nums[j] < 0) leftSum -= nums[j];\n                else break;\n            }\n            for (int j = rightIdx + 1; j < n; ++j) {\n                if (nums[j] < 0) rightSum -= nums[j];\n                else break;\n            }\n            \n            maxSum -= Math.max(0, leftSum - (-nums[removeIdx]));\n            maxSum -= Math.max(0, rightSum - (-nums[removeIdx]));\n            maxSum += Math.max(0, leftSum + rightSum - (-nums[removeIdx]));\n            \n            removed.add(removeIdx);\n        }\n        \n        return answer;\n    }\n}\n```    \n    1. Create an auxiliary set `removed` to store the indices of removed elements, and initialize it with indices `-1` and `n`. These indices will be used to indicate the left and right boundaries of segments.\n\n2. Calculate the initial maximum segment sum `maxSum` by iterating through the given `nums`.\n\n3. Iterate through the `removeQueries` array. For each removal query:\n\n   a. Store the current `maxSum` value in the answer array.\n   \n   b. Update the value of `nums[removeIdx]` to its negation.\n   \n   c. Determine the left and right boundaries of the segments connected to the removed element.\n   \n   d. Calculate the sums of the elements in the connected segments.\n   \n   e. Update the `maxSum` value by subtracting the segment sums connected to the removed element and adding back the sum of the modified segment after the removal.\n   \n   f. Add the index of the removed element to the `removed` set.\n\n4. Return the answer array.\n    ",
        "python": "\n    ```python\ndef max_seg_sum_after_queries(nums, removeQueries):\n    n = len(nums)\n    answer = [0] * n\n    removed = {-1, n}\n    \n    current_sum = 0\n    max_sum = 0\n    for x in nums:\n        if x > 0:\n            current_sum += x\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = 0\n    max_sum = max(max_sum, current_sum)\n    \n    for i, remove_idx in enumerate(removeQueries):\n        answer[i] = max_sum\n        nums[remove_idx] = -nums[remove_idx]\n        \n        left_idx = max(x for x in removed if x < remove_idx)\n        right_idx = min(x for x in removed if x > remove_idx)\n        \n        left_sum = 0\n        right_sum = 0\n        for j in range(right_idx - 1, -1, -1):\n            if nums[j] < 0:\n                left_sum -= nums[j]\n            else:\n                break\n        for j in range(left_idx + 1, n):\n            if nums[j] < 0:\n                right_sum -= nums[j]\n            else:\n                break\n                \n        max_sum -= max(0, left_sum - (-nums[remove_idx]))\n        max_sum -= max(0, right_sum - (-nums[remove_idx]))\n        max_sum += max(0, left_sum + right_sum - (-nums[remove_idx]))\n        \n        removed.add(remove_idx)\n    \n    return answer\n```    \n    1. Create an auxiliary set `removed` to store the indices of removed elements, and initialize it with indices `-1` and `n`. These indices will be used to indicate the left and right boundaries of segments.\n\n2. Calculate the initial maximum segment sum `maxSum` by iterating through the given `nums`.\n\n3. Iterate through the `removeQueries` array. For each removal query:\n\n   a. Store the current `maxSum` value in the answer array.\n   \n   b. Update the value of `nums[removeIdx]` to its negation.\n   \n   c. Determine the left and right boundaries of the segments connected to the removed element.\n   \n   d. Calculate the sums of the elements in the connected segments.\n   \n   e. Update the `maxSum` value by subtracting the segment sums connected to the removed element and adding back the sum of the modified segment after the removal.\n   \n   f. Add the index of the removed element to the `removed` set.\n\n4. Return the answer array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> maxSegSumAfterQueries(vector<int>& nums, vector<int>& removeQueries) {\n    int n = nums.size();\n    vector<int> answer(n);\n    set<int> removed;\n    removed.insert(-1);\n    removed.insert(n);\n    \n    int currentSum = 0, maxSum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] > 0) currentSum += nums[i];\n        else {\n            maxSum = max(maxSum, currentSum);\n            currentSum = 0;\n        }\n    }\n    maxSum = max(maxSum, currentSum);\n    \n    for (int i = 0; i < n; ++i) {\n        int removeIdx = removeQueries[i];\n        answer[i] = maxSum;\n        nums[removeIdx] = -nums[removeIdx];\n        \n        int leftIdx = *removed.upper_bound(removeIdx);\n        int rightIdx = *prev(removed.upper_bound(removeIdx));\n        \n        int leftSum = 0, rightSum = 0;\n        for (int j = leftIdx - 1; j >= 0; --j) {\n            if (nums[j] < 0) leftSum -= nums[j];\n            else break;\n        }\n        for (int j = rightIdx + 1; j < n; ++j) {\n            if (nums[j] < 0) rightSum -= nums[j];\n            else break;\n        }\n        \n        maxSum -= max(0, leftSum - (-nums[removeIdx]));\n        maxSum -= max(0, rightSum - (-nums[removeIdx]));\n        maxSum += max(0, leftSum + rightSum - (-nums[removeIdx]));\n        \n        removed.insert(removeIdx);\n    }\n    \n    return answer;\n}\n```    \n    1. Create an auxiliary set `removed` to store the indices of removed elements, and initialize it with indices `-1` and `n`. These indices will be used to indicate the left and right boundaries of segments.\n\n2. Calculate the initial maximum segment sum `maxSum` by iterating through the given `nums`.\n\n3. Iterate through the `removeQueries` array. For each removal query:\n\n   a. Store the current `maxSum` value in the answer array.\n   \n   b. Update the value of `nums[removeIdx]` to its negation.\n   \n   c. Determine the left and right boundaries of the segments connected to the removed element.\n   \n   d. Calculate the sums of the elements in the connected segments.\n   \n   e. Update the `maxSum` value by subtracting the segment sums connected to the removed element and adding back the sum of the modified segment after the removal.\n   \n   f. Add the index of the removed element to the `removed` set.\n\n4. Return the answer array.\n    ",
        "js": "\n    ```javascript\nfunction maxSegSumAfterQueries(nums, removeQueries) {\n    const n = nums.length;\n    const answer = new Array(n);\n    const removed = new Set([-1, n]);\n    \n    let currentSum = 0, maxSum = 0;\n    for (const x of nums) {\n        if (x > 0) currentSum += x;\n        else {\n            maxSum = Math.max(maxSum, currentSum);\n            currentSum = 0;\n        }\n    }\n    maxSum = Math.max(maxSum, currentSum);\n    \n    for (let i = 0; i < n; ++i) {\n        const removeIdx = removeQueries[i];\n        answer[i] = maxSum;\n        nums[removeIdx] = -nums[removeIdx];\n        \n        const leftIdx = Math.max(...removed).filter(x => x < removeIdx);\n        const rightIdx = Math.min(...removed).filter(x => x > removeIdx);\n        \n        let leftSum = 0, rightSum = 0;\n        for (let j = rightIdx - 1; j >= 0; --j) {\n            if (nums[j] < 0) leftSum -= nums[j];\n            else break;\n        }\n        for (let j = leftIdx + 1; j < n; ++j) {\n            if (nums[j] < 0) rightSum -= nums[j];\n            else break;\n        }\n        \n        maxSum -= Math.max(0, leftSum - (-nums[removeIdx]));\n        maxSum -= Math.max(0, rightSum - (-nums[removeIdx]));\n        maxSum += Math.max(0, leftSum + rightSum - (-nums[removeIdx]));\n        \n        removed.add(removeIdx);\n    }\n    \n    return answer;\n}\n```    \n    1. Create an auxiliary set `removed` to store the indices of removed elements, and initialize it with indices `-1` and `n`. These indices will be used to indicate the left and right boundaries of segments.\n\n2. Calculate the initial maximum segment sum `maxSum` by iterating through the given `nums`.\n\n3. Iterate through the `removeQueries` array. For each removal query:\n\n   a. Store the current `maxSum` value in the answer array.\n   \n   b. Update the value of `nums[removeIdx]` to its negation.\n   \n   c. Determine the left and right boundaries of the segments connected to the removed element.\n   \n   d. Calculate the sums of the elements in the connected segments.\n   \n   e. Update the `maxSum` value by subtracting the segment sums connected to the removed element and adding back the sum of the modified segment after the removal.\n   \n   f. Add the index of the removed element to the `removed` set.\n\n4. Return the answer array.\n    "
    },
    {
        "id": 407,
        "title": "Find the K-Sum of an Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and a **positive** integer `k`. You can choose any **subsequence** of the array and sum all of its elements together.\n\nWe define the **K-Sum** of the array as the `kth` **largest** subsequence sum that can be obtained (**not** necessarily distinct).\n\nReturn _the K-Sum of the array_.\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n**Note** that the empty subsequence is considered to have a sum of `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,-2\\], k = 5\n**Output:** 2\n**Explanation:** All the possible subsequence sums that we can obtain are the following sorted in decreasing order:\n- 6, 4, 4, 2, 2, 0, 0, -2.\nThe 5-Sum of the array is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,-2,3,4,-10,12\\], k = 16\n**Output:** 10\n**Explanation:** The 16-Sum of the array is 10."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `1 <= k <= min(2000, 2n)`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[2,4,-2],5",
                "output": "2"
            },
            {
                "input": "[1,-2,3,4,-10,12],16",
                "output": "10"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Solution {\n    public int kSum(int[] nums, int k) {\n        ArrayList<Integer> sums = new ArrayList<>();\n        sums.add(0);\n        for (int num : nums) {\n            if (num > 0) {\n                for (int i = sums.size() - 1; i >= 0; i--) {\n                    sums.add(sums.get(i) + num);\n                }\n                sums.sort(Collections.reverseOrder());\n            } else {\n                sums.add(num);\n            }\n        }\n\n        return sums.get(k - 1);\n    }\n}\n```\n    \n    To calculate the K-Sum, we need a list of all the sums of max subsequences that can be obtained. The code creates a list `sums` initialized with only one element (0). We iterate over the input `nums`. For each positive number `num`, we add another sum by summing up `num` with every sum that's already in the list `sums`. If the input number is non-positive, we simply append it to the list `sums`. After each iteartion, the list `sums` is sorted in decreasing order to keep track of the largest sum(s) possible. After the process is done, the result is the `k-th` element in the list of `sums` (1-indexed).\n    ",
        "python": "\n    ```python\ndef kSum(nums, k):\n    sums = [0]\n    for num in nums:\n        if num > 0:\n            sums.extend([s + num for s in sums])\n            sums.sort(reverse=True)\n        else:\n            sums.append(num)\n\n    return sums[k - 1]\n```\n    \n    To calculate the K-Sum, we need a list of all the sums of max subsequences that can be obtained. The code creates a list `sums` initialized with only one element (0). We iterate over the input `nums`. For each positive number `num`, we add another sum by summing up `num` with every sum that's already in the list `sums`. If the input number is non-positive, we simply append it to the list `sums`. After each iteartion, the list `sums` is sorted in decreasing order to keep track of the largest sum(s) possible. After the process is done, the result is the `k-th` element in the list of `sums` (1-indexed).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nint kSum(vector<int>& nums, int k) {\n    vector<int> sums{0};\n    for (int num : nums) {\n        if (num > 0) {\n            for (int i = sums.size() - 1; i >= 0; --i) {\n                sums.push_back(sums[i] + num);\n            }\n            sort(sums.rbegin(), sums.rend());\n        } else {\n            sums.push_back(num);\n        }\n    }\n\n    return sums[k - 1];\n}\n```\n    \n    To calculate the K-Sum, we need a list of all the sums of max subsequences that can be obtained. The code creates a list `sums` initialized with only one element (0). We iterate over the input `nums`. For each positive number `num`, we add another sum by summing up `num` with every sum that's already in the list `sums`. If the input number is non-positive, we simply append it to the list `sums`. After each iteartion, the list `sums` is sorted in decreasing order to keep track of the largest sum(s) possible. After the process is done, the result is the `k-th` element in the list of `sums` (1-indexed).\n    ",
        "js": "\n    ```javascript\nfunction kSum(nums, k) {\n    const sums = [0];\n    for (const num of nums) {\n        if (num > 0) {\n            for (let i = sums.length - 1; i >= 0; i--) {\n                sums.push(sums[i] + num);\n            }\n            sums.sort((a, b) => b - a);\n        } else {\n            sums.push(num);\n        }\n    }\n\n    return sums[k - 1];\n}\n```\n    \n    To calculate the K-Sum, we need a list of all the sums of max subsequences that can be obtained. The code creates a list `sums` initialized with only one element (0). We iterate over the input `nums`. For each positive number `num`, we add another sum by summing up `num` with every sum that's already in the list `sums`. If the input number is non-positive, we simply append it to the list `sums`. After each iteartion, the list `sums` is sorted in decreasing order to keep track of the largest sum(s) possible. After the process is done, the result is the `k-th` element in the list of `sums` (1-indexed).\n    "
    },
    {
        "id": 408,
        "title": "Build a Matrix With Conditions",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **positive** integer `k`. You are also given:\n\n*   a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and\n*   a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.\n\nThe two arrays contain integers from `1` to `k`.\n\nYou have to build a `k x k` matrix that contains each of the numbers from `1` to `k` **exactly once**. The remaining cells should have the value `0`.\n\nThe matrix should also satisfy the following conditions:\n\n*   The number `abovei` should appear in a **row** that is strictly **above** the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.\n*   The number `lefti` should appear in a **column** that is strictly **left** of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.\n\nReturn _**any** matrix that satisfies the conditions_. If no answer exists, return an empty matrix.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 3, rowConditions = \\[\\[1,2\\],\\[3,2\\]\\], colConditions = \\[\\[2,1\\],\\[3,2\\]\\]\n**Output:** \\[\\[3,0,0\\],\\[0,0,1\\],\\[0,2,0\\]\\]\n**Explanation:** The diagram above shows a valid example of a matrix that satisfies all the conditions.\nThe row conditions are the following:\n- Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.\n- Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.\nThe column conditions are the following:\n- Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.\n- Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.\nNote that there may be multiple correct answers.\n\n",
                "**Example 2:**\n\n**Input:** k = 3, rowConditions = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\],\\[2,3\\]\\], colConditions = \\[\\[2,1\\]\\]\n**Output:** \\[\\]\n**Explanation:** From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.\nNo matrix can satisfy all the conditions, so we return the empty matrix."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= k <= 400`\n*   `1 <= rowConditions.length, colConditions.length <= 104`\n*   `rowConditions[i].length == colConditions[i].length == 2`\n*   `1 <= abovei, belowi, lefti, righti <= k`\n*   `abovei != belowi`\n*   `lefti != righti`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Graph",
            "Topological Sort",
            "Matrix"
        ],
        "example": [
            {
                "input": "3,[[1,2],[3,2]],[[2,1],[3,2]]",
                "output": "[[3,0,0],[0,0,1],[0,2,0]]"
            },
            {
                "input": "3,[[1,2],[2,3],[3,1],[2,3]],[[2,1]]",
                "output": "[]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int[][] buildMatrix(int k, List<List<Integer>> rowConditions, List<List<Integer>> colConditions) {\n    int[] row = new int[k + 1], col = new int[k + 1];\n    for (List<Integer> condition : rowConditions) {\n        if (row[condition.get(0)] >= row[condition.get(1)]) return new int[][]{};\n        row[condition.get(1)] = row[condition.get(0)] + 1;\n    }\n    for (List<Integer> condition : colConditions) {\n        if (col[condition.get(0)] >= col[condition.get(1)]) return new int[][]{};\n        col[condition.get(1)] = col[condition.get(0)] + 1;\n    }\n    int[][] matrix = new int[k][k];\n    for (int i = 1; i <= k; ++i) {\n        matrix[row[i]][col[i]] = i;\n    }\n    return matrix;\n}\n```\n\n    \n    1. Initialize two arrays `row` and `col` of length `k+1`. They are used to store the row and column positions of each number respectively.\n2. Iterate through `rowConditions` and do the following:\n   a. If `row[a]` is greater than or equal to `row[b]`, then return an empty matrix as no answer exists.\n   b. Update `row[b]` to `row[a] + 1`. This ensures that number `b` is strictly below number `a`.\n3. Iterate through `colConditions` and do the following:\n   a. If `col[a]` is greater than or equal to `col[b]`, then return an empty matrix as no answer exists.\n   b. Update `col[b]` to `col[a] + 1`. This ensures that number `b` is strictly right of number `a`.\n4. Create a k x k matrix filled with zeroes.\n5. Iterate from 1 to k and fill the matrix with numbers from 1 to k at their respective row and column positions, as stored in the `row` and `col` arrays.\n6. Return the filled matrix as the result.\n    ",
        "python": "\n    ```python\ndef build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n    row, col = [0] * (k + 1), [0] * (k + 1)\n    for condition in row_conditions:\n        if row[condition[0]] >= row[condition[1]]:\n            return []\n        row[condition[1]] = row[condition[0]] + 1\n    for condition in col_conditions:\n        if col[condition[0]] >= col[condition[1]]:\n            return []\n        col[condition[1]] = col[condition[0]] + 1\n    matrix = [[0] * k for _ in range(k)]\n    for i in range(1, k + 1):\n        matrix[row[i]][col[i]] = i\n    return matrix\n```\n\n    \n    1. Initialize two arrays `row` and `col` of length `k+1`. They are used to store the row and column positions of each number respectively.\n2. Iterate through `rowConditions` and do the following:\n   a. If `row[a]` is greater than or equal to `row[b]`, then return an empty matrix as no answer exists.\n   b. Update `row[b]` to `row[a] + 1`. This ensures that number `b` is strictly below number `a`.\n3. Iterate through `colConditions` and do the following:\n   a. If `col[a]` is greater than or equal to `col[b]`, then return an empty matrix as no answer exists.\n   b. Update `col[b]` to `col[a] + 1`. This ensures that number `b` is strictly right of number `a`.\n4. Create a k x k matrix filled with zeroes.\n5. Iterate from 1 to k and fill the matrix with numbers from 1 to k at their respective row and column positions, as stored in the `row` and `col` arrays.\n6. Return the filled matrix as the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> buildMatrix(int k, std::vector<std::vector<int>>& rowConditions, std::vector<std::vector<int>>& colConditions) {\n    std::vector<int> row(k + 1, 0), col(k + 1, 0);\n    for (const auto& condition : rowConditions) {\n        if (row[condition[0]] >= row[condition[1]]) return {};\n        row[condition[1]] = row[condition[0]] + 1;\n    }\n    for (const auto& condition : colConditions) {\n        if (col[condition[0]] >= col[condition[1]]) return {};\n        col[condition[1]] = col[condition[0]] + 1;\n    }\n    std::vector<std::vector<int>> matrix(k, std::vector<int>(k));\n    for (int i = 1; i <= k; ++i) {\n        matrix[row[i]][col[i]] = i;\n    }\n    return matrix;\n}\n```\n\n    \n    1. Initialize two arrays `row` and `col` of length `k+1`. They are used to store the row and column positions of each number respectively.\n2. Iterate through `rowConditions` and do the following:\n   a. If `row[a]` is greater than or equal to `row[b]`, then return an empty matrix as no answer exists.\n   b. Update `row[b]` to `row[a] + 1`. This ensures that number `b` is strictly below number `a`.\n3. Iterate through `colConditions` and do the following:\n   a. If `col[a]` is greater than or equal to `col[b]`, then return an empty matrix as no answer exists.\n   b. Update `col[b]` to `col[a] + 1`. This ensures that number `b` is strictly right of number `a`.\n4. Create a k x k matrix filled with zeroes.\n5. Iterate from 1 to k and fill the matrix with numbers from 1 to k at their respective row and column positions, as stored in the `row` and `col` arrays.\n6. Return the filled matrix as the result.\n    ",
        "js": "\n    ```javascript\nfunction buildMatrix(k, rowConditions, colConditions) {\n    let row = new Array(k + 1).fill(0), col = new Array(k + 1).fill(0);\n    for (const condition of rowConditions) {\n        if (row[condition[0]] >= row[condition[1]]) return [];\n        row[condition[1]] = row[condition[0]] + 1;\n    }\n    for (const condition of colConditions) {\n        if (col[condition[0]] >= col[condition[1]]) return [];\n        col[condition[1]] = col[condition[0]] + 1;\n    }\n    let matrix = Array.from({length: k}, () => new Array(k).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        matrix[row[i]][col[i]] = i;\n    }\n    return matrix;\n}\n```\n\n    \n    1. Initialize two arrays `row` and `col` of length `k+1`. They are used to store the row and column positions of each number respectively.\n2. Iterate through `rowConditions` and do the following:\n   a. If `row[a]` is greater than or equal to `row[b]`, then return an empty matrix as no answer exists.\n   b. Update `row[b]` to `row[a] + 1`. This ensures that number `b` is strictly below number `a`.\n3. Iterate through `colConditions` and do the following:\n   a. If `col[a]` is greater than or equal to `col[b]`, then return an empty matrix as no answer exists.\n   b. Update `col[b]` to `col[a] + 1`. This ensures that number `b` is strictly right of number `a`.\n4. Create a k x k matrix filled with zeroes.\n5. Iterate from 1 to k and fill the matrix with numbers from 1 to k at their respective row and column positions, as stored in the `row` and `col` arrays.\n6. Return the filled matrix as the result.\n    "
    },
    {
        "id": 409,
        "title": "Maximum Number of Robots Within Budget",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` robots. You are given two **0-indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`.\n\nThe **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots.\n\nReturn _the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed_ `budget`.",
            "examples": [
                "**Example 1:**\n\n**Input:** chargeTimes = \\[3,6,1,3,4\\], runningCosts = \\[2,1,3,4,5\\], budget = 25\n**Output:** 3\n**Explanation:** \nIt is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 \\* sum(2,1,3) = 6 + 3 \\* 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\n\n",
                "**Example 2:**\n\n**Input:** chargeTimes = \\[11,12,19\\], runningCosts = \\[10,8,7\\], budget = 19\n**Output:** 0\n**Explanation:** No robot can be run that does not exceed the budget, so we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `chargeTimes.length == runningCosts.length == n`\n*   `1 <= n <= 5 * 104`\n*   `1 <= chargeTimes[i], runningCosts[i] <= 105`\n*   `1 <= budget <= 1015`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Queue",
            "Sliding Window",
            "Heap (Priority Queue)",
            "Prefix Sum",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[3,6,1,3,4],[2,1,3,4,5],25",
                "output": "3"
            },
            {
                "input": "[11,12,19],[10,8,7],19",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxConsecutiveRobots(int[] chargeTimes, int[] runningCosts, long budget) {\n    int n = chargeTimes.length;\n    int maxRobots = 0;\n    for (int i = 0; i < n; i++) {\n        int maxCharge = 0;\n        long runningSum = 0;\n        for (int j = i; j < n; j++) {\n            maxCharge = Math.max(maxCharge, chargeTimes[j]);\n            runningSum += runningCosts[j];\n            long cost = maxCharge + runningSum * (j - i + 1);\n            if (cost <= budget)\n                maxRobots = Math.max(maxRobots, j - i + 1);\n            else\n                break;\n        }\n    }\n    return maxRobots;\n}\n```\n    \n    1. Initialize `maxRobots` as 0\n2. Iterate from the first robot to the last robot as the starting point (`i`)\n3. Initialize `maxCharge` as 0 (to store the maximum charge cost) and `runningSum` as 0 (to store the sum of running costs)\n4. Iterate from the starting point robot to the last robot (`j`)\n5. Update `maxCharge` and `runningSum`\n6. Calculate the total cost (`cost`) by `maxCharge + runningSum * (j - i + 1)`\n7. If the total cost is less than or equal to the budget, update `maxRobots` as the maximum of `maxRobots` and `j - i + 1`\n8. If the total cost exceeds the budget, break the inner loop\n9. Continue the outer loop\n10. Return `maxRobots` as the maximum number of consecutive robots that can be run within the budget.\n    ",
        "python": "\n    ```python\ndef max_consecutive_robots(charge_times, running_costs, budget):\n    n = len(charge_times)\n    max_robots = 0\n    for i in range(n):\n        max_charge = 0\n        running_sum = 0\n        for j in range(i, n):\n            max_charge = max(max_charge, charge_times[j])\n            running_sum += running_costs[j]\n            cost = max_charge + running_sum * (j - i + 1)\n            if cost <= budget:\n                max_robots = max(max_robots, j - i + 1)\n            else:\n                break\n    return max_robots\n```\n    \n    1. Initialize `maxRobots` as 0\n2. Iterate from the first robot to the last robot as the starting point (`i`)\n3. Initialize `maxCharge` as 0 (to store the maximum charge cost) and `runningSum` as 0 (to store the sum of running costs)\n4. Iterate from the starting point robot to the last robot (`j`)\n5. Update `maxCharge` and `runningSum`\n6. Calculate the total cost (`cost`) by `maxCharge + runningSum * (j - i + 1)`\n7. If the total cost is less than or equal to the budget, update `maxRobots` as the maximum of `maxRobots` and `j - i + 1`\n8. If the total cost exceeds the budget, break the inner loop\n9. Continue the outer loop\n10. Return `maxRobots` as the maximum number of consecutive robots that can be run within the budget.\n    ",
        "c++": "\n    ```cpp\nint maxConsecutiveRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {\n    int n = chargeTimes.size();\n    int maxRobots = 0;\n    for (int i = 0; i < n; i++) {\n        int maxCharge = 0;\n        long long runningSum = 0;\n        for (int j = i; j < n; j++) {\n            maxCharge = max(maxCharge, chargeTimes[j]);\n            runningSum += runningCosts[j];\n            long long cost = maxCharge + runningSum * (j - i + 1);\n            if (cost <= budget)\n                maxRobots = max(maxRobots, j - i + 1);\n            else\n                break;\n        }\n    }\n    return maxRobots;\n}\n```\n    \n    1. Initialize `maxRobots` as 0\n2. Iterate from the first robot to the last robot as the starting point (`i`)\n3. Initialize `maxCharge` as 0 (to store the maximum charge cost) and `runningSum` as 0 (to store the sum of running costs)\n4. Iterate from the starting point robot to the last robot (`j`)\n5. Update `maxCharge` and `runningSum`\n6. Calculate the total cost (`cost`) by `maxCharge + runningSum * (j - i + 1)`\n7. If the total cost is less than or equal to the budget, update `maxRobots` as the maximum of `maxRobots` and `j - i + 1`\n8. If the total cost exceeds the budget, break the inner loop\n9. Continue the outer loop\n10. Return `maxRobots` as the maximum number of consecutive robots that can be run within the budget.\n    ",
        "js": "\n    ```javascript\nfunction maxConsecutiveRobots(chargeTimes, runningCosts, budget) {\n    const n = chargeTimes.length;\n    let maxRobots = 0;\n    for (let i = 0; i < n; i++) {\n        let maxCharge = 0;\n        let runningSum = 0;\n        for (let j = i; j < n; j++) {\n            maxCharge = Math.max(maxCharge, chargeTimes[j]);\n            runningSum += runningCosts[j];\n            const cost = maxCharge + runningSum * (j - i + 1);\n            if (cost <= budget)\n                maxRobots = Math.max(maxRobots, j - i + 1);\n            else\n                break;\n        }\n    }\n    return maxRobots;\n}\n```\n    \n    1. Initialize `maxRobots` as 0\n2. Iterate from the first robot to the last robot as the starting point (`i`)\n3. Initialize `maxCharge` as 0 (to store the maximum charge cost) and `runningSum` as 0 (to store the sum of running costs)\n4. Iterate from the starting point robot to the last robot (`j`)\n5. Update `maxCharge` and `runningSum`\n6. Calculate the total cost (`cost`) by `maxCharge + runningSum * (j - i + 1)`\n7. If the total cost is less than or equal to the budget, update `maxRobots` as the maximum of `maxRobots` and `j - i + 1`\n8. If the total cost exceeds the budget, break the inner loop\n9. Continue the outer loop\n10. Return `maxRobots` as the maximum number of consecutive robots that can be run within the budget.\n    "
    },
    {
        "id": 410,
        "title": "Meeting Rooms III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.\n\nYou are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**.\n\nMeetings are allocated to rooms in the following manner:\n\n1.  Each meeting will take place in the unused room with the **lowest** number.\n2.  If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting.\n3.  When a room becomes unused, meetings that have an earlier original **start** time should be given the room.\n\nReturn _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._\n\nA **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, meetings = \\[\\[0,10\\],\\[1,5\\],\\[2,7\\],\\[3,4\\]\\]\n**Output:** 0\n**Explanation:**\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period \\[5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period \\[10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n",
                "**Example 2:**\n\n**Input:** n = 3, meetings = \\[\\[1,20\\],\\[2,10\\],\\[3,5\\],\\[4,9\\],\\[6,8\\]\\]\n**Output:** 1\n**Explanation:**\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period \\[5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period \\[10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 2`\n*   `0 <= starti < endi <= 5 * 105`\n*   All the values of `starti` are **unique**.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Sorting",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "example": [
            {
                "input": "2,[[0,10],[1,5],[2,7],[3,4]]",
                "output": "0"
            },
            {
                "input": "3,[[1,20],[2,10],[3,5],[4,9],[6,8]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int mostVisitedRoom(int n, int[][] meetings) {\n    Arrays.sort(meetings, (a, b) -> Integer.compare(a[0], b[0]));\n    PriorityQueue<int[]> pq = new PriorityQueue<>(((a, b) -> Integer.compare(a[0], b[0])));\n    int[] rooms = new int[n];\n    \n    for (int[] meeting : meetings) {\n        while (!pq.isEmpty() && pq.peek()[0] <= meeting[0]) {\n            rooms[pq.poll()[1]]++;\n        }\n        pq.offer(new int[] {meeting[1], pq.size() % n});\n    }\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        if (rooms[i] > rooms[result]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```\n    \n    The solution uses a priority queue to manage the state of the rooms. First, we sort the meetings by the start time. For each meeting, we check if there are any rooms that will be available by the meeting's start time. If so, we increment the counter for that room in the `rooms` array, which tracks the number of meetings held in each room.\n\nAfter looping through all the rooms, we check the `rooms` array to find the room with the highest count of meetings. If there are multiple rooms with the same maximum count, we return the room with the lowest index (room number).\n\nThe time complexity of this solution is O(M * log(M)), where M is the number of meetings, mainly due to sorting the meetings and managing the priority queue. The space complexity is O(N+M), where N is the number of rooms, and M is the number of meetings.\n    ",
        "python": "\n    ```python\nimport heapq\n\ndef most_visited_room(n, meetings):\n    meetings.sort()\n    pq = []\n    rooms = [0] * n\n    \n    for start, end in meetings:\n        while pq and pq[0][0] <= start:\n            _, room = heapq.heappop(pq)\n            rooms[room] += 1\n        heapq.heappush(pq, (end, len(pq) % n))\n    \n    return rooms.index(max(rooms))\n```\n    \n    The solution uses a priority queue to manage the state of the rooms. First, we sort the meetings by the start time. For each meeting, we check if there are any rooms that will be available by the meeting's start time. If so, we increment the counter for that room in the `rooms` array, which tracks the number of meetings held in each room.\n\nAfter looping through all the rooms, we check the `rooms` array to find the room with the highest count of meetings. If there are multiple rooms with the same maximum count, we return the room with the lowest index (room number).\n\nThe time complexity of this solution is O(M * log(M)), where M is the number of meetings, mainly due to sorting the meetings and managing the priority queue. The space complexity is O(N+M), where N is the number of rooms, and M is the number of meetings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint mostVisitedRoom(int n, std::vector<std::vector<int>>& meetings) {\n    std::sort(meetings.begin(), meetings.end());\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> pq;\n    std::vector<int> rooms(n);\n    \n    for (const auto& meeting : meetings) {\n        while (!pq.empty() && pq.top().first <= meeting[0]) {\n            ++rooms[pq.top().second];\n            pq.pop();\n        }\n        pq.push({meeting[1], pq.size() % n});\n    }\n    int result = 0;\n    for (int i = 1; i < n; ++i) {\n        if (rooms[i] > rooms[result]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```\n    \n    The solution uses a priority queue to manage the state of the rooms. First, we sort the meetings by the start time. For each meeting, we check if there are any rooms that will be available by the meeting's start time. If so, we increment the counter for that room in the `rooms` array, which tracks the number of meetings held in each room.\n\nAfter looping through all the rooms, we check the `rooms` array to find the room with the highest count of meetings. If there are multiple rooms with the same maximum count, we return the room with the lowest index (room number).\n\nThe time complexity of this solution is O(M * log(M)), where M is the number of meetings, mainly due to sorting the meetings and managing the priority queue. The space complexity is O(N+M), where N is the number of rooms, and M is the number of meetings.\n    ",
        "js": "\n    ```javascript\nfunction mostVisitedRoom(n, meetings) {\n    meetings.sort((a, b) => a[0] - b[0]);\n    const pq = [];\n    const rooms = Array(n).fill(0);\n    \n    for (const [start, end] of meetings) {\n        while (pq.length && pq[0][0] <= start) {\n            const [_, room] = pq.shift();\n            rooms[room]++;\n        }\n        pq.push([end, pq.length % n]);\n        pq.sort((a, b) => a[0] - b[0]);\n    }\n    \n    return rooms.indexOf(Math.max(...rooms));\n}\n```\n    \n    The solution uses a priority queue to manage the state of the rooms. First, we sort the meetings by the start time. For each meeting, we check if there are any rooms that will be available by the meeting's start time. If so, we increment the counter for that room in the `rooms` array, which tracks the number of meetings held in each room.\n\nAfter looping through all the rooms, we check the `rooms` array to find the room with the highest count of meetings. If there are multiple rooms with the same maximum count, we return the room with the lowest index (room number).\n\nThe time complexity of this solution is O(M * log(M)), where M is the number of meetings, mainly due to sorting the meetings and managing the priority queue. The space complexity is O(N+M), where N is the number of rooms, and M is the number of meetings.\n    "
    },
    {
        "id": 411,
        "title": "Longest Increasing Subsequence II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `k`.\n\nFind the longest subsequence of `nums` that meets the following requirements:\n\n*   The subsequence is **strictly increasing** and\n*   The difference between adjacent elements in the subsequence is **at most** `k`.\n\nReturn _the length of the **longest** **subsequence** that meets the requirements._\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,1,4,3,4,5,8,15\\], k = 3\n**Output:** 5\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[1,3,4,5,8\\].\nThe subsequence has a length of 5, so we return 5.\nNote that the subsequence \\[1,3,4,5,8,15\\] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,4,5,1,8,12,4,7\\], k = 5\n**Output:** 4\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[4,5,8,12\\].\nThe subsequence has a length of 4, so we return 4.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,5\\], k = 1\n**Output:** 1\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[1\\].\nThe subsequence has a length of 1, so we return 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i], k <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Divide and Conquer",
            "Dynamic Programming",
            "Binary Indexed Tree",
            "Segment Tree",
            "Queue",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[4,2,1,4,3,4,5,8,15],3",
                "output": "5"
            },
            {
                "input": "[7,4,5,1,8,12,4,7],5",
                "output": "4"
            },
            {
                "input": "[1,5],1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int longestSubsequence(int[] nums, int k) {\n    int n = nums.length;\n    TreeMap<Integer, Integer> dp = new TreeMap<>();\n    int ans = 0;\n\n    for (int num : nums) {\n        int temp = 0;\n        Integer key = dp.lowerKey(num - k);\n        if (key != null) {\n            temp = dp.get(key);\n        }\n        dp.put(num, Math.max(dp.getOrDefault(num, 0), temp + 1));\n        ans = Math.max(ans, dp.get(num));\n    }\n\n    return ans;\n}\n```\n    \n    The main idea for finding the longest strictly increasing subsequence is using dynamic programming (DP). In each iteration, we iterate over the elements of the `nums` array with the given constraint that the difference between adjacent elements in the subsequence should be no more than `k`.\n\nWe use a dictionary or map to store the maximum length of subsequence that can be formed ending with each element. While iterating, we search for the largest element in the DP smaller than `num - k`. This is done using the `upper_bound` or `lowerKey` methods depending on the language.\n\nIf a valid larger element in the DP can be found, we take the length of the subsequence ending with that larger element and increment it by one (`temp = it->second` or `temp = dp.get(key)`). Then, we update the length of the subsequence ending with `num` with the maximum between the current length and `temp + 1`.\n\nIn the end, we simply return the maximum length of subsequence found.\n\nTime complexity: O(n * log n) due to the usage of a balanced search tree (map or TreeMap)\nSpace complexity: O(n) for the DP map/dictionary.\n    ",
        "python": "\n    ```python\ndef longestSubsequence(nums, k):\n    n = len(nums)\n    dp = {}\n    ans = 0\n\n    for num in nums:\n        temp = 0\n        keys = [key for key in dp if num - k <= key]\n        if keys:\n            temp = dp[max(keys)]\n\n        dp[num] = max(dp.get(num, 0), temp + 1)\n        ans = max(ans, dp[num])\n\n    return ans\n```\n    \n    The main idea for finding the longest strictly increasing subsequence is using dynamic programming (DP). In each iteration, we iterate over the elements of the `nums` array with the given constraint that the difference between adjacent elements in the subsequence should be no more than `k`.\n\nWe use a dictionary or map to store the maximum length of subsequence that can be formed ending with each element. While iterating, we search for the largest element in the DP smaller than `num - k`. This is done using the `upper_bound` or `lowerKey` methods depending on the language.\n\nIf a valid larger element in the DP can be found, we take the length of the subsequence ending with that larger element and increment it by one (`temp = it->second` or `temp = dp.get(key)`). Then, we update the length of the subsequence ending with `num` with the maximum between the current length and `temp + 1`.\n\nIn the end, we simply return the maximum length of subsequence found.\n\nTime complexity: O(n * log n) due to the usage of a balanced search tree (map or TreeMap)\nSpace complexity: O(n) for the DP map/dictionary.\n    ",
        "c++": "\n    ```cpp\nint longestSubsequence(vector<int>& nums, int k) {\n    int n = nums.size();\n    map<int, int> dp;\n    int ans = 0;\n\n    for (int num : nums) {\n        int temp = 0;\n        auto it = dp.upper_bound(num - k - 1);\n        if (it != dp.begin()) {\n            --it;\n            temp = it->second;\n        }\n        dp[num] = max(dp[num], temp + 1);\n        ans = max(ans, dp[num]);\n    }\n\n    return ans;\n}\n```\n    \n    The main idea for finding the longest strictly increasing subsequence is using dynamic programming (DP). In each iteration, we iterate over the elements of the `nums` array with the given constraint that the difference between adjacent elements in the subsequence should be no more than `k`.\n\nWe use a dictionary or map to store the maximum length of subsequence that can be formed ending with each element. While iterating, we search for the largest element in the DP smaller than `num - k`. This is done using the `upper_bound` or `lowerKey` methods depending on the language.\n\nIf a valid larger element in the DP can be found, we take the length of the subsequence ending with that larger element and increment it by one (`temp = it->second` or `temp = dp.get(key)`). Then, we update the length of the subsequence ending with `num` with the maximum between the current length and `temp + 1`.\n\nIn the end, we simply return the maximum length of subsequence found.\n\nTime complexity: O(n * log n) due to the usage of a balanced search tree (map or TreeMap)\nSpace complexity: O(n) for the DP map/dictionary.\n    ",
        "js": "\n    ```javascript\nfunction longestSubsequence(nums, k) {\n    const n = nums.length;\n    const dp = new Map();\n    let ans = 0;\n\n    for (const num of nums) {\n        let temp = 0;\n        const key = [...dp.keys()].reverse().find(key => key <= num - k);\n        if (key !== undefined) {\n            temp = dp.get(key);\n        }\n        dp.set(num, Math.max(dp.get(num) || 0, temp + 1));\n        ans = Math.max(ans, dp.get(num));\n    }\n\n    return ans;\n}\n```\n    \n    The main idea for finding the longest strictly increasing subsequence is using dynamic programming (DP). In each iteration, we iterate over the elements of the `nums` array with the given constraint that the difference between adjacent elements in the subsequence should be no more than `k`.\n\nWe use a dictionary or map to store the maximum length of subsequence that can be formed ending with each element. While iterating, we search for the largest element in the DP smaller than `num - k`. This is done using the `upper_bound` or `lowerKey` methods depending on the language.\n\nIf a valid larger element in the DP can be found, we take the length of the subsequence ending with that larger element and increment it by one (`temp = it->second` or `temp = dp.get(key)`). Then, we update the length of the subsequence ending with `num` with the maximum between the current length and `temp + 1`.\n\nIn the end, we simply return the maximum length of subsequence found.\n\nTime complexity: O(n * log n) due to the usage of a balanced search tree (map or TreeMap)\nSpace complexity: O(n) for the DP map/dictionary.\n    "
    },
    {
        "id": 412,
        "title": "Minimum Money Required Before Transactions",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** 2D integer array `transactions`, where `transactions[i] = [costi, cashbacki]`.\n\nThe array describes transactions, where each transaction must be completed exactly once in **some order**. At any given moment, you have a certain amount of `money`. In order to complete transaction `i`, `money >= costi` must hold true. After performing a transaction, `money` becomes `money - costi + cashbacki`.\n\nReturn _the minimum amount of_ `money` _required before any transaction so that all of the transactions can be completed **regardless of the order** of the transactions._",
            "examples": [
                "**Example 1:**\n\n**Input:** transactions = \\[\\[2,1\\],\\[5,0\\],\\[4,2\\]\\]\n**Output:** 10\n**Explanation:**\nStarting with money = 10, the transactions can be performed in any order.\nIt can be shown that starting with money < 10 will fail to complete all transactions in some order.\n\n",
                "**Example 2:**\n\n**Input:** transactions = \\[\\[3,0\\],\\[0,3\\]\\]\n**Output:** 3\n**Explanation:**\n- If transactions are in the order \\[\\[3,0\\],\\[0,3\\]\\], the minimum money required to complete the transactions is 3.\n- If transactions are in the order \\[\\[0,3\\],\\[3,0\\]\\], the minimum money required to complete the transactions is 0.\nThus, starting with money = 3, the transactions can be performed in any order."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= transactions.length <= 105`\n*   `transactions[i].length == 2`\n*   `0 <= costi, cashbacki <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[2,1],[5,0],[4,2]]",
                "output": "10"
            },
            {
                "input": "[[3,0],[0,3]]",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int min_money(int[][] transactions) {\n    int min_money_needed = 0;\n    for (int[] transaction : transactions) {\n        min_money_needed = Math.max(min_money_needed, transaction[0] - transaction[1]);\n    }\n    return min_money_needed;\n}\n```\n    \n    The algorithm is quite straightforward. It finds the minimum amount of money required by iterating through the transactions and calculating the difference between the cost and cashback for each transaction. To find the minimum amount of money needed, we track the maximum difference between the cost and cashback. At the end of the loop, the maximum difference is returned as the minimum amount of money required to perform all transactions in any order.\n    ",
        "python": "\n    ```python\ndef min_money(transactions):\n    min_money_needed = 0\n    for transaction in transactions:\n        min_money_needed = max(min_money_needed, transaction[0] - transaction[1])\n    return min_money_needed\n```\n    \n    The algorithm is quite straightforward. It finds the minimum amount of money required by iterating through the transactions and calculating the difference between the cost and cashback for each transaction. To find the minimum amount of money needed, we track the maximum difference between the cost and cashback. At the end of the loop, the maximum difference is returned as the minimum amount of money required to perform all transactions in any order.\n    ",
        "c++": "\n    ```cpp\nint min_money(vector<vector<int>>& transactions) {\n    int min_money_needed = 0;\n    for (const auto& transaction : transactions) {\n        min_money_needed = max(min_money_needed, transaction[0] - transaction[1]);\n    }\n    return min_money_needed;\n}\n```\n    \n    The algorithm is quite straightforward. It finds the minimum amount of money required by iterating through the transactions and calculating the difference between the cost and cashback for each transaction. To find the minimum amount of money needed, we track the maximum difference between the cost and cashback. At the end of the loop, the maximum difference is returned as the minimum amount of money required to perform all transactions in any order.\n    ",
        "js": "\n    ```javascript\nfunction min_money(transactions) {\n    let min_money_needed = 0;\n    for (const transaction of transactions) {\n        min_money_needed = Math.max(min_money_needed, transaction[0] - transaction[1]);\n    }\n    return min_money_needed;\n}\n```\n    \n    The algorithm is quite straightforward. It finds the minimum amount of money required by iterating through the transactions and calculating the difference between the cost and cashback for each transaction. To find the minimum amount of money needed, we track the maximum difference between the cost and cashback. At the end of the loop, the maximum difference is returned as the minimum amount of money required to perform all transactions in any order.\n    "
    },
    {
        "id": 413,
        "title": "Sum of Prefix Scores of Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `words` of size `n` consisting of **non-empty** strings.\n\nWe define the **score** of a string `word` as the **number** of strings `words[i]` such that `word` is a **prefix** of `words[i]`.\n\n*   For example, if `words = [ \"a \", \"ab \", \"abc \", \"cab \"]`, then the score of `\"ab \"` is `2`, since `\"ab \"` is a prefix of both `\"ab \"` and `\"abc \"`.\n\nReturn _an array_ `answer` _of size_ `n` _where_ `answer[i]` _is the **sum** of scores of every **non-empty** prefix of_ `words[i]`.\n\n**Note** that a string is considered as a prefix of itself.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abc \", \"ab \", \"bc \", \"b \"\\]\n**Output:** \\[5,4,3,2\\]\n**Explanation:** The answer for each string is the following:\n-  \"abc \" has 3 prefixes:  \"a \",  \"ab \", and  \"abc \".\n- There are 2 strings with the prefix  \"a \", 2 strings with the prefix  \"ab \", and 1 string with the prefix  \"abc \".\nThe total is answer\\[0\\] = 2 + 2 + 1 = 5.\n-  \"ab \" has 2 prefixes:  \"a \" and  \"ab \".\n- There are 2 strings with the prefix  \"a \", and 2 strings with the prefix  \"ab \".\nThe total is answer\\[1\\] = 2 + 2 = 4.\n-  \"bc \" has 2 prefixes:  \"b \" and  \"bc \".\n- There are 2 strings with the prefix  \"b \", and 1 string with the prefix  \"bc \".\nThe total is answer\\[2\\] = 2 + 1 = 3.\n-  \"b \" has 1 prefix:  \"b \".\n- There are 2 strings with the prefix  \"b \".\nThe total is answer\\[3\\] = 2.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"abcd \"\\]\n**Output:** \\[4\\]\n**Explanation:**\n \"abcd \" has 4 prefixes:  \"a \",  \"ab \",  \"abc \", and  \"abcd \".\nEach prefix has a score of one, so the total is answer\\[0\\] = 1 + 1 + 1 + 1 = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Trie",
            "Counting"
        ],
        "example": [
            {
                "input": "[\"abc\",\"ab\",\"bc\",\"b\"]",
                "output": "[5,4,3,2]"
            },
            {
                "input": "[\"abcd\"]",
                "output": "[4]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> prefixScoreSum(List<String> words) {\n    List<Integer> result = new ArrayList<>(words.size());\n    Map<String, Integer> prefixCount = new HashMap<>();\n\n    for (String word : words) {\n        String prefix = \"\";\n        for (char c : word.toCharArray()) {\n            prefix += c;\n            prefixCount.put(prefix, prefixCount.getOrDefault(prefix, 0) + 1);\n        }\n    }\n\n    for (String word : words) {\n        String prefix = \"\";\n        int sum = 0;\n        for (char c : word.toCharArray()) {\n            prefix += c;\n            sum += prefixCount.getOrDefault(prefix, 0);\n        }\n        result.add(sum);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. For each word in `words`, count the number of occurrences of each of its prefixes using a dictionary/hashmap.\n2. For each word in `words`, iterate through its prefixes and sum up the counts calculated in the previous step. Store the result for each word in the `result` list/array.\n\nThe algorithm's time complexity is O(n * max_len(words)), where n is the number of words and max_len(words) is the length of the longest word. The space complexity is also O(n * max_len(words)).\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef prefix_score_sum(words):\n    result = [0] * len(words)\n    prefix_count = defaultdict(int)\n    \n    for word in words:\n        prefix = \"\"\n        for c in word:\n            prefix += c\n            prefix_count[prefix] += 1\n    \n    for i, word in enumerate(words):\n        prefix = \"\"\n        for c in word:\n            prefix += c\n            result[i] += prefix_count[prefix]\n    \n    return result\n```\n    \n    The algorithm works as follows:\n1. For each word in `words`, count the number of occurrences of each of its prefixes using a dictionary/hashmap.\n2. For each word in `words`, iterate through its prefixes and sum up the counts calculated in the previous step. Store the result for each word in the `result` list/array.\n\nThe algorithm's time complexity is O(n * max_len(words)), where n is the number of words and max_len(words) is the length of the longest word. The space complexity is also O(n * max_len(words)).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> prefix_score_sum(std::vector<std::string>& words) {\n    std::vector<int> result(words.size(), 0);\n    std::unordered_map<std::string, int> prefix_count;\n    \n    for (const auto& word : words) {\n        std::string prefix = \"\";\n        for (const auto& c : word) {\n            prefix += c;\n            prefix_count[prefix]++;\n        }\n    }\n    \n    for (int i = 0; i < words.size(); ++i) {\n        std::string prefix = \"\";\n        for (const auto& c : words[i]) {\n            prefix += c;\n            result[i] += prefix_count[prefix];\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. For each word in `words`, count the number of occurrences of each of its prefixes using a dictionary/hashmap.\n2. For each word in `words`, iterate through its prefixes and sum up the counts calculated in the previous step. Store the result for each word in the `result` list/array.\n\nThe algorithm's time complexity is O(n * max_len(words)), where n is the number of words and max_len(words) is the length of the longest word. The space complexity is also O(n * max_len(words)).\n    ",
        "js": "\n    ```javascript\nfunction prefixScoreSum(words) {\n    const result = new Array(words.length).fill(0);\n    const prefixCount = {};\n\n    for (const word of words) {\n        let prefix = \"\";\n        for (const c of word) {\n            prefix += c;\n            prefixCount[prefix] = (prefixCount[prefix] || 0) + 1;\n        }\n    }\n\n    for (let i = 0; i < words.length; i++) {\n        let prefix = \"\";\n        for (const c of words[i]) {\n            prefix += c;\n            result[i] += prefixCount[prefix];\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. For each word in `words`, count the number of occurrences of each of its prefixes using a dictionary/hashmap.\n2. For each word in `words`, iterate through its prefixes and sum up the counts calculated in the previous step. Store the result for each word in the `result` list/array.\n\nThe algorithm's time complexity is O(n * max_len(words)), where n is the number of words and max_len(words) is the length of the longest word. The space complexity is also O(n * max_len(words)).\n    "
    },
    {
        "id": 414,
        "title": "Number of Good Paths",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a tree (i.e. a connected, undirected graph with no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.\n\nYou are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA **good path** is a simple path that satisfies the following conditions:\n\n1.  The starting node and the ending node have the **same** value.\n2.  All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).\n\nReturn _the number of distinct good paths_.\n\nNote that a path and its reverse are counted as the **same** path. For example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is also considered as a valid path.",
            "examples": [
                "**Example 1:**\n\n**Input:** vals = \\[1,3,2,1,3\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 6\n**Explanation:** There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals\\[2\\] > vals\\[0\\].\n\n",
                "**Example 2:**\n\n**Input:** vals = \\[1,1,2,2,3\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 7\n**Explanation:** There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n",
                "**Example 3:**\n\n**Input:** vals = \\[1\\], edges = \\[\\]\n**Output:** 1\n**Explanation:** The tree consists of only one node, so there is one good path."
            ],
            "constraints": "**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= vals[i] <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Tree",
            "Union Find",
            "Graph",
            "Sorting"
        ],
        "example": [
            {
                "input": "[1,3,2,1,3],[[0,1],[0,2],[2,3],[2,4]]",
                "output": "6"
            },
            {
                "input": "[1,1,2,2,3],[[0,1],[1,2],[2,3],[2,4]]",
                "output": "7"
            },
            {
                "input": "[1],[]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GoodPaths {\n    public static void dfs(int node, int parent, List<List<Integer>> adj, int[] vals, int curMax, int[] count) {\n        if (vals[node] >= curMax) {\n            if (vals[node] > curMax) {\n                count[0]++;\n                curMax = vals[node];\n            }\n            for (int next : adj.get(node)) {\n                if (next != parent) {\n                    dfs(next, node, adj, vals, curMax, count);\n                }\n            }\n        }\n    }\n\n    public static int numberOfGoodPaths(int[] vals, int[][] edges) {\n        int n = vals.length;\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            adj.get(edge[0]).add(edge[1]);\n            adj.get(edge[1]).add(edge[0]);\n        }\n        int[] count = {0};\n        for (int i = 0; i < n; i++) {\n            dfs(i, -1, adj, vals, -1, count);\n        }\n        return count[0];\n    }\n}\n```\n    \n    The problem can be solved with a Depth-First Search (DFS) traversal of the tree.\n\n1. Create an adjacency list from the given edges. The adjacency list will represent the tree graph with connections between nodes.\n2. Perform DFS on each node, passing its value, the current max value on the path, and a count variable.\n3. In the DFS function:\n   - If the current node's value is greater than or equal to the current max value, do the following:\n     - If the current node's value is greater than the current max value, increment the count and update the current max value.\n     - Continue the DFS traversal by calling the DFS function for each of the node's children (except the parent node).\n4. Return the count variable for the total number of good paths.\n\nThe time complexity of this solution is O(n^2), where n is the number of nodes. This is because in the worst case, the DFS traversal may need to visit every other node from the starting node.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]\n```\n    \n    The problem can be solved with a Depth-First Search (DFS) traversal of the tree.\n\n1. Create an adjacency list from the given edges. The adjacency list will represent the tree graph with connections between nodes.\n2. Perform DFS on each node, passing its value, the current max value on the path, and a count variable.\n3. In the DFS function:\n   - If the current node's value is greater than or equal to the current max value, do the following:\n     - If the current node's value is greater than the current max value, increment the count and update the current max value.\n     - Continue the DFS traversal by calling the DFS function for each of the node's children (except the parent node).\n4. Return the count variable for the total number of good paths.\n\nThe time complexity of this solution is O(n^2), where n is the number of nodes. This is because in the worst case, the DFS traversal may need to visit every other node from the starting node.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, int parent, const vector<vector<int>>& adj, const vector<int>& vals, int curMax, int& count) {\n    if (vals[node] >= curMax) {\n        if (vals[node] > curMax) {\n            count++;\n            curMax = vals[node];\n        }\n        for (int next : adj[node]) {\n            if (next != parent) {\n                dfs(next, node, adj, vals, curMax, count);\n            }\n        }\n    }\n}\n\nint NumberOfGoodPaths(const vector<int>& vals, const vector<vector<int>>& edges) {\n    int n = vals.size();\n    vector<vector<int>> adj(n);\n    for (const auto& edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        dfs(i, -1, adj, vals, -1, count);\n    }\n    return count;\n}\n```\n    \n    The problem can be solved with a Depth-First Search (DFS) traversal of the tree.\n\n1. Create an adjacency list from the given edges. The adjacency list will represent the tree graph with connections between nodes.\n2. Perform DFS on each node, passing its value, the current max value on the path, and a count variable.\n3. In the DFS function:\n   - If the current node's value is greater than or equal to the current max value, do the following:\n     - If the current node's value is greater than the current max value, increment the count and update the current max value.\n     - Continue the DFS traversal by calling the DFS function for each of the node's children (except the parent node).\n4. Return the count variable for the total number of good paths.\n\nThe time complexity of this solution is O(n^2), where n is the number of nodes. This is because in the worst case, the DFS traversal may need to visit every other node from the starting node.\n    ",
        "js": "\n    ```javascript\nfunction dfs(node, parent, adj, vals, curMax, count) {\n    if (vals[node] >= curMax) {\n        if (vals[node] > curMax) {\n            count[0]++;\n            curMax = vals[node];\n        }\n        for (const next of adj[node]) {\n            if (next !== parent) {\n                dfs(next, node, adj, vals, curMax, count);\n            }\n        }\n    }\n}\n\nfunction numberOfGoodPaths(vals, edges) {\n    const n = vals.length;\n    const adj = Array(n).fill(null).map(() => []);\n    for (const edge of edges) {\n        adj[edge[0]].push(edge[1]);\n        adj[edge[1]].push(edge[0]);\n    }\n    const count = [0];\n    for (let i = 0; i < n; i++) {\n        dfs(i, -1, adj, vals, -1, count);\n    }\n    return count[0];\n}\n```\n    \n    The problem can be solved with a Depth-First Search (DFS) traversal of the tree.\n\n1. Create an adjacency list from the given edges. The adjacency list will represent the tree graph with connections between nodes.\n2. Perform DFS on each node, passing its value, the current max value on the path, and a count variable.\n3. In the DFS function:\n   - If the current node's value is greater than or equal to the current max value, do the following:\n     - If the current node's value is greater than the current max value, increment the count and update the current max value.\n     - Continue the DFS traversal by calling the DFS function for each of the node's children (except the parent node).\n4. Return the count variable for the total number of good paths.\n\nThe time complexity of this solution is O(n^2), where n is the number of nodes. This is because in the worst case, the DFS traversal may need to visit every other node from the starting node.\n    "
    },
    {
        "id": 415,
        "title": "Number of Pairs Satisfying Inequality",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `nums1` and `nums2`, each of size `n`, and an integer `diff`. Find the number of **pairs** `(i, j)` such that:\n\n*   `0 <= i < j <= n - 1` **and**\n*   `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`.\n\nReturn _the **number of pairs** that satisfy the conditions._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[3,2,5\\], nums2 = \\[2,2,1\\], diff = 1\n**Output:** 3\n**Explanation:**\nThere are 3 pairs that satisfy the conditions:\n1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. Since i < j and 1 <= 1, this pair satisfies the conditions.\n2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. Since i < j and -2 <= 2, this pair satisfies the conditions.\n3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. Since i < j and -3 <= 2, this pair satisfies the conditions.\nTherefore, we return 3.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[3,-1\\], nums2 = \\[-2,2\\], diff = -1\n**Output:** 0\n**Explanation:**\nSince there does not exist any pair that satisfies the conditions, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `2 <= n <= 105`\n*   `-104 <= nums1[i], nums2[i] <= 104`\n*   `-104 <= diff <= 104`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Divide and Conquer",
            "Binary Indexed Tree",
            "Segment Tree",
            "Merge Sort",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "[3,2,5],[2,2,1],1",
                "output": "3"
            },
            {
                "input": "[3,-1],[-2,2],-1",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int countPairs(int[] nums1, int[] nums2, int diff) {\n    int n = nums1.length, count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a nested loop to iterate through all possible pairs `(i, j)` such that `0 <= i < j <= n - 1`. For each pair, it compares the difference in elements in `nums1` and `nums2` to check if it satisfies the given condition `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`. If the condition is satisfied, increment the count. In the end, return the count which holds the number of pairs that satisfy the conditions.\n    ",
        "python": "\n    ```python\ndef count_pairs(nums1, nums2, diff):\n    n = len(nums1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                count += 1\n    return count\n```\n    \n    The algorithm uses a nested loop to iterate through all possible pairs `(i, j)` such that `0 <= i < j <= n - 1`. For each pair, it compares the difference in elements in `nums1` and `nums2` to check if it satisfies the given condition `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`. If the condition is satisfied, increment the count. In the end, return the count which holds the number of pairs that satisfy the conditions.\n    ",
        "c++": "\n    ```cpp\nint countPairs(const vector<int>& nums1, const vector<int>& nums2, int diff) {\n    int n = nums1.size(), count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a nested loop to iterate through all possible pairs `(i, j)` such that `0 <= i < j <= n - 1`. For each pair, it compares the difference in elements in `nums1` and `nums2` to check if it satisfies the given condition `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`. If the condition is satisfied, increment the count. In the end, return the count which holds the number of pairs that satisfy the conditions.\n    ",
        "js": "\n    ```javascript\nfunction countPairs(nums1, nums2, diff) {\n    let n = nums1.length, count = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm uses a nested loop to iterate through all possible pairs `(i, j)` such that `0 <= i < j <= n - 1`. For each pair, it compares the difference in elements in `nums1` and `nums2` to check if it satisfies the given condition `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff`. If the condition is satisfied, increment the count. In the end, return the count which holds the number of pairs that satisfy the conditions.\n    "
    },
    {
        "id": 416,
        "title": "Create Components With Same Value",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nYou are allowed to **delete** some edges, splitting the tree into multiple connected components. Let the **value** of a component be the sum of **all** `nums[i]` for which node `i` is in the component.\n\nReturn _the **maximum** number of edges you can delete, such that every connected component in the tree has the same value._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[6,2,2,2,6\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\] \n**Output:** 2 \n**Explanation:** The above figure shows how we can delete the edges \\[0,1\\] and \\[3,4\\]. The created components are nodes \\[0\\], \\[1,2,3\\] and \\[4\\]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2\\], edges = \\[\\]\n**Output:** 0\n**Explanation:** There are no edges to be deleted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= edges[i][0], edges[i][1] <= n - 1`\n*   `edges` represents a valid tree.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Math",
            "Tree",
            "Depth-First Search",
            "Enumeration"
        ],
        "example": [
            {
                "input": "[6,2,2,2,6],[[0,1],[1,2],[1,3],[3,4]]",
                "output": "2"
            },
            {
                "input": "[2],[]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int dfs(int node, int parent, int[] nums, List<List<Integer>> graph, int total, int[] result) {\n    int sum = nums[node];\n    for (int neighbor : graph.get(node)) {\n        if (neighbor != parent) {\n            sum += dfs(neighbor, node, nums, graph, total, result);\n        }\n    }\n    if (sum == total / 2) {\n        result[0]++;\n        return 0;\n    }\n    return sum;\n}\n\npublic int delete_edges_to_balance_tree(int[] nums, int[][] edges) {\n    int n = nums.length;\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        graph.add(new ArrayList<>());\n    }\n    for (int[] e : edges) {\n        graph.get(e[0]).add(e[1]);\n        graph.get(e[1]).add(e[0]);\n    }\n\n    int total = 0;\n    for (int num : nums) {\n        total += num;\n    }\n    if (total % 2 != 0) {\n        return 0;  // It is impossible to split the tree fairly.\n    }\n\n    int[] result = {0};\n    dfs(0, -1, nums, graph, total, result);\n    return result[0] - 1;\n}\n```\n    \n    The algorithm includes the following steps:\n\n1. Build a graph representing the tree, where each node has an array of its adjacent nodes.\n2. Calculate the total sum of the values in `nums`.\n3. If the total sum is not divisible by 2, return 0 since it is impossible to divide the tree into components with the same value.\n4. Perform a Depth-First Search (DFS) from node 0, traversing through the tree and calculating the subtree sums while keeping track of how many subtree sums we have seen that are half of the total sum.\n5. Return the number of subtree sums that are half of the total sum minus 1, since we have to remove one additional component (the whole tree).\n\nThe time complexity of the algorithm is O(n), as we traverse each node in the tree once during the DFS.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef dfs(node, parent, nums, graph, total, result):\n    total_sum = nums[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            total_sum += dfs(neighbor, node, nums, graph, total, result)\n    if total_sum == total // 2:\n        result.append(1)\n        return 0\n    return total_sum\n\ndef delete_edges_to_balance_tree(nums, edges):\n    n = len(nums)\n    graph = defaultdict(list)\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    total = sum(nums)\n    if total % 2 != 0:\n        return 0  # It is impossible to split the tree fairly.\n\n    result = []\n    dfs(0, -1, nums, graph, total, result)\n    return len(result) - 1\n```\n    \n    The algorithm includes the following steps:\n\n1. Build a graph representing the tree, where each node has an array of its adjacent nodes.\n2. Calculate the total sum of the values in `nums`.\n3. If the total sum is not divisible by 2, return 0 since it is impossible to divide the tree into components with the same value.\n4. Perform a Depth-First Search (DFS) from node 0, traversing through the tree and calculating the subtree sums while keeping track of how many subtree sums we have seen that are half of the total sum.\n5. Return the number of subtree sums that are half of the total sum minus 1, since we have to remove one additional component (the whole tree).\n\nThe time complexity of the algorithm is O(n), as we traverse each node in the tree once during the DFS.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint dfs(int node, int parent, vector<int>& nums, vector<vector<int>>& graph, int total, int& result) {\n    int sum = nums[node];\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            sum += dfs(neighbor, node, nums, graph, total, result);\n        }\n    }\n    if (sum == total / 2) {\n        result++;\n        return 0;\n    }\n    return sum;\n}\n\nint delete_edges_to_balance_tree(vector<int>& nums, vector<vector<int>>& edges) {\n    int n = nums.size();\n    vector<vector<int>> graph(n);\n    for (auto& e : edges) {\n        graph[e[0]].push_back(e[1]);\n        graph[e[1]].push_back(e[0]);\n    }\n\n    int total = 0;\n    for (int num : nums) {\n        total += num;\n    }\n    if (total % 2 != 0) {\n        return 0;  // It is impossible to split the tree fairly.\n    }\n\n    int result = 0;\n    dfs(0, -1, nums, graph, total, result);\n    return result - 1;\n}\n```\n    \n    The algorithm includes the following steps:\n\n1. Build a graph representing the tree, where each node has an array of its adjacent nodes.\n2. Calculate the total sum of the values in `nums`.\n3. If the total sum is not divisible by 2, return 0 since it is impossible to divide the tree into components with the same value.\n4. Perform a Depth-First Search (DFS) from node 0, traversing through the tree and calculating the subtree sums while keeping track of how many subtree sums we have seen that are half of the total sum.\n5. Return the number of subtree sums that are half of the total sum minus 1, since we have to remove one additional component (the whole tree).\n\nThe time complexity of the algorithm is O(n), as we traverse each node in the tree once during the DFS.\n    ",
        "js": "\n    ```javascript\nfunction dfs(node, parent, nums, graph, total, result) {\n    let sum = nums[node];\n    for (let neighbor of graph[node]) {\n        if (neighbor !== parent) {\n            sum += dfs(neighbor, node, nums, graph, total, result);\n        }\n    }\n    if (sum === Math.floor(total / 2)) {\n        result.push(1);\n        return 0;\n    }\n    return sum;\n}\n\nfunction delete_edges_to_balance_tree(nums, edges) {\n    const n = nums.length;\n    const graph = Array.from({ length: n }, () => []);\n    for (const [a, b] of edges) {\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n\n    const total = nums.reduce((a, b) => a + b, 0);\n    if (total % 2 !== 0)\n        return 0; // It is impossible to split the tree fairly.\n    \n    const result = [];\n    dfs(0, -1, nums, graph, total, result);\n    return result.length - 1;\n}\n```\n\n    \n    The algorithm includes the following steps:\n\n1. Build a graph representing the tree, where each node has an array of its adjacent nodes.\n2. Calculate the total sum of the values in `nums`.\n3. If the total sum is not divisible by 2, return 0 since it is impossible to divide the tree into components with the same value.\n4. Perform a Depth-First Search (DFS) from node 0, traversing through the tree and calculating the subtree sums while keeping track of how many subtree sums we have seen that are half of the total sum.\n5. Return the number of subtree sums that are half of the total sum minus 1, since we have to remove one additional component (the whole tree).\n\nThe time complexity of the algorithm is O(n), as we traverse each node in the tree once during the DFS.\n    "
    },
    {
        "id": 417,
        "title": "Count Subarrays With Fixed Bounds",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and two integers `minK` and `maxK`.\n\nA **fixed-bound subarray** of `nums` is a subarray that satisfies the following conditions:\n\n*   The **minimum** value in the subarray is equal to `minK`.\n*   The **maximum** value in the subarray is equal to `maxK`.\n\nReturn _the **number** of fixed-bound subarrays_.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,2,7,5\\], minK = 1, maxK = 5\n**Output:** 2\n**Explanation:** The fixed-bound subarrays are \\[1,3,5\\] and \\[1,3,5,2\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1,1\\], minK = 1, maxK = 1\n**Output:** 10\n**Explanation:** Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `1 <= nums[i], minK, maxK <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Queue",
            "Sliding Window",
            "Monotonic Queue"
        ],
        "example": [
            {
                "input": "[1,3,5,2,7,5],1,5",
                "output": "2"
            },
            {
                "input": "[1,1,1,1],1,1",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int fixedBoundSubarrays(int[] nums, int minK, int maxK) {\n    int count = 0, min_index = -1, max_index = -1;\n    for (int i = 0; i < nums.length; i++) {\n        if(nums[i]==minK) min_index=i;\n        else if(nums[i]==maxK) max_index=i;\n        count += Math.min(min_index, max_index)+1;\n    }\n    return count;\n}\n```\n    \n    We initialize counter, min_index, and max_index variables. Iterate through the given nums array. Inside the loop, we check if the current element of nums equals minK or maxK, and we update min_index or max_index accordingly.\n\nAfter updating min_index and/or max_index, we calculate the minimum of min_index and max_index, and add it to the counter. We also add 1 to this result, since we need to account for the fixed-bound subarray itself.\n\nAt the end of the loop, return the counter representing the number of fixed-bound subarrays.\n    ",
        "python": "\n    ```python\ndef fixed_bound_subarrays(nums, minK, maxK):\n    count, min_index, max_index = 0, -1, -1\n    for i, num in enumerate(nums):\n        if num==minK:\n            min_index=i\n        elif num==maxK:\n            max_index=i\n        \n        count += min(min_index, max_index) + 1\n    return count\n```\n    \n    We initialize counter, min_index, and max_index variables. Iterate through the given nums array. Inside the loop, we check if the current element of nums equals minK or maxK, and we update min_index or max_index accordingly.\n\nAfter updating min_index and/or max_index, we calculate the minimum of min_index and max_index, and add it to the counter. We also add 1 to this result, since we need to account for the fixed-bound subarray itself.\n\nAt the end of the loop, return the counter representing the number of fixed-bound subarrays.\n    ",
        "c++": "\n    ```cpp\nint fixedBoundSubarrays(vector<int>& nums, int minK, int maxK) {\n    int count = 0, min_index = -1, max_index = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        if(nums[i]==minK) min_index=i;\n        else if(nums[i]==maxK) max_index=i;\n        count += min(min_index, max_index)+1;\n    }\n    return count;\n}\n```\n    \n    We initialize counter, min_index, and max_index variables. Iterate through the given nums array. Inside the loop, we check if the current element of nums equals minK or maxK, and we update min_index or max_index accordingly.\n\nAfter updating min_index and/or max_index, we calculate the minimum of min_index and max_index, and add it to the counter. We also add 1 to this result, since we need to account for the fixed-bound subarray itself.\n\nAt the end of the loop, return the counter representing the number of fixed-bound subarrays.\n    ",
        "js": "\n    ```javascript\nfunction fixedBoundSubarrays(nums, minK, maxK) {\n    let count = 0, min_index = -1, max_index = -1;\n    for (let i = 0; i < nums.length; i++) {\n        if(nums[i]===minK) min_index=i;\n        else if(nums[i]===maxK) max_index=i;\n        count += Math.min(min_index, max_index)+1;\n    }\n    return count;\n}\n```\n    \n    We initialize counter, min_index, and max_index variables. Iterate through the given nums array. Inside the loop, we check if the current element of nums equals minK or maxK, and we update min_index or max_index accordingly.\n\nAfter updating min_index and/or max_index, we calculate the minimum of min_index and max_index, and add it to the counter. We also add 1 to this result, since we need to account for the fixed-bound subarray itself.\n\nAt the end of the loop, return the counter representing the number of fixed-bound subarrays.\n    "
    },
    {
        "id": 418,
        "title": "Minimum Cost to Make Array Equal",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** arrays `nums` and `cost` consisting each of `n` **positive** integers.\n\nYou can do the following operation **any** number of times:\n\n*   Increase or decrease **any** element of the array `nums` by `1`.\n\nThe cost of doing one operation on the `ith` element is `cost[i]`.\n\nReturn _the **minimum** total cost such that all the elements of the array_ `nums` _become **equal**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,2\\], cost = \\[2,3,1,14\\]\n**Output:** 8\n**Explanation:** We can make all the elements equal to 2 in the following way:\n- Increase the 0th element one time. The cost is 2.\n- Decrease the 1st element one time. The cost is 3.\n- Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.\nThe total cost is 2 + 3 + 3 = 8.\nIt can be shown that we cannot make the array equal with a smaller cost.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\], cost = \\[4,2,8,1,3\\]\n**Output:** 0\n**Explanation:** All the elements are already equal, so no operations are needed."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length == cost.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i], cost[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Sorting",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,3,5,2],[2,3,1,14]",
                "output": "8"
            },
            {
                "input": "[2,2,2,2,2],[4,2,8,1,3]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic long minCost(int[] nums, int[] cost) {\n    long ans = Long.MAX_VALUE;\n    int minValue = nums[0];\n    \n    for (int num : nums) {\n        minValue = Math.min(minValue, num);\n    }\n    \n    for (int target = minValue; target < minValue + 2; target++) {\n        long local_res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            local_res += Math.abs(nums[i] - target) * cost[i];\n        }\n        ans = Math.min(ans, local_res);\n    }\n    \n    return ans;\n}\n```\n    \n    The algorithm starts by finding the minimum value present in the `nums` array. Then, it iterates through `target` values within the range `[base, base + 1]` because we only need to check the minimum value and potential next minimum value. For each possible `target`, calculate the local result by iterating through the elements in the `nums` array and multiplying the absolute difference between the current element and target by the corresponding cost element. Update the global minimum cost if the local result is smaller than the current global minimum.\n    ",
        "python": "\n    ```python\ndef minCost(nums, cost):\n    ans = float(\"inf\")\n    base = min(nums)\n    \n    for target in range(base, base + 2):\n        local_res = 0\n        for i in range(len(nums)):\n            local_res += abs(nums[i] - target) * cost[i]\n        ans = min(ans, local_res)\n    \n    return ans\n```\n    \n    The algorithm starts by finding the minimum value present in the `nums` array. Then, it iterates through `target` values within the range `[base, base + 1]` because we only need to check the minimum value and potential next minimum value. For each possible `target`, calculate the local result by iterating through the elements in the `nums` array and multiplying the absolute difference between the current element and target by the corresponding cost element. Update the global minimum cost if the local result is smaller than the current global minimum.\n    ",
        "c++": "\n    ```cpp\nlong long minCost(vector<int>& nums, vector<int>& cost) {\n    long long ans = LLONG_MAX;\n    long long base = *min_element(nums.begin(), nums.end());\n    \n    for(int target = base; target < base+2; target++) {        \n        long long local_res = 0;\n        for(int i = 0; i < nums.size(); i++) {\n            local_res += abs(nums[i] - target) * cost[i];\n        }\n        ans = min(ans, local_res);\n    }\n    \n    return ans;\n}\n```\n    \n    The algorithm starts by finding the minimum value present in the `nums` array. Then, it iterates through `target` values within the range `[base, base + 1]` because we only need to check the minimum value and potential next minimum value. For each possible `target`, calculate the local result by iterating through the elements in the `nums` array and multiplying the absolute difference between the current element and target by the corresponding cost element. Update the global minimum cost if the local result is smaller than the current global minimum.\n    ",
        "js": "\n    ```javascript\nfunction minCost(nums, cost) {\n    let ans = Number.MAX_VALUE;\n    let base = Math.min(...nums);\n    \n    for (let target = base; target < base + 2; target++) {\n        let local_res = 0;\n        for (let i = 0; i < nums.length; i++) {\n            local_res += Math.abs(nums[i] - target) * cost[i];\n        }\n        ans = Math.min(ans, local_res);\n    }\n    \n    return ans;\n}\n```\n    \n    The algorithm starts by finding the minimum value present in the `nums` array. Then, it iterates through `target` values within the range `[base, base + 1]` because we only need to check the minimum value and potential next minimum value. For each possible `target`, calculate the local result by iterating through the elements in the `nums` array and multiplying the absolute difference between the current element and target by the corresponding cost element. Update the global minimum cost if the local result is smaller than the current global minimum.\n    "
    },
    {
        "id": 419,
        "title": "Minimum Number of Operations to Make Arrays Similar",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two positive integer arrays `nums` and `target`, of the same length.\n\nIn one operation, you can choose any two **distinct** indices `i` and `j` where `0 <= i, j < nums.length` and:\n\n*   set `nums[i] = nums[i] + 2` and\n*   set `nums[j] = nums[j] - 2`.\n\nTwo arrays are considered to be **similar** if the frequency of each element is the same.\n\nReturn _the minimum number of operations required to make_ `nums` _similar to_ `target`. The test cases are generated such that `nums` can always be similar to `target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[8,12,6\\], target = \\[2,14,10\\]\n**Output:** 2\n**Explanation:** It is possible to make nums similar to target in two operations:\n- Choose i = 0 and j = 2, nums = \\[10,12,4\\].\n- Choose i = 1 and j = 2, nums = \\[10,14,2\\].\nIt can be shown that 2 is the minimum number of operations needed.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,5\\], target = \\[4,1,3\\]\n**Output:** 1\n**Explanation:** We can make nums similar to target in one operation:\n- Choose i = 1 and j = 2, nums = \\[1,4,3\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,1,1\\], target = \\[1,1,1,1,1\\]\n**Output:** 0\n**Explanation:** The array nums is already similiar to target."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length == target.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i], target[i] <= 106`\n*   It is possible to make `nums` similar to `target`.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[8,12,6],[2,14,10]",
                "output": "2"
            },
            {
                "input": "[1,2,5],[4,1,3]",
                "output": "1"
            },
            {
                "input": "[1,1,1,1,1],[1,1,1,1,1]",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int minOperations(int[] nums, int[] target) {\n    int n = nums.length;\n    int sum_nums = 0;\n    int sum_target = 0;\n    for (int i = 0; i < n; i++) {\n        sum_nums += nums[i];\n        sum_target += target[i];\n    }\n    int diff = (sum_target - sum_nums) / 2;\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (nums[i] > target[i]) {\n            cnt += (nums[i] - target[i] - diff) / 2;\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    1. Calculate the sum of both nums and target arrays.\n2. Calculate the difference in sum (sum_target - sum_nums) and divide by 2.\n3. For each element in nums, if it's greater than the corresponding element in target, increment the count cnt by the difference between the elements, minus diff and then divide by 2.\n4. Return the cnt as the minimum number of operations required to make nums similar to target.\n    ",
        "python": "\n    ```python\ndef minOperations(nums, target):\n    n = len(nums)\n    sum_nums = sum(nums)\n    sum_target = sum(target)\n    diff = (sum_target - sum_nums) // 2\n    cnt = 0\n    for i in range(n):\n        if nums[i] > target[i]:\n            cnt += (nums[i] - target[i] - diff) // 2\n    return cnt\n```\n\n    \n    1. Calculate the sum of both nums and target arrays.\n2. Calculate the difference in sum (sum_target - sum_nums) and divide by 2.\n3. For each element in nums, if it's greater than the corresponding element in target, increment the count cnt by the difference between the elements, minus diff and then divide by 2.\n4. Return the cnt as the minimum number of operations required to make nums similar to target.\n    ",
        "c++": "\n    ```cpp\nint minOperations(vector<int>& nums, vector<int>& target) {\n    int n = nums.size();\n    int sum_nums = 0;\n    int sum_target = 0;\n    for (int i = 0; i < n; i++) {\n        sum_nums += nums[i];\n        sum_target += target[i];\n    }\n    int diff = (sum_target - sum_nums) / 2;\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (nums[i] > target[i]) {\n            cnt += (nums[i] - target[i] - diff) / 2;\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    1. Calculate the sum of both nums and target arrays.\n2. Calculate the difference in sum (sum_target - sum_nums) and divide by 2.\n3. For each element in nums, if it's greater than the corresponding element in target, increment the count cnt by the difference between the elements, minus diff and then divide by 2.\n4. Return the cnt as the minimum number of operations required to make nums similar to target.\n    ",
        "js": "\n    ```javascript\nfunction minOperations(nums, target) {\n    const n = nums.length;\n    const sum_nums = nums.reduce((a, b) => a + b, 0);\n    const sum_target = target.reduce((a, b) => a + b, 0);\n    const diff = (sum_target - sum_nums) / 2;\n    let cnt = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] > target[i]) {\n            cnt += (nums[i] - target[i] - diff) / 2;\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    1. Calculate the sum of both nums and target arrays.\n2. Calculate the difference in sum (sum_target - sum_nums) and divide by 2.\n3. For each element in nums, if it's greater than the corresponding element in target, increment the count cnt by the difference between the elements, minus diff and then divide by 2.\n4. Return the cnt as the minimum number of operations required to make nums similar to target.\n    "
    },
    {
        "id": 420,
        "title": "Next Greater Element IV",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** array of non-negative integers `nums`. For each integer in `nums`, you must find its respective **second greater** integer.\n\nThe **second greater** integer of `nums[i]` is `nums[j]` such that:\n\n*   `j > i`\n*   `nums[j] > nums[i]`\n*   There exists **exactly one** index `k` such that `nums[k] > nums[i]` and `i < k < j`.\n\nIf there is no such `nums[j]`, the second greater integer is considered to be `-1`.\n\n*   For example, in the array `[1, 2, 4, 3]`, the second greater integer of `1` is `4`, `2` is `3`, and that of `3` and `4` is `-1`.\n\nReturn _an integer array_ `answer`_, where_ `answer[i]` _is the second greater integer of_ `nums[i]`_._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,0,9,6\\]\n**Output:** \\[9,6,6,-1,-1\\]\n**Explanation:**\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return \\[9,6,6,-1,-1\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,3\\]\n**Output:** \\[-1,-1\\]\n**Explanation:**\nWe return \\[-1,-1\\] since neither integer has any integer greater than it."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Stack",
            "Sorting",
            "Heap (Priority Queue)",
            "Monotonic Stack"
        ],
        "example": [
            {
                "input": "[2,4,0,9,6]",
                "output": "[9,6,6,-1,-1]"
            },
            {
                "input": "[3,3]",
                "output": "[-1,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] findSecondGreater(int[] nums) {\n    int n = nums.length;\n    int[] answer = new int[n];\n    Arrays.fill(answer, -1);\n    \n    for (int i = 0; i < n; i++) {\n        int k = -1;\n        for (int j = i + 1; j < n; j++) {\n            if (nums[j] > nums[i]) {\n                if (k == -1) {\n                    k = j;\n                } else {\n                    answer[i] = nums[j];\n                    break;\n                }\n            }\n        }\n    }\n    \n    return answer;\n}\n```\n    \n    1. Initialize an `answer` array of the same length as `nums` with all elements set to -1.\n2. Iterate over each element `i` of `nums`. Initialize a variable `k` to -1.\n3. Iterate over all remaining elements to the right of `i` using another loop with index `j`.\n4. If `nums[j] > nums[i]` and `k == -1`, set `k = j`. If `k != -1`, set `answer[i] = nums[j]` and break the inner loop.\n5. Return the `answer` array.\n    ",
        "python": "\n    ```python\ndef find_second_greater(nums):\n    n = len(nums)\n    answer = [-1] * n\n    for i in range(n):\n        k = -1\n        for j in range(i + 1, n):\n            if nums[j] > nums[i]:\n                if k == -1:\n                    k = j\n                else:\n                    answer[i] = nums[j]\n                    break\n    return answer\n```\n    \n    1. Initialize an `answer` array of the same length as `nums` with all elements set to -1.\n2. Iterate over each element `i` of `nums`. Initialize a variable `k` to -1.\n3. Iterate over all remaining elements to the right of `i` using another loop with index `j`.\n4. If `nums[j] > nums[i]` and `k == -1`, set `k = j`. If `k != -1`, set `answer[i] = nums[j]` and break the inner loop.\n5. Return the `answer` array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findSecondGreater(const vector<int>& nums) {\n    int n = nums.size();\n    vector<int> answer(n, -1);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1, k = -1; j < n; j++) {\n            if (nums[j] > nums[i]) {\n                if (k == -1) {\n                    k = j;\n                } else {\n                    answer[i] = nums[j];\n                    break;\n                }\n            }\n        }\n    }\n    return answer;\n}\n```\n    \n    1. Initialize an `answer` array of the same length as `nums` with all elements set to -1.\n2. Iterate over each element `i` of `nums`. Initialize a variable `k` to -1.\n3. Iterate over all remaining elements to the right of `i` using another loop with index `j`.\n4. If `nums[j] > nums[i]` and `k == -1`, set `k = j`. If `k != -1`, set `answer[i] = nums[j]` and break the inner loop.\n5. Return the `answer` array.\n    ",
        "js": "\n    ```javascript\nfunction findSecondGreater(nums) {\n    let n = nums.length;\n    let answer = new Array(n).fill(-1);\n\n    for (let i = 0; i < n; i++) {\n        let k = -1;\n        for (let j = i + 1; j < n; j++) {\n            if (nums[j] > nums[i]) {\n                if (k === -1) {\n                    k = j;\n                } else {\n                    answer[i] = nums[j];\n                    break;\n                }\n            }\n        }\n    }\n\n    return answer;\n}\n```\n    \n    1. Initialize an `answer` array of the same length as `nums` with all elements set to -1.\n2. Iterate over each element `i` of `nums`. Initialize a variable `k` to -1.\n3. Iterate over all remaining elements to the right of `i` using another loop with index `j`.\n4. If `nums[j] > nums[i]` and `k == -1`, set `k = j`. If `k != -1`, set `answer[i] = nums[j]` and break the inner loop.\n5. Return the `answer` array.\n    "
    },
    {
        "id": 421,
        "title": "Height of Binary Tree After Subtree Removal Queries",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given the `root` of a **binary tree** with `n` nodes. Each node is assigned a unique value from `1` to `n`. You are also given an array `queries` of size `m`.\n\nYou have to perform `m` **independent** queries on the tree where in the `ith` query you do the following:\n\n*   **Remove** the subtree rooted at the node with the value `queries[i]` from the tree. It is **guaranteed** that `queries[i]` will **not** be equal to the value of the root.\n\nReturn _an array_ `answer` _of size_ `m` _where_ `answer[i]` _is the height of the tree after performing the_ `ith` _query_.\n\n**Note**:\n\n*   The queries are independent, so the tree returns to its **initial** state after each query.\n*   The height of a tree is the **number of edges in the longest simple path** from the root to some node in the tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,3,4,2,null,6,5,null,null,null,null,null,7\\], queries = \\[4\\]\n**Output:** \\[2\\]\n**Explanation:** The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -> 3 -> 2).\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,8,9,2,1,3,7,4,6\\], queries = \\[3,2,4,8\\]\n**Output:** \\[3,2,3,2\\]\n**Explanation:** We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3)."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `2 <= n <= 105`\n*   `1 <= Node.val <= n`\n*   All the values in the tree are **unique**.\n*   `m == queries.length`\n*   `1 <= m <= min(n, 104)`\n*   `1 <= queries[i] <= n`\n*   `queries[i] != root.val`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "[1,3,4,2,null,6,5,null,null,null,null,null,7],[4]",
                "output": "[2]"
            },
            {
                "input": "[5,8,9,2,1,3,7,4,6],[3,2,4,8]",
                "output": "[3,2,3,2]"
            }
        ],
        "java": "\n    ```java\n// Definition for a binary tree node.\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public int[] removeSubtrees(TreeNode root, int[] queries) {\n        int[] answer = new int[queries.length];\n        \n        for (int i = 0; i < queries.length; ++i) {\n            removeSubtree(root, queries[i]);\n            answer[i] = findHeight(root);\n        }\n        \n        return answer;\n    }\n    \n    public void removeSubtree(TreeNode node, int val) {\n        if (node == null) return;\n        \n        if (node.left != null && node.left.val == val)\n            node.left = null;\n        else\n            removeSubtree(node.left, val);\n            \n        if (node.right != null && node.right.val == val)\n            node.right = null;\n        else\n            removeSubtree(node.right, val);\n    }\n    \n    public int findHeight(TreeNode node) {\n        if (node == null) return -1;\n        \n        return 1 + Math.max(findHeight(node.left), findHeight(node.right));\n    }\n}\n```\n    \n    The algorithm works as follows:\n1. Iterate through the queries independently - for each query:\n   a. Call the `removeSubtree` function, which searches for the node with the value equal to the current query and sets its reference in the parent node to null.\n   b. Call the `findHeight` function, which calculates the height of the (modified) tree using a recursive approach.\n   c. Add the height of the (modified) tree to the `answer` list/array.\n2. Return the `answer` list/array.\n    ",
        "python": "\n    ```python\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def removeSubtrees(self, root: TreeNode, queries: List[int]) -> List[int]:\n        def removeSubtree(node: TreeNode, val: int):\n            if not node: return\n\n            if node.left and node.left.val == val:\n                node.left = None\n            else:\n                removeSubtree(node.left, val)\n\n            if node.right and node.right.val == val:\n                node.right = None\n            else:\n                removeSubtree(node.right, val)\n\n        def findHeight(node: TreeNode) -> int:\n            if not node: return -1\n\n            return 1 + max(findHeight(node.left), findHeight(node.right))\n\n        answer = []\n        for query in queries:\n            removeSubtree(root, query)\n            answer.append(findHeight(root))\n\n        return answer\n```\n    \n    The algorithm works as follows:\n1. Iterate through the queries independently - for each query:\n   a. Call the `removeSubtree` function, which searches for the node with the value equal to the current query and sets its reference in the parent node to null.\n   b. Call the `findHeight` function, which calculates the height of the (modified) tree using a recursive approach.\n   c. Add the height of the (modified) tree to the `answer` list/array.\n2. Return the `answer` list/array.\n    ",
        "c++": "\n    ```cpp\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    vector<int> removeSubtrees(TreeNode* root, vector<int>& queries) {\n        vector<int> answer(queries.size());\n        \n        for (int i = 0; i < queries.size(); ++i) {\n            removeSubtree(root, queries[i]);\n            answer[i] = findHeight(root);\n        }\n        \n        return answer;\n    }\n    \n    void removeSubtree(TreeNode* node, int val) {\n        if (node == nullptr) return;\n        \n        if (node->left && node->left->val == val)\n            node->left = nullptr;\n        else\n            removeSubtree(node->left, val);\n            \n        if (node->right && node->right->val == val)\n            node->right = nullptr;\n        else\n            removeSubtree(node->right, val);\n    }\n    \n    int findHeight(TreeNode* node) {\n        if (node == nullptr) return -1;\n        \n        return 1 + max(findHeight(node->left), findHeight(node->right));\n    }\n};\n```\n    \n    The algorithm works as follows:\n1. Iterate through the queries independently - for each query:\n   a. Call the `removeSubtree` function, which searches for the node with the value equal to the current query and sets its reference in the parent node to null.\n   b. Call the `findHeight` function, which calculates the height of the (modified) tree using a recursive approach.\n   c. Add the height of the (modified) tree to the `answer` list/array.\n2. Return the `answer` list/array.\n    ",
        "js": "\n    ```javascript\n// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n}\n\n/**\n * @param {TreeNode} root\n * @param {number[]} queries\n * @return {number[]}\n */\nvar removeSubtrees = function(root, queries) {\n    const removeSubtree = (node, val) => {\n        if (!node) return;\n\n        if (node.left && node.left.val === val) {\n            node.left = null;\n        } else {\n            removeSubtree(node.left, val);\n        }\n\n        if (node.right && node.right.val === val) {\n            node.right = null;\n        } else {\n            removeSubtree(node.right, val);\n        }\n    };\n\n    const findHeight = (node) => {\n        if (!node) return -1;\n\n        return 1 + Math.max(findHeight(node.left), findHeight(node.right));\n    };\n\n    const answer = [];\n    for (const query of queries) {\n        removeSubtree(root, query);\n        answer.push(findHeight(root));\n    }\n\n    return answer;\n};\n```\n    \n    The algorithm works as follows:\n1. Iterate through the queries independently - for each query:\n   a. Call the `removeSubtree` function, which searches for the node with the value equal to the current query and sets its reference in the parent node to null.\n   b. Call the `findHeight` function, which calculates the height of the (modified) tree using a recursive approach.\n   c. Add the height of the (modified) tree to the `answer` list/array.\n2. Return the `answer` list/array.\n    "
    },
    {
        "id": 422,
        "title": "Minimum Total Distance Traveled",
        "difficulty": "Hard",
        "content": {
            "problem": "There are some robots and factories on the X-axis. You are given an integer array `robot` where `robot[i]` is the position of the `ith` robot. You are also given a 2D integer array `factory` where `factory[j] = [positionj, limitj]` indicates that `positionj` is the position of the `jth` factory and that the `jth` factory can repair at most `limitj` robots.\n\nThe positions of each robot are **unique**. The positions of each factory are also **unique**. Note that a robot can be **in the same position** as a factory initially.\n\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\n\n**At any moment**, you can set the initial direction of moving for **some** robot. Your target is to minimize the total distance traveled by all the robots.\n\nReturn _the minimum total distance traveled by all the robots_. The test cases are generated such that all the robots can be repaired.\n\n**Note that**\n\n*   All robots move at the same speed.\n*   If two robots move in the same direction, they will never collide.\n*   If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n*   If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n*   If the robot moved from a position `x` to a position `y`, the distance it moved is `|y - x|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** robot = \\[0,4,6\\], factory = \\[\\[2,2\\],\\[6,2\\]\\]\n**Output:** 4\n**Explanation:** As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\n",
                "**Example 2:**\n\n**Input:** robot = \\[1,-1\\], factory = \\[\\[-2,1\\],\\[2,1\\]\\]\n**Output:** 2\n**Explanation:** As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= robot.length, factory.length <= 100`\n*   `factory[j].length == 2`\n*   `-109 <= robot[i], positionj <= 109`\n*   `0 <= limitj <= robot.length`\n*   The input will be generated such that it is always possible to repair every robot.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Sorting"
        ],
        "example": [
            {
                "input": "[0,4,6],[[2,2],[6,2]]",
                "output": "4"
            },
            {
                "input": "[1,-1],[[-2,1],[2,1]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int minTotalDistance(int[] robot, int[][] factory) {\n    Arrays.sort(robot);\n    Arrays.sort(factory, (a, b) -> a[0] - b[0]);\n    \n    int res = 0, idx = 0;\n    for (int[] f : factory) {\n        int limit = f[1];\n        while (limit-- > 0 && idx < robot.length) {\n            res += Math.abs(f[0] - robot[idx]);\n            idx++;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    We sort the `robot` and `factory` arrays in ascending order. We create two variables, `res` to store the result and `idx` to keep track of the current robot index.\n\nWe loop through each factory in the sorted `factory` array. For each factory, we have a nested loop to repair the robots. We decrement the `limit` of the current factory and increment the `idx` pointer. We add the distance from the current factory to the robot to the result.\n\nFinally, we return the result `res` which represents the minimum total distance traveled by all the robots.\n    ",
        "python": "\n    ```python\ndef min_total_distance(robot: List[int], factory: List[List[int]]) -> int:\n    robot.sort()\n    factory.sort()\n\n    res = 0\n    idx = 0\n    for f_pos, f_limit in factory:\n        while f_limit > 0 and idx < len(robot):\n            res += abs(f_pos - robot[idx])\n            idx += 1\n            f_limit -= 1\n    \n    return res\n```\n    \n    We sort the `robot` and `factory` arrays in ascending order. We create two variables, `res` to store the result and `idx` to keep track of the current robot index.\n\nWe loop through each factory in the sorted `factory` array. For each factory, we have a nested loop to repair the robots. We decrement the `limit` of the current factory and increment the `idx` pointer. We add the distance from the current factory to the robot to the result.\n\nFinally, we return the result `res` which represents the minimum total distance traveled by all the robots.\n    ",
        "c++": "\n    ```cpp\nint minTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n    sort(robot.begin(), robot.end());\n    sort(factory.begin(), factory.end());\n    \n    int res = 0, idx = 0;\n    for (const auto& f : factory) {\n        int limit = f[1];\n        while (limit-- > 0 && idx < robot.size()) {\n            res += abs(f[0] - robot[idx]);\n            idx++;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    We sort the `robot` and `factory` arrays in ascending order. We create two variables, `res` to store the result and `idx` to keep track of the current robot index.\n\nWe loop through each factory in the sorted `factory` array. For each factory, we have a nested loop to repair the robots. We decrement the `limit` of the current factory and increment the `idx` pointer. We add the distance from the current factory to the robot to the result.\n\nFinally, we return the result `res` which represents the minimum total distance traveled by all the robots.\n    ",
        "js": "\n    ```javascript\nfunction minTotalDistance(robot, factory) {\n    robot.sort((a, b) => a - b);\n    factory.sort((a, b) => a[0] - b[0]);\n    \n    let res = 0, idx = 0;\n    for (const f of factory) {\n        let limit = f[1];\n        while (limit-- > 0 && idx < robot.length) {\n            res += Math.abs(f[0] - robot[idx]);\n            idx++;\n        }\n    }\n    \n    return res;\n}\n```\n    \n    We sort the `robot` and `factory` arrays in ascending order. We create two variables, `res` to store the result and `idx` to keep track of the current robot index.\n\nWe loop through each factory in the sorted `factory` array. For each factory, we have a nested loop to repair the robots. We decrement the `limit` of the current factory and increment the `idx` pointer. We add the distance from the current factory to the robot to the result.\n\nFinally, we return the result `res` which represents the minimum total distance traveled by all the robots.\n    "
    },
    {
        "id": 423,
        "title": "Split Message Based on Limit",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string, `message`, and a positive integer, `limit`.\n\nYou must **split** `message` into one or more **parts** based on `limit`. Each resulting part should have the suffix `\" \"`, where `\"b \"` is to be **replaced** with the total number of parts and `\"a \"` is to be **replaced** with the index of the part, starting from `1` and going up to `b`. Additionally, the length of each resulting part (including its suffix) should be **equal** to `limit`, except for the last part whose length can be **at most** `limit`.\n\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated **in order**, they should be equal to `message`. Also, the result should contain as few parts as possible.\n\nReturn _the parts_ `message` _would be split into as an array of strings_. If it is impossible to split `message` as required, return _an empty array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** message =  \"this is really a very awesome message \", limit = 9\n**Output:** \\[ \"thi<1/14> \", \"s i<2/14> \", \"s r<3/14> \", \"eal<4/14> \", \"ly <5/14> \", \"a v<6/14> \", \"ery<7/14> \", \" aw<8/14> \", \"eso<9/14> \", \"me<10/14> \", \" m<11/14> \", \"es<12/14> \", \"sa<13/14> \", \"ge<14/14> \"\\]\n**Explanation:**\nThe first 9 parts take 3 characters each from the beginning of message.\nThe next 5 parts take 2 characters each to finish splitting message. \nIn this example, each part, including the last, has length 9. \nIt can be shown it is not possible to split message into less than 14 parts.\n\n",
                "**Example 2:**\n\n**Input:** message =  \"short message \", limit = 15\n**Output:** \\[ \"short mess<1/2> \", \"age<2/2> \"\\]\n**Explanation:**\nUnder the given constraints, the string can be split into two parts: \n- The first part comprises of the first 10 characters, and has a length 15.\n- The next part comprises of the last 3 characters, and has a length 8."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= message.length <= 104`\n*   `message` consists only of lowercase English letters and `' '`.\n*   `1 <= limit <= 104`",
            "follow_up": null
        },
        "tag": [
            "String",
            "Binary Search"
        ],
        "example": [
            {
                "input": "\"thisisreallyaveryawesomemessage\",9",
                "output": "[\"thi<1/14>\",\"si<2/14>\",\"sr<3/14>\",\"eal<4/14>\",\"ly<5/14>\",\"av<6/14>\",\"ery<7/14>\",\"aw<8/14>\",\"eso<9/14>\",\"me<10/14>\",\"m<11/14>\",\"es<12/14>\",\"sa<13/14>\",\"ge<14/14>\"]"
            },
            {
                "input": "\"shortmessage\",15",
                "output": "[\"shortmess<1/2>\",\"age<2/2>\"]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> splitMessage(String message, int limit) {\n    int n = message.length();\n    int a = (limit - 3) * (n / (limit - 3)) - n;\n    int b = n / (limit - 3);\n    if ((n + b + a) % (limit - 2) != 0) \n        return new ArrayList<>();\n    int num_parts = (n + b + a) / (limit - 2);\n    List<String> result = new ArrayList<>();\n    for (int i = 0, k = 1, cnt = 0; i < n || k <= num_parts;) {\n        StringBuilder temp = new StringBuilder();\n        while (cnt < limit - 3) {\n            cnt++;\n            temp.append(message.charAt(i++));\n            if (i == n) break;\n        }\n        cnt = 0;\n        temp.append(k).append(\"/\").append(num_parts).append(\" \");\n        k++;\n        result.add(temp.toString());\n    }\n    return result;\n}\n```\n    \n    The algorithm first calculates the number of parts (`num_parts`) that the message would be divided into. It does so by calculating:\n* `a`: The number of extra characters needed for each part to be of length `limit` (except the last one).\n* `b`: The estimated number of parts calculated as the length of the message divided by `limit - 3`. The `-3` is because of the `<a/b> ` suffix.\n* If `(n + a + b) % (limit - 2) != 0`, it means it is not possible to split the message according to the given condition, so it returns an empty array.\n* Now, it calculates the actual `num_parts` by dividing `(n + a + b)` by `(limit - 2)`.\n\nThen it iterates through the message while keeping track of the current index `i`, current part index `k`, and a counter `cnt`. In each iteration, it creates a temporary string `temp` and fills it with at most `limit - 3` characters from the message. Then it appends the suffix with the current part index and the total number of parts. Finally, it adds the constructed part to the result array.\n\nThis algorithm ensures the message is divided into a minimum number of parts while keeping the length of the parts equal to `limit` except for the last one, which can be at most `limit`.\n    ",
        "python": "\n    ```python\ndef split_message(message: str, limit: int) -> list[str]:\n    n = len(message)\n    a = (limit - 3) * (n // (limit - 3)) - n\n    b = n // (limit - 3)\n    if (n + b + a) % (limit - 2) != 0:\n        return []\n    num_parts = (n + b + a) // (limit - 2)\n    result = []\n    i = k = cnt = 0\n    while i < n or k < num_parts:\n        temp = []\n        while cnt < limit - 3:\n            cnt += 1\n            temp.append(message[i])\n            i += 1\n            if i == n: break\n        cnt = 0\n        temp.append(str(k+1) + \"/\" + str(num_parts) + \" \")\n        k += 1\n        result.append(\"\".join(temp))\n    return result\n```\n    \n    The algorithm first calculates the number of parts (`num_parts`) that the message would be divided into. It does so by calculating:\n* `a`: The number of extra characters needed for each part to be of length `limit` (except the last one).\n* `b`: The estimated number of parts calculated as the length of the message divided by `limit - 3`. The `-3` is because of the `<a/b> ` suffix.\n* If `(n + a + b) % (limit - 2) != 0`, it means it is not possible to split the message according to the given condition, so it returns an empty array.\n* Now, it calculates the actual `num_parts` by dividing `(n + a + b)` by `(limit - 2)`.\n\nThen it iterates through the message while keeping track of the current index `i`, current part index `k`, and a counter `cnt`. In each iteration, it creates a temporary string `temp` and fills it with at most `limit - 3` characters from the message. Then it appends the suffix with the current part index and the total number of parts. Finally, it adds the constructed part to the result array.\n\nThis algorithm ensures the message is divided into a minimum number of parts while keeping the length of the parts equal to `limit` except for the last one, which can be at most `limit`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> splitMessage(string message, int limit) {\n    int n = message.size();\n    int a = (limit - 3) * (n / (limit - 3)) - n;\n    int b = n / (limit - 3);\n    if ((n + b + a) % (limit - 2) != 0) \n        return {};\n    int num_parts = (n + b + a) / (limit - 2);\n    vector<string> result;\n    for (int i = 0, k = 1, cnt = 0; i < n || k <= num_parts;) {\n        string temp;\n        while (cnt < limit - 3) {\n            cnt++;\n            temp += message[i++];\n            if (i == n) break;\n        }\n        cnt = 0;\n        temp += to_string(k) + \"/\" + to_string(num_parts) + \" \";\n        k++;\n        result.push_back(temp);\n    }\n    return result;\n}\n```\n    \n    The algorithm first calculates the number of parts (`num_parts`) that the message would be divided into. It does so by calculating:\n* `a`: The number of extra characters needed for each part to be of length `limit` (except the last one).\n* `b`: The estimated number of parts calculated as the length of the message divided by `limit - 3`. The `-3` is because of the `<a/b> ` suffix.\n* If `(n + a + b) % (limit - 2) != 0`, it means it is not possible to split the message according to the given condition, so it returns an empty array.\n* Now, it calculates the actual `num_parts` by dividing `(n + a + b)` by `(limit - 2)`.\n\nThen it iterates through the message while keeping track of the current index `i`, current part index `k`, and a counter `cnt`. In each iteration, it creates a temporary string `temp` and fills it with at most `limit - 3` characters from the message. Then it appends the suffix with the current part index and the total number of parts. Finally, it adds the constructed part to the result array.\n\nThis algorithm ensures the message is divided into a minimum number of parts while keeping the length of the parts equal to `limit` except for the last one, which can be at most `limit`.\n    ",
        "js": "\n    ```javascript\nfunction splitMessage(message, limit) {\n    let n = message.length;\n    let a = (limit - 3) * (n / (limit - 3)) - n;\n    let b = n / (limit - 3);\n    if ((n + b + a) % (limit - 2) !== 0) \n        return [];\n    let num_parts = (n + b + a) / (limit - 2);\n    let result = [];\n    for (let i = 0, k = 1, cnt = 0; i < n || k <= num_parts;) {\n        let temp = \"\";\n        while (cnt < limit - 3) {\n            cnt++;\n            temp += message[i++];\n            if (i === n) break;\n        }\n        cnt = 0;\n        temp += `${k}/${num_parts} `;\n        k++;\n        result.push(temp);\n    }\n    return result;\n}\n```\n    \n    The algorithm first calculates the number of parts (`num_parts`) that the message would be divided into. It does so by calculating:\n* `a`: The number of extra characters needed for each part to be of length `limit` (except the last one).\n* `b`: The estimated number of parts calculated as the length of the message divided by `limit - 3`. The `-3` is because of the `<a/b> ` suffix.\n* If `(n + a + b) % (limit - 2) != 0`, it means it is not possible to split the message according to the given condition, so it returns an empty array.\n* Now, it calculates the actual `num_parts` by dividing `(n + a + b)` by `(limit - 2)`.\n\nThen it iterates through the message while keeping track of the current index `i`, current part index `k`, and a counter `cnt`. In each iteration, it creates a temporary string `temp` and fills it with at most `limit - 3` characters from the message. Then it appends the suffix with the current part index and the total number of parts. Finally, it adds the constructed part to the result array.\n\nThis algorithm ensures the message is divided into a minimum number of parts while keeping the length of the parts equal to `limit` except for the last one, which can be at most `limit`.\n    "
    },
    {
        "id": 424,
        "title": "Maximum Number of Non-overlapping Palindrome Substrings",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` and a **positive** integer `k`.\n\nSelect a set of **non-overlapping** substrings from the string `s` that satisfy the following conditions:\n\n*   The **length** of each substring is **at least** `k`.\n*   Each substring is a **palindrome**.\n\nReturn _the **maximum** number of substrings in an optimal selection_.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abaccdbbd \", k = 3\n**Output:** 2\n**Explanation:** We can select the substrings underlined in s =  \"**aba**cc**dbbd** \". Both  \"aba \" and  \"dbbd \" are palindromes and have a length of at least k = 3.\nIt can be shown that we cannot find a selection with more than two valid substrings.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"adbcda \", k = 2\n**Output:** 0\n**Explanation:** There is no palindrome substring of length at least 2 in the string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= s.length <= 2000`\n*   `s` consists of lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Dynamic Programming",
            "Greedy"
        ],
        "example": [
            {
                "input": "\"abaccdbbd\",3",
                "output": "2"
            },
            {
                "input": "\"adbcda\",2",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maxPalindromesSubstrings(String s, int k) {\n    int n = s.length();\n    if (n < k) {\n        return 0;\n    }\n    int count = 0;\n    boolean[][] dp = new boolean[n][n];\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j < n; j++) {\n            if (i == j) {\n                dp[i][j] = true;\n            } else if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j] = i + 1 > j - 1 || dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = false;\n            }\n            if (j - i + 1 >= k && dp[i][j]) {\n                count++;\n                i = j;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we can use dynamic programming. We use a 2D boolean array `dp`, where `dp[i][j]` will be `true` if the string from index `i` to `j` is a palindrome.\n\nThe main idea of the algorithm is to iterate through the string 's' and for each position, we find the longest palindrome substring starting at that position. If it is longer than or equal to length 'k' we count it and move to the next non-overlapping position. Otherwise, we continue to check the next position.\n\nHere is the procedure for each programming language:\n\n1. If `s.length < k`, there cannot be a palindrome substring of length at least k, and we return 0.\n2. Initialize a 2D boolean `dp` array with dimensions `n x n`.\n3. Loop through the string `s` in reverse order (from end to start) using index `i`. This allows us to find the longest palindrome substring starting at the current position.\n4. For each `i`, find the longest palindrome substring starting at that position using another loop with an index `j`. Here, we continuously check if the substring from position `i` to `j` is a palindrome using our `dp` array.\n5. If the current palindrome substring length (`j - i + 1`) is at least `k` and `dp[i][j]` is `true`, increment the count, and update i to j to avoid overlapping substrings.\n6. Return count.\n\nThis approach has a time complexity of O(n^2) and space complexity of O(n^2), where n is the length of string s.\n    ",
        "python": "\n    ```python\ndef maxPalindromesSubstrings(s, k):\n    n = len(s)\n    if n < k:\n        return 0\n    count = 0\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = True\n            elif s[i] == s[j]:\n                dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]\n            else:\n                dp[i][j] = False\n            if j - i + 1 >= k and dp[i][j]:\n                count += 1\n                i = j\n                break\n    return count\n```\n    \n    To solve this problem, we can use dynamic programming. We use a 2D boolean array `dp`, where `dp[i][j]` will be `true` if the string from index `i` to `j` is a palindrome.\n\nThe main idea of the algorithm is to iterate through the string 's' and for each position, we find the longest palindrome substring starting at that position. If it is longer than or equal to length 'k' we count it and move to the next non-overlapping position. Otherwise, we continue to check the next position.\n\nHere is the procedure for each programming language:\n\n1. If `s.length < k`, there cannot be a palindrome substring of length at least k, and we return 0.\n2. Initialize a 2D boolean `dp` array with dimensions `n x n`.\n3. Loop through the string `s` in reverse order (from end to start) using index `i`. This allows us to find the longest palindrome substring starting at the current position.\n4. For each `i`, find the longest palindrome substring starting at that position using another loop with an index `j`. Here, we continuously check if the substring from position `i` to `j` is a palindrome using our `dp` array.\n5. If the current palindrome substring length (`j - i + 1`) is at least `k` and `dp[i][j]` is `true`, increment the count, and update i to j to avoid overlapping substrings.\n6. Return count.\n\nThis approach has a time complexity of O(n^2) and space complexity of O(n^2), where n is the length of string s.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint maxPalindromesSubstrings(std::string s, int k) {\n    int n = s.size();\n    if (n < k) {\n        return 0;\n    }\n    int count = 0;\n    std::vector<std::vector<bool>> dp(n, std::vector<bool>(n, false));\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j < n; j++) {\n            if (i == j) {\n                dp[i][j] = true;\n            } else if (s[i] == s[j]) {\n                dp[i][j] = i + 1 > j - 1 || dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = false;\n            }\n            if (j - i + 1 >= k && dp[i][j]) {\n                count++;\n                i = j;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we can use dynamic programming. We use a 2D boolean array `dp`, where `dp[i][j]` will be `true` if the string from index `i` to `j` is a palindrome.\n\nThe main idea of the algorithm is to iterate through the string 's' and for each position, we find the longest palindrome substring starting at that position. If it is longer than or equal to length 'k' we count it and move to the next non-overlapping position. Otherwise, we continue to check the next position.\n\nHere is the procedure for each programming language:\n\n1. If `s.length < k`, there cannot be a palindrome substring of length at least k, and we return 0.\n2. Initialize a 2D boolean `dp` array with dimensions `n x n`.\n3. Loop through the string `s` in reverse order (from end to start) using index `i`. This allows us to find the longest palindrome substring starting at the current position.\n4. For each `i`, find the longest palindrome substring starting at that position using another loop with an index `j`. Here, we continuously check if the substring from position `i` to `j` is a palindrome using our `dp` array.\n5. If the current palindrome substring length (`j - i + 1`) is at least `k` and `dp[i][j]` is `true`, increment the count, and update i to j to avoid overlapping substrings.\n6. Return count.\n\nThis approach has a time complexity of O(n^2) and space complexity of O(n^2), where n is the length of string s.\n    ",
        "js": "\n    ```javascript\nfunction maxPalindromesSubstrings(s, k) {\n    const n = s.length;\n    if (n < k) {\n        return 0;\n    }\n    let count = 0;\n    const dp = new Array(n).fill(null).map(() => new Array(n).fill(false));\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i; j < n; j++) {\n            if (i === j) {\n                dp[i][j] = true;\n            } else if (s[i] === s[j]) {\n                dp[i][j] = i + 1 > j - 1 || dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = false;\n            }\n            if (j - i + 1 >= k && dp[i][j]) {\n                count++;\n                i = j;\n                break;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we can use dynamic programming. We use a 2D boolean array `dp`, where `dp[i][j]` will be `true` if the string from index `i` to `j` is a palindrome.\n\nThe main idea of the algorithm is to iterate through the string 's' and for each position, we find the longest palindrome substring starting at that position. If it is longer than or equal to length 'k' we count it and move to the next non-overlapping position. Otherwise, we continue to check the next position.\n\nHere is the procedure for each programming language:\n\n1. If `s.length < k`, there cannot be a palindrome substring of length at least k, and we return 0.\n2. Initialize a 2D boolean `dp` array with dimensions `n x n`.\n3. Loop through the string `s` in reverse order (from end to start) using index `i`. This allows us to find the longest palindrome substring starting at the current position.\n4. For each `i`, find the longest palindrome substring starting at that position using another loop with an index `j`. Here, we continuously check if the substring from position `i` to `j` is a palindrome using our `dp` array.\n5. If the current palindrome substring length (`j - i + 1`) is at least `k` and `dp[i][j]` is `true`, increment the count, and update i to j to avoid overlapping substrings.\n6. Return count.\n\nThis approach has a time complexity of O(n^2) and space complexity of O(n^2), where n is the length of string s.\n    "
    },
    {
        "id": 425,
        "title": "Number of Beautiful Partitions",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s` that consists of the digits `'1'` to `'9'` and two integers `k` and `minLength`.\n\nA partition of `s` is called **beautiful** if:\n\n*   `s` is partitioned into `k` non-intersecting substrings.\n*   Each substring has a length of **at least** `minLength`.\n*   Each substring starts with a **prime** digit and ends with a **non-prime** digit. Prime digits are `'2'`, `'3'`, `'5'`, and `'7'`, and the rest of the digits are non-prime.\n\nReturn _the number of **beautiful** partitions of_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **substring** is a contiguous sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"23542185131 \", k = 3, minLength = 2\n**Output:** 3\n**Explanation:** There exists three ways to create a beautiful partition:\n \"2354 | 218 | 5131 \"\n \"2354 | 21851 | 31 \"\n \"2354218 | 51 | 31 \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"23542185131 \", k = 3, minLength = 3\n**Output:** 1\n**Explanation:** There exists one way to create a beautiful partition:  \"2354 | 218 | 5131 \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"3312958 \", k = 3, minLength = 1\n**Output:** 1\n**Explanation:** There exists one way to create a beautiful partition:  \"331 | 29 | 58 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k, minLength <= s.length <= 1000`\n*   `s` consists of the digits `'1'` to `'9'`.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"23542185131\",3,2",
                "output": "3"
            },
            {
                "input": "\"23542185131\",3,3",
                "output": "1"
            },
            {
                "input": "\"3312958\",3,1",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n    public int numBeautifulPartitions(String s, int k, int minLength) {\n        final int MOD = 1000000007;\n        Set<Character> primes = new HashSet<>();\n        primes.add('2');\n        primes.add('3');\n        primes.add('5');\n        primes.add('7');\n        \n        int n = s.length();\n        int[][] dp = new int[n + 1][k + 1];\n        dp[0][0] = 1;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= k; ++j) {\n                for (int l = minLength; l <= i && i - l >= j - 1; ++l) {\n                    if (primes.contains(s.charAt(i - l)) && !primes.contains(s.charAt(i - 1))) {\n                        dp[i][j] += dp[i - l][j - 1];\n                        if (dp[i][j] >= MOD) dp[i][j] -= MOD;\n                    }\n                }\n            }\n        }\n\n        return dp[n][k];\n    }\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. We have `dp[i][j]` representing the number of beautiful partitions for the first `i` characters of the string `s` into `j` substrings. From there, we iterate through the string and its possible partitions. For each partition, we check if the current and the previous characters meet the prime and non-prime requirements.\n\nIf the current partition is valid, we add the number of ways to create a beautiful partition using the previous partition (dp[i - l][j - 1]) to the current partition count (dp[i][j]). We also apply the modulo operation to keep the result within the range.\n\nAt the end, `dp[n][k]` will store the number of beautiful partitions for the entire string with `k` substrings.\n    ",
        "python": "\n    ```python\ndef numBeautifulPartitions(s: str, k: int, minLength: int) -> int:\n    MOD = 10**9 + 7\n    primes = {'2', '3', '5', '7'}\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for l in range(minLength, i + 1):\n                if i - l >= j - 1 and s[i - l] in primes and s[i - 1] not in primes:\n                    dp[i][j] += dp[i - l][j - 1]\n                    if dp[i][j] >= MOD:\n                        dp[i][j] -= MOD\n                        \n    return dp[n][k]\n```\n\n    \n    We use a dynamic programming approach to solve this problem. We have `dp[i][j]` representing the number of beautiful partitions for the first `i` characters of the string `s` into `j` substrings. From there, we iterate through the string and its possible partitions. For each partition, we check if the current and the previous characters meet the prime and non-prime requirements.\n\nIf the current partition is valid, we add the number of ways to create a beautiful partition using the previous partition (dp[i - l][j - 1]) to the current partition count (dp[i][j]). We also apply the modulo operation to keep the result within the range.\n\nAt the end, `dp[n][k]` will store the number of beautiful partitions for the entire string with `k` substrings.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_set>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint numBeautifulPartitions(const string& s, int k, int minLength) {\n    const int MOD = 1e9 + 7;\n    unordered_set<char> primes = {'2', '3', '5', '7'};\n    int n = s.length();\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            for (int l = minLength; l <= i && i - l >= j - 1; ++l) {\n                if (primes.count(s[i - l]) && !primes.count(s[i - 1])) {\n                    dp[i][j] += dp[i - l][j - 1];\n                    if (dp[i][j] >= MOD) dp[i][j] -= MOD;\n                }\n            }\n        }\n    }\n\n    return dp[n][k];\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. We have `dp[i][j]` representing the number of beautiful partitions for the first `i` characters of the string `s` into `j` substrings. From there, we iterate through the string and its possible partitions. For each partition, we check if the current and the previous characters meet the prime and non-prime requirements.\n\nIf the current partition is valid, we add the number of ways to create a beautiful partition using the previous partition (dp[i - l][j - 1]) to the current partition count (dp[i][j]). We also apply the modulo operation to keep the result within the range.\n\nAt the end, `dp[n][k]` will store the number of beautiful partitions for the entire string with `k` substrings.\n    ",
        "js": "\n    ```javascript\nfunction numBeautifulPartitions(s, k, minLength) {\n    const MOD = 1e9 + 7;\n    const primes = new Set(['2', '3', '5', '7']);\n    const n = s.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= k; j++) {\n            for (let l = minLength; l <= i && i - l >= j - 1; l++) {\n                if (primes.has(s[i - l]) && !primes.has(s[i - 1])) {\n                    dp[i][j] += dp[i - l][j - 1];\n                    if (dp[i][j] >= MOD) dp[i][j] -= MOD;\n                }\n            }\n        }\n    }\n\n    return dp[n][k];\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. We have `dp[i][j]` representing the number of beautiful partitions for the first `i` characters of the string `s` into `j` substrings. From there, we iterate through the string and its possible partitions. For each partition, we check if the current and the previous characters meet the prime and non-prime requirements.\n\nIf the current partition is valid, we add the number of ways to create a beautiful partition using the previous partition (dp[i - l][j - 1]) to the current partition count (dp[i][j]). We also apply the modulo operation to keep the result within the range.\n\nAt the end, `dp[n][k]` will store the number of beautiful partitions for the entire string with `k` substrings.\n    "
    },
    {
        "id": 426,
        "title": "Count Palindromic Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string of digits `s`, return _the number of **palindromic subsequences** of_ `s` _having length_ `5`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Note:**\n\n*   A string is **palindromic** if it reads the same forward and backward.\n*   A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"103301 \"\n**Output:** 2\n**Explanation:** \nThere are 6 possible subsequences of length 5:  \"10330 \", \"10331 \", \"10301 \", \"10301 \", \"13301 \", \"03301 \". \nTwo of them (both equal to  \"10301 \") are palindromic.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"0000000 \"\n**Output:** 21\n**Explanation:** All 21 subsequences are  \"00000 \", which is palindromic.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"9999900000 \"\n**Output:** 2\n**Explanation:** The only two palindromic subsequences are  \"99999 \" and  \"00000 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of digits.",
            "follow_up": null
        },
        "tag": [
            "String",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "\"103301\"",
                "output": "2"
            },
            {
                "input": "\"0000000\"",
                "output": "21"
            },
            {
                "input": "\"9999900000\"",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int palindromeSubsequence(String s) {\n    int n = s.length();\n    final int mod = 1000000007;\n    int[][] dp = new int[10][n];\n    for (int i = 0; i < n; ++i) dp[s.charAt(i) - '0'][i] = 1;\n    for (int len = 1; len <= 4; ++len) {\n        for (int d = 0; d < 10; ++d) {\n            for (int i = 0, j = len; j < n; ++i, ++j) {\n                dp[d][j] = (dp[d][j - 1] + (s.charAt(j) - '0' == d ? 1 : 0)) % mod;\n            }\n        }\n    }\n    long ans = 0;\n    for (int d1 = 0; d1 < 10; ++d1) {\n        for (int d2 = 0; d2 < 10; ++d2) {\n            ans += ((long) dp[d1][n - 5] * dp[d2][n - 1]) % mod;\n        }\n    }\n    return (int) (ans % mod);\n}\n```\n    \n    The algorithm uses dynamic programming to compute the number of palindromic subsequences of length 5.\n1. Create a 10xN array `dp`, where `N` is the length of the input string `s`. Initialize the first row of `dp` with 1 for the same digit as the input string.\n2. For each length from 1 to 4, iterate through all digits (0 to 9) and calculate the number of subsequences for each digit by checking if the digit at the current position is the same as the one in the input string. Update the `dp` array accordingly.\n3. Finally, calculate the total number of palindromic subsequences of length 5 by multiplying the number of subsequences of the same digit on the left and right sides and summing them up for all possible pairs of digits. The result is returned modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef palindrome_subsequence(s):\n    n = len(s)\n    mod = 1000000007\n    dp = [[0] * n for _ in range(10)]\n    for i in range(n): dp[int(s[i])][i] = 1\n    for len_ in range(1, 5):\n        for d in range(10):\n            for i, j in zip(range(n - len_), range(len_, n)):\n                dp[d][j] = (dp[d][j - 1] + (1 if s[j] == str(d) else 0)) % mod\n    ans = 0\n    for d1 in range(10):\n        for d2 in range(10):\n            ans += dp[d1][n - 5] * dp[d2][n - 1] % mod\n    return ans % mod\n```\n    \n    The algorithm uses dynamic programming to compute the number of palindromic subsequences of length 5.\n1. Create a 10xN array `dp`, where `N` is the length of the input string `s`. Initialize the first row of `dp` with 1 for the same digit as the input string.\n2. For each length from 1 to 4, iterate through all digits (0 to 9) and calculate the number of subsequences for each digit by checking if the digit at the current position is the same as the one in the input string. Update the `dp` array accordingly.\n3. Finally, calculate the total number of palindromic subsequences of length 5 by multiplying the number of subsequences of the same digit on the left and right sides and summing them up for all possible pairs of digits. The result is returned modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\nint PalindromeSubsequence(string s, int mod) {\n    int n = s.size();\n    const int mod = 1000000007;\n    vector<vector<int>> dp(10, vector<int>(n, 0));\n    for (int i = 0; i < n; ++i) dp[s[i] - '0'][i] = 1;\n    for (int len = 1; len <= 4; ++len) {\n        for (int d = 0; d < 10; ++d) {\n            for (int i = 0, j = len; j < n; ++i, ++j) {\n                dp[d][j] = (dp[d][j - 1] + (s[j] - '0' == d)) % mod;\n            }\n        }\n    }\n    long long ans = 0;\n    for (int d1 = 0; d1 < 10; ++d1) {\n        for (int d2 = 0; d2 < 10; ++d2) {\n            ans += (1LL * dp[d1][n - 5] * dp[d2][n - 1]) % mod;\n        }\n    }\n    return ans % mod;\n}\n```\n    \n    The algorithm uses dynamic programming to compute the number of palindromic subsequences of length 5.\n1. Create a 10xN array `dp`, where `N` is the length of the input string `s`. Initialize the first row of `dp` with 1 for the same digit as the input string.\n2. For each length from 1 to 4, iterate through all digits (0 to 9) and calculate the number of subsequences for each digit by checking if the digit at the current position is the same as the one in the input string. Update the `dp` array accordingly.\n3. Finally, calculate the total number of palindromic subsequences of length 5 by multiplying the number of subsequences of the same digit on the left and right sides and summing them up for all possible pairs of digits. The result is returned modulo 10^9 + 7.\n    ",
        "js": "\n    ```javascript\nfunction palindromeSubsequence(s) {\n    const n = s.length;\n    const mod = 1000000007;\n    const dp = Array.from({length: 10}, () => new Array(n).fill(0));\n    for (let i = 0; i < n; ++i) dp[parseInt(s[i])][i] = 1;\n    for (let len = 1; len <= 4; ++len) {\n        for (let d = 0; d < 10; ++d) {\n            for (let i = 0, j = len; j < n; ++i, ++j) {\n                dp[d][j] = (dp[d][j - 1] + (parseInt(s[j]) === d ? 1 : 0)) % mod;\n            }\n        }\n    }\n    let ans = 0;\n    for (let d1 = 0; d1 < 10; ++d1) {\n        for (let d2 = 0; d2 < 10; ++d2) {\n            ans = (ans + dp[d1][n - 5] * dp[d2][n - 1]) % mod;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses dynamic programming to compute the number of palindromic subsequences of length 5.\n1. Create a 10xN array `dp`, where `N` is the length of the input string `s`. Initialize the first row of `dp` with 1 for the same digit as the input string.\n2. For each length from 1 to 4, iterate through all digits (0 to 9) and calculate the number of subsequences for each digit by checking if the digit at the current position is the same as the one in the input string. Update the `dp` array accordingly.\n3. Finally, calculate the total number of palindromic subsequences of length 5 by multiplying the number of subsequences of the same digit on the left and right sides and summing them up for all possible pairs of digits. The result is returned modulo 10^9 + 7.\n    "
    },
    {
        "id": 427,
        "title": "Count Subarrays With Median K",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums` of size `n` consisting of **distinct** integers from `1` to `n` and a positive integer `k`.\n\nReturn _the number of non-empty subarrays in_ `nums` _that have a **median** equal to_ `k`.\n\n**Note**:\n\n*   The median of an array is the **middle** element after sorting the array in **ascending** order. If the array is of even length, the median is the **left** middle element.\n    *   For example, the median of `[2,3,1,4]` is `2`, and the median of `[8,4,3,5,1]` is `4`.\n*   A subarray is a contiguous part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,1,4,5\\], k = 4\n**Output:** 3\n**Explanation:** The subarrays that have a median equal to 4 are: \\[4\\], \\[4,5\\] and \\[1,4,5\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,1\\], k = 3\n**Output:** 1\n**Explanation:** \\[3\\] is the only subarray that has a median equal to 3."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i], k <= n`\n*   The integers in `nums` are distinct.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[3,2,1,4,5],4",
                "output": "3"
            },
            {
                "input": "[2,3,1],3",
                "output": "1"
            }
        ],
        "java": "\n    ```java\nint countSubarraysWithMedian(int[] nums, int k) {\n    int ans = 0;\n    for (int left = 0; left < nums.length; ++left) {\n        int count = 0;\n        List<Integer> subarray = new ArrayList<>();\n        for (int right = left; right < nums.length; ++right) {\n            count += (nums[right] == k) ? 1 : 0;\n            int index = Collections.binarySearch(subarray, nums[right]);\n            index = index >= 0 ? index : ~index;\n            subarray.add(index, nums[right]);\n            if (subarray.size() % 2 == 1 && subarray.get(subarray.size() / 2) == k) {\n                ans += count;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm iterates over all possible subarrays of the input array `nums`. For each subarray, it maintains a sorted version of the subarray called `subarray`. \n\nAt every step, if the median of the subarray is equal to `k`, it increments the count of subarrays that meet the desired condition.\n\nTo maintain the sorted subarray, it leverages binary search for inserting the right-end element at its correct position whenever a new element is added. This ensures that the time complexity is optimal for the inner loop, resulting in an overall time complexity of O(n^2 * log(n)).\n\nSince we only need the count of such subarrays, the algorithm also employs a separate variable, `count`, to store the occurrences of `k` in the subarray.\n\nFinally, it returns the total count.\n    ",
        "python": "\n    ```python\ndef count_subarrays_with_median(nums, k):\n    ans = 0\n    for left in range(len(nums)):\n        count = 0\n        subarray = []\n        for right in range(left, len(nums)):\n            count += nums[right] == k\n            subarray.insert((nums[right], nums[right]), nums[right:index + 1])\n            if len(subarray) % 2 and subarray[len(subarray) // 2] == k:\n                ans += count\n    return ans\n```\n    \n    The algorithm iterates over all possible subarrays of the input array `nums`. For each subarray, it maintains a sorted version of the subarray called `subarray`. \n\nAt every step, if the median of the subarray is equal to `k`, it increments the count of subarrays that meet the desired condition.\n\nTo maintain the sorted subarray, it leverages binary search for inserting the right-end element at its correct position whenever a new element is added. This ensures that the time complexity is optimal for the inner loop, resulting in an overall time complexity of O(n^2 * log(n)).\n\nSince we only need the count of such subarrays, the algorithm also employs a separate variable, `count`, to store the occurrences of `k` in the subarray.\n\nFinally, it returns the total count.\n    ",
        "c++": "\n    ```cpp\nint countSubarraysWithMedian(std::vector<int>& nums, int k) {\n    int ans = 0;\n    for (int left = 0; left < nums.size(); ++left) {\n        int count = 0;\n        std::vector<int> subarray;\n        for (int right = left; right < nums.size(); ++right) {\n            count += (nums[right] == k);\n            subarray.insert(lower_bound(subarray.begin(), subarray.end(), nums[right]), nums[right]);\n            if ((subarray.size() % 2 == 1) && (subarray[subarray.size() / 2] == k)) {\n                ans += count;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm iterates over all possible subarrays of the input array `nums`. For each subarray, it maintains a sorted version of the subarray called `subarray`. \n\nAt every step, if the median of the subarray is equal to `k`, it increments the count of subarrays that meet the desired condition.\n\nTo maintain the sorted subarray, it leverages binary search for inserting the right-end element at its correct position whenever a new element is added. This ensures that the time complexity is optimal for the inner loop, resulting in an overall time complexity of O(n^2 * log(n)).\n\nSince we only need the count of such subarrays, the algorithm also employs a separate variable, `count`, to store the occurrences of `k` in the subarray.\n\nFinally, it returns the total count.\n    ",
        "js": "\n    ```javascript\nfunction countSubarraysWithMedian(nums, k) {\n    let ans = 0;\n    for (let left = 0; left < nums.length; ++left) {\n        let count = 0;\n        let subarray = [];\n        for (let right = left; right < nums.length; ++right) {\n            count += (nums[right] === k) ? 1 : 0;\n            let index = subarray.findIndex(x => x >= nums[right]);\n            index = index >= 0 ? index : subarray.length;\n            subarray.splice(index, 0, nums[right]);\n            if (subarray.length % 2 === 1 && subarray[Math.floor(subarray.length / 2)] === k) {\n                ans += count;\n            }\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm iterates over all possible subarrays of the input array `nums`. For each subarray, it maintains a sorted version of the subarray called `subarray`. \n\nAt every step, if the median of the subarray is equal to `k`, it increments the count of subarrays that meet the desired condition.\n\nTo maintain the sorted subarray, it leverages binary search for inserting the right-end element at its correct position whenever a new element is added. This ensures that the time complexity is optimal for the inner loop, resulting in an overall time complexity of O(n^2 * log(n)).\n\nSince we only need the count of such subarrays, the algorithm also employs a separate variable, `count`, to store the occurrences of `k` in the subarray.\n\nFinally, it returns the total count.\n    "
    },
    {
        "id": 428,
        "title": "Divide Nodes Into the Maximum Number of Groups",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a positive integer `n` representing the number of nodes in an **undirected** graph. The nodes are labeled from `1` to `n`.\n\nYou are also given a 2D integer array `edges`, where `edges[i] = [ai, bi]` indicates that there is a **bidirectional** edge between nodes `ai` and `bi`. **Notice** that the given graph may be disconnected.\n\nDivide the nodes of the graph into `m` groups (**1-indexed**) such that:\n\n*   Each node in the graph belongs to exactly one group.\n*   For every pair of nodes in the graph that are connected by an edge `[ai, bi]`, if `ai` belongs to the group with index `x`, and `bi` belongs to the group with index `y`, then `|y - x| = 1`.\n\nReturn _the maximum number of groups (i.e., maximum_ `m`_) into which you can divide the nodes_. Return `-1` _if it is impossible to group the nodes with the given conditions_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[1,2\\],\\[1,4\\],\\[1,5\\],\\[2,6\\],\\[2,3\\],\\[4,6\\]\\]\n**Output:** 4\n**Explanation:** As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1\n**Explanation:** If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= edges.length <= 104`\n*   `edges[i].length == 2`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   There is at most one edge between any pair of vertices.",
            "follow_up": null
        },
        "tag": [
            "Breadth-First Search",
            "Union Find",
            "Graph"
        ],
        "example": [
            {
                "input": "6,[[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]",
                "output": "4"
            },
            {
                "input": "3,[[1,2],[2,3],[3,1]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int maxGroups(int n, int[][] edges) {\n    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\n    int[] color = new int[n + 1];\n\n    for (int i = 0; i <= n; ++i) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n\n    int max_group = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (color[i] == 0) {\n            Queue<Integer> q = new LinkedList<>();\n            q.add(i);\n            color[i] = 1;\n            while (!q.isEmpty()) {\n                int node = q.poll();\n                max_group = Math.max(max_group, color[node]);\n                for (int neighbor : graph.get(node)) {\n                    if (color[neighbor] == 0) {\n                        color[neighbor] = color[node] + 1;\n                        q.add(neighbor);\n                    } else if (color[neighbor] == color[node]) {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return max_group;\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal to check and assign the group/color of each node. For each uncolored node, we start a new BFS traversal and assign a color to it. As we traverse the graph, we enqueue its neighbors and assign the neighboring node `color[node] + 1`. This will ensure that neighboring nodes will have a difference of 1 in their colors/groups. If we encounter a neighboring node that has the same color as the current node, then it's not possible to create a grouping that satisfies the conditions, so we return -1. The maximum color/group number encountered during the traversal is returned as the result.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict, deque\n\ndef maxGroups(n, edges):\n    graph = defaultdict(list)\n    color = [0] * (n + 1)\n\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    max_group = 0\n    for i in range(1, n + 1):\n        if color[i] == 0:\n            q = deque([i])\n            color[i] = 1\n            while q:\n                node = q.popleft()\n                max_group = max(max_group, color[node])\n                for neighbor in graph[node]:\n                    if color[neighbor] == 0:\n                        color[neighbor] = color[node] + 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return -1\n                        \n    return max_group\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal to check and assign the group/color of each node. For each uncolored node, we start a new BFS traversal and assign a color to it. As we traverse the graph, we enqueue its neighbors and assign the neighboring node `color[node] + 1`. This will ensure that neighboring nodes will have a difference of 1 in their colors/groups. If we encounter a neighboring node that has the same color as the current node, then it's not possible to create a grouping that satisfies the conditions, so we return -1. The maximum color/group number encountered during the traversal is returned as the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nint maxGroups(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> graph(n + 1);\n    std::vector<int> color(n + 1, 0);\n\n    for (auto& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n\n    int max_group = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (color[i] == 0) {\n            std::queue<int> q;\n            q.push(i);\n            color[i] = 1;\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                max_group = std::max(max_group, color[node]);\n                for (int neighbor : graph[node]) {\n                    if (color[neighbor] == 0) {\n                        color[neighbor] = color[node] + 1;\n                        q.push(neighbor);\n                    } else if (color[neighbor] == color[node]) {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return max_group;\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal to check and assign the group/color of each node. For each uncolored node, we start a new BFS traversal and assign a color to it. As we traverse the graph, we enqueue its neighbors and assign the neighboring node `color[node] + 1`. This will ensure that neighboring nodes will have a difference of 1 in their colors/groups. If we encounter a neighboring node that has the same color as the current node, then it's not possible to create a grouping that satisfies the conditions, so we return -1. The maximum color/group number encountered during the traversal is returned as the result.\n    ",
        "js": "\n    ```javascript\nfunction maxGroups(n, edges) {\n    const graph = new Map();\n    const color = new Array(n + 1).fill(0);\n\n    for (const edge of edges) {\n        if (!graph.has(edge[0])) {\n            graph.set(edge[0], []);\n        }\n        if (!graph.has(edge[1])) {\n            graph.set(edge[1], []);\n        }\n        graph.get(edge[0]).push(edge[1]);\n        graph.get(edge[1]).push(edge[0]);\n    }\n\n    let max_group = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0) {\n            const q = [i];\n            color[i] = 1;\n            while(q.length) {\n                const node = q.shift();\n                max_group = Math.max(max_group, color[node]);\n                for (const neighbor of graph.get(node) || []) {\n                    if (color[neighbor] === 0) {\n                        color[neighbor] = color[node] + 1;\n                        q.push(neighbor);\n                    } else if (color[neighbor] === color[node]) {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    return max_group;\n}\n```\n\n    \n    The algorithm uses a Breadth-First Search (BFS) traversal to check and assign the group/color of each node. For each uncolored node, we start a new BFS traversal and assign a color to it. As we traverse the graph, we enqueue its neighbors and assign the neighboring node `color[node] + 1`. This will ensure that neighboring nodes will have a difference of 1 in their colors/groups. If we encounter a neighboring node that has the same color as the current node, then it's not possible to create a grouping that satisfies the conditions, so we return -1. The maximum color/group number encountered during the traversal is returned as the result.\n    "
    },
    {
        "id": 429,
        "title": "Minimum Total Cost to Make Arrays Unequal",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** integer arrays `nums1` and `nums2`, of equal length `n`.\n\nIn one operation, you can swap the values of any two indices of `nums1`. The **cost** of this operation is the **sum** of the indices.\n\nFind the **minimum** total cost of performing the given operation **any** number of times such that `nums1[i] != nums2[i]` for all `0 <= i <= n - 1` after performing all the operations.\n\nReturn _the **minimum total cost** such that_ `nums1` and `nums2` _satisfy the above condition_. In case it is not possible, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[1,2,3,4,5\\]\n**Output:** 10\n**Explanation:** \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = \\[4,2,3,1,5\\]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = \\[4,3,2,1,5\\].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =\\[5,3,2,1,4\\].\nWe can see that for each index i, nums1\\[i\\] != nums2\\[i\\]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[2,2,2,1,3\\], nums2 = \\[1,2,2,3,3\\]\n**Output:** 10\n**Explanation:** \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = \\[2,2,1,2,3\\].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = \\[2,3,1,2,2\\].\nThe total cost needed here is 10, which is the minimum possible.\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[1,2,2\\], nums2 = \\[1,2,2\\]\n**Output:** -1\n**Explanation:** \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `1 <= nums1[i], nums2[i] <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Greedy",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,2,3,4,5],[1,2,3,4,5]",
                "output": "10"
            },
            {
                "input": "[2,2,2,1,3],[1,2,2,3,3]",
                "output": "10"
            },
            {
                "input": "[1,2,2],[1,2,2]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minCost(int[] nums1, int[] nums2) {\n    Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\n    for (int i = 0; i < nums1.length; ++i) {\n        valueToIndices.putIfAbsent(nums1[i], new ArrayList<>());\n        valueToIndices.get(nums1[i]).add(i);\n    }\n\n    int result = 0;\n    for (int val : nums2) {\n        List<Integer> indices = valueToIndices.get(val);\n        if (indices == null || indices.isEmpty()) return -1;\n        result += indices.get(indices.size() - 1);\n        indices.remove(indices.size() - 1);\n    }\n\n    return result;\n}\n```\n\n    \n    We make a mapping (`value_to_indices`) from each value in `nums1` to its indices in `nums1`. \n\nThen, for each value `val` in `nums2`, we get the last index from `value_to_indices[val]` vector, add it to the result, and remove it from the vector. If at any point the vector is empty, it means we can't satisfy the conditions and we return -1.\n    ",
        "python": "\n    ```python\ndef min_cost(nums1: List[int], nums2: List[int]) -> int:\n    value_to_indices = {}\n    for i, val in enumerate(nums1):\n        value_to_indices.setdefault(val, []).append(i)\n\n    result = 0\n    for val in nums2:\n        if not value_to_indices[val]:\n            return -1\n        result += value_to_indices[val].pop()\n\n    return result\n```\n\n    \n    We make a mapping (`value_to_indices`) from each value in `nums1` to its indices in `nums1`. \n\nThen, for each value `val` in `nums2`, we get the last index from `value_to_indices[val]` vector, add it to the result, and remove it from the vector. If at any point the vector is empty, it means we can't satisfy the conditions and we return -1.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int, vector<int>> value_to_indices;\n    for (int i = 0; i < nums1.size(); ++i) {\n        value_to_indices[nums1[i]].push_back(i);\n    }\n    \n    int result = 0;\n    for (int val : nums2) {\n        if (value_to_indices[val].empty()) return -1;\n        result += value_to_indices[val].back();\n        value_to_indices[val].pop_back();\n    }\n    \n    return result;\n}\n```\n    \n    We make a mapping (`value_to_indices`) from each value in `nums1` to its indices in `nums1`. \n\nThen, for each value `val` in `nums2`, we get the last index from `value_to_indices[val]` vector, add it to the result, and remove it from the vector. If at any point the vector is empty, it means we can't satisfy the conditions and we return -1.\n    ",
        "js": "\n    ```javascript\nfunction minCost(nums1, nums2) {\n    const valueToIndices = new Map();\n    for (let i = 0; i < nums1.length; ++i) {\n        if (!valueToIndices.has(nums1[i])) {\n            valueToIndices.set(nums1[i], []);\n        }\n        valueToIndices.get(nums1[i]).push(i);\n    }\n\n    let result = 0;\n    for (const val of nums2) {\n        const indices = valueToIndices.get(val);\n        if (!indices || indices.length === 0) return -1;\n        result += indices.pop();\n    }\n\n    return result;\n}\n```\n\n    \n    We make a mapping (`value_to_indices`) from each value in `nums1` to its indices in `nums1`. \n\nThen, for each value `val` in `nums2`, we get the last index from `value_to_indices[val]` vector, add it to the result, and remove it from the vector. If at any point the vector is empty, it means we can't satisfy the conditions and we return -1.\n    "
    },
    {
        "id": 430,
        "title": "Maximum Number of Points From Grid Queries",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` integer matrix `grid` and an array `queries` of size `k`.\n\nFind an array `answer` of size `k` such that for each integer `queries[i]` you start in the **top left** cell of the matrix and repeat the following process:\n\n*   If `queries[i]` is **strictly** greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any **adjacent** cell in all `4` directions: up, down, left, and right.\n*   Otherwise, you do not get any points, and you end this process.\n\nAfter the process, `answer[i]` is the **maximum** number of points you can get. **Note** that for each query you are allowed to visit the same cell **multiple** times.\n\nReturn _the resulting array_ `answer`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[2,5,7\\],\\[3,5,1\\]\\], queries = \\[5,6,2\\]\n**Output:** \\[5,8,1\\]\n**Explanation:** The diagrams above show which cells we visit to get points for each query.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[5,2,1\\],\\[1,1,2\\]\\], queries = \\[3\\]\n**Output:** \\[0\\]\n**Explanation:** We can not get any points because the value of the top left cell is already greater than or equal to 3."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `k == queries.length`\n*   `1 <= k <= 104`\n*   `1 <= grid[i][j], queries[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Two Pointers",
            "Breadth-First Search",
            "Union Find",
            "Sorting",
            "Heap (Priority Queue)",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[1,2,3],[2,5,7],[3,5,1]],[5,6,2]",
                "output": "[5,8,1]"
            },
            {
                "input": "[[5,2,1],[1,1,2]],[3]",
                "output": "[0]"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> maxPoints(int[][] grid, int[] queries) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int[] dx = {-1, 0, 1, 0};\n    int[] dy = {0, 1, 0, -1};\n    List<Integer> result = new ArrayList<>();\n\t\n    for (int query : queries) {\n        int points = 0;\n        Set<String> visited = new HashSet<>();\n        Stack<int[]> stack = new Stack<>();\n        stack.push(new int[]{0, 0});\n\t\t\n        while (!stack.isEmpty()) {\n            int[] cur = stack.pop();\n            int x = cur[0], y = cur[1];\n            String coordStr = x + \",\" + y;\n\t\t\t\n            if (!visited.contains(coordStr) && grid[x][y] < query) {\n                visited.add(coordStr);\n                points++;\n                for (int i = 0; i < 4; i++) {\n                    int nx = x + dx[i], ny = y + dy[i];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                        stack.push(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n        result.add(points);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm for this problem is essentially a depth-first search on the grid. For each query, start at the top left of the grid and perform a DFS. \n\n1. If the cell has not been visited and the value of the cell is strictly lower than the query value, add the cell to the visited set, increment the points, and continue the DFS for all 4 adjacent cells.\n2. If the cell is visited or the value is not lower than the query, the DFS terminates for that path.\n\nThis process is repeated for all queries, and the answer array is returned with the maximum points for each query.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m, n = len(grid), len(grid[0])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    def dfs(x: int, y: int, q: int, visited: set) -> int:\n        if 0 <= x < m and 0 <= y < n and grid[x][y] < q and (x, y) not in visited:\n            visited.add((x, y))\n            points = 1\n            for i in range(4):\n                nx, ny = x + dx[i], y + dy[i]\n                points += dfs(nx, ny, q, visited)\n            return points\n        return 0\n\n    return [dfs(0, 0, query, set()) for query in queries]\n```\n\n    \n    The algorithm for this problem is essentially a depth-first search on the grid. For each query, start at the top left of the grid and perform a DFS. \n\n1. If the cell has not been visited and the value of the cell is strictly lower than the query value, add the cell to the visited set, increment the points, and continue the DFS for all 4 adjacent cells.\n2. If the cell is visited or the value is not lower than the query, the DFS terminates for that path.\n\nThis process is repeated for all queries, and the answer array is returned with the maximum points for each query.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\n\nvector<int> traverseMatrix(vector<vector<int>>& grid, const vector<int>& queries, int m, int n) {\n    vector<int> dx = {-1, 0, 1, 0};\n    vector<int> dy = {0, 1, 0, -1};\n    vector<int> answer(queries.size(), 0);\n\t\n    for (int k = 0; k < queries.size(); ++k) {\n        int q = queries[k];\n        int points = 0;\n        set<pair<int, int>> visited;\n\t\t\n        function<void(int, int)> dfs = [&](int x, int y) {\n            if (visited.find({x, y}) == visited.end() && grid[x][y] < q) {\n                visited.insert({x, y});\n                points++;\n                for (int i = 0; i < 4; ++i) {\n                    int nx = x + dx[i], ny = y + dy[i];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                        dfs(nx, ny);\n                    }\n                }\n            }\n        };\n\t\t\n        dfs(0, 0);\n        answer[k] = points;\n    }\n\t\n    return answer;\n}\n\nvector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\n    int m = grid.size();\n    int n = grid[0].size();\n    return traverseMatrix(grid, queries, m, n);\n}\n```\n\n    \n    The algorithm for this problem is essentially a depth-first search on the grid. For each query, start at the top left of the grid and perform a DFS. \n\n1. If the cell has not been visited and the value of the cell is strictly lower than the query value, add the cell to the visited set, increment the points, and continue the DFS for all 4 adjacent cells.\n2. If the cell is visited or the value is not lower than the query, the DFS terminates for that path.\n\nThis process is repeated for all queries, and the answer array is returned with the maximum points for each query.\n    ",
        "js": "\n    ```javascript\nfunction maxPoints(grid, queries) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dx = [-1, 0, 1, 0];\n    const dy = [0, 1, 0, -1];\n\n    function dfs(x, y, q, visited) {\n        if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] < q && !visited.has(`${x},${y}`)) {\n            visited.add(`${x},${y}`);\n            let points = 1;\n            for (let i = 0; i < 4; i++) {\n                const nx = x + dx[i], ny = y + dy[i];\n                points += dfs(nx, ny, q, visited);\n            }\n            return points;\n        }\n        return 0;\n    }\n\n    return queries.map(query => dfs(0, 0, query, new Set()));\n}\n```\n\n    \n    The algorithm for this problem is essentially a depth-first search on the grid. For each query, start at the top left of the grid and perform a DFS. \n\n1. If the cell has not been visited and the value of the cell is strictly lower than the query value, add the cell to the visited set, increment the points, and continue the DFS for all 4 adjacent cells.\n2. If the cell is visited or the value is not lower than the query, the DFS terminates for that path.\n\nThis process is repeated for all queries, and the answer array is returned with the maximum points for each query.\n    "
    },
    {
        "id": 431,
        "title": "Add Edges to Make Degrees of All Nodes Even",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an **undirected** graph consisting of `n` nodes numbered from `1` to `n`. You are given the integer `n` and a **2D** array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. The graph can be disconnected.\n\nYou can add **at most** two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\n\nReturn `true` _if it is possible to make the degree of each node in the graph even, otherwise return_ `false`_._\n\nThe degree of a node is the number of edges connected to it.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,2\\],\\[1,4\\],\\[2,5\\]\\]\n**Output:** true\n**Explanation:** The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.\n\n",
                "**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** true\n**Explanation:** The above diagram shows a valid way of adding two edges.\n\n",
                "**Example 3:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\]\\]\n**Output:** false\n**Explanation:** It is not possible to obtain a valid graph with adding at most 2 edges."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= n <= 105`\n*   `2 <= edges.length <= 105`\n*   `edges[i].length == 2`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   There are no repeated edges.",
            "follow_up": null
        },
        "tag": [
            "Hash Table",
            "Graph"
        ],
        "example": [
            {
                "input": "5,[[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]",
                "output": "true"
            },
            {
                "input": "4,[[1,2],[3,4]]",
                "output": "true"
            },
            {
                "input": "4,[[1,2],[1,3],[1,4]]",
                "output": "false"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean possibleDegreeEven(int n, int[][] edges) {\n    HashMap<Integer, Integer> degrees = new HashMap<>();\n    for (int[] edge : edges) {\n        degrees.put(edge[0], degrees.getOrDefault(edge[0], 0) + 1);\n        degrees.put(edge[1], degrees.getOrDefault(edge[1], 0) + 1);\n    }\n    \n    int odd_degrees = 0;\n    for (int i = 1; i <= n; i++) {\n        if (degrees.getOrDefault(i, 0) % 2 != 0) odd_degrees++;\n    }\n    \n    return (odd_degrees == 0 || odd_degrees == 2);\n}\n```\n    \n    The algorithm is as follows:\n1. Create a degrees list to store the degree of each node (number of edges connected to the node).\n2. Iterate through the edges list and increment the degree of both nodes (a and b) in each edge.\n3. Count the number of nodes with odd degrees.\n4. If the number of nodes with odd degrees is either 0 or 2, it is possible to add at most 2 edges to make the degree of each node even. Otherwise, it's not possible.\n\nThe solution is in O(n) time complexity, where n is the number of nodes.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef possible_degree_even(n, edges):\n    degrees = defaultdict(int)\n    for a, b in edges:\n        degrees[a] += 1\n        degrees[b] += 1\n\n    odd_degrees = sum(1 for d in range(1, n + 1) if degrees[d] % 2 != 0)\n    return odd_degrees == 0 or odd_degrees == 2\n```\n    \n    The algorithm is as follows:\n1. Create a degrees list to store the degree of each node (number of edges connected to the node).\n2. Iterate through the edges list and increment the degree of both nodes (a and b) in each edge.\n3. Count the number of nodes with odd degrees.\n4. If the number of nodes with odd degrees is either 0 or 2, it is possible to add at most 2 edges to make the degree of each node even. Otherwise, it's not possible.\n\nThe solution is in O(n) time complexity, where n is the number of nodes.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool possibleDegreeEven(int n, vector<vector<int>>& edges) {\n    vector<int> degrees(n + 1, 0);\n    for (const auto& edge : edges) {\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    int odd_degrees = 0;\n    for (int i = 1; i <= n; i++) {\n        if (degrees[i] % 2 != 0) odd_degrees++;\n    }\n\n    return (odd_degrees == 0 || odd_degrees == 2);\n}\n```\n    \n    The algorithm is as follows:\n1. Create a degrees list to store the degree of each node (number of edges connected to the node).\n2. Iterate through the edges list and increment the degree of both nodes (a and b) in each edge.\n3. Count the number of nodes with odd degrees.\n4. If the number of nodes with odd degrees is either 0 or 2, it is possible to add at most 2 edges to make the degree of each node even. Otherwise, it's not possible.\n\nThe solution is in O(n) time complexity, where n is the number of nodes.\n    ",
        "js": "\n    ```javascript\nfunction possibleDegreeEven(n, edges) {\n    let degrees = {};\n    for (let edge of edges) {\n        degrees[edge[0]] = (degrees[edge[0]] || 0) + 1;\n        degrees[edge[1]] = (degrees[edge[1]] || 0) + 1;\n    }\n    let odd_degrees = 0;\n    for (let i = 1; i <= n; i++) {\n        if ((degrees[i] || 0) % 2 != 0) odd_degrees++;\n    }\n    return (odd_degrees == 0 || odd_degrees == 2);\n}\n```\n    \n    The algorithm is as follows:\n1. Create a degrees list to store the degree of each node (number of edges connected to the node).\n2. Iterate through the edges list and increment the degree of both nodes (a and b) in each edge.\n3. Count the number of nodes with odd degrees.\n4. If the number of nodes with odd degrees is either 0 or 2, it is possible to add at most 2 edges to make the degree of each node even. Otherwise, it's not possible.\n\nThe solution is in O(n) time complexity, where n is the number of nodes.\n    "
    },
    {
        "id": 432,
        "title": "Cycle Length Queries in a Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n`. There is a **complete binary tree** with `2n - 1` nodes. The root of that tree is the node with the value `1`, and every node with a value `val` in the range `[1, 2n - 1 - 1]` has two children where:\n\n*   The left node has the value `2 * val`, and\n*   The right node has the value `2 * val + 1`.\n\nYou are also given a 2D integer array `queries` of length `m`, where `queries[i] = [ai, bi]`. For each query, solve the following problem:\n\n1.  Add an edge between the nodes with values `ai` and `bi`.\n2.  Find the length of the cycle in the graph.\n3.  Remove the added edge between nodes with values `ai` and `bi`.\n\n**Note** that:\n\n*   A **cycle** is a path that starts and ends at the same node, and each edge in the path is visited only once.\n*   The length of a cycle is the number of edges visited in the cycle.\n*   There could be multiple edges between two nodes in the tree after adding the edge of the query.\n\nReturn _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the answer to the_ `ith` _query._",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, queries = \\[\\[5,3\\],\\[4,7\\],\\[2,3\\]\\]\n**Output:** \\[4,5,3\\]\n**Explanation:** The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes \\[5,2,1,3\\]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes \\[4,2,1,3,7\\]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes \\[2,1,3\\]. Thus answer to the third query is 3. We delete the added edge.\n\n",
                "**Example 2:**\n\n**Input:** n = 2, queries = \\[\\[1,2\\]\\]\n**Output:** \\[2\\]\n**Explanation:** The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes \\[2,1\\]. Thus answer for the first query is 2. We delete the added edge."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 30`\n*   `m == queries.length`\n*   `1 <= m <= 105`\n*   `queries[i].length == 2`\n*   `1 <= ai, bi <= 2n - 1`\n*   `ai != bi`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Tree",
            "Binary Tree"
        ],
        "example": [
            {
                "input": "3,[[5,3],[4,7],[2,3]]",
                "output": "[4,5,3]"
            },
            {
                "input": "2,[[1,2]]",
                "output": "[2]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public List<Integer> length_of_cycle(int n, int[][] queries) {\n        List<Integer> result = new ArrayList();\n        for (int[] query : queries) {\n            int depth_A = 0, depth_B = 0, A = query[0], B = query[1];\n            while (A != B) {\n                if (A < B) {\n                    int tmp = A;\n                    A = B;\n                    B = tmp;\n                }\n                A >>= 1;\n                depth_A++;\n            }\n            result.add(depth_A + depth_B);\n        }\n        return result;\n    }\n} \n```\n    \n    The algorithm is based on tree traversal. For each query `[A, B]`, we keep track of the depth of nodes `A` and `B`. We traverse the tree by moving both nodes up (dividing by 2) until they become equal.\n\nIn each iteration, if `A < B`, we swap `A` and `B`. Then, we divide `A` by 2 and increment the depth of node `A`. This continues until nodes `A` and `B` become the same.\n\nAfter the loop, the length of the cycle is the sum of the depths of both nodes.\n\nThis algorithm doesn't need to add and remove edges, as finding the nodes' depths gives us the cycle length directly.\n    ",
        "python": "\n    ```python\ndef length_of_cycle(n, queries):\n    result = []\n    for A, B in queries:\n        depth_A, depth_B = 0, 0\n        while A != B:\n            if A < B:\n                A, B = B, A\n            A >>= 1\n            depth_A += 1\n        result.append(depth_A + depth_B)\n    return result\n```\n    \n    The algorithm is based on tree traversal. For each query `[A, B]`, we keep track of the depth of nodes `A` and `B`. We traverse the tree by moving both nodes up (dividing by 2) until they become equal.\n\nIn each iteration, if `A < B`, we swap `A` and `B`. Then, we divide `A` by 2 and increment the depth of node `A`. This continues until nodes `A` and `B` become the same.\n\nAfter the loop, the length of the cycle is the sum of the depths of both nodes.\n\nThis algorithm doesn't need to add and remove edges, as finding the nodes' depths gives us the cycle length directly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> length_of_cycle(int n, const std::vector<std::vector<int>>& queries) {\n    std::vector<int> result;\n    for (const auto& query : queries) {\n        int depth_A = 0, depth_B = 0, A = query[0], B = query[1];\n        while (A != B) {\n            if (A < B) std::swap(A, B);\n            A >>= 1;\n            depth_A++;\n        }\n        result.push_back(depth_A + depth_B);\n    }\n    return result;\n}\n```\n    \n    The algorithm is based on tree traversal. For each query `[A, B]`, we keep track of the depth of nodes `A` and `B`. We traverse the tree by moving both nodes up (dividing by 2) until they become equal.\n\nIn each iteration, if `A < B`, we swap `A` and `B`. Then, we divide `A` by 2 and increment the depth of node `A`. This continues until nodes `A` and `B` become the same.\n\nAfter the loop, the length of the cycle is the sum of the depths of both nodes.\n\nThis algorithm doesn't need to add and remove edges, as finding the nodes' depths gives us the cycle length directly.\n    ",
        "js": "\n    ```javascript\nfunction length_of_cycle(n, queries) {\n    const result = [];\n    for (const query of queries) {\n        let depth_A = 0, depth_B = 0, A = query[0], B = query[1];\n        while (A !== B) {\n            if (A < B) [A, B] = [B, A];\n            A >>= 1;\n            depth_A++;\n        }\n        result.push(depth_A + depth_B);\n    }\n    return result;\n}\n```\n    \n    The algorithm is based on tree traversal. For each query `[A, B]`, we keep track of the depth of nodes `A` and `B`. We traverse the tree by moving both nodes up (dividing by 2) until they become equal.\n\nIn each iteration, if `A < B`, we swap `A` and `B`. Then, we divide `A` by 2 and increment the depth of node `A`. This continues until nodes `A` and `B` become the same.\n\nAfter the loop, the length of the cycle is the sum of the depths of both nodes.\n\nThis algorithm doesn't need to add and remove edges, as finding the nodes' depths gives us the cycle length directly.\n    "
    },
    {
        "id": 433,
        "title": "Number of Great Partitions",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums` consisting of **positive** integers and an integer `k`.\n\n**Partition** the array into two ordered **groups** such that each element is in exactly **one** group. A partition is called great if the **sum** of elements of each group is greater than or equal to `k`.\n\nReturn _the number of **distinct** great partitions_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nTwo partitions are considered distinct if some element `nums[i]` is in different groups in the two partitions.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\], k = 4\n**Output:** 6\n**Explanation:** The great partitions are: (\\[1,2,3\\], \\[4\\]), (\\[1,3\\], \\[2,4\\]), (\\[1,4\\], \\[2,3\\]), (\\[2,3\\], \\[1,4\\]), (\\[2,4\\], \\[1,3\\]) and (\\[4\\], \\[1,2,3\\]).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,3,3\\], k = 4\n**Output:** 0\n**Explanation:** There are no great partitions for this array.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[6,6\\], k = 2\n**Output:** 2\n**Explanation:** We can either put nums\\[0\\] in the first partition or in the second partition.\nThe great partitions will be (\\[6\\], \\[6\\]) and (\\[6\\], \\[6\\])."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length, k <= 1000`\n*   `1 <= nums[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "[1,2,3,4],4",
                "output": "6"
            },
            {
                "input": "[3,3,3],4",
                "output": "0"
            },
            {
                "input": "[6,6],2",
                "output": "2"
            }
        ],
        "java": "\n    ```java\npublic int countPartitions(int[] nums, int k) {\n    long total_sum = 0;\n    int n = nums.length;\n    int mod = 1000000007;\n\n    for (int num : nums) {\n        total_sum += num;\n    }\n\n    if (total_sum < (long) k * 2) {\n        return 0;\n    }\n\n    long[] dp = new long[n + 1];\n    dp[0] = 1;\n\n    for (int i = 1; i <= k - 1; i++) {\n        for (int j = n - 1; j >= 1; j--) {\n            dp[j] = (dp[j] * j + dp[j - 1]) % mod;\n        }\n    }\n\n    long result = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        total_sum -= nums[i];\n        if (total_sum >= k) {\n            result = (result + dp[i + 1]) % mod;\n        }\n    }\n\n    return (int) result;\n}\n```\n    \n    1. Calculate the total sum of the given `nums` array.\n2. If the total sum is less than `k * 2`, return 0 as there are no great partitions.\n3. Initialize a dynamic programming array `dp` with the same length as `nums` plus 1, and set `dp[0]` to 1.\n4. Iterate through the `dp` array in reverse, from the second last element to the first, updating the `dp` array with the current sum of elements from the `nums` array. The updates are calculated modulo `10^9 + 7`.\n5. Iterate through the `nums` array, decrementing the total sum by the value of the current element. If the updated total sum is greater than or equal to `k`, add the `dp` value at the index plus 1 to the result, again calculated modulo `10^9 + 7`.\n6. Return the final result.\n    ",
        "python": "\n    ```python\ndef countPartitions(nums, k):\n    total_sum = sum(nums)\n    n = len(nums)\n    mod = 1000000007\n\n    if total_sum < k * 2:\n        return 0\n\n    dp = [1] * (n + 1)\n\n    for i in range(1, k):\n        for j in range(n - 1, 0, -1):\n            dp[j] = (dp[j] * j + dp[j - 1]) % mod\n\n    result = 0\n\n    for i in range(n - 1):\n        total_sum -= nums[i]\n        if total_sum >= k:\n            result = (result + dp[i + 1]) % mod\n\n    return result\n```\n    \n    1. Calculate the total sum of the given `nums` array.\n2. If the total sum is less than `k * 2`, return 0 as there are no great partitions.\n3. Initialize a dynamic programming array `dp` with the same length as `nums` plus 1, and set `dp[0]` to 1.\n4. Iterate through the `dp` array in reverse, from the second last element to the first, updating the `dp` array with the current sum of elements from the `nums` array. The updates are calculated modulo `10^9 + 7`.\n5. Iterate through the `nums` array, decrementing the total sum by the value of the current element. If the updated total sum is greater than or equal to `k`, add the `dp` value at the index plus 1 to the result, again calculated modulo `10^9 + 7`.\n6. Return the final result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint countPartitions(std::vector<int>& nums, int k) {\n    long long total_sum = 0;\n    int n = nums.size();\n    int mod = 1000000007;\n\n    for (int num : nums) {\n        total_sum += num;\n    }\n\n    if (total_sum < k * 2) {\n        return 0;\n    }\n\n    std::vector<long long> dp(n + 1, 1);\n\n    for (int i = 1; i <= k - 1; i++) {\n        for (int j = n - 1; j >= 1; j--) {\n            dp[j] = (dp[j] * j + dp[j - 1]) % mod;\n        }\n    }\n\n    long long result = 0;\n\n    for(int i = 0; i < n - 1; i++) {\n        total_sum -= nums[i];\n        if (total_sum >= k) {\n            result = (result + dp[i + 1]) % mod;\n        }\n    }\n\n    return (int) result;\n}\n```\n    \n    1. Calculate the total sum of the given `nums` array.\n2. If the total sum is less than `k * 2`, return 0 as there are no great partitions.\n3. Initialize a dynamic programming array `dp` with the same length as `nums` plus 1, and set `dp[0]` to 1.\n4. Iterate through the `dp` array in reverse, from the second last element to the first, updating the `dp` array with the current sum of elements from the `nums` array. The updates are calculated modulo `10^9 + 7`.\n5. Iterate through the `nums` array, decrementing the total sum by the value of the current element. If the updated total sum is greater than or equal to `k`, add the `dp` value at the index plus 1 to the result, again calculated modulo `10^9 + 7`.\n6. Return the final result.\n    ",
        "js": "\n    ```javascript\nfunction countPartitions(nums, k) {\n    let total_sum = nums.reduce((sum, num) => sum + num, 0);\n    let n = nums.length;\n    let mod = 1000000007;\n\n    if (total_sum < k * 2) {\n        return 0;\n    }\n\n    let dp = new Array(n + 1).fill(1);\n\n    for (let i = 1; i <= k - 1; i++) {\n        for (let j = n - 1; j >= 1; j--) {\n            dp[j] = (dp[j] * j + dp[j - 1]) % mod;\n        }\n    }\n\n    let result = 0;\n\n    for (let i = 0; i < n - 1; i++) {\n        total_sum -= nums[i];\n        if (total_sum >= k) {\n            result = (result + dp[i + 1]) % mod;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Calculate the total sum of the given `nums` array.\n2. If the total sum is less than `k * 2`, return 0 as there are no great partitions.\n3. Initialize a dynamic programming array `dp` with the same length as `nums` plus 1, and set `dp[0]` to 1.\n4. Iterate through the `dp` array in reverse, from the second last element to the first, updating the `dp` array with the current sum of elements from the `nums` array. The updates are calculated modulo `10^9 + 7`.\n5. Iterate through the `nums` array, decrementing the total sum by the value of the current element. If the updated total sum is greater than or equal to `k`, add the `dp` value at the index plus 1 to the result, again calculated modulo `10^9 + 7`.\n6. Return the final result.\n    "
    },
    {
        "id": 434,
        "title": "Maximize the Minimum Powered City",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `stations` of length `n`, where `stations[i]` represents the number of power stations in the `ith` city.\n\nEach power station can provide power to every city in a fixed **range**. In other words, if the range is denoted by `r`, then a power station at city `i` can provide power to all cities `j` such that `|i - j| <= r` and `0 <= i, j <= n - 1`.\n\n*   Note that `|x|` denotes **absolute** value. For example, `|7 - 5| = 2` and `|3 - 10| = 7`.\n\nThe **power** of a city is the total number of power stations it is being provided power from.\n\nThe government has sanctioned building `k` more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\n\nGiven the two integers `r` and `k`, return _the **maximum possible minimum power** of a city, if the additional power stations are built optimally._\n\n**Note** that you can build the `k` power stations in multiple cities.",
            "examples": [
                "**Example 1:**\n\n**Input:** stations = \\[1,2,4,5,0\\], r = 1, k = 2\n**Output:** 5\n**Explanation:** \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become \\[1,4,4,5,0\\].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.\n\n",
                "**Example 2:**\n\n**Input:** stations = \\[4,4,4,4\\], r = 0, k = 3\n**Output:** 4\n**Explanation:** \nIt can be proved that we cannot make the minimum power of a city greater than 4."
            ],
            "constraints": "**Constraints:**\n\n*   `n == stations.length`\n*   `1 <= n <= 105`\n*   `0 <= stations[i] <= 105`\n*   `0 <= r <= n - 1`\n*   `0 <= k <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Greedy",
            "Queue",
            "Sliding Window",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,2,4,5,0],1,2",
                "output": "5"
            },
            {
                "input": "[4,4,4,4],0,3",
                "output": "4"
            }
        ],
        "java": "\n    ```java\npublic int maxMinPower(int[] stations, int r, int k) {\n    int n = stations.length;\n    int[] totalPower = new int[n];\n    for (int i = 0; i < n; i++) {\n        for (int j = Math.max(0, i - r); j <= Math.min(n - 1, i + r); j++) {\n            totalPower[j] += stations[i];\n        }\n    }\n\n    int sumk = 0, minPower = Integer.MAX_VALUE;\n    for (int i = r; i < n - r; i++) {\n        sumk += stations[i];\n        minPower = Math.min(minPower, totalPower[i]);\n    }\n\n    for (int j = 0, i = n - 2 * r; j < 2 * r; j++, i--) {\n        sumk -= stations[i + r + 1];\n        minPower -= stations[j];\n        minPower += sumk;\n        minPower += k;\n        minPower = Math.min(minPower, totalPower[j]);\n    }\n\n    return minPower;\n}\n```\n    \n    Initially, we calculate the `totalPower` for all cities by iterating through all stations and adding their power to the cities in their range. Then, initialize two variables: `sumk` to store the sum of the middle stations between `r` to `n - r` (exclusive), and `minPower` to store the maximum possible minimum power of a city.\n\nWe loop through the cities from `1` to `n - 2 * r`, incrementing the iterator `j`. During each iteration, we subtract the power from the city `i + r + 1`, add the power from the city `j`, and add the value of `k` to the `minPower`. Then we update the `minPower` to be the minimum between the current `minPower` and the `totalPower` of the city `j`. Finally, return the value of `minPower`.\n    ",
        "python": "\n    ```python\ndef max_min_power(stations, r, k):\n    n = len(stations)\n    total_power = [0] * n\n    for i in range(n):\n        for j in range(max(0, i - r), min(n, i + r + 1)):\n            total_power[j] += stations[i]\n\n    sumk = 0\n    min_power = float('inf')\n    for i in range(r, n - r):\n        sumk += stations[i]\n        min_power = min(min_power, total_power[i])\n\n    for j in range(2 * r):\n        i = n - 2 * r - 1 - j\n        sumk -= stations[i + r + 1]\n        min_power -= stations[j]\n        min_power += sumk\n        min_power += k\n        min_power = min(min_power, total_power[j])\n\n    return min_power\n```\n    \n    Initially, we calculate the `totalPower` for all cities by iterating through all stations and adding their power to the cities in their range. Then, initialize two variables: `sumk` to store the sum of the middle stations between `r` to `n - r` (exclusive), and `minPower` to store the maximum possible minimum power of a city.\n\nWe loop through the cities from `1` to `n - 2 * r`, incrementing the iterator `j`. During each iteration, we subtract the power from the city `i + r + 1`, add the power from the city `j`, and add the value of `k` to the `minPower`. Then we update the `minPower` to be the minimum between the current `minPower` and the `totalPower` of the city `j`. Finally, return the value of `minPower`.\n    ",
        "c++": "\n    ```cpp\nint maxMinPower(vector<int>& stations, int r, int k) {\n    int n = stations.size();\n    vector<int> totalPower(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = max(0, i - r); j <= min(n - 1, i + r); j++) {\n            totalPower[j] += stations[i];\n        }\n    }\n\n    int sumk = 0, minPower = INT_MAX;\n    for (int i = r; i < n - r; i++) {\n        sumk += stations[i];\n        minPower = min(minPower, totalPower[i]);\n    }\n\n    for (int j = 0, i = n - 2 * r; j < 2 * r; j++, i--) {\n        sumk -= stations[i + r + 1];\n        minPower -= stations[j];\n        minPower += sumk;\n        minPower += k;\n        minPower = min(minPower, totalPower[j]);\n    }\n\n    return minPower;\n}\n```\n    \n    Initially, we calculate the `totalPower` for all cities by iterating through all stations and adding their power to the cities in their range. Then, initialize two variables: `sumk` to store the sum of the middle stations between `r` to `n - r` (exclusive), and `minPower` to store the maximum possible minimum power of a city.\n\nWe loop through the cities from `1` to `n - 2 * r`, incrementing the iterator `j`. During each iteration, we subtract the power from the city `i + r + 1`, add the power from the city `j`, and add the value of `k` to the `minPower`. Then we update the `minPower` to be the minimum between the current `minPower` and the `totalPower` of the city `j`. Finally, return the value of `minPower`.\n    ",
        "js": "\n    ```javascript\nfunction maxMinPower(stations, r, k) {\n    const n = stations.length;\n    const totalPower = Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (let j = Math.max(0, i - r); j <= Math.min(n - 1, i + r); j++) {\n            totalPower[j] += stations[i];\n        }\n    }\n\n    let sumk = 0;\n    let minPower = Infinity;\n    for (let i = r; i < n - r; i++) {\n        sumk += stations[i];\n        minPower = Math.min(minPower, totalPower[i]);\n    }\n\n    for (let j = 0, i = n - 2 * r; j < 2 * r; j++, i--) {\n        sumk -= stations[i + r + 1];\n        minPower -= stations[j];\n        minPower += sumk;\n        minPower += k;\n        minPower = Math.min(minPower, totalPower[j]);\n    }\n\n    return minPower;\n}\n```\n    \n    Initially, we calculate the `totalPower` for all cities by iterating through all stations and adding their power to the cities in their range. Then, initialize two variables: `sumk` to store the sum of the middle stations between `r` to `n - r` (exclusive), and `minPower` to store the maximum possible minimum power of a city.\n\nWe loop through the cities from `1` to `n - 2 * r`, incrementing the iterator `j`. During each iteration, we subtract the power from the city `i + r + 1`, add the power from the city `j`, and add the value of `k` to the `minPower`. Then we update the `minPower` to be the minimum between the current `minPower` and the `totalPower` of the city `j`. Finally, return the value of `minPower`.\n    "
    },
    {
        "id": 435,
        "title": "Time to Cross a Bridge",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`.\n\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (**0-indexed**) can :\n\n*   Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.\n*   Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.\n*   Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.\n*   Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.\n\nA worker `i` is **less efficient** than a worker `j` if either condition is met:\n\n*   `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`\n*   `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`\n\nThe following rules regulate the movement of the workers through the bridge :\n\n*   If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.\n*   If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with **the lowest efficiency** crosses first.\n*   If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with **the lowest efficiency** crosses first.\n\nReturn _the instance of time at which the last worker **reaches the left bank** of the river after all n boxes have been put in the new warehouse_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1, k = 3, time = \\[\\[1,1,2,1\\],\\[1,1,3,1\\],\\[1,1,4,1\\]\\]\n**Output:** 6\n**Explanation:** \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, k = 2, time = \\[\\[1,9,1,8\\],\\[10,10,10,10\\]\\]\n**Output:** 50\n**Explanation:** \nFrom 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n, k <= 104`\n*   `time.length == k`\n*   `time[i].length == 4`\n*   `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Heap (Priority Queue)",
            "Simulation"
        ],
        "example": [
            {
                "input": "1,3,[[1,1,2,1],[1,1,3,1],[1,1,4,1]]",
                "output": "6"
            },
            {
                "input": "3,2,[[1,9,1,8],[10,10,10,10]]",
                "output": "50"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int getLastMoment(int n, int k, int[][] time) {\n    PriorityQueue<int[]> left = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n    PriorityQueue<int[]> right = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n    \n    for (int i = 0; i < k; i++) {\n        left.offer(new int[]{time[i][0] + time[i][2], i});\n    }\n    \n    while (n > 0) {\n        while (!right.isEmpty() && right.peek()[0] <= left.peek()[0]) {\n            int[] rightTop = right.poll();\n            left.offer(new int[]{rightTop[0] + time[rightTop[1]][0] + time[rightTop[1]][2], rightTop[1]});\n        }\n        int[] leftTop = left.poll();\n        time[leftTop[1]][2] += time[leftTop[1]][3] + time[leftTop[1]][0] + time[leftTop[1]][1];\n        right.offer(new int[]{leftTop[0] + time[leftTop[1]][1], leftTop[1]});\n        n--;\n    }\n    \n    int lastMoment = -1;\n    while (!right.isEmpty()) {\n        lastMoment = Math.max(lastMoment, time[right.poll()[1]][2]);\n    }\n    return lastMoment;\n}\n```\n    \n    We will use two priority queues for workers at the left and right sides of the bridge. Initially, all workers are put in the left priority queue using their \"total time to cross the bridge\" as the key value. \n\nIn a loop until all `n` boxes are moved, we perform the following steps:\n1. Shift all waiting workers from the right priority queue (sorted by the return time from the old warehouse) to the left priority queue.\n2. Shift the worker with the highest priority (lowest efficiency) from the left priority queue to the right priority queue (assign the task of moving the box for this worker)\n3. We are decrementing the number of remaining boxes by 1.\n\nIn the end, we go through the right priority queue one more time, updating the maximum value while popping each worker from the queue. Since the boxes have been moved, workers in the right queue only need to put boxes in the new warehouse, and there is no need to worry about priority. The last moment at which the last worker reaches the left bank is equal to the maximum of their times on the bridge. We return this last moment value.\n    ",
        "python": "\n    ```python\nfrom heapq import heappush, heappop\n\ndef getLastMoment(n, k, time):\n    left = [(time[j][0] + time[j][2], j) for j in range(k)]\n    right = []\n\n    while n:\n        while right and right[0][0] <= left[0][0]:\n            right_top = heappop(right)\n            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))\n        left_top = heappop(left)\n        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]\n        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))\n        n -= 1\n\n    lastMoment = -1\n    while right:\n        right_top = heappop(right)\n        lastMoment = max(lastMoment, time[right_top[1]][2])\n    return lastMoment\n```\n    \n    We will use two priority queues for workers at the left and right sides of the bridge. Initially, all workers are put in the left priority queue using their \"total time to cross the bridge\" as the key value. \n\nIn a loop until all `n` boxes are moved, we perform the following steps:\n1. Shift all waiting workers from the right priority queue (sorted by the return time from the old warehouse) to the left priority queue.\n2. Shift the worker with the highest priority (lowest efficiency) from the left priority queue to the right priority queue (assign the task of moving the box for this worker)\n3. We are decrementing the number of remaining boxes by 1.\n\nIn the end, we go through the right priority queue one more time, updating the maximum value while popping each worker from the queue. Since the boxes have been moved, workers in the right queue only need to put boxes in the new warehouse, and there is no need to worry about priority. The last moment at which the last worker reaches the left bank is equal to the maximum of their times on the bridge. We return this last moment value.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint getLastMoment(int n, int k, vector<vector<int>>& time) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> left, right;\n    for (int i = 0; i < k; i++) {\n        left.push({time[i][0] + time[i][2], i});\n    }\n    \n    while (n) {\n        while (!right.empty() && right.top().first <= left.top().first) {\n            auto rightTop = right.top(); right.pop();\n            left.push({rightTop.first + time[rightTop.second][0] + time[rightTop.second][2], rightTop.second});\n        }\n        auto leftTop = left.top(); left.pop();\n        time[leftTop.second][2] += time[leftTop.second][3] + time[leftTop.second][0] + time[leftTop.second][1];\n        right.push({leftTop.first + time[leftTop.second][1], leftTop.second});\n        n--;\n    }\n    \n    int lastMoment = -1;\n    while (!right.empty()) {\n        lastMoment = max(lastMoment, time[right.top().second][2]);\n        right.pop();\n    }\n    return lastMoment;\n}\n```\n    \n    We will use two priority queues for workers at the left and right sides of the bridge. Initially, all workers are put in the left priority queue using their \"total time to cross the bridge\" as the key value. \n\nIn a loop until all `n` boxes are moved, we perform the following steps:\n1. Shift all waiting workers from the right priority queue (sorted by the return time from the old warehouse) to the left priority queue.\n2. Shift the worker with the highest priority (lowest efficiency) from the left priority queue to the right priority queue (assign the task of moving the box for this worker)\n3. We are decrementing the number of remaining boxes by 1.\n\nIn the end, we go through the right priority queue one more time, updating the maximum value while popping each worker from the queue. Since the boxes have been moved, workers in the right queue only need to put boxes in the new warehouse, and there is no need to worry about priority. The last moment at which the last worker reaches the left bank is equal to the maximum of their times on the bridge. We return this last moment value.\n    ",
        "js": "\n    ```javascript\nfunction getLastMoment(n, k, time) {\n    const left = time.map((item, index) => [item[0] + item[2], index]);\n    left.sort(([a], [b]) => a - b);\n    let right = [];\n\n    while (n) {\n        while (right.length && right[0][0] <= left[0][0]) {\n            let rightTop = right.shift();\n            left.push([rightTop[0] + time[rightTop[1]][0] + time[rightTop[1]][2], rightTop[1]]);\n            left.sort(([a], [b]) => a - b);\n        }\n        let leftTop = left.shift();\n        time[leftTop[1]][2] += time[leftTop[1]][3] + time[leftTop[1]][0] + time[leftTop[1]][1];\n        right.push([leftTop[0] + time[leftTop[1]][1], leftTop[1]]);\n        right.sort(([a], [b]) => a - b);\n        n--;\n    }\n    \n    let lastMoment = -1;\n    while (right.length) {\n        let rightTop = right.shift();\n        lastMoment = Math.max(lastMoment, time[rightTop[1]][2]);\n    }\n    return lastMoment;\n}\n```\n    \n    We will use two priority queues for workers at the left and right sides of the bridge. Initially, all workers are put in the left priority queue using their \"total time to cross the bridge\" as the key value. \n\nIn a loop until all `n` boxes are moved, we perform the following steps:\n1. Shift all waiting workers from the right priority queue (sorted by the return time from the old warehouse) to the left priority queue.\n2. Shift the worker with the highest priority (lowest efficiency) from the left priority queue to the right priority queue (assign the task of moving the box for this worker)\n3. We are decrementing the number of remaining boxes by 1.\n\nIn the end, we go through the right priority queue one more time, updating the maximum value while popping each worker from the queue. Since the boxes have been moved, workers in the right queue only need to put boxes in the new warehouse, and there is no need to worry about priority. The last moment at which the last worker reaches the left bank is equal to the maximum of their times on the bridge. We return this last moment value.\n    "
    },
    {
        "id": 436,
        "title": "Difference Between Maximum and Minimum Price Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "There exists an undirected and initially unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given the integer `n` and a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nEach node has an associated price. You are given an integer array `price`, where `price[i]` is the price of the `ith` node.\n\nThe **price sum** of a given path is the sum of the prices of all nodes lying on that path.\n\nThe tree can be rooted at any node `root` of your choice. The incurred **cost** after choosing `root` is the difference between the maximum and minimum **price sum** amongst all paths starting at `root`.\n\nReturn _the **maximum** possible **cost**_ _amongst all possible root choices_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\],\\[3,5\\]\\], price = \\[9,8,7,6,10,5\\]\n**Output:** 24\n**Explanation:** The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes \\[2,1,3,4\\]: the prices are \\[7,8,6,10\\], and the sum of the prices is 31.\n- The second path contains the node \\[2\\] with the price \\[7\\].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\]\\], price = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes \\[0,1,2\\]: the prices are \\[1,1,1\\], and the sum of the prices is 3.\n- The second path contains node \\[0\\] with a price \\[1\\].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi <= n - 1`\n*   `edges` represents a valid tree.\n*   `price.length == n`\n*   `1 <= price[i] <= 105`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Tree",
            "Depth-First Search"
        ],
        "example": [
            {
                "input": "6,[[0,1],[1,2],[1,3],[3,4],[3,5]],[9,8,7,6,10,5]",
                "output": "24"
            },
            {
                "input": "3,[[0,1],[1,2]],[1,1,1]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n    List<Integer>[] adj;\n    int[] price;\n    long[][][] dp;\n\n    void dfs(int u, int p) {\n        dp[u][0] = new long[]{price[u], 0};\n        dp[u][1] = new long[]{price[u], 0};\n\n        for (int v : adj[u]) {\n            if (v == p) continue;\n            dfs(v, u);\n            long[] tmpF = new long[]{dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]};\n            long[] tmpS = new long[]{dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]};\n\n            Arrays.sort(tmpF);\n            Arrays.sort(tmpS);\n\n            dp[u][0] = tmpF;\n            dp[u][1] = tmpS;\n        }\n    }\n\n    public int getMaxCost(int n, int[][] edges, int[] _price) {\n        adj = new ArrayList[n];\n        price = _price;\n        dp = new long[n][2][];\n\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<>();\n        }\n\n        for (int[] e : edges) {\n            adj[e[0]].add(e[1]);\n            adj[e[1]].add(e[0]);\n        }\n\n        dfs(0, -1);\n\n        long ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dp[i][0][1] - dp[i][1][1]);\n        }\n\n        return (int) ans;\n    }\n}\n```\n\n    \n    The problem requires us to find the maximum possible cost among all possible root choices after calculating the price sum of all paths. To achieve this, we will follow the steps below:\n\n1. Create an adjacency list to store the tree structure based on the given edges.\n2. Define a variable `dp` to store the maximum and minimum price sum in the format `dp[u] = [[maxF, maxS], [minF, minS]]`, where `u` is the current node.\n3. Perform a Depth-First Search traversal starting from node 0.\n  - During the traversal, for each node `u`, calculate the maximum and minimum price sums by traversing all of its children nodes.\n4. After the traversal, calculate the maximum possible cost among all possible root choices by iterating through the `dp` array and taking the difference between each node's maximum and minimum price sums.\n5. Return the maximum possible cost.\n\nThe time complexity of this solution is O(n), where n is the number of nodes. The reason lies in the fact that we store our data in an adjacency list, which speeds up the DFS traversal.\n    ",
        "python": "\n    ```python\nfrom typing import List\n\ndef dfs(u, p, adj, price, dp):\n    dp[u] = [[price[u], 0], [price[u], 0]]\n\n    for v in adj[u]:\n        if v == p:\n            continue\n        dfs(v, u, adj, price, dp)\n        tmpF = sorted([dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]])\n        tmpS = sorted([dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]])\n\n        dp[u][0] = tmpF\n        dp[u][1] = tmpS\n\ndef getMaxCost(n: int, edges: List[List[int]], price: List[int]) -> int:\n    adj = [[] for _ in range(n)]\n    dp = [None] * n\n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        adj[e[1]].append(e[0])\n\n    dfs(0, -1, adj, price, dp)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dp[i][0][1] - dp[i][1][1])\n\n    return ans\n```\n\n    \n    The problem requires us to find the maximum possible cost among all possible root choices after calculating the price sum of all paths. To achieve this, we will follow the steps below:\n\n1. Create an adjacency list to store the tree structure based on the given edges.\n2. Define a variable `dp` to store the maximum and minimum price sum in the format `dp[u] = [[maxF, maxS], [minF, minS]]`, where `u` is the current node.\n3. Perform a Depth-First Search traversal starting from node 0.\n  - During the traversal, for each node `u`, calculate the maximum and minimum price sums by traversing all of its children nodes.\n4. After the traversal, calculate the maximum possible cost among all possible root choices by iterating through the `dp` array and taking the difference between each node's maximum and minimum price sums.\n5. Return the maximum possible cost.\n\nThe time complexity of this solution is O(n), where n is the number of nodes. The reason lies in the fact that we store our data in an adjacency list, which speeds up the DFS traversal.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> price;\nvector<pair<vector<long long>, vector<long long>>> dp;\n\nvoid dfs(int u, int p) {\n    dp[u].first[0] = price[u];\n    dp[u].first[1] = 0;\n    dp[u].second[0] = price[u];\n    dp[u].second[1] = 0;\n\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u);\n        dp[u].first.push_back(dp[v].first[0] + price[u] - dp[v].second[0]);\n        dp[u].first.push_back(dp[v].first[1]);\n        dp[u].second.push_back(dp[v].second[0] + price[u] - dp[v].first[0]);\n        dp[u].second.push_back(dp[v].second[1]);\n\n        sort(dp[u].first.begin(), dp[u].first.end());\n        sort(dp[u].second.begin(), dp[u].second.end());\n    }\n}\n\nint getMaxCost(int n, vector<vector<int>>& edges, vector<int>& _price) {\n    adj.resize(n);\n    price = _price;\n    dp.resize(n, pair<vector<long long>, vector<long long>>(vector<long long>(2), vector<long long>(2)));\n\n    for (vector<int>& e : edges) {\n        adj[e[0]].push_back(e[1]);\n        adj[e[1]].push_back(e[0]);\n    }\n\n    dfs(0, -1);\n\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        ans = max(ans, dp[i].first.back() - dp[i].second.back());\n    }\n\n    return ans;\n}\n```\n\n    \n    The problem requires us to find the maximum possible cost among all possible root choices after calculating the price sum of all paths. To achieve this, we will follow the steps below:\n\n1. Create an adjacency list to store the tree structure based on the given edges.\n2. Define a variable `dp` to store the maximum and minimum price sum in the format `dp[u] = [[maxF, maxS], [minF, minS]]`, where `u` is the current node.\n3. Perform a Depth-First Search traversal starting from node 0.\n  - During the traversal, for each node `u`, calculate the maximum and minimum price sums by traversing all of its children nodes.\n4. After the traversal, calculate the maximum possible cost among all possible root choices by iterating through the `dp` array and taking the difference between each node's maximum and minimum price sums.\n5. Return the maximum possible cost.\n\nThe time complexity of this solution is O(n), where n is the number of nodes. The reason lies in the fact that we store our data in an adjacency list, which speeds up the DFS traversal.\n    ",
        "js": "\n    ```javascript\nfunction dfs(u, p, adj, price, dp) {\n  dp[u] = [[price[u], 0], [price[u], 0]];\n\n  for (const v of adj[u]) {\n    if (v == p) continue;\n    dfs(v, u, adj, price, dp);\n    const tmpF = [dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]].sort((a, b) => a - b);\n    const tmpS = [dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]].sort((a, b) => a - b);\n\n    dp[u][0] = tmpF;\n    dp[u][1] = tmpS;\n  }\n}\n\nfunction getMaxCost(n, edges, price) {\n  const adj = Array.from({length: n}, () => []);\n  const dp = Array(n);\n\n  for (const e of edges) {\n    adj[e[0]].push(e[1]);\n    adj[e[1]].push(e[0]);\n  }\n\n  dfs(0, -1, adj, price, dp);\n\n  let ans = 0;\n  for (let i = 0; i < n; ++i) {\n    ans = Math.max(ans, dp[i][0][1] - dp[i][1][1]);\n  }\n\n  return ans;\n}\n```\n\n    \n    The problem requires us to find the maximum possible cost among all possible root choices after calculating the price sum of all paths. To achieve this, we will follow the steps below:\n\n1. Create an adjacency list to store the tree structure based on the given edges.\n2. Define a variable `dp` to store the maximum and minimum price sum in the format `dp[u] = [[maxF, maxS], [minF, minS]]`, where `u` is the current node.\n3. Perform a Depth-First Search traversal starting from node 0.\n  - During the traversal, for each node `u`, calculate the maximum and minimum price sums by traversing all of its children nodes.\n4. After the traversal, calculate the maximum possible cost among all possible root choices by iterating through the `dp` array and taking the difference between each node's maximum and minimum price sums.\n5. Return the maximum possible cost.\n\nThe time complexity of this solution is O(n), where n is the number of nodes. The reason lies in the fact that we store our data in an adjacency list, which speeds up the DFS traversal.\n    "
    },
    {
        "id": 437,
        "title": "Check if Point Is Reachable",
        "difficulty": "Hard",
        "content": {
            "problem": "There exists an infinitely large grid. You are currently at point `(1, 1)`, and you need to reach the point `(targetX, targetY)` using a finite number of steps.\n\nIn one **step**, you can move from point `(x, y)` to any one of the following points:\n\n*   `(x, y - x)`\n*   `(x - y, y)`\n*   `(2 * x, y)`\n*   `(x, 2 * y)`\n\nGiven two integers `targetX` and `targetY` representing the X-coordinate and Y-coordinate of your final position, return `true` _if you can reach the point from_ `(1, 1)` _using some number of steps, and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** targetX = 6, targetY = 9\n**Output:** false\n**Explanation:** It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.\n\n",
                "**Example 2:**\n\n**Input:** targetX = 4, targetY = 7\n**Output:** true\n**Explanation:** You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= targetX, targetY <= 109`",
            "follow_up": null
        },
        "tag": [
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "6,9",
                "output": "false"
            },
            {
                "input": "4,7",
                "output": "true"
            }
        ],
        "java": "\n    ```java\npublic boolean canReach(int targetX, int targetY) {\n    while (targetX > 1 && targetY > 1) {\n        if(targetX < targetY) {\n            int temp = targetX;\n            targetX = targetY;\n            targetY = temp;\n        }\n        targetX -= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}\n```\n    \n    The algorithm will use a while loop to reduce the larger of the `targetX` and `targetY` coordinates by subtracting the smaller one until one of them becomes 1. During each iteration, if `targetX` is smaller than `targetY`, swap their values, then subtract `targetY` from `targetX`. After the loop, check if either `targetX` or `targetY` is equal to 1. If either of them is 1, then it is possible to reach the target point, so return `true`. Otherwise, return `false`. This algorithm recursively performs inverse operations, moving backwards from targetX, targetY to 1, 1, as described in the problem statement.\n    ",
        "python": "\n    ```python\ndef canReach(targetX, targetY):\n    while targetX > 1 and targetY > 1:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        targetX -= targetY\n    return targetX == 1 or targetY == 1\n```\n    \n    The algorithm will use a while loop to reduce the larger of the `targetX` and `targetY` coordinates by subtracting the smaller one until one of them becomes 1. During each iteration, if `targetX` is smaller than `targetY`, swap their values, then subtract `targetY` from `targetX`. After the loop, check if either `targetX` or `targetY` is equal to 1. If either of them is 1, then it is possible to reach the target point, so return `true`. Otherwise, return `false`. This algorithm recursively performs inverse operations, moving backwards from targetX, targetY to 1, 1, as described in the problem statement.\n    ",
        "c++": "\n    ```cpp\nbool canReach(int targetX, int targetY) {\n    while (targetX > 1 && targetY > 1) {\n        if(targetX < targetY) swap(targetX, targetY);\n        targetX -= targetY;\n    }\n    return targetX == 1 || targetY == 1;\n}\n```\n    \n    The algorithm will use a while loop to reduce the larger of the `targetX` and `targetY` coordinates by subtracting the smaller one until one of them becomes 1. During each iteration, if `targetX` is smaller than `targetY`, swap their values, then subtract `targetY` from `targetX`. After the loop, check if either `targetX` or `targetY` is equal to 1. If either of them is 1, then it is possible to reach the target point, so return `true`. Otherwise, return `false`. This algorithm recursively performs inverse operations, moving backwards from targetX, targetY to 1, 1, as described in the problem statement.\n    ",
        "js": "\n    ```javascript\nfunction canReach(targetX, targetY) {\n    while (targetX > 1 && targetY > 1) {\n        if(targetX < targetY) [targetX, targetY] = [targetY, targetX];\n        targetX -= targetY;\n    }\n    return targetX === 1 || targetY === 1;\n}\n```\n    \n    The algorithm will use a while loop to reduce the larger of the `targetX` and `targetY` coordinates by subtracting the smaller one until one of them becomes 1. During each iteration, if `targetX` is smaller than `targetY`, swap their values, then subtract `targetY` from `targetX`. After the loop, check if either `targetX` or `targetY` is equal to 1. If either of them is 1, then it is possible to reach the target point, so return `true`. Otherwise, return `false`. This algorithm recursively performs inverse operations, moving backwards from targetX, targetY to 1, 1, as described in the problem statement.\n    "
    },
    {
        "id": 438,
        "title": "Minimum Cost to Split an Array",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` and an integer `k`.\n\nSplit the array into some number of non-empty subarrays. The **cost** of a split is the sum of the **importance value** of each subarray in the split.\n\nLet `trimmed(subarray)` be the version of the subarray where all numbers which appear only once are removed.\n\n*   For example, `trimmed([3,1,2,4,3,4]) = [3,4,3,4].`\n\nThe **importance value** of a subarray is `k + trimmed(subarray).length`.\n\n*   For example, if a subarray is `[1,2,3,3,3,4,4]`, then trimmed(`[1,2,3,3,3,4,4]) = [3,3,3,4,4].`The importance value of this subarray will be `k + 5`.\n\nReturn _the minimum possible cost of a split of_ `nums`.\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,1,3,3\\], k = 2\n**Output:** 8\n**Explanation:** We split nums to have two subarrays: \\[1,2\\], \\[1,2,1,3,3\\].\nThe importance value of \\[1,2\\] is 2 + (0) = 2.\nThe importance value of \\[1,2,1,3,3\\] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1\\], k = 2\n**Output:** 6\n**Explanation:** We split nums to have two subarrays: \\[1,2\\], \\[1,2,1\\].\nThe importance value of \\[1,2\\] is 2 + (0) = 2.\nThe importance value of \\[1,2,1\\] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,1,2,1\\], k = 5\n**Output:** 10\n**Explanation:** We split nums to have one subarray: \\[1,2,1,2,1\\].\nThe importance value of \\[1,2,1,2,1\\] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < nums.length`\n*   `1 <= k <= 109`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;  } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Dynamic Programming",
            "Counting"
        ],
        "example": [
            {
                "input": "[1,2,1,2,1,3,3],2",
                "output": "8"
            },
            {
                "input": "[1,2,1,2,1],2",
                "output": "6"
            },
            {
                "input": "[1,2,1,2,1],5",
                "output": "10"
            }
        ],
        "java": "\n    ```java\npublic int minCost(int[] nums, int k) {\n    int n = nums.length;\n    int[] count = new int[1001], dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n\n    for (int i = 0, j = 0; j < n; ++j) {\n        ++count[nums[j]];\n        if (count[nums[j]] == 2)\n            dp[j + 1] = dp[i] + k + (j - i + 1);\n        else if (count[nums[j]] > 2)\n            dp[j + 1] = Math.min(dp[j], dp[j - 1] + 1);\n        else\n            dp[j + 1] = dp[j] + 1;\n\n        while (i < j + 1 && count[nums[i]] >= 2) {\n            --count[nums[i]];\n            ++i;\n        }\n    }\n    return dp[n] + n * k;\n}\n```\n    \n    1. Initialize `count` array to store the frequency of each element in the subarray, and `dp` array to store the dynamic programming results.\n2. Use two pointers `i` and `j` for subarray [i, j]. At each step, increment the count for `nums[j]`.\n3. Set the `dp[j+1]` value based on the number of occurrences of `nums[j]`:\n   - If `nums[j]` occurs twice, the importance value will be `k + trimmed(subarray).length`, so we update `dp[j+1]` to `dp[i] + k + (j - i + 1)`.\n   - If `nums[j]` occurs more than 2 times, we have to choose minimum of current `dp[j]` or `dp[j-1] + 1` as importance value.\n   - If `nums[j]` occurs only once, we update `dp[j+1]` to `dp[j] + 1` for importance value calculation.\n4. Update the first pointer `i` to the next position when `nums[i]` has occurred more than once and decrement the count for `nums[i]`.\n5. Return `dp[n]` as the minimum possible cost of a split.\n    ",
        "python": "\n    ```python\ndef minCost(nums: List[int], k: int) -> int:\n    n = len(nums)\n    count = [0] * 1001\n    dp = [0] * (n + 1)\n\n    i = 0\n    for j in range(n):\n        count[nums[j]] += 1\n        \n        if count[nums[j]] == 2:\n            dp[j + 1] = dp[i] + k + (j - i + 1)\n        elif count[nums[j]] > 2:\n            dp[j + 1] = min(dp[j], dp[j - 1] + 1)\n        else:\n            dp[j + 1] = dp[j] + 1\n\n        while i <= j and count[nums[i]] >= 2:\n            count[nums[i]] -= 1\n            i += 1\n\n    return dp[n] + n * k\n```\n    \n    1. Initialize `count` array to store the frequency of each element in the subarray, and `dp` array to store the dynamic programming results.\n2. Use two pointers `i` and `j` for subarray [i, j]. At each step, increment the count for `nums[j]`.\n3. Set the `dp[j+1]` value based on the number of occurrences of `nums[j]`:\n   - If `nums[j]` occurs twice, the importance value will be `k + trimmed(subarray).length`, so we update `dp[j+1]` to `dp[i] + k + (j - i + 1)`.\n   - If `nums[j]` occurs more than 2 times, we have to choose minimum of current `dp[j]` or `dp[j-1] + 1` as importance value.\n   - If `nums[j]` occurs only once, we update `dp[j+1]` to `dp[j] + 1` for importance value calculation.\n4. Update the first pointer `i` to the next position when `nums[i]` has occurred more than once and decrement the count for `nums[i]`.\n5. Return `dp[n]` as the minimum possible cost of a split.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<int>& nums, int k) {\n    int n = nums.size(), INF = 1e9 + 7;\n    vector<int> count(1001, 0), dp(n + 1, 0); // count for frequency, dp for dynamic programming\n\n    for (int i = 0, j = 0; j < n; ++j) {\n        ++count[nums[j]];\n        \n        if (count[nums[j]] == 2) // if occurrence is 2, change dp\n            dp[j + 1] = dp[i] + k + (j - i + 1);\n        else if (count[nums[j]] > 2) // if occurrence is more than 2\n            dp[j + 1] = min(dp[j], dp[j - 1] - (count[nums[j]] - 2)); \n        else\n            dp[j + 1] = dp[j] + getCost(j, count) + k;\n            \n        while (i < j + 1 && count[nums[i]] >= 2) {\n            --count[nums[i]];\n            ++i; // update first pointer i when nums[i] has occurred more than once\n        }\n    }\n\n    return dp[n];\n}\n\nint getCost(int j, vector<int> &count) {\n    return count[nums[j]] == 1 ? 1 : 0;\n}\n```\n    \n    1. Initialize `count` array to store the frequency of each element in the subarray, and `dp` array to store the dynamic programming results.\n2. Use two pointers `i` and `j` for subarray [i, j]. At each step, increment the count for `nums[j]`.\n3. Set the `dp[j+1]` value based on the number of occurrences of `nums[j]`:\n   - If `nums[j]` occurs twice, the importance value will be `k + trimmed(subarray).length`, so we update `dp[j+1]` to `dp[i] + k + (j - i + 1)`.\n   - If `nums[j]` occurs more than 2 times, we have to choose minimum of current `dp[j]` or `dp[j-1] + 1` as importance value.\n   - If `nums[j]` occurs only once, we update `dp[j+1]` to `dp[j] + 1` for importance value calculation.\n4. Update the first pointer `i` to the next position when `nums[i]` has occurred more than once and decrement the count for `nums[i]`.\n5. Return `dp[n]` as the minimum possible cost of a split.\n    ",
        "js": "\n    ```javascript\nfunction minCost(nums, k) {\n    const n = nums.length;\n    const count = new Array(1001).fill(0), dp = new Array(n + 1).fill(0);\n\n    let i = 0;\n    for (let j = 0; j < n; j++) {\n        count[nums[j]]++;\n        \n        if (count[nums[j]] === 2)\n            dp[j + 1] = dp[i] + k + (j - i + 1);\n        else if (count[nums[j]] > 2)\n            dp[j + 1] = Math.min(dp[j], dp[j - 1] + 1);\n        else\n            dp[j + 1] = dp[j] + 1;\n\n        while (i <= j && count[nums[i]] >= 2) {\n            count[nums[i]]--;\n            i++;\n        }\n    }\n    return dp[n] + n * k;\n}\n```\n    \n    1. Initialize `count` array to store the frequency of each element in the subarray, and `dp` array to store the dynamic programming results.\n2. Use two pointers `i` and `j` for subarray [i, j]. At each step, increment the count for `nums[j]`.\n3. Set the `dp[j+1]` value based on the number of occurrences of `nums[j]`:\n   - If `nums[j]` occurs twice, the importance value will be `k + trimmed(subarray).length`, so we update `dp[j+1]` to `dp[i] + k + (j - i + 1)`.\n   - If `nums[j]` occurs more than 2 times, we have to choose minimum of current `dp[j]` or `dp[j-1] + 1` as importance value.\n   - If `nums[j]` occurs only once, we update `dp[j+1]` to `dp[j] + 1` for importance value calculation.\n4. Update the first pointer `i` to the next position when `nums[i]` has occurred more than once and decrement the count for `nums[i]`.\n5. Return `dp[n]` as the minimum possible cost of a split.\n    "
    },
    {
        "id": 439,
        "title": "Put Marbles in Bags",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `k` bags. You are given a **0-indexed** integer array `weights` where `weights[i]` is the weight of the `ith` marble. You are also given the integer `k.`\n\nDivide the marbles into the `k` bags according to the following rules:\n\n*   No bag is empty.\n*   If the `ith` marble and `jth` marble are in a bag, then all marbles with an index between the `ith` and `jth` indices should also be in that same bag.\n*   If a bag consists of all the marbles with an index from `i` to `j` inclusively, then the cost of the bag is `weights[i] + weights[j]`.\n\nThe **score** after distributing the marbles is the sum of the costs of all the `k` bags.\n\nReturn _the **difference** between the **maximum** and **minimum** scores among marble distributions_.",
            "examples": [
                "**Example 1:**\n\n**Input:** weights = \\[1,3,5,1\\], k = 2\n**Output:** 4\n**Explanation:** \nThe distribution \\[1\\],\\[3,5,1\\] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution \\[1,3\\],\\[5,1\\], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\n",
                "**Example 2:**\n\n**Input:** weights = \\[1, 3\\], k = 2\n**Output:** 0\n**Explanation:** The only distribution possible is \\[1\\],\\[3\\]. \nSince both the maximal and minimal score are the same, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= weights.length <= 105`\n*   `1 <= weights[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)"
        ],
        "example": [
            {
                "input": "[1,3,5,1],2",
                "output": "4"
            },
            {
                "input": "[1,3],2",
                "output": "0"
            }
        ],
        "java": "\n    ```java\npublic int maximizeScore(int[] weights, int k) {\n    int n = weights.length;\n    int[] prefixSum = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + weights[i];\n    }\n    int[][] dp = new int[n][k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = -1000000000;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        dp[i][1] = prefixSum[i + 1];\n        if (i > 0) {\n            dp[i][i + 1] = prefixSum[i + 1] - prefixSum[1];\n        }\n        for (int j = 2; j <= Math.min(i + 1, k); j++) {\n            for (int q = 1; q <= i - j + 2; q++) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q]);\n            }\n        }\n    }\n    return dp[n - 1][k] - dp[n - 1][1];\n}\n```\n    \n    We use dynamic programming for this problem. Let `dp[i][j]` be the score of a distribution where the last marble is at index `i` and we distribute marbles into `j` bags. To compute `dp[i][j]`, we iterate through possible splits of the last bag, including marble `i`. We update `dp[i][j]` with the maximum score obtained by any of these splits.\n\nWhen the dynamic programming table `dp` is populated, we return the difference between the maximum and minimum scores among marble distributions (i.e., `dp[n - 1][k] - dp[n - 1][1]`).\n    ",
        "python": "\n    ```python\ndef maximize_score(weights, k):\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[-1000000000] * (k + 1) for _ in range(n)]\n\n    for i in range(n):\n        dp[i][1] = prefix_sum[i + 1]\n        if i > 0:\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]\n        for j in range(2, min(i + 1, k) + 1):\n            for q in range(1, i - j + 3):\n                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])\n\n    return dp[n - 1][k] - dp[n - 1][1]\n```\n    \n    We use dynamic programming for this problem. Let `dp[i][j]` be the score of a distribution where the last marble is at index `i` and we distribute marbles into `j` bags. To compute `dp[i][j]`, we iterate through possible splits of the last bag, including marble `i`. We update `dp[i][j]` with the maximum score obtained by any of these splits.\n\nWhen the dynamic programming table `dp` is populated, we return the difference between the maximum and minimum scores among marble distributions (i.e., `dp[n - 1][k] - dp[n - 1][1]`).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nint maximizeScore(std::vector<int>& weights, int k) {\n    int n = weights.size();\n    std::vector<int> prefix_sum(n + 1);\n    std::partial_sum(weights.begin(), weights.end(), prefix_sum.begin() + 1);\n    std::vector<std::vector<int>> dp(n, std::vector<int>(k + 1));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = -1e9;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        dp[i][1] = prefix_sum[i + 1];\n        if (i > 0) {\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1];\n        }\n        for (int j = 2; j <= std::min<int>(i + 1, k); j++) {\n            for (int q = 1; q <= i - j + 2; q++) {\n                dp[i][j] = std::max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q]);\n            }\n        }\n    }\n\n    return dp[n - 1][k] - dp[n - 1][1];\n}\n```\n    \n    We use dynamic programming for this problem. Let `dp[i][j]` be the score of a distribution where the last marble is at index `i` and we distribute marbles into `j` bags. To compute `dp[i][j]`, we iterate through possible splits of the last bag, including marble `i`. We update `dp[i][j]` with the maximum score obtained by any of these splits.\n\nWhen the dynamic programming table `dp` is populated, we return the difference between the maximum and minimum scores among marble distributions (i.e., `dp[n - 1][k] - dp[n - 1][1]`).\n    ",
        "js": "\n    ```javascript\nfunction maximizeScore(weights, k) {\n    const n = weights.length;\n    const prefixSum = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + weights[i];\n    }\n    const dp = new Array(n).fill(null).map(() => new Array(k + 1).fill(-1000000000));\n    for (let i = 0; i < n; i++) {\n        dp[i][1] = prefixSum[i + 1];\n        if (i > 0) {\n            dp[i][i + 1] = prefixSum[i + 1] - prefixSum[1];\n        }\n        for (let j = 2; j <= Math.min(i + 1, k); j++) {\n            for (let q = 1; q <= i - j + 2; q++) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q]);\n            }\n        }\n    }\n    return dp[n - 1][k] - dp[n - 1][1];\n}\n```\n    \n    We use dynamic programming for this problem. Let `dp[i][j]` be the score of a distribution where the last marble is at index `i` and we distribute marbles into `j` bags. To compute `dp[i][j]`, we iterate through possible splits of the last bag, including marble `i`. We update `dp[i][j]` with the maximum score obtained by any of these splits.\n\nWhen the dynamic programming table `dp` is populated, we return the difference between the maximum and minimum scores among marble distributions (i.e., `dp[n - 1][k] - dp[n - 1][1]`).\n    "
    },
    {
        "id": 440,
        "title": "Count Increasing Quadruplets",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a **0-indexed** integer array `nums` of size `n` containing all numbers from `1` to `n`, return _the number of increasing quadruplets_.\n\nA quadruplet `(i, j, k, l)` is increasing if:\n\n*   `0 <= i < j < k < l < n`, and\n*   `nums[i] < nums[k] < nums[j] < nums[l]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,4,5\\]\n**Output:** 2\n**Explanation:** \n- When i = 0, j = 1, k = 2, and l = 3, nums\\[i\\] < nums\\[k\\] < nums\\[j\\] < nums\\[l\\].\n- When i = 0, j = 1, k = 2, and l = 4, nums\\[i\\] < nums\\[k\\] < nums\\[j\\] < nums\\[l\\]. \nThere are no other quadruplets, so we return 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 0\n**Explanation:** There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums\\[j\\] < nums\\[k\\], we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `4 <= nums.length <= 4000`\n*   `1 <= nums[i] <= nums.length`\n*   All the integers of `nums` are **unique**. `nums` is a permutation.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming",
            "Binary Indexed Tree",
            "Enumeration",
            "Prefix Sum"
        ],
        "example": [
            {
                "input": "[1,3,2,4,5]",
                "output": "2"
            },
            {
                "input": "[1,2,3,4]",
                "output": "0"
            }
        ],
        "java": "\n    \n```java\npublic int increasingQuadruplets(int[] nums) {\n    int n = nums.length, count = 0;\n    for(int i = 0; i < n - 3; i++) {\n        for(int j = i + 1; j < n - 2; j++) {\n            for(int k = j + 1; k < n - 1; k++) {\n                if(nums[i] < nums[k] && nums[k] < nums[j]) {\n                    for(int l = k + 1; l < n; l++) {\n                        if(nums[j] < nums[l]) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    } \n    return count;\n}\n```\n\n    \n    \nWe iterate through all combinations of indices `i, j, k, l` such that `0 <= i < j < k < l < n`. For each quadruplet of indices, we check if `nums[i] < nums[k] < nums[j] < nums[l]`. If so, we increment our count of increasing quadruplets. After iterating through all possible quadruplets, we return our count.\n    ",
        "js": "\n    \n```javascript\nfunction increasingQuadruplets(nums) {\n    const n = nums.length;\n    let count = 0;\n    for(let i = 0; i < n - 3; i++) {\n        for(let j = i + 1; j < n - 2; j++) {\n            for(let k = j + 1; k < n - 1; k++) {\n                if(nums[i] < nums[k] && nums[k] < nums[j]) {\n                    for(let l = k + 1; l < n; l++) {\n                        if(nums[j] < nums[l]) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    } \n    return count;\n}\n```\n\n    \n    \nWe iterate through all combinations of indices `i, j, k, l` such that `0 <= i < j < k < l < n`. For each quadruplet of indices, we check if `nums[i] < nums[k] < nums[j] < nums[l]`. If so, we increment our count of increasing quadruplets. After iterating through all possible quadruplets, we return our count.\n    ",
        "c++": "\n    \n```cpp\nint increasing_quadruplets(vector<int>& nums) {\n    int n = nums.size(), count = 0;\n    for(int i = 0; i < n - 3; i++) {\n        for(int j = i + 1; j < n - 2; j++) {\n            for(int k = j + 1; k < n - 1; k++) {\n                if(nums[i] < nums[k] && nums[k] < nums[j]) {\n                    for(int l = k + 1; l < n; l++) {\n                        if(nums[j] < nums[l]) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    } \n    return count;\n}\n```\n\n    \n    \nWe iterate through all combinations of indices `i, j, k, l` such that `0 <= i < j < k < l < n`. For each quadruplet of indices, we check if `nums[i] < nums[k] < nums[j] < nums[l]`. If so, we increment our count of increasing quadruplets. After iterating through all possible quadruplets, we return our count.\n    ",
        "python": "\n    \n```python\ndef increasing_quadruplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n - 3):\n        for j in range(i + 1, n - 2):\n            for k in range(j + 1, n - 1):\n                if nums[i] < nums[k] and nums[k] < nums[j]:\n                    for l in range(k + 1, n):\n                        if nums[j] < nums[l]:\n                            count += 1\n    return count\n```\n\n    \n    \nWe iterate through all combinations of indices `i, j, k, l` such that `0 <= i < j < k < l < n`. For each quadruplet of indices, we check if `nums[i] < nums[k] < nums[j] < nums[l]`. If so, we increment our count of increasing quadruplets. After iterating through all possible quadruplets, we return our count.\n    "
    },
    {
        "id": 441,
        "title": "Rearranging Fruits",
        "difficulty": "Hard",
        "content": {
            "problem": "You have two fruit baskets containing `n` fruits each. You are given two **0-indexed** integer arrays `basket1` and `basket2` representing the cost of fruit in each basket. You want to make both baskets **equal**. To do so, you can use the following operation as many times as you want:\n\n*   Chose two indices `i` and `j`, and swap the `ith` fruit of `basket1` with the `jth` fruit of `basket2`.\n*   The cost of the swap is `min(basket1[i],basket2[j])`.\n\nTwo baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\n\nReturn _the minimum cost to make both the baskets equal or_ `-1` _if impossible._",
            "examples": [
                "**Example 1:**\n\n**Input:** basket1 = \\[4,2,2,2\\], basket2 = \\[1,4,1,2\\]\n**Output:** 1\n**Explanation:** Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = \\[4,1,2,2\\] and basket2 = \\[2,4,1,2\\]. Rearranging both the arrays makes them equal.\n\n",
                "**Example 2:**\n\n**Input:** basket1 = \\[2,3,4,1\\], basket2 = \\[3,2,5,1\\]\n**Output:** -1\n**Explanation:** It can be shown that it is impossible to make both the baskets equal."
            ],
            "constraints": "**Constraints:**\n\n*   `basket1.length == bakste2.length`\n*   `1 <= basket1.length <= 105`\n*   `1 <= basket1[i],basket2[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Greedy"
        ],
        "example": [
            {
                "input": "[4,2,2,2],[1,4,1,2]",
                "output": "1"
            },
            {
                "input": "[2,3,4,1],[3,2,5,1]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int minCostToEqualBaskets(int[] basket1, int[] basket2) {\n    Map<Integer, Integer> diffCount = new HashMap<>();\n    for (int i = 0; i < basket1.length; i++) {\n        diffCount.put(basket1[i] - basket2[i], diffCount.getOrDefault(basket1[i] - basket2[i], 0) + 1);\n    }\n\n    int minCost = Integer.MAX_VALUE, cost = 0;\n    for (Map.Entry<Integer, Integer> entry : diffCount.entrySet()) {\n        if (entry.getValue().equals(diffCount.get(-entry.getKey()))) {\n            cost = 0;\n            for (int i = 0; i < basket1.length; i++) {\n                if (basket1[i] - basket2[i] == entry.getKey()) {\n                    cost += Math.min(basket1[i], basket2[i]);\n                }\n            }\n            minCost = Math.min(minCost, cost);\n        }\n    }\n\n    return minCost == Integer.MAX_VALUE ? -1 : minCost / 2;\n}\n```\n    \n    1. Calculate the differences between the elements of basket1 and basket2, and store the counts in a hash map (diff_count).\n2. Iterate through the diff_count hash map, checking if there is an equal count for the negative difference value.\n3. If there is an equal count, calculate the total cost for swaps of the current difference.\n4. Keep track of the minimum total cost found.\n5. Return the minimum total cost divided by 2, or -1 if no valid swaps were found.\n    ",
        "python": "\n    ```python\ndef min_cost_to_equal_baskets(basket1, basket2):\n    diff_count = {}\n    for i in range(len(basket1)):\n        diff = basket1[i] - basket2[i]\n        diff_count[diff] = diff_count.get(diff, 0) + 1\n\n    min_cost = float('inf')\n    for diff, count in diff_count.items():\n        if count == diff_count.get(-diff, 0):\n            cost = sum(min(basket1[i], basket2[i]) for i in range(len(basket1)) if basket1[i] - basket2[i] == diff)\n            min_cost = min(min_cost, cost)\n\n    return -1 if min_cost == float('inf') else min_cost // 2\n```\n    \n    1. Calculate the differences between the elements of basket1 and basket2, and store the counts in a hash map (diff_count).\n2. Iterate through the diff_count hash map, checking if there is an equal count for the negative difference value.\n3. If there is an equal count, calculate the total cost for swaps of the current difference.\n4. Keep track of the minimum total cost found.\n5. Return the minimum total cost divided by 2, or -1 if no valid swaps were found.\n    ",
        "c++": "\n    ```cpp\nint minCostToEqualBaskets(vector<int>& basket1, vector<int>& basket2) {\n    unordered_map<int, int> diff_count;\n    for (int i = 0; i < basket1.size(); i++) {\n        diff_count[basket1[i] - basket2[i]]++;\n    }\n\n    int min_cost = INT_MAX, cost = 0;\n    for (const auto& entry : diff_count) {\n        if (entry.second == diff_count[-entry.first]) {\n            cost = 0;\n            for (int i = 0; i < basket1.size(); i++) {\n                if (basket1[i] - basket2[i] == entry.first) {\n                    cost += min(basket1[i], basket2[i]);\n                }\n            }\n            min_cost = min(min_cost, cost);\n        }\n    }\n\n    return min_cost == INT_MAX ? -1 : min_cost / 2;\n}\n```\n    \n    1. Calculate the differences between the elements of basket1 and basket2, and store the counts in a hash map (diff_count).\n2. Iterate through the diff_count hash map, checking if there is an equal count for the negative difference value.\n3. If there is an equal count, calculate the total cost for swaps of the current difference.\n4. Keep track of the minimum total cost found.\n5. Return the minimum total cost divided by 2, or -1 if no valid swaps were found.\n    ",
        "js": "\n    ```javascript\nfunction minCostToEqualBaskets(basket1, basket2) {\n    const diffCount = new Map();\n    for (let i = 0; i < basket1.length; i++) {\n        const diff = basket1[i] - basket2[i];\n        diffCount.set(diff, (diffCount.get(diff) || 0) + 1);\n    }\n\n    let minCost = Infinity, cost = 0;\n    for (const [diff, count] of diffCount.entries()) {\n        if (count === diffCount.get(-diff)) {\n            cost = 0;\n            for (let i = 0; i < basket1.length; i++) {\n                if (basket1[i] - basket2[i] === diff) {\n                    cost += Math.min(basket1[i], basket2[i]);\n                }\n            }\n            minCost = Math.min(minCost, cost);\n        }\n    }\n\n    return minCost === Infinity ? -1 : minCost / 2;\n}\n```\n    \n    1. Calculate the differences between the elements of basket1 and basket2, and store the counts in a hash map (diff_count).\n2. Iterate through the diff_count hash map, checking if there is an equal count for the negative difference value.\n3. If there is an equal count, calculate the total cost for swaps of the current difference.\n4. Keep track of the minimum total cost found.\n5. Return the minimum total cost divided by 2, or -1 if no valid swaps were found.\n    "
    },
    {
        "id": 442,
        "title": "Subsequence With the Minimum Score",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two strings `s` and `t`.\n\nYou are allowed to remove any number of characters from the string `t`.\n\nThe score of the string is `0` if no characters are removed from the string `t`, otherwise:\n\n*   Let `left` be the minimum index among all removed characters.\n*   Let `right` be the maximum index among all removed characters.\n\nThen the score of the string is `right - left + 1`.\n\nReturn _the minimum possible score to make_ `t` _a subsequence of_ `s`_._\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abacaba \", t =  \"bzaa \"\n**Output:** 1\n**Explanation:** In this example, we remove the character  \"z \" at index 1 (0-indexed).\nThe string t becomes  \"baa \" which is a subsequence of the string  \"abacaba \" and the score is 1 - 1 + 1 = 1.\nIt can be proven that 1 is the minimum score that we can achieve.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"cde \", t =  \"xyz \"\n**Output:** 3\n**Explanation:** In this example, we remove characters  \"x \",  \"y \" and  \"z \" at indices 0, 1, and 2 (0-indexed).\nThe string t becomes  \" \" which is a subsequence of the string  \"cde \" and the score is 2 - 0 + 1 = 3.\nIt can be proven that 3 is the minimum score that we can achieve."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 105`\n*   `s` and `t` consist of only lowercase English letters.",
            "follow_up": null
        },
        "tag": [
            "Two Pointers",
            "String",
            "Binary Search"
        ],
        "example": [
            {
                "input": "\"abacaba\",\"bzaa\"",
                "output": "1"
            },
            {
                "input": "\"cde\",\"xyz\"",
                "output": "3"
            }
        ],
        "java": "\n    ```java\npublic int minScore(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n    for (int i = 0; i <= m; i++) Arrays.fill(dp[i], 1000000);\n    dp[0][0] = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);\n            } else {\n                dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + 1);\n            }\n        }\n    }\n    int ans = 1000000;\n    for (int i = 0; i < m; i++) {\n        ans = Math.min(ans, dp[i + 1][n]);\n    }\n    return ans;\n}\n```\n    \n    In this problem, we use a DP approach to find minimum score to make `t` a subsequence of `s`. We initialize the DP `(m+1) x (n+1)` table with a large number `1e6`. The score in `dp[i][j]` stores the minimum number of deletions needed to create a subsequence of s[0...i] from t[0...j]. We iterate over the length of `s` and `t`, and at each step, we compare the current character in `s` and `t`. If they are the same, we update the DP table with the minimum value, keeping the previous score or updating it with the new score. If they are different, we update the table considering the deletion of a character from `t`. Finally, we iterate over the DP table's last column and find the minimum score that makes `t` a subsequence of `s`. We return this value as the answer.\n    ",
        "python": "\n    ```python\ndef minScore(s, t):\n    m, n = len(s), len(t)\n    dp = [[1e6]*(n+1) for _ in range(m+1)]\n    dp[0][0] = 0\n    for i in range(m):\n        for j in range(n):\n            if s[i] == t[j]:\n                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j])\n            else:\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + 1)\n    ans = 1e6\n    for i in range(m):\n        ans = min(ans, dp[i+1][n])\n    return int(ans)\n```\n    \n    In this problem, we use a DP approach to find minimum score to make `t` a subsequence of `s`. We initialize the DP `(m+1) x (n+1)` table with a large number `1e6`. The score in `dp[i][j]` stores the minimum number of deletions needed to create a subsequence of s[0...i] from t[0...j]. We iterate over the length of `s` and `t`, and at each step, we compare the current character in `s` and `t`. If they are the same, we update the DP table with the minimum value, keeping the previous score or updating it with the new score. If they are different, we update the table considering the deletion of a character from `t`. Finally, we iterate over the DP table's last column and find the minimum score that makes `t` a subsequence of `s`. We return this value as the answer.\n    ",
        "c++": "\n    ```cpp\nint minScore(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 1e6));\n    dp[0][0] = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            if (s[i] == t[j]) dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);\n            else dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);\n    int ans = 1e6;\n    for (int i = 0; i < m; ++i)\n        ans = min(ans, dp[i + 1][n]);\n    return ans;\n}\n```\n    \n    In this problem, we use a DP approach to find minimum score to make `t` a subsequence of `s`. We initialize the DP `(m+1) x (n+1)` table with a large number `1e6`. The score in `dp[i][j]` stores the minimum number of deletions needed to create a subsequence of s[0...i] from t[0...j]. We iterate over the length of `s` and `t`, and at each step, we compare the current character in `s` and `t`. If they are the same, we update the DP table with the minimum value, keeping the previous score or updating it with the new score. If they are different, we update the table considering the deletion of a character from `t`. Finally, we iterate over the DP table's last column and find the minimum score that makes `t` a subsequence of `s`. We return this value as the answer.\n    ",
        "js": "\n    ```javascript\nfunction minScore(s, t) {\n    const m = s.length;\n    const n = t.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(1e6));\n    dp[0][0] = 0;\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (s[i] === t[j]) {\n                dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);\n            } else {\n                dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + 1);\n            }\n        }\n    }\n\n    let ans = 1e6;\n    for (let i = 0; i < m; i++) {\n        ans = Math.min(ans, dp[i + 1][n]);\n    }\n\n    return ans;\n}\n```\n    \n    In this problem, we use a DP approach to find minimum score to make `t` a subsequence of `s`. We initialize the DP `(m+1) x (n+1)` table with a large number `1e6`. The score in `dp[i][j]` stores the minimum number of deletions needed to create a subsequence of s[0...i] from t[0...j]. We iterate over the length of `s` and `t`, and at each step, we compare the current character in `s` and `t`. If they are the same, we update the DP table with the minimum value, keeping the previous score or updating it with the new score. If they are different, we update the table considering the deletion of a character from `t`. Finally, we iterate over the DP table's last column and find the minimum score that makes `t` a subsequence of `s`. We return this value as the answer.\n    "
    },
    {
        "id": 443,
        "title": "Handling Sum Queries After Update",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given two **0-indexed** arrays `nums1` and `nums2` and a 2D array `queries` of queries. There are three types of queries:\n\n1.  For a query of type 1, `queries[i] = [1, l, r]`. Flip the values from `0` to `1` and from `1` to `0` in `nums1` from index `l` to index `r`. Both `l` and `r` are **0-indexed**.\n2.  For a query of type 2, `queries[i] = [2, p, 0]`. For every index `0 <= i < n`, set `nums2[i] = nums2[i] + nums1[i] * p`.\n3.  For a query of type 3, `queries[i] = [3, 0, 0]`. Find the sum of the elements in `nums2`.\n\nReturn _an array containing all the answers to the third type queries._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,0,1\\], nums2 = \\[0,0,0\\], queries = \\[\\[1,1,1\\],\\[2,1,0\\],\\[3,0,0\\]\\]\n**Output:** \\[3\\]\n**Explanation:** After the first query nums1 becomes \\[1,1,1\\]. After the second query, nums2 becomes \\[1,1,1\\], so the answer to the third query is 3. Thus, \\[3\\] is returned.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1\\], nums2 = \\[5\\], queries = \\[\\[2,0,0\\],\\[3,0,0\\]\\]\n**Output:** \\[5\\]\n**Explanation:** After the first query, nums2 remains \\[5\\], so the answer to the second query is 5. Thus, \\[5\\] is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length,nums2.length <= 105`\n*   `nums1.length = nums2.length`\n*   `1 <= queries.length <= 105`\n*   `queries[i].length = 3`\n*   `0 <= l <= r <= nums1.length - 1`\n*   `0 <= p <= 106`\n*   `0 <= nums1[i] <= 1`\n*   `0 <= nums2[i] <= 109`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Segment Tree"
        ],
        "example": [
            {
                "input": "[1,0,1],[0,0,0],[[1,1,1],[2,1,0],[3,0,0]]",
                "output": "[3]"
            },
            {
                "input": "[1],[5],[[2,0,0],[3,0,0]]",
                "output": "[5]"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> solve(int[] nums1, int[] nums2, int[][] queries) {\n    List<Integer> res = new ArrayList<>();\n    for (int[] q : queries) {\n        if (q[0] == 1) {\n            for (int i = q[1]; i <= q[2]; i++) {\n                nums1[i] ^= 1;\n            }\n        } else if (q[0] == 2) {\n            for (int i = 0; i < nums1.length; i++) {\n                nums2[i] += nums1[i] * q[1];\n            }\n        } else if (q[0] == 3) {\n            int sum = 0;\n            for (int num : nums2) {\n                sum += num;\n            }\n            res.add(sum);\n        }\n    }\n    return res;\n}\n```\n\n    \n    The function goes through each query in `queries` and checks the type of the query.\n- For type 1 query, it iterates from the left index `l` to the right index `r` and flips the bits in `nums1` by XORing them with 1.\n- For type 2 query, it updates the `nums2` array by adding the multiplication of `nums1[i]` and `p` to `nums2[i]` for each i in the range of `nums1`.\n- For type 3 query, it calculates the sum of the elements in `nums2` and adds it to the `res` list.\n\nFinally, the function returns the `res` list.\n    ",
        "python": "\n    ```python\ndef solve(nums1, nums2, queries):\n    res = []\n    for q in queries:\n        if q[0] == 1:\n            for i in range(q[1], q[2] + 1):\n                nums1[i] ^= 1\n        elif q[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * q[1]\n        elif q[0] == 3:\n            res.append(sum(nums2))\n    return res\n```\n\n    \n    The function goes through each query in `queries` and checks the type of the query.\n- For type 1 query, it iterates from the left index `l` to the right index `r` and flips the bits in `nums1` by XORing them with 1.\n- For type 2 query, it updates the `nums2` array by adding the multiplication of `nums1[i]` and `p` to `nums2[i]` for each i in the range of `nums1`.\n- For type 3 query, it calculates the sum of the elements in `nums2` and adds it to the `res` list.\n\nFinally, the function returns the `res` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> solve(vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &queries) {\n    vector<int> res;\n    for (auto &q : queries) {\n        if (q[0] == 1) {\n            for (int i = q[1]; i <= q[2]; i++) {\n                nums1[i] ^= 1;\n            }\n        } else if (q[0] == 2) {\n            for (int i = 0; i < nums1.size(); i++) {\n                nums2[i] += nums1[i] * q[1];\n            }\n        } else if (q[0] == 3) {\n            int sum = 0;\n            for (auto num : nums2) {\n                sum += num;\n            }\n            res.push_back(sum);\n        }\n    }\n    return res;\n}\n```\n\n    \n    The function goes through each query in `queries` and checks the type of the query.\n- For type 1 query, it iterates from the left index `l` to the right index `r` and flips the bits in `nums1` by XORing them with 1.\n- For type 2 query, it updates the `nums2` array by adding the multiplication of `nums1[i]` and `p` to `nums2[i]` for each i in the range of `nums1`.\n- For type 3 query, it calculates the sum of the elements in `nums2` and adds it to the `res` list.\n\nFinally, the function returns the `res` list.\n    ",
        "js": "\n    ```javascript\nfunction solve(nums1, nums2, queries) {\n    const res = [];\n    for (const q of queries) {\n        if (q[0] === 1) {\n            for (let i = q[1]; i <= q[2]; i++) {\n                nums1[i] ^= 1;\n            }\n        } else if (q[0] === 2) {\n            for (let i = 0; i < nums1.length; i++) {\n                nums2[i] += nums1[i] * q[1];\n            }\n        } else if (q[0] === 3) {\n            res.push(nums2.reduce((a, b) => a + b, 0));\n        }\n    }\n    return res;\n}\n```\n\n    \n    The function goes through each query in `queries` and checks the type of the query.\n- For type 1 query, it iterates from the left index `l` to the right index `r` and flips the bits in `nums1` by XORing them with 1.\n- For type 2 query, it updates the `nums2` array by adding the multiplication of `nums1[i]` and `p` to `nums2[i]` for each i in the range of `nums1`.\n- For type 3 query, it calculates the sum of the elements in `nums2` and adds it to the `res` list.\n\nFinally, the function returns the `res` list.\n    "
    },
    {
        "id": 444,
        "title": "Find the String with LCP",
        "difficulty": "Hard",
        "content": {
            "problem": "We define the `lcp` matrix of any **0-indexed** string `word` of `n` lowercase English letters as an `n x n` grid such that:\n\n*   `lcp[i][j]` is equal to the length of the **longest common prefix** between the substrings `word[i,n-1]` and `word[j,n-1]`.\n\nGiven an `n x n` matrix `lcp`, return the alphabetically smallest string `word` that corresponds to `lcp`. If there is no such string, return an empty string.\n\nA string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. For example, `\"aabd \"` is lexicographically smaller than `\"aaca \"` because the first position they differ is at the third letter, and `'b'` comes before `'c'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** lcp = \\[\\[4,0,2,0\\],\\[0,3,0,1\\],\\[2,0,2,0\\],\\[0,1,0,1\\]\\]\n**Output:**  \"abab \"\n**Explanation:** lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is  \"abab \".\n\n",
                "**Example 2:**\n\n**Input:** lcp = \\[\\[4,3,2,1\\],\\[3,3,2,1\\],\\[2,2,2,1\\],\\[1,1,1,1\\]\\]\n**Output:**  \"aaaa \"\n**Explanation:** lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is  \"aaaa \". \n\n",
                "**Example 3:**\n\n**Input:** lcp = \\[\\[4,3,2,1\\],\\[3,3,2,1\\],\\[2,2,2,1\\],\\[1,1,1,3\\]\\]\n**Output:**  \" \"\n**Explanation:** lcp\\[3\\]\\[3\\] cannot be equal to 3 since word\\[3,...,3\\] consists of only a single letter; Thus, no answer exists."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n ==` `lcp.length ==` `lcp[i].length` `<= 1000`\n*   `0 <= lcp[i][j] <= n`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "String",
            "Dynamic Programming",
            "Greedy",
            "Union Find",
            "Matrix"
        ],
        "example": [
            {
                "input": "[[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]",
                "output": "\"abab\""
            },
            {
                "input": "[[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]",
                "output": "\"aaaa\""
            },
            {
                "input": "[[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]",
                "output": "\"\""
            }
        ],
        "java": "\n    ```java\npublic String smallestWordForLCP(int[][] lcp) {\n    int n = lcp.length;\n    char[] word = new char[n];\n    Arrays.fill(word, 'a');\n    for (int i = 1; i < n; ++i)\n        for (int j = 1; j < n; ++j) {\n            if (lcp[i][j] > Math.min(lcp[i - 1][j], lcp[i][j - 1])) {\n                word[i + lcp[i][j] - 1] = (char) Math.max(word[i + lcp[i][j] - 1], word[i - 1] + 1);\n            } else if (lcp[i][j] < Math.min(lcp[i - 1][j], lcp[i][j - 1])) {\n                return \"\";\n            }\n        }\n    return new String(word);\n}\n```\n    \n    The algorithm loops through the `lcp` matrix, checking for each element if it is greater or less than the minimum of its top and left neighbors. If greater, it updates the corresponding character in the `word` array or string by taking the maximum of its current value and the previous character increased by 1. If the element is less than the minimum of its top and left neighbors, we return empty string because it's an invalid `lcp` matrix.\n\nAfter the loop, the function returns the word as a string. The algorithm has a time complexity of O(n^2) and space complexity of O(n).\n    ",
        "python": "\n    ```python\ndef smallestWordForLCP(lcp):\n    n = len(lcp)\n    word = ['a'] * n\n    for i in range(1, n):\n        for j in range(1, n):\n            if lcp[i][j] > min(lcp[i - 1][j], lcp[i][j - 1]):\n                word[i + lcp[i][j] - 1] = max(word[i + lcp[i][j] - 1], chr(ord(word[i - 1]) + 1))\n            elif lcp[i][j] < min(lcp[i - 1][j], lcp[i][j - 1]):\n                return \"\"\n    return \"\".join(word)\n```\n    \n    The algorithm loops through the `lcp` matrix, checking for each element if it is greater or less than the minimum of its top and left neighbors. If greater, it updates the corresponding character in the `word` array or string by taking the maximum of its current value and the previous character increased by 1. If the element is less than the minimum of its top and left neighbors, we return empty string because it's an invalid `lcp` matrix.\n\nAfter the loop, the function returns the word as a string. The algorithm has a time complexity of O(n^2) and space complexity of O(n).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string smallestWordForLCP(std::vector<std::vector<int>>& lcp) {\n    int n = lcp.size();\n    std::string word(n, 'a');\n    for (int i = 1; i < n; ++i)\n        for (int j = 1; j < n; ++j) {\n            if (lcp[i][j] > std::min(lcp[i - 1][j], lcp[i][j - 1])) {\n                word[i + lcp[i][j] - 1] = std::max(word[i + lcp[i][j] - 1], (char) (word[i - 1] + 1));\n            } else if (lcp[i][j] < std::min(lcp[i - 1][j], lcp[i][j - 1])) {\n                return \"\";\n            }\n        }\n    return word;\n}\n```\n    \n    The algorithm loops through the `lcp` matrix, checking for each element if it is greater or less than the minimum of its top and left neighbors. If greater, it updates the corresponding character in the `word` array or string by taking the maximum of its current value and the previous character increased by 1. If the element is less than the minimum of its top and left neighbors, we return empty string because it's an invalid `lcp` matrix.\n\nAfter the loop, the function returns the word as a string. The algorithm has a time complexity of O(n^2) and space complexity of O(n).\n    ",
        "js": "\n    ```javascript\nfunction smallestWordForLCP(lcp) {\n    let n = lcp.length;\n    let word = Array(n).fill('a');\n    for (let i = 1; i < n; ++i)\n        for (let j = 1; j < n; ++j) {\n            if (lcp[i][j] > Math.min(lcp[i - 1][j], lcp[i][j - 1])) {\n                word[i + lcp[i][j] - 1] = String.fromCharCode(Math.max(\n                    word[i + lcp[i][j] - 1].charCodeAt(0),\n                    word[i - 1].charCodeAt(0) + 1\n                ));\n            } else if (lcp[i][j] < Math.min(lcp[i - 1][j], lcp[i][j - 1])) {\n                return \"\";\n            }\n        }\n    return word.join('');\n}\n```\n    \n    The algorithm loops through the `lcp` matrix, checking for each element if it is greater or less than the minimum of its top and left neighbors. If greater, it updates the corresponding character in the `word` array or string by taking the maximum of its current value and the previous character increased by 1. If the element is less than the minimum of its top and left neighbors, we return empty string because it's an invalid `lcp` matrix.\n\nAfter the loop, the function returns the word as a string. The algorithm has a time complexity of O(n^2) and space complexity of O(n).\n    "
    },
    {
        "id": 445,
        "title": "Minimum Time to Visit a Cell In a Grid",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\nReturn _the **minimum** time required in which you can visit the bottom-right cell of the matrix_. If you cannot visit the bottom-right cell, then return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,3,2\\],\\[5,1,2,5\\],\\[4,3,8,6\\]\\]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid\\[0\\]\\[1\\] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid\\[1\\]\\[3\\] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid\\[2\\]\\[3\\] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[0,2,4\\],\\[3,2,1\\],\\[1,0,4\\]\\]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell."
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `grid[0][0] == 0`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Graph",
            "Heap (Priority Queue)",
            "Matrix",
            "Shortest Path"
        ],
        "example": [
            {
                "input": "[[0,1,3,2],[5,1,2,5],[4,3,8,6]]",
                "output": "7"
            },
            {
                "input": "[[0,2,4],[3,2,1],[1,0,4]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minTime(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] visited = new int[m][n];\n\n        for (int[] row : visited) {\n            Arrays.fill(row, 1000000);\n        }\n\n        final int[] dx = {-1, 0, 1, 0};\n        final int[] dy = {0, 1, 0, -1};\n\n        visited[0][0] = 0;\n\n        Queue<int[]> q = new LinkedList<>();\n        q.add(new int[]{0, 0});\n\n        while (!q.isEmpty()) {\n            int x = q.peek()[0];\n            int y = q.peek()[1];\n            q.poll();\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    int t = Math.max(grid[nx][ny], visited[x][y] + 1);\n                    if (visited[nx][ny] > t) {\n                        visited[nx][ny] = t;\n                        q.add(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n\n        return visited[m - 1][n - 1] == 1000000 ? -1 : visited[m - 1][n - 1];\n    }\n}\n```\n    \n    We will perform a Breadth-First Search (BFS) to find the shortest path to the bottom-right cell.\n1. We initialize a 'visited' grid with the same dimensions as the original grid, filling it with a high value, 1000000. We set the time of the top-left cell (0, 0) in the 'visited' grid to be 0.\n2. Initialize a queue with the top-left cell, and then loop until the queue is empty.\n3. Inside the loop, dequeue the current cell, and for each of the neighboring cells (up, down, left, right), calculate the time at which that neighbor can be visited, as the maximum of its value `grid[nx][ny]` and the time of the current cell `visited[x][y]` plus one. If this time is less than the value currently in the `visited` grid for that neighbor, update its time in the `visited` grid, and enqueue the neighbor.\n4. When the loop is complete, check the value of the bottom-right cell in the 'visited' grid. If it's the initial high value, return -1 since it means there's no valid path. Otherwise, return its value as the minimum time to visit the bottom-right cell.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef minTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    visited = [[1000000] * n for _ in range(m)]\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    visited[0][0] = 0\n\n    q = deque([(0, 0)])\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n\n            if 0 <= nx < m and 0 <= ny < n:\n                t = max(grid[nx][ny], visited[x][y] + 1)\n                if visited[nx][ny] > t:\n                    visited[nx][ny] = t\n                    q.append((nx, ny))\n\n    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1\n```\n    \n    We will perform a Breadth-First Search (BFS) to find the shortest path to the bottom-right cell.\n1. We initialize a 'visited' grid with the same dimensions as the original grid, filling it with a high value, 1000000. We set the time of the top-left cell (0, 0) in the 'visited' grid to be 0.\n2. Initialize a queue with the top-left cell, and then loop until the queue is empty.\n3. Inside the loop, dequeue the current cell, and for each of the neighboring cells (up, down, left, right), calculate the time at which that neighbor can be visited, as the maximum of its value `grid[nx][ny]` and the time of the current cell `visited[x][y]` plus one. If this time is less than the value currently in the `visited` grid for that neighbor, update its time in the `visited` grid, and enqueue the neighbor.\n4. When the loop is complete, check the value of the bottom-right cell in the 'visited' grid. If it's the initial high value, return -1 since it means there's no valid path. Otherwise, return its value as the minimum time to visit the bottom-right cell.\n    ",
        "c++": "\n    ```cpp\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint minTime(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    vector<vector<int>> visited(m, vector<int>(n, 1000000));\n\n    const int dx[] = {-1, 0, 1, 0};\n    const int dy[] = {0, 1, 0, -1};\n\n    visited[0][0] = 0;\n\n    queue<pair<int, int>> q;\n    q.push({0, 0});\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                int t = max(grid[nx][ny], visited[x][y] + 1);\n                if (visited[nx][ny] > t) {\n                    visited[nx][ny] = t;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    return visited[m - 1][n - 1] == 1000000 ? -1 : visited[m - 1][n - 1];\n}\n```\n    \n    We will perform a Breadth-First Search (BFS) to find the shortest path to the bottom-right cell.\n1. We initialize a 'visited' grid with the same dimensions as the original grid, filling it with a high value, 1000000. We set the time of the top-left cell (0, 0) in the 'visited' grid to be 0.\n2. Initialize a queue with the top-left cell, and then loop until the queue is empty.\n3. Inside the loop, dequeue the current cell, and for each of the neighboring cells (up, down, left, right), calculate the time at which that neighbor can be visited, as the maximum of its value `grid[nx][ny]` and the time of the current cell `visited[x][y]` plus one. If this time is less than the value currently in the `visited` grid for that neighbor, update its time in the `visited` grid, and enqueue the neighbor.\n4. When the loop is complete, check the value of the bottom-right cell in the 'visited' grid. If it's the initial high value, return -1 since it means there's no valid path. Otherwise, return its value as the minimum time to visit the bottom-right cell.\n    ",
        "js": "\n    ```javascript\nfunction minTime(grid) {\n    const m = grid.length, n = grid[0].length;\n    const visited = Array.from({ length: m }, () => new Array(n).fill(1000000));\n\n    const dx = [-1, 0, 1, 0];\n    const dy = [0, 1, 0, -1];\n\n    visited[0][0] = 0;\n\n    const q = [[0, 0]];\n\n    while (q.length) {\n        const [x, y] = q.shift();\n\n        for (let i = 0; i < 4; i++) {\n            const nx = x + dx[i];\n            const ny = y + dy[i];\n\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                const t = Math.max(grid[nx][ny], visited[x][y] + 1);\n                if (visited[nx][ny] > t) {\n                    visited[nx][ny] = t;\n                    q.push([nx, ny]);\n                }\n            }\n        }\n    }\n\n    return visited[m - 1][n - 1] === 1000000 ? -1 : visited[m - 1][n - 1];\n}\n```\n    \n    We will perform a Breadth-First Search (BFS) to find the shortest path to the bottom-right cell.\n1. We initialize a 'visited' grid with the same dimensions as the original grid, filling it with a high value, 1000000. We set the time of the top-left cell (0, 0) in the 'visited' grid to be 0.\n2. Initialize a queue with the top-left cell, and then loop until the queue is empty.\n3. Inside the loop, dequeue the current cell, and for each of the neighboring cells (up, down, left, right), calculate the time at which that neighbor can be visited, as the maximum of its value `grid[nx][ny]` and the time of the current cell `visited[x][y]` plus one. If this time is less than the value currently in the `visited` grid for that neighbor, update its time in the `visited` grid, and enqueue the neighbor.\n4. When the loop is complete, check the value of the bottom-right cell in the 'visited' grid. If it's the initial high value, return -1 since it means there's no valid path. Otherwise, return its value as the minimum time to visit the bottom-right cell.\n    "
    },
    {
        "id": 446,
        "title": "Count Number of Possible Root Nodes",
        "difficulty": "Hard",
        "content": {
            "problem": "Alice has an undirected tree with `n` nodes labeled from `0` to `n - 1`. The tree is represented as a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nAlice wants Bob to find the root of the tree. She allows Bob to make several **guesses** about her tree. In one guess, he does the following:\n\n*   Chooses two **distinct** integers `u` and `v` such that there exists an edge `[u, v]` in the tree.\n*   He tells Alice that `u` is the **parent** of `v` in the tree.\n\nBob's guesses are represented by a 2D integer array `guesses` where `guesses[j] = [uj, vj]` indicates Bob guessed `uj` to be the parent of `vj`.\n\nAlice being lazy, does not reply to each of Bob's guesses, but just says that **at least** `k` of his guesses are `true`.\n\nGiven the 2D integer arrays `edges`, `guesses` and the integer `k`, return _the **number of possible nodes** that can be the root of Alice's tree_. If there is no such tree, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[4,2\\]\\], guesses = \\[\\[1,3\\],\\[0,1\\],\\[1,0\\],\\[2,4\\]\\], k = 3\n**Output:** 3\n**Explanation:** \nRoot = 0, correct guesses = \\[1,3\\], \\[0,1\\], \\[2,4\\]\nRoot = 1, correct guesses = \\[1,3\\], \\[1,0\\], \\[2,4\\]\nRoot = 2, correct guesses = \\[1,3\\], \\[1,0\\], \\[2,4\\]\nRoot = 3, correct guesses = \\[1,0\\], \\[2,4\\]\nRoot = 4, correct guesses = \\[1,3\\], \\[1,0\\]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\], guesses = \\[\\[1,0\\],\\[3,4\\],\\[2,1\\],\\[3,2\\]\\], k = 1\n**Output:** 5\n**Explanation:** \nRoot = 0, correct guesses = \\[3,4\\]\nRoot = 1, correct guesses = \\[1,0\\], \\[3,4\\]\nRoot = 2, correct guesses = \\[1,0\\], \\[2,1\\], \\[3,4\\]\nRoot = 3, correct guesses = \\[1,0\\], \\[2,1\\], \\[3,2\\], \\[3,4\\]\nRoot = 4, correct guesses = \\[1,0\\], \\[2,1\\], \\[3,2\\]\nConsidering any node as root will give at least 1 correct guess."
            ],
            "constraints": "**Constraints:**\n\n*   `edges.length == n - 1`\n*   `2 <= n <= 105`\n*   `1 <= guesses.length <= 105`\n*   `0 <= ai, bi, uj, vj <= n - 1`\n*   `ai != bi`\n*   `uj != vj`\n*   `edges` represents a valid tree.\n*   `guesses[j]` is an edge of the tree.\n*   `guesses` is unique.\n*   `0 <= k <= guesses.length`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Dynamic Programming",
            "Tree",
            "Depth-First Search"
        ],
        "example": [
            {
                "input": "[[0,1],[1,2],[1,3],[4,2]],[[1,3],[0,1],[1,0],[2,4]],3",
                "output": "3"
            },
            {
                "input": "[[0,1],[1,2],[2,3],[3,4]],[[1,0],[3,4],[2,1],[3,2]],1",
                "output": "5"
            }
        ],
        "java": "\n    ```java\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic int possibleRoots(List<List<Integer>> edges, List<List<Integer>> guesses, int k) {\n    int n = edges.size() + 1;\n    int[] in_degree = new int[n];\n    Set<Integer> guess_parents = new HashSet<>();\n    \n    for (List<Integer> guess : guesses) {\n        guess_parents.add(guess.get(0));\n    }\n    \n    for (List<Integer> edge : edges) {\n        in_degree[edge.get(1)]++;\n    }\n    \n    int possible_roots = 0;\n    for (int i = 0; i < n; ++i) {\n        if (in_degree[i] == 0) {\n            if (k == 0 || guess_parents.contains(i)) {\n                possible_roots++;\n            }\n        } else if (in_degree[i] == 1 && guesses.size() - k < in_degree[i]) {\n            possible_roots++;\n        }\n    }\n    return possible_roots;\n}\n```\n    \n    1. Create a new array `in_degree` of length `n` with all values initialized to 0.\n2. Create a set `guess_parents` to store all the parents as guessed by Bob.\n3. Iterate through the guesses and add the parent nodes to `guess_parents`.\n4. Iterate through the edges and increase the in-degree count of each child node.\n5. Iterate from 0 to n-1 and check for each node `i`,\n    - If the in-degree of the node is 0 (possible root), increment the counter of possible roots if k is 0 or i is present in `guess_parents`.\n    - If the in-degree of the node is 1, increment the counter of possible roots if the number of guesses left `guesses.size() - k` is less than the in-degree of the node.\n6. Return the possible roots count.\n    ",
        "python": "\n    ```python\ndef possibleRoots(edges, guesses, k):\n    n = len(edges) + 1\n    in_degree = [0] * n\n    guess_parents = set()\n    \n    for guess in guesses:\n        guess_parents.add(guess[0])\n    \n    for edge in edges:\n        in_degree[edge[1]] += 1\n    \n    possible_roots = 0\n    for i in range(n):\n        if in_degree[i] == 0:\n            if k == 0 or i in guess_parents:\n                possible_roots += 1\n        elif in_degree[i] == 1 and len(guesses) - k < in_degree[i]:\n            possible_roots += 1\n    \n    return possible_roots\n```\n    \n    1. Create a new array `in_degree` of length `n` with all values initialized to 0.\n2. Create a set `guess_parents` to store all the parents as guessed by Bob.\n3. Iterate through the guesses and add the parent nodes to `guess_parents`.\n4. Iterate through the edges and increase the in-degree count of each child node.\n5. Iterate from 0 to n-1 and check for each node `i`,\n    - If the in-degree of the node is 0 (possible root), increment the counter of possible roots if k is 0 or i is present in `guess_parents`.\n    - If the in-degree of the node is 1, increment the counter of possible roots if the number of guesses left `guesses.size() - k` is less than the in-degree of the node.\n6. Return the possible roots count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nint possibleRoots(const std::vector<std::vector<int>>& edges, const std::vector<std::vector<int>>& guesses, int k) {\n    int n = edges.size() + 1;\n    std::vector<int> in_degree(n, 0);\n    std::unordered_set<int> guess_parents;\n    \n    for (const auto& guess : guesses) {\n        guess_parents.insert(guess[0]);\n    }\n    \n    for (const auto& edge : edges) {\n        in_degree[edge[1]]++;\n    }\n    \n    int possible_roots = 0;\n    for (int i = 0; i < n; ++i) {\n        if (in_degree[i] == 0) {\n            if (k == 0 || guess_parents.find(i) != guess_parents.end()) {\n                possible_roots++;\n            }\n        } else if (in_degree[i] == 1 && guesses.size() - k < in_degree[i]) {\n            possible_roots++;\n        }\n    }\n    return possible_roots;\n}\n```\n    \n    1. Create a new array `in_degree` of length `n` with all values initialized to 0.\n2. Create a set `guess_parents` to store all the parents as guessed by Bob.\n3. Iterate through the guesses and add the parent nodes to `guess_parents`.\n4. Iterate through the edges and increase the in-degree count of each child node.\n5. Iterate from 0 to n-1 and check for each node `i`,\n    - If the in-degree of the node is 0 (possible root), increment the counter of possible roots if k is 0 or i is present in `guess_parents`.\n    - If the in-degree of the node is 1, increment the counter of possible roots if the number of guesses left `guesses.size() - k` is less than the in-degree of the node.\n6. Return the possible roots count.\n    ",
        "js": "\n    ```javascript\nfunction possibleRoots(edges, guesses, k) {\n    let n = edges.length + 1;\n    let in_degree = Array(n).fill(0);\n    let guess_parents = new Set();\n    \n    for (let guess of guesses) {\n        guess_parents.add(guess[0]);\n    }\n    \n    for (let edge of edges) {\n        in_degree[edge[1]]++;\n    }\n    \n    let possible_roots = 0;\n    for (let i = 0; i < n; ++i) {\n        if (in_degree[i] === 0) {\n            if (k === 0 || guess_parents.has(i)) {\n                possible_roots++;\n            }\n        } else if (in_degree[i] === 1 && guesses.length - k < in_degree[i]) {\n            possible_roots++;\n        }\n    }\n    return possible_roots;\n}\n```\n    \n    1. Create a new array `in_degree` of length `n` with all values initialized to 0.\n2. Create a set `guess_parents` to store all the parents as guessed by Bob.\n3. Iterate through the guesses and add the parent nodes to `guess_parents`.\n4. Iterate through the edges and increase the in-degree count of each child node.\n5. Iterate from 0 to n-1 and check for each node `i`,\n    - If the in-degree of the node is 0 (possible root), increment the counter of possible roots if k is 0 or i is present in `guess_parents`.\n    - If the in-degree of the node is 1, increment the counter of possible roots if the number of guesses left `guesses.size() - k` is less than the in-degree of the node.\n6. Return the possible roots count.\n    "
    },
    {
        "id": 447,
        "title": "Split the Array to Make Coprime Products",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** integer array `nums` of length `n`.\n\nA **split** at an index `i` where `0 <= i <= n - 2` is called **valid** if the product of the first `i + 1` elements and the product of the remaining elements are coprime.\n\n*   For example, if `nums = [2, 3, 3]`, then a split at the index `i = 0` is valid because `2` and `9` are coprime, while a split at the index `i = 1` is not valid because `6` and `3` are not coprime. A split at the index `i = 2` is not valid because `i == n - 1`.\n\nReturn _the smallest index_ `i` _at which the array can be split validly or_ `-1` _if there is no such split_.\n\nTwo values `val1` and `val2` are coprime if `gcd(val1, val2) == 1` where `gcd(val1, val2)` is the greatest common divisor of `val1` and `val2`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,7,8,15,3,5\\]\n**Output:** 2\n**Explanation:** The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,7,15,8,3,5\\]\n**Output:** -1\n**Explanation:** The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `1 <= nums[i] <= 106`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Hash Table",
            "Math",
            "Number Theory"
        ],
        "example": [
            {
                "input": "[4,7,8,15,3,5]",
                "output": "2"
            },
            {
                "input": "[4,7,15,8,3,5]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\npublic int findValidSplit(int[] nums) {\n    int n = nums.length;\n    int[] prefix = new int[n];\n    int[] suffix = new int[n];\n\n    prefix[0] = nums[0];\n    suffix[n - 1] = nums[n - 1];\n\n    for (int i = 1; i < n; ++i)\n        prefix[i] = prefix[i - 1] * nums[i];\n\n    for (int i = n - 2; i >= 0; --i)\n        suffix[i] = suffix[i + 1] * nums[i];\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (gcd(prefix[i], suffix[i + 1]) == 1)\n            return i;\n    }\n\n    return -1;\n}\n\nprivate int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n\n    \n    The main idea of this solution is to use two arrays - prefix (keeps product of all elements from start to current index) and suffix (keeps product of all elements from current index to end). Then, we iterate through both arrays to find the smallest index with coprime values.\n1. Create prefix and suffix arrays with initial values.\n2. Compute prefix and suffix arrays by multiplying elements in nums.\n3. Iterate from 0 to n-2 and check the gcd of the prefix[i] and suffix[i+1] for each element in the arrays.\n4. If the gcd of prefix[i] and suffix[i+1] is 1, return the index i as the smallest index with valid coprimes.\n5. If no valid index found, return -1.\n    ",
        "python": "\n    ```python\ndef find_valid_split(nums):\n    n = len(nums)\n    prefix = [0] * n\n    suffix = [0] * n\n\n    prefix[0] = nums[0]\n    suffix[-1] = nums[-1]\n\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] * nums[i]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] * nums[i]\n\n    for i in range(n - 1):\n        if gcd(prefix[i], suffix[i + 1]) == 1:\n            return i\n\n    return -1\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n```\n\n    \n    The main idea of this solution is to use two arrays - prefix (keeps product of all elements from start to current index) and suffix (keeps product of all elements from current index to end). Then, we iterate through both arrays to find the smallest index with coprime values.\n1. Create prefix and suffix arrays with initial values.\n2. Compute prefix and suffix arrays by multiplying elements in nums.\n3. Iterate from 0 to n-2 and check the gcd of the prefix[i] and suffix[i+1] for each element in the arrays.\n4. If the gcd of prefix[i] and suffix[i+1] is 1, return the index i as the smallest index with valid coprimes.\n5. If no valid index found, return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint findValidSplit(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefix(n);\n    std::vector<int> suffix(n);\n\n    prefix[0] = nums[0];\n    suffix[n - 1] = nums[n - 1];\n\n    for (int i = 1; i < n; ++i)\n        prefix[i] = prefix[i - 1] * nums[i];\n\n    for (int i = n - 2; i >= 0; --i)\n        suffix[i] = suffix[i + 1] * nums[i];\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (gcd(prefix[i], suffix[i + 1]) == 1)\n            return i;\n    }\n\n    return -1;\n}\n```\n\n    \n    The main idea of this solution is to use two arrays - prefix (keeps product of all elements from start to current index) and suffix (keeps product of all elements from current index to end). Then, we iterate through both arrays to find the smallest index with coprime values.\n1. Create prefix and suffix arrays with initial values.\n2. Compute prefix and suffix arrays by multiplying elements in nums.\n3. Iterate from 0 to n-2 and check the gcd of the prefix[i] and suffix[i+1] for each element in the arrays.\n4. If the gcd of prefix[i] and suffix[i+1] is 1, return the index i as the smallest index with valid coprimes.\n5. If no valid index found, return -1.\n    ",
        "js": "\n    ```javascript\nfunction findValidSplit(nums) {\n    let n = nums.length;\n    let prefix = new Array(n).fill(0);\n    let suffix = new Array(n).fill(0);\n\n    prefix[0] = nums[0];\n    suffix[n - 1] = nums[n - 1];\n\n    for (let i = 1; i < n; ++i)\n        prefix[i] = prefix[i - 1] * nums[i];\n\n    for (let i = n - 2; i >= 0; --i)\n        suffix[i] = suffix[i + 1] * nums[i];\n\n    for (let i = 0; i < n - 1; ++i) {\n        if (gcd(prefix[i], suffix[i + 1]) === 1)\n            return i;\n    }\n\n    return -1;\n}\n\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n```\n\n    \n    The main idea of this solution is to use two arrays - prefix (keeps product of all elements from start to current index) and suffix (keeps product of all elements from current index to end). Then, we iterate through both arrays to find the smallest index with coprime values.\n1. Create prefix and suffix arrays with initial values.\n2. Compute prefix and suffix arrays by multiplying elements in nums.\n3. Iterate from 0 to n-2 and check the gcd of the prefix[i] and suffix[i+1] for each element in the arrays.\n4. If the gcd of prefix[i] and suffix[i+1] is 1, return the index i as the smallest index with valid coprimes.\n5. If no valid index found, return -1.\n    "
    },
    {
        "id": 448,
        "title": "Number of Ways to Earn Points",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a test that has `n` types of questions. You are given an integer `target` and a **0-indexed** 2D integer array `types` where `types[i] = [counti, marksi]` indicates that there are `counti` questions of the `ith` type, and each one of them is worth `marksi` points.\n\nReturn _the number of ways you can earn **exactly**_ `target` _points in the exam_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Note** that questions of the same type are indistinguishable.\n\n*   For example, if there are `3` questions of the same type, then solving the `1st` and `2nd` questions is the same as solving the `1st` and `3rd` questions, or the `2nd` and `3rd` questions.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 6, types = \\[\\[6,1\\],\\[3,2\\],\\[2,3\\]\\]\n**Output:** 7\n**Explanation:** You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6\n\n",
                "**Example 2:**\n\n**Input:** target = 5, types = \\[\\[50,1\\],\\[50,2\\],\\[50,5\\]\\]\n**Output:** 4\n**Explanation:** You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5\n\n",
                "**Example 3:**\n\n**Input:** target = 18, types = \\[\\[6,1\\],\\[3,2\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:** You can only earn 18 points by answering all questions."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target <= 1000`\n*   `n == types.length`\n*   `1 <= n <= 50`\n*   `types[i].length == 2`\n*   `1 <= counti, marksi <= 50`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Dynamic Programming"
        ],
        "example": [
            {
                "input": "6,[[6,1],[3,2],[2,3]]",
                "output": "7"
            },
            {
                "input": "5,[[50,1],[50,2],[50,5]]",
                "output": "4"
            },
            {
                "input": "18,[[6,1],[3,2],[2,3]]",
                "output": "1"
            }
        ],
        "java": "\n    ```java\npublic int numberOfWays(int target, int[][] types) {\n    int MOD = 1000000007;\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n    for (int[] type : types) {\n        int count = type[0], marks = type[1];\n        int[] dptmp = new int[target + 1];\n        for (int i = 0; i <= target; ++i) {\n            for (int j = 0; j <= count && j * marks + i <= target; ++j) {\n                dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD;\n            }\n        }\n        dp = dptmp;\n    }\n    return dp[target];\n}\n```\n    \n    This problem can be solved using dynamic programming.\n\nWe can create a `dp` array where `dp[target]` stores the number of ways you can earn exactly `target` points. Initially, `dp` is a zero array with `dp[0]=1` because there is exactly one way to score 0 marks (not answering any question).\n\nThen, for each `types[i] = [count_i, marks_i]`, we create a temporary DP array `dptmp` initially filled with zeros, and copy the current values from the `dp` array to `dptmp`, for each combination of questions with that type.\n\nFor each type, we iterate through all possible numbers of questions of that type, and for each number, we add the number of ways to score that number of points by answering questions of that type.\n\nFinally, we update the `dp` array with the `dptmp` values and the result is stored in `dp[target]`.\n\nThe resulting time complexity is O(n * target^2), where n is the number of types of questions. \n    ",
        "python": "\n    ```python\ndef numberOfWays(target, types):\n    MOD = 10**9 + 7\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for count, marks in types:\n        dptmp = [0] * (target + 1)\n        for i in range(target + 1):\n            for j in range(count + 1):\n                if j * marks + i <= target:\n                    dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD\n        dp = dptmp\n    return dp[target]\n```\n    \n    This problem can be solved using dynamic programming.\n\nWe can create a `dp` array where `dp[target]` stores the number of ways you can earn exactly `target` points. Initially, `dp` is a zero array with `dp[0]=1` because there is exactly one way to score 0 marks (not answering any question).\n\nThen, for each `types[i] = [count_i, marks_i]`, we create a temporary DP array `dptmp` initially filled with zeros, and copy the current values from the `dp` array to `dptmp`, for each combination of questions with that type.\n\nFor each type, we iterate through all possible numbers of questions of that type, and for each number, we add the number of ways to score that number of points by answering questions of that type.\n\nFinally, we update the `dp` array with the `dptmp` values and the result is stored in `dp[target]`.\n\nThe resulting time complexity is O(n * target^2), where n is the number of types of questions. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint numberOfWays(int target, vector<vector<int>>& types) {\n    vector<int> dp(target + 1, 0);\n    dp[0] = 1;\n    for(auto &type : types) {\n        int count = type[0], marks = type[1];\n        vector<int> dptmp(target + 1, 0);\n        for(int i = 0; i <= target; ++i) {\n            for(int j = 0; j <= count && j * marks + i <= target; ++j) {\n                dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD;\n            }\n        }\n        dp = dptmp;\n    }\n    return dp[target];\n}\n```\n    \n    This problem can be solved using dynamic programming.\n\nWe can create a `dp` array where `dp[target]` stores the number of ways you can earn exactly `target` points. Initially, `dp` is a zero array with `dp[0]=1` because there is exactly one way to score 0 marks (not answering any question).\n\nThen, for each `types[i] = [count_i, marks_i]`, we create a temporary DP array `dptmp` initially filled with zeros, and copy the current values from the `dp` array to `dptmp`, for each combination of questions with that type.\n\nFor each type, we iterate through all possible numbers of questions of that type, and for each number, we add the number of ways to score that number of points by answering questions of that type.\n\nFinally, we update the `dp` array with the `dptmp` values and the result is stored in `dp[target]`.\n\nThe resulting time complexity is O(n * target^2), where n is the number of types of questions. \n    ",
        "js": "\n    ```javascript\nfunction numberOfWays(target, types) {\n    const MOD = 1e9 + 7;\n    let dp = new Array(target + 1).fill(0);\n    dp[0] = 1;\n    for (const type of types) {\n        const count = type[0];\n        const marks = type[1];\n        const dptmp = new Array(target + 1).fill(0);\n        for (let i = 0; i <= target; ++i) {\n            for (let j = 0; j <= count && j * marks + i <= target; ++j) {\n                dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD;\n            }\n        }\n        dp = dptmp;\n    }\n    return dp[target];\n}\n```\n    \n    This problem can be solved using dynamic programming.\n\nWe can create a `dp` array where `dp[target]` stores the number of ways you can earn exactly `target` points. Initially, `dp` is a zero array with `dp[0]=1` because there is exactly one way to score 0 marks (not answering any question).\n\nThen, for each `types[i] = [count_i, marks_i]`, we create a temporary DP array `dptmp` initially filled with zeros, and copy the current values from the `dp` array to `dptmp`, for each combination of questions with that type.\n\nFor each type, we iterate through all possible numbers of questions of that type, and for each number, we add the number of ways to score that number of points by answering questions of that type.\n\nFinally, we update the `dp` array with the `dptmp` values and the result is stored in `dp[target]`.\n\nThe resulting time complexity is O(n * target^2), where n is the number of types of questions. \n    "
    },
    {
        "id": 449,
        "title": "Minimum Time to Complete All Tasks",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a computer that can run an unlimited number of tasks **at the same time**. You are given a 2D integer array `tasks` where `tasks[i] = [starti, endi, durationi]` indicates that the `ith` task should run for a total of `durationi` seconds (not necessarily continuous) within the **inclusive** time range `[starti, endi]`.\n\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\n\nReturn _the minimum time during which the computer should be turned on to complete all tasks_.",
            "examples": [
                "**Example 1:**\n\n**Input:** tasks = \\[\\[2,3,1\\],\\[4,5,1\\],\\[1,5,2\\]\\]\n**Output:** 2\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 2\\].\n- The second task can be run in the inclusive time range \\[5, 5\\].\n- The third task can be run in the two inclusive time ranges \\[2, 2\\] and \\[5, 5\\].\nThe computer will be on for a total of 2 seconds.\n\n",
                "**Example 2:**\n\n**Input:** tasks = \\[\\[1,3,2\\],\\[2,5,3\\],\\[5,6,2\\]\\]\n**Output:** 4\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 3\\].\n- The second task can be run in the inclusive time ranges \\[2, 3\\] and \\[5, 5\\].\n- The third task can be run in the two inclusive time range \\[5, 6\\].\nThe computer will be on for a total of 4 seconds."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= tasks.length <= 2000`\n*   `tasks[i].length == 3`\n*   `1 <= starti, endi <= 2000`\n*   `1 <= durationi <= endi - starti + 1`",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Binary Search",
            "Stack",
            "Greedy",
            "Sorting"
        ],
        "example": [
            {
                "input": "[[2,3,1],[4,5,1],[1,5,2]]",
                "output": "2"
            },
            {
                "input": "[[1,3,2],[2,5,3],[5,6,2]]",
                "output": "4"
            }
        ],
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int minTimeOn(int[][] tasks) {\n    int[][] intervals = new int[tasks.length][];\n    for (int i = 0; i < tasks.length; i++) {\n        intervals[i] = new int[] { tasks[i][1] + 1, tasks[i][2] };\n    }\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n\n    int[] dp = new int[2001];\n    for (int[] interval : intervals) {\n        for (int i = 2000; i >= interval[0]; i--) {\n            dp[i] = Math.max(dp[i], dp[i - interval[1]] + interval[1]);\n        }\n    }\n    return dp[2000];\n}\n```\n    \n    The algorithm first converts individual tasks into a more useful form: intervals with end time +1 and duration, which are then sorted based on the end time. This preprocessing step helps identify the tasks that can be scheduled earlier, and it ensures that the optimal scheduling for each task is found.\n\nThe dynamic programming approach maintains an array `dp` where `dp[i]` stores the maximum duration of tasks which can be scheduled within the first `i` seconds.\nFor each interval `[end, duration]`, iterate through the `dp` array in reverse order from 2000 to `end`, and update each `dp[i]` value using the maximum between the current value of `dp[i]` and the value of `dp[i-duration]` plus the duration of the current task. The reverse order is necessary to iterate through the combinations of schedules to find the best sequence of tasks to fit within the given time slots.\n\nAt the end, the last element in the `dp` array represents the optimal schedule's total time, and thus the minimum time the computer should be turned on to complete all tasks.\n    ",
        "python": "\n    ```python\ndef min_time_on(tasks):\n    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])\n\n    dp = [0] * 2001\n    for interval in intervals:\n        for i in range(2000, interval[0] - 1, -1):\n            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])\n\n    return dp[-1]\n```\n    \n    The algorithm first converts individual tasks into a more useful form: intervals with end time +1 and duration, which are then sorted based on the end time. This preprocessing step helps identify the tasks that can be scheduled earlier, and it ensures that the optimal scheduling for each task is found.\n\nThe dynamic programming approach maintains an array `dp` where `dp[i]` stores the maximum duration of tasks which can be scheduled within the first `i` seconds.\nFor each interval `[end, duration]`, iterate through the `dp` array in reverse order from 2000 to `end`, and update each `dp[i]` value using the maximum between the current value of `dp[i]` and the value of `dp[i-duration]` plus the duration of the current task. The reverse order is necessary to iterate through the combinations of schedules to find the best sequence of tasks to fit within the given time slots.\n\nAt the end, the last element in the `dp` array represents the optimal schedule's total time, and thus the minimum time the computer should be turned on to complete all tasks.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint min_time_on(vector<vector<int>>& tasks) {\n    vector<vector<int>> intervals;\n    for (const auto& task : tasks) {\n        intervals.push_back({task[1] + 1, task[2]});\n    }\n    sort(intervals.begin(), intervals.end());\n\n    vector<int> dp(2001, 0);\n    for (const auto& interval : intervals) {\n        for (int i = 2000; i >= interval[0]; --i) {\n            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1]);\n        }\n    }\n    return dp.back();\n}\n```\n    \n    The algorithm first converts individual tasks into a more useful form: intervals with end time +1 and duration, which are then sorted based on the end time. This preprocessing step helps identify the tasks that can be scheduled earlier, and it ensures that the optimal scheduling for each task is found.\n\nThe dynamic programming approach maintains an array `dp` where `dp[i]` stores the maximum duration of tasks which can be scheduled within the first `i` seconds.\nFor each interval `[end, duration]`, iterate through the `dp` array in reverse order from 2000 to `end`, and update each `dp[i]` value using the maximum between the current value of `dp[i]` and the value of `dp[i-duration]` plus the duration of the current task. The reverse order is necessary to iterate through the combinations of schedules to find the best sequence of tasks to fit within the given time slots.\n\nAt the end, the last element in the `dp` array represents the optimal schedule's total time, and thus the minimum time the computer should be turned on to complete all tasks.\n    ",
        "js": "\n    ```javascript\nfunction minTimeOn(tasks) {\n    const intervals = tasks.map(task => [task[1] + 1, task[2]]);\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    const dp = new Array(2001).fill(0);\n    for (const interval of intervals) {\n        for (let i = 2000; i >= interval[0]; i--) {\n            dp[i] = Math.max(dp[i], dp[i - interval[1]] + interval[1]);\n        }\n    }\n    return dp[dp.length - 1];\n}\n```\n    \n    The algorithm first converts individual tasks into a more useful form: intervals with end time +1 and duration, which are then sorted based on the end time. This preprocessing step helps identify the tasks that can be scheduled earlier, and it ensures that the optimal scheduling for each task is found.\n\nThe dynamic programming approach maintains an array `dp` where `dp[i]` stores the maximum duration of tasks which can be scheduled within the first `i` seconds.\nFor each interval `[end, duration]`, iterate through the `dp` array in reverse order from 2000 to `end`, and update each `dp[i]` value using the maximum between the current value of `dp[i]` and the value of `dp[i-duration]` plus the duration of the current task. The reverse order is necessary to iterate through the combinations of schedules to find the best sequence of tasks to fit within the given time slots.\n\nAt the end, the last element in the `dp` array represents the optimal schedule's total time, and thus the minimum time the computer should be turned on to complete all tasks.\n    "
    },
    {
        "id": 450,
        "title": "Collect Coins in a Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.",
            "examples": [
                "**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n",
                "**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0."
            ],
            "constraints": "**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Tree",
            "Graph",
            "Topological Sort"
        ],
        "example": [
            {
                "input": "[1,0,0,0,0,1],[[0,1],[1,2],[2,3],[3,4],[4,5]]",
                "output": "2"
            },
            {
                "input": "[0,0,0,1,1,0,0,1],[[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]",
                "output": "2"
            }
        ],
        "java": "\n    ```java\nimport java.util.*;\n\npublic int minEdgesToCollectCoins(int[] coins, int[][] edges) {\n    int n = coins.length;\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adj.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adj.get(edge[0]).add(edge[1]);\n        adj.get(edge[1]).add(edge[0]);\n    }\n    return dfs(adj, coins, 0, -1)[1] / 2;\n}\n\nprivate int[] dfs(List<List<Integer>> adj, int[] coins, int node, int parent) {\n    int sum = coins[node], distance = 0;\n    for (int neighbor : adj.get(node)) {\n        if (neighbor != parent) {\n            int[] result = dfs(adj, coins, neighbor, node);\n            sum += result[0];\n            distance += 2 * result[0] + result[1];\n        }\n    }\n    return new int[] {sum, distance};\n}\n```\n\n    \n    The algorithm starts by constructing an adjacency list `adj` from the input `edges`. Then, it performs a depth-first search (DFS) from the starting vertex (0) by calling the `dfs` function.\n\nThe `dfs` function takes the adjacency list `adj`, the `coins` array, the current node `node`, and the parent node `parent` as its arguments. It returns a pair of integers: `(sum_coins, distance)`, where `sum_coins` is the total number of coins in the subtree rooted at the current node, and `distance` is the total distance required to collect all those coins.\n\nIn the `dfs` function, we iterate over all the neighbors of the current node. If the neighbor is not the parent, we recursively call `dfs` for that neighbor. For each child, we calculate the total number of coins and the total distance as we did for the parent. Then, we can update the total number of coins and the total distance as follows:\n\n1. Add the number of coins retrieved from the child to the total number of coins.\n2. Add twice the number of coins retrieved from the child plus the distance retrieved from the child to the total distance. This is because we need to go back and forth for each child.\n\nFinally, we return the total number of coins and the total distance divided by 2, as each edge is counted twice in the total distance.\n    ",
        "python": "\n    ```python\nfrom collections import defaultdict\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)\n```\n\n    \n    The algorithm starts by constructing an adjacency list `adj` from the input `edges`. Then, it performs a depth-first search (DFS) from the starting vertex (0) by calling the `dfs` function.\n\nThe `dfs` function takes the adjacency list `adj`, the `coins` array, the current node `node`, and the parent node `parent` as its arguments. It returns a pair of integers: `(sum_coins, distance)`, where `sum_coins` is the total number of coins in the subtree rooted at the current node, and `distance` is the total distance required to collect all those coins.\n\nIn the `dfs` function, we iterate over all the neighbors of the current node. If the neighbor is not the parent, we recursively call `dfs` for that neighbor. For each child, we calculate the total number of coins and the total distance as we did for the parent. Then, we can update the total number of coins and the total distance as follows:\n\n1. Add the number of coins retrieved from the child to the total number of coins.\n2. Add twice the number of coins retrieved from the child plus the distance retrieved from the child to the total distance. This is because we need to go back and forth for each child.\n\nFinally, we return the total number of coins and the total distance divided by 2, as each edge is counted twice in the total distance.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <utility>\n\nusing std::vector;\nusing std::pair;\n\npair<int, int> dfs(const vector<vector<int>>& adj, const vector<int>& coins, int node, int parent) {\n    int sum = coins[node], distance = 0;\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            auto result = dfs(adj, coins, neighbor, node);\n            sum += result.first;\n            distance += 2 * result.first + result.second;\n        }\n    }\n    return {sum, distance};\n}\n\nint minEdgesToCollectCoins(const vector<int>& coins, const vector<vector<int>>& edges) {\n    int n = coins.size();\n    vector<vector<int>> adj(n);\n    for (const auto& edge : edges) {\n        adj[edge[0]].push_back(edge[1]);\n        adj[edge[1]].push_back(edge[0]);\n    }\n    return dfs(adj, coins, 0, -1).second / 2;\n}\n```\n\n    \n    The algorithm starts by constructing an adjacency list `adj` from the input `edges`. Then, it performs a depth-first search (DFS) from the starting vertex (0) by calling the `dfs` function.\n\nThe `dfs` function takes the adjacency list `adj`, the `coins` array, the current node `node`, and the parent node `parent` as its arguments. It returns a pair of integers: `(sum_coins, distance)`, where `sum_coins` is the total number of coins in the subtree rooted at the current node, and `distance` is the total distance required to collect all those coins.\n\nIn the `dfs` function, we iterate over all the neighbors of the current node. If the neighbor is not the parent, we recursively call `dfs` for that neighbor. For each child, we calculate the total number of coins and the total distance as we did for the parent. Then, we can update the total number of coins and the total distance as follows:\n\n1. Add the number of coins retrieved from the child to the total number of coins.\n2. Add twice the number of coins retrieved from the child plus the distance retrieved from the child to the total distance. This is because we need to go back and forth for each child.\n\nFinally, we return the total number of coins and the total distance divided by 2, as each edge is counted twice in the total distance.\n    ",
        "js": "\n    ```javascript\nfunction minEdgesToCollectCoins(coins, edges) {\n    const adj = new Array(coins.length).fill(null).map(() => []);\n    for (let [a, b] of edges) {\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n    return dfs(adj, coins, 0, -1)[1] / 2;\n}\n\nfunction dfs(adj, coins, node, parent) {\n    let sum_coins = coins[node];\n    let distance = 0;\n    for (let neighbor of adj[node]) {\n        if (neighbor !== parent) {\n            let result = dfs(adj, coins, neighbor, node);\n            sum_coins += result[0];\n            distance += 2 * result[0] + result[1];\n        }\n    }\n    return [sum_coins, distance];\n}\n```\n\n    \n    The algorithm starts by constructing an adjacency list `adj` from the input `edges`. Then, it performs a depth-first search (DFS) from the starting vertex (0) by calling the `dfs` function.\n\nThe `dfs` function takes the adjacency list `adj`, the `coins` array, the current node `node`, and the parent node `parent` as its arguments. It returns a pair of integers: `(sum_coins, distance)`, where `sum_coins` is the total number of coins in the subtree rooted at the current node, and `distance` is the total distance required to collect all those coins.\n\nIn the `dfs` function, we iterate over all the neighbors of the current node. If the neighbor is not the parent, we recursively call `dfs` for that neighbor. For each child, we calculate the total number of coins and the total distance as we did for the parent. Then, we can update the total number of coins and the total distance as follows:\n\n1. Add the number of coins retrieved from the child to the total number of coins.\n2. Add twice the number of coins retrieved from the child plus the distance retrieved from the child to the total distance. This is because we need to go back and forth for each child.\n\nFinally, we return the total number of coins and the total distance divided by 2, as each edge is counted twice in the total distance.\n    "
    },
    {
        "id": 451,
        "title": "Shortest Cycle in a Graph",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a **bi-directional** graph with `n` vertices, where each vertex is labeled from `0` to `n - 1`. The edges in the graph are represented by a given 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes an edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\n\nReturn _the length of the **shortest** cycle in the graph_. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,0\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[6,3\\]\\]\n**Output:** 3\n**Explanation:** The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 \n\n",
                "**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[0,2\\]\\]\n**Output:** -1\n**Explanation:** There are no cycles in this graph."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= edges.length <= 1000`\n*   `edges[i].length == 2`\n*   `0 <= ui, vi < n`\n*   `ui != vi`\n*   There are no repeated edges.",
            "follow_up": null
        },
        "tag": [
            "Breadth-First Search",
            "Graph"
        ],
        "example": [
            {
                "input": "7,[[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]",
                "output": "3"
            },
            {
                "input": "4,[[0,1],[0,2]]",
                "output": "-1"
            }
        ],
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic int shortestCycleLength(int n, int[][] edges) {\n    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n        graph.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n    \n    int shortestCycle = n + 1;\n    for (int start = 0; start < n; ++start) {\n        int[] dist = new int[n];\n        for (int i = 0; i < n; ++i) {\n            dist[i] = n + 1;\n        }\n        dist[start] = 0;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int neigh : graph.get(cur)) {\n                if (dist[neigh] == n + 1) {\n                    dist[neigh] = dist[cur] + 1;\n                    queue.offer(neigh);\n                } else if (dist[neigh] >= dist[cur] - 1) {\n                    shortestCycle = Math.min(shortestCycle, dist[cur] + dist[neigh] + 1);\n                }\n            }\n        }\n    }\n    \n    return shortestCycle == n + 1 ? -1 : shortestCycle;\n}\n```\n    \n    The algorithm starts by creating an adjacency list to represent the input graph. Then, it applies a Breadth-First Search (BFS) traversal from each of the `n` vertices. The BFS maintains an array `dist` representing the distance from the starting vertex `start`.\n\nDuring the BFS traversal, if we encounter a node that has a greater distance than the `dist[cur] - 1`, it implies that there is a cycle in the graph. In this case, we update the shortest cycle found till now with the value `dist[cur] + dist[neigh] + 1`.\n\nOnce the traversal is completed for all the vertices, we return the shortest cycle found. If no cycle was found, we return -1.\n    ",
        "python": "\n    ```python\nfrom collections import deque\n\ndef shortest_cycle_length(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    shortest_cycle = n + 1\n    for start in range(n):\n        dist = [n + 1] * n\n        dist[start] = 0\n        queue = deque([start])\n        \n        while queue:\n            cur = queue.popleft()\n            for neigh in graph[cur]:\n                if dist[neigh] == n + 1:\n                    dist[neigh] = dist[cur] + 1\n                    queue.append(neigh)\n                elif dist[neigh] >= dist[cur] - 1:\n                    shortest_cycle = min(shortest_cycle, dist[cur] + dist[neigh] + 1)\n                    \n    return -1 if shortest_cycle == n + 1 else shortest_cycle\n```\n    \n    The algorithm starts by creating an adjacency list to represent the input graph. Then, it applies a Breadth-First Search (BFS) traversal from each of the `n` vertices. The BFS maintains an array `dist` representing the distance from the starting vertex `start`.\n\nDuring the BFS traversal, if we encounter a node that has a greater distance than the `dist[cur] - 1`, it implies that there is a cycle in the graph. In this case, we update the shortest cycle found till now with the value `dist[cur] + dist[neigh] + 1`.\n\nOnce the traversal is completed for all the vertices, we return the shortest cycle found. If no cycle was found, we return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint shortestCycleLength(int n, vector<vector<int>>& edges) {\n    vector<vector<int>> graph(n);\n    for (const vector<int>& edge : edges) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n    \n    int shortestCycle = n + 1;\n    for (int start = 0; start < n; ++start) {\n        vector<int> dist(n, n + 1);\n        dist[start] = 0;\n        queue<int> q;\n        q.push(start);\n        \n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            for (int neigh : graph[cur]) {\n                if (dist[neigh] == n + 1) {\n                    dist[neigh] = dist[cur] + 1;\n                    q.push(neigh);\n                } else if (dist[neigh] >= dist[cur] - 1) {\n                    shortestCycle = min(shortestCycle, dist[cur] + dist[neigh] + 1);\n                }\n            }\n        }\n    }\n    \n    return shortestCycle == n + 1 ? -1 : shortestCycle;\n}\n```\n    \n    The algorithm starts by creating an adjacency list to represent the input graph. Then, it applies a Breadth-First Search (BFS) traversal from each of the `n` vertices. The BFS maintains an array `dist` representing the distance from the starting vertex `start`.\n\nDuring the BFS traversal, if we encounter a node that has a greater distance than the `dist[cur] - 1`, it implies that there is a cycle in the graph. In this case, we update the shortest cycle found till now with the value `dist[cur] + dist[neigh] + 1`.\n\nOnce the traversal is completed for all the vertices, we return the shortest cycle found. If no cycle was found, we return -1.\n    ",
        "js": "\n    ```javascript\nfunction shortestCycleLength(n, edges) {\n    const graph = Array.from({ length: n }, () => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    let shortestCycle = n + 1;\n    for (let start = 0; start < n; ++start) {\n        const dist = new Array(n).fill(n + 1);\n        dist[start] = 0;\n        const queue = [start];\n\n        while (queue.length) {\n            const cur = queue.shift();\n            for (const neigh of graph[cur]) {\n                if (dist[neigh] === n + 1) {\n                    dist[neigh] = dist[cur] + 1;\n                    queue.push(neigh);\n                } else if (dist[neigh] >= dist[cur] - 1) {\n                    shortestCycle = Math.min(shortestCycle, dist[cur] + dist[neigh] + 1);\n                }\n            }\n        }\n    }\n\n    return shortestCycle === n + 1 ? -1 : shortestCycle;\n}\n```\n    \n    The algorithm starts by creating an adjacency list to represent the input graph. Then, it applies a Breadth-First Search (BFS) traversal from each of the `n` vertices. The BFS maintains an array `dist` representing the distance from the starting vertex `start`.\n\nDuring the BFS traversal, if we encounter a node that has a greater distance than the `dist[cur] - 1`, it implies that there is a cycle in the graph. In this case, we update the shortest cycle found till now with the value `dist[cur] + dist[neigh] + 1`.\n\nOnce the traversal is completed for all the vertices, we return the shortest cycle found. If no cycle was found, we return -1.\n    "
    },
    {
        "id": 452,
        "title": "Minimum Reverse Operations",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer `n` and an integer `p` in the range `[0, n - 1]`. Representing a **0-indexed** array `arr` of length `n` where all positions are set to `0`'s, except position `p` which is set to `1`.\n\nYou are also given an integer array `banned` containing some positions from the array. For the **i****th** position in `banned`, `arr[banned[i]] = 0`, and `banned[i] != p`.\n\nYou can perform **multiple** operations on `arr`. In an operation, you can choose a **subarray** with size `k` and **reverse** the subarray. However, the `1` in `arr` should never go to any of the positions in `banned`. In other words, after each operation `arr[banned[i]]` **remains** `0`.\n\n_Return an array_ `ans` _where_ _for each_ `i` _from_ `[0, n - 1]`, `ans[i]` _is the **minimum** number of reverse operations needed to bring the_ `1` _to position_ `i` _in arr_, _or_ `-1` _if it is impossible_.\n\n*   A **subarray** is a contiguous **non-empty** sequence of elements within an array.\n*   The values of `ans[i]` are independent for all `i`'s.\n*   The **reverse** of an array is an array containing the values in **reverse order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4, p = 0, banned = \\[1,2\\], k = 4\n**Output:** \\[0,-1,-1,1\\]\n**Explanation:** In this case `k = 4` so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is `0`. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is `-1`. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is `1`. \n\n",
                "**Example 2:**\n\n**Input:** n = 5, p = 0, banned = \\[2,4\\], k = 3\n**Output:** \\[0,-1,-1,-1,-1\\]\n**Explanation:** In this case the 1 is initially at position 0, so the answer for that position is `0`. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray `[0, 2]` for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions `-1`. \n\n",
                "**Example 3:**\n\n**Input:** n = 4, p = 2, banned = \\[0,1,3\\], k = 1\n**Output:** \\[-1,-1,0,-1\\]\n**Explanation:** In this case we can only perform reverse operations of size 1. So the 1 never changes its position."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `0 <= p <= n - 1`\n*   `0 <= banned.length <= n - 1`\n*   `0 <= banned[i] <= n - 1`\n*   `1 <= k <= n`\n*   `banned[i] != p`\n*   all values in `banned` are **unique**",
            "follow_up": null
        },
        "tag": [
            "Array",
            "Breadth-First Search",
            "Ordered Set"
        ],
        "example": [
            {
                "input": "4,0,[1,2],4",
                "output": "[0,-1,-1,1]"
            },
            {
                "input": "5,0,[2,4],3",
                "output": "[0,-1,-1,-1,-1]"
            },
            {
                "input": "4,2,[0,1,3],1",
                "output": "[-1,-1,0,-1]"
            }
        ],
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int[] reachPosition(int n, int p, int[] banned, int k) {\n    Set<Integer> banned_positions = new HashSet<>();\n    for (int pos : banned) {\n        banned_positions.add(pos);\n    }\n    \n    int[] ans = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n        if (banned_positions.contains(i) || i == p) {\n            ans[i] = -1;\n            continue;\n        }\n\n        int steps = 0;\n        int an = Math.abs(p - i) / k;\n        if ((Math.abs(p - i) % k == 0) && ((an & 1) == (((n - 1) & 1) ^ (k & 1)))) {\n            steps = an;\n        }\n        else {\n            steps = -1;\n        }\n\n        ans[i] = steps;\n    }\n\n    ans[p] = 0;\n    return ans;\n}\n```\n    \n    1. Create a set from the `banned` positions for faster look-ups.\n2. Initialize the `ans` array with zeros.\n3. Iterate `i` from `0` to `n-1`.\n4. If the current position `i` is in banned positions or it is equal to p, set the `ans[i]` as -1, and continue.\n5. Calculate the possible `an` value by getting the absolute difference between `p` and `i` and divide it by `k`.\n6. If the absolute difference between `p` and `i` modulo `k` is zero, and the bitwise AND of `an`, `n-1`, and `k` equals, set the `ans[i]` to the value of `an`.\n7. Otherwise, set the `ans[i]` to -1.\n8. Set `ans[p]` to 0.\n9. Return the `ans` array.\n\nThe main idea of the algorithm is to check if the current index `i` is reachable or not under the constraints of the problem. We calculate the required steps for the number `1` to reach the position `i`, and if it is an available position, we update the result accordingly. Otherwise, we keep the default value of -1 for the position. \n\nThe bitwise operations are used to calculate the parity relationship between the positions based on the constraints. If the positions are reachable, their parity should match each other with respect to the restrictions.\n\n    ",
        "python": "\n    ```python\ndef reach_position(n, p, banned, k):\n    banned_positions = set(banned)\n    ans = [0] * n\n\n    for i in range(n):\n        if i in banned_positions or i == p:\n            ans[i] = -1\n            continue\n\n        an = abs(p - i) // k\n        if abs(p - i) % k == 0 and (an & 1) == (((n - 1) & 1) ^ (k & 1)):\n            steps = an\n        else:\n            steps = -1\n\n        ans[i] = steps\n\n    ans[p] = 0\n    return ans\n```\n    \n    1. Create a set from the `banned` positions for faster look-ups.\n2. Initialize the `ans` array with zeros.\n3. Iterate `i` from `0` to `n-1`.\n4. If the current position `i` is in banned positions or it is equal to p, set the `ans[i]` as -1, and continue.\n5. Calculate the possible `an` value by getting the absolute difference between `p` and `i` and divide it by `k`.\n6. If the absolute difference between `p` and `i` modulo `k` is zero, and the bitwise AND of `an`, `n-1`, and `k` equals, set the `ans[i]` to the value of `an`.\n7. Otherwise, set the `ans[i]` to -1.\n8. Set `ans[p]` to 0.\n9. Return the `ans` array.\n\nThe main idea of the algorithm is to check if the current index `i` is reachable or not under the constraints of the problem. We calculate the required steps for the number `1` to reach the position `i`, and if it is an available position, we update the result accordingly. Otherwise, we keep the default value of -1 for the position. \n\nThe bitwise operations are used to calculate the parity relationship between the positions based on the constraints. If the positions are reachable, their parity should match each other with respect to the restrictions.\n\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<int> reachPosition(int n, int p, std::vector<int> &banned, int k) {\n    std::set<int> banned_positions(banned.begin(), banned.end());\n    std::vector<int> ans(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        if (banned_positions.find(i) != banned_positions.end() || i == p) {\n            ans[i] = -1;\n            continue;\n        }\n\n        int steps = 0;\n        int an = abs(p - i) / k;\n        if ((abs(p - i) % k == 0) && ((an & 1) == (((n - 1) & 1) ^ (k & 1)))) {\n            steps = an;\n        }\n        else {\n            steps = -1;\n        }\n\n        ans[i] = steps;\n    }\n\n    ans[p] = 0;\n    return ans;\n}\n```\n    \n    1. Create a set from the `banned` positions for faster look-ups.\n2. Initialize the `ans` array with zeros.\n3. Iterate `i` from `0` to `n-1`.\n4. If the current position `i` is in banned positions or it is equal to p, set the `ans[i]` as -1, and continue.\n5. Calculate the possible `an` value by getting the absolute difference between `p` and `i` and divide it by `k`.\n6. If the absolute difference between `p` and `i` modulo `k` is zero, and the bitwise AND of `an`, `n-1`, and `k` equals, set the `ans[i]` to the value of `an`.\n7. Otherwise, set the `ans[i]` to -1.\n8. Set `ans[p]` to 0.\n9. Return the `ans` array.\n\nThe main idea of the algorithm is to check if the current index `i` is reachable or not under the constraints of the problem. We calculate the required steps for the number `1` to reach the position `i`, and if it is an available position, we update the result accordingly. Otherwise, we keep the default value of -1 for the position. \n\nThe bitwise operations are used to calculate the parity relationship between the positions based on the constraints. If the positions are reachable, their parity should match each other with respect to the restrictions.\n\n    ",
        "js": "\n    ```javascript\nfunction reachPosition(n, p, banned, k) {\n    const banned_positions = new Set(banned);\n    const ans = Array(n).fill(0);\n\n    for (let i = 0; i < n; ++i) {\n        if (banned_positions.has(i) || i === p) {\n            ans[i] = -1;\n            continue;\n        }\n\n        let steps = 0;\n        const an = Math.abs(p - i) / k;\n        if (Math.abs(p - i) % k === 0 && (an & 1) === ((n - 1) & 1) ^ (k & 1)) {\n            steps = an;\n        } else {\n            steps = -1;\n        }\n\n        ans[i] = steps;\n    }\n\n    ans[p] = 0;\n    return ans;\n}\n```\n    \n    1. Create a set from the `banned` positions for faster look-ups.\n2. Initialize the `ans` array with zeros.\n3. Iterate `i` from `0` to `n-1`.\n4. If the current position `i` is in banned positions or it is equal to p, set the `ans[i]` as -1, and continue.\n5. Calculate the possible `an` value by getting the absolute difference between `p` and `i` and divide it by `k`.\n6. If the absolute difference between `p` and `i` modulo `k` is zero, and the bitwise AND of `an`, `n-1`, and `k` equals, set the `ans[i]` to the value of `an`.\n7. Otherwise, set the `ans[i]` to -1.\n8. Set `ans[p]` to 0.\n9. Return the `ans` array.\n\nThe main idea of the algorithm is to check if the current index `i` is reachable or not under the constraints of the problem. We calculate the required steps for the number `1` to reach the position `i`, and if it is an available position, we update the result accordingly. Otherwise, we keep the default value of -1 for the position. \n\nThe bitwise operations are used to calculate the parity relationship between the positions based on the constraints. If the positions are reachable, their parity should match each other with respect to the restrictions.\n\n    "
    }
]